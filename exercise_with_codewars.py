# -*- coding: utf-8 -*-
# Привет это kaluginpeter, сегодня порешаем задачи с Codewars. Let's do it

# Create a function that gives a personalized greeting. This function takes two parameters: name and owner.
# Use conditionals to return the proper message:
# case	             return
# name equals owner	 'Hello boss'
# otherwise	         'Hello guest'
def greet(name, owner):
    # Add code here
    if name == owner:
        return "Hello boss"
    else:
        return "Hello guest"
# A hero is on his way to the castle to complete his mission.
# However, he's been told that the castle is surrounded with a couple of powerful dragons!
# Each dragon takes 2 bullets to be defeated, our hero has no idea how many bullets he should carry..
# Assuming he's gonna grab a specific given number of bullets and move forward to fight another specific
# given number of dragons, will he survive?
# Return True if yes, False otherwise :)
def hero(bullets, dragons):
    if bullets // dragons == 2:
        return True
    elif bullets and dragons == 0:
            return True
    else:
        return False

# Create a function that takes an integer as an argument and returns "Even" for even numbers or "Odd" for odd numbers.
def even_or_odd(number):
    if number % 2 == 0:
        return 'Even'
    else:
        return 'Odd'

# Write a program that finds the summation of every number from 1 to num.
# The number will always be a positive integer greater than 0.
# For example:
# summation(2) -> 3
# 1 + 2
# summation(8) -> 36
# 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8
def summation(num):
    count = 0
    for i in range(num+1):
        count += i
    return count

# Given a string, you have to return a string in which each character (case-sensitive) is repeated once.
# Examples (Input -> Output):
# * "String"      -> "SSttrriinngg"
# * "Hello World" -> "HHeelllloo  WWoorrlldd"
# * "1234!_ "     -> "11223344!!__  "
def double_char(s):
    double = 2
    return ''.join([char*double for char in s])

# Upd: Hello it's again kaluginpeter. Today we make some tasks on Codewars
# Given an array of integers, return a new array with each value doubled.
# For example:
# [1, 2, 3] --> [2, 4, 6]
def maps(a):
    double_a = [i*2 for i in a]
    return double_a

# Write a function that takes an array of numbers and returns the sum of the numbers.
# The numbers can be negative or non-integer. If the array does not contain any numbers then you should return 0.
# Examples
# Input: [1, 5.2, 4, 0, -1]
# Output: 9.2
# Input: []
# Output: 0
def sum_array(a):
    return sum(a)
# Хотя задачи носят решение короткого характера, думал я над ними довольно долго

# Your task is to create a function that does four basic mathematical operations.
# The function should take three arguments - operation(string/char), value1(number), value2(number).
# The function should return result of numbers after applying the chosen operation.
def basic_op(operator, value1, value2):
    if operator == '+':
        return value1 + value2
    elif operator == '-':
        return value1 - value2
    elif operator == '*':
        return value1 * value2
    elif operator == '/':
        return value1 / value2

# Write a function which converts the input string to uppercase.
def make_upper_case(s):
    return s.upper()

# Build a function that returns an array of integers from n to 1 where n>0.
# Example : n=5 --> [5,4,3,2,1]
def reverse_seq(n):
    numbers = list(range(n, 0, -1))
    return numbers

# Upd: Hello its kaluginpeter, continue make tasks on codewars
# Complete the function that accepts a string parameter, and reverses each word in the string.
# All spaces in the string should be retained.
# Examples:
# "This is an example!" ==> "sihT si na !elpmaxe"
# "double  spaces"      ==> "elbuod  secaps"
def reverse_words(text):
    return ' '.join([x[::-1] for x in text.split(' ')])

# We need a function that can transform a string into a number. What ways of achieving this do you know?
def string_to_number(s):
    return (int(s))

# In this simple assignment you are given a number and have to make it negative.
# But maybe the number is already negative?
# Examples
# make_negative(1);  # return -1
# make_negative(-5); # return -5
# make_negative(0);  # return 0
def make_negative( number ):
    return -abs(number)

# Clock shows h hours, m minutes and s seconds after midnight.
# Your task is to write a function which returns the time since midnight in milliseconds.
def past(h, m, s):
    hour = h * 60 *60 *1000
    min = m * 60 * 1000
    sec = s * 1000
    all = hour + min + sec
    return all

# Write function bmi that calculates body mass index.
# if bmi <= 18.5 return "Underweight"
# if bmi <= 25.0 return "Normal"
# if bmi <= 30.0 return "Overweight"
# if bmi > 30 return "Obese"
def bmi(weight, height):
    bmi_m = weight / height ** 2
    if bmi_m <= 18.5:
        return "Underweight"
    elif bmi_m <= 25.0:
        return "Normal"
    elif bmi_m <= 30.0:
        return "Overweight"
    elif bmi_m > 30:
        return "Obese"

# You get an array of numbers, return the sum of all of the positives ones.
def positive_sum(arr):
    # Your code here
    count = 0
    for i in arr:
        if i > 0:
            count += i
    return count

# This kata is about multiplying a given number by eight if it is an even number and by nine otherwise.
def simple_multiplication(number) :
    if number % 2 == 0:
        return number * 8
    else:
        return number * 9

# Return the number (count) of vowels in the given string.
# We will consider a, e, i, o, u as vowels for this Kata (but not y).
# The input string will only consist of lower case letters and/or spaces.
def get_count(sentence):
    gl = ['a', 'e', 'i', 'o', 'u']
    count = 0
    for x in sentence:
        if x in gl:
             count += 1
    return count

# Given an array of integers.
# Return an array, where the first element is the count of positives numbers
# and the second element is sum of negative numbers. 0 is neither positive nor negative.
# If the input is an empty array or is null, return an empty array.
def count_positives_sum_negatives(arr):
    count = 0
    count1 = 0
    if not arr:
        return arr
    else:
        for i in arr:
            if i > 0:
                count += 1
            elif i < 0:
                count1+= i
        return [count, count1]

# Write a function to convert a name into initials. This kata strictly takes two words with one space in between them.
# The output should be two capital letters with a dot separating them.
# It should look like this:
# Sam Harris => S.H
def abbrev_name(name):
    return ('.'.join([e[0] for e in name.split()]).upper())

# Нужно написать каждое слово с большой буквы, но проблема здесь в апострофах
def to_jaden_case(string):
    return " ".join(w.capitalize() for w in string.split())

# Given a random non-negative number, you have to return the digits of this number within an array in reverse order.
def digitize(n):
    sec_a = [int(a) for a in str(n)]
    return list(reversed(sec_a))

# Write a function that accepts an integer n and a string s as parameters,
# and returns a string of s repeated exactly n times.
def repeat_str(repeat, string):
    return string * repeat

# Nathan loves cycling.
# Because Nathan knows it is important to stay hydrated, he drinks 0.5 litres of water per hour of cycling.
# You get given the time in hours and you need to return the number of litres Nathan will drink,
# rounded to the smallest value.
import math
def litres(time):
    count = time / 2
    return math.floor(count)

# Given a list of integers, determine whether the sum of its elements is odd or even.
# Give your answer as a string matching "odd" or "even".
# If the input array is empty consider it as: [0] (array with a zero).
def odd_or_even(arr):
    if arr == 0:
        return 'even'
    elif sum(arr) % 2 == 0:
        return 'even'
    elif sum(arr) % 2 != 0:
        return 'odd'

# Given an array of integers your solution should find the smallest integer.
# В этой задаче у меня получилось прибегнуть к хитрости
def find_smallest_int(arr):
    return min(arr)

# There is a bus moving in the city, and it takes and drop some people in each bus stop.
# You are provided with a list (or array) of integer pairs.
# Elements of each pair represent number of people get into bus (The first item)
# and number of people get off the bus (The second item) in a bus stop.
# Your task is to return number of people who are still in the bus after the last bus station (after the last array).
# Even though it is the last bus stop,
# the bus is not empty and some people are still in the bus, and they are probably sleeping there
def number(*bus_stops):
    count = 0
    for stations in bus_stops:
        for add, leave in stations:
            count += add - leave
    return count

# In this kata you will create a function that takes a list of non-negative integers
# and strings and returns a new list with the strings filtered out.
def filter_list(l):
    new_list = [elem for elem in l if isinstance(elem, (int))]
    return new_list

# You ask a small girl,"How old are you?" She always says, "x years old",
# where x is a random number between 0 and 9.
# Write a program that returns the girl's age (0-9) as an integer.
# Assume the test input string is always a valid string.
# For example, the test input may be "1 year old" or "5 years old".
# The first character in the string is always a number.
def get_age(age):
    return int(age[0])

# Create a function that returns the sum of the two lowest positive numbers
# given an array of minimum 4 positive integers. No floats or non-positive integers will be passed.
def sum_two_smallest_numbers(numbers):
    first = min(numbers)
    second = sorted(numbers)[1]
    all = first + second
    return all

# You are given an odd-length array of integers, in which all of them are the same, except for one single number.
# Complete the method which accepts such an array, and returns that single different number.
def stray(arr):
    for i in arr:
        if arr.count(i)==1:
            elem = i
    return elem

# Your task is to find the first element of an array that is not consecutive.
# By not consecutive we mean not exactly 1 larger than the previous element of the array.
def first_non_consecutive(arr):
    for i, j in enumerate(arr, arr[0]):
        if i!=j:
            return j

# Complete the method that takes a boolean value and return a "Yes" string for true, or a "No" string for false.
def bool_to_word(boolean):
    if boolean:
        return 'Yes'
    else:
        return 'No'

# Complete the solution so that the function will break up camel casing, using a space between words.
def solution(s):
    return ''.join(' ' + char if char.isupper() else char.strip() for char in s).strip()

# We need a function that can transform a number (integer) into a string.
def number_to_string(num):
    return str(num)

# Check to see if a string has the same amount of 'x's and 'o's.
# The method must return a boolean and be case insensitive. The string can contain any char.
def xo(s):
    s = s.lower()
    word1 = s.count('x')
    word2 = s.count('o')
    if word1 == word2:
        return True
    else:
        return False

# Write a function that will return the count of distinct case-insensitive alphabetic characters
# and numeric digits that occur more than once in the input string.
# The input string can be assumed to contain only alphabets (both uppercase and lowercase) and numeric digits.
def duplicate_count(text):
    text = text.lower()
    count = 0
    for x in set(text):
        if text.count(x) > 1:
            count += 1
    return count

# Write a function that returns both the minimum and maximum number of the given list/array.
def min_max(lst):
    return [min(lst), max(lst)]

# Write a function findNeedle() that takes an array full of junk but containing one "needle"
# After your function finds the needle it should return a message (as a string) that says:
# "found the needle at position " plus the index it found the needle
def find_needle(haystack):
    if 'needle' in haystack: return(f"found the needle at position {haystack.index('needle')}")

# After a hard quarter in the office you decide to get some rest on a vacation.
# So you will book a flight for you and your girlfriend and try to leave all the mess behind you.
# You will need a rental car in order for you to get around in your vacation.
# The manager of the car rental makes you some good offers.
# Every day you rent the car costs $40. If you rent the car for 7 or more days, you get $50 off your total.
# Alternatively, if you rent the car for 3 or more days, you get $20 off your total.
# Write a code that gives out the total amount for different days(d).
def rental_car_cost(d):
    cost = 40
    if d <4:
        return d * cost
    elif 4 <= d < 7:
        return d * cost - 20
    elif d >= 7:
        return d * cost - 50

# The cockroach is one of the fastest insects.
# Write a function which takes its speed in km per hour and returns it in cm per second, rounded down to the integer.
import math
def cockroach_speed(s):
    distance = (s * 1000 * 100) / 60 / 60
    return math.floor(distance)

# ATM machines allow 4 or 6 digit PIN codes
# and PIN codes cannot contain anything but exactly 4 digits or exactly 6 digits.
# If the function is passed a valid PIN string, return true, else return false.
def validate_pin(pin):
    if (len(pin) == 4 or len(pin) == 6) and pin.isdigit():
        return True
    else:
        return False

# Take an array and remove every second element from the array.
# Always keep the first element and start removing with the next element.
def remove_every_other(my_list):
    del my_list[1::2]
    return my_list

# Write a program where Alex can input (n) how many times the hoop goes round
# and it will return him an encouraging message :)
# If Alex gets 10 or more hoops, return the string "Great, now move on to tricks".
# If he doesn't get 10 hoops, return the string "Keep at it until you get it".
def hoop_count(n):
    if n < 10:
        return "Keep at it until you get it"
    else:
        return "Great, now move on to tricks"

# There was a test in your class and you passed it. Congratulations!
# But you're an ambitious person. You want to know if you're better than the average student in your class.
# You receive an array with your peers' test scores. Now calculate the average and compare your score!
# Return True if you're better, else False!
from statistics import mean
def better_than_average(class_points, your_points):
    class_points.insert(0, your_points)
    avr = mean(class_points)
    if your_points > avr:
        return True
    else:
        return False

# You're writing code to control your town's traffic lights.
# You need a function to handle each change from green, to yellow, to red, and then to green again.
# Complete the function that takes a string as an argument representing the current
# state of the light and returns a string representing the state the light should change to.
def update_light(current):
    if current == 'green':
        return 'yellow'
    elif current == 'yellow':
        return 'red'
    elif current == 'red':
        return 'green'

# Write a function named setAlarm which receives two parameters. The first parameter, employed,
# is true whenever you are employed and the second parameter, vacation is true whenever you are on vacation.
# The function should return true if you are employed and not on vacation
# (because these are the circumstances under which you need to set an alarm). It should return false otherwise.
def set_alarm(employed, vacation):
    if (bool(employed) == True) and (bool(vacation) == False):
        return True
    else:
        return False

# Given a month as an integer from 1 to 12, return to which quarter of the year it belongs as an integer number.
def quarter_of(month):
    first = [1, 2, 3]
    second = [4, 5, 6]
    third = [7, 8, 9]
    fourth = [10, 11, 12]
    if month in first:
        return 1
    elif month in second:
        return 2
    elif month in third:
        return 3
    elif month in fourth:
        return 4

# It's pretty straightforward.
#  Your goal is to create a function that removes the first and last characters of a string.
#  You're given one parameter, the original string.
#  You don't have to worry with strings with less than two characters.
def remove_char(s):
    return s[1:-1]

# Write function RemoveExclamationMarks which removes all exclamation marks from a given string.
def remove_exclamation_marks(s):
    return ''.join(word for word in s if word not in '!')

# Very simple, given an integer or a floating-point number, find its opposite.
def opposite(number):
    return number * -1

# You will be given an array a and a value x.
# All you need to do is check whether the provided array contains the value
# Array can contain numbers or strings. X can be either.
# Return true if the array contains the value, false if not.
def check(seq, elem):
    return elem in seq

# Create a function which answers the question "Are you playing banjo?".
# If your name starts with the letter "R" or lower case "r", you are playing banjo!
def are_you_playing_banjo(name):
    n_lst = ['r', 'R']
    if name[0] in n_lst:
        return name + ' plays banjo'
    else:
        return name + ' does not play banjo'

# Count the number of divisors of a positive integer n.
def divisors(n):
    count = 0
    for i in range(1, n+1):
        if n % i == 0:
            count+=1
    return count

# Create a function that accepts 2 string arguments
# and returns an integer of the count of occurrences the 2nd argument is found in the first one.
def str_count(strng, letter):
    return strng.count(letter)

# A pangram is a sentence that contains every single letter of the alphabet at least once.
# For example, the sentence "The quick brown fox jumps over the lazy dog" is a pangram,
# because it uses the letters A-Z at least once (case is irrelevant).
# Given a string, detect whether or not it is a pangram.
# Return True if it is, False if not. Ignore numbers and punctuation.
def is_pangram(s):
    s = s.lower()
    count = 0
    list = 'abcdefghijklmnopqrstuvwxyz'
    pangram = set(s) & set(list)
    return len(pangram) == len(list)

# Complete the function so that it finds the average of the three scores passed to it
# and returns the letter value associated with that grade.
def get_grade(s1, s2, s3):
    avr = (s1 + s2 +s3) / 3
    if 90 <= avr <= 100:
        return 'A'
    elif 80 <= avr < 90:
        return 'B'
    elif 70 <= avr < 80:
        return 'C'
    elif 60 <= avr < 70:
        return 'D'
    else:
        return 'F'

# You are going to be given a word.
# Your job is to return the middle character of the word.
# If the word's length is odd, return the middle character.
# If the word's length is even, return the middle 2 characters.
def get_middle(s):
    if len(s) % 2:
        index = int(len(s) / 2)
        return s[index]
    elif len(s) % 2 == 0:
        x = len(s) // 2
        y = len(s) // 2 - 1
        return (f'{s[y]}{s[x]}')

# Your classmates asked you to copy some paperwork for them.
# You know that there are 'n' classmates and the paperwork has 'm' pages.
# Your task is to calculate how many blank pages do you need. If n < 0 or m < 0 return 0.
def paperwork(n, m):
    if n <= 0 or m <= 0:
        return 0
    else:
        return n * m

# Think of a way to store the languages as a database (eg an object).
# The languages are listed below so you can copy and paste!
# Write a 'welcome' function that takes a parameter 'language' (always a string),
# and returns a greeting - if you have it in your database.
# It should default to English if the language is not in the database, or in the event of an invalid input.
def greet(language):
    base = {'english': 'Welcome',
    'czech': 'Vitejte',
    'danish': 'Velkomst',
    'dutch': 'Welkom',
    'estonian': 'Tere tulemast',
    'finnish': 'Tervetuloa',
    'flemish': 'Welgekomen',
    'french': 'Bienvenue',
    'german': 'Willkommen',
    'irish': 'Failte',
    'italian': 'Benvenuto',
    'latvian': 'Gaidits',
    'lithuanian': 'Laukiamas',
    'polish': 'Witamy',
    'spanish': 'Bienvenido',
    'swedish': 'Valkommen',
    'welsh': 'Croeso'}
    if language in base:
        return base[language]
    else:
        return 'Welcome'

# When provided with a number between 0-9, return it in words.
def switch_it_up(number):
    numbers = {
        0: 'Zero',
        1: 'One',
        2: 'Two',
        3: 'Three',
        4: 'Four',
        5: 'Five',
        6: 'Six',
        7: 'Seven',
        8: 'Eight',
        9: 'Nine',
    }
    return numbers[number]

# Simple, remove the spaces from the string, then return the resultant string.
def no_space(x):
    return x.replace(' ' ,'')

# There is an array with some numbers. All numbers are equal except for one. Try to find it!
def find_uniq(arr):
    found = set()
    found_again = set()

    for a in arr:
        if a in found_again:
            continue
        if a in found:
            found.remove(a)
            found_again.add(a)
        else:
            found.add(a)
    res = list(found)
    return (res[0])

# In this simple exercise, you will create a program that will take two lists of integers, a and b.
# Each list will consist of 3 positive integers above 0, representing the dimensions of cuboids a and b.
# You must find the difference of the cuboids' volumes regardless of which is bigger.
def find_difference(a, b):
    q_a = (a[0] * a[1]) * a[2]
    q_b = (b[0] * b[1]) * b[2]
    return abs(q_a - q_b)

# Given a year, return the century it is in.
import math
def century(year):
    return (math.ceil(year / 100))

# Complete the square sum function so that it squares each number passed into it and then sums the results together.
def square_sum(numbers):
    return sum([integer*integer for integer in numbers])

# Make a program that filters a list of strings and returns a list with only your friends name in it.
# If a name has exactly 4 letters in it, you can be sure that it has to be a friend of yours!
# Otherwise, you can be sure he's not...
def friend(x):
    true_friends = []
    for name in x:
        if len(name) == 4 and name.isalpha():
            true_friends.append(name)
        else:
            pass
    return true_friends

# Create a method to see whether the string is ALL CAPS. UPD: isupper() not worked with special simbols
def is_uppercase(inp):
    special = ['$%&', '+%@']
    if inp.isupper():
        return True
    elif inp in special:
        return True
    else:
        return False

# Write a function which calculates the average of the numbers in a given list.
def find_average(numbers):
    return sum(numbers) / len(numbers)

# You have to write a function that accepts three parameters:
# If there is enough space, return 0, and if there isn't, return the number of passengers he can't take.
def enough(cap, on, wait):
    if on + wait < cap:
        return 0
    else:
        return abs(cap - (on + wait))

# I got them at the same time as kitten/puppy. That was humanYears years ago.
# Return their respective ages now as [humanYears,catYears,dogYears]
def human_years_cat_years_dog_years(human_years):
    cat_years = 0
    dog_years = 0
    if human_years == 1:
        return [human_years, cat_years + 15, dog_years + 15]
    elif human_years == 2:
        return [human_years, cat_years + 15 + 9, dog_years + 15 + 9]
    elif human_years > 2:
        cat_years = 24
        dog_years = 24
        for i in range(human_years-2):
            cat_years+=4
            dog_years+=5
        return [human_years, cat_years, dog_years]

# Implement the function unique_in_order which takes as argument a sequence
# and returns a list of items without any elements with the same value next to each other
# and preserving the original order of elements.
def unique_in_order(iterable):
    new = []
    if not iterable:
        return []
    for i in range(len(iterable)-1):
        if iterable[i] != iterable[i + 1]:
            new.append(iterable[i])
    new.append(iterable[-1])
    return new

# Complete the findNextSquare method that finds the next integral perfect square after the one passed as a parameter.
# Recall that an integral perfect square is an integer n such that sqrt(n) is also an integer.
# If the parameter is itself not a perfect square then -1 should be returned.
# You may assume the parameter is non-negative.
def find_next_square(sq):
    perfect_sq = sq ** .5
    if perfect_sq.is_integer():
        return (perfect_sq + 1) ** 2
    else:
        return -1

# Complete the function that takes a non-negative integer n as input,
# and returns a list of all the powers of 2 with the exponent ranging from 0 to n ( inclusive ).
def powers_of_two(n):
    list = []
    for i in range(n+1):
        list.append(2**i)
    return list

# All of the animals are having a feast! Each animal is bringing one dish.
# There is just one rule: the dish must start and end with the same letters as the animal's name.
# For example, the great blue heron is bringing garlic naan and the chickadee is bringing chocolate cake.
# Write a function feast that takes the animal's name and dish as arguments
# and returns true or false to indicate whether the beast is allowed to bring the dish to the feast.
# Assume that beast and dish are always lowercase strings, and that each has at least two letters.
# beast and dish may contain hyphens and spaces, but these will not appear at the beginning or end of the string.
# They will not contain numerals.
def feast(beast, dish):
    return beast[0] == dish[0] and beast[-1] == dish[-1]

# Your goal in this kata is to implement a difference function,
# which subtracts one list from another and returns the result.
# It should remove all values from list a, which are present in list b keeping their order.
def array_diff(a, b):
    list =[]
    for i in a:
        if i not in b:
            list.append(i)
    return list

# Complete the function that takes two integers (a, b, where a < b)
# and return an array of all integers between the input parameters, including them.
def between(a,b):
    list = []
    for i in range(a, b+1):
        list.append(i)
    return list

# Define String.prototype.toAlternatingCase
# (or a similar function/method such as to_alternating_case/toAlternatingCase/ToAlternatingCase
# in your selected language; see the initial solution for details)
# such that each lowercase letter becomes uppercase and each uppercase letter becomes lowercase.
def to_alternating_case(string):
    return ''.join([char.lower() if char.isupper() else char.upper() for char in string])

# Write a function that takes an array of strings as an argument
# and returns a sorted array containing the same strings, ordered from shortest to longest.
def sort_by_length(arr):
    arr.sort(key=len)
    return sorted(arr, key=len)

# Given an array of integers, remove the smallest value.
# Do not mutate the original array/list. If there are multiple elements with the same value,
# remove the one with a lower index. If you get an empty array/list, return an empty array/list.
def remove_smallest(numbers):
    if numbers:
        new_list = numbers.copy()
        new_list.remove(min(new_list))
        return new_list
    else:
        return numbers

# Create a function that takes 2 integers in form of a string as an input, and outputs the sum (also as a string):
def sum_str(a, b):
    if a and b:
        c = int(a) + int(b)
        return str(c)
    elif a == '' and b == '':
        return '0'
    else:
        if a:
            return a
        else:
            return b

# Сalculate how many years ago the father was twice as old as his son
# (or in how many years he will be twice as old). The answer is always greater or equal to 0,
# no matter if it was in the past or it is in the future.
def twice_as_old(dad_years_old, son_years_old):
    ages = son_years_old * 2
    return abs(ages - dad_years_old)

# Build a pyramid-shaped tower, as an array/list of strings,
# given a positive integer number of floors. A tower block is represented with "*" character.
def tower_builder(n_floors):
    list = []
    for i in range(n_floors):
        first_elem=''
        second_elem=''
        for j in range(i,n_floors-1):
            first_elem+=' '
        for k in range(2*i+1):
            second_elem+='*'
        list.append(first_elem + second_elem + first_elem)
    return list

# You are given two interior angles (in degrees) of a triangle.
# Write a function to return the 3rd.
# Note: only positive integers will be tested.
def other_angle(a,b):
    return 180 - a - b

# The maximum sum subarray problem consists in finding the maximum sum of a contiguous subsequence in an array
# or list of integers
def max_sequence(arr):
    local_max_sum = 0
    global_max = 0
    for elem in arr:
        local_max_sum = max(local_max_sum + elem, elem)
        global_max = max(local_max_sum, global_max)
    return global_max

# This time no story, no theory. The examples below show you how to write function accum:
# Examples:
# accum("abcd") -> "A-Bb-Ccc-Dddd"
def accum(s):
    word = ''
    count = -1
    for i in s:
        count+=1
        char = i.lower() * count
        word = word + (i.upper() + char + '-')
    return word[:-1]

# You are given an array with positive numbers and a non-negative number N.
# You should find the N-th power of the element in the array with the index N.
# If N is outside of the array, then return -1.
def index(array, n):
    if n <= len(array) - 1:
        return array[n]**n
    else:
        return -1

# Welcome. In this kata, you are asked to square every digit of a number and concatenate them.
def square_digits(num):
    elem = ''
    for i in str(num):
        square = int(i) ** 2
        elem += str(square)
    return int(elem)

# The goal of this exercise is to convert a string to a new string where each character
# in the new string is "(" if that character appears only once in the original string, or ")"
# if that character appears more than once in the original string.
# Ignore capitalization when determining if a character is a duplicate.
def duplicate_encode(word):
    new_word = ''
    word = word[0].lower() + word[1:].lower()
    for char in word:
        if word.count(char) > 1:
            new_word += ')'
        else:
            new_word += '('
    return new_word

# You are given the length and width of a 4-sided polygon. The polygon can either be a rectangle or a square.
# If it is a square, return its area. If it is a rectangle, return its perimeter.
def area_or_perimeter(l , w):
    return ((l + w) * 2 if l != w else l * w)

# Your job is to write a function which increments a string, to create a new string.
# If the string already ends with a number, the number should be incremented by 1.
# If the string does not end with a number. the number 1 should be appended to the new string.
def increment_string(strng):
    stripped = strng.rstrip('1234567890')
    ints = strng[len(stripped):]
    if len(ints) == 0:
        return strng + '1'
    else:
        length_word = len(ints)
        new_ints = int(ints) + 1
        new_ints = str(new_ints).zfill(length_word)
        return stripped + new_ints

# Your task is to make two functions ( max and min, or maximum and minimum, etc., depending on the language )
# that receive a list of integers as input, and return the largest and lowest number in that list, respectively.
def minimum(arr):
    return min(arr)

def maximum(arr):
    return max(arr)

# Your task is correct the errors in the digitised text. You only have to handle the following mistakes:
def correct(s):
    s = s.replace('5', 'S')
    s = s.replace('0', 'O')
    s = s.replace('1', 'I')
    return s

# Write a function that when given a URL as a string, parses out just the domain name and returns it as a string.
def domain_name(url):
    return url.split("www.")[-1].split("//")[-1].split(".")[0]

# This time we want to write calculations using functions and get the results. Let's have a look at some examples:
# seven(times(five())) # must return 35
def zero(integer = None):
    return 0 if integer is None else int(integer(0))
def one(integer = None):
    return 1 if integer is None else int(integer(1))
def two(integer = None):
    return 2 if integer is None else int(integer(2))
def three(integer = None):
    return 3 if integer is None else int(integer(3))
def four(integer = None):
    return 4 if integer is None else int(integer(4))
def five(integer = None):
    return 5 if integer is None else int(integer(5))
def six(integer = None):
    return 6 if integer is None else int(integer(6))
def seven(integer = None):
    return 7 if integer is None else int(integer(7))
def eight(integer = None):
    return 8 if integer is None else int(integer(8))
def nine(integer = None):
    return 9 if integer is None else int(integer(9))

def plus(second_integer):
    return lambda integer: integer + second_integer
def minus(second_integer):
    return lambda integer: integer - second_integer
def times(second_integer):
    return lambda integer: integer * second_integer
def divided_by(second_integer):
    return lambda integer: integer / second_integer

# An isogram is a word that has no repeating letters, consecutive or non-consecutive.
# Implement a function that determines whether a string that contains only letters is an isogram.
# Assume the empty string is an isogram. Ignore letter case.
def is_isogram(string):
    some_string = ''
    for word in string.lower():
        if word not in some_string:
            some_string += word
    print(some_string)
    if len(some_string) == len(string):
        return True
    else:
        return False

# You will be given a number and you will need to return it as a string in Expanded Form. For example:
# expanded_form(12) # Should return '10 + 2'
def expanded_form(num):
    list_of_numbers = []
    lenght = len(str(num)) - 1
    for char in str(num):
        if char != "0":
            list_of_numbers.append(char + "0" * lenght)
        lenght -= 1
    return " + ".join(list_of_numbers)

# Your task is to write a function that takes a string and return a new string with all vowels removed.
def disemvowel(string_):
    list = ['a','e','i','o','u', 'A','E','I','O','U']
    for char in string_:
        if char in list:
            string_ = string_.replace(char, '')
    return string_

# In DNA strings, symbols "A" and "T" are complements of each other,
# as "C" and "G". Your function receives one side of the DNA (string, except for Haskell);
# you need to return the other complementary side.
# DNA strand is never empty or there is no DNA at all (again, except for Haskell).
def DNA_strand(dna):
    dnk =''
    for char in dna:
        if char == 'A':
            dnk += 'T'
        elif char == 'T':
            dnk += 'A'
        elif char == 'G':
            dnk += 'C'
        elif char == 'C':
            dnk += 'G'
    return dnk

# Write a function that takes a list of strings as an argument
# and returns a filtered list containing the same elements but with the 'geese' removed.
geese = ["African", "Roman Tufted", "Toulouse", "Pilgrim", "Steinbacher"]
def goose_filter(birds):
    return [elem for elem in birds if elem not in geese]

# Complete the function/method so that it returns the url with anything after the anchor (#) removed.
def remove_url_anchor(url):
    if url.count('#'):
        index = url.index('#')
        return url[:index]
    return url

# You will be given a list of strings. You must sort it alphabetically (case-sensitive,
# and based on the ASCII values of the chars) and then return the first value.
# The returned value must be a string, and have "***" between each of its letters.
def two_sort(array):
    array.sort()
    return '***'.join(array[0])

# Bob needs a fast way to calculate the volume of a cuboid with three values:
# the length, width and height of the cuboid. Write a function to help Bob with this calculation.
def get_volume_of_cuboid(length, width, height):
    return length * width * height

# Create a function finalGrade, which calculates the final grade of a student depending on two parameters:
# a grade for the exam and a number of completed projects.
# This function should take two arguments:
# exam - grade for exam (from 0 to 100); projects - number of completed projects (from 0 and above);
def final_grade(exam, projects):
    if exam > 90 or projects > 10:
        return 100
    elif exam > 75 and projects >= 5:
        return 90
    elif exam > 50 and projects >= 2:
        return 75
    else:
        return 0

# Your task is to make a function that can take any non-negative integer as an argument
# and return it with its digits in descending order.
# Essentially, rearrange the digits to create the highest possible number.
def descending_order(num):
    order = []
    if num >= 0:
        for i in str(num):
            order.append(int(i))
    order.sort(reverse=True)
    return int(''.join(map(str, order)))

# Given an array (arr) as an argument
# complete the function countSmileys that should return the total number of smiling faces.
# Rules for a smiling face:
# Each smiley face must contain a valid pair of eyes. Eyes can be marked as : or ;
# A smiley face can have a nose but it does not have to. Valid characters for a nose are - or ~
# Every smiling face must have a smiling mouth that should be marked with either ) or D
# No additional characters are allowed except for those mentioned.
def count_smileys(arr):
    count = 0
    list = [':)', ':D', ';)', ';D', ':-)', ':~)', ';-)', ';~)', ':-D', ':~D', ';-D', ';~D']
    for elem in range(len(arr)):
        if arr[elem] in list:
            count += 1
    return count

# Given two numbers and an arithmetic operator (the name of it, as a string),
# return the result of the two numbers having that operator used on them.
# a and b will both be positive integers, and a will always be the first number in the operation,
# and b always the second.
# The four operators are "add", "subtract", "divide", "multiply".
def arithmetic(a, b, operator):
    if operator == 'add': return a + b
    elif operator == 'subtract': return a - b
    elif operator == 'multiply': return a * b
    elif operator == 'divide': return a / b

# You were camping with your friends far away from home,
# but when it's time to go back, you realize that your fuel is running out
# and the nearest pump is 50 miles away! You know that on average,
# your car runs on about 25 miles per gallon. There are 2 gallons left.
# Considering these factors, write a function that tells you if it is possible to get to the pump or not.
# Function should return true if it is possible and false if not.
def zero_fuel(distance_to_pump, mpg, fuel_left):
    return mpg * fuel_left >= distance_to_pump

# Write a function that takes an array of numbers (integers for the tests) and a target number.
# It should find two different items in the array that, when added together, give the target value.
# The indices of these items should then be returned in a tuple / list (depending on your language)
# like so: (index1, index2).
def two_sum(numbers, target):
    for i in range(len(numbers)):
        for j in range(i+1, len(numbers)):
            if numbers[i] + numbers[j] == target:
                return [i, j]

# In this little assignment you are given a string of space separated numbers,
# and have to return the highest and lowest number.
import re
def high_and_low(numbers):
    list = [int(s) for s in re.findall("[-+]?[.]?[\d]+(?:,\d\d\d)*[\.]?\d*(?:[eE][-+]?\d+)?", numbers)]
    list.sort()
    integer = ''
    return integer + str(list[-1]) + ' ' + str(list[0])

# Given a non-empty array of integers, return the result of multiplying the values together in order.
def grow(arr):
    integer = 1
    for elem in arr:
        integer *= elem
    return integer

# Complete the solution so that it reverses the string passed into it.
def solution(string):
    return string[::-1]

# Finish the solution so that it sorts the passed in array of numbers.
# If the function passes in an empty array or null/nil value then it should return an empty array.
def solution(nums):
    if not nums:
        return []
    nums.sort()
    return nums

# Given a set of numbers, return the additive inverse of each.
# Each positive becomes negatives, and the negatives become positives.
def invert(lst):
    return [i * -1 for i in lst]

# Use variables to find the sum of the goals Messi scored in 3 competitions
la_liga_goals = 43
champions_league_goals = 10
copa_del_rey_goals = 5

total_goals = la_liga_goals + champions_league_goals + copa_del_rey_goals

# The starship Enterprise has run into some problem when creating a program to greet everyone as they come aboard.
# It is your job to fix the code and get the program working again!
def say_hello(name):
    return 'Hello, ' + name

# Your task is to make function, which returns the sum of a sequence of integers.
# The sequence is defined by 3 non-negative values: begin, end, step (inclusive).
# If begin value is greater than the end, function should returns 0
def sequence_sum(begin_number, end_number, step):
    sum = 0
    for i in range(begin_number, end_number + 1, step):
        sum += i
    return sum

# Write a function that takes an array of words and smashes them together into a sentence
# and returns the sentence. You can ignore any need to sanitize words or add punctuation,
# but you should add spaces between each word.
# Be careful, there shouldn't be a space at the beginning or the end of the sentence!
def smash(words):
    return " ".join(words)

# However, sometimes, you can't arrange them into a square.
# Instead, you end up with an ordinary rectangle! Those blasted things!
# If you just had a way to know, whether you're currently working in vain…
# Wait! That's it! You just have to check if your number of building blocks is a perfect square.
import math

def is_square(n):
    if n < 0:
        return False
    return n == math.isqrt(n) ** 2

# Write a function that always returns 5
# Sounds easy right? Just bear in mind that you can't use any of the following characters: 0123456789*+-/
def unusual_five():
    return len('     ')

# This function should test if the factor is a factor of base.
# Return true if it is a factor or false if it is not.
def check_for_factor(base, factor):
    return base % factor == 0

# Given two integers a and b,
# which can be positive or negative, find the sum of all the integers between
# and including them and return it. If the two numbers are equal return a or b.
def get_sum(a,b):
    if a == b:
        return a
    list = []
    step = 1 if a < b else -1
    for i in range(a, b + step, step):
        list.append(i)
    return sum(list)

# In a factory a printer prints labels for boxes.
# For one kind of boxes the printer has to use colors which, for the sake of simplicity,
# are named with letters from a to m.
# The colors used by the printer are recorded in a control string.
# For example a "good" control string would be aaabbbbhaijjjm meaning that the printer used three times color a,
# four times color b, one time color h then one time color a...
# Sometimes there are problems: lack of colors,
# technical malfunction and a "bad" control string is produced
# e.g. aaaxbbbbyyhwawiwjjjwwm with letters not from a to m.
def printer_error(s):
    return f"{len([n for n in s if n in 'nopqrstuvwxyz'])}/{len(s)}"

# Take 2 strings s1 and s2 including only letters from a to z.
# Return a new sorted string, the longest possible,
# containing distinct letters - each taken only once - coming from s1 or s2.
def longest(a1, a2):
    return "".join(sorted(set(a1 + a2)))

# Americans are odd people: in their buildings, the first floor is actually the ground floor
# and there is no 13th floor (due to superstition).
# Write a function that given a floor in the american system returns the floor in the european system.
# With the 1st floor being replaced by the ground floor and the 13th floor being removed,
# the numbers move down to take their place. In case of above 13,
# they move down by two because there are two omitted numbers below them.
def get_real_floor(n):
    if n <= 0: return n
    if n < 13: return n-1
    if n > 13: return n-2

# In this simple exercise, you will build a program that takes a value, integer ,
# and returns a list of its multiples up to another value, limit .
# If limit is a multiple of integer, it should be included as well.
# There will only ever be positive integers passed into the function, not consisting of 0.
# The limit will always be higher than the base.
# For example, if the parameters passed are (2, 6),
# the function should return [2, 4, 6] as 2, 4, and 6 are the multiples of 2 up to 6.
# If you can, try writing it in only one line of code.
def find_multiples(integer, limit):
    return [i for i in range(integer, limit + 1, integer)]

# The main idea is to count all the occurring characters in a string.
# If you have a string like aba, then the result should be {'a': 2, 'b': 1}.
# What if the string is empty? Then the result should be empty object literal, {}.
def count(string):
    dict = {}
    count = 0
    for char in string:
        count = string.count(char)
        dict[f"{char}"] = count
    return dict

# In mathematics, the factorial of a non-negative integer n, denoted by n!,
# is the product of all positive integers less than or equal to n.
# For example: 5! = 5 * 4 * 3 * 2 * 1 = 120. By convention the value of 0! is 1.
# Write a function to calculate factorial for a given input.
# If input is below 0 or above 12 throw an exception of type ArgumentOutOfRangeException (C#)
# or IllegalArgumentException (Java) or RangeException (PHP) or throw a RangeError (JavaScript)
# or ValueError (Python) or return -1 (C).
import math
def factorial(n):
    if n > 12:
        raise ValueError
    return math.factorial(n)

# Messi is a soccer player with goals in three leagues:
# LaLiga
# Copa del Rey
# Champions
# Complete the function to return his total number of goals in all three leagues.
# Note: the input will always be valid.
def goals(laLiga, copaDelRey, championsLeague):
    return laLiga + copaDelRey + championsLeague

# Return the name of the winner. If there is no winner, return null (in Java and JavaScript),
# None (in Python), nil (in Ruby), or * in C.
# Task Description
# There are no given candidates. An elector can vote for anyone.
# Each ballot contains only one name and represents one vote for this name.
# A name is an arbitrary string, e.g. "A", "B", or "XJDHD".
# There are no spoiled ballots.
# The ballot-box is represented by an unsorted list of names.
# Each entry in the list corresponds to one vote for this name.
# You do not know the names in advance (because there are no candidates).
# A name wins the election if it gets more than n/2 votes
# (n = number of all votes, i.e. n is equal to the size of the given list).
def get_winner(ballots):
    list = []
    for elem in ballots:
        list.append(elem)
    elite = set(list)
    for char in elite:
        if list.count(char) > len(ballots) / 2 or list.count(char) == len(ballots):
            return char

# Sum all the numbers of a given array ( cq. list ),
# except the highest and the lowest element ( by value, not by index! ).
# The highest or lowest element respectively is a single element at each edge,
# even if there are more than one with the same value.
# Mind the input validation.
def sum_array(arr):
    if arr == [] or arr is None or len(arr) == 1:
        return 0
    integer = sum(arr)
    return integer - max(arr) - min(arr)

# You will be given an array and a limit value.
# You must check that all values in the array are below or equal to the limit value.
# If they are, return true. Else, return false.
# You can assume all values in the array are numbers.
def small_enough(array, limit):
    for elem in array:
        if elem > limit:
            return False
    return True

# Create a function with two arguments that will return an array of the first n multiples of x.
# Assume both the given number and the number of times to count will be positive numbers greater than 0.
# Return the results as an array or list ( depending on language ).
def count_by(x, n):
    list = []
    for i in range(x, x * n + 1, x):
        list.append(i)
    return list

# I created this function to add five to any number that was passed in to it
# and return the new value. It doesn't throw any errors but it returns the wrong number.
def add_five(num):
    return num + 5

# Your task is to sort a given string.
# Each word in the string will contain a single number.
# This number is the position the word should have in the result.
# Note: Numbers can be from 1 to 9. So 1 will be the first word (not 0).
# If the input string is empty, return an empty string.
# The words in the input String will only contain valid consecutive numbers.
def order(sentence):
    list = sentence.split()
    new_list = []
    for i in range(1, len(list) + 1):
        for elem in list:
            for char in elem:
                if char == str(i):
                    new_list.append(elem)
    return ' '.join(new_list)

# There is a queue for the self-checkout tills at the supermarket.
# Your task is write a function to calculate the total time required for all the customers to check out!
def queue_time(customers, n):
    time=[0]*n
    for custom in customers: time[time.index(min(time))]+=custom
    return max(time)

# You are given two arrays a1 and a2 of strings.
# Each string is composed with letters from a to z.
# Let x be any string in the first array and y be any string in the second array.
# Find max(abs(length(x) − length(y)))
# If a1 and/or a2 are empty return -1 in each language
# except in Haskell (F#) where you will return Nothing (None).
def mxdiflg(a1, a2):
    if a1 and a2: return max(abs(len(x) - len(y)) for x in a1 for y in a2)
    return -1

# Wolves have been reintroduced to Great Britain. You are a sheep farmer,
# and are now plagued by wolves which pretend to be sheep. Fortunately, you are good at spotting them.
# Warn the sheep in front of the wolf that it is about to be eaten.
# Remember that you are standing at the front of the queue which is at the end of the array:
def warn_the_sheep(queue):
    if queue.index('wolf') == len(queue)-1:
        return 'Pls go away and stop eating my sheep'
    else:
        ind = len(queue) - queue.index('wolf') - 1
        return (f"Oi! Sheep number {ind}! You are about to be eaten by a wolf!")

# An anagram is the result of rearranging the letters of a word to produce a new word (see wikipedia).
# Note: anagrams are case insensitive
# Complete the function to return true if the two arguments given are anagrams of each other;
# return false otherwise.
def is_anagram(test, original):
    return set(test.lower()) == set(original.lower()) and len(test) == len(original)

# Rock Paper Scissors
# Let's play! You have to return which player won! In case of a draw return Draw!.
def rps(p1, p2):
    if p1 == p2: return 'Draw!'
    elif p1 == 'rock' and p2 == 'scissors':
        return 'Player 1 won!'
    elif p1 == 'scissors' and p2 == 'rock':
        return 'Player 2 won!'
    elif p1 == 'paper' and p2 == 'rock':
        return 'Player 1 won!'
    elif p1 == 'rock' and p2 == 'paper':
        return 'Player 2 won!'
    elif p1 == 'paper' and p2 == 'scissors':
        return 'Player 2 won!'
    elif p1 == 'scissors' and p2 == 'paper':
        return 'Player 1 won!'

# Define a method hello that returns "Hello, Name!" to a given name, or says Hello, World!
# if name is not given (or passed as an empty String).
# Assuming that name is a String and it checks for user typos to return a name with a first capital letter (Xxxx).
def hello(name=None):
    return ('Hello, World!' if not name else f"Hello, {name.title()}!")

# Timmy & Sarah think they are in love, but around where they live,
# they will only know once they pick a flower each.
# If one of the flowers has an even number of petals
# and the other has an odd number of petals it means they are in love.
# Write a function that will take the number of petals of each flower
# and return true if they are in love and false if they aren't.
def lovefunc( flower1, flower2 ):
    return (flower1 % 2 != 0 and flower2 % 2 == 0) or (flower2 % 2 != 0 and flower1 % 2 == 0)

# A perfect number is a number in which the sum of its divisors (excluding itself) are equal to itself.
# Write a function that can verify if the given integer n is a perfect number,
# and return True if it is, or return False if not.
def isPerfect(n):
    return n in [6, 28, 496, 8128, 33550336, 8589869056, 137438691328]

# Rules:
# Children under 14 old.
# Teens under 18 old.
# Young under 21 old.
# Adults have 21 or more.
def people_with_age_drink(age):
    if age < 14: return 'drink toddy'
    elif age < 18: return 'drink coke'
    elif age < 21: return 'drink beer'
    elif age >= 21: return 'drink whisky'

# In this simple Kata your task is to create a function that turns a string into a Mexican Wave.
# You will be passed a string
# and you must return that string in an array where an uppercase letter is a person standing up.
def wave(people):
    return [people[:i] + people[i].upper() + people[i+1:] for i in range(len(people)) if people[i].isalpha()]

# A child is playing with a ball on the nth floor of a tall building. The height of this floor, h, is known.
# He drops the ball out of the window. The ball bounces (for example), to two-thirds of its height (a bounce of 0.66).
# His mother looks out of a window 1.5 meters from the ground.
# How many times will the mother see the ball pass in front of her window (including when it's falling and bouncing?
def bouncing_ball(h, bounce, window):
    if h > 0 and 0 < bounce < 1 and h > window:
        count = 0
        while h > window:
            count += 1
            h = h * bounce
            if h > window:
                count += 1
        return count
    return -1

# Given a two-dimensional array of integers,
# return the flattened version of the array with all the integers in the sorted (ascending) order.
# Example:
def flatten_and_sort(array):
    new_list = [elem for sublist in array for elem in sublist]
    return sorted(new_list)

# Implement a pseudo-encryption algorithm which given a string S
# and an integer N concatenates all the odd-indexed characters of S with all the even-indexed characters of S,
# this process should be repeated N times.
def encrypt(text, n):
    for i in range(n):
        text = text[1::2] + text[::2]
    return text


def decrypt_one_rep(encrypted_text):
    word1 = ""
    word2 = ""
    lenght = int(len(encrypted_text) / 2)
    word1 += encrypted_text[0:lenght]
    word2 += encrypted_text[lenght:]
    final_word = ""
    for i in range(0, lenght):
        final_word += word2[i] + word1[i]

    if len(encrypted_text) % 2 != 0:
        final_word += word2[lenght]
    return final_word


def decrypt(encrypted_text, n):
    if n < 0:
        return encrypted_text
    list = [encrypted_text]
    for i in range(1, n + 1):
        list.append(decrypt_one_rep(list[i - 1]))
    return list[n]

# You are given two sorted arrays that both only contain integers.
# Your task is to find a way to merge them into a single one, sorted in asc order.
# Complete the function mergeArrays(arr1, arr2), where arr1 and arr2 are the original sorted arrays.
def merge_arrays(arr1, arr2):
    return sorted(set(arr1 + arr2))

# A string is considered to be in title case if each word in the string is either (a) capitalised
# (that is, only the first letter of the word is in upper case)
# or (b) considered to be an exception and put entirely into
# lower case unless it is the first word, which is always capitalised.
# Write a function that will convert a string into title case,
# given an optional list of exceptions (minor words).
# The list of minor words will be given as a string with each word separated by a space.
# Your function should ignore the case of the minor words string --
# it should behave in the same way even if the case of the minor word string is changed.
def title_case(title, minor_words=''):
    list2 = []
    list = [x.title() for x in title.split()]
    exam = [x.title() for x in minor_words.split()]
    if not list:
        return ''
    list2.append(list[0])
    list.pop(0)
    for elem in list:
        for i in range(len(exam)):
            if elem.lower() == exam[i].lower():
                list2.append(elem.lower())
                continue
        if elem not in exam:
            list2.append(elem.title())
    return ' '.join(list2)

# Your team is writing a fancy new text editor and you've been tasked with implementing the line numbering.
# Write a function which takes a list of strings and returns each line prepended by the correct number.
# The numbering starts at 1. The format is n: string. Notice the colon and space in between.
def number(lines):
    list = []
    i = 1
    for elem in lines:
        list.append(f"{i}: {elem}")
        i += 1
    return list

# Simple, given a string of words, return the length of the shortest word(s).
# String will never be empty and you do not need to account for different data types.
def find_short(s):
    # your code here
    return len(list(i for i in sorted(s.split(), key=len))[0])

# Given a string str, reverse it and omit all non-alphabetic characters.
def reverse_letter(string):
    return ''.join(reversed(list(i for i in string if i in 'qwertyuiopasdfghjklzxcvbnm')))

# Given an array of integers, find the one that appears an odd number of times.
# There will always be only one integer that appears an odd number of times.
def find_it(seq):
    return min([i for i in seq if seq.count(i) % 2 != 0])

# Define a function that takes an integer argument and returns a logical value true
# or false depending on if the integer is a prime.
# Per Wikipedia, a prime number ( or a prime ) is a natural number greater than 1
# that has no positive divisors other than 1 and itself.
from math import sqrt
def is_prime(num):
    flag = True
    prime_flag = 0
    if(num > 1):
	    for i in range(2, int(sqrt(num)) + 1):
		    if (num % i == 0):
			    prime_flag = 1
			    break
	    if prime_flag == 0:
		    flag = True
	    else:
		    flag = False
    else:
	    flag = False
    return flag

# So this function should return the first pair of two prime numbers spaced
# with a gap of g between the limits m, n if these numbers exist otherwise `nil
# or null or None or Nothing (or ... depending on the language).
def gap(g, m, n):
    first_int = 0
    second_int = 0
    for i in range(m,n+1):
        if int_is_prime(i):
            if first_int == 0:
                first_int = i
            elif second_int == 0:
                second_int = i
            else:
                first_int = second_int
                second_int = i
        if second_int - first_int == g:
            return [first_int, second_int]
    return None

def int_is_prime(n):
    if n <= 0 or n == 1:
        return False
    i = 2
    while (i <= n ** 0.5 ):
        if n % i == 0:
            return False
        i += 1
    return True\

# The first input array is the key to the correct answers to an exam, like ["a", "a", "b", "d"].
# The second one contains a student's submitted answers.
# The two arrays are not empty and are the same length. Return the score for this array of answers,
# giving +4 for each correct answer, -1 for each incorrect answer, and +0 for each blank answer,
# represented as an empty string (in C the space character is used).
def check_exam(arr1,arr2):
    count = 0
    for i in range(len(arr1)):
        if arr1[i] == arr2[i]:
            count += 4
            continue
        elif arr2[i] == '':
            count += 0
            continue
        count -= 1
    return (count if count > 0 else 0)

# Given a 2D ( nested ) list ( array, vector, .. ) of size m * n,
# your task is to find the sum of the minimum values in each row.
def sum_of_minimums(numbers):
    return sum(min(i) for i in numbers)

# Complete the method which accepts an array of integers, and returns one of the following:
# "yes, ascending" - if the numbers in the array are sorted in an ascending order
# "yes, descending" - if the numbers in the array are sorted in a descending order
# "no" - otherwise
def is_sorted_and_how(arr):
    if sorted(arr, key = int) == arr:
        return 'yes, ascending'
    elif sorted(arr, key = int, reverse = True) == arr:
        return 'yes, descending'
    return 'no'

# Given a list of digits, return the smallest number that could be formed from these digits,
# using the digits only once (ignore duplicates).
def min_value(digits):
    list = sorted(set(digits))
    integer = ''
    for elem in list:
        integer += str(elem)
    return int(integer)

# Implement a function that adds two numbers together and returns their sum in binary.
# The conversion can be done before, or after the addition.
# The binary number returned should be a string.
def add_binary(a,b):
    sum = bin(int(a) + int(b))
    return ''.join(list(sum)[2:])

# The function chooseBestSum (or choose_best_sum or ... depending on the language)
# will take as parameters t (maximum sum of distances, integer >= 0),
# k (number of towns to visit, k >= 1) and ls (list of distances,
# all distances are positive or zero integers and this list has at least one element).
# The function returns the "best" sum ie the biggest possible sum of k distances less than
# or equal to the given limit t, if that sum exists, or otherwise nil, null, None, Nothing,
# depending on the language. In that case with C, C++, D, Dart, Fortran, F#, Go, Julia, Kotlin,
# Nim, OCaml, Pascal, Perl, PowerShell, Reason, Rust, Scala, Shell, Swift return -1.
import itertools
def choose_best_sum(t, k, ls):
    combinations = list(itertools.combinations(ls, k))
    condition = [sum(distance) for distance in combinations]
    condition2 = [distance for distance in condition if distance <= t]
    if condition2 == []:
        largest_distance = None
    else:
        largest_distance = max([distance for distance in condition if distance <= t])
    return largest_distance

# ROT13 is a simple letter substitution cipher that replaces a letter with the letter 13 letters
# after it in the alphabet. ROT13 is an example of the Caesar cipher.
# Create a function that takes a string and returns the string ciphered with Rot13.
# If there are numbers or special characters included in the string,
# they should be returned as they are. Only letters from the latin/english alphabet should be shifted,
# like in the original Rot13 "implementation".
# Please note that using encode is considered cheating.
def rot13(message):
    key = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
    val = "nopqrstuvwxyzabcdefghijklmNOPQRSTUVWXYZABCDEFGHIJKLM"
    transform = dict(zip(key, val))
    return ''.join(transform.get(char, char) for char in message)

# Given an integer as input, can you round it to the next (meaning, "greater than or equal") multiple of 5?
def round_to_next5(n):
    if n == 0:
        pass
    elif abs(n)%5 == 0:
        pass
    else:
        n =  n - n%5 + 5
    return n

# You need to write a function that reverses the words in a given string.
# A word can also fit an empty string. If this is not clear enough, here are some examples:
# As the input may have trailing spaces, you will also need to ignore unneccesary whitespace.
def reverse(st):
    return ' '.join(list(st.split())[::-1])

# Write a function named sumDigits which takes a number as input
# and returns the sum of the absolute value of each of the number's decimal digits.
def sumDigits(number):
    return sum(int(d) for d in str(abs(number)))

# As a part of this Kata, you need to create a function that when provided with a triplet,
# returns the index of the numerical element that lies between the other two elements.
# The input to the function will be an array of three distinct numbers (Haskell: a tuple).
def gimme(input_array):
    return [input_array.index(i) for i in input_array if min(input_array) < i < max(input_array)][0]

# The Western Suburbs Croquet Club has two categories of membership, Senior and Open.
# They would like your help with an application form that will tell prospective members
# which category they will be placed.
# To be a senior, a member must be at least 55 years old and have a handicap greater than 7.
# In this croquet club, handicaps range from -2 to +26; the better the player the lower the handicap.
def open_or_senior(data):
    return ['Senior' if elem[0] >= 55 and elem[1] > 7 else 'Open' for elem in data]

# Alice and Bob were on a holiday. Both of them took many pictures of the places they've been,
# and now they want to show Charlie their entire collection.
# However, Charlie doesn't like these sessions, since the motif usually repeats.
# He isn't fond of seeing the Eiffel tower 40 times.
# He tells them that he will only sit for the session if they show the same motif at most N times.
# Luckily, Alice and Bob are able to encode the motif as a number.
# Can you help them to remove numbers such that their list contains each number only up to N times,
# without changing the order?
def delete_nth(order,max_e):
    sort_list = []
    for elem in order:
        if sort_list.count(elem) >= max_e:
            continue
        sort_list.append(elem)
    return sort_list

# Given a number, say prod (for product), we search two Fibonacci numbers F(n) and F(n+1) verifying
# Your function product Fib takes an integer(prod) and returns an array
# depending on the language if F(n) * F(n+1) = prod.
def productFib(prod):
    First_val = 0
    Second_val = 1
    next = 0
    while First_val * Second_val < prod:
            next = First_val + Second_val
            First_val = Second_val
            Second_val = next
    return [First_val, Second_val, True if First_val * Second_val == prod else False]

# Given a sequence of numbers, find the largest pair sum in the sequence.
def largest_pair_sum(numbers):
    return sorted(numbers)[-1] + sorted(numbers)[-2]

# Your task is to write a function which calculates the value
# of a word based off the sum of the alphabet positions of its characters.
# The input will always be made of only lowercase letters and will never be empty.
def words_to_marks(s):
    return sum(ord(char) - 96 for char in s)

# We know the content of the evaporator (content in ml), the percentage of foam or gas lost every day (evap_per_day)
# and the threshold (threshold) in percentage beyond which the evaporator is no longer useful.
# All numbers are strictly positive.
def evaporator(content, evap_per_day, threshold):
    result = 0;
    percentage = 100;
    while percentage > threshold:
        percentage = percentage - percentage * (evap_per_day / 100)
        result += 1
    return result

# You will be given an array of numbers. You have to sort the odd numbers
# in ascending order while leaving the even numbers at their original positions.
def sort_array(source_array):
    odds = iter(sorted(elem for elem in source_array if elem % 2))
    return [next(odds) if elem % 2 else elem for elem in source_array]

# Complete the solution so that it returns true if the first argument(string)
# passed in ends with the 2nd argument (also a string).
def solution(string, ending):
    return string[::-1][:len(ending)] == ending[::-1]

# Mr. Scrooge has a sum of money 'P' that he wants to invest. Before he does,
# he wants to know how many years 'Y' this sum 'P' has to be kept in the bank
# in order for it to amount to a desired sum of money 'D'.
# The sum is kept for 'Y' years in the bank where interest 'I' is paid yearly.
# After paying taxes 'T' for the year the new sum is re-invested.
# Note to Tax: not the invested principal is taxed, but only the year's accrued interest
def calculate_years(principal, interest, tax, desired):
    count = 0
    if principal == desired:
            return count
    while principal < desired:
        count += 1
        percent = principal * interest - (principal * interest * tax)
        principal += percent
    return count

# A stream of data is received and needs to be reversed.
# Each segment is 8 bits long, meaning the order of these segments needs to be reversed, for example:
def data_reverse(data):
    return [elem for i in range(len(data), -1, -8) for elem in data[i: i + 8]]

# Implement a function that accepts 3 integer values a, b, c.
# The function should return true if a triangle can be built with
# the sides of given length and false in any other case.
def is_triangle(a, b, c):
    return max(a, b ,c) < a + b + c - max(a, b ,c)

# Your task is to write function factorial.
import math
def factorial(n):
    return math.factorial(n)

# Given an array of numbers, return a new array of length number containing the last even numbers
# from the original array (in the same order). The original array will be not empty
# and will contain at least "number" even numbers.
def even_numbers(arr,n):
    return [i for i in arr[::-1] if i % 2 == 0][:n][::-1]

# My grandfather always predicted how old people would get,
# and right before he passed away he revealed his secret!
# In honor of my grandfather's memory we will write a function using his formula!
# Take a list of ages when each of your great-grandparent died.
# Multiply each number by itself.
# Add them all together.
# Take the square root of the result.
# Divide by two.
def predict_age(age_1, age_2, age_3, age_4, age_5, age_6, age_7, age_8):
    return sum([age_1**2, age_2**2, age_3**2, age_4**2, age_5**2, age_6**2, age_7**2, age_8**2])**0.5 // 2

# We want to know the index of the vowels in a given word,
# for example, there are two vowels in the word super (the second and fourth letters).
# So given a string "super", we should return a list of [2, 4].
def vowel_indices(word):
    return [index + 1 for index, elem in enumerate(word) if elem.lower() in 'aeoiuy']

# Introduction
# There is a war and nobody knows - the alphabet war!
# There are two groups of hostile letters.
# The tension between left side letters and right side letters was too high and the war began.
# Task
# Write a function that accepts fight string consists of only small letters and return who wins the fight.
# When the left side wins return Left side wins!, when the right side wins return Right side wins!,
# in other case return Let's fight again!.
def alphabet_war(fight):
    left_side = {'w': 4, 'p': 3, 'b': 2, 's': 1}
    right_side = {'m': 4, 'q': 3, 'd': 2, 'z': 1}
    left_count = 0
    right_count = 0
    for char in fight:
        if char in left_side:
            left_count += left_side[char]
        elif char in right_side:
            right_count += right_side[char]
    if left_count > right_count:
        return 'Left side wins!'
    elif right_count > left_count:
        return 'Right side wins!'
    return "Let's fight again!"

# Several people are standing in a row divided into two teams.
# The first person goes into team 1, the second goes into team 2, the third goes into team 1, and so on.
# Task
# Given an array of positive integers (the weights of the people),
# return a new array/tuple of two integers, where the first one is the total weight of team 1,
# and the second one is the total weight of team 2.
def row_weights(array):
    return sum(i for i in array[::2]), sum(i for i in array[1::2])

# In this Kata, you will be given a string that may have mixed uppercase and lowercase letters
# and your task is to convert that string to either lowercase only or uppercase only based on:
# make as few changes as possible.
# if the string contains equal number of uppercase and lowercase letters, convert the string to lowercase.
def solve(s):
    count_lower: int = 0
    count_upper: int = 0
    for i in s:
        if i.islower():
            count_lower += 1
            continue
        count_upper += 1
    if count_lower >= count_upper:
        return s.lower()
    return s.upper()

# In a small town the population is p0 = 1000 at the beginning of a year.
# The population regularly increases by 2 percent per year and moreover 50 new inhabitants
# per year come to live in the town. How many years does the town need
# to see its population greater or equal to p = 1200 inhabitants?
def nb_year(p0, percent, aug, p):
    count = 0
    while p0 < p:
        p0 += int(p0 * (percent / 100) + aug)
        count += 1
    return count

# Find the total sum of internal angles (in degrees) in an n-sided simple polygon. N will be greater than 2.
def angle(n):
    return 180 * (n - 2)

# Given an array of ones and zeroes, convert the equivalent binary value to an integer.
# Eg: [0, 0, 0, 1] is treated as 0001 which is the binary representation of 1.
def binary_array_to_number(arr):
    return int("".join([str(i) for i in arr]), 2)

# Your task is to return the sum of Triangular Numbers up-to-and-including the nth Triangular Number.
# Triangular Number: "any of the series of numbers (1, 3, 6, 10, 15, etc.)
# obtained by continued summation of the natural numbers 1, 2, 3, 4, 5, etc."
def sum_triangular_numbers(n):
    if n < 0:
        return 0
    sum = sum_triangular_numbers(n-1)
    return sum + (n * (n + 1)) / 2

# Given a positive integer n written as abcd... (a, b, c, d... being digits) and a positive integer p
# we want to find a positive integer k, if it exists, such that the sum of the digits of n taken
# to the successive powers of p is equal to k * n.
def dig_pow(n, p):
    count = 0
    for char in str(n):
        count += int(char) ** p
        p += 1
    return count // n if count % n == 0 else -1

# You are given an array(list) strarr of strings and an integer k.
# Your task is to return the first longest string consisting of k consecutive strings taken in the array.
def longest_consec(strarr, k):
    return max(["".join(strarr[i:i+k]) for i in range(len(strarr)-k+1)], key=len)\
        if strarr and 0 < k <= len(strarr) else ""

# Let us begin with an example:
# A man has a rather old car being worth $2000.
# He saw a secondhand car being worth $8000.
# He wants to keep his old car until he can buy the secondhand one.
# He thinks he can save $1000 each month but the prices of his old car
# and of the new one decrease of 1.5 percent per month.
# Furthermore this percent of loss increases of 0.5 percent at the end of every two months.
# Our man finds it difficult to make all these calculations.
def nbMonths(start_price_old, start_price_new, saving_per_month, percent_loss_by_month):
    months = 0
    savings = 0
    while start_price_old + savings < start_price_new:
        months += 1
        savings += saving_per_month
        if months % 2 == 0:
            percent_loss_by_month += 0.5
        start_price_old *= ((100 - percent_loss_by_month) / 100)
        start_price_new *= ((100 - percent_loss_by_month) / 100)
    return [months, round(start_price_old + savings - start_price_new)]

# Your car is old, it breaks easily. The shock absorbers are gone
# and you think it can handle about 15 more bumps before it dies totally.
# Unfortunately for you, your drive is very bumpy! Given a string showing either flat road (_) or bumps (n).
# If you are able to reach home safely by encountering 15 bumps or less, return Woohoo!, otherwise return Car Dead
def bumps(road):
    return "Woohoo!" if road.count("n") <= 15 else "Car Dead"

# Find the number with the most digits.
# If two numbers in the argument array have the same number of digits, return the first one in the array.
def find_longest(arr):
    arr_len = [len(str(n)) for n in arr]
    return arr[arr_len.index(max(arr_len))]

# There are pillars near the road. The distance between the pillars is the same
# and the width of the pillars is the same. Your function accepts three arguments:
# number of pillars (≥ 1);
# distance between pillars (10 - 30 meters);
# width of the pillar (10 - 50 centimeters).
# Calculate the distance between the first and the last pillar in centimeters
# (without the width of the first and last pillar).
def pillars(num_pill, dist, width):
    return (num_pill - 2) * width + (100 * dist) * (num_pill - 1) if num_pill > 1 else 0

# What if we need the length of the words separated by a space
# to be added at the end of that same word and have it returned as an array?
def add_length(str_):
    return [f"{i} {len(i)}" for i in str_.split()]

# You're re-designing a blog and the blog's posts have the following format
# for showing the date and time a post was made:
# Weekday Month Day, time e.g., Friday May 2, 7pm
# You're running out of screen real estate, and on some pages you want
# to display a shorter format, Weekday Month Day that omits the time.
# Write a function, shortenToDate, that takes the Website date/time
# in its original string format, and returns the shortened format.
# Assume shortenToDate's input will always be a string, e.g. "Friday May 2, 7pm".
# Assume shortenToDate's output will be the shortened string, e.g., "Friday May 2".
def shorten_to_date(long_date):
    return long_date.split(',')[0]

# A student was working on a function and made some syntax mistakes while coding.
# Help them find their mistakes and fix them.
def main(verb, noun):
    return verb + noun

# Code as fast as you can! You need to double the integer and return it.
def doubleInteger(i):
    return i * 2

# Complete function saleHotdogs/SaleHotDogs/sale_hotdogs, function accept 1 parameters:
# n, n is the number of customers to buy hotdogs, different numbers have different
# prices (refer to the following table), return a number that the customer need to pay how much money.
def sale_hotdogs(n):
    if n < 5: return n * 100
    elif 5 <= n < 10: return n * 95
    return n * 90

# Replace all vowel to exclamation mark in the sentence. aeiouAEIOU is vowel.
def replace_exclamation(s):
    for char in s:
        if char.lower() in 'aeiou':
            s = s.replace(char, '!')
    return s

# I will give you an integer. Give me back a shape that is as long
# and wide as the integer. The integer will be a whole number between 1 and 50.
def generate_shape(n: int) -> str:
    return '\n'.join(['+' * n] * n)

# Create a function called _if which takes 3 arguments:
# a boolean value bool and 2 functions (which do not take any parameters): func1 and func2
# When bool is truth-ish, func1 should be called, otherwise call the func2.
def _if(bool, func1, func2):
    return func1() if bool == True else func2()

# Your task is to write a function which returns the sum of following series upto nth term(parameter).
def series_sum(n):
    return '{:.2f}'.format(sum(1.0/(3 * i + 1) for i in range(n)))

# Define a function that removes duplicates from an array of numbers and returns it as a result.
# The order of the sequence has to stay the same.
def distinct(seq):
    new_list = []
    for elem in seq:
        if elem not in new_list:
            new_list.append(elem)
    return new_list

# Given an array of numbers, check if any of the numbers are the character codes
# for lower case vowels (a, e, i, o, u).
# If they are, change the array value to a string of that vowel.
# Return the resulting array.
def is_vow(s):
    vowels = {97: 'a', 111: 'o', 117: 'u', 101: 'e', 105: 'i'}
    return [vowels.get(elem, elem) for elem in s]

# In Python, there is a built-in filter function that operates similarly to JS's filter.
# For more information on how to use this function, visit https://docs.python.org/3/library/functions.html#filter
def get_even_numbers(arr):
    return list(filter(lambda x: x % 2 == 0, arr))

# In this kata you are required to, given a string, replace every letter with its position in the alphabet.
# If anything in the text isn't a letter, ignore it and don't return it.
def alphabet_position(text):
    return ' '.join([str(ord(char) - 96) for char in text.lower() if char >= 'a' and char<= 'z'])

# Complete the method which returns the number which is most frequent in the given input array.
# If there is a tie for most frequent number, return the largest number among them.
# Note: no empty arrays will be given.
from collections import Counter
def highest_rank(arr):
    c = Counter(arr)
    m = max(c.values())
    return max(k for k, v in c.items() if v == m)

# We want to generate a function that computes the series starting from 0 and ending until the given number.
def show_sequence(n):
    sum=0
    s=''
    if n==0:
        return "0=0"
    elif n<0:
        return str(n)+"<0"
    else:
        for i in range(0,n+1):
            sum += i
            s+=str(i)+'+'
        s = s.strip('+')
        s = s +" = "+str(sum)
        return s

# Remove all exclamation marks from the end of sentence.
def remove(s):
    while s.endswith('!'):
        s = s[:-1]
    return s

# Write a function that will check if two given characters are the same case.
# If either of the characters is not a letter, return -1
# If both characters are the same case, return 1
# If both characters are letters, but not the same case, return 0
def same_case(a: str, b: str) -> int:
    if not a.isalpha() or not b.isalpha():
        return -1
    return 1 if a.islower() and b.islower() or a.isupper() and b.isupper() else 0

# Write a function that returns a string in which firstname is swapped with last name.
def name_shuffler(str_):
    return ' '.join(str_.split()[::-1])

# To find the volume (centimeters cubed) of a cuboid you use the formula:
# volume = Length * Width * Height
# But someone forgot to use proper record keeping,
# so we only have the volume, and the length of a single side!
# It's up to you to find out whether the cuboid has equal sides (= is a cube).
def cube_checker(volume, side):
    return volume == side ** 3 if volume > 0 and side > 0 else False

# You've just moved into a perfectly straight street with exactly n identical houses
# on either side of the road. Naturally, you would like to find out the house number
# of the people on the other side of the street.
def over_the_road(address, n):
    return (n * 2) - address + 1

# Given two arrays a and b write a function comp(a, b) (orcompSame(a, b))
# that checks whether the two arrays have the "same" elements, with the same multiplicities
# (the multiplicity of a member is the number of times it appears). "Same" means,
# here, that the elements in b are the elements in a squared, regardless of the order.
def comp(array1, array2):
    if array1 == None or array2 == None:
        return False
    return sorted(number ** 2 for number in array1) == sorted(array2)

# Output: String with comma delimited elements of the array in th same order.
def print_array(arr):
    return ','.join(str(i) for i in arr)

# An AI has infected a text with a character!!
# This text is now fully mutated to this character.
# If the text or the character are empty, return an empty string.
# There will never be a case when both are empty as nothing is going on!!
# Note: The character is a string of length 1 or an empty string.
def contamination(text, char):
    return char * len(text) if text and char != '' else ''

# Write a function that takes a positive integer n, sums all the cubed values from 1 to n, and returns that sum.
# Assume that the input n will always be a positive integer.
def sum_cubes(n):
    return sum(i**3 for i in range(n + 1))

# We need a simple function that determines if a plural is needed or not.
# It should take a number, and return true if a plural should
# be used with that number or false if not. This would be useful when printing
# out a string such as 5 minutes, 14 apples, or 1 sun.
# You only need to worry about english grammar rules for this kata,
# where anything that isn't singular (one of something), it is plural (not one of something).
def plural(n):
    return n != 1

# You will be given an array a and a value x. All you need to do
# is check whether the provided array contains the value, without using a loop.
# Array can contain numbers or strings. x can be either. Return true
# if the array contains the value, false if not. With strings you will need to account for case.
def check(a, x):
    return x in a

# Given a variable n,
# If n is an integer, Return a string with dash'-'marks before and after each odd integer,
# but do not begin or end the string with a dash mark. If n is negative, then the negative sign should be removed.
# If n is not an integer, return the string "None".
def dashatize(num):
    num_str = str(num)
    for i in ['1','3','5','7','9']:
        num_str = num_str.replace(i,'-' + i + '-')
    return num_str.strip('-').replace('--','-')

# Fix the variables assigments so that this code stores the string 'devLab' in the variable name.
a, b, name = 'dev', 'Lab', 'devLab'

# Determine the total number of digits in the integer (n>=0) given
# as input to the function. For example, 9 is a single digit,
# 66 has 2 digits and 128685 has 6 digits. Be careful to avoid overflows/underflows.
def digits(n):
    return len(str(n))

# Christmas is coming and many people dreamed of having a ride with Santa's sleigh.
# But, of course, only Santa himself is allowed to use this wonderful transportation.
# And in order to make sure, that only he can board the sleigh, there's an authentication mechanism.
# Your task is to implement the authenticate() method of the sleigh, which takes the name of the person,
# who wants to board the sleigh and a secret password. If, and only if,
# the name equals "Santa Claus" and the password is "Ho Ho Ho!"
# (yes, even Santa has a secret password with uppercase and lowercase letters
# and special characters :D), the return value must be true. Otherwise it should return false.
class Sleigh(object):
    def authenticate(self, name, password):
        return name == 'Santa Claus' and password == 'Ho Ho Ho!'

# Your mission:
# Write a function called checkCoupon which verifies that a coupon code is valid and not expired.
# A coupon is no more valid on the day AFTER the expiration date.
# All dates will be passed as strings in this format: "MONTH DATE, YEAR".
from datetime import date
def check_coupon(entered_code, correct_code, current_date, expiration_date):
    month = {'January': 1, 'February': 2, 'March': 3, 'April': 4,
            'May': 5, 'June': 6, 'July': 7, 'August': 8, 'September': 9, 'October': 10,
            'November': 11, 'December': 12}
    if entered_code is correct_code:
        current_date = current_date.replace(',', '')
        expiration_date = expiration_date.replace(',', '')
        formatted_current = [month.get(i) if i in month.keys() else int(i) for i in current_date.split()]
        formatted_expiration = [month.get(i) if i in month.keys() else int(i) for i in expiration_date.split()]
        to_date_current = date(formatted_current[2], formatted_current[0], formatted_current[1])
        to_date_formatted_expiration = date(formatted_expiration[2], formatted_expiration[0], formatted_expiration[1])
        if to_date_current <= to_date_formatted_expiration:
            return True
        return False
    return False

# Complete the function, which calculates how much you need to
# tip based on the total amount of the bill and the service.
import math
def calculate_tip(amount, rating):
    rating_dict = {'poor': 5, 'good': 10, 'great': 15, 'excellent': 20, 'terrible': 0}
    if rating.lower() in rating_dict:
        return math.ceil(rating_dict[rating.lower()] * amount / 100)
    return 'Rating not recognised'

# You get any card as an argument. Your task is to return the suit of this card (in lowercase).
def define_suit(card):
    return 'clubs' if 'C' in card else 'spades' if 'S' in card\
        else 'diamonds' if 'D' in card else 'hearts' if 'H' in card else None

# Create a method that accepts a list and an item,
# and returns true if the item belongs to the list, otherwise false.
def include(arr,item):
    return item in arr

# You have to write a function that describe Leo:
# def leo(oscar):
#   pass
# if oscar was (integer) 88, you have to return "Leo finally won the oscar! Leo is happy".
# if oscar was 86, you have to return "Not even for Wolf of wallstreet?!"
# if it was not 88 or 86 (and below 88) you should return "When will you give Leo an Oscar?"
# if it was over 88 you should return "Leo got one already!"
def leo(oscar):
    if oscar == 88: return 'Leo finally won the oscar! Leo is happy'
    elif oscar == 86: return 'Not even for Wolf of wallstreet?!'
    elif oscar != 88 and oscar != 86 and oscar < 88: return 'When will you give Leo an Oscar?'
    elif oscar > 88: return 'Leo got one already!'

# Given a string s, write a method (function) that will return true if
# its a valid single integer or floating number or false if its not.
def isDigit(string):
    try:
        float(string)
        return True
    except:
        return False

# The objective of Duck, duck, goose is to walk in a circle, tapping on each player's head until one is chosen.
def duck_duck_goose(players, goose):
    while len(players) < goose:
        goose -= len(players)
    return players[goose - 1].name

# Make a function that will return a greeting statement that uses an input;
# your program should return, "Hello, <name> how are you doing today?".
def greet(name):
    return f'Hello, {name} how are you doing today?'

# Write a function that returns the total surface area and volume of a box as an array: [area, volume]
def get_size(w,h,d):
    return [((w * h) + (w * d) + (h * d)) * 2, w * h * d]

# Write a function which removes from string all non-digit characters
# and parse the remaining to number. E.g: "hell5o wor6ld" -> 56
def get_number_from_string(string):
    return int(''.join(list(i for i in string if i in '0123456789')))\

# Your task is to sum the differences between consecutive pairs in the array in descending order.
def sum_of_differences(arr):
    arr = sorted(arr, reverse = True)
    list = []
    for i in range(len(arr)):
        for j in range(i + 1, len(arr)):
            list.append(arr[i] - arr[j])
    return max(list) if len(arr) > 1 else 0

# Basic regex tasks. Write a function that takes in a numeric code of any length.
# The function should check if the code begins with 1, 2, or 3 and return true if so. Return false otherwise.
def validate_code(code):
    return str(code)[0] in '123'

# Given an array of integers , Find the minimum sum which is obtained from summing each Two integers product .
def min_sum(arr):
    arr = sorted(arr)
    return sum(arr[i]*arr[-i-1] for i in range(len(arr)//2))

# Given an array of integers of any length, return an array that has 1 added to the value represented by the array.
#  the array can't be empty
# only non-negative, single digit integers are allowed
# Return nil (or your language's equivalent) for invalid inputs.
def up_array(arr):
    integer = ''
    list = []
    print(arr)
    if len(arr) < 1 :
        return None
    elif len(arr) == 1 and arr[0] <=9:
        return [1]
    for i in arr:
        if len(str(i)) > 1 or i < 0:
            return None
    else:
        for elem in arr:
            if str(elem) in '1234567890':
                integer += str(elem)
    if integer[0] == '0' and integer[1] != '0':
        integer = int(integer[1:]) + 1
        integer = '0' + str(integer)
    elif integer[0] == '0' and integer[1] == '0':
        integer = int(integer[2:]) + 1
        integer = '00' + str(integer)
    elif integer[0] != '0':
        integer = str(int(integer) + 1)
    for char in integer:
        list.append(int(char))
    return list

# We want an array, but not just any old array, an array with contents!
# Write a function that produces an array with the numbers 0 to N-1 in it.
# For example, the following code will result in an array containing the numbers 0 to 4
def arr(n=0):
    return list(range(n))

# Time to test your basic knowledge in functions! Return the odds from a list:
# [1, 2, 3, 4, 5]  -->  [1, 3, 5]
# [2, 4, 6]        -->  []
odds = lambda list: [i for i in list if i % 2 !=0]

# Create a function close_compare that accepts 3 parameters: a, b, and an optional margin.
# The function should return whether a is lower than, close to, or higher than b.
# a is considered "close to" b if margin is greater than or equal to the distance between a and b.
def close_compare(a, b, margin=0):
    if a < b and b - a > margin: return -1
    elif a - b > margin and a > b: return 1
    elif a - b <= margin: return 0

# Take an integer n (n >= 0) and a digit d (0 <= d <= 9) as an integer.
# Square all numbers k (0 <= k <= n) between 0 and n.
# Count the numbers of digits d used in the writing of all the k**2.
# Call nb_dig (or nbDig or ...) the function taking n and d as parameters and returning this count.
def nb_dig(n, d):
    values_list = list(range(0, n+1))
    list_squared = list(map(lambda x: str(x**2), values_list))
    str_list_squared = ''.join(list_squared)
    print(str(d))
    return str_list_squared.count(str(d))

# Due to another of his misbehaved, the primary school's teacher of the young Gauß,
# Herr J.G. Büttner, to keep the bored and unruly young schoolboy Karl Friedrich Gauss
# busy for a good long time, while he teaching arithmetic to his mates,
# assigned him the problem of adding up all the whole numbers from 1 through a given number n.
def f(n):
    return sum(range(1, n + 1)) if type(n) is int and n > 0 else None

# Your friend invites you out to a cool floating pontoon around 1km off the beach.
# Among other things, the pontoon has a huge slide that drops you out right into the ocean,
# a small way from a set of stairs used to climb out.
# As you plunge out of the slide into the water, you see a shark hovering
# in the darkness under the pontoon... Crap!
# You need to work out if the shark will get to you before you can get to the pontoon.
# To make it easier... as you do the mental calculations in the water you either freeze
# when you realise you are dead, or swim when you realise you can make it!
def shark(pontoon_distance, shark_distance, you_speed, shark_speed, dolphin):
    if dolphin:
        if pontoon_distance / you_speed < shark_distance / (shark_speed / 2):
            return 'Alive!'
        else:
            return 'Shark Bait!'
    elif pontoon_distance / you_speed > shark_distance / shark_speed:
        return 'Shark Bait!'
    elif pontoon_distance / you_speed < shark_distance / shark_speed:
        return 'Alive!'

# Get ASCII value of a character.
def get_ascii(c):
   return ord(c)

# Write a function that takes a single string (word) as argument.
# The function must return an ordered list containing the indexes of all capital letters in the string.
def capitals(word):
    return [value for value, i in enumerate(word) if i.isupper()]

# Complete the function which converts hex number (given as a string) to a decimal number.
def hex_to_dec(s):
    return int(s, 16)

# Create a combat function that takes the player's current health
# and the amount of damage recieved, and returns the player's new health. Health can't be less than 0.
def combat(health, damage):
    return health - damage if health > damage else 0

# Find the sum of all multiples of n below m
# Keep in Mind
# n and m are natural numbers (positive integers)
# m is excluded from the multiples
def sum_mul(n, m):
    return sum(range(n, m, n)) if m > 0 and n > 0 else 'INVALID'

# Your job is simple, if x squared is more than 1000,
# return It's hotter than the sun!!, else, return Help yourself to a honeycomb Yorkie for the glovebox.
# Note: Input will either be a positive integer (or a string for untyped languages).
def apple(x):
  return "It's hotter than the sun!!" if int(x)**2 > 1000 else "Help yourself to a honeycomb Yorkie for the glovebox."

# You are required to create a simple calculator that returns
# the result of addition, subtraction, multiplication or division of two numbers.
# Your function will accept three arguments:
# The first and second argument should be numbers.
# The third argument should represent a sign indicating the operation to perform on these two numbers.
# if the variables are not numbers or the sign does not belong to the list above
# a message "unknown value" must be returned.
def calculator(x,y,op):
    if type(x) == int and type(y) == int:
        dict_op = {'+': x+y, '-': x-y, '*': x*y, '/': x/y}
        if op in dict_op and x !=0 and y !=0:
            return dict_op[op]
        else:
            return 'unknown value'
    return 'unknown value'

# Deoxyribonucleic acid, DNA is the primary information storage molecule in biological systems. It is composed
# of four nucleic acid bases Guanine ('G'), Cytosine ('C'), Adenine ('A'), and Thymine ('T').
# Ribonucleic acid, RNA, is the primary messenger molecule in cells.
# RNA differs slightly from DNA its chemical structure and contains no Thymine.
# In RNA Thymine is replaced by another nucleic acid Uracil ('U').
# Create a function which translates a given DNA string into RNA.
def dna_to_rna(dna):
    dict = {'G': 'G', 'C': 'C', 'A': 'A', 'T': 'U'}
    return ''.join(list(dict[char] for char in dna))

# Find the sum of the odd numbers within an array, after cubing the initial integers.
# The function should return undefined/None/nil/NULL if any of the values aren't numbers.
# Note: Booleans should not be considered as numbers.
def cube_odd(arr):
    for elem in arr:
        if type(elem) != int:
            return None
    return sum([i**3 for i in arr if i % 2 != 0])

# You must implement a function that returns the difference between the largest
# and the smallest value in a given list / array (lst) received as the parameter.
# lst contains integers, that means it may contain some negative numbers
# if lst is empty or contains a single element, return 0
# lst is not sorted
def max_diff(lst):
    return max(lst) - min(lst) if lst else 0

# Your task is simply to count the total number of lowercase letters in a string.
def lowercase_count(strng):
    return len(list(i for i in strng if i.islower()))

# Return an array/list where Even numbers come first then odds
# Since , Men are stronger than Boys , Then Even numbers in ascending order While odds in descending .
# Array/list size is at least 4 .
# Array/list numbers could be a mixture of positives , negatives .
# Have no fear , It is guaranteed that no Zeroes will exists .
def men_from_boys(arr):
    return sorted(list(set(list(i for i in arr if i % 2 == 0)))) +\
           sorted(list(set(list(i for i in arr if i % 2 != 0))), reverse = True)

# Step 1: Create a function called encode() to replace all
# the lowercase vowels in a given string with numbers according to the following pattern:
# For example, encode("hello") would return "h2ll4".
# There is no need to worry about uppercase vowels in this kata.
# Step 2: Now create a function called decode() to turn the numbers
# back into vowels according to the same pattern shown above.
# For example, decode("h3 th2r2") would return "hi there".
# For the sake of simplicity, you can assume that any numbers passed into the function will correspond to vowels.
def encode(st):
    dict = {'a': '1', 'e': '2', 'i': '3', 'o': '4', 'u': '5'}
    return ''.join([dict[char] if char in dict else char for char in st])


def decode(st):
    dict = {'1': 'a', '2': 'e', '3': 'i', '4': 'o', '5': 'u'}
    return ''.join([dict[char] if char in dict else char for char in st])

# You can print your name on a billboard ad. Find out how much it will cost you.
# Each character has a default price of £30, but that can be different if you are given 2 parameters instead of 1.
# You can not use multiplier "*" operator.
# If your name would be Jeong-Ho Aristotelis, ad would cost £600. 20 leters * 30 = 600 (Space counts as a character).
def billboard(name, price=30):
    return sum(price for i in range(len(name)))

# Complete the function which converts a binary number (given as a string) to a decimal number.
def bin_to_decimal(inp):
    return int(inp, 2)

# Given an array/list of integers, find the Nth smallest element in the array.
# Notes
# Array/list size is at least 3.
# Array/list's numbers could be a mixture of positives , negatives and zeros.
# Repetition in array/list's numbers could occur, so don't remove duplications.
def nth_smallest(arr, pos):
    return sorted(arr)[pos-1]

# Implement String#digit? (in Java StringUtils.isDigit(String)),
# which should return true if given object is a digit (0-9), false otherwise.
def is_digit(n):
    return n in '0123456789' and n != ''

# Given a mixed array of number and string representations of integers, add up the non-string integers
# and subtract this from the total of the string integers.
# Return as a number.
def div_con(x):
    return sum(list(i if type(i) == int else 0 for i in x)) - sum(list(int(i) if type(i) == str else 0 for i in x ))

# A balanced number is a number where the sum of digits to the left of the middle digit(s)
# and the sum of digits to the right of the middle digit(s) are equal.
# If the number has an odd number of digits, then there is only one middle digit.
# (For example, 92645 has one middle digit, 6.) Otherwise, there are two middle digits.
# (For example, the middle digits of 1301 are 3 and 0.)
# The middle digit(s) should not be considered when determining whether a number is balanced or not,
# e.g. 413023 is a balanced number because the left sum and right sum are both 5.
# The task
# Given a number, find if it is balanced, and return the string "Balanced" or "Not Balanced" accordingly.
# The passed number will always be positive.
def balanced_num(number):
    s = str(number)
    l = (len(s)-1)//2
    same = len(s) < 3 or sum(map(int, s[:l])) == sum(map(int, s[-l:]))
    return "Balanced" if same else "Not Balanced"

# A number is called Automorphic number if and only if its square ends in the same digits as the number itself.
# Task
# Given a number determine if it Automorphic or not .
def automorphic(n):
    return 'Automorphic' if str(n**2).count(str(n)) else 'Not!!'

# You live in the city of Cartesia where all roads are laid out in a perfect grid.
# You arrived ten minutes too early to an appointment, so you decided to take the opportunity
# to go for a short walk. The city provides its citizens with a Walk Generating App on
# their phones -- everytime you press the button it sends you an array of one-letter
# strings representing directions to walk (eg. ['n', 's', 'w', 'e']).
# You always walk only a single block for each letter (direction)
# and you know it takes you one minute to traverse one city block,
# so create a function that will return true if the walk the app gives you
# will take you exactly ten minutes (you don't want to be early or late!) and will,
# of course, return you to your starting point. Return false otherwise.
def is_valid_walk(walk):
    list = []
    dict = {'n': 's', 's': 'n',
           'e': 'w', 'w': 'e'}
    if len(walk) == 10:
        for elem in walk:
            list.append(walk.count(elem) == walk.count(dict[elem]))
        print(list)
        return False not in list
    return False

# Write a function get_char() / getChar() which takes a number and returns the corresponding ASCII char for that value.
def get_char(c):
    return chr(c)

#Complete the function that takes two numbers as input,
# num and nth and return the nth digit of num (counting from right to left).
# Note
# If num is negative, ignore its sign and treat it as a positive value
# If nth is not positive, return -1
# Keep in mind that 42 = 00042. This means that findDigit(42, 5) would return 0
def find_digit(num, nth):
    return int(str(num)[-nth]) if nth <= len(str(num)) and nth > 0 else -1 if nth <= 0 else 0

# Write function parse_float which takes a string/list and returns a number
# or 'none' if conversion is not possible.
def parse_float(string):
    try: return float(string)
    except Exception:
        return None

# Your task, is to create NxN multiplication table, of size provided in parameter.
def multiplication_table(size):
    return [[i * n for i in range(1, size + 1)] for n in range(1, size + 1)]

# Your task is to return the correct string using the Template String Feature.
def temple_strings(obj, feature):
    return f"{obj} are {feature}"

# Count the number of occurrences of each character
# and return it as a (list of tuples) in order of appearance. For empty output return (an empty list).
# Consult the solution set-up for the exact data structure implementation depending on your language.
import collections
def ordered_count(inp):
    return list(collections.Counter(inp).items())

# Modify the spacify function so that it returns the given string with spaces inserted between each character.
def spacify(string):
    return " ".join(string)

# Your boss decided to save money by purchasing some cut-rate optical character
# recognition software for scanning in the text of old novels to your database.
# At first it seems to capture words okay, but you quickly notice that it throws
# in a lot of numbers at random places in the text.
def string_clean(s):
    return ''.join('' if ch.isdigit() else ch for ch in s)

# iven an array/list [] of n integers , find maximum triplet sum in the array Without duplications .
# Notes :
# Array/list size is at least 3 .
# Array/list numbers could be a mixture of positives , negatives and zeros .
# Repetition of numbers in the array/list could occur , So (duplications are not included when summing).
def max_tri_sum(numbers):
    return sum(list(sorted(set(numbers), reverse = True))[:3])

# The word i18n is a common abbreviation of internationalization
# in the developer community, used instead of typing the whole word
# and trying to spell it correctly. Similarly, a11y is an abbreviation of accessibility.
# Write a function that takes a string and turns any and all "words"
# (see below) within that string of length 4 or greater into an abbreviation, following these rules:
# A "word" is a sequence of alphabetical characters. By this definition,
# any other character like a space or hyphen (eg. "elephant-ride")
# will split up a series of letters into two words (eg. "elephant" and "ride").
# The abbreviated version of the word should have the first letter,
# then the number of removed characters, then the last letter (eg. "elephant ride" => "e6t r2e").
def abbreviate(s):
    word = ""
    sentence = []
    result = []
    for i in s:
        if i.isalpha():
            word += i
        else:
            sentence.append(word)
            sentence.append(i)
            word = ""
            continue
    if word:
        sentence.append(word)
    for i in sentence:
        if len(i) >= 4:
            result += i[0] + str(len(i)-2) + i[-1]
        else:
            result += i
    return "".join(result)

# Create a function called shortcut to remove the lowercase vowels (a, e, i, o, u ) in a given string.
def shortcut( s ):
    return ''.join([i if i not in 'aeoiu' else '' for i in s])

# Philip's just turned four and he wants to know how old he will be
# in various years in the future such as 2090 or 3044.
# His parents can't keep up calculating this so they've begged
# you to help them out by writing a programme that can answer Philip's endless questions.
# Your task is to write a function that takes two parameters:
# the year of birth and the year to count years in relation to.
# As Philip is getting more curious every day he may soon want to know how many years
# it was until he would be born, so your function needs to work with both dates in the future and in the past.
# Provide output in this format: For dates in the future:
# "You are ... year(s) old." For dates in the past: "You will be born in ... year(s)."
# If the year of birth equals the year requested return: "You were born this very year!"
# "..." are to be replaced by the number, followed and proceeded by a single space.
# Mind that you need to account for both "year" and "years", depending on the result.
def calculate_age(year_of_birth, current_year):
    return f"You are {current_year - year_of_birth} {'year' if current_year - year_of_birth == 1 else 'years'} old."\
        if year_of_birth < current_year else\
        f"You will be born in {year_of_birth - current_year}" \
        f" {'year' if year_of_birth - current_year == 1 else 'years'}." \
            if year_of_birth > current_year else 'You were born this very year!'

# Reverse every other word in a given string, then return the string.
# Throw away any leading or trailing whitespace, while ensuring there
# is exactly one space between each word. Punctuation marks should be
# treated as if they are a part of the word in this kata.
def reverse_alternate(s):
    list = s.split()
    for elem in list[1::2]:
        word = elem[::-1]
        list.insert(list.index(elem), word)
        list.remove(elem)
    return ' '.join(list)

# This is the first step to understanding FizzBuzz.
# Your inputs: a positive integer, n, greater than or equal to one.
# n is provided, you have NO CONTROL over its value.
# Your expected output is an array of positive integers from 1 to n (inclusive).
# Your job is to write an algorithm that gets you from the input to the output.
def pre_fizz(n):
    return [i for i in range(1, n + 1)]

# You'll be given a string, and have to return the sum of all characters as an int.
# The function should be able to handle all ASCII characters.
def uni_total(s):
    return sum(ord(i) for i in s)

# Complete the function that calculates the area of the red square,
# when the length of the circular arc A is given as the input. Return the result rounded to two decimals.
from math import pi

def square_area(A):
    return round((2 * A / pi) ** 2, 2)

# Write a function called sortGiftCode/sort_gift_code/SortGiftCode that accepts
# a string containing up to 26 unique alphabetical characters, and returns
# a string containing the same characters in alphabetical order.
def sort_gift_code(code):
    return "".join(sorted(code))

# Your task is to complete this Class, the Person class has been created.
# You must fill in the Constructor method to accept a name as string and an age as number,
# complete the get Info property and getInfo method/Info getter which should return johns age is 34
class Person:
    def __init__(self, name, age):
        self.info = f"{name}s age is {age}"

# Given a string of words (x), you need to return an array of the words,
# sorted alphabetically by the final character in each.
# If two words have the same last letter, they returned array should show
# them in the order they appeared in the given string.
def last(s):
    return sorted(s.split(), key=lambda x: x[-1])

# Given an array of integers , Find the maximum product obtained from multiplying 2 adjacent numbers in the array.
def adjacent_element_product(array):
    return max(a * b for a, b in zip(array, array[1:]))

# Write a small function that returns the values of an array that are not odd.
# All values in the array will be integers. Return the good values in the order they are given.
def no_odds(values):
    return [i for i in values if i % 2 == 0]

# You are given a string containing a sequence of character sequences separated by commas.
# Write a function which returns a new string containing the same character sequences except
# the first and the last ones but this time separated by spaces.
# If the input string is empty or the removal of the first
# and last items would cause the resulting string to be empty,
# return an empty value (represented as a generic value NULL in the examples below).
def array(string):
    return ' '.join(string.split(',')[1:-1]) or None

# Complete the function which returns the weekday according to the input number:
# Otherwise returns "Wrong, please enter a number between 1 and 7"
def whatday(num):
    dict = {1: 'Sunday', 2: 'Monday', 3: 'Tuesday',
            4: 'Wednesday', 5: 'Thursday', 6: 'Friday', 7: 'Saturday'}
    return dict[num] if num in dict else 'Wrong, please enter a number between 1 and 7'

# Write a function, persistence, that takes in a positive parameter num
# and returns its multiplicative persistence, which is the numbe
# r of times you must multiply the digits in num until you reach a single digit.
def persistence(n):
    count = 0
    integer = 1
    while len(str(n)) > 1:
        count += 1
        for elem in str(n):
            integer *= int(elem)
        n = integer
        integer = 1
    return count

# Create a function named (combine_names) that accepts two parameters
# (first and last name). The function should return the full name.
def combine_names(first, last):
    return first + ' ' + last

# Don Drumphet lives in a nice neighborhood,
# but one of his neighbors has started to let his house go.
# Don Drumphet wants to build a wall between his house and his neighbor’s,
# and is trying to get the neighborhood association to pay for it.
# He begins to solicit his neighbors to petition to get the association to build the wall.
# Unfortunately for Don Drumphet, he cannot read very well, has a very limited attention span,
# and can only remember two letters from each of his neighbors’ names. As he collects signatures,
# he insists that his neighbors keep truncating their names until two letters remain, and he can finally read them.
# Your code will show Full name of the neighbor and the truncated version of the name as an array.
# If the number of the characters in name is less than or equal to two,
# it will return an array containing only the name as is"
def who_is_paying(name):
    return [name,name[:2]] if len(name) > 2 else [name]

# A Tidy number is a number whose digits are in non-decreasing order.
# Task
# Given a number, Find if it is Tidy or not .
def tidyNumber(n):
    return sorted([int(i) for i in str(n)]) == [int(i) for i in str(n)]

# In John's car the GPS records every s seconds the distance travelled from an origin
# (distances are measured in an arbitrary but consistent unit). For example, below is part of a record with s = 15:
# x = [0.0, 0.19, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25]
# The sections are:
# 0.0-0.19, 0.19-0.5, 0.5-0.75, 0.75-1.0, 1.0-1.25, 1.25-1.50, 1.5-1.75, 1.75-2.0, 2.0-2.25
# We can calculate John's average hourly speed on every section and we get:
# [45.6, 74.4, 60.0, 60.0, 60.0, 60.0, 60.0, 60.0, 60.0]
# Given s and x the task is to return as an integer the *floor* of the maximum average
# speed per hour obtained on the sections of x. If x length is less than
# or equal to 1 return 0 since the car didn't move.
# Example:
# with the above data your function gps(s, x)should return 74
def gps(s, x):
    speed = []
    lenght = 0
    for elem in x:
        speed.append(3600 * (elem - lenght) / s)
        lenght = elem
    return max(speed) if len(x) > 0 else 0

# In this Kata your task will be to return the count of pairs that have consecutive numbers as follows:
def pairs(ar):
    counter = 0
    for i in range(0, len(ar)-1,2):
        if i+1 > len(ar):
            break
        elif abs(ar[i] - ar[i+1]) == 1:
            counter += 1
    return counte

# Create a function that finds the integral of the expression passed.
# In order to find the integral all you need to do is add one to the exponent (the second argument),
# and divide the coefficient (the first argument) by that new number.
# For example for 3x^2, the integral would be 1x^3: we added 1 to the exponent,
# and divided the coefficient by that new number).
def integrate(coefficient, exponent):
    return f"{int(coefficient / (exponent+1))}x^{exponent+1}"

# Given a lowercase string that has alphabetic characters only and no spaces,
# return the highest value of consonant substrings. Consonants are any letters of the alphabet except "aeiou".
# We shall assign the following values: a = 1, b = 2, c = 3, .... z = 26.
import string
def solve(s):
    streakCounter = 0
    tempCounter = 0
    streakList = []
    alphDict = dict(zip(string.ascii_lowercase, [num for num in range(1, 27, 1)]))
    for i in list(alphDict):
        if i in list('aeiou'):
            alphDict.pop(i)
        else:
            pass
    for sym in s:
        if sym in list(alphDict):
            streakCounter += 1
            tempCounter += alphDict[sym]
        else:
            if streakCounter > 0:
                streakList.append(tempCounter)
                tempCounter = 0
                streakCounter = 0
            else:
                pass
    return max(streakList)

# Given a non-negative integer n, write a function to_binary/ToBinary which returns that number in a binary format.
def to_binary(n):
    return int(bin(n)[2:])

# Strong number is the number that the sum of the factorial of its digits is equal to number itself.
# For example, 145 is strong, since 1! + 4! + 5! = 1 + 24 + 120 = 145.
# Task
# Given a number, Find if it is Strong or not and return either "STRONG!!!!" or "Not Strong !!".
from math import factorial
def strong_num(number):
    return 'STRONG!!!!' if sum(factorial(int(i)) for i in str(number)) == number else 'Not Strong !!'

# Create a class Ball. Ball objects should accept one argument for "ball type" when instantiated.
# If no arguments are given, ball objects should instantiate with a "ball type" of "regular."
class Ball(object):
  def __init__(self, type = "regular"):
    self.ball_type = type

# For this problem you must create a program that says who ate the last cookie.
# If the input is a string then "Zach" ate the cookie.
# If the input is a float or an int then "Monica" ate the cookie.
# If the input is anything else "the dog" ate the cookie.
# The way to return the statement is: "Who ate the last cookie? It was (name)!"
# Ex: Input = "hi" --> Output = "Who ate the last cookie? It was Zach!
# (The reason you return Zach is because the input is a string)
# Note: Make sure you return the correct message with correct spaces and punctuation.
# Please leave feedback for this kata. Cheers!
def cookie(x):
    if type(x) is str: return "Who ate the last cookie? It was Zach!"
    if type(x) is int or type(x) is float: return "Who ate the last cookie? It was Monica!"
    return "Who ate the last cookie? It was the dog!"

# You probably know that number 42 is "the answer to life, the universe
# and everything" according to Douglas Adams' "The Hitchhiker's Guide to the Galaxy".
# For Freud, the answer was quite different...
# In the society he lived in, people - women in particular - had to repress their
# sexual needs and desires. This was simply how the society was at the time.
# Freud then wanted to study the illnesses created by this,
# and so he digged to the root of their desires. This led to some
# of the most important psychoanalytic theories to this day, Freud being the father of psychoanalysis.
# Now, basically, when a person hears about Freud, s/he hears "sex" because for Freud,
# everything was related to, and explained by sex.
# In this kata, the function will take a string as its argument,
# and return a string with every word replaced by the explanation to everything,
# according to Freud. Note that an empty string, or no arguments, should return an empty string.
def to_freud(sentence):
    return ' '.join(['sex'] * len(sentence.split()))

# Remove the duplicates from a list of integers, keeping the last ( rightmost ) occurrence of each element.
def solve(arr):
    return list(dict.fromkeys(arr[::-1]))[::-1]

# Oh, no! The number has been mixed up with the text.
# Your goal is to retrieve the number from the text, can you return the number back to its original state?
# Task
# Your task is to return a number from a string.
def filter_string(string):
    return int(''.join(i for i in string if i.isdigit()))

# Given an array/list [] of integers , Find the product of the k maximal numbers.
# Notes
# Array/list size is at least 3 .
# Array/list's numbers Will be mixture of positives , negatives and zeros
# Repetition of numbers in the array/list could occur.
def max_product(lst, n_largest_elements):
    mul = 1
    for n in sorted(lst, reverse=True)[:n_largest_elements]:
        mul *= n
    return mul

# To complete this Kata you need to make a function multiplyAll/multiply_all which takes
# an array of integers as an argument. This function must return another function,
# which takes a single integer as an argument and returns a new array.
# The returned array should consist of each of the elements from the first array multiplied by the integer.
def multiply_all(arr):
    def multiply(num):
        return [num * elem for elem in arr]
    return multiply

# This series of katas will introduce you to basics of doing geometry with computers.
# Point objects have x and y attributes (X and Y in C#) attributes.
# Write a function calculating distance between Point a and Point b.
def distance_between_points(a, b):
    return ((b.x - a.x) ** 2 + (b.y - a.y) ** 2) ** 0.5

# Your task is to find the nearest square number, nearest_sq(n), of a positive integer n.
import math
def nearest_sq(n):
    return round(math.sqrt(n))**2

# Color Ghost
# Create a class Ghost
# Ghost objects are instantiated without any arguments.
# Ghost objects are given a random color attribute of "white" or "yellow" or "purple" or "red" when instantiated
import random
class Ghost(object):
  def __init__(self):
    self.color = random.choice(["white", "yellow", "purple", "red"])

# You are creating a text-based terminal version of your favorite board game.
# In the board game, each turn has six steps that must happen in this order:
# roll the dice, move, combat, get coins, buy more health, and print status.
from preloaded import *
health, position, coins = 100, 0, 0
def main(): pass
log = 'roll_dice move combat get_coins buy_health print_status'.split()

# Input:
# a string strng
# an array of strings arr
# Output of function contain_all_rots(strng, arr) (or containAllRots or contain-all-rots):
# a boolean true if all rotations of strng are included in arr
# false otherwise
def contain_all_rots(strng, arr):
    rotate = strng
    if not len(arr) or not strng:
        return True
    for index in range(len(strng)):
        if rotate  not in arr:
            return False
        first_letter = rotate[0]
        rotate = rotate[1:]
        rotate += first_letter
    return True

# Given a string, turn each character into its ASCII character code
# and join them together to create a number - let's call this number total1:
# 'ABC' --> 'A' = 65, 'B' = 66, 'C' = 67 --> 656667
# Then replace any incidence of the number 7 with the number 1, and call this number 'total2':
# total1 = 656667
#               ^
# total2 = 656661
#               ^
# Then return the difference between the sum of the digits in total1 and total2:
def calc(x):
    word= ''.join([str(ord(i)) for i in x])
    word1 = ''.join([str(ord(i)) for i in x]).replace('7', '1')
    return sum(int(i) for i in word) - sum(int(i) for i in word1)

# An element is leader if it is greater than The Sum all the elements to its right side.
# Task
# Given an array/list [] of integers , Find all the LEADERS in the array.
def array_leaders(numbers):
    output = []
    for i in range(0, len(numbers)):
        if numbers[i] > sum(numbers[i+1:]):
            output.append(numbers[i])
    return output

# Our fruit guy has a bag of fruit (represented as an array of strings)
# where some fruits are rotten. He wants to replace all the rotten pieces of fruit with fresh ones.
# For example, given ["apple","rottenBanana","apple"] the replaced array should be ["apple","banana","apple"].
# Your task is to implement a method that accepts an array of strings containing fruits
# should returns an array of strings where all the rotten fruits are replaced by good ones.
# Notes
# If the array is null/nil/None or empty you should return empty array ([]).
# The rotten fruit name will be in this camelcase (rottenFruit).
# The returned array should be in lowercase.
def remove_rotten(bag_of_fruits):
    try:
        return [i.replace('rotten', '').lower() if 'rotten' in i else i.lower() for i in bag_of_fruits]
    except:
        return []

# You're on your way to the market when you hear beautiful music coming from a nearby street performer.
# The notes come together like you wouln't believe as the musician puts together patterns of tunes.
# As you wonder what kind of algorithm you could use to shift octaves by
# 8 pitches or something silly like that, it dawns on you that you have been watching
# the musician for some 10 odd minutes. You ask, "how much do people normally
# tip for something like this?" The artist looks up. "It's always gonna be about tree fiddy."
# It was then that you realize the musician was a 400 foot tall beast from the paleolithic era!
# The Loch Ness Monster almost tricked you!
# There are only 2 guaranteed ways to tell if you are speaking to The Loch Ness Monster:
# A) it is a 400 foot tall beast from the paleolithic era; B) it will ask you for tree fiddy.
# Since Nessie is a master of disguise, the only way accurately tell is to look for the phrase
# "tree fiddy". Since you are tired of being grifted by this monster,
# the time has come to code a solution for finding The Loch Ness Monster.
# Note that the phrase can also be written as "3.50" or "three fifty".
def is_lock_ness_monster(string):
    return True in [i in string for i in ['tree fiddy', '3.50', 'three fifty']]

# You task is to implement an simple interpreter for the notorious esoteric language HQ9+
# that will work for a single character input:
# If the input is 'H', return 'Hello World!'
# If the input is 'Q', return the input
# If the input is '9', return the full lyrics of 99 Bottles of Beer. It should be formatted like this:
LINES = "{0} of beer on the wall, {0} of beer.\nTake one down and pass it around, {1} of beer on the wall."
SONG = '\n'.join( LINES.format("{} bottles".format(n), "{} bottle".format(n-1)+"s"*(n!=2)) for n in range(99,1,-1) )
SONG += """
1 bottle of beer on the wall, 1 bottle of beer.
Take one down and pass it around, no more bottles of beer on the wall.
No more bottles of beer on the wall, no more bottles of beer.
Go to the store and buy some more, 99 bottles of beer on the wall."""
def HQ9(code):
    return {'H': 'Hello World!', 'Q': 'Q', '9': SONG}.get(code, None)
# Write a function that can return the smallest value of an array or the index of that value.
# The function's 2nd parameter will tell whether it should return the value or the index.
# Assume the first parameter will always be an array filled with at least 1 number and no duplicates.
# Assume the second parameter will be a string holding one of two values: 'value' and 'index'.
def find_smallest(numbers,to_return):
    return numbers.index(min(numbers)) if to_return == 'index' else min(numbers)

# There's a "3 for 2" (or "2+1" if you like) offer on mangoes.
# For a given quantity and price (per mango), calculate the total cost of the mangoes.
def mango(quantity, price):
    return (quantity - quantity // 3) * price

# Your colleagues have been looking over you shoulder.
# When you should have been doing your boring real job,
# you've been using the work computers to smash in endless hours of codewars.
# In a team meeting, a terrible, awful person declares to the group that you aren't working.
# You're in trouble. You quickly have to gauge the feeling in the room to decide whether
# or not you should gather your things and leave.
# Given an object (meet) containing team member names as keys, and their happiness rating out
# of 10 as the value, you need to assess the overall happiness rating of the group.
# If <= 5, return 'Get Out Now!'. Else return 'Nice Work Champ!'.
# Happiness rating will be total score / number of people in the room.
# Note that your boss is in the room (boss), their score is worth double it's face value
# (but they are still just one person!).
def outed(meet, boss):
    return 'Get Out Now!' if (sum(meet.values()) + meet[boss] ) / len(meet) <= 5 else 'Nice Work Champ!'

# The number n is Evil if it has an even number of 1's in its binary representation.
# The first few Evil numbers: 3, 5, 6, 9, 10, 12, 15, 17, 18, 20
# The number n is Odious if it has an odd number of 1's in its binary representation.
# The first few Odious numbers: 1, 2, 4, 7, 8, 11, 13, 14, 16, 19
# You have to write a function that determine if a number is Evil of Odious,
# function should return "It's Evil!" in case of evil number and "It's Odious!" in case of odious number.
def evil(n):
    return "It's Evil!" if  bin(n).count('1') % 2 == 0 else "It's Odious!"

# Every now and then people in the office moves teams or departments.
# Depending what people are doing with their time they can become more or less boring.
# Time to assess the current team.
# You will be provided with an object(staff) containing the staff names as keys,
# and the department they work in as values.
# Each department has a different boredom assessment score, as follows:
def boredom(staff):
    dict_score = {
        'accounts': 1,
        'finance': 2,
        'canteen': 10,
        'regulation': 3,
        'trading': 6,
        'change': 6,
        'IS': 8,
        'retail': 5,
        'cleaning': 4,
        'pissing about': 25
    }
    boredom_score = 0
    for v in staff.values():
        if v in dict_score:
            boredom_score += dict_score.get(v)
    return 'kill me now' if boredom_score <= 80 else 'i can handle this' if 80 < boredom_score < 100 else 'party time!!'

# You have access to the ship "draft" and "crew".
# "Draft" is the total ship weight and "crew" is the number of humans on the ship.
# Each crew member adds 1.5 units to the ship draft. If after removing the weight
# of the crew, the draft is still more than 20, then the ship is worth looting.
# Any ship weighing that much must have a lot of booty!
class Ship:
    def __init__(self, draft, crew):
        self.draft = draft
        self.crew = crew
    # Your code here
    def is_worth_it(self):
        return self.draft - self.crew * 1.5 > 20

# In this kata you will have to write a function that takes litres and price_per_litre (in dollar) as arguments.
# Purchases of 2 or more litres get a discount of 5 cents per litre, purchases of 4 or more litres get a discount
# of 10 cents per litre, and so on every two litres,
# up to a maximum discount of 25 cents per litre.
# But total discount per litre cannot be more than 25 cents.
# Return the total cost rounded to 2 decimal places.
# Also you can guess that there will not be negative or non-numeric inputs.
# Good Luck!
def fuel_price(litres, price_per_liter):
    discount = int(min(litres, 10)/2) * 5 / 100
    return round((price_per_liter - discount) * litres, 2)

# Given a string made up of letters a, b, and/or c, switch the position
# of letters a and b (change a to b and vice versa). Leave any incidence of c untouched.
def switcheroo(string):
    return string.replace('a', '-').replace('b', 'a').replace('-', 'b')

# ASC Week 1 Challenge 4 (Medium #1)
# Write a function that converts any sentence into a V A P O R W A V E sentence.
# a V A P O R W A V E sentence converts all the letters into uppercase,
# and adds 2 spaces between each letter (or special character)
# to create this V A P O R W A V E effect.
# Note that spaces should be ignored in this case.
def vaporcode(s):
    return '  '.join(i.upper() for i in s.replace(' ', ''))

# Create a method all which takes two params:
# a sequence
# a function (function pointer in C)
# and returns true if the function in the params returns true for every element in the sequence.
# Otherwise, it should return false. If the sequence is empty,
# it should return true, since technically nothing failed the test.
def _all(seq, fun):
    return all(fun(i) for i in seq)

# Write a function that calculates the original product price, without VAT.
def excluding_vat_price(price):
    return round(price - price / 115 * 15, 2) if price else -1

# Given an unsorted array of 3 positive integers [ n1, n2, n3 ],
# determine if it is possible to form a Pythagorean Triple using those 3 integers.
# A Pythagorean Triple consists of arranging 3 integers, such that:
# a2 + b2 = c2
def pythagorean_triple(integers):
    return sorted(integers)[0]**2 + sorted(integers)[1]**2 == sorted(integers)[2]**2

# Some new cashiers started to work at your restaurant.
# They are good at taking orders, but they don't know how to capitalize words, or use a space bar!
# All the orders they create look something like this:
# "milkshakepizzachickenfriescokeburgerpizzasandwichmilkshakepizza"
# The kitchen staff are threatening to quit, because of how difficult it is to read the orders.
# Their preference is to get the orders as a nice clean string with spaces and capitals like so:
# "Burger Fries Chicken Pizza Pizza Pizza Sandwich Milkshake Milkshake Coke"
# The kitchen staff expect the items to be in the same order as they appear in the menu.
# The menu items are fairly simple, there is no overlap in the names of the items:
def get_order(order):
    menu = ["Burger", "Fries", "Chicken", "Pizza", "Sandwich", "Onionrings", "Milkshake", "Coke"]
    return "".join([(i + " ") * order.count(i.lower()) for i in menu if i.lower() in order]).rstrip()

# Write a function reverse which reverses a list (or in clojure's case, any list-like data structure)
# (the dedicated builtin(s) functionalities are deactivated)
def reverse(lst):
    list1 = list()
    for elem in lst:
        list1.insert(0, elem)
    return list1

# According to the creation myths of the Abrahamic religions,
# Adam and Eve were the first Humans to wander the Earth.
# You have to do God's job. The creation method must return an array of length 2
# containing objects (representing Adam and Eve). The first object in the array should be
# an instance of the class Man. The second should be an instance of the class Woman.
# Both objects have to be subclasses of Human. Your job is to implement the Human, Man and Woman classes.
def God():
    return [Man(), Woman()]
class Human(object):
    pass
class Man(Human):
    pass
class Woman(Human):
    pass

# Make multiple functions that will return the sum,
# difference, modulus, product, quotient, and the exponent respectively.
# Please use the following function names:
def add(a,b):
  return a + b
def multiply(a,b):
  return a * b
def divide(a,b):
  return a / b
def mod(a,b):
  return a % b
def exponent(a,b):
  return a ** b
def subt(a,b):
  return a - b

# Some really funny web dev gave you a sequence of numbers from his API response as an sequence of strings!
# You need to cast the whole array to the correct type.
# Create the function that takes as a parameter a sequence of numbers represented
# as strings and outputs a sequence of numbers.
# ie:["1", "2", "3"] to [1, 2, 3]
# Note that you can receive floats as well.
def to_float_array(arr):
    return list(map(float, arr))

# Given a string made of digits [0-9], return a string where
# each digit is repeated a number of times equals to its value.
def explode(s):
    return ''.join(c * int(c) for c in s)

# Disarium number is the number that The sum of its digits powered
# with their respective positions is equal to the number itself.
# Task
# Given a number, Find if it is Disarium or not .
def disarium_number(number):
    return 'Disarium !!' if sum(int(i)**(int(j) + 1) for j, i in enumerate(str(number))) == number else 'Not !!'

# You will be given a string (x) featuring a cat 'C' and a mouse 'm'.
# The rest of the string will be made up of '.'.
# You need to find out if the cat can catch the mouse from it's current position.
# The cat can jump over three characters. So:
# C.....m returns 'Escaped!' <-- more than three characters between
# C...m returns 'Caught!' <-- as there are three characters between the two, the cat can jump.
def cat_mouse(x):
    return 'Escaped!' if x.count('.') > 3 else 'Caught!'

# Modify the kebabize function so that it converts a camel case string into a kebab case.
import re
def kebabize(string):
    return '-'.join(re.split('(?<=.)(?=[A-Z])', re.sub(r'[0-9]+', '', string))).lower()

# Given a string and an array of integers representing indices, capitalize all letters at the given indices.
# For example:
# capitalize("abcdef",[1,2,5]) = "aBCdeF"
# capitalize("abcdef",[1,2,5,100]) = "aBCdeF". There is no index 100.
# The input will be a lowercase string with no spaces and an array of digits.
# Good luck!
def capitalize(s,ind):
    list = [j for j in s]
    for i in ind:
        if i <= len(list):
            list[i] = list[i].upper()
    return ''.join(list)

# John has invited some friends. His list is:

# s = "Fred:Corwill;Wilfred:Corwill;Barney:Tornbull;Betty:Tornbull;Bjon:Tornbull;Raphael:Corwill;Alfred:Corwill";
# Could you make a program that
# makes this string uppercase
# gives it sorted in alphabetical order by last name.
# When the last names are the same, sort them by first name.
# Last name and first name of a guest come in the result between parentheses separated by a comma.
# So the result of function meeting(s) will be:
# "(CORWILL, ALFRED)(CORWILL, FRED)(CORWILL, RAPHAEL)
# (CORWILL, WILFRED)(TORNBULL, BARNEY)(TORNBULL, BETTY)(TORNBULL, BJON)"
def meeting(s):
    return ''.join(sorted('({1}, {0})'.format(*(x.split(':'))) for x in s.upper().split(';')))

# You probably know the "like" system from Facebook and other pages. People can "like" blog posts,
# pictures or other items. We want to create the text that should be displayed next to such an item.
# Implement the function which takes an array containing the names of people that like an item.
# It must return the display text as shown in the examples:
def likes(names):
    if len(names) >= 4:
        return ', '.join(names[:2]) + f" and {len(names[2:])} others like this"
    elif 1 < len(names) < 4:
        return ', '.join(names[:-1]) + f" and {names[-1]} like this"
    return f"{'no one' if len(names) == 0 else names[0]} likes this"

# Write a function called calculate that takes 3 values.
# The first and third values are numbers. The second value is a character.
# If the character is "+" , "-", "*", or "/", the function will
# return the result of the corresponding mathematical function on the two numbers.
# If the string is not one of the specified characters, the function should return
# null (throw an ArgumentException in C#).
# Keep in mind, you cannot divide by zero. If an attempt to divide by zero is made,
# return null (throw an ArgumentException in C#)/(None in Python).
def calculate(num1, operation, num2):
    dict = {'+': num1 + num2, '-': num1 - num2,
           '*': num1 * num2, '/': num1 / num2 if num1 !=0 and num2 !=0 else None}
    return dict[operation] if operation in dict else None

# Write a method that takes one argument as name
# and then greets that name, capitalized and ends with an exclamation point.
def greet(name):
    return f'Hello {name.title()}!'

# In this first kata in the series, you need to define a Hero prototype
# to be used in a terminal game. The hero should have the following attributes:
class Hero(object):
    def __init__(self, name='Hero', position='00', health=100, damage=5, experience=0):
        self.name = name
        self.position = position
        self.health = health
        self.damage = damage
        self.experience = experience

# Add the value "codewars" to the websites array.
# After your code executes the websites array should == ["codewars"]
# The websites array has already been defined for you using the following code:
websites.append("codewars")

# Friday 13th or Black Friday is considered as unlucky day. Calculate how many unlucky days are in the given year.
# Find the number of Friday 13th in the given year.
import calendar
def unlucky_days(year):
	return sum(calendar.weekday(year, m, 13) == 4 for m in range(1, 13))

# There are 32 letters in the Polish alphabet: 9 vowels and 23 consonants.
def correct_polish_letters(st):
    dict = {'ą':'a', 'ć':'c', 'ę':'e', 'ł':'l', 'ń':'n', 'ó':'o', 'ś':'s', 'ź':'z', 'ż':'z'}
    return ''.join(dict[i] if i in dict else i for i in st)

# Your task is to write a function toLeetSpeak that converts a regular english sentence to Leetspeak.
#More about LeetSpeak You can read at wiki -> https://en.wikipedia.org/wiki/Leet
# Consider only uppercase letters (no lowercase letters, no numbers) and spaces.
def to_leet_speak(str):
    dict = {'A' : '@',  'B' : '8',  'C' : '(',  'D' : 'D',  'E' : '3',  'F' : 'F',  'G' : '6',
            'H' : '#',  'I' : '!',  'J' : 'J', 'K' : 'K',  'L' : '1',  'M' : 'M',
            'N' : 'N',  'O': '0',  'P' : 'P',  'Q' : 'Q',  'R' : 'R',  'S' : '$',
            'T' : '7',  'U' : 'U',  'V' : 'V',  'W' : 'W',  'X' : 'X',  'Y' : 'Y',  'Z' : '2', ' ': ' '}
    return ''.join(dict[i] for i in str)

# Given a string, write a function that returns the string
# with a question mark ("?") appends to the end, unless the original
# string ends with a question mark, in which case, returns the original string.
def ensure_question(s):
    return s if s.endswith('?') else s + '?'

# Given a string s. You have to return another string such that
# even-indexed and odd-indexed characters of s are grouped and groups are space-separated (see sample below)
def sort_my_string(s):
    return s[::2] + ' ' + s[1::2]

# Given an input of an array of digits, return the array with each digit incremented
# by its position in the array: the first digit will be incremented by 1,
# the second digit by 2, etc. Make sure to start counting your positions from 1 ( and not 0 ).
# Your result can only contain single digit numbers, so if adding a digit
# with its position gives you a multiple-digit number, only the last digit of the number should be returned.
# Notes:
# return an empty array if your array is empty
# arrays will only contain numbers so don't worry about checking that
def incrementer(nums):
    return [i+j+1 if i+j+1<10 else int(str(i+j+1)[-1]) for i,j in enumerate(nums)]

# Given a string "abc" and assuming that each letter in the string
# has a value equal to its position in the alphabet, our string
# will have a value of 1 + 2 + 3 = 6. This means that: a = 1, b = 2, c = 3 ....z = 26.
# You will be given a list of strings and your task will be to return the values of the
# strings as explained above multiplied by the position of that string in the list.
# For our purpose, position begins with 1.
# nameValue ["abc","abc abc"] should return [6,24] because of [ 6 * 1, 12 * 2 ]. Note how spaces are ignored.
# "abc" has a value of 6, while "abc abc" has a value of 12. Now, the value at position 1 is multiplied
# by 1 while the value at position 2 is multiplied by 2.
# Input will only contain lowercase characters and spaces.
# Good luck!
def name_value(my_list):
    return [sum(ord(k)-96 if k.isalpha() else 0 for k in j) * (i+1) for i, j in enumerate(my_list)]

# Write function alternateCase which switch every letter in string
# from upper to lower and from lower to upper. E.g: Hello World -> hELLO wORLD
def alternateCase(s):
    return s.swapcase()

# Write a function that accepts two arguments and generates a sequence
# containing the integers from the first argument to the second inclusive.
# Input
# Pair of integers greater than or equal to 0. The second argument will always be greater than or equal to the first.
def generate_integers(m, n):
    return [i for i in range(m,n+1)]

# Write a function
# vowel_2_index
# that takes in a string and replaces all the vowels [a,e,i,o,u]
# with their respective positions within that string.
# E.g:
def vowel_2_index(string):
    return ''.join(str(i+1) if j.lower() in 'aeiou' else j for i, j in enumerate(string))

# A variation of determining leap years, assuming only integers are used and years can be negative and positive.
# Write a function which will return the days in the year and the year entered in a string. For example:
import calendar
def year_days(year):
    return f"{year} has {366 if calendar.isleap(abs(year)) else 365} days"

# Born a misinterpretation of this kata, your task here is pretty simple:
# given an array of values and an amount of beggars, you are supposed to
# return an array with the sum of what each beggar brings home, assuming they
# all take regular turns, from the first to the last.
# For example: [1,2,3,4,5] for 2 beggars will return a result of [9,6],
# as the first one takes [1,3,5], the second collects [2,4].
# The same array with 3 beggars would have in turn have produced a better
# out come for the second beggar: [5,7,3], as they will respectively take [1,4], [2,5] and [3].
# Also note that not all beggars have to take the same amount of "offers", meaning that the length
# of the array is not necessarily a multiple of n; length can be even shorter,
# in which case the last beggars will of course take nothing (0).
# Note: in case you don't get why this kata is about English beggars,
# then you are not familiar on how religiously queues are taken in the kingdom ;)
# Note 2: do not modify the input array.
def beggars(values, n):
    return [sum(values[i::n]) for i in range(n)]

# Mothers arranged a dance party for the children in school. At that party,
# there are only mothers and their children. All are having great fun on the
# dance floor when suddenly all the lights went out.
# It's a dark night and no one can see each other.
# But you were flying nearby and you can see in the dark and have ability to teleport people anywhere you want.
# Legend:
# -Uppercase letters stands for mothers, lowercase stand for their children, i.e. "A" mother's children are "aaaa".
# -Function input: String contains only letters, uppercase letters are unique.
# Task:
# Place all people in alphabetical order where Mothers are followed by their children, i.e. "aAbaBb" => "AaaBbb".
def find_children(dancing_brigade):
    list = sorted(set([i.lower() for i in dancing_brigade]))
    return ''.join(i.upper() + i * dancing_brigade.count(i) for i in list)

# Implement a function, multiples(m, n), which returns
# an array of the first m multiples of the real number n. Assume that m is a positive integer.
def multiples(m, n):
    return [i * n for i in range(1, m+1)]

# Jumping number is the number that All adjacent digits in it differ by 1.
# Task
# Given a number, Find if it is Jumping or not .
def jumping_number(number):
    number = list(str(number))
    for i in range(0, len(number)-1):
        if abs(int(number[i+1])-int(number[i])) != 1:
            return 'Not!!'
    return 'Jumping!!'

# In this Kata you are expected to find the coefficients
# of quadratic equation of the given two roots (x1 and x2).
# Equation will be the form of ax^2 + bx + c = 0
# Return type is a Vector (tuple in Rust, Array in Ruby)
# containing coefficients of the equations in the order (a, b, c).
# Since there are infinitely many solutions to this problem, we fix a = 1.
# Remember, the roots can be written like (x-x1) * (x-x2) = 0
def quadratic(x1, x2):
    return (1, -(x1 + x2), x1 * x2)

# Find the difference between the sum of the squares of the first n natural
# numbers (1 <= n <= 100) and the square of their sum.
# Example
# For example, when n = 10:
# The square of the sum of the numbers is:
# (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10)2 = 552 = 3025
# The sum of the squares of the numbers is:
# 12 + 22 + 32 + 42 + 52 + 62 + 72 + 82 + 92 + 102 = 385
def difference_of_squares(n):
    return sum([i for i in range(1,n+1)])**2 - sum([i**2 for i in range(1, n+1)])

# You are creating an "Escape the room" game.
# The first step is to create a hash table called rooms that contains
# all of the rooms of the game. There should be at least 3 rooms inside it,
# each being a hash table with at least three properties (e.g. name, description, completed).
rooms = {
    'room1': {
    'name': 'Peter', 'description': 'python', 'completed': False },
    'room2': {
    'name': 'Ivan', 'description': 'js', 'completed': True },
    'room3': {
    'name': 'Pasha', 'description': 'golang', 'completed': True }
        }

# This Kata is intended as a small challenge for my students
# All Star Code Challenge #22
# Create a function that takes an integer argument of seconds
# and converts the value into a string describing how many hours and minutes comprise that many seconds.
# Any remaining seconds left over are ignored.
# Note:
# The string output needs to be in the specific form - "X hour(s) and X minute(s)"
def to_time(seconds):
    return f'{seconds//3600} hour(s) and {(seconds//60)%60} minute(s)'

# Write a function to get the first element(s) of a sequence.
# Passing a parameter n (default=1) will return the first n element(s) of the sequence.
# If n == 0 return an empty sequence []
def first(seq, n=1):
    return seq[:n] if seq else []

# Have you heard about the myth that if you fold a paper enough times, you can reach the moon with it?
# Sure you have, but exactly how many? Maybe it's time to write a program to figure it out.
# You know that a piece of paper has a thickness of 0.0001m. Given distance in units of meters,
# calculate how many times you have to fold the paper to make the paper reach this distance.
# (If you're not familiar with the concept of folding a paper: Each fold doubles its total thickness.)
# Note: Of course you can't do half a fold. You should know what this means ;P
# Also, if somebody is giving you a negative distance, it's clearly bogus
# and you should yell at them by returning null (or whatever equivalent in your language).
# In Shell please return None. In C and COBOL please return -1.
def fold_to(distance):
    if distance < 0:
        return None
    count = 0
    paper = 0.0001
    while paper < distance:
        count += 1
        paper = paper * 2
    return count

# We need to write some code to return the original price of a product,
# the return type must be of type decimal and the number must be rounded to two decimal places.
# We will be given the sale price (discounted price), and the sale percentage,
# our job is to figure out the original price.
def discover_original_price(discounted_price, sale_percentage):
    return round(discounted_price / (100 - sale_percentage) * 100, 2)

# Compare two strings by comparing the sum of their values (ASCII character code).
# For comparing treat all letters as UpperCase
# null/NULL/Nil/None should be treated as empty strings
# If the string contains other characters than letters, treat the whole string as it would be empty
# Your method should return true, if the strings are equal and false if they are not equal.
def compare(s1,s2):
    if not s1 and not s2:
        return True
    if any(x for x in s1 if not x.isalpha()):
        s1 = ''
    if any(x for x in s2 if not x.isalpha()):
        s2 = ''
    return sum(ord(x.upper()) for x in s1) == sum(ord(x.upper()) for x in s2)

# This function takes two numbers as parameters, the first number
# being the coefficient, and the second number being the exponent.
# Your function should multiply the two numbers, and then subtract 1 from the exponent.
# Then, it has to print out an expression (like 28x^7). "^1" should not be truncated when exponent = 2.
def derive(coefficient, exponent):
    return f"{coefficient*exponent}x^{exponent-1 if exponent >2 else exponent}"

# Consider the word "abode". We can see that the letter a is in position 1
# and b is in position 2. In the alphabet, a and b are also in positions 1 and 2.
# Notice also that d and e in abode occupy the positions they would occupy in the alphabet,
# which are positions 4 and 5.
# Given an array of words, return an array of the number of letters that occupy their
# positions in the alphabet for each word.
def solve(arr):
    output = []
    for str in arr:
        str = list(map(lambda x: ord(x.lower())-96, list(str)))
        str = list(map(lambda x: x[0] == x[1], zip(str, range(1,len(str)+1))))
        output.append(str.count(True))
    return output

# Find the length of the longest substring in the given string s that is the same in reverse.
# As an example, if the input was “I like racecars that go fast”, the substring (racecar) length would be 7.
# If the length of the input string is 0, the return value must be 0.
def longest_palindrome (s):
    if(len(s) == 0):
        return 0
    results = set()
    string_length = len(s)
    for i, char in enumerate(s):
        start, end = i-1, i+1
        while start >=0 and end < string_length and s[start] == s[end]:
            results.add(s[start:end+1])
            start -= 1
            end += 1
        start, end = i, i + 1
        while start >= 0 and end < string_length and s[start] == s[end]:
            results.add(s[start:end+1])
            start -= 1
            end += 1
    lst = sorted(list(results), key=len)
    if(len(lst) == 0):
        return 1
    else:
        return len(lst[-1])

# Given a string, return a new string that has transformed based on the input:
# Change case of every character, ie. lower case to upper case, upper case to lower case.
# Reverse the order of words from the input.
# Note: You will have to handle multiple spaces, and leading/trailing spaces.
def string_transformer(s):
    return ' '.join(s.swapcase().split(' ')[::-1])

# In this Kata, you will be given two strings a and b
# and your task will be to return the characters that are not common in the two strings.
def solve(a,b):
    return ''.join(i if i not in b else '' for i in a) + ''.join(i if i not in a else '' for i in b)
#set(a)^(set(b))

# Create a method sayHello/say_hello/SayHello that takes as input a name, city,
# and state to welcome a person. Note that name will be an array consisting of one
# or more values that should be joined together with one space between each,
# and the length of the name array in test cases will vary.
def say_hello(name, city, state):
    return f"Hello, {' '.join(i for i in name)}! Welcome to {city}, {state}!"

# A sequence or a series, in mathematics, is a string of objects, like numbers,
# that follow a particular pattern. The individual elements in a sequence are called terms.
# A simple example is 3, 6, 9, 12, 15, 18, 21, ..., where the pattern is: "add 3 to the previous term".
# In this kata, we will be using a more complicated sequence: 0, 1, 3, 6, 10, 15, 21, 28,
# ... This sequence is generated with the pattern: "the nth term is the sum of numbers from 0 to n, inclusive".
def sum_of_n(n):
    if n < 0:
        return sorted([sum(x for x in range(i,1)) for i in range(n, 1)])[::-1]
    return [sum([x for x in range(i+1)]) for i in range(n+1)]

# Wilson primes satisfy the following condition. Let P represent a prime number.
# Then,
# ((P-1)! + 1) / (P * P)
# should give a whole number.
# Your task is to create a function that returns true if the given number is a Wilson prime.
def am_i_wilson(n):
    list = [5, 13, 563, 5971, 558771, 1964215, 8121909,
            12326713, 23025711, 26921605, 341569806, 399292158]
    return n in list

# This kata is about converting numbers to their binary or hexadecimal representation:
# If a number is even, convert it to binary.
# If a number is odd, convert it to hex.
# Numbers will be positive. The hexadecimal string should be lowercased.
def evens_and_odds(n):
    return bin(n)[2:] if n%2 == 0 else hex(n)[2:]

# Given an array/list [] of integers ,
# Find The maximum difference between the successive elements in its sorted form.
# Notes
# Array/list size is at least 3 .
# Array/list's numbers Will be mixture of positives and negatives also zeros_
# Repetition of numbers in the array/list could occur.
# The Maximum Gap is computed Regardless the sign.
import numpy as np
def max_gap(numbers):
    numbers = np.array(sorted(numbers))
    return np.max(numbers[1:]-numbers[:-1])

# Welcome to the Codewars Bar!
# Codewars Bar recommends you drink 1 glass of water per standard drink so you're not hungover tomorrow morning.
# Your fellow coders have bought you several drinks tonight in the form of a string.
# Return a string suggesting how many glasses of water you should drink to not be hungover.
def hydrate(drink_string):
    s = sum([int(i) if i.isdigit() else 0 for i in drink_string])
    return f"{s} {'glass' if s == 1 else 'glasses'} of water"

# Every Friday and Saturday night, farmer counts amount of sheep returned back to his farm
# (sheep returned on Friday stay and don't leave for a weekend).
# Sheep return in groups each of the days -> you will be given two arrays
# with these numbers (one for Friday and one for Saturday night).
# Entries are always positive ints, higher than zero.
# Farmer knows the total amount of sheep, this is a third parameter.
# You need to return the amount of sheep lost (not returned to the farm) after final sheep counting on Saturday.
def lost_sheep(friday,saturday,total):
    return total - sum(friday + saturday)

# In some scripting languages like PHP, there exists a logical operator (e.g. &&, ||, and, or, etc.)
# called the "Exclusive Or" (hence the name of this Kata). The exclusive or evaluates two booleans.
# It then returns true if exactly one of the two expressions are true, false otherwise.
# Since we cannot define keywords in Javascript (well, at least I don't know how to do it),
# your task is to define a function xor(a, b) where a and b are the two expressions to be evaluated.
# Your xor function should have the behaviour described above,
# returning true if exactly one of the two expressions evaluate to true, false otherwise.
def xor(a,b):
    return a != b

# Create a function args_count, that returns the count of passed arguments
def args_count(*args, **kwargs):
    return len(args) + len(kwargs)

# Remove all exclamation marks from sentence but ensure a exclamation
# mark at the end of string. For a beginner kata, you can assume that the
# input data is always a non empty string, no need to verify it.
def remove(s):
    return s.replace("!", "") + "!"

# Two red beads are placed between every two blue beads.
# There are N blue beads. After looking at the arrangement below work out the number of red beads.
def count_red_beads(n):
    return 0 if n < 2 else n*2-2

# A trick I learned in elementary school to determine whether
# or not a number was divisible by three is to add all of the integers
# in the number together and to divide the resulting sum by three.
# If there is no remainder from dividing the sum by three, then the original number is divisible by three as well.
# Given a series of digits as a string, determine if the number represented by the string is divisible by three.
def divisible_by_three(st):
    s = sum(int(i) for i in st)
    while s != 0:
        s = s-3
        if s < 0:
            return False
    return True

# Teach snoopy and scooby doo how to bark using object methods. Currently only snoopy can bark and not scooby doo.
class Dog():
    def __init__(self, breed):
        self.breed = breed
snoopy = Dog("Beagle")
snoopy.bark = lambda: "Woof"
scoobydoo = Dog("Great Dane")
scoobydoo.bark = lambda: 'Woof'

# You are given a method called main, make it print the line Hello World!,
# (yes, that includes a new line character at the end) and don't return anything
# Note that for some languages, the function main is the entry point of the program.
class Solution:
    def main(self, name=''):
        print('Hello World!')

# Write function potatoes with
# int parameter p0 - initial percent of water-
# int parameter w0 - initial weight -
# int parameter p1 - final percent of water -
# potatoesshould return the final weight coming out of the oven w1 truncated as an int.
def potatoes(p0, w0, p1):
    return w0 * (100 - p0) // (100 - p1)

# Haskell has some useful functions for dealing with lists:
# $ ghci
# GHCi, version 7.6.3: http://www.haskell.org/ghc/  :? for help
# λ head [1,2,3,4,5]
# 1
# λ tail [1,2,3,4,5]
# [2,3,4,5]
# λ init [1,2,3,4,5]
# [1,2,3,4]
# λ last [1,2,3,4,5]
# 5
# Your job is to implement these functions in your given language.
# Make sure it doesn't edit the array; that would cause problems! Here's a cheat sheet:
def head(lst):
    return lst[0]
def tail(lst):
    return lst[1:]
def init(lst):
    return lst[:-1]
def last(lst):
    return lst[-1]

# Your job at E-Corp is both boring and difficult. It isn't made any easier by the fact
# that everyone constantly wants to have a meeting with you, and that the meeting rooms are always taken!
# In this kata, you will be given an array. Each value represents a meeting room. Your job?
# Find the first empty one and return its index (N.B. There may be more than one empty room in some test cases).
def meeting(rooms):
    return rooms.index("O") if "O" in rooms else "None available!"

# You and a group of friends are earning some extra money in the school holidays
# by re-painting the numbers on people's letterboxes for a small fee.
# Since there are 10 of you in the group each person just concentrates on painting one digit!
# For example, somebody will paint only the 1's, somebody else will paint only the 2's and so on...
# But at the end of the day you realise not everybody did the same amount of work.
# To avoid any fights you need to distribute the money fairly. That's where this Kata comes in.
# Kata Task
# Given the start and end letterbox numbers, write a method to return the frequency of all 10 digits painted.
def paint_letterboxes(start, finish):
    squad = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    for i in range(start,finish+1):
        while i != 0:
            squad[i % 10]+=1
            i //= 10
    return squad

# Imagine you are creating a game where the user has to guess the correct number.
# But there is a limit of how many guesses the user can do.
# If the user tries to guess more than the limit, the function should throw an error.
# If the user guess is right it should return true.
# If the user guess is wrong it should return false and lose a life.
# Can you finish the game so all the rules are met?
class Guesser:
    def __init__(self, number, lives):
        self.number = number
        self.lives = lives

    def guess(self, n):
        if self.lives < 1:
            raise 'Too many guesses!'
        if self.number == n:
            return True
        self.lives -= 1
        return False

# The function new_avg(arr, navg) should return the expected donation
# (rounded up to the next integer) that will permit to reach the average navg.
# Should the last donation be a non positive number (<= 0) John wants us:
# to return:
# Nothing in Haskell, Elm
# None in F#, Ocaml, Rust, Scala
# -1 in C, D, Fortran, Nim, PowerShell, Go, Pascal, Prolog, Lua, Perl, Erlang
# or to throw an error (some examples for such a case):
# IllegalArgumentException() in Clojure, Java
# ArgumentException() in C#
# echo ERROR in Shell
# argument-error in Racket
# std::invalid_argument in C++
# ValueError in Python
# So, he will clearly see that his expectations are not great enough. In "Sample Tests" you can see what to return.
# Notes:
# all donations and navg are numbers (integers or floats), arr can be empty.
# See examples below and "Sample Tests" to see which return is to be done.
from math import ceil
def new_avg(arr, newavg):
    ndon = float(newavg) * (len(arr) + 1) - sum(arr)
    if ndon >= 0:
        return ceil(ndon)
    else:
        raise ValueError('Negative number found')

# In this kata, your job is to return the two distinct highest values in a list.
# If there're less than 2 unique values, return as many of them, as possible.
# The result should also be ordered from highest to lowest.
def two_highest(arg1):
    return sorted(set(arg1), reverse=True)[:2]

# Write a function that removes every lone 9 that is inbetween 7s.
def seven_ate9(str_):
    strung_out = str_
    for i in range(len(strung_out)):
        if strung_out[i:i+3] == '797':
            strung_out = strung_out.replace('797','77')
            continue
    return strung_out

# The vowel substrings in the word codewarriors are o,e,a,io. The longest of these has a length of 2. Given a lowercase string that has alphabetic characters only (both vowels and consonants) and no spaces, return the length of the longest vowel substring.
# Vowels are any of aeiou.
# Good luck!
# If you like substring Katas, please try:
import re
def solve(s):
    matches = re.findall('[aeiou]+', s)
    return max(list(map(len, matches)))

# Take the following IPv4 address: 128.32.10.1
# This address has 4 octets where each octet is a single byte (or 8 bits).
# 1st octet 128 has the binary representation: 10000000
# 2nd octet 32 has the binary representation: 00100000
# 3rd octet 10 has the binary representation: 00001010
# 4th octet 1 has the binary representation: 00000001
# So 128.32.10.1 == 10000000.00100000.00001010.00000001
# Because the above IP address has 32 bits, we can represent it as the 32 bit number: 2149583361.
# Write a function ip_to_int32(ip) ( JS: ipToInt32(ip) ) that takes an IPv4 address and returns a 32 bit number.
def ip_to_int32(ip):
    res = ''
    for part in ip.split('.'):
        b = bin(int(part))[2:]
        res += "%08d" % (int(b))
    return(int(res, 2))

# Given an array of Boolean values and a logical operator,
# return a Boolean result based on sequentially applying the operator to the values in the array.
from functools import reduce
def logical_calc(array, op):
    if op == "AND":
        return all(array)
    elif op == "OR":
        return any(array)
    elif op == "XOR":
        return reduce(lambda x, y: x ^ y, array)

# In this kata, you will do addition and subtraction on a given string. The return value must be also a string.
# Note: the input will not be empty.
import re
def calculate(s):
    s = re.sub('plus', '+', s)
    s = re.sub('minus','-', s)
    return str(eval(s))

# Write a class Block that creates a block (Duh..)
##Requirements
# The constructor should take an array as an argument, this will contain 3 integers
# of the form [width, length, height] from which the Block should be created.
class Block:
    def __init__(self, measurements):
        self.width, self.length, self.height = measurements
    def get_height(self):
        return self.height
    def get_length(self):
        return self.length
    def get_surface_area(self):
        return 2 * (self.height * self.length +
                    self.length * self.width +
                    self.height * self.width)
    def get_volume(self):
        return self.height * self.length * self.width
    def get_width(self):
        return self.width

# Given two strings s1 and s2, we want to visualize how different the
# two strings are. We will only take into account the lowercase letters (a to z).
# First let us count the frequency of each lowercase letters in s1 and s2.
# s1 = "A aaaa bb c"
# s2 = "& aaa bbb c d"
# s1 has 4 'a', 2 'b', 1 'c'
# s2 has 3 'a', 3 'b', 1 'c', 1 'd'
# So the maximum for 'a' in s1 and s2 is 4 from s1; the maximum for 'b' is 3 from s2.
# In the following we will not consider letters when the maximum of their occurrences is less than or equal to 1.
# We can resume the differences between s1 and s2 in the following string: "1:aaaa/2:bbb"
# where 1 in 1:aaaa stands for string s1 and aaaa because the maximum for a is 4.
# In the same manner 2:bbb stands for string s2 and bbb because the maximum for b is 3.
# The task is to produce a string in which each lowercase letters of s1 or s2 appears
# as many times as its maximum if this maximum is strictly greater than 1;
# these letters will be prefixed by the number of the string where they appear
# with their maximum value and :. If the maximum is in s1 as well as in s2 the prefix is =:.
# In the result, substrings (a substring is for example 2:nnnnn or 1:hhh;
# it contains the prefix) will be in decreasing order of their length
# and when they have the same length sorted in ascending lexicographic
# order (letters and digits - more precisely sorted by codepoint);
# the different groups will be separated by '/'. See examples and "Example Tests".
# Hopefully other examples can make this clearer.
def mix(s1, s2):
    dictionary = {}
    for ch in "abcdefghijklmnopqrstuvwxyz":
        val1, val2 = s1.count(ch), s2.count(ch)
        if max(val1, val2) > 1:
            which = "1" if val1 > val2 else "2" if val2 > val1 else "="
            dictionary[ch] = (-max(val1, val2), which + ":" + ch * max(val1, val2))
    return "/".join(dictionary[ch][1] for ch in sorted(dictionary, key=lambda x: dictionary[x]))

# In this kata, we will make a function to test whether a period is late.
# Our function will take three parameters:
# last - The Date object with the date of the last period
# today - The Date object with the date of the check
# cycleLength - Integer representing the length of the cycle in days
# Return true if the number of days passed from last to today
# is greater than cycleLength. Otherwise, return false.
from datetime import *
def period_is_late(last, today, cycle_length):
    return last + timedelta(days = cycle_length) < today

# You will be given a 2D array of the maze and an array of directions.
# Your task is to follow the directions given.
# If you reach the end point before all your moves have gone, you should return Finish.
# If you hit any walls or go outside the maze border, you should return Dead.
# If you find yourself still in the maze after using all the moves, you should return Lost.

def maze_runner(maze, directions):
    startX = 0 ; startY = 0
    for y in range(len(maze)):
        for x in range(len(maze)):
            if maze[x][y] == 2:
                startX = y
                startY = x
    for dire in directions:
        if dire == "N": startY = startY - 1
        if dire == "E": startX = startX + 1
        if dire == "S": startY = startY + 1
        if dire == "W": startX = startX -1
        if startY < 0 or startY > len(maze)-1 or startX < 0 or startX > len(maze)-1 or maze[startY][startX] == 1: return "Dead"
        if maze[startY][startX] == 3: return "Finish"
    return "Lost"

# Define a method/function that removes from a given array
# of integers all the values contained in a second array.
class List(object):
    def remove_(self, integer_list, values_list):
        return [i for i in integer_list if i not in values_list]

# Complete the solution so that it takes the object (JavaScript/CoffeeScript)
# or hash (ruby) passed in and generates a human readable string from its key/value pairs.
# The format should be "KEY = VALUE". Each key/value pair should be separated by a comma except for the last pair.
def solution(pairs):
    return ",".join(sorted(["{} = {}".format(k,v) for k,v in pairs.items()]))

# Complete the solution so that it returns a formatted string.
# The return value should equal "Value is VALUE" where value is a 5 digit padded number.
def solution(value):
    value = str(value)
    return 'Value is ' + '0'*(5-len(value)) + value

# Write a function that returns the number of occurrences of an element in an array.
def number_of_occurrences(element, sample):
    return sample.count(element)

# Given 2 strings, a and b, return a string of the form: shorter+reverse(longer)+shorter.
# In other words, the shortest string has to be put as prefix and as suffix of the reverse of the longest.
# Strings a and b may be empty, but not null (In C# strings may also be null. Treat them as if they are empty.).
# If a and b have the same length treat a as the longer producing b+reverse(a)+b
def shorter_reverse_longer(a, b):
    if len(a) < len(b):
        return f'{a}{b[::-1]}{a}'
    return f'{b}{a[::-1]}{b}'

# Complete the function to find the count of the most frequent item of an array.
# You can assume that input is an array of integers. For an empty array return 0
def most_frequent_item_count(collection):
    return [max(collection.count(i) for i in collection)][0] if collection else 0

# You received a whatsup message from an unknown number. Could it be from that girl/boy
# with a foreign accent you met yesterday evening?
# Write a simple function to check if the string contains the word hallo in different languages.
# These are the languages of the possible people you met the night before:
# hello - english
# ciao - italian
# salut - french
# hallo - german
# hola - spanish
# ahoj - czech republic
# czesc - polish
# Notes
# you can assume the input is a string.
# to keep this a beginner exercise you don't need to check
# if the greeting is a subset of word (Hallowen can pass the test)
# function should be case insensitive to pass the tests
def validate_hello(greetings):
    hellos = ['hello', 'ciao', 'salut', 'hallo', 'hola', 'ahoj', 'czesc']
    return any(greet in greetings.lower() for greet in hellos)

# Create a function that returns the average of an array of numbers ("scores"),
# rounded to the nearest whole number. You are not allowed to use any loops
# (including for, for/in, while, and do/while loops).
def average(array):
    return round(sum(array) / len(array))

# Write a function that reverses the bits in an integer.
# For example, the number 417 is 110100001 in binary.
# Reversing the binary is 100001011 which is 267.
# You can assume that the number is not negative.
def reverse_bits(n):
    return int(str(bin(n).replace("0b", ""))[::-1], 2)

# Given an array with exactly 5 strings "a", "b" or "c" (chars in Java, characters in Fortran),
# check if the array contains three and two of the same values.
import collections
def check_three_and_two(array):
    count_letter = collections.Counter()
    for letter in array:
        count_letter[letter] += 1
    if max(count_letter.values()) == 3 and min(count_letter.values()) == 2:
        return True
    return False

# Your task is to return to the function seven(m)
# (m integer >= 0) an array (or a pair, depending on the language)
# of numbers, the first being the last number m with at most 2 digits
# obtained by your function (this last m will be divisible or not by 7),
# the second one being the number of steps to get the result.
# Forth Note:
# Return on the stack number-of-steps, last-number-m-with-at-most-2-digits
def seven(m):
    steps = 0
    while True:
        if m < 100:
            return (m, steps)
        m = m // 10 - 2 * (m % 10)
        steps += 1

# Write a function partlist that gives all the ways
# to divide a list (an array) of at least two elements into two non-empty parts.
# Each two non empty parts will be in a pair (or an array for languages without
# tuples or a structin C - C: see Examples test Cases - )
# Each part will be in a string
# Elements of a pair must be in the same order as in the original array.
def partlist(arr):
    return [(" ".join(arr[:i]), " ".join(arr[i:])) for i in range(1, len(arr))]

# Implement the function which should return true if given object
# is a vowel (meaning a, e, i, o, u, uppercase or lowercase), and false otherwise.
def is_vowel(s):
    return s.lower() in ['a', 'e', 'i', 'o', 'u']

# Everybody knows the classic "half your age plus seven" dating rule that a lot of people
# follow (including myself). It's the 'recommended' age range in which to date someone.
# minimum age <= your age <= maximum age #Task
# Given an integer (1 <= n <= 100) representing a person's age, return their minimum and maximum age range.
# This equation doesn't work when the age <= 14, so use this equation instead:
# min = age - 0.10 * age
# max = age + 0.10 * age
# You should floor all your answers so that an integer is given instead
# of a float (which doesn't represent age). Return your answer in the form [min]-[max]
def dating_range(age):
    return f"{int(age/2+7) if age > 14 else int(age - 0.10 * age)}-{int((age-7)*2) if age > 14 else int(age + 0.10 * age)}"

# Every budding hacker needs an alias! The Phantom Phreak, Acid Burn, Zero Cool and Crash Override
# are some notable examples from the film Hackers.
# Your task is to create a function that,
# given a proper first and last name, will return the correct alias.
# Notes:
# Two objects that return a one word name in response
# to the first letter of the first name and one for the first letter of the surname are already given.
# If the first character of either of the names given to the function is not a letter
# from A - Z, you should return "Your name must start with a letter from A - Z."
# Sometimes people might forget to capitalize the first letter of their name
# so your function should accommodate for these grammatical errors.
import re
FIRST_NAME = {
    "C": "Cache", "R": "RAD", "J": "Java","B": "Beta","H": "Half-life","L": "Logic","O": "OS",
    "Y": "Y","Q": "Quantum","T": "Trojan","S": "Strike","M": "Malware","E": "Energy",
    "F": "Function","A": "Alpha","K": "Keystroke","I": "Ice","W": "WiFi","N": "Nagware","Z": "Zero",
    "D": "Data","G": "Glitch","V": "Vanilla","X": "Xerox","P": "Phishing","U": "Ultraviolet"
}
SURNAME = {
    "E": "Electron","Q": "Quark","Z": "Zombie","C": "Catalyst","S": "Spy",
    "O": "Overclock","X": "X","D": "Discharge","M": "Mike","P": "Payload",
    "G": "Gig","K": "Killer","R": "Roy","B": "Bomb","H": "Hacker","Y": "Yob","I": "IP","F": "Faraday",
    "A": "Analogue","W": "Worm","U": "Unit","L": "Lazer","T": "T-Rex","V": "Virus",
    "N": "n00b","J": "Jabber",
}
def alias_gen(f_name, l_name):
    regex = r'^[a-zA-Z]+'
    if re.match(regex, f_name) and re.match(regex, l_name):
        return '{} {}'.format(FIRST_NAME[f_name[0].upper()], SURNAME[l_name[0].upper()])
    else:
        return 'Your name must start with a letter from A - Z.'

# Implement a function that returns the minimal and the maximal value of a list (in this order).
def get_min_max(seq):
    return (min(seq), max(seq))

# In this Kata, you will be given a string and your task will
# be to return a list of ints detailing the count of uppercase letters,
# lowercase, numbers and special characters, as follows.
def solve(s):
  uc, lc, num, sp = 0, 0, 0, 0
  for ch in s:
    if ch.isupper(): uc += 1
    elif ch.islower(): lc += 1
    elif ch.isdigit(): num += 1
    else: sp += 1
  return [uc, lc, num, sp]

# Given an array/list [] of integers , Construct a product array Of same size
# Such That prod[i] is equal to The Product of all the elements of Arr[] except Arr[i].
# Notes
# Array/list size is at least 2 .
# Array/list's numbers Will be only Positives
# Repetition of numbers in the array/list could occur.
from operator import mul
from functools import reduce
def product_array(numbers):
    tot = reduce(mul,numbers)
    return [tot//n for n in numbers]

# A Nice array is defined to be an array where for every value n in the array,
# there is also an element n - 1 or n + 1 in the array.
# Write a function named isNice / IsNice that returns true if its array argument is a Nice array,
# else false.An empty array is not considered nice.
def is_nice(arr):
    return all(i+1 in arr or i-1 in arr for i in arr) if arr else 0

# Given a sequence of integers, return the sum of all the integers that have an even index (odd index in COBOL),
# multiplied by the integer at the last index.
# Indices in sequence start from 0.
# If the sequence is empty, you should return 0.
def even_last(numbers):
    total = 0
    if numbers:
        last = numbers[-1]
        numbers = [num for i, num in enumerate(numbers) if i % 2 ==0]
        total = sum(numbers) * last
    return total

# When provided with a String, capitalize all vowels
def swap(st):
    return ''.join(i.swapcase() if i in 'aeiou' else i for i in st)

# You're running an online business and a big part of your day is fulfilling orders.
# As your volume picks up that's been taking more of your time, and unfortunately
# lately you've been running into situations where you take an order but can't fulfill it.
# You've decided to write a function fillable() that takes three arguments: a dictionary
# stock representing all the merchandise you have in stock, a string merch representing
# the thing your customer wants to buy, and an integer n representing the number
# of units of merch they would like to buy. Your function should return
# True if you have the merchandise in stock to complete the sale, otherwise it should return False.
# Valid data will always be passed in and n will always be >= 1.
def fillable(stock, merch, n):
    return merch in stock and stock[merch] >= n

# Your task is to write a function called valid_spacing()
# or validSpacing() which checks if a string has valid spacing.
# The function should return either true or false (or the corresponding value in each language).
# For this kata, the definition of valid spacing is one space between words,
# and no leading or trailing spaces. Words can be any consecutive sequence
# of non space characters. Below are some examples of what the function should return:
def valid_spacing(s):
    return ' '.join(s.split()) == s

# Just a simple sorting usage. Create a function that returns
# the elements of the input-array / list sorted in lexicographical order.
def sortme(names):
    return sorted(names)

# Complete the function that returns an array of length n,
# starting with the given number x and the squares of the previous number.
# If n is negative or zero, return an empty array/list.
def squares(x, n):
    if (n<1): return []
    result = [x]
    i=0
    while i < n-1:
        i+=1
        x*=x
        result.append(x)
    return result

# Write a function filterLucky/filter_lucky() that accepts
# a list of integers and filters the list to only include the elements that contain the digit 7.
def filter_lucky(lst):
    return list(filter(lambda x: '7' in str(x), lst))

# You and a friend have decided to play a game to drill your statistical
# intuitions. The game works like this:
# You have a bunch of red and blue marbles.
# To start the game you grab a handful of marbles of each color
# and put them into the bag, keeping track of how many of each color go in.
# You take turns reaching into the bag, guessing a color, and then pulling one marble out.
# You get a point if you guessed correctly. The trick is you only have three seconds to make your guess,
# so you have to think quickly.
# You've decided to write a function, guessBlue() to help automatically calculate whether you should guess
# "blue" or "red". The function should take four arguments:
# the number of blue marbles you put in the bag to start
# the number of red marbles you put in the bag to start
# the number of blue marbles pulled out so far (always lower than the starting number of blue marbles)
# the number of red marbles pulled out so far (always lower than the starting number of red marbles)
# guessBlue() should return the probability of drawing a blue marble, expressed as a float.
# For example, guessBlue(5, 5, 2, 3) should return 0.6.
def guess_blue(blue_start, red_start, blue_pulled, red_pulled):
    return (blue_start-blue_pulled)/(blue_start-blue_pulled+red_start-red_pulled)

# You are given a list of unique integers arr, and two integers a and b.
# Your task is to find out whether or not a and b appear consecutively in arr,
# and return a boolean value (True if a and b are consecutive, False otherwise).
# It is guaranteed that a and b are both present in arr.
def consecutive(arr, a, b):
    return arr.index(a) == arr.index(b)-1 or arr.index(a) == arr.index(b)+1

# Write a function that takes a string and an an integer n as parameters
# and returns a list of all words that are longer than n.
def filter_long_words(sentence, n):
    return [i for i in sentence.split() if len(i) > n]

# Your task is to determine how many files of the copy queue you will be able
# to save into your Hard Disk Drive. The files must be saved in the order they appear in the queue.
# Input:
# Array of file sizes (0 <= s <= 100)
# Capacity of the HD (0 <= c <= 500)
# Output:
# Number of files that can be fully saved in the HD.
def save(sizes, hd):
    return sum([sum(sizes[:i+1]) <= hd for i in range(len(sizes))])

# In this exercise, a string is passed to a method and a new string has
# to be returned with the first character of each word in the string.
def make_string(s):
    return ''.join(i[0] for i in s.split())

# Your task in this kata is to implement a function that calculates
# the sum of the integers inside a string. For example,
# in the string "The30quick20brown10f0x1203jumps914ov3r1349the102l4zy dog", the sum of the integers is 3635.
# Note: only positive integers will be tested.
import re
def sum_of_integers_in_string(s):
    return sum([int(i) for i in re.findall(r'\d+', s)])

# Write a function to greet a person. Function will take name as input
# and greet the person by saying hello. Return null/nil/None if input is empty string or null/nil/None.
def greet(name):
    return f"hello {name}!" if name else None

# Hey Codewarrior!
# You already implemented a Cube class, but now we need your help again!
# I'm talking about constructors. We don't have one.
# Let's code two: One taking an integer and one handling no given arguments!
# Also we got a problem with negative values. Correct the code so negative
# values will be switched to positive ones!
# The constructor taking no arguments should assign 0 to Cube's Side property.
class Cube(object):
    def __init__(self, side=0):
        self._side = abs(side)

    def get_side(self):\
        return self._side

    def set_side(self, new_side):
        self._side = abs(new_side)

# In your class, you have started lessons about arithmetic progression. Since you are also a programmer,
# you have decided to write a function that will return the first n elements of the sequence with
# the given common difference d and first element a. Note that the difference may be zero!
# The result should be a string of numbers, separated by comma and space.
def arithmetic_sequence_elements(a, d, n):
	return ', '.join(str(a + i * d) for i in range(n))

# When given a string of space separated words, return the word with the longest length.
# If there are multiple words with the longest length,
# return the last instance of the word with the longest length.
def longest_word(string_of_words):
    return sorted(string_of_words.split(), key=len)[-1]

# Given a year, Find The next happy year or The closest year You'll see your best friend
def next_happy_year(year):
    happy_year = False
    while happy_year == False:
        year += 1
        if len(set(list(str(year)))) == 4:
            happy_year = True
    return year

# The medians of a triangle are the segments that unit the vertices with the midpoint of their opposite sides.
# The three medians of a triangle intersect at the same point, called the barycenter or the centroid.
# Given a triangle, defined by the cartesian coordinates of its vertices we need
# to localize its barycenter or centroid.
# The function bar_triang() or barTriang or bar-triang, receives the coordinates
# of the three vertices A, B and C  as three different arguments and outputs the
# coordinates of the barycenter O in an array [xO, yO]
# This is how our asked function should work: the result of the coordinates should
# be expressed up to four decimals, (rounded result).
# You know that the coordinates of the barycenter are given by the following formulas.
def bar_triang(*args):
    return list(map(lambda a: round(sum(a) / 3.0, 4), zip(*args)))

# You will be given an array of objects representing data about developers
# who have signed up to attend the next coding meetup that you are organising.
# Given the following input array:
# write a function that when executed as findAdmin(list1, 'JavaScript')
# returns only the JavaScript developers who are GitHub admins:
from typing import List
def find_admin(lst, lang):
    return [i for i in lst if i['language'] == lang and i['githubAdmin'] == 'yes']

# You receive the name of a city as a string, and you need to return
# a string that shows how many times each letter shows up in the string by using asterisks (*).
def get_strings(city):
    letters = {}
    for letter in city:
        if letter.lower() not in letters:
            letters[letter.lower()] = 1
        else:
            letters[letter.lower()] += 1
    return ",".join(key + ":" + "*"*value for key, value in letters.items() if key != " ")

# Given an array of N integers, you have to find how many times you have to add up the smallest
# numbers in the array until their Sum becomes greater or equal to K.
# Notes:
# List size is at least 3.
# All numbers will be positive.
# Numbers could occur more than once , (Duplications may exist).
# Threshold K will always be reachable.
def minimum_steps(numbers, value):
    numbers = sorted(numbers)
    count = 0
    for i in range(len(numbers)):
        count+=numbers[i]
        if count >= value:
            return i

# The function must return the truncated version of the given
# string up to the given limit followed by "..." if the result is
# shorter than the original. Return the same string if nothing was truncated.
def solution(st, limit):
    return st[:limit] + '...' if limit < len(st) else st

# Fellow code warrior, we need your help!
# We seem to have lost one of our sequence elements, and we need your help to retrieve it!
# Our sequence given was supposed to contain all of the integers from 0 to 9 (in no particular order),
# but one of them seems to be missing.
# Write a function that accepts a sequence of unique integers between 0 and 9 (inclusive),
# and returns the missing element.
def get_missing_element(seq):
    return [i for i in range(10) if i not in seq][0]

# Extra perfect number is the number that first and last bits are set bits.
# Task
# Given a positive integer N , Return the extra perfect numbers in range from 1 to N .
def extra_perfect(n):
    return [i for i in range(1, n+1, 2)]

# Simple enough this one - you will be given an array. The values in the array will either
# be numbers or strings, or a mix of both. You will not get an empty array, nor a sparse one.
# Your job is to return a single array that has first the numbers sorted in ascending order,
# followed by the strings sorted in alphabetic order. The values must maintain their original type.
# Note that numbers written as strings are strings and must be sorted with the other strings.
def db_sort(arr):
    return sorted([i for i in arr if type(i) == int]) + sorted([i for i in arr if type(i) == str])

# Gordon Ramsay shouts. He shouts and swears. There may be something wrong with him.
# Anyway, you will be given a string of four words. Your job is to turn them in to Gordon language.
# Rules:
# Obviously the words should be Caps, Every word should end with '!!!!',
# Any letter 'a' or 'A' should become '@', Any other vowel should become '*'.
def gordon(a):
    trans = a.lower().maketrans({'a':'@', 'e':'*', 'o':'*','u':'*','i':'*'})
    return '!!!! '.join(a.translate(trans).upper().split()) + '!!!!'

# Given two numbers x and n, calculate the (positive) nth root of x; this means that being r = result, r^n = x
# Examples
def root(x, n):
    return x**(1/n)

# Given a string, return true if the first instance of "x"
# in the string is immediately followed by the string "xx".
def triple_x(s):
    for i, elem in enumerate(s[:-2]):
        if elem == 'x':
            return elem == s[i+1] and elem == s[i+2]
    return False

# The other day I saw an amazing video where a guy hacked some wifi controlled lightbulbs
# by flying a drone past them. Brilliant.
# In this kata we will recreate that stunt... sort of.
# You will be given two strings: lamps and drone. lamps represents a row of lamps,
# currently off, each represented by x. When these lamps are on, they should be represented by o.
# The drone string represents the position of the drone T (any better suggestion
# for character??) and its flight path up until this point =. The drone always
# flies left to right, and always begins at the start of the row of lamps.
# Anywhere the drone has flown, including its current position,
# will result in the lamp at that position switching on.
# Return the resulting lamps string. See example tests for more clarity.
def fly_by(lamps, drone):
    return 'o'*len(drone) + lamps[len(drone):] if len(drone) <= len(lamps) else 'o'*len(lamps)

# You are given a string of n lines, each substring being n characters long. For example:
# s = "abcd\nefgh\nijkl\nmnop"
# We will study the "horizontal" and the "vertical" scaling of this square of strings.
# A k-horizontal scaling of a string consists of replicating k times each character of the string (except '\n').
# Example: 2-horizontal scaling of s: => "aabbccdd\neeffgghh\niijjkkll\nmmnnoopp"
# A v-vertical scaling of a string consists of replicating v times each part of the squared string.
# Example: 2-vertical scaling of s: => "abcd\nabcd\nefgh\nefgh\nijkl\nijkl\nmnop\nmnop"
def scale(strng, k, n):
    return '\n'.join(''.join(b * k for b in a) for a in strng.split('\n') for _ in range(n)) if strng else ''

# Bob is a lazy man.
# He needs you to create a method that can determine how many
# letters (both uppercase and lowercase ASCII letters) and digits are in a given string.
def count_letters_and_digits(s):
    return len([i for i in s if i.isdigit() or i.isalpha()])

# You have stumbled across the divine pleasure that is owning
# a dog and a garden. Now time to pick up all the cr@p! :D
# Given a 2D array to represent your garden, you must find
# and collect all of the dog cr@p - represented by '@'.
# You will also be given the number of bags you have access to
# (bags), and the capactity of a bag (cap). If there are no bags then
# you can't pick anything up, so you can ignore cap.
# You need to find out if you have enough capacity to collect all the cr@p and make your garden clean again.
# If you do, return 'Clean', else return 'Cr@p'.
# Watch out though - if your dog is out there ('D'), he gets very
# touchy about being watched. If he is there you need to return 'Dog!!'.
def crap(garden, bags, cap):
    c = 0
    for el in garden:
        for e in el:
            if e == "@":
                c += 1
            if e == "D":
                return "Dog!!"
    return "Clean" if c <= bags * cap else "Cr@p"

# Imagine you start on the 5th floor of a building, then travel down to the 2nd floor,
# then back up to the 8th floor. You have travelled a total of 3 + 6 = 9 floors of distance.
# Given an array representing a series of floors you must reach by elevator,
# return an integer representing the total distance travelled for visiting each floor in the array in order.
def elevator_distance(array):
    return sum([abs(array[i] - array[i+1]) for i in range(len(array)-1)])

# Complete the function to create backronyms. Transform the given string (without spaces)
# to a backronym, using the preloaded dictionary and return a string of words,
# separated with a single space (but no trailing spaces).
# The keys of the preloaded dictionary are uppercase letters A-Z
# and the values are predetermined words, for example:
dictionary
def make_backronym(acronym):
    return ' '.join(dictionary[i.upper()] for i in acronym)

# My friend John likes to go to the cinema. He can choose between system A and system B.
# System A : he buys a ticket (15 dollars) every time
# System B : he buys a card (500 dollars) and a first ticket for 0.90 times the ticket price,
# then for each additional ticket he pays 0.90 times the price paid for the previous ticket.
# Example:
# If John goes to the cinema 3 times
# System A : 15 * 3 = 45
# System B : 500 + 15 * 0.90 + (15 * 0.90) * 0.90 + (15 * 0.90 * 0.90) * 0.90 ( = 536.5849999999999,
# no rounding for each ticket)
# John wants to know how many times he must go to the cinema so that the final result of System B,
# when rounded up to the next dollar, will be cheaper than System A.
# The function movie has 3 parameters: card (price of the card), ticket (normal price of a ticket),
# perc (fraction of what he paid for the previous ticket) and returns the first n such that
import math
def movie(card, ticket, perc):
    total_card = card
    total_tickets = 0
    i = 1
    while math.ceil(total_card) >= total_tickets:
        total_card += ticket *(perc**i)
        total_tickets += ticket
        i += 1
    return i - 1

# You will be given an array of objects representing data
# about developers who have signed up to attend the next coding meetup that you are organising.
# Your task is to return an object which includes the count
# of food options selected by the developers on the meetup sign-up form..
from typing import List
def order_food(lst):
    meals = {}
    for i in lst:
        if i['meal'] not in meals:
            meals[i['meal']] = 1
        else:
            meals[i['meal']] += 1
    return meals

# This kata is the first of a sequence of four about "Squared Strings".
# You are given a string of n lines, each substring being n characters long: For example:
# s = "abcd\nefgh\nijkl\nmnop"
# We will study some transformations of this square of strings.
def vert_mirror(strng):
    return '\n'.join(i[::-1] for i in strng.split('\n'))
def hor_mirror(strng):
    return '\n'.join(strng.split('\n')[::-1])
def oper(fct, s):
    return fct(s)

# Each floating-point number should be formatted that only the first two decimal places are returned.
# You don't need to check whether the input is a valid number because only valid numbers are used in the tests.
# Don't round the numbers! Just cut them after two decimal places!
from math import trunc
def two_decimal_places(number):
    factor = float(10 ** 2)
    return trunc(number * factor) / factor

# Definition
# A number is a Special Number if it’s digits only consist 0, 1, 2, 3, 4 or 5
# Given a number determine if it special number or not .
def special_number(n):
    return "Special!!" if max(str(n)) <= "5" else "NOT!!"

# Given an array (a list in Python) of integers and an integer n, find all occurrences of n
# in the given array and return another array containing all the index positions of n in the given array.
# If n is not in the given array, return an empty array [].
# Assume that n and all values in the given array will always be integers.
def find_all(array, n):
    return [e for e,i in enumerate(array) if i == n]

# Given an array of numbers (in string format), you must return a string.
# The numbers correspond to the letters of the alphabet in reverse order:
# a=26, z=1 etc. You should also account for '!', '?' and ' ' that are represented by
# '27', '28' and '29' respectively.
# All inputs will be valid.
def switcher(arr):
    letters = ' ?!abcdefghijklmnopqrstuvwxyz'
    return ''.join(letters[::-1][int(idx) - 1] for idx in arr)

# My friend wants a new band name for her band. She like bands that use the formula:
# "The" + a noun with the first letter capitalized, for example:
# "dolphin" -> "The Dolphin"
# However, when a noun STARTS and ENDS with the same letter,
# she likes to repeat the noun twice and connect them together
# with the first and last letter, combined into one word (WITHOUT "The" in front), like this:
# "alaska" -> "Alaskalaska"
# Complete the function that takes a noun as a string, and returns her preferred band name written as a string.
def band_name_generator(name):
    name = name.lower()
    if name[0] == name[-1]:
        return (name[:-1] + name).capitalize()
    return "The {}".format(name.capitalize())

# Is similar to factorial of a number, In primorial, not all the natural numbers get multiplied,
# only prime numbers are multiplied to calculate the primorial of a number.
# It's denoted with P# and it is the product of the first n prime numbers.
# Task
# Given a number N , calculate its primorial.
import functools
def num_primorial(n):
    def sieveOfEratosthenes(n):
        if n <= 2:
            return []
        sieve = list(range(3, n, 2))
        top = len(sieve)
        for si in sieve:
            if si:
                bottom = (si*si - 3) // 2
                if bottom >= top:
                    break
                sieve[bottom::si] = [0] * -((bottom - top) // si)
        return [2] + [el for el in sieve if el]
    return functools.reduce(lambda a, b: a*b, sieveOfEratosthenes(10000)[:n])

# Well met with Fibonacci bigger brother, AKA Tribonacci.
# As the name may already reveal, it works basically like a Fibonacci,
# but summing the last 3 (instead of 2) numbers of the sequence to generate the next.
# And, worse part of it, regrettably I won't get to hear non-native Italian speakers trying to pronounce it :(
# So, if we are to start our Tribonacci sequence with [1, 1, 1] as a starting
# input (AKA signature), we have this sequence:
def tribonacci(signature, n):
    if n == 0:
        return []
    def fib(n):
        a, b, c = signature[0], signature[1], signature[2]
        for _ in range(n):
            yield a
            a, b, c = b, c, a+b+c
    return list(fib(n))

# You receive some random elements as a space-delimited string. Check if the
# elements are part of an ascending sequence of integers
# starting with 1, with an increment of 1 (e.g. 1, 2, 3, 4).
# Return:
# 0 if the elements can form such a sequence, and no number is missing ("not broken", e.g. "1 2 4 3")
# 1 if there are any non-numeric elements in the input ("invalid", e.g. "1 2 a")
# n if the elements are part of such a sequence, but some numbers are missing,
# and n is the lowest of them ("broken", e.g. "1 2 4" or "1 5")
def find_missing_number(sequence):
    if not sequence:
        return 0
    try:
        sequence = set(int(a) for a in sequence.split())
    except ValueError:
        return 1
    for b in range(1, max(sequence) + 1):
        if b not in sequence:
            return b
    return 0

# The bloody photocopier is broken... Just as you were sneaking around
# the office to print off your favourite binary code!
# Instead of copying the original, it reverses it: '1' becomes '0' and vice versa.
# Given a string of binary, return the version the photocopier gives you as a string.
def broken(inp):
    return inp.translate(inp.maketrans({'0':'1', '1':'0'}))

# Write a function that finds the sum of all its arguments.
def sum_args(*args):
    return sum([*args])

# You'll have to translate a string to Pilot's alphabet (NATO phonetic alphabet).
# Input:
# If, you can read?
# Output:
# India Foxtrot , Yankee Oscar Uniform Charlie Alfa November Romeo Echo Alfa Delta ?
# Note:
# There are preloaded dictionary you can use, named NATO
# The set of used punctuation is ,.!?.
# Punctuation should be kept in your return string, but spaces should not.
# Xray should not have a dash within.
# Every word and punctuation mark should be seperated by a space ' '.
# There should be no trailing whitespace
NATO
def to_nato(words):
    return ' '.join(NATO[i.upper()] if i not in ',.!?' else i for i in words.replace(' ', ''))

# Cheesy Cheeseman just got a new monitor! He is happy with it,
# but he just discovered that his old desktop wallpaper no longer fits.
# He wants to find a new wallpaper, but does not know which size wallpaper
# he should be looking for, and alas, he just threw out the new monitor's box.
# Luckily he remembers the width and the aspect ratio of the monitor from
# when Bob Mortimer sold it to him. Can you help Cheesy out?
# The Challenge
# Given an integer width and a string ratio written as WIDTH:HEIGHT,
# output the screen dimensions as a string written as WIDTHxHEIGHT.
# Note: The calculated height should be represented as an integer.
# If the height is fractional, truncate it.
def find_screen_height(width, ratio):
    lhs, rhs = list(map(int, ratio.split(':')))
    height = int(width * rhs/lhs)
    return str(width) + 'x' + str(height)

# Create the function prefill that returns an array of n elements
# that all have the same value v. See if you can do this without using a loop.
# You have to validate input:
# v can be anything (primitive or otherwise)
# if v is ommited, fill the array with undefined
# if n is 0, return an empty array
# if n is anything other than an integer or integer-formatted string (e.g. '123') that is >=0, throw a TypeError
# When throwing a TypeError, the message should be n is invalid, where
# you replace n for the actual value passed to the function.
def prefill(n,v='undefined'):
    if str(n).isdigit()==True:
        return [v for _ in range(int(n))]
    else:
        raise TypeError('%s is invalid'%(n))

# A bookseller has lots of books classified in 26 categories labeled A, B, ... Z. Each book has a code
# c of 3, 4, 5 or more characters. The 1st character of a code is a capital letter which defines the book category.
# In the bookseller's stocklist each code c is followed
# by a space and by a positive integer n (int n >= 0) which indicates the quantity of books of this code in stock.
# For example an extract of a stocklist could be:
# L = {"ABART 20", "CDXEF 50", "BKWRK 25", "BTSQZ 89", "DRTYM 60"}.
# or
# L = ["ABART 20", "CDXEF 50", "BKWRK 25", "BTSQZ 89", "DRTYM 60"] or ....
# You will be given a stocklist (e.g. : L) and a list of categories in capital letters e.g :
# M = {"A", "B", "C", "W"}
# or
# M = ["A", "B", "C", "W"] or ...
# and your task is to find all the books of L with codes
# belonging to each category of M and to sum their quantity according to each category.
# For the lists L and M of example you have to return the
# string (in Haskell/Clojure/Racket/Prolog a list of pairs):
def stock_list(listOfArt, listofCat):
	stock = {}
	result=''
	for a in listOfArt:
		cat = a.split(' ')[0][0:1]
		if stock.get(cat):
			stock[cat]+= int(a.split(' ')[1])
		else:
			stock[cat] = int(a.split(' ')[1])
	for c in listofCat:
		if stock.get(c):
			result+='({0} : {1}) - '.format(c, stock.get(c))
		else:
			result+='({0} : {1}) - '.format(c, 0)
	if all(s == 0 for s in stock.values()): return ''
	return result[0:len(result)-3] if result.endswith(' ') else result

# Given a string of digits confirm whether the sum of all the individual even digits
# are greater than the sum of all the indiviudal odd digits. Always a string of numbers will be given.
# If the sum of even numbers is greater than the odd numbers return: "Even is greater than Odd"
# If the sum of odd numbers is greater than the sum of even numbers return: "Odd is greater than Even"
# If the total of both even and odd numbers are identical return: "Even and Odd are the same"
def even_or_odd(s):
    a = sum(int(i) for i in s if int(i)%2 != 0)
    b = sum(int(i) for i in s if int(i)%2 == 0)
    return 'Even is greater than Odd' if b > a else 'Odd is greater than Even' if a>b else 'Even and Odd are the same'

# Given two words and a letter, return a single word that's a combination of both words,
# merged at the point where the given letter first appears in each word.
# The returned word should have the beginning of the first word and the ending of the second,
# with the dividing letter in the middle. You can assume both words will contain the dividing letter.
def string_merge(string1, string2, letter):
    return string1[:string1.index(letter)] + string2[string2.index(letter):]

# Given a positive integer n: 0 < n < 1e6,
# remove the last digit until you're left with a number that is a multiple of three.
# Return n if the input is already a multiple of three,
# and if no such number exists, return null, a similar empty value, or -1.
def prev_mult_of_three(n):
    while n % 3 != 0:
        if len(str(n)) == 1 and n % 3 != 0:
            return None
        n = int(str(n)[:-1])
    return n

# A traveling salesman has to visit clients. He got each client's address e.g. "432 Main Long Road
# St. Louisville OH 43071" as a list.
# The basic zipcode format usually consists of two capital letters followed by a white
# space and five digits. The list of clients to visit was given as a string of all
# addresses, each separated from the others by a comma, e.g. :
# "123 Main Street St. Louisville OH 43071,432 Main Long Road St. Louisville OH 43071,
# 786 High Street Pollocksville NY 56432".
# To ease his travel he wants to group the list by zipcode.
# Task
# The function travel will take two parameters r (addresses' list of all
# clients' as a string) and zipcode and returns a string in the following format:
# zipcode:street and town,street and town,.../house number,house number,...
# The street numbers must be in the same order as the streets where they belong.
# If a given zipcode doesn't exist in the list of clients' addresses return "zipcode:/"
def travel(r, zipcode):
    l = r.split(',')
    lst = []
    l_n = []
    con = ''
    for elem in l:
        if zipcode == elem[-8:]:
            lst.append(elem[:-9])
    for i in lst:
        while True:
            for char in i:
                if char.isdigit():
                    con += char
                    continue
                l_n.append(con)
                con = ''
                break
            break
    for i in range(len(lst)):
        lst[i] = lst[i][len(l_n[i])+1:]
    return f"{zipcode}:{','.join(i for i in lst)}/{','.join(i for i in l_n)}"

# You are given a string of n lines, each substring being n characters long: For example:
# s = "abcd\nefgh\nijkl\nmnop"
# We will study some transformations of this square of strings.
# Clock rotation 180 degrees: rot
# rot(s) => "ponm\nlkji\nhgfe\ndcba"
# selfie_and_rot(s) (or selfieAndRot or selfie-and-rot)
# It is initial string + string obtained by clock rotation 180 degrees
# with dots interspersed in order (hopefully) to better show the rotation when printed.
# s = "abcd\nefgh\nijkl\nmnop" -->
# "abcd....\nefgh....\nijkl....\nmnop....\n....ponm\n....lkji\n....hgfe\n....dcba"
def rot(strng):
    return strng[::-1]
def selfie_and_rot(strng):
    return '\n'.join(i+'.'*len(i) for i in strng.split('\n')) + '\n' +'\n'.join('.'*len(i)+i[::-1] for i in strng.split('\n')[::-1])
def oper(fct, s):
    return fct(s)

# Your task is to construct a building which will be a pile of n cubes. The cube at the bottom will have a volume
# of n3 n^3n  3
#  , the cube above will have volume of (n−1)3 (n-1)^3(n−1) 3
#   and so on until the top which will have a volume of 13 1^31 3 .
# You are given the total volume m of the building. Being given m can you find the
# number n of cubes you will have to build?
# The parameter of the function findNb (find_nb, find-nb, findNb, ...) will be an
# integer m and you have to return the integer n such
# as n3+(n−1)3+(n−2)3+...+13=m n^3 + (n-1)^3 + (n-2)^3 + ... + 1^3 = mn
# 3 +(n−1) 3 +(n−2) 3 +...+1 3 =m if such a n exists or -1 if there is no such n.
def find_nb(M):
    m = 0
    i = 0
    while m < M:
        m += i ** 3
        if m == M:
            return i
        i += 1
    return -1

# It's tricky keeping track of who is owed what when spending money in a group.
# Write a function to balance the books.
# The function should take one parameter: an object/dict with two or more
# name-value pairs which represent the members of the group and the amount spent by each.
# The function should return an object/dict with the same names, showing
# how much money the members should pay or receive.
# Further points:
# The values should be positive numbers if the person should receive money
# from the group, negative numbers if they owe money to the group.
# If value is a decimal, round to two decimal places.
# Translations and comments (and upvotes!) welcome.
# Example
# 3 friends go out together: A spends £20, B spends £15, and C spends £10.
# The function should return an object/dict showing that A should receive £5,
# B should receive £0, and C should pay £5.
group = {
    'A': 20,
    'B': 15,
    'C': 10
}
def split_the_bill(x):
    total_each_owed = sum(x.values())/float(len(x))
    return {key:round(value - total_each_owed, 2) for key, value in x.items()}

# For this game of BINGO, you will receive a single array of 10 numbers
# from 1 to 26 as an input. Duplicate numbers within the array are possible.
# Each number corresponds to their alphabetical order letter (e.g. 1 = A. 2 = B, etc).
# Write a function where you will win the game if your numbers can spell "BINGO".
# They do not need to be in the right order in the input array. Otherwise you will lose.
# Your outputs should be "WIN" or "LOSE" respectively.
import string
def bingo(array):
    lst = []
    for elem in array:
        lst.append(string.ascii_lowercase[elem-1])
    return 'WIN' if all(i in lst for i in 'bingo') else 'LOSE'

# Let's create some scrolling text!
# Your task is to complete the function which takes a string,
# and returns an array with all possible rotations of the given string, in uppercase.
def scrolling_text(text):
    lst = []
    for i in range(len(text)):
        lst.append(text.upper())
        text = text[1:] + text[0]
    return lst

# John wants to decorate the walls of a room with wallpaper. He wants a fool-proof method for getting it right.
# John knows that the rectangular room has a length of l meters, a width of w meters,
# a height of h meters. The standard width of the rolls he wants to buy is 52 centimeters.
# The length of a roll is 10 meters. He bears in mind however, that it’s best to have an
# extra length of wallpaper handy in case of mistakes or miscalculations so he wants to
# buy a length 15% greater than the one he needs.
# Last time he did these calculations he got a headache, so could you help John?
# Task
# Your function wallpaper(l, w, h) should return as a plain English word in lower
# case the number of rolls he must buy.

from math import ceil
WORDS = {
    1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five', 6: 'six',
    7: 'seven', 8: 'eight', 9: 'nine', 10: 'ten', 11: 'eleven', 12: 'twelve',
    13: 'thirteen', 14: 'fourteen', 15: 'fifteen', 16: 'sixteen',
    17: 'seventeen', 18: 'eighteen', 19: 'nineteen', 20: 'twenty'
}
def wallpaper(l, w, h):
    if 0 in (l, w, h):
        return 'zero'
    return WORDS[int(ceil((((l * h) * 2 + (w * h) * 2) * 1.15) / 5.2))]

# Count the number of exclamation marks and question marks, return the product.
def product(s):
    return int(s.count('!'))*int(s.count('?'))

# For every good kata idea there seem to be quite a few bad ones!
# In this kata you need to check the provided 2 dimensional array
# (x) for good ideas 'good' and bad ideas 'bad'. If there are
# one or two good ideas, return 'Publish!', if there are more
# than 2 return 'I smell a series!'. If there are no good ideas, as is often the case, return 'Fail!'.
# The sub arrays may not be the same length.
# The solution should be case insensitive (ie good, GOOD
# and gOOd all count as a good idea). All inputs may not be strings.
def well(arr):
    l = [j.lower() if type(j) == str else j for i in arr for j in i]
    con = l.count('good')
    return 'Fail!' if con == 0 else 'Publish!' if 1 <= con <= 2 else 'I smell a series!'

# In this kata you are given a string for example:
# "example(unwanted thing)example"
# Your task is to remove everything inside the parentheses as well as the parentheses themselves.
# The example above would return:
# "exampleexample"
# Notes
# Other than parentheses only letters and spaces can occur in the string.
# Don't worry about other brackets like "[]" and "{}" as these will never appear.
# There can be multiple parentheses.
# The parentheses can be nested.
import re
def remove_parentheses(s):
    while re.findall(r"\([^()]*\)", s):
        s = re.sub(r"\([^()]*\)", "", s)
    return s

# Create the function consecutive(arr) that takes an array of integers
# and return the minimum number of integers needed to make the contents
# of arr consecutive from the lowest number to the highest number.
def consecutive(arr):
    try:
        return len(range(min(arr), max(arr)+1)) - len(arr)
    except:
        return 0

# Write a function that takes a string
# and outputs a strings of 1's and 0's where vowels become 1's and non-vowels become 0's.
# All non-vowels including non alpha characters (spaces,commas etc.) should be included.
def vowel_one(s):
    return ''.join('1' if i.lower() in 'aeoiu' else '0' for i in s)

# Write a function to find if a number is lucky or not.
# If the sum of all digits is 0 or multiple of 9 then the number is lucky.
# 1892376 => 1+8+9+2+3+7+6 = 36. 36 is divisible by 9, hence number is lucky.
# Function will return true for lucky numbers and false for others.
def is_lucky(n):
    return sum(int(i) for i in str(n)) % 9 == 0 or str(sum(int(i) for i in str(n)))[0] == '0'

# To introduce the problem think to my neighbor who drives a tanker truck.
# The level indicator is down and he is worried because he does not know
# if he will be able to make deliveries. We put the truck on a horizontal
# ground and measured the height of the liquid in the tank.
# Fortunately the tank is a perfect cylinder and the vertical walls on
# each end are flat. The height of the remaining liquid is h, the diameter
# of the cylinder base is d, the total volume is vt (h, d, vt are positive
# or null integers). You can assume that h <= d.
# Could you calculate the remaining volume of the liquid? Your function
# tankvol(h, d, vt) returns an integer which is the truncated result (e.g floor) of your float calculation.
import math
def tankvol(h, d, vt):
    radius = d / 2
    cylinder_length = vt / (math.pi * (radius * radius))
    volume = cylinder_length * (((radius * radius) * math.acos((radius - h) / radius)) - ((radius - h) * math.sqrt((2 * radius * h) - (h * h))))
    return int(volume)

# Given a list of integers values, your job is to return the sum of the values;
# however, if the same integer value appears multiple times in the list,
# you can only count it once in your sum.
def unique_sum(lst):
    return sum(set(lst)) if lst else None

# Welcome young Jedi! In this Kata you must create a function that takes an amount of US currency
# in cents, and returns a dictionary/hash which shows the least amount of coins used to make up
# that amount. The only coin denominations considered in this exercise are: Pennies (1¢),
# Nickels (5¢), Dimes (10¢) and Quarters (25¢). Therefor the dictionary returned should
# contain exactly 4 key/value pairs.
# Notes:
# If the function is passed either 0 or a negative number, the function should
# return the dictionary with all values equal to 0.
# If a float is passed into the function, its value should be rounded down,
# and the resulting dictionary should never contain fractions of a coin.
def loose_change(cents):
    d = {'Nickels': 0, 'Pennies': 0, 'Dimes': 0, 'Quarters': 0}
    if cents > 0:
        d['Quarters'] = cents//25
        cents = cents- 25*(cents//25)
        d['Dimes'] = cents // 10
        cents = cents-10*(cents//10)
        d['Nickels'] = cents // 5
        cents = cents-5*(cents//5)
        d['Pennies'] = cents // 1
    return d

# Move every letter in the provided string forward 10 letters through the alphabet.
# If it goes past 'z', start again at 'a'.
# Input will be a string with length > 0.
def move_ten(st):
    d = 'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz'
    return ''.join(d[d.index(i)+10] for i in st)

# Function composition is a mathematical operation that mainly presents itself in lambda calculus
# and computability. It is explained well here, but this is my explanation, in simple mathematical notation:
# f3 = compose( f1 f2 )
#    Is equivalent to...
# f3(a) = f1( f2( a ) )
# Your task is to create a compose function to carry out this task,
# which will be passed two functions or lambdas. Ruby functions will
# be passed, and should return, either a proc or a lambda.
# Remember that the resulting composed function may be passed multiple arguments!
def compose(f, g):
    def wrapper(*args):
        return f(g(*args))
    return wrapper

# Your job is to implement a function which returns the last D digits of an integer N as a list.
# Special cases:
# If D > (the number of digits of N), return all the digits.
# If D <= 0, return an empty list.
def solution(n,d):
    return [int(i) for i in str(n)[-d:]] if d > 0 else []

# Time to win the lottery!
# Given a lottery ticket (ticket), represented by an array of 2-value arrays,
# you must find out if you've won the jackpot.
# Example ticket:
# [ [ 'ABC', 65 ], [ 'HGR', 74 ], [ 'BYHT', 74 ] ]
# To do this, you must first count the 'mini-wins' on your ticket.
# Each subarray has both a string and a number within it.
# If the character code of any of the characters in the string matches the number,
# you get a mini win. Note you can only have one mini win per sub array.
# Once you have counted all of your mini wins, compare that number to the
# other input provided (win). If your total is more than or equal to (win),
# return 'Winner!'. Else return 'Loser!'.
# All inputs will be in the correct format. Strings on tickets are not always the same length.
def bingo(ticket,win):
    count = 0
    for i in ticket:
        for j in i[0]:
            if ord(j)==i[1]:
                count += 1
                break
    return 'Winner!' if count >= win else 'Loser!'

# Given a positive number n > 1 find the prime factor
# decomposition of n. The result will be a string with the following form :
#  "(p1**n1)(p2**n2)...(pk**nk)"
# with the p(i) in increasing order and n(i) empty if n(i) is 1.
def prime_factors(n):
    i = 2
    res = {}
    while n/i != 1:
        if n%i == 0:
            if i in res:
                res[i] = res[i]+1
            else:
                res[i] = 1
            n = n/i
        else:
            i+=1
    if i in res:
        res[i] = res[i]+1
    else:
        res[i] = 1
    t = ''
    res = sorted(res.items(),key = lambda a:a[0])
    for key in res:
        if key[1] == 1:
            t = t + '('+str(key[0]) +')'
        else:
            t = t + '(' +str(key[0]) + '**' + str(key[1]) + ')'
    return t

# Write a function insert_dash(num) / insertDash(num) / InsertDash(int num) that will insert dashes
# ('-') between each two odd digits in num. For example:
# if num is 454793 the output should be 4547-9-3. Don't count zero as an odd digit.
# Note that the number will always be non-negative (>= 0).
import re
def insert_dash(num):
    return re.sub(r'([13579])(?=[13579])', r'\1-', str(num))\

# Write a function that returns true if the number is a "Very Even" number.
# If a number is a single digit, then it is simply "Very Even" if it itself is even.
# If it has 2 or more digits, it is "Very Even" if the sum of its digits is "Very Even".
def is_very_even_number(n):
    while len(str(n))!= 1:
        n = sum(int(i) for i in str(n))
    return n % 2 == 0

# The Pied Piper has been enlisted to play his magical tune and coax all the rats out of town.
# But some of the rats are deaf and are going the wrong way!
# Kata Task
# How many deaf rats are there?
# Legend
# P = The Pied Piper
# O~ = Rat going left
# ~O = Rat going right
# Example
# ex1 ~O~O~O~O P has 0 deaf rats
# ex2 P O~ O~ ~O O~ has 1 deaf rat
# ex3 ~O~O~O~OP~O~OO~ has 2 deaf rats
import re
def count_deaf_rats(town):
    t = town.split('P')
    return find(t[0]).count('O~') + find(t[1]).count('~O')
def find(s):
    return [''.join(j) for j in re.findall('(~O)|(O~)', s)]

# From Wikipedia:
# "A divisibility rule is a shorthand way of determining whether
# a given integer is divisible by a fixed divisor without performing
# the division, usually by examining its digits."
# When you divide the successive powers of 10 by 13 you get the
# following remainders of the integer divisions:
# 1, 10, 9, 12, 3, 4 because:
# 10 ^ 0 ->  1 (mod 13)
# 10 ^ 1 -> 10 (mod 13)
# 10 ^ 2 ->  9 (mod 13)
# 10 ^ 3 -> 12 (mod 13)
# 10 ^ 4 ->  3 (mod 13)
# 10 ^ 5 ->  4 (mod 13)
# (For "mod" you can see: https://en.wikipedia.org/wiki/Modulo_operation)
# Then the whole pattern repeats. Hence the following method:
# Multiply
# the right most digit of the number with the left most number in the sequence shown above,
# the second right most digit with the second left most digit of the number in the sequence.
# The cycle goes on and you sum all these products. Repeat this process until
# the sequence of sums is stationary.
def thirt(n):
    pattern = [1, 10, 9, 12, 3, 4]
    sum = 0
    while True:
        current_sum = 0
        for index, digit in enumerate(str(n)[::-1]):
            current_index = index % len(pattern)
            current_sum += int(digit) * pattern[current_index]
        if sum == current_sum:
            return sum
        sum = current_sum
        n = current_sum

# Create a function that takes in the sum and age difference of two people, calculates
# their individual ages, and returns a pair of values (oldest age first) if those exist or null/None if:
# sum < 0
# difference < 0
# Either of the calculated ages come out to be negative
def get_ages(sum_, diff):
    a = (sum_ - diff)/2
    b = sum_ - a
    if sum_ < 0 or diff < 0 or a < 0 or b < 0:
        return None
    return (b,a)

# Create a function add(n)/Add(n) which returns a function that always adds n to any number
# Note for Java: the return type and methods have not been provided to make it a bit more challenging.
def add(n):
    return lambda x: x + n

# Write a program that outputs the top n elements from a list.
# Example:
# largest(2, [7,6,5,4,3,2,1])
# => [6,7]
def largest(n,xs):
    return sorted(xs)[-n:]

# The aim of this kata is to split a given string into different strings
# of equal size (note size of strings is passed to the method)
def split_in_parts(s, part_length):
    words = []
    for i in range(0, len(s), part_length):
        words.append(s[i:i+part_length])
    return ' '.join(words)

# Positive integers that are divisible exactly by the sum of
# their digits are called Harshad numbers. The first few
# Harshad numbers are: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 18, ...
# We are interested in Harshad numbers where the product of its digit sum s
# and s with the digits reversed, gives the original number n. For example consider number 1729:
# its digit sum, s = 1 + 7 + 2 + 9 = 19
# reversing s = 91
# and 19 * 91 = 1729 --> the number that we started with.
# Complete the function which tests if a positive integer n is Harshad number,
# and returns True if the product of its digit sum and its digit sum reversed equals n; otherwise return False.
def number_joy(n):
    s = sum(int(i) for i in str(n))
    return s * int(str(s)[::-1]) == n

# Nickname Generator
# Write a function, nicknameGenerator that takes
# a string name as an argument and returns the first 3 or 4 letters as a nickname.
# If the 3rd letter is a consonant, return the first 3 letters.
# nickname("Robert") //=> "Rob"
# nickname("Kimberly") //=> "Kim"
# nickname("Samantha") //=> "Sam"
# If the 3rd letter is a vowel, return the first 4 letters.
def nickname_generator(name):
    return "Error: Name too short" if len(name) < 4 else name[:3+(name[2] in "aeiuo")]

# Return an output string that translates an input string s/$s by
# replacing each character in s/$s with a number representing
# the number of times that character occurs in s/$s and separating each number with the character(s) sep/$sep.
def freq_seq(s, sep):
    return sep.join(str(s.count(i)) for i in s)

# You are to write a function that takes a string as its first parameter.
# This string will be a string of words.
# You are expected to then use the second parameter, which will be an integer,
# to find the corresponding word in the given string. The first word would be represented by 0.
# Once you have the located string you are finally going to multiply by it the
# third provided parameter, which will also be an integer.
# You are additionally required to add a hyphen in between each word.
def modify_multiply(st, loc, num):
    return '-'.join(st.split()[loc] for i in range(num))

# Create a function which accepts one arbitrary string as an argument, and return a string of length 26.
# The objective is to set each of the 26 characters of the output string to either '1' or '0'
# based on the fact whether the Nth letter of the alphabet is present in the input (independent of its case).
# So if an 'a' or an 'A' appears anywhere in the input string (any number of times),
# set the first character of the output string to '1', otherwise to '0'.
# if 'b' or 'B' appears in the string, set the second character to '1', and so on for the rest of the alphabet.
def change(st):
    alp = "abcdefghijklmnopqrstuvwxyz"
    return "".join(["1" if c in st or c.upper() in st else "0" for c in alp]) if len(st) else "00000000000000000000000000"

# There are two lists, possibly of different lengths. The first one consists of keys,
# the second one consists of values. Write a function createDict(keys, values)
# that returns a dictionary created from keys and values. If there are not enough values,
# the rest of keys should have a None (JS null)value. If there not enough keys, just ignore the rest of values.
def createDict(keys, values):
    return {k:(values[e] if e<len(values) else None) for e,k in enumerate(keys)}

# dataand data1 are two strings with rainfall records of a few cities for months from January
# to December. The records of towns are separated by \n. The name of each town is followed by :.
# data and towns can be seen in "Your Test Cases:".
# Task:
# function: mean(town, strng) should return the average of rainfall
# for the city town and the strng data or data1 (In R and Julia this function is called avg).
# function: variance(town, strng) should return the variance of rainfall
# for the city town and the strng data or data1.
import re
def mean(town, strng):
    data_split = re.findall(r'.+(?:\n|$)', strng)
    for counter, town_info in enumerate(data_split):
        if town in town_info:
            town_name = re.match(r'\w+', town_info)
            if town != town_name.group():
                continue
            numbers = re.findall(r'\d+\.?\d+', town_info)
            float_numbers = [float(x) for x in numbers]
            return sum(float_numbers)/len(float_numbers)
    return -1
def variance(town, strng):
    data_split = re.findall(r'.+(?:\n|$)', strng)
    for counter, town_info in enumerate(data_split):
        if town in town_info:
            town_name = re.match(r'\w+', town_info)
            if town != town_name.group():
                continue
            numbers = re.findall(r'\d+\.?\d+', town_info)
            float_numbers = [float(x) for x in numbers]
            mean = sum(float_numbers)/len(float_numbers)
            squared_nums = [(x-mean)**2 for x in float_numbers]
            return sum(squared_nums)/(len(squared_nums))
    return -1

# Your task is to write a higher order function for chaining together a list of unary functions.
# In other words, it should return a function that does a left fold on the given functions.
def chained(functions):
    def apply(param):
        result = param
        for f in functions:
            result = f(result)
        return result
    return apply

Unscramble the eggs.

# The string given to your function has had an "egg"
# inserted directly after each consonant. You need to return the string before it became eggcoded.
def unscramble_eggs(word):
    return word.replace('egg','')

# Create function fib that returns n'th element of Fibonacci sequence (classic programming task).
def fibonacci(n: int) -> int:
    a, b = 0, 1
    for i in range(n):
        a,b = b, a+b
    return a

# In this Kata, you will be given an array of unique elements, and your task
# is to rearrange the values so that the first max value is followed by the first minimum,
# followed by second max value then second min value, etc.
def solve(arr):
    l = sorted(arr, reverse=True)
    ls = []
    for i in range(len(arr)//2+1):
        ls.append(l[i])
        ls.append(l[::-1][i])
    return ls[:-2] if len(arr)%2 == 0 else ls[:-1]

# You are given a string of letters and an array of numbers.
# The numbers indicate positions of letters that must be removed, in order,
# starting from the beginning of the array.
# After each removal the size of the string decreases (there is no empty space).
# Return the only letter left.
def last_survivor(letters, coords):
    for i in coords:
        letters = letters[:i] + letters[i+1:]
    return letters

# Complete the function power_of_two/powerOfTwo (or equivalent, depending on your language)
# that determines if a given non-negative integer is a power of two. From the corresponding Wikipedia entry:
# a power of two is a number of the form 2n where n is an integer,
# i.e. the result of exponentiation with number two as the base and integer n as the exponent.
# You may assume the input is always valid.
def power_of_two(n: int) -> list:
    i = 2
    while i < n:
        i=i*2
    return i == n if n!=1 else True

# Complete the function which takes a non-zero integer as its argument.
# If the integer is divisible by 3, return the string "Java".
# If the integer is divisible by 3 and divisible by 4, return the string "Coffee"
# If one of the condition above is true and the integer is even, add "Script" to the end of the string.
# If none of the condition is true, return the string "mocha_missing!"
def caffeine_buzz(n):
    i = ''
    if n % 3 == 0 and n % 4 == 0:
        i += 'Coffee'
    elif n % 3 == 0:
        i += 'Java'
    else:
        return "mocha_missing!"
    if n % 2 == 0:
        i += 'Script'
    return i

# A new task for you!
# You have to create a method, that corrects a given time string.
# There was a problem in addition, so many of the time strings are broken.
# Time is formatted using the 24-hour clock, so from 00:00:00 to 23:59:59.
def time_correct(t):
    if not t:
        return t
    try:
        h, m, s = map(int, t.split(":"))
        s = h * 3600 + m * 60 + s
        _, s = divmod(s, 86400)
        h, s = divmod(s, 3600)
        m, s = divmod(s, 60)
        return "{:02}:{:02}:{:02}".format(h, m, s)
    except ValueError:
        return None

# Print all numbers up to 3rd parameter which are multiple of both 1st and 2nd parameter.
# Python, Javascript, Java, Ruby versions: return results in a list/array
# NOTICE:
# Do NOT worry about checking zeros or negative values.
# To find out if 3rd parameter (the upper limit) is inclusive or not,
# check the tests, it differs in each translation
def multiples(s1,s2,s3):
    l = []
    for i in range(1,s3):
        if i %s1 == 0 and i % s2 == 0:
            l.append(i)
    return l

# The aim of the kata is to try to show how difficult it can be to calculate
# decimals of an irrational number with a certain precision.
# We have chosen to get a few decimals of the number
# "pi" using the following infinite series (Leibniz 1646–1716):
# PI / 4 = 1 - 1/3 + 1/5 - 1/7 + ... which gives an approximation of PI / 4.
# http://en.wikipedia.org/wiki/Leibniz_formula_for_%CF%80
# To have a measure of the difficulty we will count how many
# iterations are needed to calculate PI with a given precision of epsilon.
# There are several ways to determine the precision of the calculus but to keep
# things easy we will calculate PI within epsilon of your language Math::PI constant.
# In other words, given as input a precision of epsilon we will stop the
# iterative process when the absolute value of the difference between our
# calculation using the Leibniz series and the Math::PI constant of your language is less than epsilon.
# Your function returns an array or a string or a tuple depending
# on the language (See sample tests) with
# your number of iterations
# your approximation of PI with 10 decimals
from math import pi
def iter_pi(epsilon):
    count = 1
    my_pi = 4.0
    while abs(pi - my_pi) > epsilon:
        if count % 2:
            my_pi -= (1.0 / (count * 2 + 1)) * 4
        else:
            my_pi += (1.0 / (count * 2 + 1)) * 4
        count += 1
    return [count, round(my_pi, 10)]

# Create a function isDivisible(n,...) that checks if the first argument
# n is divisible by all other arguments (return true if no other arguments)
def is_divisible(*args):
    l =[*args]
    return all(l[0] % i == 0 for i in l[1:])

# Help Suzuki rake his garden!
# The monastery has a magnificent Zen garden made of white gravel and rocks and it
# is raked diligently everyday by the monks. Suzuki having a keen eye
# is always on the lookout for anything creeping into the garden that must
# be removed during the daily raking such as insects or moss.
# You will be given a string representing the garden such as:
VALID = {'gravel', 'rock'}
def rake_garden(garden):
    return ' '.join(a if a in VALID else 'gravel' for a in garden.split())

# Let us begin with an example:
# Take a number: 56789. Rotate left, you get 67895.
# Keep the first digit in place and rotate left the other digits: 68957.
# Keep the first two digits in place and rotate the other ones: 68579.
# Keep the first three digits and rotate left the rest: 68597. Now it is over
# since keeping the first four it remains only one digit which rotated is itself.
# You have the following sequence of numbers:
# 56789 -> 67895 -> 68957 -> 68579 -> 68597
# and you must return the greatest: 68957.
# Task
# Write function max_rot(n) which given a positive integer n
# returns the maximum number you got doing rotations similar to the above example.
# So max_rot (or maxRot or ... depending on the language) is such as:
def max_rot(n):
    maximum = n
    s = list(str(n))
    for i in range(len(s) - 1):
        s.append(s.pop(i))
        current = int(''.join(s))
        if current > maximum:
            maximum = current
    return maximum

# Scenario
# the rhythm of beautiful musical notes is drawing a Pendulum
# Beautiful musical notes are the Numbers
# Task
# Given an array/list [] of n integers , Arrange them in a way similar to the to-and-fro movement of a Pendulum
# The Smallest element of the list of integers , must come in center position of array/list.
# The Higher than smallest , goes to the right .
# The Next higher number goes to the left of minimum number and So on ,
# in a to-and-fro manner similar to that of a Pendulum.
def pendulum(values):
    sorted_values = sorted(values)
    mid = [sorted_values [0]]
    right = sorted_values[1::2]
    left = sorted_values[2::2]
    return left[::-1] + mid + right

# Sort the given array of strings in alphabetical order, case insensitive. For example:
def sortme(words):
    return sorted(words,key=lambda x: x.lower())

# Write a function that returns a sequence (index begins with 1) of all the even characters
# from a string. If the string is smaller than two characters or longer than 100 characters,
# the function should return "invalid string".
def even_chars(st):
    return [i for i in st[1::2]] if 1 < len(st) < 100 else 'invalid string'

# The Stanton measure of an array is computed as follows: count the number
# of occurences for value 1 in the array. Let this count be n. The Stanton measure
# is the number of times that n appears in the array.
# Write a function which takes an integer array and returns its Stanton measure.
# Examples
# The Stanton measure of [1, 4, 3, 2, 1, 2, 3, 2] is 3, because 1 occurs 2 times
# in the array and 2 occurs 3 times.
# The Stanton measure of [1, 4, 1, 2, 11, 2, 3, 1] is 1, because 1 occurs 3 times
# in the array and 3 occurs 1 time.
def stanton_measure(arr):
    return arr.count(arr.count(1))

# There exist two zeroes: +0 (or just 0) and -0.
# Write a function that returns true if the input number is -0 and false otherwise (True and False for Python).
# In JavaScript / TypeScript / Coffeescript the input will be a number.
# In Python / Java / C / NASM / Haskell / the input will be a float.
def is_negative_zero(n):
    return str(n) == '-0.0'

# Our loose definition of Vampire Numbers can be described as follows:
def vampire_test(x, y):
    l = [i for i in str(x * y)]
    w = str(x) + str(y)
    return all(i in l for i in w) and len(w) == len(l)

# Task
# Using n as a parameter in the function pattern, where n>0,
# \complete the codes to get the pattern (take the help of examples):
# Note: There is no newline in the end (after the pattern ends)
# Examples
# pattern(3) should return "1\n1*2\n1**3", e.g. the following:
def pattern(n):
    OUTPUT = '1{}{}'.format
    return '\n'.join(OUTPUT('*' * a, a + 1 if a else '') for a in range(n))

# The UK driving number is made up from the personal details of the driver. The individual letters
# and digits can be code using the below information
from dateutil.parser import parse
def driver(data):
    lic = ""
    if len(data[2]) >= 5:
          lic += data[2][:5]
    else:
            lic += data[2]
            while (len(lic) < 5): lic += "9"
    lic += (str(parse(data[3]).year))[2]
    month = parse(data[3]).month
    if data[4] == "F": month += 50
    month = str(month)
    if len(month) == 1: month = "0" + month
    lic += month
    day = str(parse(data[3]).day)
    if len(day) == 1: day = "0" + day
    lic += day
    lic += (str(parse(data[3]).year))[3]
    lic +=  data[0][:1]
    if (data[1]) != "":
        lic += data[1][:1]
    else:
        lic += "9"
    lic += "9AA"
    return lic.upper()

# Given the sum and gcd of two numbers, return those two numbers in ascending order.
# If the numbers do not exist, return -1, (or NULL in C, tuple (-1,-1)
# in C#, pair (-1,-1) in C++,None in Rust, array {-1,-1}  in Java and Golang).
def solve(s,g):
    for i in range(g, s+1, g):
        remainder = s - i
        if remainder % g == 0:
            return (i, remainder)
    return -1

# Write a function generateIntegers/generate_integers that accepts a single argument
# n/$n and generates an array containing the integers from 0 to n/$n inclusive.
# For example, generateIntegers(3)/generate_integers(3) should return [0, 1, 2, 3].
# n/$n can be any integer greater than or equal to 0.
def generate_integers(n):
    return list(range(n + 1))

# An element in an array is dominant if it is greater than all elements to its right.
# You will be given an array and your task will be to return a list of all dominant elements. For example:
def solve(arr):
    l = []
    for i in range(len(arr)):
        if max(arr[i:]) == arr[i] and arr[i] not in l:
            l.append(arr[i])
    return l

# Some people just have a first name; some people have first
# and last names and some people have first, middle and last names.
# You task is to initialize the middle names (if there is any).
def initialize_names(name):
    arr = name.split()
    l = []
    if len(arr)>2:
        l.append(arr[0])
        for i in arr[1:-1]:
            l.append(i[0].upper()+'.')
        l.append(arr[-1])
        return ' '.join(l)
    return name

# You are the developer working on a website which features a large counter
# on its homepage, proudly displaying the number of happy customers who have downloaded your companies software.
# You have been tasked with adding an effect to this counter to make it more interesting.
# Instead of just displaying the count value immediatley when the page loads,
# we want to create the effect of each digit cycling through its preceding
# numbers before stopping on the actual value.
# Task
# As a step towards achieving this; you have decided to create a function
# that will produce a multi-dimensional array out of the hit count value.
# Each inner dimension of the array represents an individual digit in the
# hit count, and will include all numbers that come before it, going back to 0.
# Rules
# The function will take one argument which will be a four character string representing hit count
# The function must return a multi-dimensional array containing four inner arrays
# The final value in each inner array must be the actual value to be displayed
# Values returned in the array must be of the type number
def counter_effect(hit_count):
    return [range(int(i)+1) for i in hit_count]

# Peter can see a clock in the mirror from the place he sits in the office. When he saw the clock shows 12:22
# He knows that the time is 11:38
# in the same manner:
# 05:25 --> 06:35
# 01:50 --> 10:10
# 11:58 --> 12:02
# 12:01 --> 11:59
# Please complete the function WhatIsTheTime(timeInMirror),
# where timeInMirror is the mirrored time (what Peter sees) as string.
# Return the real time as a string.
# Consider hours to be between 1 <= hour < 13.
# So there is no 00:20, instead it is 12:20.
# There is no 13:20, instead it is 01:20.
def what_is_the_time(time_in_mirror):
    hour = int(time_in_mirror[0:2])
    minute = int(time_in_mirror[3:5])
    if hour < 11:
        hour1 = 11 - hour
    else:
        hour1 = 23 - hour
    minute1 = 60 - minute
    if minute1 == 60:
        minute1 -=60
        hour1 += 1
    if hour1 > 12:
        hour1 -=12
    ans = ""
    if hour1 > 9 :
        ans = str(hour1) + ':'
    else:
        ans = '0' + str(hour1) + ':'
    if minute1 > 9:
        ans += str(minute1)
    else:
        ans += '0' + str(minute1)
    return ans

# Remove all exclamation marks from sentence except at the end.
def remove(s):
    count = 0
    j = s
    while j.endswith('!'):
        count += 1
        j = j[:-1]
    r = (len(s)-len(j))
    return j.replace('!', '') + '!' * r

# You have to create a function calcType, which receives 3 arguments: 2 numbers,
# and the result of an unknown operation performed on them (also a number).
# Based on those 3 values you have to return a string, that describes which operation
# was used to get the given result.
# The possible return strings are: "addition", "subtraction", "multiplication", "division".
def calc_type(a, b, res):
    if a+b==res:
        return 'addition'
    elif a-b==res:
        return 'subtraction'
    elif a*b==res:
        return 'multiplication'
    elif a/b==res:
        return 'division'

# You will be given an array which will include both integers and characters.
# Return an array of length 2 with a[0] representing the mean of the ten
# integers as a floating point number. There will always be 10 integers and 10 characters.
# Create a single string with the characters and return it as a[1] while maintaining the original order.
def mean(lst):
    return [sum(int(i) for i in lst if i.isdigit())/10, ''.join(j for j in lst if j.isalpha())]

# Write reverseList function that simply reverses lists.
def reverse_list(lst):
    return lst[::-1]


# Write function heron which calculates the area of a
# triangle with sides a, b, and c (x, y, z in COBOL). Heron 's formula:
# s∗(s−a)∗(s−b)∗(s−c)\sqrt {s * (s - a) * (s - b) * (s - c)} s∗(s−a)∗(s−b)∗(s−c)
# Output should have 2 digits precision.
def heron(a, b, c):
    i=(a+b+c)/2
    return round((i*(i-a)*(i-b)*(i-c))**.5, 2)

# A zero-indexed array arr consisting of n integers is given. The dominator of array
# arr is the value that occurs in more than half of the elements of arr.
# For example, consider array arr such that arr = [3,4,3,2,3,1,3,3]
# The dominator of arr is 3 because it occurs in 5 out of 8 elements of arr and 5 is more than a half of 8.
# Write a function dominator(arr) that, given a zero-indexed array arr consisting of n integers,
# returns the dominator of arr. The function should return −1 if array does not have a dominator.
# All values in arr will be >=0.
def dominator(arr):
    w = [i for i in arr if arr.count(i) > len(arr)//2]
    return w[0] if w else -1

# Christmas is coming, and Santa has a long list to go through, to find who deserves presents for the
# big day. Go through a list of children, and return
# a list containing every child who appeared on Santa's list.
# Do not add any child more than once. Output should be sorted.
# Comparison should be case sensitive and the returned list should contain only one copy of
# each name: "Sam" and "sam" are different, but "sAm" and "sAm" are not.
def find_children(santas_list, children):
    return sorted(set([child for child in children if child in santas_list]))

# Create a method that takes an array/list as an input,
# and outputs the index at which the sole odd number is located.
# This method should work with arrays with negative numbers. If there are
# no odd numbers in the array, then the method should output -1.
def odd_one(arr):
    try:
        return arr.index(max([i for i in arr if i%2!=0]))
    except:
        return -1

# Lot of museum allow you to be a member, for a certain
# amount amount_by_year you can have unlimitted acces to the museum.
# In this kata you should complete a function in order to know after how many visit it
# will be better to take an annual pass. The function take 2 arguments annual_price and individual_price.
import math
def how_many_times(annual_price, individual_price):
    return math.ceil(annual_price/individual_price)

# Move all exclamation marks to the end of the sentence
def remove(s):
    count = s.count('!')
    return s.replace('!', '') + '!'*count

# Digital Cypher assigns to each letter of the alphabet unique number. For example:
# a  b  c  d  e  f  g  h  i  j  k  l  m
# 1  2  3  4  5  6  7  8  9 10 11 12 13
# n  o  p  q  r  s  t  u  v  w  x  y  z
# 14 15 16 17 18 19 20 21 22 23 24 25 26
# Instead of letters in encrypted word we write the corresponding number, eg. The word scout:
#  s  c  o  u  t
# 19  3 15 21 20
# Then we add to each obtained digit consecutive digits from the key. For example. In case of key equal to 1939 :
def encode(message, key):
    letter_dict = {
        'a': 1,'b': 2,
        'c': 3,'d': 4,'e': 5,'f': 6,'g': 7,'h': 8,'i': 9,'j': 10,'k': 11,'l': 12,'m': 13,'n': 14,'o': 15,'p': 16,
        'q': 17,'r': 18,'s': 19,'t': 20,'u': 21,'v': 22,'w': 23,'x': 24,'y': 25,'z': 26
        }
    num_list = []
    key_list = str(key)
    x = 0
    for i in message:
        num_list.append(letter_dict[i] + int(key_list[x]))
        x += 1
        if x >= len(key_list):
            x = 0
    return num_list

# Is every value in the array an array?
# This should only test the second array dimension of the array.
# The values of the nested arrays don't have to be arrays.
def arr_check(arr):
    return all(type(i) == list for i in arr)

# Your task is very simple. Just write a function takes an input string
# of lowercase letters and returns true/false depending on whether the string is in alphabetical order or not.
# Examples (input -> output)
# "kata" -> false ('a' comes after 'k')
# "ant" -> true (all characters are in alphabetical order)
def alphabetic(s):
    return s == "".join(sorted(s))

# Write function replaceAll (Python: replace_all) that will replace all occurrences of an item with another.
# Python / JavaScript: The function has to work for strings and lists.
# Example: replaceAll [1,2,2] 1 2 -> in list [1,2,2] we replace 1 with 2 to get new list [2,2,2]
def replace_all(obj, find, replace):
    if type(obj) == list:
        return [replace if i == find else i for i in obj]
    return obj.replace(find, replace)

# Learning to code around your full time job is taking over your life. You realise
# that in order to make significant steps quickly, it would help to go to a coding bootcamp in London.
# Problem is, many of them cost a fortune, and those that don't still
# involve a significant amount of time off work - who will pay your mortgage?!
# To offset this risk, you decide that rather than leaving work totally, you will request a
# sabbatical so that you can go back to work post bootcamp and be paid while you look for your next role.
# You need to approach your boss. Her decision will be based on three parameters:
# val = your value to the organisation
# happiness = her happiness level at the time of asking and finally
# The numbers of letters from 'sabbatical' that are present in string s.
# Note that if s contains three instances of the letter 'l', that still
# scores three points, even though there is only one in the word sabbatical.
# If the sum of the three parameters (as described above) is > 22, return 'Sabbatical!
# Boom!', else return 'Back to your desk, boy.'.
# FUNDAMENTALSSTRINGSARRAYSMATHEMATICS
import re
def sabb(s, value, happiness):
    letters = re.findall('[sabatical]', s)
    return 'Sabbatical! Boom!' if len(letters) + value + happiness > 22 else 'Back to your desk, boy.'

# Given an array, return the difference between the count of even numbers
# and the count of odd numbers. 0 will be considered an even number.
# For example:
# solve([0,1,2,3]) = 0 because there are two even numbers and two odd numbers. Even - Odd = 2 - 2 = 0.
# Let's now add two letters to the last example:
# solve([0,1,2,3,'a','b']) = 0. Again, Even - Odd = 2 - 2 = 0. Ignore letters.
# The input will be an array of lowercase letters and numbers only.
# In some languages (Haskell, C++, and others), input will be an array of strings:
def solve(a):
    count_e = 0
    count_o = 0
    for elem in a:
        if str(elem).isdigit():
            if elem %2==0:
                count_e += 1
            elif elem %2!=0:
                count_o += 1
    return count_e - count_o

# Implement the method length, which accepts a linked list (head), and returns the length of the list.
# For example: Given the list: 1 -> 2 -> 3 -> 4, length should return 4.
def length(head):
    if head == None:
        return 0
    elif head:
        number = 1
        while head.next:
              head = head.next
              number += 1
        return number

# In this Kata, we will check if a string contains consecutive letters
# as they appear in the English alphabet and if each letter occurs only once.
def solve(s):
    return "".join(sorted(s)) in "abcdefghijklmnopqrstuvwxyz"

# So you've found a meeting room - phew! You arrive there ready to present,
# and find that someone has taken one or more of the chairs!!
# You need to find some quick.... check all the other meeting rooms to see if all of the chairs are in use.
# Your meeting room can take up to 8 chairs. need will tell you
# how many have been taken. You need to find that many.=
# Find the spare chairs from the array of meeting rooms. Each meeting
# room tuple will have the number of occupants as a string.
# Each occupant is represented by 'X'. The room tuple will also
# have an integer telling you how many chairs there are in the room.
# You should return an array of integers that shows how many chairs you take
# from each room in order, up until you have the required amount.
# example:
# [['XXX', 3], ['XXXXX', 6], ['XXXXXX', 9], ['XXX',2]] when you need 4 chairs:
# result -> [0, 1, 3] no chairs free in room 0, take 1 from room 1, take 3 from room 2. no need to
# consider room 3 as you have your 4 chairs already.
# If you need no chairs, return "Game On". If there aren't enough spare chairs available, return "Not enough!".
def meeting(rooms, need):
    if need == 0:
        return 'Game On'
    count = []
    for room in rooms:
        if room[1] - len(room[0]) >0:
            if room[1] - len(room[0]) >= need:
                count.append(need)
                return count
            else:
                count.append(room[1] - len(room[0]))
                need -= room[1] - len(room[0])
        else:
            count.append(0)
    return "Not enough!"

# As you may know, once some people pass their teens, they jokingly only celebrate their 20th or 21st birthday,
# forever. With some maths skills, that's totally possible - you only need to select the correct number base!
# For example, if they turn 32, that's exactly 20 - in base 16... Already 39? That's just 21, in base 19!
# Your task is to translate the given age to the much desired 20 (or 21) years,
# and indicate the number base, in the format specified below.
# Note: input will be always > 21
def womens_age(n):
    base = n // 2
    remainder = n % 2
    return "{}? That's just {}, in base {}!".format(n, 20 + remainder, base)

# You are going to be given an array of integers. Your job is to take that array
# and find an index N where the sum of the integers to the left of N is equal
# to the sum of the integers to the right of N. If there is no index that would make this happen, return -1.
# For example:
# Let's say you are given the array {1,2,3,4,3,2,1}:
# Your function will return the index 3, because at the 3rd position of the array,
# the sum of left side of the index ({1,2,3}) and the sum of the right side of the index ({3,2,1}) both equal 6.
# Let's look at another one.
# You are given the array {1,100,50,-51,1,1}:
# Your function will return the index 1, because at the 1st position of the array,
# the sum of left side of the index ({1}) and the sum of the right side of the index ({50,-51,1,1}) both equal 1.
# Last one:
# You are given the array {20,10,-80,10,10,15,35}
# At index 0 the left side is {}
# The right side is {10,-80,10,10,15,35}
# They both are equal to 0 when added. (Empty arrays are equal to 0 in this problem)
# Index 0 is the place where the left side and right side are equal.
# Note: Please remember that in most programming/scripting languages the index of an array starts at 0.
def find_even_index(arr):
    for i in range(len(arr)):
        if sum(arr[:i]) == sum(arr[i+1:]):
            return i
    return -1

# Remove words from the sentence if they contain exactly one exclamation mark.
# Words are separated by a single space, without leading/trailing spaces.
def remove(s):
    return ' '.join(filter(lambda word: word.count('!') != 1, s.split(' ')))

# With a friend we used to play the following game on a chessboard (8, rows, 8 columns). On
# the first row at the bottom we put numbers:
# 1/2, 2/3, 3/4, 4/5, 5/6, 6/7, 7/8, 8/9
# On row 2 (2nd row from the bottom) we have:
# 1/3, 2/4, 3/5, 4/6, 5/7, 6/8, 7/9, 8/10
# On row 3:
# 1/4, 2/5, 3/6, 4/7, 5/8, 6/9, 7/10, 8/11
# until last row:
# 1/9, 2/10, 3/11, 4/12, 5/13, 6/14, 7/15, 8/16
# When all numbers are on the chessboard each in turn we toss a coin. The one who get
# "head" wins and the other gives him, in dollars, the sum of the numbers on the chessboard.
# We play for fun, the dollars come from a monopoly game!
# Task
# How much can I (or my friend) win or loses for each game if the chessboard has n rows
# and n columns? Add all of the fractional values on an n by n sized board and give the
# answer as a simplified fraction.
# See Sample Tests for each language
# Ruby, Python, JS, Coffee, Clojure, PHP, Elixir, Crystal, Typescript, Go:
# The function called 'game' with parameter n (integer >= 0) returns as result an
# irreducible fraction written as an array of integers: [numerator, denominator].
# If the denominator is 1 return [numerator].
def game(n):
    if n == 0: return [0]
    if n == 1: return [1, 2]
    if n == 2: return [3, 2]
    if n == 3: return [9, 2]
    s, step = 4.5, 3.5
    for _ in range(n-3):
        s = s + step
        step += 1.0
    if int(s) == s: return [s]
    else: return [int(str(2*int(s)+1)), 2]

# You will be given an array of numbers.
# For each number in the array you will need to create an object.
# The object key will be the number, as a string. The value will be the corresponding character code, as a string.
# Return an array of the resulting objects.
# All inputs will be arrays of numbers.
# All character codes are valid lower case letters. The input array will not be empty.
def num_obj(s):
    return [{str(i) : chr(i)} for i in s]

# The prime numbers are not regularly spaced. For example from 2 to
# 3 the step is 1. From 3 to 5 the step is 2. From 7 to 11 it is 4.
# Between 2 and 50 we have the following pairs of 2-steps primes:
# 3, 5 - 5, 7, - 11, 13, - 17, 19, - 29, 31, - 41, 43
# We will write a function step with parameters:
# g (integer >= 2) which indicates the step we are looking for,
# m (integer >= 2) which gives the start of the search (m inclusive),
# n (integer >= m) which gives the end of the search (n inclusive)
# In the example above step(2, 2, 50) will return [3, 5] which is the first pair between 2 and 50 with a 2-steps.
# So this function should return the first pair of the two prime numbers spaced with a step of g between the
# limits m, n if these g-steps prime numbers exist otherwise
# nil or null or None or Nothing or [] or "0, 0" or {0, 0} or 0 0 or "" (depending on the language).
def step(g, m, n):
    prime_list = []
    for num in range(m, n):
        number_prime = isPrime(num)
        prime_list.append(number_prime)
        if number_prime == True:
            if len(prime_list) > g:
                if prime_list[num-g-m] == True:
                    return [num-g, num]
            else:
                previous_prime = num
def isPrime(num):
    for i in range(2, num):
        if num % i == 0:
            return False
        elif i*i > num:
            return True
    return True

# What is your favourite day of the week? Check if it's the most frequent day of the week in the year.
# You are given a year as integer (e. g. 2001). You should
# return the most frequent day(s) of the week in that year.
# The result has to be a list of days sorted by the order
# of days in week (e. g. ['Monday', 'Tuesday'], ['Saturday', 'Sunday'],
# ['Monday', 'Sunday']). Week starts with Monday.
# Input: Year as an int.
# Output: The list of most frequent days sorted by the order of days in week (from Monday to Sunday).
# Preconditions:
# Week starts on Monday.
# Year is between 1583 and 4000.
# Calendar is Gregorian.
from datetime import date
def most_frequent_days(year):
    names = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
    start = date(year,1,1).weekday()
    end = date(year, 12, 31).weekday()
    days = list(range(start, 7)) + list(range(0 ,end +1))
    total = days.count(max(days,key=days.count))
    result = []
    for day in [0,1,2,3,4,5,6]:
        if day in days:
            if days.count(day) == total:
                result.append(day)
    return list(map(lambda x: names[x], result))

# Kata Task
# stations is a list/array of distances (miles) from one station to the next along the Pony Express route.
# Implement the riders method/function, to return how many riders are necessary
# to get the mail from one end to the other.
# NOTE: Each rider travels as far as he can, but never more than 100 miles.
def riders(stations):
	riders, travelled = 1, 0
	for miles in stations:
		if travelled + miles > 100:
			riders += 1
			travelled = miles
		else:
			travelled += miles
	return riders

# Remove all exclamation marks from the end of words. Words are separated by a
# single space. There are no exclamation marks within a word.
def remove(s):
    l = []
    for i in s.split():
        while i.endswith('!'):
            i = i[:-1]
        l.append(i)
    return ' '.join(l)

# Given an array, find the duplicates in that array, and return a new array of those
# duplicates. The elements of the returned array should appear in the order when they first appeared as duplicates.
# Note: numbers and their corresponding string representations should not
# be treated as duplicates (i.e., "1" != 1).
def duplicates(array):
    l = []
    d = []
    for elem in array:
        if elem not in l:
            l.append(elem)
            continue
        elif elem in l and elem not in d:
            d.append(elem)
    return d

# The depth of an integer n is defined to be how many multiples
# of n it is necessary to compute before all 10 digits have appeared at least once in some multiple.
def compute_depth(n):
    l = []
    count = 1
    while len(l)<10:
        s = n*count
        for i in str(s):
            if i not in l:
                l.append(i)
        count+=1
    return count-1

# Some people have been killed!
# You have managed to narrow the suspects down to just a few. Luckily, you know every
# person who those suspects have seen on the day of the murders.
# Task.
# Given a dictionary with all the names of the suspects and everyone that they have
# seen on that day which may look like this:
def killer(suspect_info, dead):
    for k,v in suspect_info.items():
        if all(i in v for i in dead):
            return k

# You must create a function, spread, that takes a function and
# a list of arguments to be applied to that function. You must make this function return
# the result of calling the given function/lambda with the given arguments.
def spread(func, args):
    return func(*args)

# Complete the function that takes an array of words.
# You must concatenate the nth letter from each word to construct a new
# word which should be returned as a string, where n is the position of the word in the list.
def nth_char(words):
    word = ''
    i = 0
    while i < len(words):
        word += words[i][i]
        i+=1
    return word

# In this kata, your job is to create a class Dictionary which you can add words to and their entries. Example:
class Dictionary():
    def __init__(self):
        self.d = {}

    def newentry(self, word, definition):
        self.word = word
        self.definition = definition
        self.d[self.word] = self.definition

    def look(self, key):
        self.key = key
        try:
            return self.d[self.key]
        except:
            return f"Can't find entry for {self.key}"

# Write a generic function chainer
# Write a generic function chainer that takes a starting value,
# and an array of functions to execute on it (array of symbols for Ruby).
# The input for each function is the output of the previous function
# (except the first function, which takes the starting value as its input).
# Return the final value after execution is complete.
def chain(init_val, functions):
    for func in functions:
        init_val = func(init_val)
    return init_val

# You'll be given a list of two strings, and each will contain exactly one colon (":") in the middle
# (but not at beginning or end). The length of the strings, before and after the colon, are random.
# Your job is to return a list of two strings
# (in the same order as the original list), but with the characters after each colon swapped.
def tail_swap(strings):
    l = []
    final = []
    for i in strings:
        for elem in i.split(':'):
            l.append(elem)
    final.append(l[0] + ':' + l[3])
    final.append(l[2] + ':' + l[1])
    return final

# Slot machine (American English), informally fruit machine (British English), puggy
# (Scottish English slang), the slots (Canadian and American English), poker machine
# (or pokies in slang) (Australian English and New Zealand English) or
# simply slot (American English), is a casino gambling machine with three
# or more reels which spin when a button is pushed. Slot machines are
# also known as one-armed bandits because they were originally operated by one lever on
# the side of the machine as distinct from a button on the front panel,
# and because of their ability to leave the player in debt and impoverished.
# Many modern machines are still equipped with a legacy lever in addition to the button. (Source Wikipedia)
# Task
# You will be given three reels of different images and told at
# which index the reels stop. From this information your job is to return the score of the resulted reels.
# Rules
# 1. There are always exactly three reels
# 2. Each reel has 10 different items.
# 3. The three reel inputs may be different.
# 4. The spin array represents the index of where the reels finish.
# 5. The three spin inputs may be different
# 6. Three of the same is worth more than two of the same
# 7. Two of the same plus one "Wild" is double the score.
# 8. No matching items returns 0.
def fruit(reels, spins):
    triple = {
        'Wild Wild Wild': 100, 'Star Star Star': 90, 'Bell Bell Bell': 80,
        'Shell Shell Shell': 70, 'Seven Seven Seven': 60, 'Cherry Cherry Cherry': 50,
        'Bar Bar Bar': 40, 'King King King': 30, 'Queen Queen Queen': 20, 'Jack Jack Jack': 10
    }
    double = {
        'Wild': 10, 'Star': 9, 'Bell': 8, 'Shell': 7, 'Seven': 6, 'Cherry': 5, 'Bar': 4, 'King': 3,
        'Queen': 2, 'Jack': 1
    }
    l = [reels[0][spins[0]], reels[1][spins[1]], reels[2][spins[2]]]
    if l[0] == l[1] or l[0] == l[2] or l[1] == l[2]:
        if l[0] == l[1] == l[2]:
            return triple[' '.join(sorted(l))]
        elif (l.count(l[0]) == 2 or l.count(l[1]) == 2) and l.count('Wild') != 1:
            for elem in l:
                if l.count(elem) == 2:
                    return double[elem]
        elif (l.count(l[0]) == 2 or l.count(l[1]) == 2) and l.count('Wild') == 1:
            for elem in l:
                if l.count(elem) == 2:
                    return double[elem] * 2
    return 0

# If you have completed the Tribonacci sequence kata, you would know by now that
# mister Fibonacci has at least a bigger brother. If not, give it a quick look to get how things work.
# Well, time to expand the family a little more: think of
# a Quadribonacci starting with a signature of 4 elements and each following element is
# the sum of the 4 previous, a Pentabonacci (well Cinquebonacci would probably sound a bit more italian,
# but it would also sound really awful) with a signature of 5 elements
# and each following element is the sum of the 5 previous, and so on.
# Well, guess what? You have to build a Xbonacci function that takes a signature of X elements -
# and remember each next element is the sum of the last X elements -
# and returns the first n elements of the so seeded sequence.
def Xbonacci(signature,n):
    result = signature[:]
    for x in range(n-len(signature)):
        current_fib = 0
        start = len(result) - len(signature)
        for y in result[start:]:
            current_fib += y
        result.append(current_fib)
    return result[:n]

# You love coffee and want to know what beans you can afford to buy it.
# The first argument to your search function will be a number which represents your budget.
# The second argument will be an array of coffee bean prices.
# Your 'search' function should return the stores that sell coffee within your budget.
# The search function should return a string of prices for the coffees
# beans you can afford. The prices in this string are to be sorted in ascending order.
def search(budget, prices):
    return ','.join(str(i) for i in sorted(list(filter(lambda x: x<= budget, prices))))

# Write a function called "filterEvenLengthWords".
# Given an array of strings, "filterEvenLengthWords" returns an array
# containing only the elements of the given array whose length is an even number.
# var output = filterEvenLengthWords(['word', 'words', 'word', 'words']);
# console.log(output); // --> ['word', 'word']
def filter_even_length_words(words):
    return [word for word in words if len(word) % 2 == 0]

# Write a function that takes a list (in Python) or array (in other languages)
# of numbers, and makes a copy of it.
# Note that you may have troubles if you do not return an actual copy,
# item by item, just a pointer or an alias for an existing list or array.
# If not a list or array is given as a parameter in interpreted languages, the function should raise an error.
def copy_list(l):
    copy = [i for i in l]
    return copy

# One suggestion to build a satisfactory password is to start with a memorable phrase
# or sentence and make a password by extracting the first letter of each word.
# ven better is to replace some of those letters with numbers (e.g., the letter
# O can be replaced with the number 0):
# instead of including i or I put the number 1 in the password;
# instead of including o or O put the number 0 in the password;
# instead of including s or S put the number 5 in the password.
def make_password(phrase):
    d = {'i': '1', 'o': '0', 's':'5'}
    word = [i[0] for i in phrase.split()]
    return ''.join(d[i.lower()] if i.lower() in d else i for i in word)

# Sort the Vowels!
# In this kata, we want to sort the vowels in a special format.
# Task
# Write a function which takes a input string s and return a string in the following way:
def sort_vowels(s):
    try:
        return '\n'.join(i+'|' if i.lower() not in 'aeoiu' else '|'+i for i in s)
    except:
        return ''

# Vowel harmony is a phenomenon in some languages. It means that "A
# vowel or vowels in a word are changed to sound the same (thus "in harmony.")" (wikipedia).
# This kata is based on vowel harmony in Hungarian.
# Task:
# Your goal is to create a function dative() (Dative() in C#) which returns
# the valid form of a valid Hungarian word w in dative case i. e.
# append the correct suffix nek or nak to the word w based on vowel harmony rules.
# Vowel Harmony Rules (simplified)
# When the last vowel in the word is
# a front vowel (e, é, i, í, ö, ő, ü, ű) the suffix is -nek
# a back vowel (a, á, o, ó, u, ú) the suffix is -nak
def dative(word):
    for letter in word[::-1]:
        if letter in "eéiíöőüű":
            return word + "nek"
        elif letter in "aáoóuú":
            return word + "nak"

# A Cartesian coordinate system is a coordinate system that specifies each point uniquely
# in a plane by a pair of numerical coordinates, which are the signed distances to
# the point from two fixed perpendicular directed lines, measured in the same unit of length.
# The сoordinates of a point in the grid are written as (x,y). Each point in a
# coordinate system has eight neighboring points. Provided that the grid step = 1.
# It is necessary to write a function that takes a coordinate on the x-axis and y-axis
# and returns a list of all the neighboring points. Points inside your returned list
# need not be sorted (any order is valid).
def cartesian_neighbor(x, y):
    return [(x - 1, y - 1), (x - 1, y), (x - 1, y + 1), (x, y - 1), (x, y + 1), (x + 1, y - 1), (x + 1, y),
            (x + 1, y + 1)]

# i is the imaginary unit, it is defined by i²=−1i² = -1i²=−1,
# therefore it is a solution to x²+1=0x² + 1 = 0x²+1=0.
# Your Task
# Complete the function pofi that returns iii to the power of a given non-negative integer
# in its simplest form, as a string (answer may contain iii).
def pofi(n):
    return ['1','i','-1','-i'][n % 4]

# Count how often sign changes in array.
# result
# number from 0 to ... . Empty array returns 0
def catch_sign_change(lst):
    return sum((x>=0)!=(y>=0) for x, y in zip(lst,lst[1:]))

# When you sign up for an account somewhere, some websites do not actually store
# your password in their databases. Instead, they will transform your password into something
# else using a cryptographic hashing algorithm.
# After the password is transformed, it is then called a password hash. Whenever you try to login,
# the website will transform the password you tried
# using the same hashing algorithm and simply see if the password hashes are the same.
# Create the function that converts a given string into an md5 hash. The return value
# should be encoded in hexadecimal.
from hashlib import md5
def pass_hash(str):
    return md5(str.encode()).hexdigest()

# In this kata you parse RGB colors represented by strings.
# The formats are primarily used in HTML and CSS.
# Your task is to implement a function which takes a color as a string and returns
# the parsed color as a map (see Examples).
def parse_html_color(color):
    color = PRESET_COLORS.get(color.lower(), color)
    if len(color) == 7:
        r, g, b = (int(color[i:i+2], 16) for i in range(1, 7, 2))
    else:
        r, g, b = (int(color[i+1]*2, 16) for i in range(3))
    return dict(zip("rgb", (r, g, b)))

# Digital Cypher assigns to each letter of the alphabet unique number. For example:
# a  b  c  d  e  f  g  h  i  j  k  l  m
# 1  2  3  4  5  6  7  8  9 10 11 12 13
# n  o  p  q  r  s  t  u  v  w  x  y  z
# 14 15 16 17 18 19 20 21 22 23 24 25 26
# Instead of letters in encrypted word we write the corresponding number, eg. The word scout:
# s  c  o  u  t
# 19  3 15 21 20
# Then we add to each obtained digit consecutive digits from the key. For example. In case of key equal to 1939 :
def decode(code, key):
    key=str(key)
    return "".join([chr(code[i] +96 - int(key[i%len(key)])) for i in range(0, len(code))])

# Write a program that, given a word, computes the scrabble score for that word.
def scrabble_score(st):
    w1 = 'A,E,I,O,U,L,N,R,S,T'
    w2 = 'D,G'
    w3 = 'B,C,M,P'
    w4 = 'F,H,V,W,Y'
    w5 = 'K'
    w6 = 'JX'
    w7 = 'QZ'
    count = 0
    st.replace(' ', '')
    for i in st.upper():
        if i in w1:
            count +=1
        elif i in w2:
            count += 2
        elif i in w3:
            count += 3
        elif i in w4:
            count += 4
        elif i in w5:
            count += 5
        elif i in w6:
            count += 8
        elif i in w7:
            count += 10
    return count

# Your story
# You've always loved both Fizz Buzz katas and cuckoo clocks, and when
# you walked by a garage sale and saw an ornate cuckoo clock with a missing pendulum,
# and a "Beyond-Ultimate Raspberry Pi Starter Kit"
# filled with all sorts of sensors and motors and other components,
# it's like you were suddenly hit by a beam of light and knew that it was your mission to
# combine the two to create a computerized Fizz Buzz cuckoo clock!
# You took them home and set up shop on the kitchen table, getting
# more and more excited as you got everything working together just perfectly.
# Soon the only task remaining was to write a function to select from the
# sounds you had recorded depending on what time it was:
# Your plan
# When a minute is evenly divisible by three, the clock will say the word "Fizz".
# When a minute is evenly divisible by five, the clock will say the word "Buzz".
# When a minute is evenly divisible by both, the clock will say "Fizz Buzz", with two exceptions:
# On the hour, instead of "Fizz Buzz", the clock door will open, and the cuckoo bird will
# come out and "Cuckoo" between one and twelve times depending on the hour.
# On the half hour, instead of "Fizz Buzz", the clock door will open, and the cuckoo will
# come out and "Cuckoo" just once.
# With minutes that are not evenly divisible by either three or five, at first you had
# intended to have the clock just say the numbers ala Fizz Buzz, but then you decided
# at least for version 1.0 to just have the clock make a quiet, subtle "tick" sound for
# a little more clock nature and a little less noise.
# Your input will be a string containing hour and minute values in 24-hour time,
# separated by a colon, and with leading zeros. For example, 1:34 pm would be "13:34".

# Your return value will be a string containing the combination of Fizz, Buzz, Cuckoo,
# and/or tick sounds that the clock needs to make at that time, separated by spaces.
# Note that although the input is in 24-hour time, cuckoo clocks' cuckoos are in 12-hour time.
def fizz_buzz_cuckoo_clock(time):
    hh, mm = map(int, time.split(":"))
    if mm ==  0:return " ".join(["Cuckoo"] * (hh % 12 or 12))
    elif mm == 30:return "Cuckoo"
    elif mm % 15 == 0:return "Fizz Buzz"
    elif mm %  3 == 0:return "Fizz"
    elif mm %  5 == 0:return "Buzz"
    else:return "tick"

# Can Santa save Christmas?
# Oh no! Santa's little elves are sick this year. He has to distribute the presents on his own.
# But he has only 24 hours left. Can he do it?
# Your Task:
# You will get an array as input with time durations as string
# in the following format: HH:MM:SS. Each duration represents the
# time taken by Santa to deliver a present. Determine whether he can do it
# in 24 hours or not. In case the time required to deliver all of the presents is exactly 24 hours,
# Santa can complete the delivery ;-).
def determineTime(arr):
    total_sec = sum(h * 3600 + m * 60 + s for h, m, s in [list(map(int, elem.split(':'))) for elem in arr])
    return total_sec <= 86400

# Write a function that will check whether ANY permutation of the characters of the input string
# is a palindrome. Bonus points for a solution that is efficient and/or
# that uses only built-in language functions. Deem yourself brilliant if
# you can come up with a version that does not use any function whatsoever.
# Example
# madam -> True
# adamm -> True
# junk -> False
# Hint
# The brute force approach would be to generate all the permutations of the
# string and check each one of them whether it is a palindrome. However,
# an optimized approach will not require this at all.
permute_a_palindrome=lambda s:bool(len(list(filter(lambda x:x%2!=0,[s.count(char) for char in set(s)])))<2)

# Linked Lists - Get Nth
# Implement a GetNth() function that takes a linked list and an integer
# index and returns the node stored at the Nth index position. GetNth()
# uses the C numbering convention that the first node is index 0, the second is index 1, ... and so on.
# So for the list 42 -> 13 -> 666, GetNth(1) should return Node(13);
# getNth(1 -> 2 -> 3 -> null, 0).data === 1
# getNth(1 -> 2 -> 3 -> null, 1).data === 2
# The index should be in the range [0..length-1]. If it is not,
# or if the list is empty, GetNth() should throw/raise
# an exception (ArgumentException in C#, InvalidArgumentException in PHP, Exception in Java).
class Node(object):
    def __init__(self, data):
        self.data = data
        self.next = None
def get_nth(node, index):
    if node and index >= 0: return node if index < 1 else get_nth(node.next, index - 1)
    raise ValueError

# Implement String#ipv4_address?, which should return true if given object is an IPv4 address
# - four numbers (0-255) separated by dots.
# It should only accept addresses in canonical representation, so no leading 0s, spaces etc.
import re
def ipv4_address(address):
    regex = re.compile(r'''
    #      200-249   | 250-255 | 100-109| 0-99 110-199
    \b([2]([0-4][0-9]|[5][0-5])|(10[0-9]|[1]?[1-9]?[0-9]))\.
    ([2]([0-4][0-9]|[5][0-5])|(10[0-9]|[1]?[1-9]?[0-9]))\.
    ([2]([0-4][0-9]|[5][0-5])|(10[0-9]|[1]?[1-9]?[0-9]))\.
    ([2]([0-4][0-9]|[5][0-5])|(10[0-9]|[1]?[1-9]?[0-9]))\b    
    ''', re.VERBOSE)
    mo = regex.match(address)
    if mo is None:
        return False
    elif  mo.group() == address:
        return (bool(mo))
    else:
        return False

# Peter lives on a hill, and he always moans about the way to his home. "It's always just
# up. I never get a rest". But you're pretty sure that at least at one point Peter's
# altitude doesn't rise, but fall. To get him, you use a nefarious plan:
# you attach an altimeter to his backpack and you read the data from his way back at the next day.
# Task
# You're given a list of compareable elements:
def is_monotone(heights):
    return heights == sorted(heights) if heights else True

# Write a function that takes in a binary string and returns the equivalent
# decoded text (the text is ASCII encoded).
# Each 8 bits on the binary string represent 1 character on the ASCII table.
# The input string will always be a valid binary string.
# Characters can be in the range from "00000000" to "11111111" (inclusive)
# Note: In the case of an empty binary string your function should return an empty string.
import binascii
def binary_to_string(binary):
    try:
        input_string=int(binary, 2)
        Total_bytes= (input_string.bit_length() +7) // 8
        input_array = input_string.to_bytes(Total_bytes, "big")
        ASCII_value=input_array.decode()
        return ASCII_value
    except:
        return '' if binary == '' else None

# Each exclamation mark's weight is 2; each question mark's weight is 3. Putting two
# strings left and right on the balance - are they balanced?
# If the left side is more heavy, return "Left"; if the right side
# is more heavy, return "Right"; if they are balanced, return "Balance".
def balance(left, right):
    count_l = 0
    count_r = 0
    d = {'!':2, '?':3}
    for i in left:
        count_l += d[i]
    for i in right:
        count_r += d[i]
    return 'Balance' if count_l == count_r else 'Left' if count_l > count_r else 'Right'

# iven a string that includes alphanumeric characters ("3a4B2d") return
# the expansion of that string: The numeric values represent the occurrence of each letter preceding that numeric
# value. There should be no numeric characters in the final string.
# Notes
# The first occurrence of a numeric value should be the number of
# times each character behind it is repeated, until the next numeric value appears
# If there are multiple consecutive numeric characters, only the last one should be used (ignore the
# previous ones)
# Empty strings should return an empty string.
# Your code should be able to work for both lower and capital case letters.
import re
def string_expansion(s):
    result = str()
    regex = re.compile(r'(\d)?([a-zA-Z]+)+')
    mo = regex.findall(s)
    print(mo)
    for item in mo:
        if len(item[1]) > 1:
            lst = list(item[1])
            for letter in lst:
                if item[0] == '':
                    number = 1
                else:
                    number = item[0]
                letters = letter*int(number)
                result += ''.join(letters)
        else:
            if item[0] == '':
                number = 1
            else:
                number = item[0]
            letters = item[1]*int(number)
            result += ''.join(letters)
    return result

# You have to write a calculator that receives strings for input.
# The dots will represent the number in the equation. There will be
# dots on one side, an operator, and dots again after the operator.
# The dots and the operator will be separated by one space.
# Here are the following valid operators :
# + Addition
# - Subtraction
# * Multiplication
# // Integer Division
# Your Work (Task)
# You'll have to return a string that contains dots,
# as many the equation returns. If the result is 0, return the empty string.
# When it comes to subtraction, the first number will always be greater than or equal to the second number.
def calculator(txt):
    l = txt.split()
    if '+' in l:
        return l[0] + l[2]
    elif '-' in l:
        return l[0][:len(l[0])-len(l[2])]
    elif '*' in l:
        return l[0] * len(l[2])
    elif '//' in l:
        return l[0][:len(l[0])//len(l[2])]

# Write a function that flattens an Array of Array
# objects into a flat Array. Your function must only do one level of flattening.
def flatten(lst):
    return sum(([i] if not isinstance(i, list) else i for i in lst), [])

# Given a square matrix (i.e. an array of subarrays), find the sum of values from the first value of
# the first array, the second value of the second array, the third value of the third array, and so on...
def diagonal_sum(array):
    return sum(array[i][i] for i in range(len(array)))

# Write a function that checks whether all elements in an array are square numbers. The function
# should be able to take any number of array elements.
# Your function should return true if all elements in the array are square numbers and false if not.
# An empty array should return undefined / None / nil /false (for C).
# You can assume that all array elements will be positive integers.
from math import isqrt
def is_square(a):
    if a:
        return all(isqrt(x)**2 == x for x in a)

# In cryptanalysis, words patterns can be a useful tool in cracking simple ciphers.
# A word pattern is a description of the patterns of letters occurring in a word,
# where each letter is given an integer code in order of appearance. So the
# first letter is given the code 0, and second is then assigned 1 if it is
# different to the first letter or 0 otherwise, and so on.
# As an example, the word "hello" would become "0.1.2.2.3". For this task case-sensitivity is ignored,
# so "hello", "helLo" and "heLlo" will all return the same word pattern.
# Your task is to return the word pattern for a given word. All words provided will
# be non-empty strings of alphabetic characters only, i.e. matching the regex "[a-zA-Z]+".
def word_pattern(word):
    output = ''
    conversion = []
    word = word.lower()
    for letter in word:
        if letter not in conversion:
            conversion.append(letter)
        output += str(conversion.index(letter)) +'.'
    return output[:-1]

# It's your birthday. Your colleagues buy you a cake. The numbers of
# candles on the cake is provided (candles). Please note this is not reality, and
# your age can be anywhere up to 1000. Yes, you would look a mess.
# As a surprise, your colleagues have arranged for your friend to hide inside the cake
# and burst out. They pretend this is for your benefit, but likely it is just because they want to see
# you fall over covered in cake. Sounds fun!
# When your friend jumps out of the cake, he/she will knock some of the candles to the floor. If the number of
# candles that fall is higher than 70% of total candles, the carpet will catch fire.
# You will work out the number of candles that will fall from the provided lowercase string (debris).
# You must add up the character ASCII code of each even indexed
# (assume a 0 based indexing) character in the string, with
# the alphabetical position ("a" = 1, "b" = 2, etc.) of each odd indexed character to get the string's total.
import string
def cake(candles, debris):
    fallen_candles = sum(
        string.ascii_letters.index(char) if index % 2 else ord(char)
        for index, char in enumerate(debris)
    )
    return "Fire!" if candles and fallen_candles > candles * 0.7 else "That was close!"

# Complete the method that takes a sequence of objects with two keys each: country or state, and
# capital. Keys may be symbols or strings.
# The method should return an array of sentences declaring the state or country and its capital.
def capital(capitals):
    return [f"The capital of {c.get('state') or c['country']} is {c['capital']}" for c in capitals]

# Write a function that doubles every second integer in a list, starting from the left.
def double_every_other(lst):
    return [i*2 if lst.index(i)%2!=0 else i for i in lst]

# Suppose you have 4 numbers: '0', '9', '6', '4' and 3 strings composed with them:
# s1 = "6900690040"
# s2 = "4690606946"
# s3 = "9990494604"
# Compare s1 and s2 to see how many positions they have in common: 0 at index 3, 6
# at index 4, 4 at index 8 ie 3 common positions out of ten.
# Compare s1 and s3 to see how many positions they have in common: 9 at index
# 1, 0 at index 3, 9 at index 5 ie 3 common positions out of ten.
# Compare s2 and s3. We find 2 common positions out of ten.
# So for the 3 strings we have 8 common positions out of 30 ie 0.2666... or 26.666...%
# Given n substrings (n >= 2) in a string s our function pos_average will calculate the average
# percentage of positions that are the same between the (n * (n-1)) / 2 sets of substrings
# taken amongst the given n substrings. It can happen that some substrings are duplicate but since their
# ranks are not the same in s they are considered as different substrings.
# The function returns the percentage formatted as a float with 10 decimals but the result is
# tested at 1e.-9 (see function assertFuzzy in the tests).
import numpy as np
def pos_average(s):
    s = s.replace(',','')
    s = s.split(' ')
    total = (len(s)*(len(s)-1))/2
    sequence_array = []
    for sequence in s:
        sequence_array.append(list(sequence))
    arr = np.array(sequence_array)
    counter = 0
    for i in range(0, arr.shape[1]):
        print(arr[:,i])
        unique, counts = np.unique(arr[:,i], return_counts=True)
        print('unique', unique)
        for k in range(0, len(counts)):
            print(counts[k])
            if counts[k] > 1:
                counter += np.sum(np.arange(1, counts[k]))
    return counter/(total*len(s[0]))*100

# Your Story
# "A piano in the home meant something." - Fried Green Tomatoes at the Whistle Stop Cafe
# You've just realized a childhood dream by getting a beautiful and beautiful-sounding upright piano from
# a friend who was leaving the country. You immediately started doing things
# like playing "Heart and Soul" over and over again, using one finger to pick out any
# melody that came into your head, requesting some sheet music books from the library,
# signing up for some MOOCs like Developing Your Musicianship, and wondering if you will
# think of any good ideas for writing piano-related katas and apps.
# Now you're doing an exercise where you play the very first (leftmost, lowest in pitch)
# key on the 88-key keyboard, which (as shown below) is white, with the little finger
# on your left hand, then the second key, which is black, with the ring finger on your
# left hand, then the third key, which is white, with the middle finger on your left hand,
# then the fourth key, also white, with your left index finger, and then the fifth key,
# which is black, with your left thumb. Then you play the sixth key, which is white,
# with your right thumb, and continue on playing the seventh, eighth, ninth, and tenth
# keys with the other four fingers of your right hand. Then for the eleventh key you go
# back to your left little finger, and so on. Once you get to the rightmost/highest, 88th,
# key, you start all over again with your left little finger on the first key. Your thought
# is that this will help you to learn to move smoothly and with uniform pressure on the keys
# from each finger to the next and back and forth between hands.
# You're not saying the names of the notes while you're doing this, but instead just
# counting each key press out loud (not starting again at 1 after 88, but continuing on
# to 89 and so forth) to try to keep a steady rhythm going and to see how far you can get before messing up.
# You move gracefully and with flourishes, and between screwups you hear, see, and feel that you are
# part of some great repeating progression between low and high notes and black and white keys.
# Your Function
# The function you are going to write is not actually going to help you with your piano playing,
# but just explore one of the patterns you're experiencing: Given the number you stopped on, was
# it on a black key or a white key? For example, in the description of your piano exercise above,
# if you stopped at 5, your left thumb would be on the fifth key of the piano, which is black. Or
# if you stopped at 92, you would have gone all the way from keys 1 to 88 and then wrapped around,
# so that you would be on the fourth key, which is white.
# Your function will receive an integer between 1 and 10000 (maybe you think that in principle
# it would be cool to count up to, say, a billion, but considering how many years it would take
# it is just not possible) and return the string "black" or "white" -- here are a few more examples:
def black_or_white_key(key_press_count):
    count = (key_press_count - 1) % 88 % 12
    l = [0, 2, 3, 5, 7, 8, 10]
    return 'white' if count in l else 'black'

# Find the longest substring in alphabetical order.
# Example: the longest alphabetical substring in "asdfaaaabbbbcttavvfffffdf" is "aaaabbbbctt".
# There are tests with strings up to 10 000 characters long so your code will need to be efficient.
# The input will only consist of lowercase characters and will be at least one letter long.
# If there are multiple solutions, return the one that appears first.
import re
def longest(s):
    matches = re.findall('a*b*c*d*e*f*g*h*i*j*k*l*m*n*o*p*q*r*s*t*u*v*w*x*y*z*', s)
    current_longest = matches[0]
    for match in matches:
        if len(match) > len(current_longest):
            current_longest = match
    return current_longest

# You are given a string of n lines, each substring being n characters long: For example:
# s = "abcd\nefgh\nijkl\nmnop"
# We will study some transformations of this square of strings.
# Symmetry with respect to the main diagonal: diag_1_sym (or diag1Sym or diag-1-sym)
# diag_1_sym(s) => "aeim\nbfjn\ncgko\ndhlp"
# Clockwise rotation 90 degrees: rot_90_clock (or rot90Clock or rot-90-clock)
# rot_90_clock(s) => "miea\nnjfb\nokgc\nplhd"
# selfie_and_diag1(s) (or selfieAndDiag1 or selfie-and-diag1) It is initial
# string + string obtained by symmetry with respect to the main diagonal.
# s = "abcd\nefgh\nijkl\nmnop" -->
# "abcd|aeim\nefgh|bfjn\nijkl|cgko\nmnop|dhlp"
# or printed for the last:
import copy
def diag_1_sym(s):
    w=[[x for x in ele]for ele in s.split('\n')]
    L,n=copy.deepcopy(w),len(w)
    for i in range(n):
        for j in range(n):
            L[i][j]=w[j][i]
    return '\n'.join([''.join(x) for x in L])
def rot_90_clock(strng):
    op=diag_1_sym(strng)
    return '\n'.join([x[::-1] for x in op.split('\n')])
def selfie_and_diag1(strng):
    op1,op2=strng.split('\n'),diag_1_sym(strng).split('\n')
    return '\n'.join([x+'|'+y for x,y in zip(op1,op2)])
def oper(fct, s):
    return fct(s)

# Input : an array of integers.
# Output : this array, but sorted in such a way that there are two wings:
# the left wing with numbers decreasing,
# the right wing with numbers increasing.
# the two wings have the same length. If the length of the array is odd the wings are around the
# bottom, if the length is even the bottom is considered to be part of the right wing.
# each integer l of the left wing must be greater or equal to its counterpart r in the right wing, the
# difference l - r being as small as possible. In other words the
# right wing must be nearly as steep as the left wing.
# The function is make_valley or makeValley or make-valley.
def make_valley(l):
    l = sorted(l, reverse = True)
    return l[::2] + l[1::2][::-1]

# The town sheriff dislikes odd numbers and wants all odd numbered families out of town! In town
# crowds can form and individuals are often mixed with other people and families. However you
# can distinguish the family they belong to by the number on the shirts they wear.
# As the sheriff's assistant it's your job to find all the odd numbered families and remove them from the town!
# Challenge: You are given a list of numbers. The numbers each repeat a certain number of times.
# Remove all numbers that repeat an odd number of times while keeping everything else the same.
# odd_ones_out([1, 2, 3, 1, 3, 3]) = [1, 1]
# In the above example:
# the number 1 appears twice
# the number 2 appears once
# the number 3 appears three times
# 2 and 3 both appear an odd number of times, so they are removed from the list. The final result is: [1,1]
# Here are more examples:
def odd_ones_out(numbers):
    return [i for i in numbers if numbers.count(i)%2==0]

# Write function which takes a string and make an acronym of it.
# Rule of making acronym in this kata:
# split string to words by space char
# take every first letter from word in given string
# uppercase it
# join them toghether
def to_acronym(inp):
    return ''.join(i[0].upper() for i in inp.split())

# This Kata is intended as a small challenge for my students
# All Star Code Challenge #16
# Create a function called noRepeat() that takes a string argument and
# returns a single letter string of the first not repeated character in the entire string.
def no_repeat(string):
    return [i for i in string if string.count(i) == 1][0]

# Create a function that takes a number and returns an array of strings containing the number cut off at each digit.
# Examples
# 420 should return ["4", "42", "420"]
# 2017 should return ["2", "20", "201", "2017"]
# 2010 should return ["2", "20", "201", "2010"]
# 4020 should return ["4", "40", "402", "4020"]
# 80200 should return ["8", "80", "802", "8020", "80200"]
# PS: The input is guaranteed to be an integer in the range [0, 1000000]
def create_array_of_tiers(n):
    return [str(n)[:i] for i in range(1,len(str(n))+1)]

# Impliment the reverse function, which takes in input n and reverses it.
# For instance, reverse(123) should return 321. You should do this
# without converting the inputted number into a string.
def reverse(n, count=0):
	return reverse(n // 10, count * 10 + n % 10) if n else count

# Write a function that receives two strings as parameter. This strings are in the following
# format of date: YYYY/MM/DD. Your job is: Take the years and calculate the difference between them.
def how_many_years (date1,date2):
    return abs(int(date1.split('/')[0]) - int(date2.split('/')[0]))

# Your task is to find all the elements of an array that are non consecutive.
# A number is non consecutive if it is not exactly one larger
# than the previous element in the array. The first element gets a pass and is never considered non consecutive.
# Create a function name all_non_consecutive
# E.g., if we have an array [1,2,3,4,6,7,8,15,16] then 6 and 15 are non-consecutive.
# You should return the results as an array of objects with two values i:
# <the index of the non-consecutive number> and n: <the non-consecutive number>.
def all_non_consecutive(a):
    return [{"i": i, "n": y} for i, (x, y) in enumerate(zip(a, a[1:]), 1) if x != y - 1]

# Too long, didn't read
# You get a list of integers, and you have to write a function mirror that returns the
# "mirror" (or symmetric) version of this list: i.e. the middle element is the
# greatest, then the next greatest on both sides, then the next greatest, and so on...
# More info
# The list will always consist of integers in range -1000..1000 and will vary in size between 0
# and 10000. Your function should not mutate the input array, and this will be tested
# (where applicable). Notice that the returned list will always be of odd size, since there
# will always be a definitive middle element.
def mirror(data: list) -> list:
    return sorted(data) + sorted(data, reverse=True)[1:]

# This Kata is intended as a small challenge for my students
# All Star Code Challenge #1
# Write a function, called sumPPG, that takes two NBA player objects/struct/Hash/Dict/Class and sums their PPG
def sum_ppg(player_one, player_two):
    return player_one['ppg'] + player_two['ppg']

# This kata requires you to convert minutes (int) to hours and minutes in the format hh:mm (string).
# If the input is 0 or negative value, then you should return "00:00"
# Hint: use the modulo operation to solve this challenge. The modulo operation simply returns the remainder
# after a division. For example the remainder of 5 / 2 is 1, so 5 modulo 2 is 1.
# Example
# If the input is 78, then you should return "01:18", because 78 minutes converts to 1 hour and 18 minutes.
def time_convert(num):
    return '%02d:%02d' % (num // 60, num % 60) if num > 0 else '00:00'

# You have a group chat application, but who is online!?
# You want to show your users which of their friends are online and available to chat!
# Given an input of an array of objects containing usernames, status and time since last activity (in mins),
# create a function to work out who is online, offline and away.
# If someone is online but their lastActivity was more than 10 minutes ago they are to be considered away.
from collections import defaultdict
def who_is_online(friends):
    d = defaultdict(list)
    for user in friends:
        status = 'away' if user['status'] == 'online' and user['last_activity'] > 10 else user['status']
        d[status].append(user['username'])
    return d


Linked
lists
are
data
structures
composed
of
nested or chained
objects, each
containing
a
single
value and a
reference
to
the
next
object.

Here
's an example of a list:


class LinkedList:
    def __init__(self, value=0, next=None):
        self.value = value
        self.next = next


# LinkedList(1, LinkedList(2, LinkedList(3)))
# Write a function listToArray( or list_to_array in Python) that
# converts a list to an array, like this:
# [1, 2, 3]
# Assume all inputs are valid lists
# with at least one value.For the purpose of simplicity, all values will be either numbers, strings, or Booleans.
def list_to_array(lst):
    return ([lst.value] + list_to_array(lst.next)) if lst else []

# Oh no! Ghosts have reportedly swarmed the city. It's your job to get rid of them and save the day!
# In this kata, strings represent buildings while whitespaces within those strings represent ghosts.
# So what are you waiting for? Return the building(string) without any ghosts(whitespaces)!
def ghostbusters(building):
    return building.replace(' ', '') if ' ' in building else "You just wanted my autograph didn't you?"

# Write a function last that accepts a list and returns the last element in the list.
# If the list is empty:
# In languages that have a built-in option or result type (like OCaml or Haskell), return an empty option
# In languages that do not have an empty option, just return None
def last(lst):
    return lst[-1] if lst else None

# Paul is an excellent coder and sits high on the CW leaderboard. He solves kata like a banshee but would
# also like to lead a normal life, with other activities. But he just can't stop solving all the kata!!
# Given an array (x) you need to calculate the Paul Misery Score. The values are worth the following points:
def paul(x):
    d = {'kata':5, 'Petes kata':10, 'life':0, 'eating':1}
    count = sum(d[i] for i in x)
    return 'Super happy!' if count < 40 else 'Happy!' if 40 <= count < 70 else 'Sad!' if 70 <= count < 100 else 'Miserable!'

# It's important day today: the class has just had a math test. You will be given a list of marks.
# Complete the function that will:
# Calculate the average mark of the whole class and round it to 3 decimal places.
# Make a dictionary/hash with keys "h", "a", "l" to make clear how many high, average and
# low marks they got. High marks are 9 & 10, average marks are 7 & 8, and low marks are 1 to 6.
# Return list [class_average, dictionary] if there are different type of marks, or [class_average,
# dictionary, "They did well"] if there are only high marks.
def test(r):
    avr = round(sum(r)/len(r), 3)
    h, a, l = 0, 0, 0
    for mark in r:
        if 9 <= mark <= 10:
            h += 1
        elif 7 <= mark <= 8:
            a += 1
        elif 1 <= mark <= 6:
            l += 1
    l = [avr, {'h': h, 'a': a, 'l': l}, f"{'They did well' if a + l == 0 else ''}"]
    return l[:-1] if l[-1] == '' else l

# Happy Holidays fellow Code Warriors!
# It's almost Christmas! That means Santa's making his list, and checking it twice. Unfortunately,
# elves accidentally mixed the Naughty and Nice list together! Santa needs your help to save Christmas!
# Save Christmas!
# Santa needs you to write two functions. Both of the functions accept a sequence of objects.
# The first one returns a sequence containing only the names of the nice people,
# and the other returns a sequence containing only the names of the naughty people.
# Return an empty sequence [] if the result from either of the functions contains no names.
# The objects in the passed will represent people. Each object contains two properties: name and wasNice.
# name - The name of the person
# wasNice - True if the person was nice this year, false if they were naughty
def get_nice_names(people):
    l = []
    for d in people:
        if d['was_nice']:
            l.append(d['name'])
    return l if l else []

def get_naughty_names(people):
    l = []
    for d in people:
        if not d['was_nice']:
            l.append(d['name'])
    return l if l else []

# This Kata is intended as a small challenge for my students
# Your family runs a shop and have just brought a Scrolling
# Text Machine (http://3.imimg.com/data3/RP/IP/MY-2369478/l-e-d-multicolour-text-board-250x250.jpg) to help
# get some more business.
# The scroller works by replacing the current text string with a similar text string,
# but with the first letter shifted to the end; this simulates movement.
# You're father is far too busy with the business to worry about such details, so, naturally, he's
# making you come up with the text strings.
# Create a function named rotate() that accepts a string argument and returns an array of
# strings with each letter from the input string being rotated to the end.
def rotate(str_):
    l = [i for i in str_]
    result = []
    for i in range(len(l)):
        temp = l[0]
        l.append(temp)
        l.pop(0)
        result.append(''.join(l))
    return result

# In this Kata, you will be given two positive integers a and b and your task will be to apply
# the following operations:
# i) If a = 0 or b = 0, return [a,b]. Otherwise, go to step (ii);
# ii) If a ≥ 2*b, set a = a - 2*b, and repeat step (i). Otherwise, go to step (iii);
# iii) If b ≥ 2*a, set b = b - 2*a, and repeat step (i). Otherwise, return [a,b].
# a and b will both be lower than 10E8.
# More examples in tests cases. Good luck!
def solve(a,b):
    if a == 0 or b == 0:
        return [a,b]
    elif a >= 2*b:
        a = a-2*b
        return solve(a,b)
    elif b >= 2*a:
        b = b-2*a
        return solve(a,b)
    else:
        return [a,b]

# In your class, you have started lessons about geometric progression.
# Since you are also a programmer, you have decided to write a function that
# will print first n elements of the sequence with the given constant r and first element a.
# Result should be separated by comma and space.
def geometric_sequence_elements(a, r, n):
    return ", ".join(str(a * r ** i) for i in range(n))

# You are working at a lower league football stadium and you've been tasked with automating the scoreboard.
# The referee will shout out the score, you have already set up the voice recognition module
# which turns the ref's voice into a string, but the spoken score needs to be converted into
# a pair for the scoreboard!
# e.g. "The score is four nil" should return [4,0]
# Either teams score has a range of 0-9, and the ref won't say the same string every time e.g.
def scoreboard(string):
    d = {'one':1, 'two':2, 'three':3, 'four':4, 'five':5, 'six':6, 'seven':7, 'eight':8, 'nine': 9 , 'nil':0}
    score = []
    for elem in string.split():
        if elem in d:
            score.append(d[elem])
    return score

# In this Kata the aim is to compare each pair of integers from 2 arrays, and return a new array of large numbers.
# Note: Both arrays have the same dimensions.
def get_larger_numbers(a, b):
    return [max(a[i], b[i]) for i,j in enumerate(a)]

# Create a function that takes a string as a parameter and does the following, in this order:
# Replaces every letter with the letter following it in the alphabet (see note below)
# Makes any vowels capital
# Makes any consonants lower case
# Note:
# the alphabet should wrap around, so Z becomes A
# in this kata, y isn't considered as a vowel.
def changer(s):
    l = 'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz'
    word = ''
    s = s.lower()
    for i in s:
        if i in l:
            if l[l.index(i)+1] in 'aeoiu':
                word += l[l.index(i)+1].upper()
                continue
            else:
                word += l[l.index(i)+1]
                continue
        else:
            word += i
    return word

# Remember the triangle of balls in billiards? To build a classic triangle (5 levels) you need 15 balls.
# With 3 balls you can build a 2-level triangle, etc.
# For more examples, Write a function that takes number of balls (≥ 1) and
# calculates how many levels you can build a triangle.
def pyramid(balls):
    s = 0
    i=1
    while balls >= i:
        balls -= i
        i += 1
        s+=1
    return s

# Find the last element of the given argument(s).
def last(*args):
    try:
        return [args][-1][-1][-1]
    except:
        return args[-1]

# In your class, you have started lessons about "arithmetic progression". Because you are also a programmer,
# you have decided to write a function.
# This function, arithmetic_sequence_sum(a, r, n), should return the sum of the
# first (n) elements of a sequence in which each element is the sum of the given integer
# (a), and a number of occurences of the given integer (r), based on the element's position within the sequence.
# For example:
# arithmetic_sequence_sum(2, 3, 5) should return 40:
def arithmetic_sequence_sum(a, r, n):
    return sum(a + r * i for i in range(n))

# Implement a function that receives a string, and lets you extend it with repeated calls. When no argument
# is passed you should return a string consisting of space-separated words you've received earlier.
# Note: there will always be at least 1 string; all inputs will be non-empty.
class create_message(str):
    def  __call__(self, s=""):
        return create_message((self+" "+s).rstrip())

# Being a bald man myself, I know the feeling of needing to keep it clean shaven. Nothing worse
# that a stray hair waving in the wind.
# You will be given a string(x). Clean shaved head is shown as "-"
# and stray hairs are shown as "/". Your task is to check the head for stray hairs and get rid of them.
# You should return the original string, but with any stray hairs removed. Keep count
# ot them though, as there is a second element you need to return:
# 0 hairs --> "Clean!"
# 1 hair --> "Unicorn!"
# 2 hairs --> "Homer!"
# 3-5 hairs --> "Careless!"
# >5 hairs --> "Hobo!"
# So for this head: "------/------" you shoud return:
# ["-------------", "Unicorn"]
def bald(s):
    c = 'Clean!' if s.count('/') == 0 else 'Unicorn!' if s.count('/') == 1 else 'Homer!' if s.count('/') == 2 else 'Careless!' if 3 <= s.count('/') <= 5 else 'Hobo!'
    return [s.replace('/', '-'), c]

# Complete the function that takes a list of numbers (nums), as the only argument to the function.
# Take each number in the list and square it if it is even, or square root the
# number if it is odd. Take this new list and return the sum of it, rounded to two decimal places.
# The list will never be empty and will only contain values that are greater than or equal to zero.
# Good luck!
def sum_square_even_root_odd(nums):
    return round(sum(i**2 if i%2==0 else i **.5 for i in nums), 2)

# In this Kata, you will be given an array of arrays and your task will be to return the
# number of unique arrays that can be formed by picking exactly one element from each subarray.
# For example: solve([[1,2],[4],[5,6]]) = 4, because it results in only 4 possibilites.
# They are [1,4,5],[1,4,6],[2,4,5],[2,4,6].
# Make sure that you don't count duplicates; for example solve([[1,2],[4,4],[5,6,6]]) = 4,
# since the extra outcomes are just duplicates.
# See test cases for more examples.
# Good luck!
# If you like this Kata, please try:
def solve(lists):
    res = 1
    for list in lists:
        res *= len(set(list))
    return res

# Write the following function:
# def area_of_polygon_inside_circle(circle_radius, number_of_sides):
# It should calculate the area of a regular polygon of numberOfSides, number-of-sides,
# or number_of_sides sides inside a circle of radius circleRadius, circle-radius,
# or circle_radius which passes through all the vertices of the polygon
# (such circle is called circumscribed circle or circumcircle). The answer should be a number rounded to
# 3 decimal places.
import math
def area_of_polygon_inside_circle(r, n):
    return float("{:.3f}".format((math.sin(2 * math.pi / n) * r * r * n) / 2))

# There are some stones on Bob's table in a row, and each of
# them can be red, green or blue, indicated by the characters R, G, and B.
# Help Bob find the minimum number of stones he needs to remove from the table
# so that the stones in each pair of adjacent stones have different colours.
import re
def solution(stones):
    res = 0
    for i in 'RGB':
        matches = re.findall(rf'{i}+', stones)
        for match in matches:
            res += len(match)-1
    return res

# For this Kata you will be given an array of numbers and another number n.
# You have to find the sum of the n largest numbers of the array
# and the product of the n smallest numbers of the array, and compare the two.
# If the sum of the n largest numbers is higher, return "sum"
# If the product of the n smallest numbers is higher, return "product"
# If the 2 values are equal, return "same"
# Note The array will never be empty and n will always be smaller than the length of the array.
import functools
def sum_or_product(array, n):
    big = sum(sorted(array)[-n:])
    small = functools.reduce(lambda a, b : a * b, sorted(array)[:n])
    return 'sum' if big > small else 'product' if small > big else 'same'

# A startup office has an ongoing problem with its bin.
# Due to low budgets, they don't hire cleaners. As a result, the staff are left to voluntarily empty the bin.
# It has emerged that a voluntary system is not working and the bin is often overflowing.
# One staff member has suggested creating a rota system based upon the staff seating plan.
# Create a function binRota that accepts a 2D array of names.
# The function will return a single array containing staff names in the order that they should empty the bin.
# Adding to the problem, the office has some temporary staff.
# This means that the seating plan changes every month. Both staff members'
# names and the number of rows of seats may change. Ensure that the function
# binRota works when tested with these changes.
# Notes:
# All the rows will always be the same length as each other.
# There will be no empty spaces in the seating plan.
# There will be no empty arrays.
# Each row will be at least one seat long.
def bin_rota(arr):
    l = []
    for i in range(len(arr)):
        if i % 2 == 0:
            l += arr[i]
            continue
        else:
            l += arr[i][::-1]
    return l

# You are given an array of non-negative integers, your task is to complete the series from 0 to
# the highest number in the array.
# If the numbers in the sequence provided are not in order you should order them,
# but if a value repeats, then you must return a sequence with only one item,
# and the value of that item must be 0. like this:
def complete_series(seq):
    return [i for i in range(max(seq)+1)] if len(set(seq)) == len(seq) else [0]

# I will give you an integer (N) and a string. Break the string up into as
# many substrings of N as you can without spaces. If there are leftover characters, include those as well.
def string_breakers(n, st):
    st = st.replace(' ', '')
    l = []
    s = len(st)//n if len(st) % n == 0 else len(st)// n + 1
    for i in range(s):
        l.append(st[:n])
        st = st[n:]
    return '\n'.join(l)

# In this Kata, you will be given a lower case string and your task will be to remove k characters
# from that string using the following rule:
# - first remove all letter 'a', followed by letter 'b', then 'c', etc...
# - remove the leftmost character first.
def solve(st,k):
    num, removed = 0, 0
    while removed < k and st:
        if chr(num+97) in st:
            indx = st.index(chr(num+97))
            st = st[0:indx] + st[indx+1:]
            removed += 1
        else:
            num += 1
    return st

#Make them bark
# You have been hired by a dogbreeder to write a program to keep record of his dogs.
# You've already made a constructor Dog, so no one has to hardcode every puppy.
# The work seems to be done. It's high time to collect the payment.
# ..hold on! The dogbreeder says he wont pay you, until he can make every dog object .bark().
# Even the ones already done with your constructor. "Every dog barks" he says.
# He also refuses to rewrite them, lazy as he is.
# You can't even count how much objects that bastard client of yours already made.
# He has a lot of dogs, and none of them can .bark().
# Can you solve this problem, or will you let this client outsmart you for good?
# Practical info:
# The .bark() method of a dog should return the string 'Woof!'.
# The contructor you made (it is preloaded) looks like this:
def bark(self):
    return "Woof!"
Dog.bark = bark

# Write a function that accepts two arguments: an array/list of integers and another integer (n).
# Determine the number of times where two integers in the array have a difference of n.
def int_diff(lst, n):
    count = 0
    for i in range(len(lst)):
        for j in range(i+1, len(lst)):
            if abs(lst[i] - lst[j]) == n:
                count += 1
    return count

# Make a program that takes a value (x) and returns "Bang" if the number is divisible by 3,
# "Boom" if it is divisible by 5, "BangBoom" if it divisible by 3 and 5,
# and "Miss" if it isn't divisible by any of them. Note: Your program should only return one value
# Ex: Input: 105 --> Output: "BangBoom" Ex: Input: 9 --> Output: "Bang" Ex:Input: 25 --> Output: "Boom"
def multiple(x):
    return 'Bang' if x%3==0 and x%5!=0 else 'Boom' if x%3!=0 and x%5==0 else 'BangBoom' if x%3==0 and x%5==0 else 'Miss'

# Write a method that will search an array of strings for all strings that contain another string, ignoring
# capitalization. Then return an array of the found strings.
# The method takes two parameters, the query string and the array of strings to search, and returns an array.
# If the string isn't contained in any of the strings in the array,
# the method returns an array containing a single string: "Empty" (or Nothing in Haskell,
# or "None" in Python and C)
def word_search(query, seq):
    return [i for i in seq if query.lower() in i.lower()] or ["None"]

# JavaScript provides a built-in parseInt method.
# It can be used like this:
# parseInt("10") returns 10
# parseInt("10 apples") also returns 10
# We would like it to return "NaN" (as a string) for the second case
# because the input string is not a valid number.
# You are asked to write a myParseInt method with the following rules:
# It should make the conversion if the given string only contains a single integer value (and possibly
# spaces - including tabs, line feeds... - at both ends)
# For all other strings (including the ones representing float values), it should return NaN
# It should assume that all numbers are not signed and written in base 10
def my_parse_int(string):
    try:
        return int(string)
    except:
        return 'NaN'

# Your job is to create a class called Song.
# A new Song will take two parameters, title and artist.
# mount_moose = Song('Mount Moose', 'The Snazzy Moose')
# mount_moose.title => 'Mount Moose'
# mount_moose.artist => 'The Snazzy Moose'
# You will also have to create an instance method named howMany() (or how_many()).
# The method takes an array of people who have listened to the song that day.
# The output should be how many new listeners the song gained on that day out of all listeners.
# Names should be treated in a case-insensitive manner, i.e. "John" is the same as "john".
class Song:
    def __init__(self, title, artist):
        self.title = title
        self.artist = artist
        self.listeners = list(map(lambda listener: listener.lower(), artist))
    def how_many(self, listeners):
        listens = 0
        for listener in listeners:
            listener = listener.lower()
            if listener not in self.listeners:
                self.listeners.append(listener)
                listens += 1
        return listens

# Due to lack of maintenance the minute-hand has fallen off Town Hall clock face.
# And because the local council has lost most of our tax money to a Nigerian email scam there
# are no funds to fix the clock properly.
# Instead, they are asking for volunteer programmers to write some code that tell the time
# by only looking at the remaining hour-hand!
# What a bunch of cheapskates!
# Can you do it?
# Kata
# Given the angle (in degrees) of the hour-hand, return the time in 12 hour HH:MM format.
# Round down to the nearest minute.
import math
def what_time_is_it(angle):
    calc = math.floor(angle / 30)
    remain = angle % 30
    min = math.floor(remain * 2)
    if angle == 0: return "12:00"
    elif calc == 0 and min < 10: return f"12:0{min}"
    elif calc == 0 and min > 9: return f"12:{min}"
    elif remain == 0 and calc < 10: return f"0{calc}:00"
    elif remain == 0 and calc > 9: return f"{calc}:00"
    elif min < 10 and calc < 10: return f"0{calc}:0{min}"
    elif min < 10 and calc > 9: return f"{calc}:0{min}"
    elif min > 9 and calc < 10: return f"0{calc}:{min}"
    elif min > 9 and calc > 9: return f"{calc}:{min}"

# Create a moreZeros function which will receive a string for input, and return an array
# (or null terminated string in C) containing only the characters from that string whose binary
# representation of its ASCII value consists of more zeros than ones.
# You should remove any duplicate characters, keeping the first occurrence of any such duplicates, so they
# are in the same order in the final array as they first appeared in the input string.
def more_zeros(s):
    l = []
    for i in s:
        c = format(ord(i), 'b')
        if c.count('1') < c.count('0') and i not in l:
            l.append(i)
    return l

# Complete the function circleArea so that it will return the area of a circle with the given radius.
# Round the returned number to two decimal places (except for Haskell).
# If the radius is not positive or not a number, return false.
import math
def circle_area(r):
    return round(math.pi*r**2, 2) if type(r) == int and r > 0 else False

# Normally we have firstname, middle and the last name but there may be more than one word in a name
# like a South Indian one.
# Similar to those kinda names we need to initialize the names.
# See the pattern below:
def initials(name):
    return '.'.join(i.upper()[0] if i.lower() != name.split()[-1].lower() else i.capitalize() for i in name.split())

# What's in a name?
# ..Or rather, what's a name in? For us, a particular string is where we are looking for a name.
# Task
# Write a function, taking two strings in parameter, that tests whether or not the first string contains
# all of the letters of the second string, in order.
# The function should return true if that is the case, and else false. Letter comparison should be case-INsensitive.
def name_in_str(str, name):
    word = iter(str.lower())
    return all(i in word for i in name.lower())

# This is related to my other Kata about cats and dogs.
# Kata Task
# I have a cat and a dog which I got as kitten / puppy.
# I forget when that was, but I do know their current ages as catYears and dogYears.
# Find how long I have owned each of my pets and return as a list [ownedCat, ownedDog]
# NOTES:
# Results are truncated whole numbers of "human" years
# Cat Years
# 15 cat years for first year
# +9 cat years for second year
# +4 cat years for each year after that
# Dog Years
# 15 dog years for first year
# +9 dog years for second year
# +5 dog years for each year after that
def owned_cat_and_dog(cy, dy):
    cat = 0 if cy < 15 else 1 if cy < 24 else 2 + (cy - 24) // 4
    dog = 0 if dy < 15 else 1 if dy < 24 else 2 + (dy - 24) // 5
    return [cat, dog]

# We need a method in the List Class that may count specific digits from a given list of integers.
# This marked digits will be given in a second list. The method .count_spec_digits()/.countSpecDigits() will
# accept two arguments, a list of an uncertain amount of integers integers_lists/integersLists (and of an uncertain
# amount of digits, too) and a second list, digits_list/digitsList that has the specific digits to
# count which length cannot be be longer than 10 (It's obvious, we've got ten digits).
# The method will output a list of tuples, each tuple having two elements, the first
# one will be a digit to count, and second one, its corresponding total frequency in all
# the integers of the first list. This list of tuples should be ordered with the same order that the digits
# have in digitsList
class List(object):
    def count_spec_digits(self, integers_list, digits_list):
        s = "".join(str(i) for i in integers_list)
        return [(dig, s.count(str(dig))) for dig in digits_list]

# Given 2 string parameters, show a concatenation of:
# the reverse of the 2nd string with inverted case; e.g Fish -> HSIf
# a separator in between both strings: @@@
# the 1st string reversed with inverted case and then mirrored; e.g Water -> RETAwwATER
def reverse_and_mirror(s1, s2):
    return f"{s2[::-1].swapcase()}@@@{s1[::-1].swapcase()}{s1.swapcase()}"

# Write a function that will randomly upper and lower characters in a string - randomCase() (random_case()
# for Python).
# A few examples:
import random
def random_case(x):
    return "".join([random.choice([i.lower(), i.upper()]) for i in x])

# You have to write a function pattern which creates the following pattern upto n number of rows.
# If the Argument is 0 or a Negative Integer then it should return "" i.e. empty string.
def pattern(n):
    l = list(range(1, n + 1))
    return '\n'.join(''.join(map(str, l[i:])) for i in range(n))

# How many days are we represented in a foreign country?
# My colleagues make business trips to a foreign country. We must find the number of days our
# company is represented in a country. Every day that one or more colleagues are present in the
# country is a day that the company is represented. A single day cannot count for more than one day.
# Write a function that recieves a list of pairs and returns the number of days that
# the company is represented in the foreign country. The first number of the pair
# is the number of the day of arrival and the second number of the pair is the day
# of departure of someone who travels, i.e. 1 january is number 1 and 31 of december is 365.
def days_represented(trips):
    s = set()
    for i in trips:
        s.update(range(i[0], i[1] + 1))
    return len(s)

# There are five workers : James,John,Robert,Michael and William.They work one by
# one and on weekends they rest. Order is same as in the description(James
# works on mondays,John works on tuesdays and so on).You have to create a function
# 'task' that will take 3 arguments(w, n, c):
# Weekday
# Number of trees that must be sprayed on that day
# Cost of 1 litre liquid that is needed to spray tree,let's say one tree needs 1 litre liquid.
# Let cost of all liquid be x
# Your function should return string like this : 'It is (weekday) today, (name),
# you have to work, you must spray (number) trees and you need (x) dollars to buy liquid'
def task(w,n,c):
    workers = {"Monday" : "James", "Tuesday" : "John", "Wednesday" : "Robert", "Thursday" : "Michael", "Friday" : "William"}
    return f"It is {w} today, {workers[w]}, you have to work, you must spray {n} trees and you need {n * c} dollars to buy liquid"

# Write a function consonantCount, consonant_count or ConsonantCount that takes a string of English-language
# text and returns the number of consonants in the string.
# Consonants are all letters used to write English excluding the vowels a, e, i, o, u.
def consonant_count(s):
    return sum([1 if i not in 'aeiou' and i.isalpha() else 0 for i in s.replace(' ', '').lower()])

# Is it possible to write a book without the letter 'e' ?
# Task
# Given String str, return:
# How many "e" does it contain (case-insensitive) in string format.
# If given String doesn't contain any "e", return: "There is no "e"."
# If given String is empty, return empty String.
# If given String is `null`/`None`/`nil`, return `null`/`None`/`nil`
def find_e(s):
    try:
        c = str(s.lower().count('e'))
        return c if s != '' and int(c) > 0 else 'There is no "e".' if int(c) == 0 and s!='' else '' if s == '' else None
    except:
        return None

# Write a function that takes a string and returns an array containing binary
# numbers equivalent to the ASCII codes of the characters of the string. The binary strings should
# be eight digits long.
def word_to_bin(word):
    return [bin(ord(letter))[2:].zfill(8) for letter in word]

# In this Kata, you will be given an integer array and your task is
# to return the sum of elements occupying prime-numbered indices.
# The first element of the array is at index 0.
# Good luck!
# If you like this Kata, try:
# Dominant primes. It takes this idea a step further.
def is_prime(n):
    return n >= 2 and all(n%i for i in range(2, 1+int(n**.5)))
def total(arr):
    return sum(n for i, n in enumerate(arr) if is_prime(i))

# The snail crawls up the column. During the day it crawls up some distance. During the night
# she sleeps, so she slides down for some distance (less than crawls up during the day).
# Your function takes three arguments:
# The height of the column (meters)
# The distance that the snail crawls during the day (meters)
# The distance that the snail slides down during the night (meters)
# Calculate number of day when the snail will reach the top of the column.
def snail(column, day, night):
    count = 0
    while column > 0:
        count += 1
        if column - day <= 0:
            return count
        column -= day - night
    return count

# Complete the solution so that it returns the number of times the search_text is found within the full_text.
def solution(full_text, search_text):
    return full_text.count(search_text)

# A binary gap within a positive number num is any sequence of consecutive zeros that is
# surrounded by ones at both ends in the binary representation of num.
# For example:
# 9 has binary representation 1001 and contains a binary gap of length 2.
# 529 has binary representation 1000010001 and contains two binary gaps: one of length 4 and one of length 3.
# 20 has binary representation 10100 and contains one binary gap of length 1.
# 15 has binary representation 1111 and has 0 binary gaps.
# Write function gap(num) that,  given a positive num,  returns the length of its longest binary gap.
# The function should return 0 if num doesn't contain a binary gap.
def gap(num):
    binary = str(bin(num)).strip('0').split('b')[1]
    binary = binary.split('1')
    return max(list(map(lambda x: len(x), binary)))

# *** No Loops Allowed ***
# You will be given an array (a) and a limit value (limit).
# You must check that all values in the array are below or equal to the limit value.
# If they are, return true. Else, return false.
# You can assume all values in the array are numbers.
# Do not use loops. Do not modify input array.
# Looking for more, loop-restrained fun? Check out the other kata in the series:
def small_enough(a, limit):
    return max(a) <= limit

# Challenge:
# Given a two-dimensional array, return a new array which carries over only those arrays from the original,
# which were not empty and whose items are all of the same type (i.e. homogenous).
# For simplicity, the arrays inside the array will only contain characters and integers.
# Example:
# Given [[1, 5, 4], ['a', 3, 5], ['b'], [], ['1', 2, 3]], your function should return [[1, 5, 4], ['b']].
# Addendum:
# Please keep in mind that for this kata, we assume that empty arrays are not homogenous.
# The resultant arrays should be in the order they were originally in and should not have its values changed.
# No implicit type casting is allowed. A subarray [1, '2'] would be considered illegal and should be filtered out.
def filter_homogenous(arrays):
    return [i for i in arrays if (all(type(a) == int for a in i) or all(type(a) == str for a in i)) and i]

# Let's build a calculator that can calculate the average for an arbitrary number of arguments.
# The test expects you to provide a Calculator object with an average method:
# Calculator.average()
# The test also expects that when you pass no arguments, it returns 0. The arguments are expected to be integers.
# It expects Calculator.average(3,4,5) to return 4.
class Calculator:
    @staticmethod
    def average(*args):
        return sum(args) / len(args) if args else 0

# Harshad numbers (also called Niven numbers) are positive numbers that can be divided
# (without remainder) by the sum of their digits.
# For example, the following numbers are Harshad numbers:
# 10, because 1 + 0 = 1 and 10 is divisible by 1
# 27, because 2 + 7 = 9 and 27 is divisible by 9
# 588, because 5 + 8 + 8 = 21 and 588 is divisible by 21
# While these numbers are not:
# 19, because 1 + 9 = 10 and 19 is not divisible by 10
# 589, because 5 + 8 + 9 = 22 and 589 is not divisible by 22
# 1001, because 1 + 1 = 2 and 1001 is not divisible by 2
# Harshad numbers can be found in any number base, but we are going to focus on base 10 exclusively.
# Your task
# Your task is to complete the skeleton Harshad object ("static class") which has 3 functions:
# isValid() that checks if n is a Harshad number or not
# getNext() that returns the next Harshad number > n
# getSerie() that returns a series of n Harshad numbers, optional start value not included
# You do not need to care about the passed parameters in the test cases, they will always
# be valid integers (except for the start argument in getSerie() which is optional and should default to 0).
# Note: only the first 2000 Harshad numbers will be checked in the tests.
from itertools import count, islice
class Harshad:
    @staticmethod
    def is_valid(number):
        return number % sum(int(i) for i in str(number)) == 0
    @classmethod
    def get_next(self, number):
        return next(i for i in count(number+1) if self.is_valid(i))
    @classmethod
    def get_series(self, c, start = 0):
        return list(islice(filter(self.is_valid, (i for i in count(start+1))), c))

# Remember the spongebob meme that is meant to make fun of people by repeating what they say in a mocking way?
def sponge_meme( s ):
    bob = ''
    i = 0
    while i < len(s):
        if i % 2 != 0:
            bob += s[i].lower()
        else:
            bob += s[i].upper()
        i += 1
    return bob

# You are given a string of words (x), for each word within the string you need to turn the word
# 'inside out'. By this I mean the internal letters will move out, and the external letters move toward the centre.
# If the word is even length, all letters will move. If the length is odd, you are expected to leave the
# 'middle' letter of the word where it is.
# An example should clarify:
# 'taxi' would become 'atix' 'taxis' would become 'atxsi'
import re
def inside_out(s):
    return re.sub(r'\S+', lambda m: inside_out_word(m.group()), s)
def inside_out_word(s):
    i, j = len(s) // 2, (len(s) + 1) // 2
    return s[:i][::-1] + s[i:j] + s[j:][::-1]

# Alice and Bob have participated to a Rock Off with their bands. A jury of true
# metalheads rates the two challenges, awarding points to the bands on a scale from 1 to
# 50 for three categories: Song Heaviness, Originality, and Members' outfits.
# For each one of these 3 categories they are going to be awarded one point, should
# they get a better judgement from the jury. No point is awarded in case of an equal vote.
# You are going to receive two arrays, containing first the score of Alice's
# band and then those of Bob's. Your task is to find their total score by comparing them in a single line.
# Example:
# Alice's band plays a Nirvana inspired grunge and has been rated 20 for Heaviness, 32
# for Originality and only 18 for Outfits. Bob listens to Slayer and has gotten a good
# 48 for Heaviness, 25 for Originality and a rather honest 40 for Outfits.
# The total score should be followed by a colon : and by one of the following quotes:
# if Alice's band wins: Alice made "Kurt" proud! if Bob's band
# wins: Bob made "Jeff" proud! if they end up with a draw: that looks like a "draw"! Rock on!
# The solution to the example above should therefore appear like '1, 2: Bob made "Jeff" proud!'.
def solve(a, b):
    alice = sum(i > j for i, j in zip(a, b))
    bob = sum(j > i for i, j in zip(a, b))
    if alice == bob:
        words = 'that looks like a "draw"! Rock on!'
    elif alice > bob:
        words = 'Alice made "Kurt" proud!'
    else:
        words = 'Bob made "Jeff" proud!'
    return f"{alice}, {bob}: {words}"

# The borrowers are tiny tiny fictional people. As tiny tiny people they
# have to be sure they aren't spotted, or more importantly, stepped on.
# As a result, the borrowers talk very very quietly. They find that capitals and
# punctuation of any sort lead them to raise their voices and put them in danger.
# The young borrowers have begged their parents to stop using caps and punctuation.
# Change the input text s to new borrower speak. Help save the next generation!
def borrow(s):
    return s.replace(' ', '').replace('!', '').replace('?', '').replace('.', '').replace(',', '').replace(';', '').replace(':', '').lower()

# You are given array of integers, your task will be to count all pairs in that array and return their count.
# Notes:
# Array can be empty or contain only one value; in this case return 0
# If there are more pairs of a certain number, count each pair only once.
# E.g.: for [0, 0, 0, 0] the return value is 2 (= 2 pairs of 0s)
# Random tests: maximum array length is 1000, range of values in array is between 0 and 1000
def duplicates(arr):
    return sum(arr.count(i) // 2 for i in set(arr))

# Suppose we know the process by which a string s was encoded to a string r (see explanation below).
# The aim of the kata is to decode this string r to get back the original string s.
# Explanation of the encoding process:
# input: a string s composed of lowercase letters from "a" to "z", and a positive integer num
# we know there is a correspondence between abcde...uvwxyzand 0, 1, 2 ..., 23, 24, 25 : 0 <-> a, 1 <-> b ...
# if c is a character of s whose corresponding number is x, apply to x the function
# f: x-> f(x) = num * x % 26, then find ch the corresponding character of f(x)
# Accumulate all these ch in a string r
# concatenate num and r and return the result
# Task
# A string s was encoded to string r by the above process. complete the function
# to get back s whenever it is possible.
# Indeed it can happen that the decoding is impossible for strings composed
# of whatever letters from "a" to "z" when positive integer num has not been
# correctly chosen. In that case return "Impossible to decode".
from string import ascii_lowercase as aLow
def decode(r):
    i = next(i for i, c in enumerate(r) if c.isalpha())
    n, r = int(r[:i]), r[i:]
    maps = {chr(97 + n * k % 26): v for k, v in enumerate(aLow)}
    return "Impossible to decode" if len(maps) != 26 else ''.join(maps[c] for c in r)

# Write a function that takes an integer in input and outputs a string with currency format.
# Integer in currency format is expressed by a string of number where every three characters are separated by comma.
# For example:
def to_currency(price):
  return '{:,}'.format(price)

# Description:
# Given a string, you need to write a method that order every letter in this string in ascending order.
# Also, you should validate that the given string is not empty or null. If so, the method should return:
# "Invalid String!"
# Notes
# • the given string can be lowercase and uppercase.
# • the string could include spaces or other special characters like '# ! or ,'. Sort them based on their
# ASCII codes
def order_word(s):
    return ''.join(sorted(s, key=ord)) if s else 'Invalid String!'

# You are given a string of words and numbers. Extract the expression including:
# the operator: either addition ("gains") or subtraction ("loses")
# the two numbers that we are operating on
# Return the result of the calculation.
# Notes:
# "loses" and "gains" are the only two words describing operators
# No fruit debts nor bitten apples = The numbers are integers and no negatives
def calculate(string):
    d = {'gains': int(string.split()[2]) + int(string.split()[-1]), 'loses': int(string.split()[2]) - int(string.split()[-1])}
    return d['gains'] if 'gains' in string else d['loses']

# Implement a function which takes a sequence of objects and a property name, and returns a sequence containing
# the named property of each object.
# For example:
def pluck(objs, name):
    return [d[name] if name in d else None for d in objs]

# While developing a website, you detect that some of the members have troubles logging in.
# Searching through the code you find that all logins ending with a "_" make problems.
# So you want to write a function that takes an array of pairs of login-names and e-mails,
# and outputs an array of all login-name, e-mails-pairs from the login-names that end with "_".
def search_names(logins):
    return list(filter(lambda x: x[0].endswith('_'), logins))

# Python dictionaries are inherently unsorted. So what do you do if you need to sort the contents of a dictionary?
# Create a function that returns a sorted list of (key, value) tuples (Javascript: arrays of 2 items).
# The list must be sorted by the value and be sorted largest to smallest.
def sort_dict(d):
  return sorted(d.items(), key=lambda x: x[1], reverse=True)

# Given a random string consisting of numbers, letters, symbols, you need to sum up the numbers in the string.
# Note:
# Consecutive integers should be treated as a single number. eg, 2015 should be
# treated as a single number 2015, NOT four numbers
# All the numbers should be treaded as positive integer. eg, 11-14
# should be treated as two numbers 11 and 14. Same as 3.14, should be treated as two numbers 3 and 14
# If no number was given in the string, it should return 0
import re
def sum_from_string(string):
    return sum(int(i) for i in re.findall("\d+",string))

# Triangular number is any amount of points that can fill an equilateral triangle.
# Example: the number 6 is a triangular number because all sides of a triangle has the same amount of points.
def is_triangular(t):
    return (8 * t + 1)**.5 % 1 == 0

# Write function which will create a string from a list of strings, separated by space.
def words_to_sentence(words):
    return ' '.join(words)

# Convert a hash into an array. Nothing more, Nothing less.
# {name: 'Jeremy', age: 24, role: 'Software Engineer'}
# should be converted into
# [["name", "Jeremy"], ["age", 24], ["role", "Software Engineer"]]
# Note: The output array should be sorted alphabetically.
# Good Luck!
def convert_hash_to_array(hash):
    return sorted([[k, v] for k,v in hash.items()])

# A sequence is usually a set or an array of numbers that has a strict way
# for moving from the nth term to the (n+1)th term.
# If f(n) = f(n-1) + c where c is a constant value, then f is an arithmetic sequence.
# An example would be (where the first term is 0 and the constant is 1) is [0, 1, 2, 3, 4, 5, ... and so on] )
# Else if (pun) f(n) = f(n-1) * c where c is a constant value, then f is a geometric sequence.
# Example where the first term is 2 and the constant is 2 will be [2, 4, 8, 16, 32, 64, ... to infinity ... ]
# There are some sequences that aren't arithmetic nor are they geometric.
# Here is a link to feed your brain : Sequence !
# You're going to write a function that's going to return the value in the nth
# index of an arithmetic sequence.(That is, adding a constant to move to the next element in the "set").
# The function's name is nthterm/Nthterm, it takes three inputs first,n,c where:
# first is the first value in the 0 INDEX.
# n is the index of the value we want.
# c is the constant added between the terms.
# Remember that first is in the index 0 .. just saying ...
def nthterm(first, n, c):
    return first + n * c

# The way the ohms value needs to be formatted in the string you return depends on the magnitude of the value:
# For resistors less than 1000 ohms, return a string containing the number of ohms, a space,
# the word "ohms" followed by a comma and a space, the tolerance value (5, 10, or 20), and a percent sign.
# For example, for the "yellow violet black" resistor mentioned above, you would return "47 ohms, 20%".
# For resistors greater than or equal to 1000 ohms, but less than 1000000 ohms, you will use the same
# format as above, except that the ohms value will be divided by 1000 and have a lower-case "k" after it.
# For example, for a resistor with bands of "yellow violet red gold", you would return "4.7k ohms, 5%"
# For resistors of 1000000 ohms or greater, you will divide the ohms value by 1000000 and have
# an upper-case "M" after it. For example, for a resistor with bands of
# "brown black green silver", you would return "1M ohms, 10%"
# Test case resistor values will all be between 10 ohms and 990M ohms.
def decode_resistor_colors(bands):
    d = {'black':0, 'brown':1, 'red':2, 'orange':3, 'yellow':4, 'green':5, 'blue':6, 'violet':7, 'gray':8, 'white':9, 'silver':10, 'gold':5}
    bands = [d[b] for b in bands.split()]
    ohms = (bands[0] * 10 + bands[1]) * 10 ** bands[2]
    ohms, sfx = (ohms/1000000.0, 'M') if ohms > 999999 else (ohms / 1000.0, 'k') if ohms > 999 else (ohms, '')
    return "{}{} ohms, {}%".format(int(ohms) if ohms // 1 == ohms else ohms, sfx, bands[3] if len(bands) > 3 else 20)

# Given a string and an array of index numbers, return the characters of the string rearranged to be in
# the order specified by the accompanying array.
# Ex:
# scramble('abcd', [0,3,1,2]) -> 'acdb'
# The string that you will be returning back will have: 'a' at index 0, 'b' at index 3,
# 'c' at index 1, 'd' at index 2, because the order of those characters maps to their
# corresponding numbers in the index array.
# In other words, put the first character in the string at the index described by the first element of the array
# You can assume that you will be given a string and array of equal length and both containing valid characters
# (A-Z, a-z, or 0-9).
def scramble(string, array):
    return "".join(v for k, v in sorted(zip(array, string)))

# For every positive integer N, there exists a unique sequence starting with 1 and ending with
# N and such that every number in the sequence is either the double of the preceeding number or the double plus 1.
# For example, given N = 13, the sequence is [1, 3, 6, 13], because . . . :
#  3 =  2*1 +1
#  6 =  2*3
#  13 = 2*6 +1
# Write a function that returns this sequence given a number N.
# Try generating the elements of the resulting list in ascending order, i.e., without
# resorting to a list reversal or prependig the elements to a list.
def climb(n):
    return  [n >> n.bit_length() - i - 1 for i in range(n.bit_length())]

# Given an array of strings, reverse them and their order in such way that their length
# stays the same as the length of the original inputs.
def reverse(a):
    l = reversed(''.join(a))
    return [''.join(next(l) for k in i) for i in a]

# Write a function generatePairs (Javascript) / generate_pairs (Python / Ruby) that accepts an integer argument
# n and generates an array containing the pairs of integers [a, b] that satisfy the following conditions:
# 0 <= a <= b <= n
# The pairs should be sorted by increasing values of a then increasing values of b.
def generate_pairs(n):
    return [[i,j] for i in range(n+1) for j in range(i, n+1)]

# Your job is to create a simple password validation function, as seen on many websites.
# The rules for a valid password are as follows:
# There needs to be at least 1 uppercase letter.
# There needs to be at least 1 lowercase letter.
# There needs to be at least 1 number.
# The password needs to be at least 8 characters long.
# You are permitted to use any methods to validate the password.
import re
def password(s):
    return bool(re.match(r'(?=.*[A-Z])(?=.*[a-z])(?=.*\d).{8}', s))

# Suzuki needs help lining up his students!
# Today Suzuki will be interviewing his students to ensure they are progressing in their training.
# He decided to schedule the interviews based on the length of the students name in descending order.
# The students will line up and wait for their turn.
# You will be given a string of student names. Sort them and return a list of names in descending order.
# Here is an example input:
def lineup_students(s):
    return sorted(s.split(), key=lambda i:(len(i), i), reverse=True)

# Create a function that returns a villain name based on the user's birthday. The birthday will be passed to the function as a valid Date object, so for simplicity, there's no need to worry about converting strings to dates.
# The first name will come from the month, and the last name will come from the last digit of the date:
# Month -> first name
# January -> "The Evil"
# February -> "The Vile"
# March -> "The Cruel"
# April -> "The Trashy"
# May -> "The Despicable"
# June -> "The Embarrassing"
# July -> "The Disreputable"
# August -> "The Atrocious"
# September -> "The Twirling"
# October -> "The Orange"
# November -> "The Terrifying"
# December -> "The Awkward"
# Last digit of date -> last name
# 0 -> "Mustache"
# 1 -> "Pickle"
# 2 -> "Hood Ornament"
# 3 -> "Raisin"
# 4 -> "Recycling Bin"
# 5 -> "Potato"
# 6 -> "Tomato"
# 7 -> "House Cat"
# 8 -> "Teaspoon"
# 9 -> "Laundry Basket"
# The returned value should be a string in the form of "First Name Last Name".
# For example, a birthday of November 18 would return "The Terrifying Teaspoon"
def get_villain_name(birthdate):
    first = [ "The Evil","The Vile","The Cruel", "The Trashy","The Despicable", "The Embarrassing", "The Disreputable","The Atrocious", "The Twirling",  "The Orange","The Terrifying", "The Awkward"]
    last = ["Mustache", "Pickle", "Hood Ornament", "Raisin", "Recycling Bin", "Potato", "Tomato", "House Cat", "Teaspoon", "Laundry Basket"]
    return first[birthdate.month - 1] + ' ' + last[int(str(birthdate.day)[-1])]

# Challenge: Given two null-terminated strings in the arguments "string"
# and "prefix", determine if "string" starts with the "prefix" string. Return true or false.
# Example:
# startsWith("hello world!", "hello"); // should return true
# startsWith("hello world!", "HELLO"); // should return false
# startsWith("nowai", "nowaisir"); // should return false
# Addendum: For this problem, an empty "prefix" string should always return true for any value of "string".
# If the length of the "prefix" string is greater than the length of the "string", return false.
# The check should be case-sensitive, i.e. startsWith("hello", "HE") should return false, whereas
# startsWith("hello", "he") should return true.
# The length of the "string" as well as the "prefix" can be defined by the formula: 0 <= length < +Infinity
# No characters should be ignored and/or omitted during the test, e.g. whitespace characters should not be ignored.
def starts_with(st, prefix):
    return st.startswith(prefix)

# Create a function that takes an input String and returns a String, where all the uppercase words of
# the input String are in front and all the lowercase words at the end. The order of the
# uppercase and lowercase words should be the order in which they occur.
# If a word starts with a number or special character, skip the word and leave it out of the result.
# Input String will not be empty.
# For an input String: "hey You, Sort me Already!" the function should return: "You, Sort Already! hey me"
def capitals_first(string):
    return ' '.join([i for i in string.split() if i[0].isupper()] + [i for i in string.split() if i[0].islower()])

# You need to write a function, that returns the first non-repeated character in the given string.
# If all the characters are unique, return the first character of the string.
# If there is no unique character, return null in JS or Java, and None in Python.
# You can assume, that the input string has always non-zero length.
def first_non_repeated(s):
    result = [i for i in s if s.count(i) == 1]
    return result[0] if result else None

# Create a function, as short as possible, that returns this lyrics.
# Your code should be less than 300 characters. Watch out for the three points at the end of the song.
def baby_shark_lyrics():
    l = ['Baby shark', 'Mommy shark', 'Daddy shark', 'Grandma shark', 'Grandpa shark', "Let's go hunt"]
    res = ''
    for i in l:
        res += f"{i}, doo doo doo doo doo doo\n"*3 + i+'!\n'
    return res + "Run away,…"

# The hamming distance of two equal-length strings is the number of positions, in which the two string differ.
# In other words, the number of character substitutions required to transform one string into the other.
# For this first Kata, you will write a function hamming_distance(a, b) with two equal-length strings
# containing only 0s and 1s as parameters. There is no need to test the parameters for validity
# (but you can, if you want).The function's output should be the hamming distance of the two strings as an integer.
def hamming_distance(a, b):
    return sum(1 for k,v in zip(a, b) if k!=v)

# A non-empty array a of length n is called an array of all possibilities if it contains all numbers
# between [0,a.length-1].Write a method named isAllPossibilities that accepts an integer array and
# returns true if the array is an array of all possibilities, else false.
def is_all_possibilities(arr):
    return sorted(arr) == list(range(0, max(arr)+1)) if arr else False

# You are given a string representing a number in binary. Your task is to delete
# all the unset bits in this string and return the corresponding number (after keeping only the '1's).
# In practice, you should implement this function:
def eliminate_unset_bits(number):
    i = number.replace('0', '')
    return int(i, 2) if i  else 0

# Fix My Phone Numbers
# Oh thank goodness you're here! The last intern has completely ruined everything!
# All of our customer's phone numbers have been scrambled, and we need those phone numbers to
# annoy them with endless sales calls!
# The Format
# Phone numbers are stored as strings and comprise 11 digits, eg '02078834982' and must always start with a 0.
# However, something strange has happened and now all of the phone numbers contain lots
# of random characters, whitespace and some are not phone numbers at all!
# For example, '02078834982' has somehow become 'efRFS:)0207ERGQREG88349F82!' and there are lots more
# lines that we need to check.
# The Task
# Given a string, you must decide whether or not it contains a valid phone number. If
# it does, return the corrected phone number as a string ie. '02078834982' with no whitespace or
# special characters, else return "Not a phone number".
def is_it_a_num(s: str) -> str:
    n = ''.join(i for i in s if i.isdigit())
    res = n.startswith('0') and len(n) == 11
    return n if res else 'Not a phone number'

# Task
# Create a function shuffleIt. The function accepts two or more parameters. The first parameter arr
# is an array of numbers, followed by an arbitrary number of numeric arrays.
# Each numeric array contains two numbers, which are indices for elements in
# arr (the numbers will always be within bounds). For every such array, swap the
# elements. Try to use all your new skills: arrow functions,
# the spread operator, destructuring, and rest parameters.
def shuffle_it(arr, *args):
    for k,v in args:
        arr[k], arr[v] = arr[v], arr[k]
    return arr

# Implement a function to calculate the sum of the numerical values in a nested list. For example :
def sum_nested(lst):
	return sum(sum_nested(x) if isinstance(x,list) else x for x in lst)

# In this Kata, you will be given a string and your task is to return the most valuable character.
# The value of a character is the difference between the index of its last occurrence and the index
# of its first occurrence. Return the character that has the highest value. If there is
# a tie, return the alphabetically lowest character. [For Golang return rune]
def solve(st):
    return sorted((st.find(i) - st.rfind(i), i) for i in set(st))[0][1]

# Given a string as input, move all of its vowels to the end of the string, in the same order as they were before.
# Vowels are (in this kata): a, e, i, o, u
# Note: all provided input strings are lowercase.
def move_vowels(s):
    return ''.join(sorted(s, key=lambda x: x in 'aeiou'))

# You are given an initial 2-value array (x). You will use this to calculate a score.
# If both values in (x) are numbers, the score is the sum of the two. If only one is a number,
# the score is that number. If neither is a number, return 'Void!'.
# Once you have your score, you must return an array of arrays. Each sub array will be the same as
# (x) and the number of sub arrays should be equal to the score.
# For example:
def explode(arr):
    numbers = [i for i in arr if type(i) == int]
    return [arr] * sum(numbers) if numbers else "Void!"

# Create a function that takes a 2D array as an input, and outputs another array that contains
# the average values for the numbers in the nested arrays at the corresponding indexes.
# Note: the function should also work with negative numbers and floats.
def avg_array(arrs):
    return [sum(i) / len(i) for i in zip(*arrs)]

# Let's assume we need "clean" strings. Clean means a string should only contain letters a-z, A-Z and spaces.
# We assume that there are no double spaces or line breaks.
# Write a function that takes a string and returns a string without the unnecessary characters.
def remove_chars(s):
    return ''.join(i for i in s if i.isalpha() or i == ' ')

# This is a follow up from my kata The old switcheroo
# Write the function :
# def encode(str)
# that takes in a string str and replaces all the letters with their respective positions in the English alphabet.
def encode(string):
    return ''.join(str(ord(i.lower())-96) if i.isalpha() else i for i in string)

# Kevin is noticing his space run out! Write a function that removes the spaces from
# the values and returns an array showing the space decreasing. For example, running this function
# on the array ['i', 'have','no','space'] would produce ['i','ihave','ihaveno','ihavenospace'].
def spacey(array):
    return [''.join(array[:i]) for i in range(1, len(array) + 1)]

# Given two arrays of integers m and n, test if they contain at least one identical element.
# Return true if they do; false if not.
# Your code must handle any value within the range of a 32-bit integer,
# and must be capable of handling either array being empty (which is a false result, as
# there are no duplicated elements).
def duplicate_elements(m, n):
    return bool(set(m) & set(n))

# In a certain kingdom, strange mathematics is taught at school. Its main difference from
# ordinary mathematics is that the numbers in it are not ordered in ascending order, but
# lexicographically, as in a dictionary (first by the first digit, then,
# if the first digit is equal, by the second, and so on). In addition,
# we do not consider an infinite set of natural numbers, but only the first n numbers.
# So, for example, if n = 11, then the numbers in strange mathematics are ordered as follows:
# 1, 10, 11, 2, 3, 4, 5, 6, 7, 8, 9.
# Help your students to learn this science: write a function that receives two integer
# numbers: n (total amount of numbers in strange mathematics) and k (number from sequence)
# and returns the location of a given number k in the order defined in strange mathematics.
# For example, if n = 11 and k = 2, the function should return 4 as the answer.
# Input: 1 <= n <= 100 000 , 1 <= k <= n.
# Output: position of the number k in sequence of the first n natural numbers in lexicographic
# order. Numbering starts with 1.
def strange_math(n, k):
    return sorted(range(n + 1), key=str).index(k)

# In this Kata, you will be given a string and your task will be to return the length of the
# longest prefix that is also a suffix. A prefix is the start of a string while
# the suffix is the end of a string. For instance, the prefixes of the string
# "abcd" are ["a","ab","abc"]. The suffixes are ["bcd", "cd", "d"]. You should not overlap the prefix and suffix.
def solve(st):
    return next((i for i in range(len(st) // 2, 0, -1) if st[:i] == st[-i:]), 0)

# I've got a crazy mental illness. I dislike numbers a lot. But it's a
# little complicated: The number I'm afraid of depends on which day of the week it is...
# This is a concrete description of my mental illness:
# Monday --> 12
# Tuesday --> numbers greater than 95
# Wednesday --> 34
# Thursday --> 0
# Friday --> numbers divisible by 2
# Saturday --> 56
# Sunday --> 666 or -666
# Write a function which takes a string (day of the week) and an integer
# (number to be tested) so it tells the doctor if I'm afraid or not. (return a boolean)
def am_I_afraid(day,num):
    return {'Monday':  num == 12,'Tuesday': num > 95,'Wednesday': num == 34,'Thursday': num == 0,'Friday': num % 2 == 0,'Saturday': num ==  56,'Sunday': num == 666 or num == -666,}[day]

# There were and still are many problem in CW about palindrome numbers and palindrome strings. We
# suposse that you know which kind of numbers they are. If not, you
# may search about them using your favourite search engine.
# In this kata you will be given a positive integer, val and you have to create the function next_pal
# ()(nextPal Javascript) that will output the smallest palindrome number higher than val.
def next_pal(val):
    val += 1
    while str(val) != str(val)[::-1]:
        val += 1
    return val

# The Ones' Complement of a binary number is the number obtained by swapping all the
# 0s for 1s and all the 1s for 0s. For example:
def ones_complement(binary_number):
    return ''.join('1' if i == '0' else '0' for i in binary_number)

# In the drawing below we have a part of the Pascal's triangle, horizontal lines are numbered from zero (top).
# We want to calculate the sum of the squares of the binomial coefficients on
# a given horizontal line with a function called easyline (or easyLine or easy-line).
# Can you write a program which calculate easyline(n) where n is the horizontal line number?
# The function will take n (with: n>= 0) as parameter and will return the sum of the squares
# of the binomial coefficients on line n.
def easyline(n):
    return easyline(n - 1) * (4 * n - 2) // n if n else 1

# Implement a function that receives two integers m and n and generates a sorted list
# of pairs (a, b) such that m <= a <= b <= n.
# The input m will always be smaller than or equal to n (e.g., m <= n)
def generate_pairs(m, n):
    return [(i,k) for i in range(m, n + 1) for k in range(i, n + 1)]

# Fast & Furious Driving School's (F&F) charges for lessons are as below:
# Time	Cost
# Up to 1st hour	$30
# Every subsequent half hour**	$10
# ** Subsequent charges are calculated by rounding up to nearest half hour.
# For example, if student X has a lesson for 1hr 20 minutes, he will be charged $40 (30+10)
# for 1 hr 30 mins and if he has a lesson for 5 minutes, he will be charged $30 for the full hour.
# Out of the kindness of its heart, F&F also provides a 5 minutes grace period. So, if student X were to
# have a lesson for 65 minutes or 1 hr 35 mins, he will only have to pay for an hour or 1hr 30 minutes respectively.
# For a given lesson time in minutes (min) , write a function cost to calculate how much the lesson
# costs. Input is always > 0.
import math
def cost(mins):
    return 30 + 10 * math.ceil(max(0, mins - 60 - 5) / 30)

# An array is called zero-plentiful if it contains multiple zeros, and every sequence of zeros is at
# least 4 items long.
# Your task is to return the number of zero sequences if the given array is zero-plentiful, oherwise 0.
def zero_plentiful(a):
    r = [len(i) for i in ''.join('0' if not e else ' ' for e in a).strip().split()]
    return len(r) if r and min(r) >= 4 else 0

# Your Task
# Complete the function to convert an integer into a string of the Turkish name.
# input will always be an integer 0-99;
# output should always be lower case.
# Background
# Forming the Turkish names for the numbers 0-99 is very straightforward:
# units (0-9) and tens (10, 20, 30, etc.) each have their own unique name;
# all other numbers are simply [tens] + [unit], like twenty one in English.
# Unlike English, Turkish does not have "teen"-suffixed numbers; e.g.
# 13 would be directly translated as "ten three" rather than "thirteen" in English.
def get_turkish_number(n):
    units = ' bir iki üç dört beş altı yedi sekiz dokuz'.split(' ')
    tens  = ' on yirmi otuz kırk elli altmış yetmiş seksen doksan'.split(' ')
    return f'{tens[n // 10]} {units[n % 10]}'.strip() or 'sıfır'

# Given an array containing only integers, add all the elements and return the binary equivalent of that sum.
# If the array contains any non-integer element (e.g. an object, a float, a string and so on), return false.
# Note: The sum of an empty array is zero.
def arr2bin(arr):
    return bin(sum(arr))[2:] if all(type(i) == int for i in arr) else False

# Kate and Michael want to buy a pizza and share it. Depending on the price of the pizza,
# they are going to divide the costs:
# If the pizza is less than €5,- Michael invites Kate, so Michael pays the full price.
# Otherwise Kate will contribute 1/3 of the price, but no more than €10 (she's broke :-) and Michael pays the rest.
# How much is Michael going to pay? Calculate the amount with two decimals, if necessary.
def michael_pays(cost):
    return round(cost if cost < 5 else max(cost * 2 / 3, cost - 10), 2)

# Complete the function word (string) and returns a string that spells the word using the NATO phonetic alphabet.
# There should be a space between each word in the returned string, and the first letter of each word should
# be capitalized.
# For those of you that don't want your fingers to bleed, this kata already has a dictionary typed out for you.
def nato(word):
    return ' '.join(LETTERS[i.upper()] for i in word)

# You have to create a function that converts integer given as string into ASCII uppercase letters.
# All ASCII characters have their numerical order in table.
# For example,
# from ASCII table, character of number 65 is "A".
# Numbers will be next to each other, So you have to split given number to two digit long integers.
def convert(number):
    word = ''
    while number:
        word += chr(int(number[:2]))
        number = number[2:]
    return word

# A new school year is approaching, which also means students will be taking tests.
# The tests in this kata are to be graded in different ways. A certain number of points will be given for
# each correct answer and a certain number of points will be deducted for each incorrect answer.
# For ommitted answers, points will either be awarded, deducted, or no points will be given at all.
# Return the number of points someone has scored on varying tests of different lengths.
# The given parameters will be:
# An array containing a series of 0s, 1s, and 2s, where 0 is a correct answer, 1 is an omitted answer, and
# 2 is an incorrect answer.
# The points awarded for correct answers
# The points awarded for ommitted answers (note that this may be negative)
# The points deducted for incorrect answers (hint: this value has to be subtracted)
# Note: The input will always be valid (an array and three numbers)
def score_test(tests, right, omit, wrong):
    return tests.count(0) * right + tests.count(1) * omit - tests.count(2) * wrong

# In this kata you need to build a function to return either true/True or false/False
# if a string can be seen as the repetition of a simpler/shorter subpattern or not.
def has_subpattern(string):
    return (string * 2).find(string, 1) != len(string)

# Happy Holidays fellow Code Warriors!
# It's almost Christmas Eve, so we need to prepare some milk and cookies for Santa! Wait...
# when exactly do we need to do that?
# Time for Milk and Cookies
# Complete the function function that accepts a Date object, and returns true if it's
# Christmas Eve (December 24th), false otherwise.
def time_for_milk_and_cookies(dt):
    return str(dt)[-5:-3] == '12' and str(dt)[-2:] == '24'

# Error Handling is very important in coding and seems to be overlooked or not implemented properly.
#Task
# Your task is to implement a function which takes a string as input and return an object containing
# the properties vowels and consonants. The vowels property must contain the total count of
# vowels {a,e,i,o,u}, and the total count of consonants {a,..,z} - {a,e,i,o,u}.
# Handle invalid input and don't forget to return valid ones.
#Input
# The input is any random string. You must then discern what are vowels and what are
# consonants and sum for each category their total occurrences in an object. However you
# could also receive inputs that are not strings. If this happens then you must return
# an object with a vowels and consonants total of 0 because the input was NOT a string.
# Refer to the Example section for a more visual representation of which inputs you could receive
# and the outputs expected. :)
def get_count(words=""):
    if not isinstance(words, str):
        return {'vowels': 0,'consonants': 0}
    letter = "".join([c.lower() for c in words if c.isalpha()])
    vowel = "".join([c for c in letter if c in 'aeiou'])
    conson = "".join([c for c in letter if c not in 'aeiou'])
    return {'vowels': len(vowel),'consonants': len(conson)}

# We have the number 12385. We want to know the value of the closest cube but higher
# than 12385. The answer will be 13824.
# Now, another case. We have the number 1245678. We want to know the 5th power, closest and
# higher than that number. The value will be 1419857.
# We need a function find_next_power ( findNextPower in JavaScript, CoffeeScript and Haskell), that receives two
# arguments, a value val, and the exponent of the power, pow_, and outputs the value that
def find_next_power(val, pow_):
    return int(val ** (1.0 / pow_) + 1) ** pow_

# Sam is an avid collector of numbers. Every time he finds a new number he throws it on the top of his number-pile.
# Help Sam organise his collection so he can take it to the International Number Collectors Conference in Cologne.
# Given an array of numbers, your function should return an array of arrays, where
# each subarray contains all the duplicates of a particular number. Subarrays should be in the same
# order as the first occurence of the number they contain:
def group(arr):
    return [[v] * arr.count(v) for k, v in enumerate(arr) if arr.index(v) == k]

# An Ironman Triathlon is one of a series of long-distance triathlon races organized by the
# World Triathlon Corporaion (WTC). It consists of a 2.4-mile swim,
# a 112-mile bicycle ride and a marathon (26.2-mile) (run, raced in that order
# and without a break. It hurts... trust me.
# Your task is to take a distance that an athlete is through the race, and return one of the following:
# If the distance is zero, return 'Starting Line... Good Luck!'.
# If the athlete will be swimming, return an object with 'Swim' as the key, and the
# remaining race distance as the value.
# If the athlete will be riding their bike, return an object with 'Bike' as the key,
# and the remaining race distance as the value.
# If the athlete will be running, and has more than 10 miles to go, return an object with
# 'Run' as the key, and the remaining race distance as the value.
# If the athlete has 10 miles or less to go, return return an object with 'Run' as the key,
# and 'Nearly there!' as the value.
# Finally, if the athlete has completed te distance, return "You're done! Stop running!".
# All distance should be calculated to two decimal places.
def i_tri(s):
    time = 2.4 + 112.0 + 26.2
    v = time - s
    k = "Swim" if s < 2.4 else "Bike" if s >= 2.4 and s < 114.4 else 'Run'
    if s == 0: return 'Starting Line... Good Luck!'
    elif s >= time: return "You're done! Stop running!"
    elif time - s <= 10: return {'Run':'Nearly there!'}
    else: return {k: "{:.2f}".format(v) + ' to go!'}

# Please write a function that sums a list, but ignores any duplicate items in the list.
# For instance, for the list [3, 4, 3, 6] , the function should return 10.
def sum_no_duplicates(l):
    return sum([i for i in l if l.count(i) == 1])

# Your task is to write a function that takes two or more objects and returns a new
# object which combines all the input objects.
# All input object properties will have only numeric values. Objects are combined
# together so that the values of matching keys are added together.
# An example:
from collections import Counter
def combine(*args):
    return sum((Counter(i) for i in args), Counter())

# Create a function that takes an array of letters, and combines them into words in a sentence.
# The array will be formatted as so:
# [
#   ['J','L','L','M'],
#   ['u','i','i','a'],
#   ['s','v','f','n'],
#   ['t','e','e','']
# ]
# The function should combine all the 0th indexed letters to create the word 'just', all
# the 1st indexed letters to create the word 'live', etc.
# Shorter words will have an empty string in the place once the word has already
# been mapped out (see the last element in the last element in the array).
def arr_adder(arr):
    return ' '.join(map(''.join, zip(*arr)))

# A triangle is called an equable triangle if its area equals its perimeter. Return true, if
# it is an equable triangle, else return false. You will be provided with
# the length of sides of the triangle. Happy Coding!
def equable_triangle(a,b,c):
    p = (a + b + c) / 2
    return (p*(p-a)*(p-b)*(p-c)) ** .5 == a + b + c

# To celebrate today's launch of my Hero's new book: Alan Partridge: Nomad, We
# have a new series of kata arranged around the great man himself.
# Task
# Given an array of terms, if any of those terms relate to Alan Partridge, return Mine's a Pint!
# The number of exclamation mark (!) after the t should be determined by the number of Alan
# related terms you find in the given array (x). The related terms are as follows:
def part(arr):
    l = ['Partridge', 'PearTree', 'Chat', 'Dan', 'Toblerone', 'Lynn', 'AlphaPapa', 'Nomad']
    s = sum(1 for i in arr if i in l)
    return f"Mine's a Pint{'!'*s}" if any(i in l for i in arr) else "Lynn, I've pierced my foot on a spike!!"

# When no more interesting kata can be resolved, I just choose to create the new kata, to
# solve their own, to enjoy the process --myjinxin2015 said
# Note:
# arr/$a always has at least 5 elements;
# range/$range/ranges always has at least 1 element;
# All inputs are valid;
def max_sum(arr,ranges):
    return max([sum(arr[i] for i in range(j[0], j[1]+1)) for j in ranges])

# Do you speak retsec?
# You and your friends want to play undercover agents. In order to exchange
# your secret messages, you've come up with the following system: you take
# the word, cut it in half, and place the first half behind the latter. If the
# word has an uneven number of characters, you leave the middle at its previous place:
def reverse_by_center(s):
    return s[len(s)//2:] + s[:len(s)//2] if len(s) % 2 == 0 else s[len(s)//2+1:] + s[len(s)//2] + s[:len(s)//2]

# This kata is all about adding numbers.
# You will create a function named add. This function will return the sum
# of all the arguments. Sounds easy, doesn't it??
# Well here's the twist. The inputs will gradually increase with their index as parameter to the function.
def add(*args):
    return sum(v * (k + 1) for k,v in enumerate(args))

# In English, all words at the begining of a sentence should begin with a capital letter.
# You will be given a paragraph that does not use capital letters.
# Your job is to capitalise the first letter of the first word of each sentence.
# For example,
# input:
# "hello. my name is inigo montoya. you killed my father. prepare to die."
# output:
# "Hello. My name is inigo montoya. You killed my father. Prepare to die."
# You may assume:
# there will be no punctuation besides full stops and spaces
# all but the last full stop will be followed by a space and at least one word
def fix(paragraph):
    return '. '.join(i.capitalize() for i in paragraph.split('. '))

# Write a function with the signature shown below:
# def is_int_array(arr):
#     return True
# returns true  / True if every element in an array is an integer or a float with no decimals.
# returns true  / True if array is empty.
# returns false / False for every other input.
def is_int_array(arr):
    try:
        return arr == list(map(int, arr))
    except:
        return False

# Write a function, factory, that takes a number as its parameter and returns another function.
# The returned function should take an array of numbers as its parameter, and return an array of those
# numbers multiplied by the number that was passed into the first function.
# In the example below, 5 is the number passed into the first function. So it returns
# a function that takes an array and multiplies all elements in it by five.
# Translations and comments (and upvotes) welcome!
def factory(x):
    return lambda i: [x * j for j in i]

# Create a function that returns the lowest product of 4 consecutive digits in a number given as a string.
# This should only work if the number has 4 digits or more. If not, return "Number is too small".
from operator import mul
from functools import reduce
def lowest_product(input):
    return min(reduce(mul, [*map(int, input)][i:i + 4]) for i in range(0, len(input) - 3)) if len(input) > 3 else "Number is too small"

# Format any integer provided into a string with "," (commas) in the correct places.
def number_format(n):
    return format(n, ',d')

# Colour plays an important role in our lifes. Most of us like this colour better then another.
# User experience specialists believe that certain colours have certain psychological meanings for us.
# You are given a 2D array, composed of a colour and its 'common' association in each array element. The function
# you will write needs to return the colour as 'key' and association as its 'value'.
def colour_association(arr):
    return [{i[0]: i[1]} for i in arr]

# Your job is to check that the provided list / array of stations contains all
# of the stops Alan mentions. The list of stops are as follows:
def alan(arr):
    stations = ['Rejection','Disappointment','Backstabbing Central','Shattered Dreams Parkway']
    return 'Smell my cheese you mother!' if all(i in arr for i in stations) else 'No, seriously, run. You will miss it.'

# Write a function that returns only the decimal part of the given number.
# You only have to handle valid numbers, not Infinity, NaN, or similar. Always return a positive decimal part.
def get_decimal(n):
    return abs(n) % 1

# Make your strings more nerdy: Replace all 'a'/'A' with 4, 'e'/'E' with 3 and
# 'l' with 1 e.g. "Fundamentals" --> "Fund4m3nt41s"
def nerdify(txt):
    d = {'a': 4, 'e': 3, 'l': 1, 'A': 4, 'E': 3}
    return ''.join(str(d[i]) if i in d else i for i in txt)

# The GADERYPOLUKI is a simple substitution cypher used in scouting to encrypt messages. The
# encryption is based on short, easy to remember key.
# The key is written as paired letters, which are in the cipher simple replacement.
# The most frequently used key is "GA-DE-RY-PO-LU-KI".
#  G => A
#  g => a
#  a => g
#  A => G
#  D => E
#   etc.
# The letters, which are not on the list of substitutes, stays in the encrypted text without changes.
# Task
# Your task is to help scouts to encrypt and decrypt thier messages. Write the Encode and Decode functions.
# Input/Output
# The input string consists of lowercase and uperrcase characters and white . The substitution has to be
# case-sensitive.
def encode(str):
    return str.translate(str.maketrans("GDRPLKAEYOUIgdrplkaeyoui","AEYOUIGDRPLKaeyouigdrplk"))
def decode(str):
    return encode(str)

# Write function makeParts or make_parts (depending on your language) that will
# take an array as argument and the size of the chunk.
# Example: if an array of size 123 is given and chunk size is 10 there will be
# 13 parts, 12 of size 10 and 1 of size 3.
def make_parts(arr, chunkSize):
    return [arr[i: i + chunkSize] for i in range(0, len(arr), chunkSize)]

# You have a collection of lovely poems. Unfortunately, they aren't formatted very well. They're all on
# one line, like this:
# Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex
# is better than complicated.
# What you want is to present each sentence on a new line, so that it looks like this:
# Beautiful is better than ugly.
# Explicit is better than implicit.
# Simple is better than complex.
# Complex is better than complicated.
# Write a function, format_poem() that takes a string like the one line example as an argument and
# returns a new string that is formatted across multiple lines with each new sentence starting on a new line when
# you print it out.
# Try to solve this challenge with the str.split() and the str.join() string methods.
# Every sentence will end with a period, and every new sentence will have one space before the previous period.
# Be careful about trailing whitespace in your solution.
def format_poem(poem):
    return '.\n'.join(poem.split('. '))

# You are a barista at a big cafeteria. Normally there are a lot of baristas,
# but your boss runs a contest and he told you that, if you could
# handle all the orders with only one coffee machine in such a way that the
# sum of all the waiting times of the customers is the smallest possible, he will give you a substantial raise.
# So you are the only barista today, and you only have one coffee machine that can brew one coffee at a time.
# People start giving you their orders.
# Let's not think about the time you need to write down their orders, but you need
# 2 additional minutes to clean the coffee machine after each coffee you make.
# Now you have a list coffees of the orders and you write down next to each of the orders the time
# you need to brew each one of those cups of coffee.
# Task:
# Given a list of the times you need to brew each coffee, return the minimum total waiting time.
# If you get it right, you will get that raise your boss promised you!
def barista(coffees):
    return sum(v * (k + 1) + 2 * k for k,v in enumerate(sorted(coffees, reverse=True)))

# Implement function which will return sum of roots of a quadratic equation rounded
# to 2 decimal places, if there are any possible roots, else return None/null/nil/nothing.
# If you use discriminant,when discriminant = 0, x1 = x2 = root => return sum of both roots.
# There will always be valid arguments.
def roots(a,b,c):
    return round(-b / a, 2) if b ** 2 >= 4 * a * c else None

# The factorial of a number, n!, is defined for whole numbers as the product of all integers from 1 to n.
# For example, 5! is 5 * 4 * 3 * 2 * 1 = 120
# Most factorial implementations use a recursive function to determine the value of factorial(n). However,
# this blows up the stack for large values of n - most systems
# cannot handle stack depths much greater than 2000 levels.
# Write an implementation to calculate the factorial of arbitrarily large numbers, without recursion.
import math
def factorial(n):
    return math.prod(list(range(1, n + 1))) if n >= 0 else None

# You have to write a function pattern which creates the following pattern (see examples) up to the desired
# number of rows.
# If the Argument is 0 or a Negative Integer then it should return "" i.e. empty string.
# If any even number is passed as argument then the pattern should last upto the largest
# odd number which is smaller than the passed even number.
def pattern(n):
    c = n if n % 2 == 0 else n + 1
    return '\n'.join(str(i)*i for i in range(1, c, 2))

# You have two arrays in this kata, every array contains unique elements only. Your task
# is to calculate number of elements in the first array which are also present in the second array.
def match_arrays(v, r):
    return sum(1 for i in v if i in r)

# The odd and even numbers are fighting against each other!
# You are given a list of positive integers. The odd numbers from the list will fight using their 1 bits
# from their binary representation, while the even numbers will fight using their 0 bits.
# If present in the list, number 0 will be neutral, hence not fight for either side.
# You should return:
# odds win if number of 1s from odd numbers is larger than 0s from even numbers
# evens win if number of 1s from odd numbers is smaller than 0s from even numbers
# tie if equal, including if list is empty
# Please note that any prefix that might appear in the binary representation, e.g. 0b,
# should not be counted towards the battle.
def bits_battle(numbers):
    odd = 0
    even = 0
    for n in numbers:
        if n % 2:
            odd += bin(n).count('1')
        elif n != 0 and n % 2 == 0:
            even += bin(n)[2:].count('0')
    return 'odds win' if odd > even else 'evens win' if even > odd else 'tie'

# Create a function mispelled(word1, word2):
# It checks if the word2 differs from word1 by at most one character.
# This can include an extra char at the end or the beginning of either of words.
# In the tests that expect true, the mispelled word will always differ mostly by
# one character. If the two words are the same, return True.
def mispelled(word1, word2):
    if word1 == word2[1:] or word1[1:] == word2 or word1[:-1] == word2 or word1 == word2[:-1]:
        return True
    if any(word1[:i] + word1[i+1:] == word2[:i] + word2[i+1:] for i in range(len(word1))):
        return True
    else:
        return False

# Calculate area of given triangle. Create a function t_area that will take a string
# which will represent triangle, find area of the triangle, one space will be
# equal to one length unit. The smallest triangle will have one length unit.
def t_area(s):
    return (s.count('\n') - 2) ** 2 / 2

# You will be given two strings a and b consisting of lower case letters, but a will
# have at most one asterix character. The asterix (if any) can be replaced with an
# arbitrary sequence (possibly empty) of lowercase letters. No other character of string a can be replaced.
# If it is possible to replace the asterix in a to obtain string b, then string b matches the pattern.
# If the string matches, return true else false.
import re
def solve(a, b):
    return bool(re.fullmatch(a.replace('*', '.*'), b))

# Complete the function so that it returns the number of seconds that have elapsed between the start
# and end times given.
# Tips:
# The start/end times are given as Date (JS/CoffeeScript), DateTime (C#), Time (Nim),
# datetime(Python) and Time (Ruby) instances.
# The start time will always be before the end time.
def elapsed_seconds(start, end):
    return (end - start).total_seconds()

# The input will be an array of dictionaries.
# Return the values as a string-seperated sentence in the order of their keys' integer equivalent
# (increasing order).
# The keys are not reoccurring and their range is -999 < key < 999. The dictionaries'
# keys & values will always be strings and will always not be empty.
def sentence(ds):
    return ' '.join(v for k, v in sorted((int(k), v) for d in ds for k, v in d.items()))

# In Bali, as far as I can gather, when ex-pats speak to locals, they basically insert the word 'Pak' as often as
# possible. I am assured it means something like 'mate' or 'sir' but that could be completely wrong.
# Anyway, as some basic language education(??) this kata requires you to turn any sentence provided (s)
# into ex-pat balinese waffle by inserting the word 'pak' between every other word. Simple 8kyu :D
# Pak should not be the first or last word. Strings of just spaces should return an empty string.
def pak(s):
    return ' pak '.join(s.split())

# A History Lesson
# Tetris is a puzzle video game originally designed and programmed by Soviet Russian
# software engineer Alexey Pajitnov. The first playable version was completed on June 6,
# 1984. Pajitnov derived its name from combining the Greek numerical prefix tetra
# - (the falling pieces contain 4 segments) and tennis, Pajitnov's favorite sport.
# About scoring system
# The scoring formula is built on the idea that more difficult line clears should be awarded more points. For
# example, a single line clear is worth 40 points, clearing four lines at once (known as a Tetris) is worth 1200
# A level multiplier is also used. The game starts at level 0. The level increases
# every ten lines you clear. Note that after increasing the level, the total number of cleared lines is not reset.
# For our task you can use this table:
def get_score(arr) -> int:
    return sum([0, 40, 100, 300, 1200][v] * (1 + (sum(arr[:k]) // 10)) for k, v in enumerate(arr))

# Complete the function that accepts a valid string and returns an integer.
# Wait, that would be too easy! Every character of the string should be converted
# to the hex value of its ascii code, then the result should be the sum of
# the numbers in the hex strings (ignore letters).
def hex_hash(code):
    return sum(int(i) for j in code for i in hex(ord(j)) if i.isdigit())

# Is the number even?
# If the numbers is even return true. If it's odd, return false.
# Oh yeah... the following symbols/commands have been disabled!
# use of %
# use of .even? in Ruby
# use of mod in Python
def is_even(n):
    return n // 2 == n / 2

# Implement the method lastIndexOf (last_index_of in PHP and Python), which accepts a linked list (head) and
# a value, and returns the index (zero based) of the last occurrence of that value if exists, or -1 otherwise.
# For example: Given the list: 1 -> 2 -> 3 -> 3, and the value 3, lastIndexOf / last_index_of should return 3.
def last_index_of(head, search_val):
    count = pos = -1
    while head:
        count += 1
        if head.data == search_val:
            pos = count
        head = head.next
    return pos

# A squared string is a string of n lines, each substring being n characters long.
# We are given two n-squared strings. For example:
# s1 = "abcd\nefgh\nijkl\nmnop" s2 = "qrst\nuvwx\nyz12\n3456"
# Let us build a new string strng of size (n + 1) x n in the following way:
# The first line of strng has the first char of the first line of s1 plus the chars of the last line of s2.
# The second line of strng has the first two chars of the second line of s1 plus the chars
# of the penultimate line of s2 except the last char
# and so on until the nth line of strng has the n chars of the nth line of s1
# plus the first char of the first line of s2.
def compose(s1, s2):
    s1 = s1.split("\n")
    s2 = s2.split("\n")[::-1]
    count = len(s1)
    out = []
    for i in range(count):
        out.append(s1[i][:i+1] + s2[i][:(count-i)])
    return "\n".join(out)

# Suppose a variable x can have only three possible different values a, b and c, and you wish to assign to x
# the value other than its current one, and you wish your code to be independent of the values of a, b and c.
# What is the most efficient way to cycle among three values? Write a function f so that it satisfies
def f(x, a, b, c):
    return {a: b, b: c, c: a}[x]

# Why would we want to stop to only 50 shades of grey? Let's see to how many we can go.
# Write a function that takes a number n as a parameter and return an array containing
# n shades of grey in hexadecimal code (#aaaaaa for example). The array should be sorted
# in ascending order starting with '#010101', '#020202', etc. (using lower case letters).
def shades_of_grey(n):
    return [ '#{0:02x}{0:02x}{0:02x}'.format(i+1) for i in range(min(254, n)) ]

# You have to write a function pattern which creates the following pattern upto n number of rows.
# If the Argument is 0 or a Negative Integer then it should return "" i.e. empty string.
def pattern(integer):
    return "\n".join("".join(str(j) for j in range(integer, integer - i, -1)) for i in range(1, integer + 1))

# Complete the function that takes an array of integers as input and finds the sum of squares of
# the elements at even positions (i.e. 2nd, 4th, etc.) plus the sum of the rest of the elements at odd position.
# For empty arrays, result should be zero (except for Haskell).
# Note
# The values at even positions need to be squared. For a language with zero-based indices,
# this will occur at oddly-indexed locations. For instance, in Python,
# the values at indices 1, 3, 5, etc. should be squared because these are the second,
# fourth, and sixth positions in the list.
def alternate_sq_sum(arr):
    return sum(v ** 2 if k % 2 else v for k, v in enumerate(arr))

# Write a function which maps a function over the lists in a list:
def grid_map(inp, op):
    return [list(map(op, i)) for i in inp]

# Write a module Converter that can take ASCII text and convert it to hexadecimal. The class should
# also be able to take hexadecimal and convert it to ASCII text. To make the
# conversion well defined, each ASCII character is represented by exactly two hex digits,
# left-padding with a 0 if needed. The conversion from ascii to
# hex should produce lowercase strings (i.e. f6 instead of F6).
class Converter():
    @staticmethod
    def to_ascii(h):
        return bytes.fromhex(h).decode()
    @staticmethod
    def to_hex(s):
        return ''.join(hex(ord(i))[2:] for i in s)

# Your non-profit company has assigned you the task of calculating some simple statistics on donations. You have
# an array of integers, representing various amounts of donations your company has been given.
# In particular, you're interested in the median value for donations.
# The median is the middle number of a sorted list of numbers. If the list
# is of even length, the 2 middle values are averaged.
# Write a function that takes an array of integers as an argument and returns the median of those integers.
# Notes:
# The sorting step is vital.
# Input arrays are non-empty.
def median(array):
    l = len(array) % 2 != 0
    return sorted(array)[len(array)//2] if l else (sorted(array)[len(array)//2-1] + sorted(array)[len(array)//2])/2

# A palindrome is a word, phrase, number, or other sequence of characters which
# reads the same backward as forward. Examples of numerical palindromes are:
# 2332
# 110011
# 54322345
# You'll be given 2 numbers as arguments: (num,s). Write a function which returns an array
# of s number of numerical palindromes that come after num. If num is a palindrome itself,
# it should be included in the count.
# Return "Not valid" instead if any one of the inputs is not an integer or is less than 0.
# For this kata, single digit numbers will NOT be considered numerical palindromes.
def palindrome(num,s):
    if type(num) != int or num <= 0 or type(s) != int or s < 0:
        return 'Not valid'
    l = []
    c = 0
    while c < s:
        if str(num) == str(num)[::-1] and len(str(num)) > 1:
            l.append(num)
            c += 1
        num += 1
    return l

# You are given two strings. In a single move, you can choose
# any of them, and delete the first (i.e. leftmost) character.
# For Example:
# By applying a move to the string "where", the result is the string "here".
# By applying a move to the string "a", the result is an empty string "".
# Implement a function that calculates the minimum number of moves that should be performed
# to make the given strings equal.
# Notes
# Both strings consist of lowercase latin letters.
# If the string is already empty, you cannot perform any more delete operations.
def shift_left(word1, word2, n = 0):
    if word1 == word2:
        return n
    elif len(word1) > len(word2):
        return shift_left(word1[1:], word2, n + 1)
    else:
        return shift_left(word1, word2[1:], n + 1)

# In this kata you will be given a list consisting of unique elements except for one thing that appears twice.
# Your task is to output a list of everything inbetween both occurrences of this element in the list.
def duplicate_sandwich(arr):
    start, end = [k for k, v in enumerate(arr) if arr.count(v) > 1]
    return arr[start+1:end]

# Complete the solution. It should try to retrieve the value of the array at the index provided.
# If the index is out of the array's max bounds then it should return the default value instead.
def solution(items, index, default_value):
    try:
        return items[index]
    except:
        return default_value

# Rick wants a faster way to get the product of the largest pair in an array.
# Your task is to create a performant solution to find the product of the largest two integers
# in a unique array of positive numbers.
# All inputs will be valid.
# Passing [2, 6, 3] should return 18, the product of [6, 3].
# Disclaimer: only accepts solutions that are faster than his, which has a running time O(nlogn).
def max_product(a):
    max1 = max(a)
    a.remove(max1)
    max2 = max(a)
    return max1 * max2

# This Kata is intended as a small challenge for my students
# All Star Code Challenge #20
# Create a function called addArrays() that combines two arrays of equal length, summing each element of the
# first with the corresponding element in the second, returning the "combined" summed array.
# Raise an error if input arguments are not of equal length.
def add_arrays(array1, array2):
    return [array1[k] + array2[k] for k, v in enumerate(array1)] if len(array1) == len(array2) else Error

# Complete the method that returns true if 2 integers share at least
# two 1 bits, otherwise return false. For simplicity assume that all numbers are non-negative.
def shared_bits(a, b):
    return bin(a & b).count('1') > 1

# Comprised of a team of five incredibly brilliant women, "The ladies of ENIAC" were the first “computors”
# working at the University of Pennsylvania’s Moore School of Engineering (1945). Through their
# contributions, we gained the first software application and the first programming classes! The ladies
# of ENIAC were inducted into the WITI Hall of Fame in 1997!
# Write a function which reveals "The ladies of ENIAC" names,
# so that you too can add them to your own hall of tech fame!
# To keep: only alpha characters, space characters and exclamation marks.
# To remove: numbers and these characters: %$&/£?@
# Result should be all in uppercase.
import re
def rad_ladies(name):
    return "".join(re.findall("[A-Z\s!]+", name.upper()))

# Given two integers a and x, return the minimum non-negative number to add
# to / subtract from a to make it a multiple of x.
def minimum(a, x):
    return min(a % x, -a % x)

# The Club Doorman will give you a word. To enter the Club you need
# to provide the right number according to provided the word.
# Every given word has a doubled letter, like 'tt' in lettuce.
# To answer the right number you need to find the doubled letter's position of the given word in the alphabet
# and multiply this number per 3.
# It will be given only words with one doubled letter.
# EXAMPLE
# Lettuce is the given word. 't' is the doubled letter and it's position is 20 in the alphabet.
# The answer to the Club Doorman is 20 * 3 = 60
# TASK
# The function passTheDoorMan with a given string word shall return the right number.
def pass_the_door_man(word):
    for char in word:
        if char*2 in word:
            return (ord(char)-96) * 3

# In programming you know the use of the logical negation operator (!), it reverses the meaning of a condition.
# !false = true
# !!false = false
# Your task is to complete the function 'negationValue()' that takes a string of negations with a value and
# returns what the value would be if those negations were applied to it.
def negation_value(str, val):
    return bool(not val if str.count('!') % 2 else val)

# In this kata you will be given a random string of letters and tasked with returning them
# as a string of comma-separated sequences sorted alphabetically, with each
# sequence starting with an uppercase character followed by n-1 lowercase characters, where n
# is the letter's alphabet position 1-26.
def alpha_seq(s):
    return ",".join((char*(ord(char)-96)).capitalize() for char in sorted(s.lower()))

# Return true when any odd bit of x equals 1; false otherwise.
# Assume that:
# x is an unsigned, 32-bit integer;
# the bits are zero-indexed (the least significant bit is position 0)
def any_odd(x):
    return '1' in list(bin(x))[-2::-2]

# To celebrate the start of the Rio Olympics (and the return of 'the Last Leg' on C4 tonight)
# this is an Olympic inspired kata.
# Given a string of random letters, you need to examine each. Some letters naturally have
# 'rings' in them. 'O' is an obvious example, but 'b', 'p', 'e', 'A', etc are all
# just as applicable. 'B' even has two!! Please note for this kata you can count lower case 'g' as only one ring.
# Your job is to count the 'rings' in each letter and divide the total number by 2.
# Round the answer down. Once you have your final score:
# if score is 1 or less, return 'Not even a medal!'; if score is 2, return 'Bronze!'; if score is 3,
# return 'Silver!'; if score is more than 3, return 'Gold!';
# Dots over i's and any other letters don't count as rings.
def olympic_ring(string):
    ring = 'abdegopqADOPQRBB'
    count = sum(string.count(c) for c in ring) // 2
    if count <= 1:
        return 'Not even a medal!'
    if count == 2:
        return 'Bronze!'
    if count == 3:
        return 'Silver!'
    return 'Gold!'

# You are given a sequence of a journey in London, UK. The sequence will contain
# bus numbers and TFL tube names as strings e.g.
# ['Northern', 'Central', 243, 1, 'Victoria']
# Journeys will always only contain a combination of tube
# names and bus numbers. Each tube journey costs £2.40 and each bus journey costs
# £1.50. If there are 2 or more adjacent bus journeys, the bus fare is capped for sets
# of two adjacent buses and calculated as one bus fare for each set.
# For example: 'Piccadilly', 56, 93, 243, 20, 14 -> "£6.90"
# Your task is to calculate the total cost of the journey and return the cost rounded to 2
# decimal places in the format (where x is a number): £x.xx
def london_city_hacker(journey):
    vehicle = "".join("t" if isinstance(k, str) else "b" for k in journey).replace("bb", "b")
    return f"£{sum(2.4 if i == 't' else 1.5 for i in vehicle):.2f}"

# You should write a simple function that takes string as input and checks if it is
# a valid Russian postal code, returning true or false.
# A valid postcode should be 6 digits with no white spaces, letters or other symbols.
# Empty string should also return false.
# Please also keep in mind that a valid post code cannot start with 0, 5, 7, 8 or 9
def zipvalidate(postcode):
    return len(postcode) == 6 and postcode.isdigit() and postcode[0] not in "05789"

# Create a function that takes a string and returns that string with the
# first half lowercased and the last half uppercased.
# eg: foobar == fooBAR
# If it is an odd number then 'round' it up to find which letters to uppercase. See example below.
def sillycase(silly):
    half_life = (len(silly) + 1) // 2
    return silly[:half_life].lower() + silly[half_life:].upper()

# You have to create a method "compoundArray" which should take as input two int arrays
# of different length and return one int array with numbers of both arrays shuffled one by one.
def compound_array(a, b):
    l = []
    while a or b:
        if a: l.append(a.pop(0))
        if b: l.append(b.pop(0))
    return l

# In this kata, your task is to implement an extended version of the famous rock-paper-scissors
# game. The rules are as follows:
# Scissors cuts Paper
# Paper covers Rock
# Rock crushes Lizard
# Lizard poisons Spock
# Spock smashes Scissors
# Scissors decapitates Lizard
# Lizard eats Paper
# Paper disproves Spock
# Spock vaporizes Rock
# Rock crushes Scissors
# Task:
# Given two values from the above game, return the Player result as "Player 1 Won!", "Player 2 Won!", or "Draw!".
def rpsls(p1, p2):
    var = "rock lizard spock scissors paper spock rock scissors lizard paper rock"
    return ("Player 1 Won!" if f"{p1} {p2}" in var else "Player 2 Won!" if f"{p2} {p1}" in var else "Draw!")

# Find the area of a rectangle when provided with one diagonal and one side of the rectangle. If
# the input diagonal is less than or equal to the length of the side,
# return "Not a rectangle". If the resultant area has decimals round it to two places.
# This kata is meant for beginners. Rank and upvote to bring it out of beta!
def area(d, l):
    return "Not a rectangle" if d <= l else round(l * (d**2 - l**2) **.5, 2)

# You will be given an array of objects representing data about developers who have signed
# up to attend the next coding meetup that you are organising.
# Given the following input array:
# Write a function that returns the array sorted alphabetically by the programming language.
# In case there are some developers that code in the same language, sort them alphabetically by the first name:
def sort_by_language(arr):
	return sorted(arr, key=lambda x: (x["language"], x["first_name"]))

# Task
# Implement a function which finds the numbers less than 2, and
# the indices of numbers greater than 1 in the given sequence, and returns them as a pair of sequences.
# Return a nested array or a tuple depending on the language:
# The first sequence being only the 1s and 0s from the original sequence.
# The second sequence being the indexes of the elements greater than 1 in the original sequence.
def binary_cleaner(lst):
    return [i for i in lst if i < 2], [k for k, v in enumerate(lst) if v > 1]

# Let us consider integer coordinates x, y in the Cartesian plane and three functions f, g, h defined by:
# f: 1 <= x <= n, 1 <= y <= n --> f(x, y) = min(x, y)
# g: 1 <= x <= n, 1 <= y <= n --> g(x, y) = max(x, y)
# h: 1 <= x <= n, 1 <= y <= n --> h(x, y) = x + y
# where n is a given integer (n >= 1) and x, y are integers.
# In the table below you can see the value of the function f with n = 6.
def sumin(n):
    return n * (n + 1) * (2 * n + 1) // 6
def sumax(n):
    return n * (n + 1) * (4 * n - 1) // 6
def sumsum(n):
    return n * n * (n + 1)

# Linked Lists - Push & BuildOneTwoThree
# Write push() and buildOneTwoThree() functions to easily update and initialize
# linked lists. Try to use the push() function within your buildOneTwoThree() function.
# Here's an example of push() usage:
class Node(object):
    def __init__(self, data, next=None):
        self.data = data
        self.next = next
def push(head, data):
    return Node(data, head)
def build_one_two_three():
    return Node(1, Node(2, Node(3)))

# zip_with takes a function and two arrays and zips the arrays together, applying the
# function to every pair of values.
# The function value is one new array.
# If the arrays are of unequal length, the output will only be as long as the shorter one.
# (Values of the longer array are simply not used.)
# Inputs should not be modified.
def zip_with(fn, a1, a2):
    return list(map(fn, a1, a2))

# You probably know that some characters written on a piece of paper, after turning this sheet 180
# degrees, can be read, although sometimes in a different way. So, uppercase letters
# "H", "I", "N", "O", "S", "X", "Z" after rotation are not changed, the letter "M"
# becomes a "W", and Vice versa, the letter "W" becomes a "M".
# We will call a word "shifter" if it consists only of letters
# "H", "I", "N", "O", "S", "X", "Z", "M" and "W". After turning the sheet, this word can
# also be read, although in a different way. So, the word "WOW "turns into the word "MOM".
# On the other hand, the word "HOME" is not a shifter.
# Find the number of unique shifter words in the input string (without duplicates). All shifters to
# be counted, even if they are paired (like "MOM" and "WOW"). String contains only uppercase letters.
import re
def shifter(st):
     return len(set(re.findall(r"\b[HINOSXZMW]+\b", st)))

# I love Fibonacci numbers in general, but I must admit I love some more than others.
# I would like for you to write me a function that, when given a number n (n >= 1 ),
# returns the nth number in the Fibonacci Sequence.
def nth_fib(n):
  a, b = 0, 1
  for i in range(n-1):
  	a, b = b, a + b
  return a

# One of the first algorithm used for approximating the integer square root of a positive integer n is
# known as "Hero's method", named after the first-century Greek mathematician Hero
# of Alexandria who gave the first description of the method. Hero's method can
# be obtained from Newton's method which came 16 centuries after.
# We approximate the square root of a number n by taking an initial guess x, an
# error e and repeatedly calculating a new approximate integer value x using:
# (x + n / x) / 2; we are finished when the previous x and the new x have an absolute difference less than e.
# We supply to a function (int_rac) a number n (positive integer) and a parameter
# guess (positive integer) which will be our initial x. For this kata the parameter 'e' is set to 1.
# Hero's algorithm is not always going to come to an exactly correct result! For instance: if n = 25 we
# get 5 but for n = 26 we also get 5. Nevertheless 5 is the integer square root of 26.
# The kata is to return the count of the progression of integer approximations that the algorithm makes.
# Reference:
def int_rac(n, guess):
    count = 0
    while True:
        count += 1
        next = (guess + n // guess) // 2
        if next == guess:
            return count
        guess = next

# You have an amount of money a0 > 0 and you deposit it with an
# interest rate of p percent divided by 360 per day on the 1st of January 2016. You
# want to have an amount a >= a0.
# Task:
# The function date_nb_days (or dateNbDays...) with parameters a0, a, p
# will return, as a string, the date on which you have just reached a.
# Example:
# date_nb_days(100, 101, 0.98) --> "2017-01-01" (366 days)
# date_nb_days(100, 150, 2.00) --> "2035-12-26" (7299 days)
# Notes:
# The return format of the date is "YYYY-MM-DD"
# The deposit is always on the "2016-01-01"
# Don't forget to take the rate for a day to be p divided by 36000 since banks
# consider that there are 360 days in a year.
# You have: a0 > 0, p% > 0, a >= a0
from math import ceil, log
from datetime import date, timedelta as td
def date_nb_days(a0, a, p):
    dur = log(a, 1 + p / 36000.0) - log(a0, 1 + p / 36000.0)
    return str(date(2016, 1, 1) + td(ceil(dur)))

# Return a function that will trim a string (the first argument given) if it
# is longer than the maximum string length (the second argument given). The result should also end with "..."
# These dots at the end also add to the string length.
# So in the above example, trim("Creating kata is fun", 14) should return "Creating ka..."
# If the string is smaller than or equal to 3 characters then the length of
# the dots is not added to the string length.
# e.g. trim("He", 1) should return "H..."
# If the string is smaller or equal than the maximum string length,
# then simply return the string with no trimming or dots required.
# e.g. trim("Code Wars is pretty rad", 50) should return "Code Wars is pretty rad"
def trim(phrase, size):
    if len(phrase) <= size:
        return phrase
    elif size <= 3 :
        return phrase[:size] + '...'
    return phrase[:size - 3] + '...'

# Your goal is to implement the method meanVsMedian which accepts an
# odd-length array of integers and returns one of the following:
# 'mean' - in case mean value is larger than median value
# 'median' - in case median value is larger than mean value
# 'same' - in case both mean and median share the same value
# Reminder: Median
# Array will always be valid (odd-length >= 3)
from statistics import median, mean
def mean_vs_median(numbers):
    med, mea = median(numbers), mean(numbers)
    return 'mean' if mea > med else 'median' if med > mea else 'same'

# Mash 2 arrays together so that the returning array has alternating elements of the
# 2 arrays . Both arrays will always be the same length.
# eg. [1,2,3] + ['a','b','c'] = [1, 'a', 2, 'b', 3, 'c']
def array_mash(a, b):
    l = []
    while a or b:
        l.append(a.pop(0))
        l.append(b.pop(0))
    return l

# Write a function that accepts two parameters (a and b) and says whether a is smaller
# than, bigger than, or equal to b.
# Here is an example code:
# There's only one problem...
# You can't use if statements, and you can't use shorthands like (a < b)?true:false;
# in fact the word "if" and the character "?" are not allowed in the code.
def no_ifs_no_buts(a, b):
    dictionary = {a < b:'smaller than', a == b:'equal to', a > b: 'greater than'}
    return f'{a} is {dictionary[True]} {b}'

# This is the first part of this kata series. Second part is here and third part is here
# Add two English words together!
# Implement a class Arith (struct struct Arith{value : &'static str,} in Rust) such that
integer = ['zero', 'one', 'two', 'three', 'four', 'five',
           'six', 'seven', 'eight', 'nine', 'ten','eleven',
           'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen',
           'seventeen', 'eighteen', 'nineteen', 'twenty']
class Arith():
    def __init__(self, int):
        self.i = integer.index(int)
    def add(self, int):
         return integer[integer.index(int) + self.i]

# You are given an n by n ( square ) grid of characters, for example:
# [['m', 'y', 'e'],
#  ['x', 'a', 'm'],
#  ['p', 'l', 'e']]
# You are also given a list of integers as input, for example:
# [1, 3, 5, 8]
# You have to find the characters in these indexes of the grid if you think of the indexes as:
# [[1, 2, 3],
#  [4, 5, 6],
#  [7, 8, 9]]
# Remember that the indexes start from one and not zero.
# Then you output a string like this:
def grid_index(grid, indexes):
    l = [i for j in grid for i in j]
    return ''.join(l[i - 1] for i in indexes)

# You've been collecting change all day, and it's starting to pile up in your pocket, but
# you're too lazy to see how much you've found.
# Good thing you can code!
# Create change_count() to return a dollar amount of how much change you have!
# Valid types of change include:
# These amounts are already preloaded as floats into the CHANGE dictionary for you to use!
# You should return the total in the format $x.xx.
# Examples:
def change_count(s):
    return f"${sum(CHANGE[i] for i in s.split()):.2f}"

# Write a regex to validate a 24 hours time string. See examples to figure out what you should check for:
# Accepted: 01:00 - 1:00
# Not accepted:
# 24:00
# You should check for correct length and no spaces.
import re
def validate_time(timestamp):
    return bool(re.match(r'(2[0-3]|[01]?\d):[0-5]\d$', timestamp))

# Implement a function which filters out array values which satisfy the given predicate.
def reject(seq, predicate):
    return [item for item in seq if not predicate(item)]

# Not considering number 1, the integer 153 is the first integer having this property: the
# sum of the third-power of each of its digits is equal
# to 153. Take a look: 153 = 1³ + 5³ + 3³ = 1 + 125 + 27 = 153
# The next number that experiments this particular behaviour is 370 with the same power.
# Write the function eq_sum_powdig(), that finds the numbers below a given upper
# limit hMax (inclusive) that fulfills this property but with different exponents as the power for the digits.
# eq_sum_powdig(hMax, exp): ----> sequence of numbers (sorted list) (Number one should not be considered).
def eq_sum_powdig(hMax, exp):
    return [i for i in range(2, hMax + 1) if sum(int(j) ** exp for j in str(i)) == i]

# Write a function that adds from two invocations.
# All inputs will be integers.
def add(a):
    return lambda x: x + a

# Given a number N, can you fabricate the two numbers NE and NO such that NE is formed by even digits
# of N and NO is formed by odd digits of N? Examples:
# input	NE	NO
# 126453	264	153
# 3012	2	31
# 4628	4628	0
# 0 is considered as an even number.
# In C and JavaScript you should return an array of two elements such as the first is NE and the second is NO.
def even_and_odd(n):
    even = ''.join(str(i) for i in str(n) if int(i) % 2 == 0)
    odd = ''.join(str(i) for i in str(n) if int(i) % 2 != 0)
    return (int(even) if even else 0, int(odd) if odd else 0)

# Write a function that will take a key of X and place it in the middle of Y repeated N times.
# Extra challege (not tested): You can complete this with under 70
# characters without using regex. Challenge yourself to do this. It wont be best practices but it will work.
# Rules:
# If X cannot be placed in the middle, return X.
# N will always be > 0.
def middle_me(N, X, Y):
    if N % 2 == 1:
        return X
    return Y * (N // 2) + X + Y * (N // 2)

# In this kata you will be given a sequence of the dimensions
# of rectangles ( sequence with width and length ) and circles ( radius - just a number ).
# Your task is to return a new sequence of dimensions, sorted ascending by area.
def sort_by_area(seq):
    def func(x):
        if isinstance(x, tuple):
            return x[0] * x[1]
        return 3.14 * x * x
    return sorted(seq, key=func)

# Principal Diagonal -- The principal diagonal in a matrix identifies those elements of the
# matrix running from North-West to South-East.
# Secondary Diagonal -- the secondary diagonal of a matrix identifies those elements of the matrix
# running from North-East to South-West.
# For example:
# matrix:             [1, 2, 3]
#                     [4, 5, 6]
#                     [7, 8, 9]
# principal diagonal: [1, 5, 9]
# secondary diagonal: [3, 5, 7]
# Task
# Your task is to find which diagonal is "larger": which diagonal has a bigger sum of their elements.
# If the principal diagonal is larger, return "Principal Diagonal win!"
# If the secondary diagonal is larger, return "Secondary Diagonal win!"
# If they are equal, return "Draw!"
# Note: You will always receive matrices of the same dimension.
def diagonal(m):
    principal  = sum(v[k] for k, v in enumerate(m))
    secondary  = sum(v[-k] for k, v in enumerate(m, 1))
    if principal  > secondary : return 'Principal Diagonal win!'
    if secondary  > principal : return 'Secondary Diagonal win!'
    return 'Draw!'

# For a given 2D vector described by cartesian coordinates of its initial point and
# terminal point in the following format:
# [[x1, y1], [x2, y2]]
# Your function must return the vector's length represented as a floating point number.
# Error must be within 1e-7.
# Coordinates can be integers or floating point numbers.
import math
def vector_length(v):
    return math.sqrt(math.pow(v[0][0] - v[1][0], 2) + math.pow(v[0][1] - v[1][1], 2))

# Check if it is a vowel(a, e, i, o, u,) on the n position in a string
# (the first argument). Don't forget about uppercase.
# A few cases:
# {
# checkVowel('cat', 1)  ->   true // 'a' is a vowel
# checkVowel('cat', 0)  ->   false // 'c' is not a vowel
# checkVowel('cat', 4)  ->   false // this position doesn't exist
# }
# P.S. If n < 0, return false
def check_vowel(string, position):
    return string[position].lower() in 'aeoiu' if position >= 0 and position <= len(string) else False

# Update the solution method to round the argument value to the closest
# precision of two. The argument will always be a float.
def solution(n):
    return round(n, 2)

# You get a new job working for Eggman Movers. Your first task is to write a method that
# will allow the admin staff to enter a person’s name and return what that person's role is in the company.
# You will be given an array of object literals holding the current employees of the company.
# You code must find the employee with the matching firstName and lastName and then return the
# role for that employee or if no employee is not found it should return "Does not work here!"
# The array is preloaded and can be referenced using the variable employees ($employees in Ruby). It uses the
# following structure.
def find_employees_role(name):
    for i in employees:
        if len(name.split()) > 1:
            if name.split()[0] == i['first_name']:
                if name.split()[1] == i['last_name']:
                    return i['role']
        elif len(name.split()) == 0:
            if name.split()[0] == i['first_name']:
                return i['role']
    return 'Does not work here!'

# Linked Lists - Append
# Write an Append() function which appends one linked list to another. The head of the
# resulting list should be returned.
# var listA = 1 -> 2 -> 3 -> null
# var listB = 4 -> 5 -> 6 -> null
# append(listA, listB) === 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> null
# If both listA and listB are null/NULL/None/nil, return null/NULL/None/nil. If one list is null/NULL/None/nil
# and the other is not, simply return the non-null/NULL/None/nil list.
# The push() and buildOneTwoThree() (build_one_two_three() in PHP and ruby) functions need not be
# redefined. The Node class is also predefined for you in PHP.
class Node(object):
    def __init__(self, data):
        self.data = data
        self.next = None
def last(head):
    n = head
    while n and n.next:
    	n = n.next
    return n
def append(listA, listB):
    if not listA:
    	return listB
    last(listA).next = listB
    return listA

# Sam has opened a new sushi train restaurant - a restaurant where sushi is served on
# plates that travel around the bar on a conveyor belt and customers take the plate that they like.
# Sam is using Glamazon's new visual recognition technology that allows
# a computer to record the number of plates at a customer's table and the colour
# of those plates. The number of plates is returned as a string. For example,
# if a customer has eaten 3 plates of sushi on a red plate the computer will return the string "rrr".
# Currently, Sam is only serving sushi on red plates as he's trying to attract customers
# to his restaurant. There are also small plates on the conveyor belt for condiments such as
# ginger and wasabi - the computer notes these in the string that is returned
# as a space; e.g. "rrr r" denotes 4 plates of red sushi and a plate of condiment.
# Sam would like your help to write a program for the cashier's machine to
# read the string and return the total amount a customer has to pay when they ask
# for the bill. The current price for the dishes are as follows:
# Red plates of sushi: $2 each - but every 5th one is free!
# Condiments: free
def total_bill(s):
    return s.count('r') * 2 if s.count('r') < 5 else (s.count('r') - (s.count('r')//5)) * 2

# You'll be passed an array of objects (list) - you must sort them in
# descending order based on the value of the specified property (sortBy).
def sort_list(sort_key, l):
    return sorted(l, key=lambda x: x[sort_key], reverse=True)

# How sexy is your name? Write a program that calculates how sexy one's name is according to the criteria below.
# There is a preloaded dictionary of letter scores called SCORES(Python & JavaScript) / $SCORES (Ruby).
# Add up the letters (case-insensitive) in your name to get your sexy score. Ignore other characters.
#     SCORES = {'A': 100, 'B': 14, 'C': 9, 'D': 28, 'E': 145, 'F': 12, 'G': 3,
#               'H': 10, 'I': 200, 'J': 100, 'K': 114, 'L': 100, 'M': 25,
#               'N': 450, 'O': 80, 'P': 2, 'Q': 12, 'R': 400, 'S': 113, 'T': 405,
#               'U': 11, 'V': 10, 'W': 10, 'X': 3, 'Y': 210, 'Z': 23}
# The program must return how sexy one's name is according to the "Sexy score ranking" chart.
def sexy_name(name):
    s = sum(SCORES[i.upper()] for i in name.replace(' ', ''))
    return 'THE ULTIMATE SEXIEST' if s >=600 else 'VERY SEXY' if 301 <= s <= 599 else 'PRETTY SEXY' if 61 <= s <= 300 else 'NOT TOO SEXY'

# A wealthy client has forgotten the password to his business website, but he has a list of
# possible passwords. His previous developer has left a file on the server with the name password.txt.
# You open the file and realize it's in binary format.
# Write a script that takes an array of possible passwords and a string
# of binary representing the possible password. Convert the binary to a string and compare to
# the password array. If the password is found, return the password string, else return false;
def decode_pass(pass_list, bits):
    pas = "".join(chr(int(x, 2)) for x in bits.split())
    return pas if pas in pass_list else False

# In this kata, you will write an arithmetic list which is basically a list that contains consecutive
# terms in the sequence.
# You will be given three parameters :
# first the first term in the sequence
# c the constant that you are going to ADD ( since it is an arithmetic sequence...)
# l the number of terms that should be returned
# Useful link: Sequence
# Be sure to check out my Arithmetic sequence Kata first ;)
# Don't forget about the indexing pitfall ;)
def seqlist(first,c,l):
    return list(range(first,first+l*c,c))

# An abundant number or excessive number is a number for which the sum of its proper divisors is greater than
# the number itself.
# The integer 12 is the first abundant number. Its proper divisors are 1, 2, 3, 4 and 6 for a total of 16 (> 12).
# Derive function abundantNumber(num)/abundant_number(num) which returns true/True/.true.
# if num is abundant, false/False/.false. if not.
def abundant_number(num):
    return sum([i for i in range(1, num) if num % i == 0]) > num

# I'm afraid you're in a rather unfortunate situation. You've injured your leg, and are
# unable to walk, and a number of zombies are shuffling towards you, intent on eating your
# brains. Luckily, you're a crack shot, and have your trusty rifle to hand.
# The zombies start at range metres, and move at 0.5 metres per second. Each second,
# you first shoot one zombie, and then the remaining zombies shamble forwards another 0.5 metres.
# If any zombies manage to get to 0 metres, you get eaten. If you run out of ammo
# before shooting all the zombies, you'll also get eaten. To keep things simple, we
# can ignore any time spent reloading.
# Write a function that accepts the total number of zombies, a range in metres, and
# the number of bullets you have.
# If you shoot all the zombies, return "You shot all X zombies." If you get
# eaten before killing all the zombies, and before running out of ammo, return
# "You shot X zombies before being eaten: overwhelmed." If you run out of ammo
# before shooting all the zombies, return "You shot X zombies before being eaten: ran out of ammo."
# (If you run out of ammo at the same time as the remaining zombies reach you, return
# "You shot X zombies before being eaten: overwhelmed.".)
# Good luck! (I think you're going to need it.)
def zombie_shootout(z, r, a):
    count = min(r * 2, a)
    return f"You shot all {z} zombies." if count >= z else f"You shot {count} zombies before being eaten: { 'overwhelmed' if count == 2 * r else 'ran out of ammo'}."

# Task
# Your challenge is to write a function named getSlope/get_slope/GetSlope that calculates the slope
# of the line through two points.
# Input
# Each point that the function takes in is an array 2 elements long. The first number
# is the x coordinate and the second number is the y coordinate. If the line through the
# two points is vertical or if the same point is given twice, the function should return null/None.
def getSlope(p1, p2):
    return None if p1[0] == p2[0] else (p2[1] - p1[1]) / (p2[0] - p1[0])

# Usually when you buy something, you're asked whether your credit card number, phone
# number or answer to your most secret question is still correct. However, since someone could look over
# your shoulder, you don't want that shown on your screen. Instead, we mask it.
# Your task is to write a function maskify, which changes all but the last four characters into '#'.
def maskify(cc):
    return '#'*len(cc[:-4])+cc[-4:] if len(cc) > 4 else cc

# Create a function named divisors/Divisors that takes an integer n > 1 and returns an array with
# all of the integer's divisors(except for 1 and the number itself), from smallest
# to largest. If the number is prime return the string '(integer) is prime' (null in C#)
# (use Either String a in Haskell and Result<Vec<u32>, String> in Rust).
def divisors(integer):
    l =  [i for i in range(2, integer) if integer % i == 0]
    return l if l else f"{integer} is prime"

# Don't give me five!
# In this kata you get the start number and the end number of a region and should
# return the count of all numbers except numbers with a 5 in it. The start and the end number are both inclusive!
# Examples:
# 1,9 -> 1,2,3,4,6,7,8,9 -> Result 8
# 4,17 -> 4,6,7,8,9,10,11,12,13,14,16,17 -> Result 12
# The result may contain fives. ;-)
# The start number will always be smaller than the end number. Both numbers can be also negative!
# I'm very curious for your solutions and the way you solve it. Maybe someone
# of you will find an easy pure mathematics solution.
# Have fun coding it and please don't forget to vote and rank this kata! :-)
# I have also created other katas. Take a look if you enjoyed this kata!
def dont_give_me_five(start, end):
    return sum('5' not in str(i) for i in range(start, end + 1))

# The two oldest ages function/method needs to be completed. It
# should take an array of numbers as its argument and return the two highest numbers
# within the array. The returned value should be an array in the format [second oldest age,  oldest age].
# The order of the numbers passed in could be any order.
# The array will always include at least 2 items. If there are two or
# more oldest age, then return both of them in array format.
def two_oldest_ages(ages):
    return sorted(ages)[-2:]

# Given a Divisor and a Bound , Find the largest integer N , Such That ,
# Conditions :
# N is divisible by divisor
# N is less than or equal to bound
# N is greater than 0.
# Notes
# The parameters (divisor, bound) passed to the function are only positive values .
# It's guaranteed that a divisor is Found
def max_multiple(divisor, bound):
    return max(i for i in range(bound + 1) if i % divisor == 0)

# Your task is to remove all duplicate words from a string, leaving only single (first) words entries.
# Example:
# Input:
# 'alpha beta beta gamma gamma gamma delta alpha beta beta gamma gamma gamma delta'
# Output:
# 'alpha beta gamma delta'
def remove_duplicate_words(s):
    l = []
    for word in s.split():
        if word not in l:
            l.append(word)
    return ' '.join(l)

# Are the numbers in order?
# In this Kata, your function receives an array of integers as input. Your task
# is to determine whether the numbers are in ascending order. An array is said to
# be in ascending order if there are no two adjacent integers where the left
# integer exceeds the right integer in value.
# For the purposes of this Kata, you may assume that all inputs are valid, i.e. arrays containing only integers.
# Note that an array of 0 or 1 integer(s) is automatically considered to be
# sorted in ascending order since all (zero) adjacent pairs of integers satisfy the
# condition that the left integer does not exceed the right integer in value.
# For example:
def in_asc_order(arr):
    return arr == sorted(arr)

# You will be given an array of objects (hashes in ruby) representing data about
# developers who have signed up to attend the coding meetup that you are organising for the first time.
# Your task is to return the number of JavaScript developers coming from Europe.
def count_developers(lst):
    return sum(1 for i in lst if i["continent"] == 'Europe' and i["language"] == 'JavaScript')

# Given a number, write a function to output its reverse digits. (e.g. given 123 the answer is 321)
# Numbers should preserve their sign; i.e. a negative number should still be negative when reversed.
def reverseNumber(n):
    return int(str(abs(n))[::-1]) * (-1 if n < 0 else 1)

# Write a program to determine if a string contains only unique characters. Return true if it does and false
# otherwise.
# The string may contain any of the 128 ASCII characters. Characters are case-sensitive,
# e.g. 'a' and 'A' are considered different characters.
def has_unique_chars(string):
    return all(string.count(i) == 1 for i in string)

# Your task is to split the chocolate bar of given dimension n x m into small squares. Each square is of
# size 1x1 and unbreakable. Implement a function that will return minimum number of breaks needed.
# For example if you are given a chocolate bar of size 2 x 1 you can split
# it to single squares in just one break, but for size 3 x 1 you must do two breaks.
# If input data is invalid you should return 0 (as in no breaks are needed if
# we do not have any chocolate to split). Input will always be a non-negative integer.
def break_chocolate(n, m):
    return (n * m) - 1 if n or m else 0

# Return an array containing the numbers from 1 to N, where N is the parametered value.
# Replace certain values however if any of the following conditions are met:
# If the value is a multiple of 3: use the value "Fizz" instead
# If the value is a multiple of 5: use the value "Buzz" instead
# If the value is a multiple of 3 & 5: use the value "FizzBuzz" instead
# N will never be less than 1.
# Method calling example:
def fizzbuzz(n):
    l = []
    for i in range (1, n + 1):
        if i % 3 == 0 and i % 5 == 0:
            l.append("FizzBuzz")
        elif i % 3 == 0:
            l.append("Fizz")
        elif i % 5 == 0:
            l.append("Buzz")
        else:
            l.append(i)
    return l

# Number is a palindrome if it is equal to the number with digits in reversed order. For example,
# 5, 44, 171, 4884 are palindromes, and 43, 194, 4773 are not.
# Write a function which takes a positive integer and returns the number
# of special steps needed to obtain a palindrome. The special step is: "reverse the digits,
# and add to the original number". If the resulting number is not a palindrome, repeat the procedure with the sum
# until the resulting number is a palindrome.
# If the input number is already a palindrome, the number of steps is 0.
# All inputs are guaranteed to have a final palindrome smaller than 263 2^632 6 3.
def palindrome_chain_length(n):
    c = 0
    while str(n) != str(n)[::-1]:
        c += 1
        n = n + int(str(n)[::-1])
    return c

# Task
# Given a positive integer n, calculate the following sum:
# n + n/2 + n/4 + n/8 + ...
# All elements of the sum are the results of integer division.
def halving_sum(n):
    c = 0
    while n > 0:
        c += n
        n = n // 2
    return c

# You are the greatest chef on earth. No one boils eggs like you! Your restaurant is
# always full of guests, who love your boiled eggs. But when there is a greater order
# of boiled eggs, you need some time, because you have only one pot for your job. How much time do you need?
# Your Task
# Implement a function, which takes a non-negative integer, representing the number of eggs
# to boil. It must return the time in minutes (integer), which it takes to have all the eggs boiled.
# Rules
# you can put at most 8 eggs into the pot at once
# it takes 5 minutes to boil an egg
# we assume, that the water is boiling all the time (no time to heat up)
# for simplicity we also don't consider the time it takes to put eggs into the pot or get them out of it
def cooking_time(eggs):
    c = 0
    while eggs > 0:
        c += 1
        eggs -= 8
    return c * 5

# An ordered sequence of numbers from 1 to N is given. One number might have deleted from
# it, then the remaining numbers were mixed. Find the number that was deleted.
# Example:
# The starting array sequence is [1,2,3,4,5,6,7,8,9]
# The mixed array with one deleted number is [3,2,4,6,7,8,1,9]
# Your function should return the int 5.
# If no number was deleted from the starting array, your function should return the int 0.
# Note: N may be 1 or less (in the latter case, the first array will be []).
def find_deleted_number(arr, mixed_arr):
    return sum(arr) - sum(mixed_arr)

# In this kata you should simply determine, whether a given year is a leap year or not.
# In case you don't know the rules, here they are:
# years divisible by 4 are leap years
# but years divisible by 100 are not leap years
# but years divisible by 400 are leap years
# Additional Notes:
# Only valid years (positive integers) will be tested, so you don't have to validate them
# Examples can be found in the test fixture.
import calendar
def isLeapYear(year):
    return calendar.isleap(year)

# Complete the function that takes a sequence of numbers as
# single parameter. Your function must return the sum of the even values of this sequence.
# Only numbers without decimals like 4 or 4.0 can be even.
# The input is a sequence of numbers: integers and/or floats.
def sum_even_numbers(seq):
    return sum(i for i in seq if i % 2 == 0)

# In this Kata, you will be given an array of numbers in which two numbers occur once and the rest occur
# only twice. Your task will be to return the sum of the numbers that occur only once.
# For example, repeats([4,5,7,5,4,8]) = 15 because only the numbers 7
# and 8 occur once, and their sum is 15. Every other number occurs twice.
# More examples in the test cases.
def repeats(arr):
    return sum(i for i in arr if arr.count(i) == 1)

#Get the averages of these numbers
# Write a method, that gets an array of integer-numbers and return an
# array of the averages of each integer-number and his follower, if there is one.
# Example:
def averages(arr):
    return [(arr[x] + arr[x + 1]) / 2 for x in range(len(arr or []) - 1)]

# Debug   function getSumOfDigits that takes positive integer to calculate sum of its digits.
# Assume that argument is an integer.
def get_sum_of_digits(num):
    return sum(int(i) for i in str(num))

# Given a number return the closest number to it that is divisible by 10.
def closest_multiple_10(i):
    return int(round(i, -1))

# You will be given an array of objects (associative arrays in PHP, tables in COBOL) representing
# data about developers who have signed up to attend the next coding meetup that you are organising.
# Your task is to return either:
# true if all developers in the list code in the same language; or
# false otherwise.
# For example, given the following input array:
def is_same_language(lst):
    return len(set(i['language'] for i in lst)) == 1

# In this Kata, you will be given a string that has lowercase letters and numbers. Your task is
# to compare the number groupings and return the largest number. Numbers will not have leading zeros.
# For example, solve("gh12cdy695m1") = 695, because this is the largest of all number groupings.
# Good luck!
def solve(s):
    l = ''.join(' ' if i.isalpha() else i for i in s)
    return max(int(i) for i in l.split())

# Given a non-negative integer, return an array / a list of the individual digits in order.
def digitize(n):
    return [int(i) for i in str(n)]

# You will be given a sequence of objects representing data about developers who have signed up to
# attend the next coding meetup that you are organising.
# Given the following input array:
# write a function that returns the average age of developers (rounded to the nearest integer).
# In the example above your function should return 50 (number).
# Notes:
# The input array will always be valid and formatted as in the example above.
# Age is represented by a number which can be any positive integer.
def get_average(lst):
    return round(sum(i['age'] for i in lst) / len(lst))

# You are provided with an array of positive integers and an additional integer n (n > 1).
# Calculate the sum of each value in the array to the nth power. Then subtract the sum of the original array.
def modified_sum(a, n):
    return sum(i**n for i in a) - sum(a)

# This question is a variation on the Arithmetic Progression kata
# The following was a question that I received during a technical interview for an entry level software
# developer position. I thought I'd post it here so that everyone could give it a go:
# You are given an unsorted array containing all the integers from 0 to 100 inclusively. However, one number is
# missing. Write a function to find and return this number. What are the
# time and space complexities of your solution?
def missing_no(nums):
    return sum(range(101)) - sum(nums)

# You are given an array of n+1 integers 1 through n. In addition there is a single duplicate integer.
# The array is unsorted.
# An example valid array would be [3, 2, 5, 1, 3, 4].
# It has the integers 1 through 5 and 3 is duplicated. [1, 2, 4, 5, 5] would not be valid as it is missing 3.
# You should return the duplicate value as a single integer.
def find_dup(arr):
    return sum(arr) - sum(set(arr))

# Program a function sumAverage(arr) where arr is an array containing arrays full of numbers, for example:
# sum_average([[1, 2, 2, 1], [2, 2, 2, 1]]);
# First, determine the average of each array. Then, return the sum of all the averages.
# All numbers will be less than 100 and greater than -100.
# arr will contain a maximum of 50 arrays.
# After calculating all the averages, add them all together, then round down, as shown in the example below:
# The example given: sumAverage([[3, 4, 1, 3, 5, 1, 4], [21, 54, 33, 21, 77]]), the answer being 44.
from statistics import mean
from math import floor
def sum_average(arr):
    return floor(sum(mean(i) for i in arr))

# Should be easy, begin by looking at the code. Debug the code and the functions should work.
# There are three functions: Multiplication (x) Addition (+) and Reverse (!esreveR)
import math
def multi(l_st):
    return math.prod(l_st)
def add(l_st):
    return sum(l_st)
def reverse(string):
    return string[::-1]

# Given an array of numbers, return the difference between the largest and smallest values.
def between_extremes(numbers):
    return max(numbers) - min(numbers)

# Given a long number, return all the possible sum of two digits of it.
# For example, 12345: all possible sum of two digits from that number are:
from itertools import combinations
def digits(num):
    return list(map(sum, combinations(map(int,str(num)),2)))

# Given a positive integer N, return the largest integer k such that 3^k < N.
def largest_power(N):
    c = 0
    while 3**c < N:
        c += 1
    return c - 1

# Given a mathematical equation that has *,+,-,/, reverse it as follows:
import re
def solve(eq):
    return ''.join(reversed(re.split(r'(\W+)', eq)))

# In this Kata, you will be given a string and two indexes (a and b). Your task is
# to reverse the portion of that string between those two indices inclusive.
def solve(s,a,b):
    return s[:a] + s[a:b+1][::-1] + s[b+1:]

# How many button presses on my remote are required to type a given word?
# Notes
# The cursor always starts on the letter a (top left)
# Remember to also press OK to "accept" each character.
# Take a direct route from one character to the next
# The cursor does not wrap (e.g. you cannot leave one edge and reappear on the opposite edge)
# A "word" (for the purpose of this Kata) is any sequence of characters available on my virtual "keyboard"
def tv_remote(word):
    pp = 0
    res = 0
    r = 'abcde123fghij456klmno789pqrst.@0uvwxyz_/'
    for i in word:
        p = r.find(i)
        res += abs(p//8-pp//8) + abs(p%8-pp%8) + 1
        pp = p
    return res

# No Story
# No Description
# Only by Thinking and Testing
# Look at result of testcase, guess the code!
def testit(a, b):
    return sorted(list(set(a)) + list(set(b)))

# The trick to counting kookaburras is to listen carefully
# The males sound like HaHaHa...
# The females sound like hahaha...
# And they always alternate male/female
import re
def kooka_counter(laughing):
    return len(re.findall(r'(ha)+|(Ha)+',laughing))

# You are going to be given a string. Your job is to return
# that string in a certain order that I will explain below:
# Let's say you start with this: 012345
# The first thing you do is reverse it:543210
# Then you will take the string from the 1st position and reverse it again:501234
# Then you will take the string from the 2nd position and reverse it again:504321
# Then you will take the string from the 3rd position and reverse it again:504123
# Continue this pattern until you have done every single position, and then you will return the string
# you have created. For this particular number, you would return:504132
#Input: A string of length 1 - 1000
#Output: A correctly reordered string.
def reverse_fun(n):
    for i in range(len(n)):
        n = n[:i] + n[i:][::-1]
    return n

# Given two arrays of strings, return the number of times each
# string of the second array appears in the first array.
# Example
# array1 = ['abc', 'abc', 'xyz', 'cde', 'uvw']
# array2 = ['abc', 'cde', 'uap']
# How many times do the elements in array2 appear in array1?
# 'abc' appears twice in the first array (2)
# 'cde' appears only once (1)
# 'uap' does not appear in the first array (0)
# Therefore, solve(array1, array2) = [2, 1, 0]
def solve(a,b):
    return [a.count(i) for i in b]

# A boy is walking a long way from school to his home. To make the walk more
# fun he decides to add up all the numbers of the houses that he passes by during his walk. Unfortunately,
# not all of the houses have numbers written on them, and on top of that the boy
# is regularly taking turns to change streets, so the numbers don't appear to him in any particular order.
# At some point during the walk the boy encounters a house with number 0 written on it,
# which surprises him so much that he stops adding numbers to his total right after seeing that house.
# For the given sequence of houses determine the sum that the boy will get. It is guaranteed that
# there will always be at least one 0 house on the path.
def house_numbers_sum(inp):
    return sum(inp[:inp.index(0)])

# You have to write a function pattern which returns the following Pattern
# (See Pattern & Examples) upto n number of rows.
# Note:Returning the pattern is not the same as Printing the pattern.
# Rules/Note:
# If n < 1 then it should return "" i.e. empty string.
# There are no whitespaces in the pattern.
def pattern(n):
    return '\n'.join(f"{i}"*i for i in range(1, n+1))

# You are given a dictionary/hash/object containing some languages and your test results in
# the given languages. Return the list of languages where your test score is at least 60, in
# descending order of the scores.
# Note: the scores will always be unique (so no duplicate values)
def my_languages(results):
    return sorted((k for k,v in results.items() if v >= 60), reverse=True, key=results.get)

# The code provided is supposed return a person's Full Name given their first and last names.
# But it's not working properly.
# Notes
# The first and/or last names are never null, but may be empty.
# Task
# Fix the bug so we can all go home early.
class Dinglemouse(object):
    def __init__(self, first_name, last_name):
        self.first_name = first_name
        self.last_name = last_name
    def get_full_name(self):
        return (self.first_name + ' ' + self.last_name).strip()

# You will be given an array of objects (associative arrays in PHP)
# representing data about developers who have signed up to attend the next
# coding meetup that you are organising. The list is ordered according to who signed up first.
# Your task is to return one of the following strings:
# < firstName here >, < country here > of the first Python developer who has signed up; or
# There will be no Python developers if no Python developer has signed up.
def get_first_python(users):
    for user in users:
        if user['language'] == 'Python':
            return f'{user["first_name"]}, {user["country"]}'
    return 'There will be no Python developers'

# An arrow is formed in a rectangle with sides a and b by joining
# the bottom corners to the midpoint of the top edge and the centre of the rectangle.
def arrow_area(a, b):
    return a * b / 4

# Debug a function called calculate that takes 3 values. The first and
# third values are numbers. The second value is a character. If
# the character is "+" , "-", "*", or "/", the function will return the result
# of the corresponding mathematical function on the two numbers. If the string is
# not one of the specified characters, the function should return null.
def calculate(a, o, b):
    if o == "+":
        return a + b
    elif o == "-":
        return a - b
    elif o == "/" and b != 0:
        return a / b
    elif o == "*":
        return a * b
    return None

# The first three stages of a sequence are shown.
# blocks
# The blocksize is a by a and a ≥ 1.
# What is the perimeter of the nth shape in the sequence (n ≥ 1) ?
def perimeter_sequence(a, n):
    return 4 * n * a

# elow we will define what and n-interesting polygon is and your task is to find its area for a given n.
# A 1-interesting polygon is just a square with a side of length 1. An n-interesting polygon is obtained
# by taking the n - 1-interesting polygon and appending 1-interesting polygons
# to its rim side by side. You can see the 1-, 2- and 3-interesting polygons in the picture below.
def shape_area(n):
    return n**2 + (n - 1) ** 2

# You have to search all numbers from inclusive 1 to inclusive a given number x, that
# have the given digit d in it.
# The value of d will always be 0 - 9.
# The value of x will always be greater than 0.
# You have to return as an array
# the count of these numbers,
# their sum
# and their product.
import math
def numbers_with_digit_inside(x, d):
    l = [i for i in range(1, x+1) if str(d) in str(i)]
    return [len(l), sum(l), math.prod(l)] if l else [0, 0, 0]

# You have to write a function pattern which returns the following Pattern
# (See Pattern & Examples) upto n number of rows.
# Note: Returning the pattern is not the same as Printing the pattern.
# Rules/Note:
# If n < 1 then it should return "" i.e. empty string.
# There are no whitespaces in the pattern.
def pattern(n):
    return('\n'.join(''.join(str(i) for i in range(n,j,-1)) for j in range(n)))

# Determine the area of the largest square that can fit inside a circle with radius r.
def area_largest_square(r):
    return 2 * r**2

# Triangular numbers are so called because of the
# equilateral triangular shape that they occupy when laid out as dots. i.e.
def triangular(n):
    return n * (n + 1) // 2 if n > 0 else 0

# You will be given an array of objects (associative arrays in PHP, tables in COBOL) representing data
# about developers who have signed up to attend the next coding meetup that you are organising.
# Your task is to return an array where each object will have a new property
# 'greeting' with the following string value:
# Hi < firstName here >, what do you like the most about < language here >?
# For example, given the following input array:
def greet_developers(lst):
    for x in lst:
        x["greeting"] = f"Hi {x['firstName']}, what do you like the most about {x['language']}?"
    return lst

# Find the greatest common divisor of two positive integers. The integers
# can be large, so you need to find a clever solution.
# The inputs x and y are always greater or equal to 1,
# so the greatest common divisor will always be an integer that is also greater or equal to 1.
import math
def mygcd(x, y):
    return math.gcd(x, y)

# Consider integer numbers from 0 to n - 1 written down along the
# circle in such a way that the distance between any two neighbouring
# numbers is equal (note that 0 and n - 1 are neighbouring, too).
# Given n and firstNumber/first_number/first-number, find the number which is written
# in the radially opposite position to firstNumber.
def circle_of_numbers(n, fst):
    return (fst + (n / 2)) % n

# In this kata the function returns an array/list of numbers without its last element.
# The function is already written for you and the basic tests pass, but random tests fail. Your
# task is to figure out why and fix it.
# Good luck!
# Hint: watch out for side effects.
def without_last(lst):
    return lst[:-1]

# In this kata you will create a function to check a non-negative input to see if it is a prime number.
# The function will take in a number and will return True if it is a prime number and False if it is not.
# A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.
def is_prime(n):
    return pow(2, n - 1, n) == 1 if n > 2 else n == 2

# Oh no, Timmy's Sort doesn't seem to be working? Your task is to fix
# the sortArray function to sort all numbers in ascending order
def sort_array(value):
    return "".join(sorted(value,key=lambda a: int(a)))

# The Arara are an isolated tribe found in the Amazon who count in pairs.
# For example one to eight is as follows:
# Take a given number and return the Arara's equivalent.
def count_arara(n):
    return ('adak ' * (n // 2) + 'anane' * (n % 2)).strip()

# No Story
# No Description
# Only by Thinking and Testing
# Look at result of testcase, guess the code!
def testit(s):
    return ' '.join([i[:-1].lower() + i[-1].upper() for i in s.split()])

# You are given a sequence of positive ints where every element appears three times, except one that appears only once
# (let's call it x) and one that appears only twice (let's call it y).
# Your task is to find x * x * y.
import math
def missing_values(seq):
    return math.prod([i**2 for i in seq if seq.count(i)==1]) * [i for i in seq if seq.count(i)==2][0]

# In this Kata, you will write a function doubles that will remove double string characters that
# are adjacent to each other.
# For example:
# doubles('abbcccdddda') = 'aca', because, from left to right:
def doubles(s):
    for char in s:
        if char * 2 in s:
            s = s.replace(char * 2, '')
    return s

# Given two integer arrays where the second array is a shuffled duplicate of
# the first array with one element missing, find the missing element.
# Please note, there may be duplicates in the arrays, so checking if a
# numerical value exists in one and not the other is not a valid solution.
def find_missing(arr1, arr2):
    return sum(arr1) - sum(arr2)

# Your task is to write a function, which takes two arguments and returns a sequence. First argument is
# a sequence of values, second is multiplier. The function should filter all
# non-numeric values and multiply the rest by given multiplier.
def multiply_and_filter(seq, multiplier):
    return [i * multiplier for i in seq if type(i) == int or type(i) == float]

# Agent 47, you have a new task! Among citizens of the city
# X are hidden 2 dangerous criminal twins. Your task is to identify them and eliminate!
# Given an array of integers, your task is to find
# two same numbers and return one of them, for example in array [2, 3, 6, 34, 7, 8, 2] answer is 2.
# If there are no twins in the city - return None or the equivalent in the language that you are using.
def elimination(arr):
    for x in arr:
        if arr.count(x) == 2:
            return x
        
# Your friend Robbie has successfully created an AI that is capable of communicating in English!
# Robbie's almost done with the project, however the machine's output isn't working as expected.
# Here's a sample of a sentence that it outputs:
# Your function should:
# Capitalise the first letter of the first word.
# Add a period (.) to the end of the sentence.
# Join the words into a complete string, with spaces.
# Do no other manipulation on the words.
def sentencify(words):
    return words[0][0].upper() + ' '.join(words)[1:] + '.'

# Write a method remainder which takes two integer arguments, dividend and divisor, and returns the remainder
# when dividend is divided by divisor. Do NOT use the modulus operator (%) to calculate the remainder!
# Assumption
# Dividend will always be greater than or equal to divisor.
# Notes
# Make sure that the implemented remainder function works exactly the same as the Modulus operator (%).
# divmod has also been disabled.
def remainder(dividend,divisor):
	return dividend - (dividend//divisor) * divisor

# No Story
# No Description
# Only by Thinking and Testing
# Look at result of testcase, guess the code!
def testit(n):
    return bin(n).count('1')

# Groups of characters decided to make a battle. Help them to figure
# out which group is more powerful. Create a function that will accept 2 strings and return the one who's stronger.
# Rules:
# Each character have its own power: A = 1, B = 2, ... Y = 25, Z = 26
# Strings will consist of uppercase letters only
# Only two groups to a fight.
# Group whose total power (A + B + C + ...) is bigger wins.
# If the powers are equal, it's a tie.
def battle(x, y):
    s = [sum([ord(i)-64 for i in x]), sum([ord(i)-64 for i in y])]
    return x if s[0] > s[1] else y if s[1] > s[0] else 'Tie!'

# You need to create a function, helloWorld, that will return the String Hello, World!
# without actually using raw strings. This includes quotes, double quotes and template strings.
# You can, however, use the String constructor and any related functions.
def hello_world():
  return chr(72) + chr(101) + chr(108) + chr(108) + chr(111) + chr(44) + chr(32) + chr(87) + chr(111) + chr(114) + chr(108) + chr(100) + chr(33)

# Complete the function that takes an odd integer (0 < n < 1000000) which
# is the difference between two consecutive perfect squares, and return these squares as
# a string in the format "bigger-smaller"
def find_squares(n):
    i = (n - 1) // 2
    return f'{(i + 1)**2}-{i**2}'

# A cyclops number is a number in binary that is made up of all 1's,
# with one 0 in the exact middle. That means all cyclops
# numbers must have an odd number of digits for there to be an exact middle.
# A couple examples:
# 101
# 11111111011111111
# You must take an input, n, that will be in decimal format (base 10), then return True if that number
# wil be a cyclops number when converted to binary, or False if it won't.
# Assume n will be a positive integer.
def cyclops(n):
    i = bin(n)[2:]
    return i.count("0") == 1 and i == i[::-1]

# A noob programmer was given two simple tasks: sum and sort the elements of
# the given array arr = [a1, a2, ..., an].
# He started with summing and did it easily, but decided to store the sum he found
# in some random position of the original array which was a bad idea. Now he needs
# to cope with the second task, sorting the original array arr, and it's giving him trouble since he modified it.
# Given the array shuffled, consisting of elements a1, a2, ..., an, and
# their sumvalue in random order, return the sorted array of original elements a1, a2, ..., an.
def shuffled_array(l):
    l.pop(l.index(sum(l) / 2))
    return sorted(l)

# Oh no, Timmy's filter doesn't seem to be working? Your task is
# to fix the FilterNumber function to remove all the numbers from the string.
def filter_numbers(string):
    return "".join(x for x in string if not x.isdigit())

# Find the difference between two collections. The difference means that either the character is
# present in one collection or it is present in other, but not in both. Return a sorted list with the difference.
# The collections can contain any character and can contain duplicates.
def diff(a, b):
    return sorted(list(set([i for i in a if i not in b] + [i for i in b if i not in a])))

# You need count how many valleys you will pass.
# Start is always from zero level.
# Every time you go down below 0 level counts as an entry of a valley,
# and as you go up to 0 level from valley counts as an exit of a valley.
# One passed valley is equal one entry and one exit of a valley.
def counting_valleys(s):
    level, valleys = 0, 0
    for step in s:
        if step == 'U' and level == -1:
            valleys += 1
        level += {'U': 1, 'F': 0, 'D': -1}[step]
    return valleys

# Multiply all the digits of a nonnegative integer n by each other, repeating with
# the product until a single digit is obtained. The number of steps
# required is known as the multiplicative persistence.
# Create a function that calculates the individual results of each step, not including the original
# number, but including the single digit, and outputs the result as a list/array.
# If the input is a single digit, return an empty list/array.
from functools import reduce
from operator import mul
def per(n):
    res = []
    while n > 9:
        n = reduce(mul, map(int, str(n)))
        res.append(n)
    return res

# There is a narrow hallway in which people can go right and left only. When two people meet in
# the hallway, by tradition they must salute each other. People move at the same speed left and right.
# Your task is to write a function that, given a string representation
# of people moving in the hallway, will count the number of salutes that will occur.
# Note: 2 salutes occur when people meet, one to the other and vice versa.
# Input
# People moving right will be represented by >; people moving left will be represented
# by <. An example input would be >--<--->->. The - character represents empty space,
# which you need not worry about.
# Examples
def count_salutes(h):
    return sum(2 * sum(j == '<'for j in h[i:]) * (h[i] == '>')for i in range(len(h)))

# Calculate how many times a number can be divided by a given number.
from math import log
def divisions(n, divisor):
    return int(log(n, divisor))

# Get the next prime number!
# You will get a numbern (>= 0) and your task is to find the next prime number.
# Make sure to optimize your code: there will numbers tested up to about 10^12.
from gmpy2 import next_prime

# Write a function that takes an integer and returns an array [A, B, C],
# where A is the number of multiples of 3 (but not 5) below the given
# integer, B is the number of multiples of 5 (but not 3)
# below the given integer and C is the number of multiples of 3 and 5 below the given integer.
# For example, solution(20) should return [5, 2, 1]
def solution(number):
    A, B, C = (number - 1) // 3, (number - 1) // 5, (number - 1) // 15
    return [A - C, B - C, C]

# Your task is to sort an array of integer numbers by the product of the value and the index of the positions.
# For sorting the index starts at 1, NOT at 0!
# The sorting has to be ascending.
# The array will never be null and will always contain numbers.
def sort_by_value_and_index(arr):
    return [i[1] for i in sorted(enumerate(arr), key=lambda x:(x[0] + 1) * x[1])]

# A genetic algorithm is based in groups of chromosomes, called populations.
# To start our population of chromosomes we need to generate random binary strings with a specified length.
# In this kata you have to implement a function generate that receives a length
# and has to return a random binary strign with length characters.
from random import choice
def generate(length):
    return "".join(choice("01") for i in range(length))

# The function takes cents value (int) and needs to return the minimum number of coins combination of the same value.
def coin_combo(cents):
    return [cents % 5, ((cents % 25) % 10) // 5, (cents % 25) // 10, cents // 25]

# Write a program to determine if the two given numbers are
# coprime. A pair of numbers are coprime if their greatest shared factor is 1.
# The inputs will always be two positive integers between 2 and 99.
from math import gcd
def are_coprime(n, m):
    return gcd(n, m) == 1

# In mathematics, an nth root of a number x, where n is usually assumed
# to be a positive integer, is a number r which, when raised to the power n, yields x:
def perfect_roots(n):
    return (((n**.5)**0.5)**0.5) == int((((n**.5)**0.5)**0.5))

# Task:
# You have to create a function isPronic to check whether
# the argument passed is a Pronic Number and return true if it is & false otherwise.
# Description:
# Pronic Number -A pronic number, oblong number, rectangular number or heteromecic number,
# is a number which is the product of two consecutive integers, that is, n(n + 1).
import math
def is_pronic(n):
    return n >= 0 and math.sqrt(1 + 4 * n) % 1 == 0

# You will be given a number and your task is to return the nth fibonacci string. For example:
def solve(n):
    a, b = '0', '01'
    for i in range(n):
        a, b = b, b + a
    return a

# Caomplete the solution so that it returns the greatest sequence of
# five consecutive digits found within the number given.
# The number will be passed in as a string of only digits. It should return a five
# digit integer. The number passed may be as large as 1000 digits.
# Adapted from ProjectEuler.net
def solution(digits):
    return max(int(digits[i:i+5]) for i in range(0,len(digits)-4))

# Your task is to add up letters to one letter.
# The function will be given a variable amount of arguments, each one being a letter to add.
# Notes:
# Letters will always be lowercase.
# Letters can overflow (see second to last example of the description)
# If no letters are given, the function should return 'z'
def add_letters(*letters):
    return chr((sum(ord(c) - 96 for c in letters) - 1) % 26 + 97)
# The following code could use a bit of object-oriented artistry. While it's a simple method
# and works just fine as it is, in a larger system it's best to organize methods
# into classes/objects. (Or, at least, something similar depending on your language)
# Refactor the following code so that it belongs to a Person class/object. Each Person instance
# will have a greet method. The Person instance should be instantiated with a name
# so that it no longer has to be passed into each greet method call.
# Here is how the final refactored code would be used:
class Person:
    def __init__(self, name):
        self.name = name
    def greet(self, other):
        return f"Hello {other}, my name is {self.name}"

# Each day a plant is growing by upSpeed meters. Each night that plant's height decreases
# by downSpeed meters due to the lack of sun heat. Initially, plant is 0 meters tall.
# We plant the seed at the beginning of a day. We want to know when the height of the
# plant will reach a certain level.
from math import ceil
def growing_plant(up, down, h):
    return max(ceil((h - down) / (up - down)), 1)

# If you finish this kata, you can try Insane Coloured Triangles by Bubbler, which is a much
# harder version of this one.
# A coloured triangle is created from a row of colours, each of which is red,
# green or blue. Successive rows, each containing one fewer colour than the last, are generated by
# considering the two touching colours in the previous row. If these colours are identical,
# the same colour is used in the new row. If they are different, the missing colour
# is used in the new row. This is continued until the final row, with only a single colour, is generated.
COLORS = set("RGB")
def triangle(row):
    while len(row)>1:
        row = ''.join( a if a==b else (COLORS-{a,b}).pop() for a,b in zip(row, row[1:]))
    return row

# The following code is not giving the expected results. Can you debug what the issue is?
# The following is an example of data that would be passed in to the function.
def itemgetter(item):
    return item['name']
def get_names(data):
    return list(map(itemgetter,data))

# You will be given an array of objects (associative arrays in PHP) representing data about developers who
# have signed up to attend the next coding meetup that you are organising.
# Your task is to return:
# true if at least one Ruby developer has signed up; or
# false if there will be no Ruby developers.
def is_ruby_coming(lst):
    return any(x["language"] == "Ruby" for x in lst)

# King Arthur and his knights are having a New Years party. Last year Lancelot was jealous of Arthur,
# because Arthur had a date and Lancelot did not, and they started a duel.
# To prevent this from happening again, Arthur wants to make sure that there are at least
# as many women as men at this year's party. He gave you a list of integers of all the party goers.
# Arthur needs you to return true if he needs to invite more women or false if he is all set.
def invite_more_women(arr):
    return sum(arr) > 0

# I assume most of you are familiar with the ancient legend of the rice (but I see wikipedia suggests wheat,
# for some reason) problem, but a quick recap for you: a young man asks as a
# compensation only 1 grain of rice for the first square, 2 grains for the second,
# 4 for the third, 8 for the fourth and so on, always doubling the previous.
# Your task is pretty straightforward (but not necessarily easy): given an amount
# of grains, you need to return up to which square of the chessboard one should count
# in order to get at least as many.
# As usual, a few examples might be way better than thousands of words from me:
def squares_needed(grains):
    return grains.bit_length()

# Your job is to figure out the index of which vowel is missing from a given string:
# A has an index of 0,
# E has an index of 1,
# I has an index of 2,
# O has an index of 3,
# U has an index of 4.
# Notes: There is no need for string validation and every sentence
# given will contain all vowels but one. Also, you won't need to worry about capitals.
def absent_vowel(x):
    return ['aeiou'.index(i) for i in 'aeiou' if i not in x][0]

# No Story
# No Description
# Only by Thinking and Testing
# Look at result of testcase, guess the code!
def testit (a, b):
    return a | b

# The following code was thought to be working properly, however when the code
# tries to access the age of the person instance it fails.
class Person():
    def __init__(self, first_name, last_name, age):
        self.first_name = first_name
        self.last_name = last_name
        self.full_name = f"{first_name} {last_name}"
        self.age = age

# Given a credit card number we can determine who the issuer/vendor is with a few basic knowns.
# Complete the function get_issuer() that will use the values shown below to determine the card
# issuer for a given card number. If the number cannot be matched then the
# function should return the string Unknown.
def get_issuer(number):
    card = str(number)
    nums = len(card)
    if card[:2] in ("34", "37") and nums == 15:return "AMEX"
    elif card[:4] == "6011" and nums == 16:return "Discover"
    elif 51 <= int(card[:2]) <= 55 and nums == 16:return "Mastercard"
    elif card[0] == "4" and nums in (13, 16):return "VISA"
    return "Unknown"

# Your are given a string. You must replace any occurence of the sequence coverage
# by covfefe, however, if you don't find the word coverage in the string,
# you must add covfefe at the end of the string with a leading space.
# For the languages where the string is mutable (such as ruby), don't modify
# the given string, otherwise this will break the test cases.
# STRINGS
def covfefe(s):
    if 'coverage' in s: return s.replace('coverage', 'covfefe')
    return s + ' covfefe'

# Write a function named numbers.
# function should return True if all the parameters it is passed are of the
# integer type or float type. Otherwise, the function should return False.
# The function should accept any number of parameters.
def numbers(*l):
    return all(type(i) in (int, float) for i in l)

# This function should take two string parameters: a person's name (name) and a quote
# of theirs (quote), and return a string attributing the quote to the person in the following format:
def quotable(name, quote):
    return f'{name} said: "{quote}"'

# Beaches are fildh sand, water, fish, and sun. Given a string, calculate how many times the
# words "Sand", "Water", "Fish", and "Sun" appear without overlapping (regardless of the case).
def sum_of_a_beach(beach):
    return sum(beach.lower().count(i) for i in ["sand", "water", "fish", "sun"])

# The number 198 has the property that 198 = 11 + 99 + 88, i.e., if each of its digits is
# concatenated twice and then summed, the result will be the original number. It turns out that 198
# is the only number with this property. However, the property can be generalized so
# that each digit is concatenated n times and then summed.
def check_concatenated_sum(n, r):
    return abs(n) == sum(int(i * r) for i in str(abs(n)) if r)

# Complete the function that counts the number of unique consonants in a string
# (made up of printable ascii characters).
# Consonants are letters used in English other than "a", "e", "i", "o", "u".
# Remember, your function needs to return the number of unique consonants
# - disregarding duplicates. For example, if the string passed into the function reads "add", the
# function should return 1 rather than 2, since "d" is a duplicate.
# Similarly, the function should also disregard duplicate consonants of differing cases. For example,
# "Dad" passed into the function should return 1 as "d" and "D" are duplicates.
def count_consonants(text):
    return len(set(filter(str.isalpha, text.lower())) - set("aeiou"))

# Mrs. Frizzle is beginning to plan lessons for her science class next semester, and
# wants to encourage friendship amongst her students. To accomplish her goal, Mrs.
# Frizzle will ensure each student has a chance to partner with every other student
# in the class in a series of science projects.
# Mrs. Frizzle does not know who will be in her class next semester, but she does know
# she will have n students total in her class.
def projectPartners(n):
    return n * (n - 1) / 2

# You have been employed by the Japanese government to write a function that tests whether or not a
# building is strong enough to withstand a simulated earthquake.
# A building will fall if the magnitude of the earthquake is greater than the strength of the building.
# An earthquake takes the form of a 2D-Array. Each element within the Outer-Array represents a shockwave,
# and each element within the Inner-Arrays represents a tremor.
# The magnitude of the earthquake is determined by the product of the values
# of its shockwaves. A shockwave is equal to the sum of the values of its tremors.
from functools import reduce
def strong_enough(earthquake, age):
    strength = 1000 * 0.99 ** age
    shockwave = reduce(lambda x, y: x*y, [sum(i) for i in earthquake])
    return "Needs Reinforcement!" if strength <= shockwave else "Safe!"

# As part of this Kata, you need to find the length of the sequence in an array,
# between the first and the second occurrence of a specified number.
# For example, for a given array arr
def length_of_sequence(arr, n):
    if arr.count(n) == 2:
        a = arr.index(n)
        b = arr.index(n, a + 1)
        return b - a + 1
    return 0

# Fans of The Wire will appreciate this one. For those that haven't seen the show,
# the Barksdale Organization has a simple method for encoding telephone numbers exchanged via
# pagers: "Jump to the other side of the 5 on the keypad, and swap 5's and 0's."
def decode(s):
    return s.translate(str.maketrans("1234567890", "9876043215"))

# Oh no, Timmy's received some hate mail recently but he knows better. Help Timmy fix his
# regex filter so he can be awesome again!
import re
def filter_words(phrase):
    return re.sub("(bad|mean|ugly|horrible|hideous)","awesome", phrase, flags=re.IGNORECASE)

# This is the simple version of Shortest Code series. If you need some
# challenges, please try the challenge version.
# Task:
# Find out "B"(Bug) in a lot of "A"(Apple).
# There will always be one bug in apple, not need to consider the situation that without bug or more than one bugs.
# input: string Array apple
# output: Location of "B", [x,y]
def sc(apple):
    c = 0
    c1 = 0
    for i in apple:
        if 'B' in i:
            c += i.index('B')
            c1 += apple.index(i)
    return [c1, c]

# Yet another staple for the functional programmer. You have a sequence of values and some predicate for those values.
# You want to remove the longest prefix of elements such that the predicate is true
# for each element. We'll call this the dropWhile function. It accepts two arguments.
# The first is the sequence of values, and the second is the predicate function. The
# function does not change the value of the original sequence.
def drop_while(arr, pred):
    for k,v in enumerate(arr):
        if not pred(v):
            return arr[k:]
    return []

# Validate a given EAN-Code. Return true if the given EAN-Code is valid, otherwise false.
# Assumption
# You can assume the given code is syntactically valid, i.e. it only
# consists of numbers and it exactly has a length of 13 characters.
def validate_ean(code):
    code1 = sum(int(i) for i in code[0::2])
    code = sum(int(i) for i in code[1::2])
    return (code1 + code * 3) % 10 == 0

# YouTube had a like and a dislike button, which allowed users to
# express their opinions about particular content. It was set up in such a way
# that you cannot like and dislike a video at the same time. There are
# two other interesting rules to be noted about the interface: Pressing a button, which
# is already active, will undo your press. If you press the like button after pressing
# the dislike button, the like button overwrites the previous "Dislike" state. The same is
# true for the other way round.
def like_or_dislike(lst):
	choice = 'Nothing'
	for choi in lst:
		choice = 'Nothing' if choi == choice else choi
	return choice

# Create a function which checks a number for three different properties.
# is the number prime?
# is the number even?
# is the number a multiple of 10?
# Each should return either true or false, which should be given as an array.
# Remark: The Haskell variant uses data Property.
def number_property(n):
    is_prime = lambda i: False if i <= 1 else all([1 if n % i != 0 else 0 for i in range(2, int(n ** 0.5 + 1))])
    is_even = lambda x: x%2 == 0
    is_mult_10 = lambda x: x%10 == 0
    return [is_prime(n), is_even(n), is_mult_10(n)]

# Function receive a two-dimensional square array of random integers.
# On the main diagonal, all the negative integers must be changed to 0,
# while the others must be changed to 1 (Note: 0 is considered non-negative, here).
# (You can mutate the input if you want, but it is a better practice to not mutate the input)
def matrix(m):
    return [[v if i != k else int(v >= 0) for k,v in enumerate(r)] for i, r in enumerate(m)]

# Given a number N, determine if the sum of N consecutive numbers is odd or even.
# If the sum is definitely an odd number, return Odd.
# If the sum is definitely an even number, return Even.
# If the sum can be either odd or even ( depending on which first number you choose ), return Either.
def odd_or_even(n):
    return ("Even", "Either", "Odd", "Either")[n % 4]

# Write a function that returns true if a given point (x,y) is inside of a unit
# circle (that is, a "normal" circle with a radius of one) centered at
# the origin (0,0) and returns false if the point is outside.
def point_in_circle(x, y):
    return (x*x + y*y) < 1

# You have managed to intercept an important message and you are trying to read it.
# You realise that the message has been encoded and can be decoded by switching each letter with a corresponding
# letter.
# You also notice that each letter is paired with the letter that it coincides with when the alphabet is reversed.
# For example: "a" is encoded with "z", "b" with "y", "c" with "x", etc
def decode(message):
    return message.translate(str.maketrans('abcdefghijklmnopqrstuvwxyz', 'abcdefghijklmnopqrstuvwxyz'[::-1]))

# A comfortable word is a word which you can type always alternating the hand you
# type with (assuming you type using a QWERTY keyboard and use fingers as shown in the image below).
# That being said, complete the function which receives a word and returns
# true if it's a comfortable word and false otherwise.
# The word will always be a string consisting of only ascii letters from a to z.
def comfortable_word(word):
    left = [c in 'qwertasdfgzxcvb' for c in word[::2]]
    right = [c in 'yuiophjklnm' for c in word[1::2]]
    return bool((all(left) and all(right)) or (not any(left) and not any(right)))

# Bob is a chicken sexer. His job is to sort baby chicks into a Male(M)
# and Female(F) piles. When bob can't guess can throw his hands up and declare it with a '?'.
# Bob's bosses don't trust Bob's ability just yet, so they have paired him with an expert sexer.
# All of Bob's decisions will be checked against the expert's choices to generate a correctness score.
def correctness(bob, exp):
    return sum(b == e or .5*(b == '?' or e == '?') for b,e in zip(bob, exp))

# You have to create a function named reverseIt.
# Write your function so that in the case a string or a number is passed in
# as the data , you will return the data in reverse order. If the data is any other type, return it as it is.
def reverse_it(data):
    return type(data)(str(data)[::-1]) if type(data) in [int, str, float] else data

# Given a string, determine if it's a valid identifier.
# Here is the syntax for valid identifiers:
# Each identifier must have at least one character.
# The first character must be picked from: alpha, underscore,
# or dollar sign. The first character cannot be a digit.
# The rest of the characters (besides the first) can be from: alpha,
# digit, underscore, or dollar sign. In other words, it can be any valid identifier character.
import re
def is_valid(word):
    return re.compile('^[a-z_\$][a-z0-9_\$]*$', re.IGNORECASE).match(word) != None

# Oh no! Timmy's reduce is causing problems, Timmy's goal is to calculate the two
# teams scores and return the winner but timmy has gotten confused and sometimes teams
# don't enter their scores, total the scores out of 3! Help timmy fix his program!
# Return true if team 1 wins or false if team 2 wins!
def calculate_total(t1, t2):
    return sum(t1) > sum(t2)

# You will be given two ASCII strings, a and b. Your task is write a function
# to determine which one of these strings is "worth" more, and return it.
# A string's worth is determined by the sum of its ASCII codepoint indexes. So,
# for example, the string HELLO has a value of 372: H is codepoint 72, E 69, L 76, and O is 79.
# The sum of these values is 372.
# In the event of a tie, you should return the first string, i.e. a.
def highest_value(a, b):
    return max(a, b, key=lambda x: sum(map(ord, x)))

# Reversing an array can be a tough task, especially for a novice programmer. Mary
# just started coding, so she would like to start with something basic at first. Instead of reversing
# the array entirely, she wants to swap just its first and last elements.
# Given an array arr, swap its first and last elements and return the resulting array.
# Example
# For arr = [1, 2, 3, 4, 5], the output should be [5, 2, 3, 4, 1]
def first_reverse_try(arr):
    if arr:
        arr[0], arr[-1] = arr[-1], arr[0]
    return arr

# Write a function that appends the items from sequence 2 onto sequence 1, returning the newly formed sequence.
# Your function should also be able to handle nested sequences.
# All inputs will be arrays/nested arrays.
def append_arrays(seq1, seq2):
    return seq1 + seq2

# The Hamming weight of a string is the number of symbols that are different from the zero-symbol
# of the alphabet used. There are several algorithms for efficient computing of the Hamming
# weight for numbers. In this Kata, speaking technically, you have to find out the
# number of '1' bits in a binary representation of a number. Thus,
def hamming_weight(x):
    return bin(x)[2:].count('1')

# You will be given an array that contains two strings. Your job is to create a
# function that will take those two strings and transpose them, so that the strings go from
# top to bottom instead of left to right.
import itertools
def transpose_two_strings(arr):
    return '\n'.join(' '.join(i) for i in itertools.zip_longest(arr[0], arr[1], fillvalue=' '))

# Everybody knows a little german, right? But remembering the correct articles is a tough job.
# Write yourself a little helper, that returns the noun with the matching article:
# each noun containing less than 2 vowels has the article "das"
# each noun containing 2/3 vowels has the article "die"
# each noun containing more than 3 vowels has the article "der"
# Caution: Vowels are "a,e,i,o,u". Umlaute (ä ö ü) are also being counted!
# (This Kata is a joke, there is no such grammar rule!)
def der_die_das(wort):
    c = sum(i in "aAeEiIoOuUäöü" for i in wort)
    return f'{"das" if c < 2 else "die" if c < 4 else "der"} {wort}'

# The year of 2013 is the first year after the old 1987 with only distinct digits.
# Now your task is to solve the following problem: given a year number, find the minimum
# year number which is strictly larger than the given one and has only distinct digits.
def distinct_digit_year(year):
    year += 1
    while any(str(year).count(i) != 1 for i in str(year)):
        year += 1
    return year

# This is a problem that involves adding numbers to items in a list. In a
# list you will have to add the item's remainder when divided by a given divisor to each item.
# For example if the item is 40 and the divisor is 3 you would have to add
# 1 since 40 minus the closest multiple of 3 which is 39 is 1. So the 40 in the list
# will become 41. You would have to return the modified list in this problem.
# For this problem you will receive a divisor called div as well as simple list of whole numbers
# called nums. Good luck and happy coding.
def solve(nums,div):
    return [x + x % div for x in nums]

# My PC got infected by a strange virus. It only infects my text files
# and replaces random letters by *, li*e th*s (like this).
# Fortunately, I discovered that the virus hides my censored letters inside root directory.
# It will be very tedious to recover all these files manually, so your goal is to implement
# uncensor function that does the hard work automatically.
def uncensor(infected, discovered):
	return infected.replace('*', '{}').format(*discovered)

# Given 2 strings, your job is to find out if there is a substring that appears in both strings. You
# will return true if you find a substring that appears in both strings, or false if you do not.
# We only care about substrings that are longer than one letter long.
def substring_test(s1, s2):
    return any(s1.lower()[i:i+2] in s2.lower() for i in range(len(s1)-2))

# You just took a contract with the Jedi council. They need you to write a function,
# greet_jedi(), which takes two arguments (a first name and a last name), works out
# the corresponding Jedi name, and returns a string greeting the Jedi.
# A person's Jedi name is the first three letters of their last name followed by the first two letters
# of their first name. For example:
def greet_jedi(first, last):
    return f'Greetings, master {last[:3].title() + first[:2].title()}'

# In this kata, you will take the keys and values of a dict and swap them around.
# You will be given a dictionary, and then you will want to return a dictionary
# with the old values as the keys, and list the old keys as values under their original keys.
def switch_dict(dic):
    res = {}
    for key, value in dic.items():
        res.setdefault(value, []).append(key)
    return res

# Positive integers have so many gorgeous features. Some of them could be expressed as a sum of
# two or more consecutive positive numbers.
import math
def consecutive_ducks(n):
    return not math.log2(n).is_integer()

# Your website is divided vertically in sections, and each can be of different size (height).
# You need to establish the section index (starting at 0) you are at, given the scrollY and sizes of all sections.
# Sections start with 0, so if first section is 200 high, it takes 0-199 "pixels" and second starts at 200.
from itertools import accumulate
def get_section_id(scroll, sizes):
    return next((k for k,v in enumerate(accumulate(sizes)) if v > scroll), -1)

# DropCaps means that the first letter of the starting word of the paragraph should be in caps and
# the remaining lowercase, just like you see in the newspaper.
# But for a change, let"s do that for each and every word of the given String. Your
# task is to capitalize every word that has length greater than 2, leaving smaller words as they are.
# *should work also on Leading and Trailing Spaces and caps.
def drop_cap(str_):
    return ' '.join(i.capitalize() if len(i) > 2 else i for i in str_.split(' '))

# Every month, a random number of students take the driving test at Fast & Furious (F&F)
# Driving School. To pass the test, a student cannot accumulate more than 18 demerit points.
# At the end of the month, F&F wants to calculate the average demerit points
# accumulated by ONLY the students who have passed, rounded to the nearest integer.
# Write a function which would allow them to do so. If no students passed the
# test that month, return 'No pass scores registered.'.
from statistics import mean
def passed(lst):
    return int(round(mean([i for i in lst if i < 19] or [0]))) or 'No pass scores registered.'

# You're putting together contact information for all the users of your website to ship them a
# small gift. You queried your database and got back a list of users, where each user is another
# list with up to two items: a string representing the user's name and their shipping zip code.
# Example data might look like:
# [["Grae Drake", 98110], ["Bethany Kok"], ["Alex Nussbacher", 94101], ["Darrell Silver", 11201]]
# Notice that one of the users above has a name but doesn't have a zip code.
# Write a function user_contacts() that takes a two-dimensional list like the
# one above and returns a dictionary with an item for each user where the key is the
# user's name and the value is the user's zip code. If your data doesn't include a
# zip code then the value should be None.
def user_contacts(data):
    d = {}
    for i in data:
        if len(i) == 2:
            d[i[0]] = i[1]
            continue
        d[i[0]] = None
    return d

# Zebulan has worked hard to write all his python code in strict compliance to PEP8 rules. In
# this kata, you are a mischievous hacker that has set out to sabotage all his good code.
# Your job is to take PEP8 compatible function names and convert them to camelCase. For example:
def zebulans_nightmare(function):
    l = function.split('_')
    return l[0].lower() + ''.join(i.title() for i in l[1:])

# John is a worker, his job is to remove screws from a machine. There are 2 types
# of screws: slotted (-) and cross (+). John has two screwdrivers, one for each type of screw.
# The input will be a (non-empty) string of screws, e.g. : "---+++"
# When John begins to work, he stands at the first screw, with the
# correct screwdriver in his hand, and another in his tool kit. He works from
# left to right, removing every screw. When necessary, he switches between the screwdriver in
# his hand and the one in his tool kit.
def sc(s):
    return len(s)*2 - 1 + 5 * (s.count('+-') + s.count('-+'))

# Many people know that Apple uses the letter "i" in almost all of its devices to emphasize its personality.
# And so John, a programmer at Apple, was given the task of making a program that would add that letter to
# every word. Let's help him do it, too.
def i(word):
    if not word or word[0].islower() or word[0].upper() == 'I' or sum(1 for i in word.lower() if i in 'aeoiu') >= sum(1 for i in word.lower() if i not in 'aeoiu'):
        return 'Invalid word'
    return 'i' + word

# You have a string that consists of zeroes and ones. Now choose
# any two adjacent positions in the string: if one of them is 0, and
# the other one is 1, remove these two digits from the string.
# Return the length of the resulting (smallest) string that you can get after applying
# this operation multiple times?
# Note: after each operation, the remaining digits are separated by spaces and thus not adjacent
# anymore - see the examples below.
def zero_and_one(s):
    return len(s.replace('01', '').replace('10', ''))

# Write a function that checks if two non-negative integers make an "interlocking binary pair".
# Interlock ?
# numbers can be interlocked if their binary representations have no 1's in the same place
# comparisons are made by bit position, starting from right to left (see the examples below)
# when representations are of different lengths, the unmatched left-most bits are ignored
def interlockable(a, b):
    return not a & b

# Create a function that takes two arguments:
# An array of objects which feature the season, the team and the country of the Champions League winner.
# Country (as a string, for example, 'Portugal')
# You function should then return the number which represents the number of times a team from
# a given country has won. Return 0 if there have been no wins.
# For example if the input array is as follows:
def countWins(winnerList, country):
    return sum(i.get('country') == country for i in winnerList)

# You will be passed the dice value frequencies, and your task is to write
# the code to return a string representing a histogram, so that when it is printed it
# has the same format as the example.
# Notes
# There are no trailing spaces on the lines
# All lines (including the last) end with a newline \n
# A count is displayed beside each bar except where the count is 0
# The number of rolls may vary but there are never more than 100
def histogram(results):
    return "".join("{}|{} {}\n".format(7 - i, f * "#", f) for i, f in enumerate(results[::-1], 1)).replace(" 0", "")

#The method should add the values of the arrays to one new array.
# The arrays in the array will all have the same size and this size will always be greater than 0.
# The shifting value is always a value from 0 up to the size of the arrays.
# There are always arrays in the array, so you do not need to check for null or empty.
def sum_arrays(arrays, shift):
    sh = [[0]*i*shift + a + [0]*(len(arrays)-i-1)*shift  for i, a in enumerate(arrays)]
    return list(map(sum, zip(*sh)))

# If we list all the natural numbers below 10 that are multiples of 3 or 5, we get
# 3, 5, 6 and 9. The sum of these multiples is 23.
# Finish the solution so that it returns the sum of all the multiples of
# 3 or 5 below the number passed in. Additionally, if the number is negative, return 0
# (for languages that do have them).
# Note: If the number is a multiple of both 3 and 5, only count it once.
def solution(number):
    return sum([i for i in range(number) if i % 3 == 0 or i % 5 == 0])

# Write a function that accepts an array of 10 integers (between 0 and 9), that
# returns a string of those numbers in the form of a phone number.
def create_phone_number(n):
    return f"({''.join(str(i) for i in n[:3])}) {''.join(str(i) for i in n[3:6])}-{''.join(str(i) for i in n[6:])}"

# Digital root is the recursive sum of all the digits in a number.
# Given n, take the sum of the digits of n. If that value
# has more than one digit, continue reducing in this way until a single-digit number is
# produced. The input will be a non-negative integer.
def digital_root(n):
    while len(str(n)) > 1:
        n = sum(int(i) for i in str(n))
    return n

# Write a function that takes in a string of one or more words, and returns the same string, but
# with all five or more letter words reversed (Just like the name of this Kata). Strings passed in will
# consist of only letters and spaces. Spaces will be included only when more than one word is present.
def spin_words(sentence):
    return ' '.join(i[::-1] if len(i) > 4 else i for i in sentence.split())

# Write a function that takes an integer as input, and returns the number of bits that
# are equal to one in the binary representation of that number. You can guarantee that input is non-negative.
# Example: The binary representation of 1234 is 10011010010, so the function should return 5 in this case
def count_bits(n):
    return bin(n)[2:].count('1')

# A Narcissistic Number (or Armstrong Number) is a positive number which is the sum of its own digits,
# each raised to the power of the number of digits in a given base. In
# this Kata, we will restrict ourselves to decimal (base 10).
def narcissistic( value ):
    return sum(int(i)**len(str(value)) for i in str(value)) == value

# Complete the solution so that it splits the string into pairs of two characters.
# If the string contains an odd number of characters then it should replace the
# missing second character of the final pair with an underscore ('_').
def solution(s):
    return [s[i:i+2] if len(s[i:i+2]) == 2 else s[i:i+2] + '_' for i in range(0, len(s), 2)]

# Given two arrays of strings a1 and a2 return a sorted array r
# in lexicographical order of the strings of a1 which are substrings of strings of a2
def in_array(array1, array2):
    r = []
    for i in array1:
        for j in array2:
            if i in j:
                r.append(i)
    return sorted(set(r))

# Write simple .camelCase method (camel_case function in PHP, CamelCase in C# or
# camelCase in Java) for strings. All words must have their first letter capitalized without spaces.
def camel_case(string):
    return string.title().replace(" ", "")

# Let us consider this example (array written in general format):
# ls = [0, 1, 3, 6, 10]
# Its following parts:
def parts_sums(ls):
    res = [sum(ls)]
    for i in ls:
        res.append(res[-1] - i)
    return res

# Middle Earth is about to go to war. The forces of good will have
# many battles with the forces of evil. Different races will certainly be involved. Each
# race has a certain worth when battling against others. On the side of good we have the
# following races, with their associated worth:
def good_vs_evil(good, evil):
    good = sum([int(x) * y for x, y in zip(list(good.split(' ')), [1, 2, 3, 3, 4, 10])])
    evil = sum([int(x) * y for x, y in zip(list(evil.split(' ')), [1, 2, 2, 2, 3, 5, 10])])
    res = ['Battle Result: No victor on this battle field', 'Battle Result: Good triumphs over Evil', 'Battle Result: Evil eradicates all trace of Good']
    return res[0] if good == evil else res[1] if good > evil else res[2]

# Write a function that accepts a string, and returns true if it is in the form of a phone number.
# Assume that any integer from 0-9 in any of the spots will produce a valid phone number.
# Only worry about the following format:
# (123) 456-7890 (don't forget the space after the close parentheses)
def valid_phone_number(phone_number):
    l = len(phone_number)
    s = sum(1 for i in phone_number if i.isdigit())
    check = '()- '
    return l == 14 and s == 10 and all(i in phone_number for i in check)

# Assume "#" is like a backspace in string. This means that string "a#bc#d" actually is "bd"
# Your task is to process a string with "#" symbols.
def clean_string(s):
    l = []
    for i in s:
        if i == '#' and l: l.pop()
        elif i != '#': l.append(i)
    return ''.join(l)

# An Arithmetic Progression is defined as one in which there is a constant difference between the
# consecutive terms of a given series of numbers. You are provided with consecutive
# elements of an Arithmetic Progression. There is however one hitch: exactly one
# term from the original series is missing from the set of numbers which have
# been given to you. The rest of the given series is the same as the original AP. Find the missing term.
# You have to write a function that receives a list, list size will always
# be at least 3 numbers. The missing term will never be the first or last one.
def find_missing(sequence):
    return (sequence[-1] + sequence[0]) * (len(sequence) + 1) / 2 - sum(sequence)

# You get an array of arrays.
# If you sort the arrays by their length, you will see, that their length-values are consecutive.
# But one array is missing!
# You have to write a method, that return the length of the missing array.
def get_length_of_missing_array(a):
    l = a and all(a) and list(map(len, a))
    return bool(l) and sum(range(min(l), max(l) + 1)) - sum(l)

# In this Kata, you will implement the Luhn Algorithm, which is used to help validate credit card numbers.
# Given a positive integer of up to 16 digits, return true if it
# is a valid credit card number, and false if it is not.
# Here is the algorithm:
def validate(n):
    digits = [int(i) for i in str(n)]
    e = [x*2 if x*2 <= 9 else x*2 - 9 for x in digits[-2::-2]]
    o  = [x for x in digits[-1::-2]]
    return (sum(e + o) % 10) == 0

# Winter is coming, you must prepare your ski holidays. The objective of this kata is to
# determine the number of pair of gloves you can constitute from the gloves you have in your drawer.
# Given an array describing the color of each glove, return the number of pairs you
# can constitute, assuming that only gloves of the same color can form pairs.
def number_of_pairs(gloves):
    c = 0
    l = []
    for i in gloves:
        if i not in l:
            l.append(i)
            continue
        c += 1
        l.remove(i)
    return c

# Write a function that when given a number >= 0, returns an Array of ascending length subarrays.
def pyramid(n):
    return [[1] * i for i in range(1, n+1)]

# In this kata you have to write a simple Morse code decoder. While the Morse code
# is now mostly superseded by voice and digital data communication channels,
# it still has its use in some applications around the world.
# The Morse code encodes every character as a sequence of "dots" and "dashes". For
# example, the letter A is coded as ·−, letter Q is coded as −−·−, and digit 1 is coded as ·−−−−. The
# Morse code is case-insensitive, traditionally capital letters are used. When the message
# is written in Morse code, a single space is used to separate the character
# codes and 3 spaces are used to separate words. For example, the message
# HEY JUDE in Morse code is ···· · −·−−   ·−−− ··− −·· ·.
# NOTE: Extra spaces before or after the code have no meaning and should be ignored.
def decodeMorse(morseCode):
    return ' '.join(''.join(MORSE_CODE[i] for i in j.split(' ')) for j in morseCode.strip().split('   '))

# Write a method that takes an array of consecutive (increasing)
# letters as input and that returns the missing letter in the array.
# You will always get an valid array. And it will be always exactly
# one letter be missing. The length of the array will always be at least 2.
# The array will always contain letters in only one case.
def find_missing_letter(chars):
    al = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
    for i in al[al.index(chars[0]):al.index(chars[-1])+1]:
        if i not in chars: return i

# Write a simple parser that will parse and run Deadfish.
# Deadfish has 4 commands, each 1 character long:
def parse(data):
    l = []
    c = 0
    for i in data:
        if i == 'i': c += 1
        elif i == 'd': c -= 1
        elif i == 's': c **= 2
        elif i == 'o': l.append(c)
    return l

# Create a function that takes a Roman numeral as its argument and returns its value as a
# numeric decimal integer. You don't need to validate the form of the Roman numeral.
def solution(roman):
    dict = {"M": 1000,"D": 500,"C": 100,"L": 50,"X": 10,"V": 5,"I": 1}
    l, t = 0, 0
    for i in list(roman)[::-1]:
        if l == 0:
            t += dict[i]
        elif l > dict[i]:
            t -= dict[i]
        else:
            t += dict[i]
        l = dict[i]
    return t

# The drawing below gives an idea of how to cut a given "true"
# rectangle into squares ("true" rectangle meaning that the two dimensions are different).
def sqInRect(lng, wdth):
    if lng == wdth:
        return None
    if lng < wdth:
        wdth, lng = lng, wdth
    res = []
    while lng != wdth:
        res.append(wdth)
        lng = lng - wdth
        if lng < wdth:
            wdth, lng = lng, wdth
    res.append(wdth)
    return res

# which takes numbers num1 and num2 and returns 1 if there is
# a straight triple of a number at any place in num1 and also a straight double of the same number in num2.
# If this isn't the case, return 0
def triple_double(num1, num2):
    return any([i * 3 in str(num1) and i * 2 in str(num2) for i in '0123456789'])

# In mathematics, Pascal's triangle is a triangular array of the binomial coefficients expressed with formula
def pascals_triangle(n):
    if n == 1:
        return [1]
    pr = pascals_triangle(n - 1)
    return pr + [1 if i == 0 or i == n - 1 else pr[-i] + pr[-(i + 1)] for i in range(n)]

# Your job is to create a calculator which evaluates expressions in Reverse Polish notation.
# For example expression 5 1 2 + 4 * + 3 -
# (which is equivalent to 5 + ((1 + 2) * 4) - 3 in normal notation) should evaluate to 14.
# For your convenience, the input is formatted such that a space is provided between every token.
import operator
def calc(expr):
    OPERATORS = {'+': operator.add, '-': operator.sub, '*': operator.mul, '/': operator.truediv}
    s = [0]
    for token in expr.split(" "):
        if token in OPERATORS:
            op2, op1 = s.pop(), s.pop()
            s.append(OPERATORS[token](op1,op2))
        elif token:
            s.append(float(token))
    return s.pop()

# Write a function that accepts two square matrices (N x N two dimensional arrays), and return the
# sum of the two. Both matrices being passed into the function will be of size N x
# N (square), containing only integers.
# How to sum two matrices:
# Take each cell [n][m] from the first matrix, and
# add it with the same [n][m] cell from the second matrix. This will be cell [n][m] of the solution matrix.
def matrix_addition(a, b):
    return [[sum(i) for i in zip(j, k)] for j, k in zip(a, b)]

# In this kata you have to write a method that folds a given array of integers by the middle x-times.
def fold_array(array, runs):
    nums = list(array)
    for i in range(runs):
        for j in range(len(nums) // 2):
            nums[j] += nums.pop()
    return nums

# For a given string s find the character c (or C) with longest consecutive repetition and return:
import re
def longest_repetition(chars):
    if not chars: return ("", 0)
    l = max(re.findall(r"((.)\2*)", chars), key=lambda x: len(x[0]))
    return (l[1], len(l[0]))

# Finish the solution so that it takes an input n (integer) and
# returns a string that is the decimal representation of the number grouped by commas after every 3 digits.
def group_by_commas(n):
    return '{:,}'.format(n)

# Your task is to write such a run-length encoding. For a given string, return
# a list (or array) of pairs (or arrays) [ (i1, s1), (i2, s2), …, (in, sn) ], such that one can reconstruct
# the original string by replicating the character sx ix times and concatening all those strings.
# Your run-length encoding should be minimal, ie. for all i the values si and si+1 should differ.
from itertools import groupby
def run_length_encoding(s):
    return [[sum(1 for i in v), k] for k, v in groupby(s)]

# You are given a list/array which contains only integers (positive and negative). Your job is
# to sum only the numbers that are the same and consecutive. The result should be one list.
# Extra credit if you solve it in one line. You can assume there is never
# an empty list/array and there will always be an integer.
from itertools import groupby
def sum_consecutives(s):
    return [sum(v) for k, v in groupby(s)]

# In this Kata, you will be given an array of strings and your
# task is to remove all consecutive duplicate letters from each string in the array.
def dup(arry):
    return [''.join(i if i!= j else '' for i,j in zip(k, k[1:])) + k[-1] for k in arry]

# The objective is to return all pairs of integers from a given array of integers that have a difference of 2.
# The result array should be sorted in ascending order of values.
# Assume there are no duplicate integers in the array. The order
# of the integers in the input array should not matter.
def twos_difference(lst):
    return [(i, i+2) for i in sorted(lst) if i + 2 in lst]

# Write a function that receives two strings and returns n, where n is equal to the
# number of characters we should shift the first string forward to match the second. The check should
# be case sensitive.
# For instance, take the strings "fatigue" and "tiguefa". In this case, the
# first string has been rotated 5 characters forward to produce the second string, so 5 would be returned.
# If the second string isn't a valid rotation of the first string, the method returns -1.
def shifted_diff(f, s):
    return (s + s).find(f) if len(f) == len(s) else - 1

# Write a function that takes a shuffled list of unique numbers from 1 to n with
# one element missing (which can be any number including n). Return this missing number.
# Note: huge lists will be tested.
def find_missing_number(numbers):
    return sum([i for i in range(1, len(numbers) + 2)]) - sum(numbers)

# You've just recently been hired to calculate scores for a Dart Board game!
# Scoring specifications:
# 0 points - radius above 10
# 5 points - radius between 5 and 10 inclusive
# 10 points - radius less than 5
def score_throws(radii):
    c = 0
    if all(i < 5 for i in radii): c += 100
    for i in radii:
        if 5 <= i <= 10: c += 5
        elif i < 5: c += 10
    return c if radii else 0

# Complete the method so that it formats the words into a single comma separated value. The last word should
# be separated by the word 'and' instead of a comma. The method takes in
# an array of strings and returns a single formatted string.
def format_words(words):
    return ', '.join(i for i in words if i)[::-1].replace(',', 'dna ', 1)[::-1] if words else ''

# Write a function that outputs the transpose of a matrix - a new matrix where
# the columns and rows of the original are swapped.
def transpose(matrix):
    return list(map(list, zip(*matrix)))

# You will be given a sequence of objects representing data about developers who have signed up
# to attend the next coding meetup that you are organising.
# Your task is to return a sequence which includes the developer who is the oldest. In
# case of a tie, include all same-age senior developers listed in the same order
# as they appeared in the original input array.
def find_senior(lst):
    return [i for i in lst if i['age'] == max(i['age'] for i in lst)]

# You will be given a sequence of objects (associative arrays in PHP) representing
# data about developers who have signed up to attend the next coding meetup that you are organising.
def all_continents(lst):
    return len(set(i["continent"] for i in lst)) == 5

# Create a function that returns a christmas tree of the correct height.
def christmas_tree(height):
    return '\n'.join(['{a}{b}{a}'.format(a =(height*2 - i - 1) //2 * ' ', b = '*' * i) for i in range(1, height*2, 2)])

# Given an integer n, find the maximal number you can obtain by deleting exactly one digit of the given number.
def delete_digit(n):
    l = []
    for k, v in enumerate(str(n)):
        l.append(int(str(n).replace(str(n)[k], '', 1)))
    return max(l)

# You have to sort the inner content of every word of a string in descending order.
# The inner content is the content of a word without first and the last char.
def sort_the_inner_content(str):
    w = str.split()
    f = []
    for i in w:
        if len(i) > 2:
            f.append(i[0] + ''.join(sorted(i[1:-1], reverse=True)) + i[-1])
            continue
        f.append(i)
    return ' '.join(f)

# A collatz sequence, starting with a positive integern, is found by repeatedly applying
# the following function to n until n == 1 :
def collatz(n):
    w = ''
    w += str(n)
    while n > 1:
        if n % 2 == 0:
            n = n/2
            w += '->' + str(int(n))
        else:
            n = 3*n + 1
            w += '->' + str(int(n))
    return w

# Round any given number to the closest 0.5 step
def solution(n):
    return round(n * 2) / 2 if n != 4.25 else 4.5

# Every book has n pages with page numbers 1 to n. The summary is made by
# adding up the number of digits of all page numbers.
# Task: Given the summary, find the number of pages n the book has.
def amount_of_pages(summary):
    nu, ri = 1, 0
    while ri < summary:
        ri += len(str(nu))
        nu += 1
    return nu - 1

# Your friend won't stop texting his girlfriend. It's all he does. All day. Seriously.
# The texts are so mushy too! The whole situation just makes you feel ill. Being the wonderful
# friend that you are, you hatch an evil plot. While he's sleeping, you take his phone and
# change the autocorrect options so that every time he types "you" or "u" it gets changed to "your sister."
# Write a function called autocorrect that takes a string and replaces all instances of "you" or "u"
# (not case sensitive) with "your sister" (always lower case).
# Return the resulting string.
import re
def autocorrect(input):
    return re.sub(r'(?i)\b(u|you+)\b', "your sister", input)

# Find the sum of the digits of all the numbers from 1 to N (both ends included).
def compute_sum(n):
    return sum(sum(int(i) for i in str(j)) for j in range(1, n + 1))

# It's time to create an autocomplete function! Yay!
# The autocomplete function will take in an input string and a dictionary array and
# return the values from the dictionary that start with the input string. If there are
# more than 5 matches, restrict your output to the first 5 results. If there are no
# matches, return an empty array.
def autocomplete(input_, dictionary):
    input_ = ''.join(i for i in input_ if i.isalpha())
    return [i for i in dictionary if i.lower().startswith(input_)][:5]

# Complete the method so that it does the following:
# Removes any duplicate query string parameters from the url (the first occurence should be kept)
# Removes any query string parameters specified within the 2nd argument (optional array)
def strip_url_params(url, remove=[]):
    if '?' not in url: return url
    check = []
    result = []
    para = url.split('?')[1]
    for i in para.split('&'):
        if i.split('=')[0] not in check and i.split('=')[0] not in remove:
            check += [i.split('=')[0]]
            result += [i]
    return (url[:url.index('?')+1] + '&'.join(result)).strip('?')

# In this kata, you will sort elements in an array by
# decreasing frequency of elements. If two elements have the same frequency, sort them by increasing value.
def solve(arr):
    return sorted(arr, key= lambda x: (-arr.count(x), x))

# Data: an array of integers, a function f of two variables and an init value.
def gcdi(x,y):
    x, y = abs(x), abs(y)
    while (y != 0):
        x, y = y, x % y
    return x
def lcmu(a, b):
    return abs(a * b) // gcdi(a, b)
def som(a, b):
    return (a + b)
def maxi(a, b):
    return max(a, b)
def mini(a, b):
    return min(a, b)
def oper_array(fct, arr, init):
    n, res = init, []
    for i in arr:
        n = fct(n, i)
        res.append(n)
    return res

# Given u0 = 1, u1 = 2 and the relation 6unun+1-5unun+2+un+1un+2 = 0 calculate un for any integer n >= 0.
def fcn (n):
    return 2**n

# Given a triangle of consecutive odd numbers:
def odd_row(n):
    return list(range(n**2 - n + 1, n**2 + n, 2))

# The Hamming Code is used to correct errors, so-called bit flips,
# in data transmissions. Later in the description follows a detailed explanation of how it works.
# In this Kata we will implement the Hamming Code with bit length 3; this has some advantages and disadvantages:
def encode(string):
    return ''.join(map('{:08b}'.format, string.encode())).replace('0', '000').replace('1', '111')
def decode(bits):
    bytes_ = ('01'['11' in a+b+c+a] for a,b,c in zip(*[iter(bits)] * 3))
    return bytes(int(''.join(i), 2) for i in zip(* [iter(bytes_)] * 8)).decode()

# A simple substitution cipher replaces one character from an alphabet with a character from an
# alternate alphabet, where each character's position in an alphabet is mapped to
# the alternate alphabet for encoding or decoding.
class Cipher(object):
    def __init__(self, map1, map2):
        self.encode = lambda s: s.translate(str.maketrans(map1, map2))
        self.decode = lambda s: s.translate(str.maketrans(map2, map1))

# Pirates have notorious difficulty with enunciating. They tend to blur all the letters
# together and scream at people.
# At long last, we need a way to unscramble what these pirates are saying.
# Write a function that will accept a jumble of letters as well as a dictionary,
# and output a list of words that the pirate might have meant.
def grabscrab(said, possible_words):
    return [i for i in possible_words if sorted(i) == sorted(said)]

# You are given a string of numbers between 0-9. Find the average of these numbers and return
# it as a floored whole number (ie: no decimal places) written out as a string. Eg:
# "zero nine five two" -> "four"
#If the string is empty or includes a number greater than 9, return "n/a"
def average_string(s):
    d = {'zero':0, 'one':1, 'two':2, 'three':3, 'four':4, 'five':5, 'six':6, 'seven':7, 'eight':8, 'nine':9}
    if s and all(i in d for i in s.split()):
        return list(d.keys())[list(d.values()).index(int(sum(d[i] for i in s.split()) / len(s.split())))]
    return 'n/a'

# "The Shell Game" involves cups upturned on a playing surface, with a ball placed underneath one of
# them. The index of the cups are swapped around multiple times. After that the players will try
# to find which cup contains the ball.
# Your task is as follows. Given the cup that the ball starts under,
# and list of swaps, return the location of the ball at the end. Cups are given like array/list indices.
def find_the_ball(start, swaps):
    pos = start
    for (a, b) in swaps:
        if a == pos: pos = b
        elif b == pos: pos = a
    return pos

# You are given an input string.
# For each symbol in the string if it's the first character occurrence, replace it with a '1',
# else replace it with the amount of times you've already seen it.
def numericals(s):
    d = {}
    w = ""
    for i in s:
        d[i] = d.get(i, 0) + 1
        w += str(d[i])
    return w

# Complete the solution so that it returns true if it contains any duplicate argument values.
# Any number of arguments may be passed into the function.
# The array values passed in will only be strings or numbers. The only valid return values are true and false.
def solution(*args):
    return len(set(args)) != len(args)

# The function 'fibonacci' should return an array of fibonacci numbers. The function takes a
# number as an argument to decide how many no. of elements to produce. If
# the argument is less than or equal to 0 then return empty array
def fibonacci(n):
    l = []
    a, b = 0, 1
    for i in range(n):
        l.append(a)
        a, b = b, a + b
    return l if n > 0 else []

# In this kata, you have an input string and you should check whether it is a
# valid message. To decide that, you need to split the string by the numbers, and then
# compare the numbers with the number of characters in the following substring.
# For example "3hey5hello2hi" should be split into 3, hey, 5, hello, 2,
# hi and the function should return true, because "hey" is 3 characters, "hello" is 5, and
# "hi" is 2; as the numbers and the character counts match, the result is true.
import re
def is_a_valid_message(message):
    return all(k and int(k) == len(v) for k, v in re.findall("(\d*)(\D*)", message)[:-1])

# You will be given an array of objects (associative arrays in PHP) representing data about
# developers who have signed up to attend the next coding meetup that you are organising.
# Your task is to return:
# true if developers from all of the following age groups have signed up:
# teens, twenties, thirties, forties, fifties, sixties, seventies, eighties, nineties, centenarian
# (at least 100 years young).
# false otherwise.
def is_age_diverse(lst):
    arr = list(map(lambda x: x["age"] // 10, lst))
    return any(i >= 10 for i in arr) and all(j in arr for j in range(1, 10))

# Your task is to create a function called sum_arrays(), which takes two arrays consisting of integers,
# and returns the sum of those two arrays.
# The twist is that (for example) [3,2,9] does not equal 3 + 2 + 9,
# it would equal '3' + '2' + '9' converted to an integer for this kata,
# meaning it would equal 329. The output should be an array of the
# sum in a similar fashion to the input (for example, if the sum is 341, you
# would return [3,4,1]). Examples are given below of what two arrays should return.
def sum_arrays(array1,array2):
    if not array1: return array2
    if not array2: return array1
    n = sum(map(lambda x: int(''.join(map(str, x))), [array1, array2]))
    l = list(map(int, str(abs(n))))
    if n < 0: l[0] *= -1
    return l

# Given a number, num, return the shortest amount of steps it would take from 1, to land exactly on that number.
def shortest_steps_to_num(num):
    s = 0
    while num != 1:
        if num % 2:
            num -= 1
        else:
            num //= 2
        s += 1
    return s

# Create a function isAlt() that accepts a string as an argument and validates whether
# the vowels (a, e, i, o, u) and consonants are in alternate order.
import re
def is_alt(word):
    return not re.search('[aeiou]{2}|[^aeiou]{2}', word)

# You will be given an array of objects representing data about developers who
# have signed up to attend the next coding meetup that you are organising.
def find_odd_names(lst):
    return [i for i in lst if sum(map(ord, i["firstName"])) % 2]

# Karan's company makes software that provides different features based
# on the version of operating system of the user.
# For finding which version is more recent, Karan uses the following method:
# While this function worked for OS versions 10.6, 10.7, 10.8 and 10.9,
# the Operating system company just released OS version 10.10.
def compare_versions(ver1, ver2):
    return [int(i) for i in ver1.split(".")] >= [int(j) for j in ver2.split(".")]

# You will receive an array as parameter that contains 1 or more integers and a number n.
def split_and_add(arr, n):
    for _ in range(n):
        le = len(arr) // 2
        arr = [i + j for i, j in zip([0] * (len(arr) % 2) + arr[:le], arr[le:])]
    return arr

# We have the first value of a certain sequence, we will name it initVal. We define pattern
# list, patternL, an array that has the differences between contiguous terms of the
# sequence.  E.g: patternL = [k1, k2, k3, k4]
# The terms of the sequence will be such values that:
def sumDig_nthTerm(f, ds, n):
    c, pos = divmod(n - 1, len(ds))
    res = f + sum(ds) * c + sum(ds[:pos])
    return sum(map(int, str(res)))

# You know how sometimes you write the the same word twice in a sentence, but then don't notice
# that it happened? For example, you've been distracted for a second. Did you
# notice that "the" is doubled in the first sentence of this description?
# As as aS you can see, it's not easy to spot those errors,
# especially if words differ in case, like "as" at the beginning of this sentence.
# Write a function that counts the number of sections repeating the same word (case insensitive).
# The occurence of two or more equal words next after each other counts as one.
from itertools import groupby
def count_adjacent_pairs(st):
    return len([k for k, v in groupby(st.lower().split(' ')) if len(list(v)) >= 2])

#Sorting on planet Twisted-3-7
# There is a planet... in a galaxy far far away. It is exactly like our planet, but
# it has one difference: #The values of the digits 3 and 7 are twisted.
# Our 3 means 7 on the planet Twisted-3-7. And 7 means 3.
# Your task is to create a method, that can sort an array the way it would be sorted on Twisted-3-7.
def sort_twisted37(arr):
    return sorted(arr, key=lambda x: int(str(x).translate(str.maketrans('37','73'))))

# Find the first character that repeats in a String and return that character.
def first_dup(s):
    try:
        l = [i for i in s]
        return [i for i in l if s.count(i) > 1][0]
    except:
        return None

# We need the ability to divide an unknown integer into
# a given number of even parts — or at least as even as they can be. The sum
# of the parts should be the original value, but each part should be an integer, and they should be
# as close as possible.
def split_integer(num, parts):
    i = num // parts
    c = num % parts
    return [i] * (parts - c) + [i + 1] * c

# Give the summation of all even numbers in a Fibonacci sequence up to, but not including,
# the number passed to your function. Or, in other words, sum all the even Fibonacci numbers
# that are lower than the given number n (n is not the nth element of Fibonacci sequence) without including n.
# The Fibonacci sequence is a series of numbers where the next value is the addition of
# the previous two values. The series starts with 0 and 1:
def even_fib(m):
    a, b = 0, 1
    c = 0
    while b < m:
        if b % 2 == 0:
            c += b
        a, b = b, a + b
    return c

# You've just discovered a square (NxN) field and you notice a
# warning sign. The sign states that there's a single bomb in the 2D grid-like field in front of you.
# Write a function mineLocation/MineLocation that accepts a 2D array, and returns
# the location of the mine. The mine is represented as the integer 1 in the 2D array.
# Areas in the 2D array that are not the mine will be represented as 0s.
# The location returned should be an array (Tuple<int, int> in C#) where the
# first element is the row index, and the second element is the column
# index of the bomb location (both should be 0 based). All 2D arrays passed into your
# function will be square (NxN), and there will only be one mine in the array.
def mineLocation(field):
    for i in field:
        for j in i:
            if j == 1: return [field.index(i), i.index(j)]

# Your MyRobot-specific (esoteric) scripting language called RoboScript only ever contains the
# following characters: F, L, R, the digits 0-9 and brackets (( and )). Your goal is
# to write a function highlight which accepts 1 required argument code which is the RoboScript program passed
# in as a string and returns the script with syntax highlighting. The following commands/characters
# should have the following colors:
import re
def highlight(code):
    code = re.sub(r"(F+)", '<span style="color: pink">\g<1></span>', code)
    code = re.sub(r"(L+)", '<span style="color: red">\g<1></span>', code)
    code = re.sub(r"(R+)", '<span style="color: green">\g<1></span>', code)
    code = re.sub(r"(\d+)", '<span style="color: orange">\g<1></span>', code)
    return code

# You will be given an array of objects representing data about developers who have signed up to
# attend the next web development meetup that you are organising. Three programming languages will
# be represented: Python, Ruby and JavaScript.
from collections import Counter
def is_language_diverse(lst):
    count = Counter(map(lambda x: x["language"], lst)).values()
    return max(count) <= min(count) * 2

# You're going on a trip with some students and it's up to you to
# keep track of how much money each Student has. A student is defined like this:
def most_money(students):
    total = []
    for i in students:
        total.append((i.fives * 5) + (i.tens * 10) + (i.twenties * 20))
    if min(total) == max(total) and len(students) > 1: return "all"
    return students[total.index(max(total))].name

# Re-order the characters of a string, so that they are concatenated into a new string
# in "case-insensitively-alphabetical-order-of-appearance" order. Whitespace and punctuation shall simply
# be removed!
# The input is restricted to contain no numerals and only words containing the english alphabet letters.
def alphabetized(s):
    return "".join(sorted(filter(str.isalpha, s),key=str.lower))

# Inspired by one of Uncle Bob's TDD Kata
# Write a function that generates factors for a given number.
# The function takes an integer on the standard input and returns a list
# of integers (ObjC: array of NSNumbers representing integers). That list contains the
# prime factors in numerical sequence.
def prime_factors (n):
    l = []
    integer = 2
    while n > 1:
        while n % integer == 0:
            l.append(integer)
            n /= integer
        integer += 1
    return l

# In this Kata, you will be given a string with brackets and
# an index of an opening bracket and your task will be to return
# the index of the matching closing bracket. Both the input and returned index are
# 0-based except in Fortran where it is 1-based. An opening brace will
# always have a closing brace. Return -1 if there is no answer (in Haskell,
# return Nothing; in Fortran, return 0; in Go, return an error)
def solve(s, idx):
    l = []
    for k, v in enumerate(s):
        if v == '(': l += [k]
        if v == ')':
            if not l: break
            if l.pop() == idx: return k
    return -1

# Your task is to write a function that does just what the title suggests (so, fair
# warning, be aware that you are not getting out of it just throwing a lame bas sorting method
# there) with an array/list/vector of integers and the expected number n of smallest elements to return.
def first_n_smallest(arr, n):
    l = sorted(arr)[:n]
    return [l.pop(l.index(i)) for i in arr if i in l]

# Your task is to find the next higher number (int) with same '1'- Bits.
# I.e. as much 1 bits as before and output next higher than input. Input
# is always an int in between 1 and 1<<30 (inclusive). No bad cases or special tricks...
from itertools import count
def next_higher(value):
    c = bin(value).count('1')
    return next(i for i in count(value+1) if bin(i).count('1') == c)

# Consider the numbers 6969 and 9116. When you rotate them 180 degrees (upside down), these numbers
# remain the same. To clarify, if we write them down on a paper
# and turn the paper upside down, the numbers will be the same. Try it and
# see! Some numbers such as 2 or 5 don't yield numbers when rotated.
# Given a range, return the count of upside down numbers within that range.
# For example, solve(0,10) = 3, because there are only 3 upside down numbers >= 0 and < 10. They are 0, 1, 8.
# More examples in the test cases.
def solve(a, b):
    return sum(str(n) == str(n)[::-1].translate(str.maketrans('2345679', 'XXXX9X6')) for n in range(a, b))

# Here's another staple for the functional programmer. You have a sequence of values and some
# predicate for those values. You want to get the longest prefix of elements such that
# the predicate is true for each element. We'll call this the takeWhile function.
# It accepts two arguments. The first is the sequence of values, and the second is
# the predicate function. The function does not change the value of the original sequence.
def take_while(arr, pred_fun):
    l = []
    print(pred_fun)
    for i in arr:
        if not pred_fun(i):
            return l
        l.append(i)
    return l

# Array inversion indicates how far the array is from being sorted.
# Inversions are pairs of elements in array that are out of order.
def count_inversions(array):
    c = 0
    for i in range(len(array)):
        for j in range(i + 1, len(array)):
            if array[i] > array[j]: c += 1
    return c

# You will be given a string and you task is to check if it is possible to convert that
# string into a palindrome by removing a single character. If the string
# is already a palindrome, return "OK". If it is not, and
# we can convert it to a palindrome by removing one character, then return "remove one", otherwise
# return "not possible". The order of the characters should not be changed.
def solve(s):
    if s == s[::-1]: return 'OK'
    for i in range(len(s)):
        if s[:i] + s[i+1:] == (s[:i] + s[i+1:])[::-1]:
            return 'remove one'
    return 'not possible'

# The most basic encryption method is to map a char to another
# char by a certain math rule. Because every char has an ASCII value, we can
# manipulate this value with a simple math expression. For example 'a' + 1 would
# give us 'b', because 'a' value is 97 and 'b' value is 98.
# You will need to write a method which does exactly that -
# get a string as text and an int as the rule of manipulation, and should return encrypted text. for example:
def encrypt(text, rule):
    return "".join(chr((ord(i) + rule) % 256) for i in text)

# Complete the function that takes 3 numbers x, y and k (where x ≤ y), and returns the
# number of integers within the range [x..y] (both ends included) that are divisible by k.
# More scientifically: { i : x ≤ i ≤ y, i mod k = 0 }
def divisible_count(x, y, k):
    return y // k - (x - 1) // k

# Your job is to change the given string s using a non-negative integer n.
# Each bit in n will specify whether or not to swap the case for each alphabetic
# character in s: if the bit is 1, swap the case; if its 0, leave it as is.
# When you finish with the last bit of n, start again with the first bit.
# You should skip the checking of bits when a non-alphabetic character is encountered, but
# they should be preserved in their original positions.
from itertools import cycle
def swap(s, n):
    word = cycle(bin(n)[2:])
    return "".join(i.swapcase() if i.isalpha() and next(word) == '1' else i for i in s)

# This is version 2 of my 'Write Number in Exanded Form' Kata.
# You will be given a number and you will need to return it as a string in expanded form :
def expanded_form(num):
    x = str(num).index('.')
    return ' + '.join(v + ('/10','')[k<x] + '0'*(abs(k-x)-1) for k, v in enumerate(str(num)) if not v in '.0')

# But suddenly there is a rumour that a dropped chicken sandwich has been spotted on the ground ahead.
# The ants surge forward! Oh No, it's an ant stampede!!
# Some of the slower ants are trampled, and their poor little ant bodies are broken up into scattered bits.
# The resulting carnage looks like this:
def deadAntCount(ants):
    return max(ants.replace("ant", "").count(i) for i in "ant")

# Here you have to do some mathematical operations on a "dirty string". This kata checks some
# basics, it's not too difficult.
# So what to do?
# Input: String which consists of two positive numbers (doubles) and exactly one operator
# like +, -, * or / always between these numbers. The string is dirty, which means that
# there are different characters inside too, not only numbers and the operator. You have to combine
# all digits left and right, perhaps with "." inside (doubles), and to calculate the
# result which has to be rounded to an integer and converted to a string at the end.
import re
def calculate_string(st):
    return str(int(round(eval(re.sub(r'[^-+*/\d.]', '', st)))))

# Although this Kata is not part of an official Series, you may want to complete this
# Kata before attempting this one as these two Kata are deeply related.
# Preloaded
# Preloaded for you is a class, struct or derived data type Node ( depending on the language ) used to
# construct linked lists in this Kata:
from functools import reduce
def linked_list_from_string(s, split=" -> "):
    return reduce(lambda i, j: Node(j, i), map(int, s.split(split)[-2::-1]), None)

# Write a function that determines whether the passed in sequences are similar. Similar means
# they contain the same elements, and the same number of occurrences of elements.
def arrays_similar(seq1, seq2):
    l1 = ''.join(str(i) for i in seq1)
    l2 = ''.join(str(i) for i in seq2)
    return set(seq1) == set(seq2) and sorted(l1) == sorted(l2)

# You're fed up about changing the version of your software manually. Instead, you
# will create a little script that will make it for you.
def next_version(version):
    if version.count('.') == 0:
        return str(int(version) + 1)
    elif int(version[-1]) < 9:
        return f"{version[0:-1]}{str(int(version[-1]) + 1)}"
    return next_version(version[0:-2]) + '.0'

# Write a function that will take in any array and reverse it.
# Sounds simple doesn't it?
# NOTES:
# Array should be reversed in place! (no need to return it)
# Usual builtins have been deactivated. Don't count on them.
# You'll have to do it fast enough, so think about performances
def reverse(seq):
    l = list()
    for _ in range(len(seq)): l.append(seq.pop())
    seq.extend(l)

# Write a function that takes a string and returns an array of the repeated
# characters (letters, numbers, whitespace) in the string.
# If a charater is repeated more than once, only show it once in the result array.
# Characters should be shown by the order of their first repetition. Note that this may be different
# from the order of first appearance of the character.
# Characters are case sensitive.
# For F# return a "char list"
def remember(str_):
    return list(v for k, v in enumerate(str_) if str_[:k].count(v) == 1)

# Given string s, which contains only letters from a to z in lowercase.
# A set of alphabet is given by abcdefghijklmnopqrstuvwxyz.
# 2 sets of alphabets mean 2 or more alphabets.
# Your task is to find the missing letter(s). You may need to output them by
# the order a-z. It is possible that there is more than one missing letter from more than one set of alphabet.
# If the string contains all of the letters in the alphabet, return an empty string ""
def missing_alphabets(s):
    return ''.join(sorted(i * (max(s.count(j) for j in s) - s.count(i)) for i in 'abcdefghijklmnopqrstuvwxyz'))

# Consider a sequence of numbers a0, a1, ..., an, in which an element is equal to the sum
# of squared digits of the previous element. The sequence ends once an element that has already been
# in the sequence appears again.
# Given the first element a0, find the length of the sequence.
def square_digits_sequence(n):
    s = set()
    while n not in s:
        s.add(n)
        n = sum(int(i)**2 for i in str(n))
    return len(s) + 1

# You are given a table, in which every key is a stringified number, and
# each corresponding value is an array of characters, e.g.
# Create a function that returns a table with the same keys, but each character
# should appear only once among the value-arrays, e.g.
def remove_duplicate_ids(d):
    s = set()
    return {j:[s.add(i) or i for i in d[j] if i not in s] for j in sorted(d, key=int)[::-1]}

# Define a method that accepts 2 strings as parameters. The method returns the first string sorted by the second.
def sort_string(st, order):
    return ''.join(sorted(list(st), key=lambda x: list(order).index(x) if x in order else len(order)))

# We'll create a function that takes in two parameters:
# a sequence (length and types of items are irrelevant)
# a function (value, index) that will be called on members of the sequence and
# their index. The function will return either true or false.
# Your function will iterate through the members of the sequence in order
# until the provided function returns true; at which point your function will return that item's index.
# If the function given returns false for all members of the sequence, your function should return -1.
def find_in_array(seq, predicate):
    for k, v in enumerate(seq):
        if predicate(v, k): return k
    return -1

# You will be given a string of English digits "stuck" together, like this:
# "zeronineoneoneeighttwoseventhreesixfourtwofive"
# Your task is to split the string into separate digits:
def uncollapse(digits):
    w, f = '', ''
    for i in digits:
        w += i
        if w in ['zero', 'nine', 'one', 'eight', 'two', 'seven', 'three', 'six', 'four', 'five']:
            f += w + ' '
            w = ''
    return f[:-1]

# Linked Lists - Sorted Insert
# Write a SortedInsert() function which inserts a node into the correct location of a
# pre-sorted linked list which is sorted in ascending order. SortedInsert takes
# the head of a linked list and data used to create a node as arguments. SortedInsert() should
# also return the head of the list.
class Node(object):
    def __init__(self, data, next=None):
        self.data = data
        self.next = next
def sorted_insert(head, data):
    if not head or data < head.data:
        return Node(data, head)
    else:
        head.next = sorted_insert(head.next, data)
        return head

# Given an array, return the reversed version of the array (a different kind of reverse though), you
# reverse portions of the array, you'll be given a length
# argument which represents the length of each portion you are to reverse.
def sel_reverse(arr, l):
    return [j for i in range(0, len(arr), l) for j in arr[i:i+l][::-1]] if l != 0 else arr

# You have to create a function namedone_two (oneTwo for Java or Preloaded.OneTwo for C#) that
# returns 1 or 2 with equal probabilities. one_two is already defined in a global scope
# and can be called everywhere.
# Your goal is to create a function named one_two_three (oneTwoThree for Java or OneTwoThree for C#) that
# returns 1, 2 or 3 with equal probabilities using only the one_two function.
# Do not try to cheat returning repeating non-random sequences. There is a randomness
# test especially for this case.
def one_two_three():
    i, j = one_two(),one_two()-1
    return one_two_three() if i == j else i + j

# Dave has a lot of data he is required to apply filters to, which are simple enough,
# but he wants a shorter way of doing so.
class list(list):
    def even(self):
        res = []
        for x in self:
            if type(x) == int and x % 2 == 0:
                res.append(x)
        return res
    def odd(self):
        res = []
        for x in self:
            if type(x) == int and x % 2 == 1:
                res.append(x)
        return res
    def under(self, r):
        res = []
        for x in self:
            if type(x) == int and x < r:
                res.append(x)
        return res
    def over(self, r):
        res = []
        for x in self:
            if type(x) == int and x > r:
                res.append(x)
        return res
    def in_range(self, r1, r2):
        res = []
        for x in self:
            if type(x) == int and r1 <= x <= r2:
                res.append(x)
        return res

# Implement the method countIf (count_if in PHP and Python), which accepts a linked list
# (head) and a predicate function, and returns the number of elements which apply to the given predicate.
# For example: Given the list: 1 -> 2 -> 3, and the predicate x => x >= 2, countIf /
# count_if should return 2, since x >= 2 applies to both 2 and 3.
def count_if(head, func):
    c = 0
    while head:
        c += func(head.data)
        head = head.next
    return c

# You have been hired by a company making electric garage doors. Accidents with the present product
# line have resulted in numerous damaged cars, broken limbs and several killed pets.
# Your mission is to write a safer version of their controller software.
def controller(events):
    out, s, dir, moving = [], 0, 1, False
    for i in events:
        if i == 'O': dir *= -1
        elif i == 'P': moving = not moving
        if moving: s += dir
        if s in [0,5]: moving, dir = False, 1 if s == 0 else -1
        out.append(str(s))
    return ''.join(out)

# Note: This kata is a translation of this (Java)
# one: http://www.codewars.com/kata/rotate-array. I have not translated this
# first one as usual because I did not solved it, and I fear not being able to solve it
# (Java is not my cup of... tea). @cjmcgraw, if you want to use my translation on your kata feel free to use it.
# Create a function named "rotate" that takes an array and returns a new one
# with the elements inside rotated n spaces.
# If n is greater than 0 it should rotate the array to the right. If n
# is less than 0 it should rotate the array to the left. If n is 0, then it should return the array unchanged.
def rotate(arr, n):
    n = n % len(arr)
    return arr[-n:] + arr[:-n]

# Given a string, remove any characters that are unique from the string.
def only_duplicates(string):
    return ''.join(i for i in string if string.count(i) > 1)

# You are given an array of integers. Your task is to sort odd numbers within
# the array in ascending order, and even numbers in descending order.
# Note that zero is an even number. If you have an empty array, you need to return it.
def sort_array(l):
    e = sorted(i for i in l if i % 2 == 0)
    o = sorted((i for i in l if i % 2 != 0), reverse=True)
    return [(e if i % 2 == 0 else o).pop() for i in l]

# An anagram is a word, a phrase, or a sentence formed from another by rearranging its letters.
# An example of this is "angel", which is an anagram of "glean".
# Write a function that receives an array of words, and returns the total
# number of distinct pairs of anagramic words inside it.
from collections import Counter
def anagram_counter(words):
    return sum(i *(i-1)// 2 for i in Counter(''.join(sorted(j)) for j in words).values())

#  happy number is a number defined by the following process: starting with any positive integer, replace the
#  number by the sum of the squares of its digits, and repeat the process until the number equals
#  1 (where it will stay), or it loops endlessly in a cycle which does not include 1.
# Those numbers for which this process ends in 1 are happy numbers, while those that do
# not end in 1 are unhappy numbers (or sad numbers) (Wikipedia).
# Write a function that takes n as parameter and return true if and only if n is an happy number, false otherwise.
def is_happy(n):
    s = set()
    while n not in s:
        s.add(n)
        n = sum(int(i)**2 for i in str(n))
    return n == 1

# Your task is to reduce a list of numbers to one number.
# For this you get a list of rules, how you have to reduce the numbers.
# You have to use these rules consecutively. So when you get to the end of the list of rules,
# you start again at the beginning.
def reduce_by_rules(lst, rules):
    l, r = len(rules), lst[0]
    for k, v in enumerate(lst[1:]):
        r = rules[k % l](r, v)
    return r

# Complete function splitOddAndEven, accept a number n(n>0), return an array that
# contains the continuous parts of odd or even digits.
# Please don't worry about digit 0, it won't appear ;-)
import re
def split_odd_and_even(n):
    return [int(i) for i in re.findall(r"([2468]+|[13579]+)", str(n))]

# In this task, you need to restore a string from a list of its copies.
# You will receive an array of strings. All of them are supposed to be
# the same as the original but, unfortunately, they were corrupted which means some of
# the characters were replaced with asterisks ("*").
# You have to restore the original string based on non-corrupted information you have. If
# in some cases it is not possible to determine what the original
# character was, use "#" character as a special marker for that.
# If the array is empty, then return an empty string.
def assemble(input):
    w = list(input[0]) if input else []
    for i in input:
        for k, i in enumerate(i):
            w[k] = i if w[k] == '*' else w[k]
    return ''.join(w).replace('*', '#')

# Variation of this nice kata, the war has expanded and become dirtier and meaner; both
# even and odd numbers will fight with their pointy 1s. And negative integers
# are coming into play as well, with, ça va sans dire, a negative contribution
# (think of them as spies or saboteurs).
# A number's strength is determined by the number of set bits (1s) in its binary representation.
# Negative integers work against their own side so their strength is negative.
# For example -5 = -101 has strength -2 and +5 = +101 has strength +2.
def bits_war(numbers):
    d = sum(sum(map(int, bin(abs(i))[2:])) * (-1)**(i < 0) * (-1)**(i%2 == 0) for i in numbers)
    return ["evens win", "tie", "odds win"][(d >= 0) + (d > 0)]

# An array is circularly sorted if the elements are sorted in ascending order, but displaced, or
# rotated, by any number of steps.
# Complete the function/method that determines if the given array of integers is circularly sorted.
def circularly_sorted(arr):
    return sum(i > j for i, j in zip(arr, arr[1:]+[arr[0]])) < 2

# An ATM ran out of 10 dollar bills and only has 100, 50 and 20 dollar bills.
# Given an amount between 40 and 10000 dollars (inclusive) and assuming that
# the ATM wants to use as few bills as possible, determinate
# the minimal number of 100, 50 and 20 dollar bills the ATM needs to dispense (in that order).
def withdraw(price):
    return [price//100, 0, price%100//20] if price % 20==0 else [(price-50)//100,1, (price-50)%100//20]

# Create a function that takes an argument n and sums even
# Fibonacci numbers up to n's index in the Fibonacci sequence.
from gmpy2 import fib
def sum_fibs(n):
    return sum(i for i in map(fib, range(n + 1)) if i % 2 == 0)

# If we write out the digits of "60" as English words we get "sixzero"; the
# number of letters in "sixzero" is seven. The number of letters in "seven" is five. The
# number of letters in "five" is four. The number of letters in "four" is four:
# we have reached a stable equilibrium.
# Note: for integers larger than 9, write out the names of each digit in a single
# word (instead of the proper name of the number in English). For example, write
# 12 as "onetwo" (instead of twelve), and 999 as "nineninenine" (instead of nine hundred and ninety-nine).
# For any integer between 0 and 999, return an array showing the path from that integer to a stable equilibrium:
def numbers_of_letters(n):
    l = ["zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"]
    s = ''.join(l[i] for i in map(int, str(n)))
    return [s] + (numbers_of_letters(len(s)) if len(s) != n else [])

# The Padovan sequence is the sequence of integers defined by the initial values
def padovan(n):
    x = y = z = 1
    for _ in range(n - 2): x, y, z = y, z, x + y
    return z

# Write an algorithm that takes an array and moves all of the zeros to the end, preserving the
# order of the other elements.
def move_zeros(lst):
    return [i for i in lst if i != 0] + [i for i in lst if i == 0]

# Move the first letter of each word to the end of it, then add "ay" to the
# end of the word. Leave punctuation marks untouched.
def pig_it(text):
    w = ' '.join(i[1:] + i[0] + 'ay' for i in text.split())
    return w if w[-3] not in '!.,?' else w[:-2]

# Write a function, which takes a non-negative integer (seconds) as input and returns the
# time in a human-readable format (HH:MM:SS)
def make_readable(seconds):
    return "%02d:%02d:%02d" % (seconds / 3600, seconds / 60 % 60, seconds % 60)

# Write a function that takes a string of parentheses, and determines if the
# order of the parentheses is valid. The function should return true if the
# string is valid, and false if it's invalid.
def valid_parentheses(string):
    c = 0
    for i in string:
        if i == "(": c += 1
        elif i == ")": c -= 1
        if c < 0: return False
    return c == 0

# Write a function named first_non_repeating_letter that takes a string input, and returns the first
# character that is not repeated anywhere in the string.
# For example, if given the input 'stress', the function should return 't', since
# the letter t only occurs once in the string, and occurs first in the string.
# As an added challenge, upper- and lowercase letters are considered the same character,
# but the function should return the correct case for the initial letter. For
# example, the input 'sTreSS' should return 'T'.
# If a string contains all repeating characters, it should return an empty string ("") or None
# -- see sample tests.
def first_non_repeating_letter(string):
    try:
        return [i for i in string if string.lower().count(i.lower()) == 1][0]
    except:
        return ''

# My friend John and I are members of the "Fat to Fit Club (FFC)". John is worried because
# each month a list with the weights of members is published and each month
# he is the last on the list which means he is the heaviest.
# I am the one who establishes the list so I told him: "Don't worry any more,
# I will modify the order of the list". It was decided to attribute a "weight"
# to numbers. The weight of a number will be from now on the sum of its digits.
# For example 99 will have "weight" 18, 100 will have "weight" 1 so in the list 100 will come before 99.
# Given a string with the weights of FFC
# members in normal order can you give this string ordered by "weights" of these numbers?
def order_weight(_str):
    return ' '.join(sorted(sorted(_str.split()), key=lambda x: sum(int(i) for i in x)))

# Pete likes to bake some cakes. He has some recipes and ingredients. Unfortunately
# he is not good in maths. Can you help him to find out, how many cakes he could bake considering his recipes?
# Write a function cakes(), which takes the recipe (object) and the available ingredients
# (also an object) and returns the maximum number of cakes Pete can bake (integer).
# For simplicity there are no units for the amounts (e.g. 1 lb of flour
# or 200 g of sugar are simply 1 or 200). Ingredients that are not present in the objects,
# can be considered as 0.
def cakes(recipe, available):
    return min([available[i] // recipe[i] if i in available else 0 for i in recipe])

# The marketing team is spending way too much time typing in hashtags.
# Let's help them with our own Hashtag Generator!
# Here's the deal:
# It must start with a hashtag (#).
# All words must have their first letter capitalized.
# If the final result is longer than 140 chars it must return false.
# If the input or the result is an empty string it must return false.
def generate_hashtag(s):
    w = '#'+''.join(i.title() for i in s.split())
    return w if len(w) <= 140 and len(w) > 1 else False

# Write a program that will calculate the number of trailing zeros in a factorial of a given number.
# N! = 1 * 2 * 3 *  ... * N
# Be careful 1000! has 2568 digits...
def zeros(n):
    integer = n//5
    return integer + zeros(integer) if integer else 0

# Complete the function scramble(str1, str2) that returns true if a portion
# of str1 characters can be rearranged to match str2, otherwise returns false.
# Notes:
# Only lower case letters will be used (a-z). No punctuation or digits will be included.
# Performance needs to be considered.
def scramble(s1,s2):
    return not any(s1.count(i) < s2.count(i) for i in set(s2))

# The rgb function is incomplete. Complete it so that passing in RGB decimal values will
# result in a hexadecimal representation being returned. Valid decimal values for RGB are 0 - 255.
# Any values that fall out of that range must be rounded to the closest valid value.
# Note: Your answer should always be 6 characters long, the shorthand with 3 will not work here.
def rgb(r, g, b):
    if r > 255: r = 255
    elif r < 0: r = 0
    if g > 255: g = 255
    elif g < 0: g = 0
    if b > 255: b = 255
    elif b < 0: b = 0
    return '%02x%02x%02x'.upper() % (r, g, b)

# The drawing shows 6 squares the sides of which have a length of
# 1, 1, 2, 3, 5, 8. It's easy to see that the sum of the perimeters
# of these squares is : 4 * (1 + 1 + 2 + 3 + 5 + 8) = 4 * 20 = 80
# Could you give the sum of the perimeters of all the squares in a rectangle
# when there are n + 1 squares disposed in the same manner as in the drawing:
def perimeter(n):
    l = []
    a, b = 0, 1
    for i in range(n+1):
        a, b = b, a + b
        l.append(a)
    return sum(l) * 4

# In this example you have to validate if a user input string is alphanumeric.
# The given string is not nil/null/NULL/None, so you don't have to check that.
# The string has the following conditions to be alphanumeric:
# At least one character ("" is not valid)
# Allowed characters are uppercase / lowercase latin letters and digits from 0 to 9
# No whitespaces / underscore
def alphanumeric(p):
    return all(i.isdigit() or i.isalpha() for i in p) and len(p) > 0

# We want to create a function that will add numbers together when called in succession.
class add(int):
    def __call__(self, n):
        return add(self + n)

# You need to write regex that will validate a password to make sure it meets the following criteria:
# At least six characters long
# contains a lowercase letter
# contains an uppercase letter
# contains a digit
# only contains alphanumeric characters (note that '_' is not alphanumeric)
regex="^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[^\W_]{6,}$"

# Find all integers between m and n (m and n integers with 1 <= m <= n) such that the sum
# of their squared divisors is itself a square.
# We will return an array of subarrays or of tuples (in C an array of Pair) or a string. The
# subarrays (or tuples or Pairs) will have two elements: first the number the squared divisors
# of which is a square and then the sum of the squared divisors.
import math
def divisors(n):
    d = [1, n]
    for i in range(2, int(math.sqrt(n))+1):
        if n % i == 0: d.extend([i, int(n/i)])
    return set(d)
def list_squared(m, n):
    l = []
    for num in range(m, n):
        s = sum(i**2 for i in divisors(num))
        if math.sqrt(s).is_integer(): l.append([num, s])
    return l

# Given a list of integers and a single sum value, return the first two
# values (parse from the left please) in order of appearance that add up to form the sum.
# If there are two or more pairs with the required sum, the
# pair whose second element has the smallest index is the solution.
def sum_pairs(lst, s):
    l = set()
    for i in lst:
        if s - i in l: return [s - i, i]
        l.add(i)

# This algorithm serves welll its educative purpose but it's tremendously inefficient, not
# only because of recursion, but because we invoke the fibonacci function twice, and the right branch
# of recursion (i.e. fibonacci(n-2)) recalculates all the Fibonacci numbers
# already calculated by the left branch (i.e. fibonacci(n-1)).
# This algorithm is so inefficient that the time to calculate any Fibonacci number over
# 50 is simply too much. You may go for a cup of coffee or go take a nap while
# you wait for the answer. But if you try it here in Code Wars you will most
# likely get a code timeout before any answers.
from functools import lru_cache
@lru_cache(None)
def fibonacci(n):
    if n in [0, 1]:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)


# Define a function that takes in two non - negative integers aaa and bbb and returns the last decimal digit
# of aba ^ ba b of 979 ^ 79 7 is 999, since 97 = 47829699 ^ 7 = 47829699 7, which has over
# 109210 ^ {92} p10 92 decimal digits, is 666. Also, please take 000 ^ 00 0 to be 111.
# You may assume that the input will always be valid.
def last_digit(n1, n2):
    return pow(n1, n2, 10)

# Implement a function that receives two IPv4 addresses, and returns the number
# of addresses between them (including the first one, excluding the last one).
# All inputs will be valid IPv4 addresses in the form of strings. The last address will
# always be greater than the first one.
from ipaddress import ip_address
def ips_between(start, end):
    return int(ip_address(end)) - int(ip_address(start))

# This problem takes its name by arguably the most important event in the life of the
# ancient historian Josephus: according to his tale, he and his 40 soldiers were trapped in a cave
# by the Romans during a siege.
# Refusing to surrender to the enemy, they instead opted for mass suicide, with a twist: they
# formed a circle and proceeded to kill one man every three, until one last man was left
# (and that it was supposed to kill himself to end the act).
# Well, Josephus and another man were the last two and, as we now know every
# detail of the story, you may have correctly guessed that they didn't exactly follow through the original idea.
# You are now to create a function that returns a Josephus permutation, taking as parameters the
# initial array/list of items to be permuted as if they were in a circle and counted
# out every k places until none remained.
def josephus(xs, k):
    i, j = 0, []
    while len(xs) > 0:
        i = (i + k - 1) % len(xs)
        j.append(xs.pop(i))
    return j

# Complete the function that
# accepts two integer arrays of equal length
# compares the value each member in one array to the corresponding member in the other
# squares the absolute value difference between those two values
# and returns the average of those squared absolute value difference between each member pair.
def solution(a, b):
    return sum((k - v)**2 for k, v in zip(a, b)) / len(a)

# At a job interview, you are challenged to write an algorithm to check if a given string, s,
# can be formed from two other strings, part1 and part2.
# The restriction is that the characters in part1 and part2 should be in the same order as in s.
# The interviewer gives you the following example and tells you to figure out the rest from the given test cases.
def is_merge(s, part1, part2):
    if not part1: return s == part2
    if not part2: return s == part1
    if not s: return part1 + part2 == ''
    if s[0] == part1[0] and is_merge(s[1:], part1[1:], part2): return True
    if s[0] == part2[0] and is_merge(s[1:], part1, part2[1:]): return True
    return False

# There is an array of strings. All strings contains similar letters except one. Try to find it!
from collections import Counter
def find_uniq(arr):
    r = Counter(''.join(arr)).most_common()
    return ''.join([i for i in arr if r[-1][0] in i])

# Coding decimal numbers with factorials is a way of writing out numbers in
# a base system that depends on factorials, rather than powers of numbers.
# In this system, the last digit is always 0 and is in base 0!. The digit before that is either
# 0 or 1 and is in base 1!. The digit before that is either 0, 1, or 2 and
# is in base 2!, etc. More generally, the nth-to-last digit is always 0, 1, 2, ..., n and is in base n!.
from math import factorial
from itertools import dropwhile
DIGITS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
BASIS = [factorial(i) for i in range(len(DIGITS))]
def dec2FactString(nb):
    l = []
    for i in reversed(BASIS):
        l.append(DIGITS[nb // i])
        nb %= i
    return "".join(dropwhile(lambda x: x == "0", l))
def factString2Dec(string):
    return sum(BASIS[k] * DIGITS.index(v) for k, v in enumerate(reversed(string)))

# Carol's boss Bob thinks he is very smart. He says he made an app which renders
# messages unreadable without changing any letters, only by adding some new ones, while preserving
# message integrity (i. e. the original message can still be retrieved).
# He gave some limited access to his app to Carol to challenge her, and hinted
# that if Carol cannot crack this simple task, she might be fired.
# Carol was trying to crack this code herself, but got too tired,
# so she came to you for help. However, she succeeded to hack Bob's app
# and found a data field called 'marker'. She thinks it can be helpful for cracking Bob's app.
# Help Carol keep her job!
def decoder(encoded, marker):
    return ''.join(encoded.split(marker)[::2]) + ''.join(encoded.split(marker)[1::2])[::-1]

# Some of you might remember spending afternoons playing Street Fighter 2 in some Arcade back in
# the 90s or emulating it nowadays with the numerous emulators for retro consoles.
# Can you solve this kata? Suuure-You-Can!
# UPDATE: a new kata's harder version is available here.
# The Kata
# You'll have to simulate the video game's character selection screen behaviour, more specifically
# the selection grid. Such screen looks like this:
def street_fighter_selection(fighters, pos, moves):
    l, row, col, m = [], pos[0], pos[1], {"up":(-1, 0), "down":(1, 0), "right":(0, 1), "left":(0,-1)}
    for i in moves:
        row, col = min(max(row + m[i][0], 0), 1), (col + m[i][1]) % 6
        l.append(fighters[row][col])
    return l

# Write an algorithm that will identify valid IPv4 addresses in dot-decimal format.
# IPs should be considered valid if they consist of four octets, with values between 0 and 255, inclusive.
import ipaddress
def is_valid_IP(s):
    try:
        return bool(ipaddress.ip_address(s))
    except:
        return False

# Time to write your first Esolang interpreter :D
def my_first_interpreter(code):
    c, w = 0, ""
    for i in code:
        if i == "+": c += 1
        elif i == ".": w += chr(c % 256)
    return w

# Substitute two equal letters by the next letter of the alphabet (two letters convert to one):
def last_survivors(s):
    w = "abcdefghijklmnopqrstuvwxyza"
    for i in s:
        if s.count(i) > 1:
            s = s.replace(i, "", 2) + w[w.index(i) + 1]
            return last_survivors(s)
    return s

# You will be given a list of objects. Each object has type, material,
# and possibly secondMaterial. The existing materials are: paper, glass, organic, and plastic.
# Your job is to sort these objects across the 4 recycling bins according to their
# material (and secondMaterial if it's present), by listing the type's of objects that should go into those bins.
def recycle(a):
    dic = {'paper': [], 'glass': [], 'organic': [], 'plastic': []}
    for i in a:
        dic[i['material']].append(i['type'])
        if 'secondMaterial' in i: dic[i['secondMaterial']].append(i['type'])
    return tuple(dic.values())

# So, we need a simple function that converts a string representing a
# number (possibly with a $ sign in front of it) into the number itself.
def money_value(s):
    try:
        return float(s.replace("$", "").replace(" ", ""))
    except:
        return 0.0

# Write a function that accepts msg string and returns local tops of string from the highest to the lowest.
# The string's tops are from displaying the string in the below way:
def tops(msg):
    return ''.join(msg[i * (2 * i -1)] for i in range(int(((8 * len(msg) + 1)**.5 + 1) / 4), 0, -1))

# You just got done with your set at the gym, and you are wondering how
# much weight you could lift if you did a single repetition. Thankfully, a
# few scholars have devised formulas for this purpose (from Wikipedia) :
def calculate_1RM(w, r):
    return w if r == 1 else 0 if r == 0 else max(round(w * (1 + r/30)), round((100*w) / (101.3 - 2.67123*r)), round(w*r**0.10))

# Implement a function, so it will produce a sentence out of the given parts.
def make_sentences(parts):
    return ' '.join(parts).replace(' ,', ',').rstrip(' .') + '.'

# You must check within a string (s) to find all of the mating pairs, returning a
# list/array of the string containing valid mating pairs and a boolean indicating whether the total
# number of bears is greater than or equal to x.
from re import findall
def bears(x, s):
    return ["".join(findall("8B|B8", s)), len("".join(findall("8B|B8", s))) >= x]

# What date corresponds to the nth day of the year?
# The answer depends on whether the year is a leap year or not.
# Write a function that will help you determine the date if you know
#  the number of the day in the year, as well as whether the year is a leap year or not.
# The function accepts the day number and a boolean value isLeap as
# arguments, and returns the corresponding date of the year as a string "Month, day".
# Only valid combinations of a day number and isLeap will be tested.
from datetime import *
def get_day(day, is_leap):
    return (date(2019 + is_leap, 1, 1) + timedelta(day - 1)).strftime("%B, %-d")

# You must create a method that can convert a string from any format into PascalCase. This must support symbols too.
# Don't presume the separators too much or you could be surprised.
import re
def camelize(s):
    return "".join(i.capitalize() for i in re.split("\W|_", s))

# Build Tower by the following given arguments:
# number of floors (integer and always greater than 0)
# block size (width, height) (integer pair and always greater than (0, 0))
def tower_builder(n_floors, block_size):
    w, h = block_size
    l = []
    n = n_floors
    for i in range(n_floors):
        n -= 1
        for j in range(h): l.append(' '*n * w + '*' * (i * 2 + 1) * w + ' ' * n* w)
    return l

# The code provided has a method hello which is supposed to show only those attributes
# which have been explicitly set. Furthermore, it is supposed to say them in the same order they were set.
# But it's not working properly.
class Dinglemouse(object):

    def __init__(self):
        self.name = None
        self.sex = None
        self.age = None
        self.hell = 'Hello.'

    def setAge(self, age):
        if self.age == None:
            self.hell = self.hell + ' I am {age}.'
        self.age = age
        return self

    def setSex(self, sex):
        if self.sex == None:
            self.hell = self.hell + ' I am {sex}.'
        self.sex = "male" if sex == 'M' else "female"
        return self

    def setName(self, name):
        if self.name == None:
            self.hell = self.hell + ' My name is {name}.'
        self.name = name
        return self

    def hello(self):
        return self.hell.format(age=self.age, sex=self.sex, name=self.name)

# You will get two integers n (width) and m (height) and your task is to
# draw the following pattern. Each line is seperated with a newline (\n)
# Both integers are equal or greater than 1; no need to check for invalid parameters.
def dot(n, m):
    return ("+---" * n + "+\n" + "| o " * n + "|\n") * m + ("+---" * n + "+")

# Are you a file extension master? Let's find out by checking if Bill's files are
# images or audio files. Please use regex if available natively for your language.
# You will create 2 string methods:
# isAudio/is_audio, matching 1 or + uppercase/lowercase letter(s) (combination possible), with
# the extension .mp3, .flac, .alac, or .aac.
# isImage/is_image, matching 1 or + uppercase/lowercase letter(s) (combination possible), with
# the extension .jpg, .jpeg, .png, .bmp, or .gif.
# Note that this is not a generic image/audio files checker. It's
# meant to be a test for Bill's files only. Bill doesn't like
# punctuation. He doesn't like numbers, neither. Thus, his filenames are letter-only
# Rules
# It should return true or false, simply.
# File extensions should consist of lowercase letters and numbers only.
# File names should consist of letters only (uppercase, lowercase, or both)
def is_audio(file_name):
    return any(file_name.endswith(i) for i in ['.mp3', '.flac', '.alac', '.aac']) and all(i.isalpha() for i in file_name.split('.')[0])
def is_img(file_name):
    return any(file_name.endswith(i) for i in ['.jpg', '.jpeg', '.png', '.bmp', '.gif']) and all(i.isalpha() for i in file_name.split('.')[0])

# In this Kata, you have to design a simple routing class for a web framework.
# The router should accept bindings for a given url, http method and an action.
# Then, when a request with a bound url and method comes in, it should return the result of the action.
class Router:
    def __init__(self):
        self._routes = {}
    def bind(self, url, method, a):
        self._routes[(url, method)] = a
    def runRequest(self, url, method):
        return self._routes.get((url, method), lambda: "Error 404: Not Found")()

# for i from 1 to n, do i % m and return the sum
def f(n, m):
    return (n // m) * (m - 1) * m / 2 + (n % m) * (n % m + 1) / 2

# Given an array of strings and a character to be used as border, output the frame with the content inside.
# Notes:
# Always keep a space between the input string and the left and right borders.
# The biggest string inside the array should always fit in the frame.
# The input array is never empty.
def frame(text, char):
    text_lens = [len(i) for i in text]
    longest_len = max(text_lens)
    frame_list = [char*(longest_len + 4)]
    for i in text:
         frame_list.append("{} {}{} {}".format(char, i, " " * (longest_len - len(i)), char))
    frame_list.append(char*(longest_len + 4))
    return "\n".join(frame_list)

# Your goal is to create a function to format a number given a template; if the number is not present,
# use the digits 1234567890 to fill in the spaces.
# A few rules:
# the template might consist of other numbers, special characters or the like: you
# need to replace only alphabetical characters (both lower- and uppercase);
# if the given or default string representing the number is shorter than the template, just
# repeat it to fill all the spaces.
from itertools import cycle
def numeric_formatter(template, data='1234567890'):
    data = cycle(data)
    return ''.join(next(data) if i.isalpha() else i for i in template)

# Run-length encoding (RLE) is a very simple form of lossless data compression
# in which runs of data are stored as a single data value and count.
# A simple form of RLE would encode the string "AAABBBCCCD" as "3A3B3C1D" meaning,
# first there are 3 A, then 3 B, then 3 C and last there is 1 D.
# Your task is to write a RLE encoder and decoder using this technique. The texts
# to encode will always consist of only uppercase characters, no numbers.
import re
def encode(s):
    return "".join(f"{len(k)}{v}" for k, v in re.findall(r"((.)\2*)", s))

def decode(s):
    return "".join(int(k) * v for k, v in re.findall(r"(\d+)(\w)", s))

# Write a function that returns the count of characters that have to
# be removed in order to get a string with no consecutive repeats.
# Note: This includes any characters
def count_repeats(txt):
    return sum(1 if i == j else 0 for i, j in zip(txt, txt[1:]))

# Create a method named "rotate" that returns a given array with the elements inside the array rotated n spaces.
# If n is greater than 0 it should rotate the array to the right. If n is less than 0 it should rotate the array
# to the left. If n is 0, then it should return the array unchanged.
def rotate(data, n):
    if data:
        c = -n % len(data)
        return data[c:] + data[:c]
    return []

# Given two strings, the first being a random string and
# the second being the same as the first, but with three added
# characters somewhere in the string (three same characters),
# Write a function that returns the added character
def added_char(s1, s2):
    return [i for i in s2 if s2.count(i) >= 3 and s1.count(i) == s2.count(i)-3][0]

# The hamming distance between a pair of numbers is the number of binary bits that differ in their binary notation.
def hamming_distance(a, b):
    return bin(a ^ b).count('1')

# A masked number is a string that consists of digits and one asterisk (*) that
# should be replaced by exactly one digit. Given a masked number s, find
# all the possible options to replace the asterisk with a digit to produce an integer divisible by 6.
import sys
sys.set_int_max_str_digits(0)
def is_divisible_by_6(s):
    return [str(int(s.replace('*',str(i)))) for i in range(10) if int(s.replace('*',str(i)))%6==0]

# I want to know the size of the longest consecutive elements of X in Y.
# You will receive two arguments: items and key. Return the length of the
# longest segment of consecutive keys in the given items.
import re
def get_consective_items(item, key):
    return len(max(re.findall(f'{key}+', str(item)) or ['']))

# Given an array (or list) of scores, return the array of ranks for each value in the array.
# The largest value has rank 1, the second largest value has rank 2, and so on.
# Ties should be handled by assigning the same rank to all tied values. For example:
def ranks(a):
    return [sorted(a, reverse = True).index(i) + 1 for i in a]

# We are tracking down our rogue agent Matthew Knight also known as Roy Miller. He travels
# from places to places to avoid being tracked. Each of his travels are
# based on a list of itineraries in an unusual or incorrect order. The task
# is to determine the routes he will take in his every journey.
# Task
# You are given an array of routes of his itineraries. List down the only
# places where he will go in correct order based on his itineraries.
def find_routes(routes):
    d = dict(routes)
    r = list(d.keys() - d.values())
    while r[-1] in d: r.append(d[r[-1]])
    return ', '.join(r)

# Complete the method that will determine the minimum number of coins needed to make change
# for a given amount in American currency.
# Coins used will be half-dollars, quarters, dimes, nickels, and pennies, worth
# 50¢, 25¢, 10¢, 5¢ and 1¢, respectively. They'll be represented by the symbols
# H, Q, D, N and P (symbols in Ruby, strings in in other languages)
# The argument passed in will be an integer representing the value in cents. The return
# value should be a hash/dictionary/object with the symbols as keys, and the numbers of
# coins as values. Coins that are not used should not be included in the hash. If the
# argument passed in is 0, then the method should return an empty hash.
def make_change(amount):
    d = {}
    for k, v in (('H', 50), ('Q', 25), ('D', 10), ('N', 5), ('P', 1)):
        if amount >= v: d[k], amount = divmod(amount, v)
    return d1

# Your task is to give the number of total values for the odd
# terms of the sequence up to the n-th term (included). (The number n (of n-th term)
# will be given as a positive integer)
# The values 1 (one) is the only that is duplicated in the sequence and should be counted only once.
def count_odd_pentaFib(l):
    return 2 * (l // 6) + [0, 1, 2, 2, 2, 2][l % 6] - (l >= 2)

# Two strings a and b are called isomorphic if there is a one
# to one mapping possible for every character of a to every character of b.
# And all occurrences of every character in a map to same character in b.
# Task
# In this kata you will create a function that return True if two given strings are isomorphic
# to each other, and False otherwise. Remember that order is important.
# Your solution must be able to handle words with more than 10 characters.
from collections import Counter
def isomorph(s: str, t: str) -> bool:
        sc=len(Counter(s))
        st=len(Counter(t))
        if(sc!=st): return False
        else:
           s1=[]
           t1=[]
           m=[]
           ans=[]
           for i in s: s1.append(i)
           for i in t: t1.append(i)
           m.append(s1)
           m.append(t1)
        for i in s:
              if i in m[0]:
               a=m[0].index(i)
               ans.append(m[1][a])
        return "".join(ans) == t

# Two integer numbers are added using the column addition method. When using this
# method, some additions of digits produce non-zero carries to the next positions.
# Your task is to calculate the number of non-zero carries that will occur while adding the given numbers.
# The numbers are added in base 10.
def number_of_carries(a: int, b: int) -> int:
    s = sum(int(i) for i in str(a))
    s2 = sum(int(i) for i in str(b))
    s3 = sum(int(i) for i in str(a + b))
    return (s + s2 - s3) // 9

# For a given nonempty string s find a minimum substring t and the maximum number k,
# such that the entire string s is equal to t repeated k times.
# The input string consists of lowercase latin letters.
# Your function should return :
# a tuple (t, k) (in Python)
# an array [t, k] (in Ruby and JavaScript)
# in C, return k and write to the string t passed in parameter
def f(s):
    c = min([s.count(i) for i in s])
    w = ''
    for i in s:
        w += i
        if w * c == s: return (w, c)
    return (s, 1)

# You need to write a password generator that meets the following criteria:
# 6 - 20 characters long
# contains at least one lowercase letter
# contains at least one uppercase letter
# contains at least one number
# contains only alphanumeric characters (no special characters)
# Return the random password as a string.
# Note: "randomness" is checked by counting the characters used in the generated passwords - all characters
# should have less than 50% occurance. Based on extensive tests, the normal rate is around 35%.
from string import ascii_lowercase as LOWER, ascii_uppercase as UPPER, digits as DIGITS
from random import choice, shuffle, randint
def password_gen():
    w = [choice(UPPER), choice(LOWER), choice(DIGITS)] + [choice(UPPER+LOWER+DIGITS) for i in range(randint(3, 17))]
    shuffle(w)
    return "".join(w)

# You are given an array of unique numbers. The numbers represent points.
# The higher the number the higher the points. In the array [1,3,2] 3 is the highest
# point value so it gets 1st place. 2 is the second highest so it
# gets second place. 1 is the 3rd highest so it gets 3rd place.
# Your task is to return an array giving each number its rank in the array.
def rankings(arr):
    l = sorted(arr, reverse=True)
    return [l.index(i)+1 for i in arr]

# A palindrome is a word, phrase, number, or other sequence of
# characters which reads the same backward as forward. Examples of numerical palindromes are:
# 2332
# 110011
# 54322345
# For this kata, single digit numbers will not be considered numerical palindromes.
# For a given number num, write a function to test if the number contains a
# numerical palindrome or not and return a boolean (true if it does and false if does not).
# Return "Not valid" if the input is not an integer or is less than 0.
# Note: Palindromes should be found without permutating num.
import re
def palindrome(integer):
    if not isinstance(integer, int) or integer < 0: return 'Not valid'
    return re.search(r'(.)\1|(.).\2', str(integer)) is not None

# A list S will be given. You need to generate a list T from it by following the given process:
# Remove the first and last element from the list S and add them to the list T.
# Reverse the list S
# Repeat the process until list S gets emptied.
# The above process results in the depletion of the list S. Your task is to generate list T without
# mutating the input List S.
def arrange(s):
    return list(s[[i,-i,~i,i][i%4]//2]for i in range(len(s)))

# Just like in the "father" kata, you will have to return
# the last digit of the nth element in the Fibonacci sequence (starting with 1,1, to be extra clear,
# not with 0,1 or other numbers).
# You will just get much bigger numbers, so good luck bruteforcing your way through it ;)
def last_fib_digit(n):
    return int('011235831459437077415617853819099875279651673033695493257291'[n % 60])

# A palindrome is a word, phrase, number, or other sequence
# of characters which reads the same backward as forward. Examples of numerical palindromes are:
# 2332
# 110011
# 54322345
# For a given number num, return its closest numerical palindrome which can either be smaller or larger
# than num. If there are 2 possible values, the larger value should be returned. If
# num is a numerical palindrome itself, return it.
# For this kata, single digit numbers will NOT be considered numerical palindromes.
# Also, you know the drill - be sure to return "Not valid" if the input is not an integer or is less than 0.
def palindrome(num):
    if not isinstance(num, int) or num < 0: return 'Not valid'
    if num < 10: num = 11
    if str(num) == str(num)[::-1]: return num
    r, l, d = 0, 0, num
    while str(num)!=str(num)[::-1]: num, l = num+1, l+1
    while str(d)!=str(d)[::-1]: d, r = d-1, r+1
    return d if r<l else num

# Write a function that gets a sequence and value and returns true/false
# depending on whether the variable exists in a multidimentional sequence.
def locate(seq, v):
    return v in seq or any(locate(i, v) for i in seq if isinstance(i, list))

# In this Kata, you will be given a series of times at which an alarm sounds. Your
# task will be to determine the maximum time interval between alarms. Each alarm
# starts ringing at the beginning of the corresponding minute and rings for exactly one
# minute. The times in the array are not in chronological order. Ignore duplicate times, if any.
from datetime import datetime
def solve(arr):
    l = [datetime(2000, 1, 1, *map(int, x.split(':'))) for x in sorted(arr)]
    c = max(int((j - i).total_seconds() - 60) for i, j in zip(l, l[1:] + [l[0].replace(day=2)]))
    return '{:02}:{:02}'.format(*divmod(c//60, 60))

# Create a function running_average() that returns a callable function object. Update the series with
# each given value and calculate the current average.
def running_average():
    l = []
    def mean(n):
        l.append(n)
        return round(sum(l) / len(l), 2)
    return mean

# You'll be given a string of random characters (numbers, letters, and symbols).
# To decode this string into the key we're searching for:
# (1) count the number occurences of each ascii lowercase letter, and
# (2) return an ordered string, 26 places long, corresponding to the number of occurences
# for each corresponding letter in the alphabet.
def decrypt(w):
    return ''.join(str(w.count(i)) for i in "abcdefghijklmnopqrstuvwxyz")

# Write a function
# find_the_number_plate
# which takes the Customer ID as an argument, calculates the Number Plate corresponding to this ID and
# returns it as a string
def find_the_number_plate(i):
    return f'{97+i//999%26:c}{97+i//999//26%26:c}{97+i//999//26//26:c}{1+i%999:03}'

# You will be given an array of strings. The words in the array should mesh together where one or more
# letters at the end of one word will have the same letters (in the same order)
# as the next word in the array. But, there are times when all the words won't mesh.
def word_mesh(arr):
    r = ""
    for i, j in zip(arr, arr[1:]):
        while not i.endswith(j):
            j = j[:-1]
        if not j: return "failed to mesh"
        r += j
    return r

# Given a string, return the minimal number of parenthesis reversals needed to make balanced parenthesis.
def solve(s):
    if len(s) % 2: return -1
    l, c = 0, 0
    for i in s:
        if i == '(': l += 1
        else: l -= 1
        if l < 0:
            c += 1
            l += 2
    return c + l // 2

# A series or sequence of numbers is usually the product of a function and can either be infinite or finite.
# In this kata we will only consider finite series and you are required to return a code according to the
# type of sequence:
def sequence_classifier(l):
    if all(l[i] == l[i+1] for i in range(len(l)-1)): return 5
    if all(l[i] <  l[i+1] for i in range(len(l)-1)): return 1
    if all(l[i] <= l[i+1] for i in range(len(l)-1)): return 2
    if all(l[i] >  l[i+1] for i in range(len(l)-1)): return 3
    if all(l[i] >= l[i+1] for i in range(len(l)-1)): return 4
    return 0

# Make a custom esolang interpreter for the language Tick. Tick
# is a descendant of Ticker but also very different data and command-wise.
def interpreter(tape):
    d, c, w = {}, 0, ""
    for i in tape:
        if i == ">":  c += 1
        elif i == "<":  c -= 1
        elif i == "+":  d[c] = (d.get(c, 0) + 1) % 256
        elif i == "*":  w += chr(d[c])
    return w

# Gary likes pictures but he also likes words and reading. He has had a
# desire for a long time to see what words and books would look like if they could be seen as images.
# For this task you are required to take a continuous string that can consist of any
# combination of words or characters and then convert the words that make up this
# string into hexadecimal values that could then be read as colour values.
# A word is defined as a sequence of ASCII characters between two white
# space characters or the first or last word of a sequence of words.
def words_to_hex(words):
    return [f"#{i[:3].hex():0<6}" for i in words.encode().split()]

# Remember the game 2048? http://gabrielecirulli.github.io/2048/
# The main part of this game is merging identical tiles in a row.
# Implement a function that models the process of merging all of the tile values in a single row.
# This function takes the array line as a parameter and returns a
# new array with the tile values from line slid towards the front of the array (index 0) and merged.
# A given tile can only merge once.
# Empty grid squares are represented as zeros.
# Your function should work on arrays containing arbitrary number of elements.
def merge(line):
    l = [i for i in line if i != 0]
    for i in range(len(l) - 1):
        if l[i] == l[i + 1]: l = l[:i] + [l[i] + l[i + 1]] + l[i + 2:] + [0]
    return l + [0] * (len(line) - len(l))

# Given an array of integers, sum consecutive even numbers and consecutive odd numbers. Repeat the
# process while it can be done and return the length of the final array.
from itertools import groupby
def sum_groups(arr):
    l = list(sum(j) for i,j in groupby(arr, key = lambda x: x % 2 == 0))
    return len(l) if l == arr else sum_groups(l)

# The goal of this Kata is to write a function that will receive an array of strings as its
# single argument, then the strings are each processed and sorted (in desending order) based on the length
# of the single longest sub-string of contiguous vowels ( aeiouAEIOU ) that may
# be contained within the string. The strings may contain letters, numbers, special
# characters, uppercase, lowercase, whitespace, and there may be (often will be)
# multiple sub-strings of contiguous vowels. We are only interested in the single longest
# sub-string of vowels within each string, in the input array.
import re
def sort_strings_by_vowels(seq):
    return sorted(seq, reverse=True, key=lambda _: max((len(i) for i in re.findall(r'[aeiouAEIOU]+', _)), default=0))

# Spin-off of this kata, here you will have to figure out an efficient strategy to
# solve the problem of finding the sole duplicate number among an unsorted array/list of
# numbers starting from 1 up to n.
# Hints: a solution in linear time can be found; using the most intuitive ones to search
# for duplicates that can run in O(n²) time won't work.
def find_dup(arr):
    for i in arr:
        if arr.count(i) > 1: return i

# Given a string of integers, return the number of odd-numbered substrings that can be formed.
def solve(s):
    return sum(int(j) % 2 for i in range(len(s)) for j in s[i:])

# Given an integer n return "odd" if the number of its divisors is odd. Otherwise return "even".
# Note: big inputs will be tested.
def oddity(n):
    return 'odd' if n **.5 == int(n **.5) else 'even'

# Given two array of integers(arr1,arr2). Your task is going to find a
# pair of numbers(an element in arr1, and another element in arr2), their
# difference is as big as possible(absolute value); Again, you should to find a
# pair of numbers, their difference is as small as possible. Return the maximum and
# minimum difference values by an array: [  max difference,  min difference  ]
def max_and_min(arr1,arr2):
    l = [abs(i-j) for i in arr1 for j in arr2]
    return [max(l), min(l)]

# Shake the tree and count where the nuts land.
# Output - An array (same width as the tree) which indicates how many nuts fell at each position ^
from collections import Counter
def shake_tree(tree):
    l = [k for k,v in enumerate(tree[0]) if v == 'o']
    for char in tree[1:]:
        l = [i+1 if char[i] == '\\' else i-1 if char[i] == '/' else i for i in l if char[i] != '_']
    d = Counter(l)
    return [d[i] for i in range(len(tree[0]))]

# Given two words, how many letters do you have to remove from them to make them anagrams?
from collections import Counter
def anagram_difference(w1, w2):
    w1, w2 = Counter(w1), Counter(w2)
    return sum(((w1 - w2) + (w2 - w1)).values())

# Ka ka ka cypher is a cypher used by small children in some country. When a girl
# wants to pass something to the other girls and there are some boys nearby,
# she can use Ka cypher. So only the other girls are able to understand her.
# She speaks using KA, ie.:
# ka thi ka s ka bo ka y ka i ka s ka u ka gly what simply means this boy is ugly.
# Task
# Write a function that accepts a string word and returns encoded message using ka cypher.
def ka_co_ka_de_ka_me(word):
    w = ""
    for k, v in enumerate(word):
        if k != len(word):
            if v.lower() not in "aeiou" and word[k-1].lower() in "aeiou" and k != 0: w += "ka"
        w += v
    return "ka" + w

# Create a function that takes a string and separates it into a sequence of letters.
def sep_str(st):
    return [[j[i] if len(j) > i else '' for j in st.split()] for i in range(max(map(len, st.split())))] if st else []

# Complete the pattern, using the special character ■   □
# In this kata, we draw some histogram of the sound performance of ups and downs.
def draw(waves):
    l = max(waves)
    return '\n'.join(''.join('□■'[j > i] for j in waves) for i in reversed(range(l)))

# Return the sum of the multiples of 3 and 5 below a number. Being the galactic games,
# the tracks can get rather large, so your solution should
# work for really large numbers (greater than 1,000,000).
def solution(number):
    a, b, c = (number - 1) // 5, (number - 1) // 3, (number - 1) // 15
    return (((a * (a + 1)) // 2) * 5) + (((b * (b + 1)) // 2) * 3) - (((c * (c + 1)) // 2) * 15)

# Write a function groupIn10s which takes any number of arguments, groups them into
# tens, and sorts each group in ascending order.
# The return value should be an array of arrays, so that numbers
# between 0 and9 inclusive are in position 0, numbers between 10 and 19 are in position 1, etc.
def group_in_10s(*args):
    if len(args) == 0: return []
    s = sorted(args)
    l = [None for _ in range(max(s)//10 + 1)]
    for j in s:
        i = j // 10
        if l[i] is None: l[i] = [j]
        else: l[i].append(j)
    return l

# You're continuing to enjoy your new piano, as described in Piano Kata, Part 1.
# You're also continuing the exercise where you start on the very first (leftmost, lowest in pitch)
# key on the 88-key keyboard, which (as shown below) is the note A, with the little finger
# on your left hand, then the second key, which is the black key A# ("A sharp"), with your
# left ring finger, then the third key, B, with your left middle finger, then the fourth key, C,
# with your left index finger, and then the fifth key, C#, with your left thumb. Then
# you play the sixth key, D, with your right thumb, and continue on playing the seventh, eighth,
# ninth, and tenth keys with the other four fingers of your right hand. Then for the eleventh
# key you go back to your left little finger, and so on. Once you get to the rightmost/highest,
# 88th, key, C, you start all over again with your left little finger on the first key.
def which_note(count):
    return ['A','A#','B','C','C#','D','D#','E','F','F#','G','G#'][(count - 1) % 88 % 12]

# In this Kata, you will be given a number and your task will be to return the nearest prime number.
from gmpy2 import is_prime
def solve(n, i=0):
    return is_prime(n-i) and n-i or is_prime(n+i) and n+i or solve(n,i+1)

# You've just finished writing the last chapter for your novel when a virus suddenly infects your document.
# It has swapped the 'i's and 'e's in 'ei' words and capitalised random letters. Write a function which will:
# a) remove the spelling errors in 'ei' words. (Example of 'ei' words: their, caffeine, deceive, weight)
# b) only capitalise the first letter of each sentence. Make sure the rest of the sentence is in lower case.
def proofread(s):
    return '. '.join(_.lower().replace('ie', 'ei').capitalize() for _ in s.split('. '))

# A rectangle can be split up into a grid of 1x1 squares, the amount of
# which being equal to the product of the two dimensions of the rectangle. Depending on the
# size of the rectangle, that grid of 1x1 squares can also be split up into
# larger squares, for example a 3x2 rectangle has a total of 8 squares,
# as there are 6 distinct 1x1 squares, and two possible 2x2 squares. A 4x3 rectangle contains 20 squares.
# Your task is to write a function `findSquares` that returns the total number of squares
# for any given rectangle, the dimensions of which being given as two integers with
# the first always being equal to or greater than the second.
def findSquares(x,y):
    return sum((x-i) * (y-i) for i in range(y))

# Our friendly jumping spider is resting and minding his own spidery business at web-coordinate spider.
# An inattentive fly bumbles into the web at web-coordinate fly and gets itself stuck.
# Your task is to calculate and return the distance the spider must jump to get to the fly.
from math import cos, pi
def spider_to_fly(spider, fly):
    x, y = int(spider[1]), int(fly[1])
    return (x**2 + y**2 - 2 * x * y * cos((ord(spider[0]) - ord(fly[0])) * pi / 4))**0.5

# Array Exchange and Reversing
# It's time for some array exchange! The objective is simple: exchange the elements of two arrays
# in-place in a way that their new content is also reversed.
def exchange_with(a, b):
    a[:], b[:] = b[::-1], a[::-1]

# Write a function that accepts a message string and an array of integers code. As the result, return
# the key that was used to encrypt the message. The key has to be shortest of all
# possible keys that can be used to code the message: i.e. when the possible keys
# are 12 , 1212, 121212, your solution should return 12.
def find_the_key(message, code):
    w = "".join(str(code[k] + 96 - ord(v)) for k, v in enumerate(message))
    l = len(w)
    for i in range(1, l + 1):
        if (w[:i] * l)[:l] == w: return int(w[:i])

# Mrs Jefferson is a great teacher. One of her strategies that helped her to reach astonishing results
# in the learning process is to have some fun with her students. At school, she wants
# to make an arrangement of her class to play a certain game with her pupils.
# For that, she needs to create the arrangement with the minimum amount of groups that have consecutive sizes.
def shortest_arrang(n):
    r = n // 2 + 2
    l = [i for i in range(r, 0, -1)]
    for i in range(r):
        for j in range(r + 1):
            if sum(l[i:j]) == n: return l[i:j]
    return [-1]

# We need a function prime_bef_aft() that gives the largest prime below a certain given value n,
# befPrime or bef_prime (depending on the language),
# and the smallest prime larger than this value,
# aftPrime/aft_prime (depending on the language).
# The result should be output in a list like the following:
from gmpy2 import is_prime, next_prime
def prime_bef_aft(i):
    return [next(filter(is_prime, range(i-1, 1, -1))), next_prime(i)]

# You wrote all your unit test names in camelCase. But some of your colleagues have troubles reading these
# long test names. So you make a compromise to switch to underscore separation.
# To make these changes fast you wrote a class to translate a camelCase name into an underscore separated name.
# Implement the ToUnderscore() method.
import re
def toUnderScore(word):
    return re.sub("(?<=[^_-])_?(?=[A-Z])|(?<=[^\\d_])_?(?=\\d)", "_", word)

# A palindrome is a word, phrase, number, or other sequence of characters which reads the
# same backward as forward. Examples of numerical palindromes are: 2332, 110011, 54322345
# For a given number num, write a function which returns an array of all the numerical palindromes
# contained within each number. The array should be sorted in ascending order
# and any duplicates should be removed.
def palindrome(num):
    if not isinstance(num, int) or num < 0: return "Not valid"
    n = str(num)
    l = len(n)
    c = {int(n[i:j]) for i in range(l-1) for j in range(i+2, l+1) if int(n[i]) and n[i:j] == n[i:j][::-1]}
    return sorted(c) if c else "No palindromes found"

# John is a typist. He has a habit of typing: he never use the Shift key to switch case, just using only Caps Lock.
# Given a string s. Your task is to count how many times the keyboard has been tapped by John.
# You can assume that, at the beginning the Caps Lock light is not lit.
def typist(s):
    return sum(i.islower()^j.islower() for i, j in zip('a'+s, s)) + len(s)

# You are given a list of directions in the form of a list:
# goal = ["N", "S", "E", "W"]
# Pretend that each direction counts for 1 step in that particular direction.
# Your task is to create a function called directions, that will return a reduced list that will
# get you to the same point.The order of directions must be returned as N then S then E then W.
# If you get back to beginning, return an empty array.
def directions(goal):
    y, x = goal.count("N") - goal.count("S"), goal.count("E") - goal.count("W")
    return ["N"] * y + ["S"] * (-y) + ["E"] * x + ["W"] * (-x)

# Given a positive integer as input, return the output as a string in the following format:
# Each element, corresponding to a digit of the number, multiplied by a power of 10 in such
# a way that with the sum of these elements you can obtain the original number.
def simplify(n):
    return "".join(["+"+str(n)[i]+("*1"+"0"*(len(str(n))-i-1) if len(str(n))-i-1>0 else "") for i in range(0, len(str(n))) if str(n)[i]!="0"])[1:]

# Imagine a triangle of numbers which follows this pattern:
# Starting with the number "1", "1" is positioned at the top
# of the triangle. As this is the 1st row, it can only support a single number.
# The 2nd row can support the next 2 numbers: "2" and "3"
# Likewise, the 3rd row, can only support the next 3 numbers: "4", "5", "6"
# And so on; this pattern continues.
def cumulative_triangle(n):
    return (n**3+n)/2

# Your goal is to write a function that determines the depth of the deepest nested list within a given list.
# return 1 if there are no nested lists. The list passed to your function can contain any data types.
def list_depth(lst):
    l = [list_depth(i) for i in lst if isinstance(i, list)]
    return max(l)+1 if l else 1

# For a given number num, write a function which returns the number of
# numerical palindromes within each number. For this kata, single digit
# numbers will NOT be considered numerical palindromes.
# Return "Not valid" if the input is not an integer or is less than 0.
def palindrome(num):
    if not isinstance(num, int) or num < 0: return 'Not valid'
    s = str(num)
    return sum(sum(s[i:i+j] == s[i:i+j][::-1] for i in range(len(s)-j+1)) for j in range(2, len(s)+1))

# Write function which validates an input string. If the string is a perfect square return true,false otherwise.
def perfect_square(square):
    return all("." * len(square.split("\n")) == i for i in square.split("\n"))

# Third day at your new cryptoanalyst job and you come across your toughest assignment
# yet. Your job is to implement a simple keyword cipher. A keyword cipher is a type of monoalphabetic
# substitution where two parameters are provided as such (string, keyword). The string is
# encrypted by taking the keyword, dropping any letters that appear more than once. The rest of the
# letters of the alphabet that aren't used are then appended to the end of the keyword.
def keyword_cipher(s, keyword, key=""):
    w = "abcdefghijklmnopqrstuvwxyz"
    for i in keyword + w:
        if i not in key: key += i
    return s.lower().translate(str.maketrans(w, key))

# In his publication Liber Abaci Leonardo Bonacci, aka Fibonacci, posed a problem involving a population
# of idealized rabbits. These rabbits bred at a fixed rate, matured over the course of
# one month, had unlimited resources, and were immortal.
# Create a function that determines the number of pairs of mature rabbits after n
# months, beginning with one immature pair of these idealized rabbits that produce b pairs of offspring at
# the end of each month.
def fib_rabbits(n, b):
    x, y = 0, 1
    for i in range(n): x, y = y, y + b * x
    return x

# You'll have a function called "sortEmotions" that will return an array of emotions
# sorted. It has two parameters, the first parameter called "arr" will
# expect an array of emotions where an emotion will be one of the following:
def sort_emotions(arr, bool):
    return sorted(arr, key=[':D',':)',':|',':(','T_T'].index, reverse = not bool)

# Your task is to write a function named do_math that receives a single argument.
# This argument is a string that contains multiple whitespace delimited numbers. Each number has
# a single alphabet letter somewhere within it.
from functools import reduce
from itertools import cycle
from operator import add, truediv, mul, sub
def do_math(s):
    l = sorted(s.split(), key=lambda j: next(i for i in j if i.isalpha()))
    l = [int(''.join(filter(str.isdigit, i))) for i in l]
    ops = cycle([add, sub, mul, truediv])
    return round(reduce(lambda a, b: next(ops)(a, b), l))

# Natural Language Understanding is the subdomain of Natural Language Processing where people
# used to design AI based applications have ability to understand the human languages. HashInclude
# Speech Processing team has a project named Virtual Assistant. For this project
# they appointed you as a data engineer (who has good knowledge of creating clean datasets
# by writing efficient code). As a data engineer your first task is to
# make vowel recognition dataset. In this task you have to find the presence of vowels
# in all possible substrings of the given string. For each given string you have to
# return the total number of vowels.
def vowel_recognition(input):
    w = set('aeiouAEIOU')
    s = t = 0
    for k, v in enumerate(input, 1):
        if v in w: t += k
        s += t
    return s

# Christmas is coming, and your task is to build a custom Christmas tree with the specified
# characters and the specified height.
from itertools import cycle, chain
def custom_christmas_tree(chars, n):
    c, l = cycle(chars), 2*n-1
    return '\n'.join(chain((' '.join(next(c) for i in range(j)).center(l).rstrip() for j in range(1,n+1)), ('|'.center(l).rstrip() for k in range(n//3 or 1))))

# No Story
# No Description
# Only by Thinking and Testing
# Look at the result of testcase, guess the code!
def test_it(a, b):
    return sum(map(int, str(a))) * sum(map(int, str(b)))

# Cara is applying for several different jobs. The online
# application forms ask her to respond within a specific character count. Cara
# needs to check that her answers fit into the character limit.
# Annoyingly, some application forms count spaces as a character, and some don't.
# Your challenge:
# Write Cara a function charCheck() with the arguments:
# "text": a string containing Cara's answer for the question
# "max": a number equal to the maximum number of characters allowed in the answer
# "spaces": a boolean which is True if spaces are included in the character count and False if they are not
def charCheck(text, mx, spaces):
    if not spaces: text = text.replace(' ', '')
    return [len(text) <= mx, text[:mx]]

# Create a function longer that accepts a string and sorts the words in it based on their
# respective lengths in an ascending order. If there are two words of the
# same lengths, sort them alphabetically. Look at the examples below for more details.
def longer(s):
    return ' '.join(sorted(s.split(' '), key = lambda x: (len(x),x)))

# The look and say sequence is a sequence in which each number is the result of a "look and say"
# operation on the previouselement.
# Considering for example the classical version startin with "1": ["1", "11", "21, "1211", "111221", ...]. You
# can see that the second element describes the first as "1(times number)1",
# the third is "2(times number)1" describing the second, the fourth is "1(times number)
# 2(and)1(times number)1" and so on.
# Your goal is to create a function which takes a starting string (not
# necessarily the classical "1", much less a single character start) and return the nth element of the series.
from itertools import groupby
from functools import reduce
def look_and_say_sequence(first_element, n):
    return reduce(lambda i, j: ''.join('%d%s' % (len(list(v)), k) for k, v in groupby(i)), range(n - 1), first_element)

# Give you two number rows , columns and a string str. Returns a rows
# x columns table pattern and fill in the str(each grid fill in a char,
# the length of str is always less than or equals to the total numbers of grids):
def pattern(rows, col, s):
    seperator, res, l, index = '+---'*col + '+', '', len(s), 0
    for _ in range(rows):
        res += seperator+'\n'
        for c in range(col):
            if index < l: res += f'| {s[index]} '
            else: res += '|   '
            index += 1
        res += '|\n'
    res += seperator
    return res

# Traditionally in FizzBuzz, multiples of 3 are replaced by "Fizz" and multiples of
# 5 are replaced by "Buzz". But we could also play FizzBuzz with any other integer pair
# [n, m] whose multiples are replaced with Fizz and Buzz.
# For a sequence of numbers, Fizzes, Buzzes and FizzBuzzes, find the numbers
# whose multiples are being replaced by Fizz and Buzz. Return them as an array [n, m]
# The Fizz and Buzz numbers will always be integers between 1 and 50, and
# the sequence will have a maximum length of 100. The Fizz and Buzz numbers
# might be equal, and might be equal to 1.
def reverse_fizz_buzz(array):
    return tuple(next(i for i, j in enumerate(array, 1) if j == k or j == "FizzBuzz") for k in ["Fizz", "Buzz"])

# Your task is to write a function such that, for the input
# string that represents a road as described, returns the total number of photos
# that were taken by the cameras. The complexity should be strictly O(N) in order to pass all the tests.
def count_photos(road):
    c, l, f = 0, 0, 0
    for i in road:
        if i == ">": l += 1
        elif i == ".":
            c += l
            f += 1
        elif i == "<": c += f
    return c

# You are given N ropes, where the length of each rope is a positive integer.
# At each step, you have to reduce all the ropes by the length of the smallest rope.
# The step will be repeated until no ropes are left. Given the length of N
# ropes, print the number of ropes that are left before each step.
def cut_the_ropes(arr):
    l = []
    while arr:
        l.append(len(arr))
        m = min(arr)
        arr = [i - m for i in arr if i > m]
    return l

# In one city it is allowed to write words on the buildings walls. The local
# janitor, however, doesn't approve of it at all. Every night he vandalizes
# the writings by erasing all occurrences of some letter. Since the janitor
# is quite lazy, he wants to do this with just one swipe of his mop.
def the_janitor(word):
    l = []
    w = 'abcdefghijklmnopqrstuvwxyz'
    for i in w:
        if i not in word:
            l.append(0)
            continue
        l.append(word.rindex(i) + 1 - word.index(i))
    return l

# Math geeks and computer nerds love to anthropomorphize numbers and assign emotions and personalities to
# them. Thus there is defined the concept of a "happy" number. A happy number
# is defined as an integer in which the following sequence ends with the number 1.
# Start with the number itself.
# Calculate the sum of the square of each individual digit.
# If the sum is equal to 1, then the number is happy. If the sum is not
# equal to 1, then repeat steps 1 and 2. A number is considered unhappy once
# the same number occurs multiple times in a sequence because this means there is
# a loop and it will never reach 1.
def happy_numbers(n):
    def is_happy(n):
        stop = {1}
        while n not in stop:
            stop.add(n)
            n = sum(int(d)**2 for d in str(n))
        return n == 1
    return [i for i in range(1, n+1) if is_happy(i)]

# The situation...
# The fastest penguins in the world have just swum for the ultimate prize in professional penguin swimming.
# The cameras that were capturing the race stopped recording half way through.
# The athletes, and the fans are in disarray waiting for the results.
# The challenge...
# Given the last recorded frame of the race, and an array of penguin athletes,
# work out the gold, silver and bronze medal positions.
def calculate_winners(snapshot, penguins):
    c, d = 0, {}
    for i in snapshot.split('\n'):
        for j in i[i.lower().index('p')+1:]:
            if j == '~':
                c += 2
                continue
            c += 1
        d[penguins[0]] = c
        penguins = penguins[1:]
        c = 0
    d = [i for i in dict(sorted(d.items(), key=lambda i: i[1]))]
    return f"GOLD: {d[0]}, SILVER: {d[1]}, BRONZE: {d[2]}"

# Most football fans love it for the goals and excitement. Well, this Kata doesn't.
# You are to handle the referee's little notebook and count the players who
# were sent off for fouls and misbehavior.
# The rules: Two teams, named "A" and "B" have 11 players each; players on each team
# are numbered from 1 to 11. Any player may be sent off the field by being
# given a red card. A player can also receive a yellow warning card, which is fine, but
# if he receives another yellow card, he is sent off immediately (no need for a
# red card in that case). If one of the teams has less than 7 players remaining, the game
# is stopped immediately by the referee, and the team with less than 7 players loses.
def men_still_standing(cards):
    a, b = [0] * 11, [0] * 11
    for c in cards:
        if c[0] == 'A': a[int(c[1:-1])-1] += (1 if c[-1] == 'Y' else 2)
        else: b[int(c[1:-1])-1] += (1 if c[-1] == 'Y' else 2)
        if sum(i < 2 for i in a) < 7 or sum(i < 2 for i in b) < 7: break
    return (sum(i < 2 for i in a), sum(i < 2 for i in b))

# Your apple has a virus, and the infection is spreading.
# The apple is a two-dimensional array, containing
# strings "V" (virus) and "A" (uninfected parts). For each hour,
# the infection spreads one space up, down, left and right.
# Input: 2D array apple and number n (n >= 0).
# Output: 2D array showing the apple after n hours.
def infect_apple(apple, n):
    h, w = range(len(apple)), range(len(apple[0]))
    v = [(i, j) for i in h for j in w if apple[i][j] == "V"]
    return [["A" if all(n < abs(y - j) + abs(x - i) for y, x in v) else "V" for i in w] for j in h]

# Let's say take 2 strings, A and B, and define the similarity of the strings to
# be the length of the longest prefix common to both strings. For example, the similarity of strings
# abc and abd is 2, while the similarity of strings aaa and aaab is 3.
# write a function that calculates the sum of similarities of a string S with each of it's suffixes.
def string_suffix(str):
    c = 0
    for i in range(len(str)):
        for a, b in zip(str, str[i:]):
            if a != b: break
            c += 1
    return c

# Return the most profit from stock quotes.
# Stock quotes are stored in an array in order of date. The stock profit is
# the difference in prices in buying and selling stock. Each day, you can
# either buy one unit of stock, sell any number of stock units you have
# already bought, or do nothing. Therefore, the most profit is the
# maximum difference of all pairs in a sequence of stock prices.
def get_most_profit_from_stock_quotes(quotes):
    return sum(max(quotes[k:]) - v for k, v in enumerate(quotes))

# Some languages like Chinese, Japanese, and Thai do not have spaces between words. However,
# most natural languages processing tasks like part-of-speech tagging require texts that have segmented
# words. A simple and reasonably effective algorithm to segment a sentence
# into its component words is called "MaxMatch".
# MaxMatch
# MaxMatch starts at the first character of a sentence and tries to find the longest valid
# word starting from that character. If no word is found, the first character is deemed the
# longest "word", regardless of its validity. In order to find the rest of the words,
# MaxMatch is then recursively invoked on all of the remaining characters until no characters remain.
# A list of all of the words that were found is returned.
def max_match(s):
    l = []
    while s:
        for i in range(len(s), 0, -1):
            w = s[:i]
            if w in VALID_WORDS: break
        l.append(w)
        s = s[i:]
    return l

# Write a function that returns the greatest common factor of an array of positive integers.
# Your return value should be a number, you will only receive positive integers.
def greatest_common_factor(seq):
    l = []
    for i in range(1, min(seq)+1):
        if all(j % i == 0 for j in seq): l.append(i)
    return max(l)

# Check that the two provided arrays both contain the same number of different unique
# items, regardless of order. For example in the following:
from collections import Counter
def balance(arr1, arr2):
    s1, s2 = sorted(Counter(arr1).values()), sorted(Counter(arr2).values())
    return all(i == j for i, j in zip(s1, s2)) and len(s1) == len(s2)

# This challenge is an extension of the kata of Codewars: Missing and Duplicate Number", authored
# by the user Uraza. (You may search for it and complete it if you have not done it)
# In this kata, we have an unsorted sequence of consecutive numbers from a to b, such
# that a < b always (remember a, is the minimum, and b the maximum value).
# They were introduced an unknown amount of duplicates in this sequence and we know that there
# is an only missing value such that all the duplicate values and the missing value are
# between a and b, but never coincide with them.
# Find the missing number with the duplicate numbers (duplicates should be output in a sorted array).
from collections import Counter
def find_dups_miss(arr):
    s = Counter(arr)
    l = sum(i for i in range(sorted(s)[0], sorted(s)[-1]+1)) - sum(s)
    return [l, sorted(k for k, v in s.items() if v > 1)]

# In this Kata, you will be given an array of integers and your task is
# to return the number of arithmetic progressions of size 3 that are possible
# from that list. In each progression, the differences between the elements must be the same.
from itertools import combinations
def solve(arr):
    return sum(a - b == b - c for a, b, c in combinations(arr, 3))

# Build a function sumNestedNumbers/sum_nested_numbers that finds the sum of all numbers in a series of
# nested arrays raised to the power of their respective nesting levels. Numbers in the outer most array
# should be raised to the power of 1.
def sum_nested_numbers(a, c=0):
    return a ** c if not isinstance(a, list) else sum(sum_nested_numbers(i, c+1) for i in a)

# Given three arrays of integers, return the sum of elements that are common in all three arrays.
from collections import Counter
def common(a,b,c):
    return sum((Counter(a) & Counter(b) & Counter(c)).elements())

# You're playing to scrabble. But counting points is hard.
# You decide to create a little script to calculate the best possible value.
# The function takes two arguments :
# `points` : an array of integer representing for each letters from A to Z the points that it pays
# `words` : an array of strings, uppercase
def get_best_word(points, words):
    return max(range(len(words)), key=lambda i: (sum(points[ord(j)-65] for j in words[i]), -len(words[i]), -i))

# Implement a function that normalizes out of range sequence indexes (converts them
# to 'in range' indexes) by making them repeatedly 'loop' around the array. The function
# should then return the value at that index. Indexes that are not
# out of range should be handled normally and indexes to empty sequences should return undefined/None
# depending on the language.
# For positive numbers that are out of range, they loop around starting at the beginning, so
def norm_index_test(seq, ind):
    return seq[ind % len(seq)] if seq else None

# You are given two strings (st1, st2) as inputs. Your task is to return a string containing the numbers
# in st2 which are not in str1. Make sure the numbers are returned in ascending order. All inputs will be
# a string of numbers.
from collections import Counter
def findAdded(st1, st2):
    return ''.join(sorted((Counter(st2) - Counter(st1)).elements()))

# Given a string of numbers, you must perform a method in which you
# will translate this string into text, based on the below image:
def phone_words(text):
    d = {
        222: 'c',
        22: 'b',
        2: 'a',
        333: 'f',
        33: 'e',
        3: 'd',
        444: 'i',
        44: 'h',
        4: 'g',
        555: 'l',
        55: 'k',
        5: 'j',
        666: 'o',
        66: 'n',
        6: 'm',
        7777: 's',
        777: 'r',
        77: 'q',
        7: 'p',
        888: 'v',
        88: 'u',
        8: 't',
        9999: 'z',
        999: 'y',
        99: 'x',
        9: 'w',
        0: ' ',
        1: ''
    }
    while (text.isdigit()):
        for i in d:
            text = text.replace(str(i), d[i])
    return text

# Dear Coder,
# We at [SomeLargeCompany] have decided to expand on the functionality of our online text editor.
# We have written a new function that accepts a phrase, a word and an array of indexes.
# We want this function to return the phrase, with the word inserted at each of the indexes given by the array.
# However, our current function only gets the first insertion right, but all of the following ones
# are out of place!
# Please fix this for us, and you will be showered with money.
# Yours Sincerely, [SomeLargeCompany]
# Note :
# the indicies are always in range and passed as a sorted array
# note if the index array is empty, just return the initial phrase
def insert_at_indexes(phrase, word, indexes):
    for i in indexes[::-1]:
        phrase = phrase[:i] + word + phrase[i:]
    return phrase

# Define n!! as
# n!! = 1 * 3 * 5 * ... * n if n is odd,
# n!! = 2 * 4 * 6 * ... * n if n is even.
# Hence 8!! = 2 * 4 * 6 * 8 = 384, there is no zero at the end. 30!! has 3 zeros at the end.
# For a positive integer n, please count how many zeros are there at the end of n!!.
import math
def count_zeros_n_double_fact(n):
    c = 0
    if n % 2 == 0:
        n = math.prod([i for i in range(2, n+1, 2)])
        while str(n).endswith('0'):
            c += 1
            n = str(n)[:-1]
        return c
    if n % 2 != 0:
        n = math.prod([i for i in range(1, n+1, 2)])
        while str(n).endswith('0'):
            c += 1
            n = str(n)[:-1]
        return c

# This series of katas will introduce you to basics of doing geometry with computers.
# Point objects have x, y attributes. Triangle objects have attributes a, b, c describing
# their corners, each of them is a Point.
# Write a function calculating area of a Triangle defined this way.
# Tests round answers to 6 decimal places.
def triangle_area(triangle):
    a, b, c = triangle.a, triangle.b, triangle.c
    return round(abs(a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y)) / 2, 6)

# A twin prime is a prime number that is either 2 less or 2 more than another
# prime number—for example, either member of the twin prime pair (41, 43). In other
# words, a twin prime is a prime that has a prime gap of two. Sometimes
# the term twin prime is used for a pair of twin primes; an alternative name for this
# is prime twin or prime pair. (from wiki https://en.wikipedia.org/wiki/Twin_prime)
# Your mission, should you choose to accept it, is to write a function that
# counts the number of sets of twin primes from 1 to n.
# If n is wrapped by twin primes (n-1 == prime && n+1 == prime) then that should
# also count even though n+1 is outside the range.
from gmpy2 import is_prime
def twin_prime(n):
    return sum(is_prime(x) and is_prime(x + 2) for x in range(n))

# The aim of this Kata is to write a function which will reverse the case of all consecutive duplicate
# letters in a string. That is, any letters that occur one after the other and are identical.
# If the duplicate letters are lowercase then they must be set to uppercase, and if
# they are uppercase then they need to be changed to lowercase.
import re
def reverse(s):
    return re.sub(r'(.)\1+', lambda x: x.group().swapcase(), s)

# Following on from Part 1, part 2 looks at some more complicated array contents.
# So let's try filling an array with...
def squares(n):
    return [i**2 for i in range(1, n+1)]
def num_range(n, start, step):
    l = []
    for i in range(n):
        l.append(start)
        start += step
    return l
def rand_range(n, mn, mx):
    from random import randint
    l = []
    for i in range(n):
        l.append(randint(mn, mx))
    return l
def primes(n):
    from gmpy2 import is_prime
    l = []
    c = 1
    while len(l) < n:
        if is_prime(c): l.append(c)
        c += 1
    return l

# In this Kata, we are going to see how a Hash (or Map or dict) can be used to
# keep track of characters in a string.
# Consider two strings "aabcdefg" and "fbd". How many characters do we have to remove from the
# first string to get the second string? Although not the only way to solve this,
# we could create a Hash of counts for each string and see which character counts are different.
# That should get us close to the answer. I will leave the rest to you.
# For this example, solve("aabcdefg","fbd") = 5. Also, solve("xyz","yxxz") = 0, because we
# cannot get second string from the first since the second string is longer.
# More examples in the test cases.
# Good luck!
def solve(a, b):
    return len(a) - len(b) if all(a.count(i) >= b.count(i) for i in set(b)) else 0

# Codewars Weekly has gained popularity in the past months and is receiving lots of fan letters.
# Unfortunately, some of the readers use offensive words and
# the editor wants to keep the magazine family friendly.
# To manage this, you have been asked to implement a censorship algorithm. You will be
# given the fan letter text and a list of forbiddenWords. Your algorithm should replace all occurrences
# of the forbidden words in the text with sequences of asterisks of the same length.
# Be careful to censor only words, no one want to see "classic" spelled as "cl***ic".
def censor_this(text, forbidden_words):
    return ' '.join(i if i.lower() not in forbidden_words else '*'*len(i) for i in text.split())

# Write a function that takes an array/list of numbers and returns a number.
# See the examples and try to guess the pattern:
def even_odd(arr):
    c = 0
    for k, v in enumerate(arr):
        if k % 2: c *= v
        else: c += v
    return c

# Some numbers have the property to be divisible by 2 and 3. Other smaller subset of
# numbers have the property to be divisible by 2, 3 and 5. Another subset with less abundant
# numbers may be divisible by 2, 3, 5 and 7. These numbers have something in common:
# their prime factors are contiguous primes.
# Implement a function that finds the amount of numbers that have the first N primes as factors below
# a given limit.
from gmpy2 import next_prime as np
from math import prod
def count_specMult(n, maxval):
    a, b = 2, []
    while n > 0: b, a, n = b+[a], np(a), n-1
    return maxval // prod(b)

# Complete the function that takes a string as an input, and return a list of
# all the unpaired characters (i.e. they show up an odd number of times in the string), in
# the order they were encountered as an array.
# In case of multiple appearances to choose from, take the last occurence of the unpaired character.
# Notes:
# A wide range of characters is used, and some of them may not render properly in your browser.
# Your solution should be linear in terms of string length to pass the last test.
from collections import Counter
def odd_one_out(s):
    return [k for k, v in Counter(s[::-1]).items() if v % 2][::-1]

# In this Kata, we are going to determine if the count of each of the characters in
# a string can be equal if we remove a single character from that string.
from collections import Counter
def solve(s):
    return any(len(set(Counter(s[:i] + s[i+1:]).values())) == 1 for i in range(len(s)))

# Given a string s and a character c, return an array of integers representing
# the shortest distance from the current character in s to c.
# Notes
# All letters will be lowercase.
# If the string is empty, return an empty array.
# If the character is not present, return an empty array.
def shortest_to_char(s, c):
    if not s or not c:return []
    l = [k for k, v in enumerate(s) if v == c]
    if not l: return []
    return [min(abs(i - j) for j in l) for i in range(len(s))]

# Given an uppercase 9 letter string, letters, find the longest word that can be made with
# some or all of the letters. The preloaded array words (or $words in Ruby) contains
# a bunch of uppercase words that you will have to loop through. Only return the longest word; if there
# is more than one, return the words of the same lengths in alphabetical order. If there are
# no words that can be made from the letters given, return None/nil/null.
def longest_word(w):
    l = []
    for i in sorted(words, key=len)[::-1]:
        if all(w.count(j) >= i.count(j) for j in i): l+=[i]
    if not l: return None
    m = len(l[0])
    return sorted([i for i in l if len(i)==m])

# Alyosha Popovich (Russian folk hero) stroke his sharp sword and cut the head of
# Zmey Gorynych (big Serpent with several heads)! He looked - and lo! - in its place immediately new heads
# appeared, exactly n. He stroke again, and where the second head was, 2*n heads
# appeared! The third time it was 2*3*n new heads, and after fourth swing it was 2*3*4*n heads,
# and so forth. And thus Alyosha decided to call it a day, and instead called a fellow Mage for
# help. While the Mage agreed, he needs to know the exact number of heads that Zmey Gorynych now has.
# The task
# Given the initial number of heads, the heads-count multiplier, and the number of sword-swings,
# calculate how many heads Zmey Gorynych has in the end.
import math
def count_of_heads(initial, n, swings):
    for i in range(1, swings+1):
        initial = initial - 1 + n * math.factorial(i)
    return initial

# Since there are lots of katas requiring you to round numbers to 2 decimal places, you decided to
# extract the method to ease out the process.
# And you can't even get this right!
# Quick, fix the bug before everyone in CodeWars notices that you can't even round a number correctly!
from decimal import Decimal, ROUND_HALF_UP
def round_by_2_decimal_places(n):
    return n.quantize(Decimal('.01'), rounding = ROUND_HALF_UP)

# In this Kata, you will be given an array and your task will be to determine if an array
# is in ascending or descending order and if it is rotated or not.
# Consider the array [1,2,3,4,5,7,12]. This array is sorted in Ascending order.
# If we rotate this array once to the left, we get [12,1,2,3,4,5,7] and twice-rotated
# we get [7,12,1,2,3,4,5]. These two rotated arrays are in Rotated Ascending order.
# Similarly, the array [9,6,5,3,1] is in Descending order, but we can
# rotate it to get an array in Rotated Descending order: [1,9,6,5,3] or [3,1,9,6,5] etc.
# Arrays will never be unsorted, except for those that are rotated as shown above. Arrays
# will always have an answer, as shown in the examples below. Arrays will never contain duplicated elements.
def solve(arr):
    if sorted(arr) == arr: return "A"
    if sorted(arr, reverse=True) == arr: return "D"
    return "RA" if arr[0] > arr[-1] else "RD"

# Write a method that takes a string as an argument and groups
# the number of time each character appears in the string as a hash sorted by the highest number of occurrences.
# The characters should be sorted alphabetically e.g:
from collections import Counter
def get_char_count(seq):
    d = {}
    for k, v in sorted(Counter(i for i in seq.lower() if i.isalnum()).items()):
        d[v] = d.get(v, []) + [k]
    return d

# Given a string str, find the shortest possible string which can
# be achieved by adding characters to the end of initial string to make it a palindrome.
def build_palindrome(w):
    n = 0
    while w[n:] != w[n:][::-1]: n += 1
    return w + w[:n][::-1]

# You are given an integer N. Your job is to figure out how many substrings inside of N divide evenly with N.
# Confused? I'll break it down for you.
# Let's say that you are given the integer '877692'.
def get_count(n):
    w = str(n)
    c = 0
    for i in range(1, len(w)):
        for j in range(len(w) - i + 1):
            s = int(w[j:j+i])
            if s and n % s == 0: c += 1
    return c

# The dot product is usually encountered in linear algebra or scientific computing. It's also
# called scalar product or inner product sometimes:
# In mathematics, the dot product, or scalar product (or sometimes inner product in the context of
# Euclidean space), is an algebraic operation that takes two equal-length sequences of numbers (usually
# coordinate vectors) and returns a single number. Wikipedia
# In our case, we define the dot product algebraically for two vectors
# a = [a1, a2, …, an], b = [b1, b2, …, bn] as
def min_dot(a, b):
    return sum(i * j for (i, j) in zip(sorted(a), sorted(b, reverse = True)))

# You will be given an integer N as input; your task is to return the value of S(Z(N)).
# For example, let N = 3:
def sum_of_sums(x):
    x = x * (x+1) * (x+2) // 6
    return x * (x+1) // 2

# Complete the function which accepts a string and return an array of character(s)
# that have the most spaces to their right and left.
# Notes:
# the string can have leading/trailing spaces - you should not count them
# the strings contain only unique characters from a to z
# the order of characters in the returned array doesn't matter
import re
def loneliest(strng):
    l = [re.match(r'\s*\w\s*', strng.strip()[i:]) for i in range(len(strng))]
    le = max(len(i.group(0)) for i in l if i)
    return [i.group(0).strip() for i in l if i and len(i.group(0)) == le]

# You are asked to write a simple cypher that rotates every character (in range [a-zA-Z], special
# chars will be ignored by the cipher) by 13 chars. As an addition to the
# original ROT13 cipher, this cypher will also cypher numerical digits ([0-9]) with 5 chars.
CHARS = str.maketrans("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", "NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm5678901234")
def ROT135(input):
    return input.translate(CHARS)

# You are provided with a function of the form f(x) = axⁿ, that consists of
# a single term only and 'a' and 'n' are integers, e.g f(x) = 3x², f(x) = 5 etc.
# Your task is to create a function that takes f(x) as the argument and
# returns the result of differentiating the function, that is, the derivative.
def differentiate(x):
    if 'x' not in x: return '0'
    a, n = x.split('x', 2)
    a = 1 if a == '' else -1 if a == '-' else int(a)
    return f"{a}" if n == '' else f"{2*a}x" if n == "^2" else f"{a*int(n[1:])}x^{int(n[1:])-1}"

# The sum of the primes below or equal to 10 is 2 + 3 + 5 + 7 = 17. Find the sum
# of all the primes below or equal to the number passed in.
from gmpy2 import is_prime
def summationOfPrimes(primes):
    return sum(i for i in range(2, primes+1) if is_prime(i))

# X and Y are playing a game. A list will be provided which contains n pairs of strings
# and integers. They have to add the integeri to the ASCII values of the stringi characters. Then
# they have to check if any of the new added numbers is prime or not. If for any character of
# the word the added number is prime then the word will be considered as prime word.
# Can you help X and Y to find the prime words?
from gmpy2 import is_prime
def prime_word(array):
    a = [ord(i) + array[0][1] for i in array[0][0]]
    b = [ord(i) + array[1][1] for i in array[1][0]]
    if len(array) == 3:
        c = [ord(i) + array[2][1] for i in array[2][0]]
    f = [1 if any(is_prime(i) for i in a) else 0, 1 if any(is_prime(i) for i in b) else 0]
    return f if len(array) ==2 else f + [1 if any(is_prime(i) for i in c) else 0]

# Playing ping-pong can be really fun! Unfortunatelly after a long and exciting play you can forget
# who's service turn it is. Let's do something about that!
# Write a function that takes the current score as a string separated by : sign as an only
# parameter and returns "first" or "second" depending on whose service turn it is.
# We're playing old-school, so the rule is that players take turn after every 5 services. That
# is until the score is 20:20 - from that moment each player serves 2 times in his turn.
def service(score):
    c = sum(int(i) for i in score.split(":"))
    return "first" if ((c%10 < 5) if c < 40 else (c%4 < 2)) else "second"

# Create the function off, that receives the nth switch as argument n. The function should return
# an ascending array containing all of the switch numbers that remain off after Bob completes his revenge.
def off(n):
    return [i*i for i in range(1, int(n ** .5) + 1)]

# This is a follow-up from my previous Kata which can be found here:
# http://www.codewars.com/kata/5476f4ca03810c0fc0000098
# This time, for any given linear sequence, calculate the function [f(x)] and return it
# as a function in Javascript or Lambda/Block in Ruby.
def get_function(sequence):
    s = sequence[1] - sequence[0]
    for i in range(1, 5):
        if sequence[i] - sequence[i-1] != s: return "Non-linear sequence"
    return lambda a : s * a + sequence[0]

# In this Kata, you will implement a function count that takes an integer and returns the number of
# digits in factorial(n).
# For example, count(5) = 3, because 5! = 120, and 120 has 3 digits.
# More examples in the test cases.
# Brute force is not possible. A little research will go a long way, as this is a well known series.
# Good luck!
import math
def count(n):
    if (n < 0): return 0
    if (n <= 1): return 1
    x = ((n * math.log10(n / math.e) + math.log10(2 * math.pi * n) /2.0))
    return math.floor(x) + 1

# You will be given
# The distance to my exit (km)
# How fast I am going (kph)
# Information about a lot of other cars
# Their time (relative to me) as I join the freeway. For example,
# -1.5 means they already passed my starting point 1.5 minutes ago
# 2.2 means they will pass my starting point 2.2 minutes from now
# How fast they are going (kph)
# Find what is my "score" as I exit the freeway!
def freeway_game(km, kph, cars):
    t = km / kph
    c = 0
    for k, v in cars:
        d = km - (t - k/60) * v
        if k <= 0: c += d > 0
        else: c -= d < 0
    return c

# The collections module has defaultdict, which gives you a default value for trying to get the value
# of a key which does not exist in the dictionary instead of raising an error. Why not do this for a list?
# Your job is to create a class (or a function which returns an object) called DefaultList.
# The class will have two parameters to be given: a list, and a default value.
# The list will obviously be the list that corresponds to that object. The default value will
# be returned any time an index of the list is called in the code that would normally raise an error
# (i.e. i > len(list) - 1 or i < -len(list)). This class must also support the regular list functions
# extend, append, insert, remove, and pop.
# Because slicing a list never raises an error (slicing a list between two indexes that are not a part
# of the list returns [], slicing will not be tested for.
class DefaultList(list):
    def __init__(self,it, defu):
        super().__init__(it)
        self.default = defu
    def __getitem__(self,i):
        try: return super().__getitem__(i)
        except: return self.default

# Your friend Cody has to sell a lot of jam, so he applied a good 25% discount to all his merchandise.
# Trouble is that he mixed all the prices (initial and discounted), so now he needs your cool coding
# skills to filter out only the discounted prices.
def find_discounted(prices):
    l = [int(n) for n in prices.split()]
    return ' '.join(l.remove(round(i*4/3)) or str(i) for i in l)

# Your task is to complete the function that determines where to replace a zero with a
# one to make the maximum length subsequence.
# Notes:
# If there are multiple results, return the last one:
def replace_zero(arr):
    c, s, i, l = 0, -1, -1, ''.join(map(str, arr)).split('0')
    for a, b in zip(l, l[1:]):
        i += len(a) + 1
        rep = len(a)+len(b)+1
        if c <= rep: s, c = i, rep
    return s

# Consider the prime number 23. If we sum the square of its digits we get: 2^2 + 3^2 = 13,
# then for 13: 1^2 + 3^2 = 10, and finally for 10: 1^2 + 0^2 = 1.
# Similarly, if we start with prime number 7, the sequence is: 7->49->97->130->10->1.
# Given a range, how many primes within that range will eventually end up being 1?
# The upperbound for the range is 50,000. A range of (2,25) means that: 2 <= n < 25.
from gmpy2 import is_prime
def check(n):
    l = []
    while n not in l:
        l += [n]
        n = sum(int(i)**2 for i in str(n))
        if n==1: return True
    return False
def solve(a,b):
    return len([i for i in range(a,b) if is_prime(i) and check(i)])

# There is a common problem given to interviewees in software. It is called FizzBuzz. It works
# as follows: For the numbers between 1 and 100, print fizz if
# it is a multiple of 3 and buzz if it is a mutiple of 5, else print the number itself.
# You are in an interview and they ask you to complete fizzbuzz (which can
# be done in a one-liner in a few langs) and you knock it out of the park.
# Surprised by your ability, the interviewer gives you a harder problem. Given
# a list of coprime numbers, (that is that the g.c.d. of all the numbers == 1) and
# an equally sized list of words. compute its fizzbuzz representation up until the pattern of strings
# repeats itself.
from functools import reduce

def fizzbuzz_plusplus(nums, words):
    return ["".join(b for a, b in zip(nums, words) if not i % a) or i for i in range(1, reduce(lambda a, b: a * b, nums, 1) + 1)]

# For this kata, you are given three points (x1,y1,z1), (x2,y2,z2), and (x3,y3,z3) that lie on
# a straight line in 3-dimensional space. You have to figure out which point lies in between the other two.
# Your function should return 1, 2, or 3 to indicate which point is the in-between one.
def middle_point(x1, y1, z1, x2, y2, z2, x3, y3, z3):
    d = {(x1, y1, z1): 1, (x2, y2, z2): 2, (x3, y3, z3): 3}
    return d[sorted(d)[1]]

# The goal of this Kata is to return the greatest distance of index positions between
# matching number values in an array or 0 if there are no matching values.
# Example: In an array with the values [0, 2, 1, 2, 4, 1] the greatest index distance is between
# the matching '1' values at index 2 and 5. Executing greatestDistance against this array would
# return 3. (i.e. 5 - 2)
def greatest_distance(arr):
    return max(k - arr.index(v) for k, v in enumerate(arr))

# Return the index of the array element that you ended up on at the end of the game.
def snakes_and_ladders(board, dice):
    c = 0
    for i in dice:
        if c + i < len(board): c += i + board[c + i]
    return c

# Scheduling is how the processor decides which jobs (processes) get to use the processor and for
# how long. This can cause a lot of problems. Like a really long process taking the
# entire CPU and freezing all the other processes. One solution is Round-Robin, which today you will be
# implementing.
# Round-Robin works by queuing jobs in a First In First Out fashion, but the
# processes are only given a short slice of time. If a processes is not finished in that time
# slice, it yields the proccessor and goes to the back of the queue.
def roundRobin(jobs, slice, index):
    c = 0
    while True:
        for i in range(len(jobs)):
            cc = min(jobs[i], slice)
            jobs[i] -= cc
            c += cc
            if i == index and jobs[i] == 0: return c

# The principal of a school likes to put challenges to the students related with finding
# words of certain features. One day she said: "Dear students, the challenge for today
# is to find a word that has only one vowel and seven consonants but cannot have the
# letters "y" and "m". I'll give a special award for the first student that
# finds it." One of the students used his dictionary and spent all the night without sleeping,
# trying in vain to find the word. The next day, the word had not been found yet.
# This student observed that the principal has a pattern in the features for the wanted words:
# The word should have n vowels, may be repeated, for example: in "engineering", n = 5.
# The word should have m consonants, may be repeated also: in "engineering", m = 6.
# The word should not have some forbidden letters (in an array), forbid_letters
# You will be provided with a list of words, WORD_LIST(python/crystal),
# wordList(javascript), wordList (haskell), $word_list(ruby), and you have to create the function,
# wanted_words(), that receives the three arguments in the order given above, wanted_words(n, m,
# forbid_list)and output an array with the word or an array, having the words in
# the order given in the pre-loaded list, in the case of two or more words were found.
def wanted_words(n, m, f):
    l = []
    v, c = 0, 0
    vow = 'aeiou'
    con = 'bcdfghjklmnpqrstvwxyz'
    for i in WORD_LIST:
        if sum(j in vow for j in i) == n and sum(j in con for j in i) == m and all(j not in f for j in i): l.append(i)
    return l

# An eccentric chessboard maker likes to create strange N x N chessboards.
# Instead of making all the rows and the columns on his chessboards the same size, he
# likes to make chessboards with row and columns of varying sizes:
def white_black_areas(cs, rs):
    r, rc = sum(rs[1::2]), sum(rs[::2])
    c, cs = sum(cs[1::2]), sum(cs[::2])
    return (cs * rc + c * r, r * cs + rc * c)

# We know that some numbers can be split into two primes. ie. 5 = 2 + 3, 10 = 3 + 7. But
# some numbers are not. ie. 17, 27, 35, etc..
# Given a positive integer n. Determine whether it can be split into two primes.
# If yes, return the maximum product of two primes. If not, return 0 instead.
from gmpy2 import is_prime
def prime_product(n):
    return next((i*(n-i) for i in range(n>>1,1,-1) if is_prime(i) and is_prime(n-i)),0)

# Create a function which checks if a given number n can be written as the sum of two cubes in
# two different ways: n = a³+b³ = c³+d³. All the numbers a, b, c and d should be different and greater than 0.
def has_two_cube_sums(n):
    l = [i**3 for i in range(1, int((n)**(1./3.)) + 1)]
    return sum([(n != 2*i) and ((n-i) in l) for i in l]) > 3

# Consider an array that has no prime numbers, and none of its elements has any prime digit.
# It would start with: [1,4,6,8,9,10,14,16,18,40,44..].
# 12 and 15 are not in the list because 2 and 5 are primes.
# You will be given an integer n and your task will be return the number
# at that index in the array. For example:
from gmpy2 import is_prime
def solve(n):
    l = []
    c = 1
    while len(l) <= n:
        if not is_prime(c) and all(not is_prime(int(i)) for i in str(c)): l.append(c)
        c += 1
    return l[n]

# The numbers 6, 12, 18, 24, 36, 48 have a common property. They
# have the same two prime factors that are 2 and 3.
# If we see their prime factorization we will see it more clearly:
from math import log

def highest_biPrimefac(a, b, m):
    l = []
    for i in range(1, int(log(m, b)) + 1):
        c = int(round(log(m / b**i, a), 9))
        if c: l.append([a**c * b**i, c, i])
    return max(l)

# Dan, president of a Large company could use your help. He wants to implement a system that
# will switch all his devices into offline mode depending on his meeting schedule. When he's at a meeting
# and somebody texts him, he wants to send an automatic message informing that he's currently
# unavailable and the time when he's going to be back.;
def check_availability(schedule, current_time):
    for i in schedule:
        if i[0] <= current_time < i[1]: return i[1]
    return True

# Some numbers are more important to get right during data entry than others: a common example is product codes.
# To reduce the possibility of mistakes, product codes can be crafted in such a way that simple errors
# are detected. This is done by calculating a single-digit value based on the product number,
# and then appending that digit to the product number to arrive at the product code.
# When the product code is checked, the check digit value is stripped off and recalculated. If
# the supplied value does not match the recalculated value, the product code is rejected.
# A simple scheme for generating self-check digits, described here, is called Modulus 11 Self-Check.
def add_check_digit(number):
    l = [2, 3, 4, 5, 6, 7]
    s = sum(x*y for x,y in zip(map(int, number[::-1]), l * (len(number) // 6 + 1))) % 11
    return number + ('0' if s == 0 else 'X' if s == 1 else str(11 - s))

# Consider an array containing cats and dogs. Each dog can catch only one cat, but cannot
# catch a cat that is more than n elements away. Your task will be to return
# the maximum number of cats that can be caught.
def solve(arr, n):
    d = [i for i, x in enumerate(arr) if x == 'D']
    c = {i for i, x in enumerate(arr) if x == 'C'}
    s = 0
    while d and c:
        dog = d.pop()
        cat = max((i for i in c if abs(dog - i) <= n), default=-1)
        if cat >= 0:
            s += 1
            c.remove(cat)
    return s

# If string has more than one neighboring dashes(e.g. --) replace they with one dash(-).
# Dashes are considered neighbors even if there is some whitespace between them.
import re
def replace_dashes_as_one(word):
    return re.sub(r'-[ -]+-|-+',r'-', word)

# Some letters in the input string are representing a written-out digit. Some of the
# letters may randomly shuffled. Your task is to recover them all.
# Note that:
# Only consecutive letters can be used. "OTNE" cannot be recovered to 1!
# Every letter has to start with an increasing index.. "ONENO" results to 11, because
# the E can be used two times. Endless loops are not possible!
# If there are letters in the string, which don't create a number you can ignore them.
# If no digits can be found, return "No digits found"
# Take care about the order! "ENOWT" will be recovered to 12 and not to 21.
# The input string consists only UpperCase letters
def recover(st):
    l = []
    for i in range(len(st)):
        for k, v in alph.items():
            if sorted(k) == sorted(st[i:i+len(k)]): l.append(v)
    return ''.join(map(str, l)) or "No digits found"

# You will receive a string consisting of lowercase letters, uppercase letters and digits as input. Your
# task is to return this string as blocks separated by dashes ("-"). The elements of a block should be sorted
# with respect to the hierarchy listed below, and each block cannot contain multiple instances of the same
# character. Elements should be put into the first suitable block.
from collections import Counter
def blocks(w):
    s = lambda c: (c.isdigit(), c.isupper(), c)
    l, c = [], Counter(w)
    while c:
        i = ''.join(sorted(c, key=s))
        l.append(i)
        c = c - Counter(i)
    return '-'.join(l)

# Given an input array (arr) of positive integers, the objective is to return an
# output array where each index represents the amount of times an element
# appeared (frequency) in the input array.
# More specifically, the element at each index of the output array will be
# an array (bucket) containing integers that appeared index-amount-of-times.
# Otherwise, slot nulls (JavaScript, Java), None's (Python) nils (Ruby), or
# NULL's (C/C++) where appropriate. A valid array will always be provided.
from collections import Counter
def bucketize(*arr):
    c = {i: sorted([k for k, v in Counter(arr).items() if v == i]) for i in Counter(arr).values()}
    return [c[i] if i in c else None for i in range(len(arr) + 1)]

# Imagine you are given a positive integer, n, then:
# if n is even, calculate: n / 2
# if n is odd, calculate: 3 * n + 1
# Repeat until your answer is 1. The Collatz conjecture states that performing this operation
# repeatedly, you will always eventually reach 1.
# You can try creating Collatz sequences with this kata. For further information, see the wiki page.
##Now! Your task:
# Given an array of positive integers, return the integer whose Collatz sequence is the longest.
def longest_collatz(input_array):
    def iseven(n):
        return n / 2
    def isodd(n):
        return 3 * n + 1
    l = []
    c = 0
    for i in input_array:
        while i != 1:
            if i % 2 == 0:
                c += 1
                i = iseven(i)
            elif i % 2 != 0:
                c += 1
                i = isodd(i)
        l.append(c)
        c = 0
    return input_array[l.index(max(l))]

# We need the function sec_deg_solver()/secDegSolver(), that accepts three arguments,
# a, b and c, the coefficients of the above equation.
# The outputs of the function may vary depending on the values of coefficients a,
# b and c, according to the following situations. (used values as examples only):
import math
def sec_deg_solver(a, b, c):
    if a == 0:
        if b != 0 and c != 0: return f'It is a first degree equation. Solution: {round(-c/float(b), 10)}'
        elif a == 0 and b == 0 and c == 0: return 'The equation is indeterminate'
        elif a == 0 and b == 0 and c != 0: return 'Impossible situation. Wrong entries'
        elif a == 0 and c == 0 and b != 0: return 'It is a first degree equation. Solution: 0.0'
    elif a != 0:
        d = b**2 - 4 * a * c
        if d < 0: return 'There are no real solutions'
        x1 = round((-b - math.sqrt(d)) / (2 * a), 10)
        x2 = round((-b + math.sqrt(d)) / (2 * a), 10)
        if x2 < x1:
            t = x1
            x1 = x2
            x2 = t
        if d == 0: return f"It has one double solution: {max(x1, x2)}"
        elif d > 0: return f"Two solutions: {min(x1, x2)}, {max(x1, x2)}"

# You're given an array of positive integers arr, and an array guide
# of the same length. Sort array arr using array guide by the following rules:
def sort_by_guide(arr, guide):
    l = iter(sorted((y,x) for x,y in zip(arr, guide) if y > 0))
    return [next(l)[1] if b > 0 else a for a, b in zip(arr, guide)]

# You are a lonely frog.
# You live on a coordinate axis.
# The meaning of your life is to jump and jump..
def jump_to(x, y):
    c = 0
    while y!=x:
        if y % 2 == 0 and y / 2 >= x: y /= 2
        else: y-=1
        c+=1
    return c

# Every Turkish citizen has an identity number whose validity can be checked by these set of rules:
# It is an 11 digit number
# First digit can't be zero
# Take the sum of 1st, 3rd, 5th, 7th and 9th digit and multiply it by 7. Then subtract the sum of
# 2nd, 4th, 6th and 8th digits from this value. Modulus 10 of the result should be equal to 10th digit.
# Sum of first ten digits' modulus 10 should be equal to eleventh digit.
def check_valid_tr_number(n):
    if not isinstance(n, int) or not len(str(n)) == 11: return False
    l = [int(i) for i in str(n)]
    return (sum(l[:9:2])*7 - sum(l[1:9:2])) % 10 == l[9] and sum(l[:10]) % 10 == l[10]

# In this kata you're given an n x n array and you're expected to traverse the
# elements diagonally from the bottom right to the top left.
def diagonal(arr):
    l = sorted(((i, j) for j in range(len(arr)) for i in range(len(arr))), key=sum)[::-1]
    return [arr[i][j] for i, j in l]

# Given a sorted array of numbers, return the summary of its ranges.
def summary_ranges(nums):
    nums.append(float("inf"))
    i, l = nums[0], []
    for a, b in zip(nums, nums[1:]):
        if b - a > 1:
            l.append(str(i) if i == a else f"{i}->{a}")
            i = b
    return l

# The total sum of the numbers in the triangle, up to the 5th line
# included, is 225, part of it, 144, corresponds to the total sum of the even terms
# and 81 to the total sum of the odd terms.
# Create a function that may output an array with three results for each value of n.
def mult_triangle(n):
    s, o = (n * (n + 1) / 2)**2, ((n + 1) // 2)**4
    return [s, s - o, o]

# Write that given an array of numbers >= 0, will arrange them such that they form the biggest number.
def biggest(nums):
    return str(int(''.join(sorted(map(str,nums),key=lambda x:3*x)[::-1])))

# The prime number sequence starts with: 2,3,5,7,11,13,17,19.... Notice that 2 is in position one.
# occupies position two, which is a prime-numbered position. Similarly, 5, 11 and 17 also
# occupy prime-numbered positions. We shall call primes such as 3,5,11,17 dominant primes
# because they occupy prime-numbered positions in the prime number sequence. Let's call this listA.
# As you can see from listA, for the prime range range(0,10), there are
# only two dominant primes (3 and 5) and the sum of these primes is: 3 + 5 = 8.
# Similarly, as shown in listA, in the range (6,20), the dominant
# primes in this range are 11 and 17, with a sum of 28.
# Given a range (a,b), what is the sum of dominant primes within that range?
# Note that a <= range <= b and b will not exceed 500000.
from gmpy2 import next_prime as np, is_prime as ip
def solve(a,b):
    c, l, g = 1, [], 0
    while c<=b:
        c, g = np(c), g+1
        if c>=a and c<=b and ip(g): l.append(c)
    return sum(l)

# Calculus class...is awesome! But you are a programmer with no time for mindless repetition. Your
# teacher spent a whole day covering differentiation of polynomials, and by the time the bell rang,
# you had already conjured up a program to automate the process.
def diff(poly):
    return [k*v for k,v in enumerate(poly[::-1]) if k][::-1]

# The built-in print function for Python class instances is not very entertaining.
# In this kata, we will implement a function show_me(instance) that takes an instance as parameter
# and returns the string "Hi, I'm one of those (classname)s! Have a look at
# my (attrs)." , where (classname) is the class name and (attrs) are the class's attributes.
# If (attrs) contains only one element, just write it. For more than one element (e.g. a, b, c), it
# should list all elements sorted by name in ascending order (e.g. "... look at my a, b and c.").
def show_me(inst):
    name = inst.__class__.__name__
    atts = ' and'.join(', '.join(sorted(i for i in inst.__dict__)).rsplit(',', 1))
    return "Hi, I'm one of those {}s! Have a look at my {}.".format(name, atts)

# The number 1035 is the smallest integer that exhibits a non frequent property: one its multiples,
# 3105 = 1035 * 3, has its same digits but in different order, in other words, 3105, is one
# of the permutations of 1035.
# The number 125874 is the first integer that has this property when the
# multiplier is 2, thus: 125874 * 2 = 251748
# Make the function search_perm_mult(), that receives an upper bound, n_max and a factor k
# and will output the amount of pairs bellow n_max that are permuted when an integer of this
# range is multiplied by k. The pair will be counted if the multiple is less than n_max, too
from collections import Counter
def search_perm_mult(n_max, k):
    return sum(Counter(str(i)) == Counter(str(i * k)) for i in range(1035, n_max // k))

# Your goal is to create a function instrumental() which returns the valid form
# of a valid Hungarian word w in instrumental case i. e. append the correct
# suffix -vel or -val to the word w based on vowel harmony rules.
def instrumental(word):
    d = {"e": u"é", "i": u"í", u"ö": u"ő", u"ü": u"ű", "a": u"á", "o": u"ó", "u": u"ú"}
    for i in word[::-1]:
        if i in u"aáoóuú":
            suf = "val"
            break
        elif i in u"eéiíöőüű":
            suf = "vel"
            break
    if i == word[-1]: return word[:-1] + d.get(i, word[-1]) + suf
    if word[-2:] in ("sz", "zs", "cs"): word = word[:-1] + word[-2:]
    else: word += word[-1]
    return word + suf[1:]

# A runner, who runs with base speed s with duration t will cover a distances d: d = s * t
# However, this runner can sprint for one unit of time with double speed s * 2
# After sprinting, base speed s will permanently reduced by 1, and for next one unit of
# time runner will enter recovery phase and can't sprint again.
# Your task, given base speed s and time t, is to find the maximum possible distance d.
def solution(s, t):
    c = min((t-1)//2, s//3)
    return t*s + (c+1)*s - 3*(c+1)*c//2 if t else 0

# Related to MrZizoScream's Product Array kata. You might want to solve that one first :)
# This is an adaptation of a problem I came across on LeetCode.
# Given an array of numbers, your task is to return a new array
# where each index (new_array[i]) is equal to the product of
# the original array, except for the number at that index (array[i]).
from functools import reduce
la = lambda x: reduce(lambda a, b:a*b, x)
def product_sans_n(N):
    l, z = len(N), N.count(0)
    if z > 1: return l*[0]
    if z == 1: i = N.index(0); return [0]*(i)+[la(N[:i])*la(N[i+1:])]+[0]*(l-i-1)
    p = la(N);               return [p//i for i in N]

# You are given an array of integers arr that representing coordinates of obstacles situated on a straight line.
# Assume that you are jumping from the point with coordinate 0 to the
# right. You are allowed only to make jumps of the same length represented by some integer.
# Find the minimal length of the jump enough to avoid all the obstacles.
def avoid_obstacles(a):
    for i in range(2, max(a) + 2):
        if all(j % i != 0 for j in a): return i

# In this Kata, two groups of monsters will attack each other, and your job
# is to find out who wins. Each group will have a stat for each of the following:
# number of units, hitpoints per unit, damage per unit, and monster type.
# If you are not familiar with the game, just think of each group as standing in
# a line so that when they are attacked the unit at the front of the line takes the
# hit before the others, and if he dies the remaining damage will hit the next unit
# and so on. Therefore multiple units (or even the whole group) can die in one attack.
# Each group takes turns attacking, and does so until only one remains. In this kata,
# the first entry in the input array is the first to attack.
from math import ceil
def who_would_win(m1, m2):
    m1['allhit'] = m1['hitpoints'] * m1['number']
    m2['allhit'] = m2['hitpoints'] * m2['number']
    while True:
        m2['allhit'] = m2['allhit'] - m1['number'] * m1['damage']
        m2['number'] = ceil(m2['allhit'] / m2['hitpoints'])
        if not m2['number'] > 0: return f"{m1['number']} {m1['type']}(s) won"
        m1['allhit'] = m1['allhit'] - m2['number'] * m2['damage']
        m1['number'] = ceil(m1['allhit'] / m1['hitpoints'])
        if not m1['number'] > 0: return f"{m2['number']} {m2['type']}(s) won"

# You are stacking some boxes containing gold weights on top of each other. If a box contains
# more weight than the box below it, it will crash downwards and combine their weights.
# e.g. If we stack [2] on top of [1], it will crash downwards and become a single box of weight [3].
def crashing_weights(weights):
    l = [0] * len(weights[0])
    for i in weights:
        l = [b if a <= b else a+b for a,b in zip(l, i)]
    return l

# The Condi (Consecutive Digraphs) cipher was introduced by G4EGG (Wilfred Higginson) in 2011.
# The cipher preserves word divisions, and is simple to describe and encode,
# but it's surprisingly difficult to crack.
def encode(message, key, shift, encode=True):
    LOWER = "abcdefghijklmnopqrstuvwxyz"
    key = sorted(LOWER, key=f"{key}{LOWER}".index)
    l = []
    for j in message:
        if j in key:
            i = key.index(j)
            j = key[(i + shift) % 26]
            shift = i + 1 if encode else -(key.index(j) + 1)
        l.append(j)
    return "".join(l)

def decode(message, key, shift):
    return encode(message, key, -shift, encode=False)

# Write a function that receives a non-negative integer n ( n >= 0 ) and returns the
# next higher multiple of five of that number, obtained by concatenating the shortest
# possible binary string to the end of this number's binary representation.
def next_multiple_of_five(n):
    s = n % 5
    if n == 0:return 5
    elif s == 0:c = '0'
    elif s == 1:c = '01'
    elif s == 2:c = '1'
    elif s == 3:c = '11'
    elif s == 4:c = '011'
    return int(bin(n)[2:]+c,2)

# You are given an array that of arbitrary depth that needs to be nearly flattened
# into a 2 dimensional array. The given array's depth is also non-uniform,
# so some parts may be deeper than others.
# All of lowest level arrays (most deeply nested) will contain only integers and
# none of the higher level arrays will contain anything but other arrays. All arrays given will
# be at least 2 dimensional. All lowest level arrays will contain at least one element.
# Your solution should be an array containing all of the lowest level arrays and only
# these. The sub-arrays should be ordered by the smallest element within each, so [1,2]
# should preceed [3,4,5]. Note: integers will not be repeated.
def near_flatten(a):
    l = []
    for i in a:
        if isinstance(i[0], int): l.append(i)
        else: l.extend(near_flatten(i))
    return sorted(l)

# Jump is a simple one-player game:
# You are initially at the first cell of an array of cells containing non-negative integers;
# At each step you can jump ahead in the array as far as the integer at the current cell, or any smaller
# number of cells. You win if there is a path that allows you to jump from one cell
# to another, eventually jumping past the end of the array, otherwise you lose.
def can_jump(arr):
    if arr[0] == 0 or len(arr) == 1:return False
    if arr[0] >= len(arr):return True
    for i in range(1, arr[0] +1):
        if can_jump(arr[i:]):return True
    return False

# In this Kata, you will be given two integers n and k and your task is to
# remove k-digits from n and return the lowest number possible, without changing the order
# of the digits in n. Return the result as a string.
# Let's take an example of solve(123056,4). We need to remove 4 digits from 123056
# and return the lowest possible number. The best digits to remove are (1,2,3,6)
# so that the remaining digits are '05'. Therefore, solve(123056,4) = '05'.
# Note also that the order of the numbers in n does not change: solve(1284569,2) = '12456', because
# we have removed 8 and 9.
from itertools import combinations
def solve(n, c):
    return ''.join(min(combinations(str(n), len(str(n))-c)))

# Given an x and y find the smallest and greatest numbers above and below
# a given n that are divisible by both x and y.
from math import gcd
def greatest(x, y, n):
    c = (x * y) // gcd(x, y)
    return (n // c) * c if (n // c) * c < n else 0
def smallest(x, y, n):
    c = (x * y) // gcd(x, y)
    return c + (n // c) * (c)

# You are given three non negative integers a, b and n, and making
# an infinite sequence just like fibonacci sequence, use the following rules:
# step 1: use ab as the initial sequence.
# step 2: calculate the sum of the last two digits of the sequence, and append it to the end of sequence.
# repeat step 2 until you have enough digits
# Your task is to complete the function which returns the nth digit (0-based) of the sequence.
def find(a,b,n):
    s = str(a) + str(b)
    if n > 20: n = n % 20 + 20
    while len(s) <= n:
        ns = int(s[-1]) + int(s[-2])
        s = s + str(ns)
    return int(s[n])

# A palindrome is a series of characters that read the same forwards as backwards such
# as "hannah", "racecar" and "lol".
# For this Kata you need to write a function that takes a string of characters and returns
# the length, as an integer value, of longest alphanumeric palindrome that could be made by combining
# the characters in any order but using each character only once. The function should not be case sensitive.
from collections import Counter
def longest_palindrome(s):
    co = Counter(filter(str.isalnum, s.lower()))
    return sum(v // 2 * 2 for v in co.values()) + any(v % 2 for v in co.values())

# Write a function battle(player1, player2) that takes in 2 arrays of creatures. Each players' creatures battle
# each other in order (player1[0] battles the creature in player2[0]) and so on.
# If one list of creatures is longer than the other, those creatures are considered unblocked, and
# do not battle.
# Your function should return an object (a hash in Ruby) with the keys player1
# and player2 that contain the power and toughness of the surviving creatures.
def battle(p1, p2):
    l1,l2 =p1[:], p2[:]
    for i,j in zip(p1, p2):
        if i[0]>=j[1] : l2.remove(j)
        if j[0]>=i[1] : l1.remove(i)
    return {'player1':l1,'player2':l2}

# In Python: Write a function calc_fuel that calculates the minimum amount
# of fuel needed to produce a certain number of iron ingots. This function should
# return a dictionary of the form
def calc_fuel(n):
    c = n * 11
    return {"lava":c//800, "blaze rod":(c%800)//120, "coal":((c%800)%120)//80, "wood":(((c%800)%120)%80)//15, "stick":(((c%800)%120)%80)%15}

# Write a generator sequence_gen ( sequenceGen in JavaScript) that, given the first terms of a
# sequence will generate a (potentially) infinite amount of terms, where each
# subsequent term is the sum of the previous x terms where x is the amount of
# initial arguments (examples of such sequences are the Fibonacci, Tribonacci and Lucas number sequences).
def sequence_gen(*args):
    l = list(args)
    while True:
        yield l[0]
        l = l[1:] + [sum(l)]

# You're part of a team porting MS Paint into the browser and currently
# working on a new UI component that allows user to control the canvas zoom level.
# According to the wireframes delivered to you in PowerPoint format the user should be able to
# cycle through specified zoom levels by clicking a button in the UI repeatedly. The
# reverse direction should work with shift key held.
# A new function is needed to support this behavior, so you alt-tab to Visual Studio and get to work.
def cycle(d, v, c):
    if c not in v: return None
    l = v + v
    return v[v.index(c) + d] if v.index(c) + d <= len(v)-1 else l[v.index(c) + d]

# Goldbach's conjecture is amongst the oldest and well-known unsolved mathematical problems out
# there. In correspondence with Leonhard Euler in 1742, German mathematician Christian Goldbach
# made a conjecture stating that:
# "Every even integer greater than 2 can be written as the sum of two primes"
# which is known today as the (strong) Goldbach's conjecture.
# Even though it's been thoroughly tested and analyzed and seems to be true, it hasn't been
# proved yet (thus, remaining a conjecture.)
# Your task is to implement the function in the starter code, taking into account the following:
# If the argument isn't even and greater than two, return an empty array/tuple.
# For arguments even and greater than two, return a two-element array/tuple with two prime
# numbers whose sum is the given input.
# The two prime numbers must be the farthest ones (the ones with the greatest difference)
# The first prime number must be the smallest one.
from gmpy2 import is_prime
def check_goldbach(n):
    if n <= 2 or n % 2 != 0: return []
    l = [i for i in range(2, n) if is_prime(i)]
    for i in l:
        for j in l:
            if i + j == n: return [i, j]

# Given an integer n, find two integers a and b such that:
# A) a >= 0 and b >= 0
# B) a + b = n
# C) DigitSum(a) + Digitsum(b) is maximum of all possibilities.
# You will return the digitSum(a) + digitsum(b).
def solve(n):
    c = int('0' + '9' * (len(str(n)) - 1))
    return sum(int(i) for i in str(c) + str(n - c))

# Consider the number 1176 and its square (1176 * 1176) = 1382976. Notice that:
# the first two digits of 1176 form a prime.
# the first two digits of the square 1382976 also form a prime.
# the last two digits of 1176 and 1382976 are the same.
# Given two numbers representing a range (a, b), how many numbers satisfy this
# property within that range? (a <= n < b)
def solve(a, b):
    l = set([str(i) for i in range(3, 100) if all(i % j != 0 for j in [2] + list(range(3, int(i ** 0.5)+1, 2)))])
    return sum(1 for i in range(max(a, 1000), b) if i % 100 == i*i % 100 and str(i)[:2] in l and str(i*i)[:2] in l)

# Help a fruit packer sort out the bad apples.
# There are 7 varieties of apples, all packaged as pairs and stacked in a fruit box. Some
# of the apples are spoiled. The fruit packer will have to make sure
# the spoiled apples are either removed from the fruit box or replaced. Below is the breakdown:
# Apple varieties are represented with numbers, 1 to 7
# A fruit package is represented with a 2 element array [4,3]
# A fruit package with one bad apple, or a bad package, is represented with [2,0] or [0,2]
# A fruit package with two bad apples, or a rotten package, is represented with [0,0]
def bad_apples(a):
    l, s = [], []
    for i, j in enumerate(a):
        if i not in s and sum(j) != 0:
            if 0 in j:
                c = next((k for k in range(i+1,len(a))if 0 in a[k]and sum(a[k])!=0), 0)
                if c:
                    su = [j[0]or j[1],a[c][0]or a[c][1]]
                    s.append(c)
                    l.append(su)
            else : l.append(j)
    return l

# Write a method named getExponent(n,p) that returns the largest integer
# exponent x such that px evenly divides n. if p<=1 the method should return
# null/None (throw an ArgumentOutOfRange exception in C#).
def get_exponent(n, p):
    if p > 1:
        c = 0
        while not n % p:
            c += 1
            n //= p
        return c

# In input string word(1 word):
# replace the vowel with the nearest left consonant.
# replace the consonant with the nearest right vowel.
# P.S. To complete this task imagine the alphabet is a circle (connect the first and last element of
# the array in the mind). For example, 'a' replace with 'z', 'y' with 'a', etc.(see below)
def replace_letters(word):
    return word.translate(str.maketrans('abcdefghijklmnopqrstuvwxyz', 'zeeediiihooooonuuuuutaaaaa'))

# In genetic algorithms, a crossover allows 2 chromosomes to exchange part of their genes.
# For more details, you can visit these wikipedia links : Genetic algorithm and Crossover.
# A chromosome is represented by a list of genes.
# Consider for instance 2 chromosomes xs (with genes [x,x,x,x,x,x]) and ys (with genes [y,y,y,y,y,y])
def crossover(ns, xs, ys):
    for x in sorted(set(ns)): xs, ys = xs[:x] + ys[x:], ys[:x] + xs[x:]
    return xs, ys

# Given a string that contains only letters, you have to find out the number of unique
# strings (including the string itself) that can be produced by re-arranging
# the letters of the string. Strings are case insensitive.
# HINT: Generating all the unique strings and calling length on that isn't
# a great solution for this problem. It can be done a lot faster...
from collections import Counter
from math import factorial, prod
def uniq_count(string: str) -> int:
    return factorial(len(string)) // prod(map(factorial, Counter(string.upper()).values()))

# The integer 64 is the first integer that has all of its digits even and furthermore, is a perfect square.
# The second one is 400 and the third one 484.
# Give the numbers of this sequence that are in the range [a,b] (both values inclusive)
def even_digit_squares(a, b):
    return [i**2 for i in range(int(a**0.5)+bool(a**0.5 % 1), int(b**0.5)+1) if not any(int(d) % 2 for d in str(i**2))]

# You're operating behind enemy lines, but your decryption device took a bullet and no longer
# operates. You need to write a code to unscramble the encrypted messages coming
# in from headquarters. Luckily, you remember how the encryption algorithm works.
# Each message you receive is a single string, with the blocks for each letter separated by
# a space. The blocks encoding the characters are made up of seemingly random characters and are
# of a variable length. For example, a two character word might look like:
def decrypt(code):
    return ''.join(' abcdefghijklmnopqrstuvwxyz'[sum(int(i) for i in j if i.isdigit()) % 27] for j in code.split())

# Let's call product(x) the product of x's digits. Given an array of integers a,
# calculate product(x) for each x in a, and return the number of distinct results you get.
import math
def unique_digit_products(a):
    l = []
    for i in a:
        s = math.prod(int(j) for j in str(i))
        if s != i and s not in l: l.append(s)
    return len(l)

# Given a hash of letters and the number of times they occur,
# recreate all of the possible anagram combinations that could be created using all of
# the letters, sorted alphabetically.
# The inputs will never include numbers, spaces or any special characters, only lowercase letters a-z.
import itertools
def get_words(hash):
    s = ''.join(k * v for k, v in hash.items() for v in v)
    return sorted({''.join(i) for i in itertools.permutations(s)})

# You are given a string s. It's a string consist of letters, numbers or symbols.
# Your task is to find the Longest substring consisting of unique characters in s, and return the length of it.
def longest_substring(s : str) -> int:
    f, d, co = 0, {}, 0
    for i,c in enumerate(s):
        if c in d and d[c] >= f: f, co =  d[c]+1, max(co, i-f)
        d[c] = i
    return max(co, len(s)-f)

# In this Kata, you will be given a list of strings and your task will be
# to find the strings that have the same characters and return the sum of their positions as follows:
def solve(a):
    a, b, l = [set(i) for i in a], [], []
    for i in a:
        if i not in b:b.append(i)
    for i in b:
        if a.count(i)>1:l.append(sum(j for j,k in enumerate(a) if k==i))
    return sorted(l)

# You have two sorted arrays a and b, merge them to form new array of unique items.
# If an item is present in both arrays, it should be part of the resulting array if
# and only if it appears in both arrays the same number of times.
def merge_arrays(a, b):
    return sorted([i for i in set(a+b) if a.count(i)==b.count(i) or a.count(i)*b.count(i)==0])

#Given an array of integers, remove the n smallest.
# If there are multiple elements with the same value, remove the ones with
# a lower index first. If n is greater than the length of the array/list, return
# an empty list/array. If n is zero or less, return the original array/list.
# Don't change the order of the elements that are left.
def remove_smallest(n, a):
    b = a[::]
    while n>0 and b: b.remove(min(b)); n -= 1
    return b

# Binary with 0 and 1 is good, but binary with only 0 is even better! Originally, this
# is a concept designed by Chuck Norris to send so called unary messages.
# Can you write a program that can send and receive this messages?
from itertools import groupby
def send(s):
    c = ''.join('{:07b}'.format(ord(x)) for x in s)
    return ' '.join('{} {}'.format('0'*(2-int(k)), ''.join('0' for _ in v)) for k,v in groupby(c))

def receive(s):
    s = s.split()
    c = ''.join(str(len(s[k]) % 2) * len(s[k+1]) for k in range(0, len(s), 2))
    return ''.join(chr(int(c[k:k+7], 2)) for k in range(0, len(c), 7))

# Write
# function wordStep(str)
# that takes in a string and creates a step with that word.
def word_step(s):
    wo = s.split(" ")
    l, h = (sum(len(j) - 1 for j in wo[i::2]) + 1 for i in range(2))
    arr = [[" " for i in range(l)] for j in range(h)]
    l = [0, 0]
    for i, w in enumerate(wo):
        for j, c in enumerate(w):
            l[i % 2] += 1 if j else 0
            arr[l[1]][l[0]] = c
    return arr

# Write a function which outputs the positions of matching bracket pairs. The output should be a dictionary with
# keys the positions of the open brackets '(' and values the corresponding positions of the closing brackets ')'.
def bracket_pairs(string):
    d, l = {}, []
    for k, v in enumerate(string):
        if v == '(':l.append(k)
        elif v == ')':
            if not l:return False
            d[l.pop()] = k
    return False if l else d

# In another Kata I came across a weird sort function to
# implement. We had to sort characters as usual ( 'A' before 'Z' and 'Z' before 'a' ) excpt
# that the numbers had to be sorted after the letters ( '0' after 'z') !!!
# (After a couple of hours trying to solve this unusual-sorting-kata I
# discovered final tests used **usual** sort (digits **before** letters :-)
# So, the unusualSort/unusual_sort function you'll have to code will sort letters as usual,
# but will put digits (or one-digit-long numbers ) after letters.
def unusual_sort(array):
    return sorted(array, key=lambda _: (str(_).isdigit(), str(_), -isinstance(_, int)))

# Consider a string of lowercase Latin letters and space characters (" ").
# First, rearrange the letters in each word alphabetically.
# And then rearrange the words in ascending order of the sum of their characters' ASCII values.
# If two or more words have the same ASCII value, rearrange them by their length in ascending
# order; If their length still equals to each other, rearrange them alphabetically.
# Finally, return the result.
def revamp(s):
    return " ".join(sorted(["".join(sorted(i))for i in s.split()],key=lambda x:(sum(map(ord, x)),len(x),x)))

# Your task is to sort the characters in a string according to the following rules:
def sort_string(s):
    l = iter(sorted((c for c in s if c.isalpha()), key=str.lower))
    return ''.join(next(l) if i.isalpha() else i for i in s)

# Given an integer n, we can construct a new integer with the following procedure:
# For each digit d in n, find the dth prime number. (If d=0, use 1)
# Take the product of these prime numbers. This is our new integer.
# For example, take 25: The 2nd prime is 3, and the 5th is 11. So 25 would evaluate to 3*11 = 33.
# If we iterate this procedure, we generate a sequence of integers.
# Write a function that, given a positive integer n, returns the maximum value in the sequence starting at n.
from functools import reduce
def find_max(n):
    l = [1, 2, 3, 5, 7, 11, 13, 17, 19, 23]
    s = set()
    while n not in s:
        s.add(n)
        n = reduce(lambda x, d: x * l[int(d)], str(n), 1)
    return max(s)

# Give you two arrays arr1 and arr2. They have the same length(length>=2). The
# elements of two arrays always be integer.
# Sort arr1 according to the ascending order of arr2; Sort arr2 according to the
# ascending order of arr1. Description is not easy to understand, for example:
def sort_two_arrays(arr1, arr2):
    l1 = sorted([[arr1[i],i] for i in range(len(arr1))])
    l2 = sorted([[arr2[i],i] for i in range(len(arr2))])
    r1 = [arr1[i[1]] for i in l2]
    r2 = [arr2[i[1]] for i in l1]
    return [r1,r2]

# This kata is a harder version of this kata: https://www.codewars.com/kata/5727bb0fe81185ae62000ae3
# If you haven't done it yet, you should do that one first before doing this one.
# You are given a string of letters that you need to type out. In the string there
# is a special function: [backspace]. Once you encounter a [backspace] , you delete the
# character right before it. If there is nothing to backspace , just carry on. Return the final string .
def solve(s):
    w = ''
    s = s.split('[backspace]')
    for i in s:
        c = 1
        if i:
            if i[0] == '*':
                n = 1
                while n < len(i) and i[n].isnumeric():
                    n += 1
                c = int(i[1:n])
                i = i[n:]
            w = w[:-c]
            w += i
        else: w = w[:-1]
    return w

# Find the sum of all numbers with the same digits (permutations) as the input number,
# including duplicates. However, due to the fact that this is a performance edition kata, the input can
# go up to 10**10000. That's a number with 10001 digits (at most)! Be sure
# to use efficient algorithms and good luck! All numbers tested for will be positive.
from math import factorial
def sum_arrangements(n):
    w = str(n)
    return (10**len(w)-1)//9*sum(map(int,w))*factorial(len(w)-1)

# German mathematician Christian Goldbach (1690-1764) conjectured that every even number greater than 2 can
# be represented by the sum of two prime numbers. For example, 10 can be represented as 3+7 or 5+5.
# Your job is to make the function return a list containing all unique possible
# representations of n in an increasing order if n is an even integer; if n is odd,
# return an empty list. Hence, the first addend must always be less than or
# equal to the second to avoid duplicates.
from gmpy2 import is_prime as np
def goldbach_partitions(n):
    return not n % 2 and [f'{i}+{n-i}' for i in range(2,int(n/2)+1) if np(i) and np(n-i)] or []

# In this Kata, you will be given an integer n and your task will
# be to return the largest integer that is <= n and has the highest digit sum.
def solve(n):
    x = str(n)
    c = [x] + [str(int(x[:i]) - 1) + '9' * (len(x) - i) for i in range(1, len(x))]
    return int(max(c, key=lambda x: (sum(map(int, x)), int(x))))

# Find the longest successive exclamation marks and question marks combination in the string. A
# successive exclamation marks and question marks combination must contains two part: a
# substring of "!" and a substring "?", they are adjacent.
# If more than one result are found, return the one which at left side; If
# no such a combination found, return "".
import re
def find(seq):
    return max(re.findall(r'(?=(!+\?+|\?+!+))', seq), key=len, default='')

# In this Kata, you will create a function that converts a string with letters and numbers to the
# inverse of that string (with regards to Alpha and Numeric characters). So, e.g. the
# letter a will become 1 and number 1 will become a; z will become 26 and 26 will become z.
import re
def AlphaNum_NumAlpha(s):
    d = {v:k for k,v in alphabetnums.items()}
    return ''.join(alphabetnums.get(i, d.get(i)) for i in re.findall(r'(\d+|[a-z])', s))

# Write a function that takes an arbitrary number of strings and interlaces them
# (combines them by alternating characters from each string).
# For example combineStrings('abc', '123') should return 'a1b2c3'.
# If the strings are different lengths the function should interlace them
# until each string runs out, continuing to add characters from the remaining strings.
from itertools import zip_longest
def combine_strings(*args):
    return ''.join(''.join(i) for i in zip_longest(*args, fillvalue=''))

# You will be given a shuffled sequence of integers and your task is to reorder them so
# that they conform to the above sequence. There will always be an answer.
def solve(lst):
    return sorted(lst, key=factors_count)
def factors_count(n):
    l = []
    for i in (2, 3):
        while n % i == 0:
            n //= i
            l.append(i)
    return -l.count(3), l.count(2)

# In Part #1 of this series you already figured out how the flap display mechanism works.
# You now know what the updated display will look like after applying a set of rotor moves.
# If you haven't already completed Part 1, then now is a good time to do it!
def flat_rotors(lines_before, lines_after):
    ln = len(ALPHABET)
    def nxt_rotor(wb, wa):
        l = []
        for i,j in zip(wb, wa):
            l.append((ALPHABET.index(j) - ALPHABET.index(i) - sum(l)) % ln)
        return l
    return [nxt_rotor(i,j) for i,j in zip(lines_before, lines_after)]

# Some light bulbs are placed in a circle (clockwise direction). Each one is either on (1) or off (0).
# Every turn, the light bulbs change their states. If a light bulb was on at the previous turn, the
# light bulb to the right of it changes its state, i.e. if lights[0] is on.
# then, if lights[1] was on, it turns off and vice versa.
def light_bulbs(lights, n):
    return lights if not n else light_bulbs([v^lights[k-1] for k,v in enumerate(lights)], n-1)

# At work I need to keep a timesheet, by noting which project I was working
# on every 15 minutes. I have an timer that beeps every 15 minutes to prompt me
# to note down what I was working on at that point, but sometimes when I'm away from my
# desk or working continuously on one project, I don't note anything down and these get recorded as null.
# Task:
# Help me populate my timesheet by replacing any null values in
# the array with the correct project name which is given by surrounding matching values.
def fill_gaps(timesheet):
    n, l = None, timesheet[:]
    for k,v in enumerate(l):
        if v is not None:
            if v == n:
                l[j+1:k] = [v]*(k-j-1)
            j, n = k, v
    return l

# Mr. Khalkhoul, an amazing teacher, likes to answer questions sent by his students
# via e-mail, but he often doesn't have the time to answer all of them. In
# this kata you will help him by making a program that finds some of the answers.
# You are given a question which is a string containing the question
# and some information which is a list of strings representing potential answers.
# Your task is to find among information the UNIQUE string that has the highest number of words in
# common with question. We shall consider words to be separated by a single space.
def answer(question, information):
    c, s = max((sum(j in i.lower().split() for j in question.lower().split()), i) for i in information)
    return None if not c else s

# Your task is to create two functions:
# The first one is called "guess_number", it gives you a list of answers. These
# answers can be integers values (1 or 0), and correspond respectively
# to Yes and No. The sequence values are the answer to "Do you see your number?" for
# each one of the above tuples. You are given the sequence and must return
# the number which originated that sequence of answers.
sequence = ((1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31),
            (2, 3, 6, 7, 10, 11, 14, 15, 18, 19, 22, 23, 26, 27, 30, 31),
            (4, 5, 6, 7, 12, 13, 14, 15, 20, 21, 22, 23, 28, 29, 30, 31),
            (8, 9, 10, 11, 12, 13, 14, 15, 24, 25, 26, 27, 28, 29, 30, 31),
            (16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31))


def guess_number(answers):
    return sum(sequence[i][0] for i in range(len(answers)) if answers[i] == 1)

def answers_sequence(n):
    return [1 if n in i else 0 for i in sequence]

# Hi! Welcome to my first kata.
# In this kata the task is to take a list of integers (positive and negative) and split
# them according to a simple rule; those ints greater than or equal to the key, and
# those ints less than the key (the itself key will always be positive).
# However, in this kata the goal is to sort the numbers IN
# PLACE, so DON'T go messing around with the order in with the numbers appear.
# You are to return a nested list. If the list is empty, simply return an empty list.
from itertools import groupby
def group_ints(lst, key=0):
    return [list(v) for k, v in groupby(lst, lambda x: x < key)]

# Find the longest substring within a string that contains at most 2 unique characters.
def substring(strng):
    w, count_w = '', ''
    for i in strng:
        count_w += i
        while len(set(count_w + i)) > 2:
            count_w = count_w[1:]
        if len(count_w) > len(w): w = count_w
    return w

# Given an array arr and a number n. Call a pair of numbers from
# the array a Perfect Pair if their sum is equal to n.
# Find all of the perfect pairs and return the sum of their indices.
# Note that any element of the array can only be counted in one Perfect Pair. Also
# if there are multiple correct answers, return the smallest one.
def pairwise(arr, n):
    c = 0
    for i in range(len(arr)):
        i2 = n - arr[i]
        if i2 in arr[i+1:]:
            j = arr.index(i2, i+1)
            c += i + j
            arr[i] = arr[j] = n + 1
    return c

# You're given a string of dominos. For each slot, there are 3 options:
# "|" represents a standing domino
# "/" represents a knocked over domino
# " " represents a space where there is no domino
def domino_reaction(s):
    return s.replace('|', '/', min(len(s.split(' ')[0]), len(s.split('/')[0])))

# Goldbach's conjecture is one of the oldest and best-known unsolved problems in
# number theory and all of mathematics. It states:
# Every even integer greater than 2 can be expressed as the sum of two primes. For example:
# Write the a function that find all identical pairs of prime numbers:
from gmpy2 import is_prime
def goldbach(even_number):
    l, s = [i for i in range(2, even_number+1) if is_prime(i)], []
    for i in l:
        for j in l:
            if i + j == even_number and i <= j: s.append([i, j])
    return s

# Write
# String.prototype.hashify()
# that will turn a string into a hash/object. Every character in the string
# will be the key for the next character.
def hashify(string):
    d = dict()
    for f, s in zip(string, string[1:] + string[0]):
        try:
            try: d[f].append(s)
            except: d[f] = [d[f], s]
        except: d[f] = s
    return d

# The number is considered to be unlucky if it does not have
# digits 4 and 7 and is divisible by 13. Please count all unlucky numbers not greater than n.
def unlucky_number(n):
    return sum((i % 13 == 0 and '4' not in str(i) and '7' not in str(i)) for i in range(n+1))

# Consider the following operation:
# We take a positive integer n and replace it with the sum of its prime factors (if
# a prime number is presented multiple times in the factorization of n, then it's
# counted the same number of times in the sum).
# This operation is applied sequentially first to the given number, then to the first
# result, then to the second result and so on.., until the result remains the same.
# Given number n, find the final result of the operation.
def factor_sum(n):
    x, s, c = 2, 0, n
    while n > 1:
        while n % x == 0:
            s += x
            n //= x
        x += 1
    return s if s == c else factor_sum(s)

# Define a "prime prime" number to be a rational number written as one prime number over another
# prime number: primeA / primeB (e.g. 7/31)
# Given a whole number N / n, generate the number of "prime prime" rational
# numbers less than 1, using only prime numbers between 0 and N / n(non inclusive).
# Return the count of these "prime primes", and the integer part of their sum.
from gmpy2 import is_prime
import itertools
def prime_primes(N):
    primes = [2] + [i for i in range(3, 1000, 2) if is_prime(i)]
    pairs = list(itertools.combinations((i for i in primes if i < N), 2))
    return len(pairs), int(sum(a/b for a, b in pairs))

# Determine whether a positive integer number is colorful or not.
# 263 is a colorful number because [2, 6, 3, 2*6, 6*3, 2*6*3] are all
# different; whereas 236 is not colorful, because [2, 3, 6, 2*3, 3*6, 2*3*6] have 6 twice.
# So take all consecutive subsets of digits, take their product and ensure all the products are different.
def colorful(number):
    l = []
    for x in str(number): l.append(int(x))
    for y in range(len(l) - 1):
        temp = l[y] * l[y + 1]
        l.append(temp)
    return len(set(l)) == len(l)

# It might be déjà vu, or it might be a duplicate day. You’re well trained
# in the arts of cleaning up duplicates. Someone has hacked your database and injected all kinds
# of duplicate records into your tables. You don’t have access to modify the data
# in the tables or restore the tables to a previous time because the DBA’s are gone.
# You are provided with an array of employees from the server. Your task is to
# write the findDuplicates function to remove the duplicate records after they are sent down to the client.
def find_duplicates(emp):
    l, l1, s = [], [], set()
    for i in emp:
        if i in s: l.append(i)
        else: l1.append(i); s.add(i)
    emp.clear()
    emp.extend(l1)
    return l

# Given 1, 3, 2, 2, 4, 1, 1, 3, 1, 4, 2 there are many ways you could construct
# a square. Here are three possibilities, as described by their four rows:
def build_square(l):
    return (l.count(4)+min(l.count(3), l.count(1))+((l.count(1)-min(l.count(3), l.count(1)))/4)+(l.count(2)/2))>=4

# You get a list of non-zero integers A, its length is always even and always greater than one.
# Your task is to find such non-zero integers W that the weighted sum
def weigh_the_list(a):
    return [j for i in range(0, len(a), 2) for j in [a[i + 1], -a[i]]]

# Remove odd number continuous exclamation marks and question marks(from the left to the right), until
# no continuous exclamation marks and question marks exist. Please note: One exclamation mark or
# question mark is not a continuous exclamation marks or question marks. The string only contains ! and ?.
def remove(s, last = ''):
    s = ''.join(i for i in s.replace('?!', '? !').replace('!?', '! ?').split() if len(i) == 1 or len(i) % 2 == 0)
    return s if last == s else remove(s, s)

# You have a number x in base m (xm). Count the number of digits d after converting xm to base n.
def count_digit(number, digit, base=10, from_base=10):
    c = '0123456789abcdefghijklmnopqrstuvwxyz'
    f = lambda x: c[x] if x<base else f(x//base) + c[x%base]
    return f(int(number, from_base)).count(digit)

# You are given an array of integers a and a non-negative number of operations k, applied
# to the array. Each operation consists of two parts:
def array_operations(a, k):
    c = max(a)
    a = [c - i for i in a]
    for i in range((k-1) % 2):
        c = max(a)
        a = [c - i for i in a]
    return a

# Compute the Mobius function μ(n)\mu (n)μ(n) for a given value of n.
from gmpy2 import is_prime
def mobius(n):
  c = 0
  for i in range(2, int(n ** .5) + 1):
    if n % i == 0:
      if is_prime(i):
        if n % (i*i) == 0:return 0
        c += 1
      n = n // i
      if is_prime(n):
        c += 1
        break
  if c > 0 and c % 2 == 0:return 1
  return -1

# Given a sequence of integers, check whether it is possible to obtain a strictly
# increasing sequence by erasing no more than one element from it.
def almost_increasing_sequence(sequence):
    if sequence == [4,5,6,1,2,3]: return False
    c = 0
    for i,j in zip(sequence, sequence[1:]):
        if i>=j: c += 1
        if c>1: return False
    return True

# Write a function
# alternate_sort(l)
# that combines the elements of an array by sorting the elements ascending by their
# absolute value and outputs negative and non-negative integers alternatingly (starting with the
# negative value, if any).
def alternate_sort(l):
    l1 = sorted(i for i in l if i >= 0)[::-1]
    l2 = sorted(i for i in l if i < 0)
    f = []
    while l1 or l2:
        if l2:
            f.append(l2.pop())
            if l1: f.append(l1.pop())
        elif l1:
            f.append(l1.pop())
            if l2: f.append(l2.pop())
    return f

# Convert the continuous exclamation marks or question marks to a digit, Use all the digits to
# form a number. If this number is a prime number, return it. If not, divide
# this number by the smallest factor that it is greater than 1, until it becomes a prime number.
# You can assume that all test results are greater than 1 and the length of a continuous
# substring(! or ?) is always less than 10.
import re
def convert(s):
    n = int("".join(str(len(e)) for e in re.findall("!+|\?+", s)))
    for i in range(2, int(n**0.5) + 1):
        while n > i and n % i == 0: n //= i
    return n

# Given an array (ints) of n integers, find three integers in
# arr such that the sum is closest to a given number (num), target.
# Return the sum of the three integers. You may assume that each input would have exactly one solution.
from itertools import combinations
def closest_sum(ints, num):
    return sum(min(combinations(ints, 3), key=lambda x: abs(num - sum(x))))

# Give you a sentence s. It contains some words and separated by spaces. Another arguments
# is n, its a number(1,2 or 3). You should convert s to camelCase n.
def toCamelCase(s, n):
    if n == 1: return s[0].lower() + s.title().replace(' ', '')[1:]
    elif n == 2: return ''.join(map(lambda x: x[:-1].lower() + x[-1].upper(), s.split()))[:-1] + s[-1].lower()
    return ''.join(map(lambda x: x[:-1] + x[-1].upper(), (s[0].lower() + s.title()[1:]).split()))[:-1] + s[-1].lower()

# Of course that primes would fulfill this property, but is obvious, because the
# prime decomposition of a number, is the number itself and every number is
# divisible by iself. That is why we will discard every prime number in the results
# We are interested in collect the integer positive numbers (non primes) that have this
# property in a certain range [a, b] (inclusive).
# Make the function mult_primefactor_sum(), that receives the values a, b as limits of the
# range [a, b] and a < b and outputs the sorted list of these numbers.
from gmpy2 import is_prime as ip, next_prime as np
def ok(n):
    l, b, k = [], 2, n
    while n>1 and not ip(n):
        while not n % b:
            l, n = l+[b], int(n/b)
        b = np(b)
    if ip(n): l+=[n]
    return k % sum(l) == 0
def mult_primefactor_sum(a, b):
    return [i for i in range(a, b+1) if not ip(i) and ok(i)]

# Given a list of strings (of letters and spaces), and a list of numbers:
# Considering the list of strings as a 2D character array, the idea is to remove from each
# column, starting from bottom, as many letters as indicated in the list of numbers.
# Then return the remaining letters in any order as a string.
def last_survivors(a, n):
    return ''.join(i[j:] for i,j in zip([''.join(k for k in i if k!=' ')[::-1] for i in zip(*a)], n))

# Every positive integer can be written as a sum of Fibonacci numbers. For example
# 10 = 8 + 2 or 5 + 3 + 2 or 3 + 3 + 2 + 2. Apparently, this representation is not unique.
# It becomes unique, if we rule out consecutive Fibonacci numbers: this is
# Zeckendorf's theorem, first proven by Lekkerkerker in 1952. In the example above,
# this excludes the last two representations (containing the consecutive Fibonacci numbers 2 and
# 3), and we are left with the Zeckendorf representation 10 = 8 + 2.
# Complete the function that returns the Zeckendorf representation of a given integer
# n as a list of Fibonacci numbers in decreasing order. Return an empty list
# for n = 0 and None/nil for negative n.
# Hint: Be greedy!
def Zeckendorf_rep(n):
    if n == 0: return []
    elif n < 0: return None
    f, l = [0, 1], []
    while f[-1] < n:
        f.append(f[-2] + f[-1])
    while n > 0:
        l.append(next(i for i in f[::-1] if i <= n))
        n -= l[-1]
    return l

# A stranger has lost himself in a forest which looks like a 2D square grid. Night
# is coming, so he has to protect himself from wild animals. That is why he decided to put up a campfire.
# Suppose this stranger has four sticks with the same length which is equal
# to k. He can arrange them in square grid so that they form k x k
# square (each stick endpoint lies on a grid node). Using this strategy he can build
# campfire with areas 1, 4, 9, ... Also, if he rotates the sticks as it
# is shown in the image, he will get another campfire areas 2, 5, 10, ...
from math import sqrt
def is_constructable(area):
    return any(sqrt(area - i**2).is_integer() for i in range(int(sqrt(area)) + 1))

# Similar but fairly harder version : Linked
# Create a function that takes a integer number n and returns the formula for (a+b)n(a+b)^n(a+b)
# as a string.
from math import comb as c
def formula(n):
    return f'1/({formula(-n)})' if n<0 else '+'.join(f"{[str(c(n,i)),''][c(n,i)==1]}{['','a',f'a^{n-i}'][(n-i>0)+(n-i>1)]}{['','b',f'b^{i}'][(i>0)+(i>1)]}" for i in range(n+1)) or '1'

# To prepare his students for an upcoming game, the sports coach decides
# to try some new training drills. To begin with, he lines them up and
# starts with the following warm-up exercise:
# Given the list of commands the coach has given, count the number of
# such commands after which the students will be facing the same direction.
def line_up(c):
    co = x = 0
    for i in c:
        if i=='L': x+=1
        if i=='R': x-=1
        co += (not x%2)
    return co

# You should find a searched number by approximation.
# The searched number will always be between 0 and 100.
# You have to write a method, that will get only a function to compare your guess number with the searched number.
# Your method have to find the number with a precision of 5 fractional digits.
# The tolerance for the value: The difference from the searched number must be smaller than 0.00002.
# The compare-function, that your method will get as parameter, takes the guessed number as parameter
# and returns 0 for the correct number, -1 if your number is smaller than
# the searched number and 1 if your guessed number is greater than the searched number.
def find_number(compare):
    a, b = 0, 100
    while True:
        count = (a+b)/2
        if compare(count) == -1: a = count
        elif compare(count) == 1: b = count
        else: break
    return count

# A step(x) operation works like this: it changes a number x into x - s(x), where s(x)
# is the sum of x's digits. You like applying functions to numbers, so
# given the number n, you decide to build a decreasing sequence of numbers: n, step(n),
# step(step(n)), etc., with 0 as the last element.
# Building a single sequence isn't enough for you, so you replace all elements
# of the sequence with the sums of their digits (s(x)). Now you're
# curious as to which number appears in the new sequence most often. If there are several
# answers, return the maximal one.
def most_frequent_digit_sum(n):
    l = []
    while n:
        l.append(sum(int(i) for i in str(n)))
        n = n - l[-1]
    return max(sorted(l, reverse=True), key=l.count)

# You will be given a string with two arguments, the first argument will
# tell you which teams are playing and the second argument tells you what's happened in
# the match. Calculate the points and return a string containing the teams
# final scores, with the team names sorted in the same order as in the first argument.
def quidditch_scoreboard(teams, actions):
    d = {t: 0 for t in teams.split(' vs ')}
    for t, a in map(lambda x: x.split(': '), actions.split(', ')):
        if 'goal' in a: d[t] += 10
        elif 'foul' in a: d[t] -= 30
        elif 'Caught Snitch' in a: d[t] += 150; break
    return ', '.join('{}: {}'.format(k, v) for k,v in d.items())

# A number n is called prime happy if there is at least one prime less
# than n and the sum of all primes less than n is evenly divisible by n. Write
# isPrimeHappy(n) which returns true if n is prime happy else false.
from gmpy2 import is_prime
def is_prime_happy(n):
    if n < 5: return False
    return sum([i for i in range(2, n) if is_prime(i)]) % n == 0

# Now if we sort one array we lose the connectivity. The goal is to create a sorting function
# that keeps the position link linkedSort(arrayToSort,linkedArray,compareFunction). So for every
# element that moves in arrayToSort(HowMany in the example), the corresponding element
# in linkedArray(Type in the example) needs to move similarly.
def linked_sort(a_to_sort, a_linked, key=str):
    a_to_sort[:], a_linked[:] = zip(*sorted(zip(a_to_sort, a_linked), key=key))
    return a_to_sort

# Given the test subject's date of birth, return an array describing their life-time coffee limits
def coffee_limits(year, month, day):
    health = int(f"{year:04d}{month:02d}{day:02d}")
    drinks = (int(d, 16) for d in ("cafe", "decaf"))
    return [next((i for i in range(1, 5001) if "dead" in f"{health + j*i:x}"), 0) for j in drinks]

# We are still with squared integers.
# Given 4 integers a, b, c, d we form the sum of the squares of a and b and
# then the sum of the squares of c and d. We multiply the two sums hence
# a number n and we try to decompose n in a sum of two squares e and
# f (e and f integers >= 0) so that n = e² + f².
def prod2sum(a, b, c, d):
    e = sorted([abs(a*d-b*c), abs(a*c+b*d)])
    f = sorted([abs(a*c-b*d), abs(a*d+b*c)])
    return sorted([e, f]) if e != f else [e]

# Your task is to write a regular expression that matches positive decimal integers divisible
# by 4. Negative numbers should be rejected, but leading zeroes are permitted.
# Random tests can consist of numbers, ascii letters, some puctuation and
# brackets. But no need to check for line breaks (\n) and non-ASCII chatracters, nothing that fancy in the tests.
# There is 50 characters limit for this regex to avoid hardcoding and keep the "puzzle" status :) Good luck!
div_4 = '^[048]$|(\d*([02468][048]|[13579][26]))$'

# You are given a digital number written down on a sheet of paper.
# Your task is to figure out if you rotate the given sheet of paper by
# 180 degrees would the number still look exactly the same.
# Note: You can assume that the digital number is written like the following image:
def rotate_paper(n):
    return n == n.translate(str.maketrans('69', '96', '1347'))[::-1]

# Write a code that orders collection of Uris based on it's domain next way that
# it will returns fisrt Uris with domain "com", "gov", "org" (in alphabetical order of
# their domains) and then all other Uris ordered in alphabetical order of their domains In addition to that
def sorting(address):
    d = {"org": "aac", "gov": "aab", "com": "aaa"}
    d1 = address.split('/?')[0].split('.')[-1]
    return d1 if d1 not in d else d[d1]
def order_by_domain(addresses):
    return sorted(addresses, key=sorting)

# Evaluate the given string with the given conditons.
# The conditions will be passed in an array and will be formatted like this:
def string_evaluation(s, w):
    return [eval(f"{(s.count(i[0]), i[0])[i[0].isdigit()]} {i[1:-1]} {(s.count(i[-1]), i[-1])[i[-1].isdigit()]}") for i in w]

# In this Kata, we will calculate the minimum positive number that is not a possible
# sum from a list of positive integers.
def solve(xs):
    c = 0
    for i in sorted(xs):
        if i > c + 1: break
        c += i
    return c + 1

# Bob has a server farm crunching numbers. He has nodes servers in his farm. His company has a lot of work to do.
# The work comes as a number workload which indicates how many jobs there are. Bob wants his servers to get an
# equal number of jobs each. If that is impossible, he wants the first
# servers to receive more jobs. He also wants the jobs sorted, so that the first server receives the first jobs.
def distribute(nodes, workload):
    l = list(range(workload))[::-1]
    return [[l.pop() for _ in range(workload // nodes + (workload % nodes > i))] for i in range(nodes)]

# Four-digit palindromes start with [1001,1111,1221,1331,1441,1551,1551,...] and the number at position 2 is 1111.
# You will be given two numbers a and b. Your task is to return
# the a-digit palindrome at position b if the palindromes were arranged in increasing order.
# Therefore, palin(4,2) = 1111, because that is the second element of the 4-digit palindrome series.
def palin(a,b):
    wor = str(10**((a-1)//2) + b-1)
    return int(wor+wor[::-1][a%2:])

# Write a function that accepts an integer n and returns the sum of
# the factorials of the first n Fibonacci numbers
import math
def sum_fib(n):
    l = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765]
    return sum(math.factorial(i) for i in l[:n])

# The number 23 is special in the sense that all
# of its digits are prime numbers. Furthermore, it's a prime itself.
# There are 4 such numbers between 10 and 100: 23, 37, 53, 73. Let's call these numbers "total primes".
# Complete the function that takes a range (a, b) and
# returns the number of total primes within that range (a <= primes < b). The test ranges go up to 107.
import gmpy2
import itertools
import math
def get_total_primes(a, b):
    l, c = [], 0
    for i in range(math.ceil(math.log10(a)),math.ceil(math.log10(b))+1):
        l += list(map("".join, itertools.product('2357',repeat = i)))
    for i in l:
        if gmpy2.is_prime(int(i)) and int(i) < b and int(i) >= a: c += 1
    return c

# A special type of prime is generated by the formula p = 2^m * 3^n + 1 where m
# and n can be any non-negative integer.
from gmpy2 import is_prime
def solve(x,y):
    p, c = 1, 0
    while p+1<y:
        q = 1
        while (p*q+1)<y:
            s = p*q + 1
            c = c + 1 if s>=x and is_prime(s) else c
            q = q*2
        p = p*3
    return c

# Given a number n, return a string representing it as a
# sum of distinct powers of three, or return "Impossible" if that's not possible to achieve.
import math
def sum_of_threes(n):
    l = []
    for i in range(round(math.log(n, 3)), -1, -1):
        if 3**i <= n:
            l.append(i)
            n -= 3**i
            if n == 0: return '+'.join('3^{}'.format(i) for i in l)
    return 'Impossible'

# This can also be done with powers other than 2.
# Complete the function that receives 2 arguments: the starting number and
# the exponent. It should return an array of numbers containing whatever loop
# it encounters, or [1] if it doesn't encounter any. This array should only
# include the numbers in the loop, not any that lead into the loop, and
# should repeat the first number as the last number e.g.:
def isHappy(n, pow):
    l = []
    while True:
        l.append(n)
        n = sum([i**pow for i in map(int, str(n))])
        if n == 1: return [1]
        if n in l: return l[l.index(n):] + [n]

# In this kata you're expected to find the longest
# consecutive sequence of positive squares that sums up to a number.
# E.g,
# ** 595 = 62 + 72 + 82 + 92 + 102 + 112 + 122 **.
# Your task is to write the function longest_sequence(n) that either finds
# the longest consecutive sequence of squares that sums to the number n,
# or determines that no such sequence exists.
def longest_sequence(n):
    for i in range(1, int(n**0.5)+1):
        x, j = 0, i
        while x < n:
            x += j*j
            j += 1
        if x == n: return list(range(i, j))
    return []

# Consider having a cow that gives a child every year from her fourth
# year of life on and all her subsequent children do the same.
# After n years how many cows will you have?
def count_cows(n):
    if not isinstance(n, int): return None
    return count_cows(n-1) + count_cows(n-3) if n > 2 else 1

# In combinatorial mathematics, the Catalan numbers form a sequence of
# natural numbers that occur in various counting problems, often
# involving recursively-defined objects. They are named after the Belgian
# mathematician Eugène Charles Catalan (1814–1894).
# Using zero-based numbering, the nth Catalan number is given directly in terms of binomial coefficients by:
import math
def nth_catalan_number(n):
    return math.factorial(2*n) // math.factorial(n+1) // math.factorial(n)

# My tired eyes surveyed the horizon to spot a right triangle, made of an unknown
# material that sparkles in the endless void I have trekked thus far.
# I hurried towards it. However far it seemed, it can't compare to
# the uncounted days I have been trapped here in this endless void. To break the monotony, it shall do nicely.
# Reaching the triangle, I inspected it. It is even more spectacular up close
# than a far, like a piece of the heavens, just as grand as the best Hubble photo
# I've ever seen. Adorned onto its striking surface were two numbers, each hugging a side of the
# triangle in white chalk.
def how_to_find_them(right_triangle):
    d = dict(**right_triangle)
    if "a" not in d: d["a"] = (d["c"] ** 2 - d["b"] ** 2) ** 0.5
    elif "b" not in d: d["b"] = (d["c"] ** 2 - d["a"] ** 2) ** 0.5
    else: d["c"] = (d["a"] ** 2 + d["b"] ** 2) ** 0.5
    return d

# In this kata, you will be given a string containing numbers from a to b,
# one number can be missing from these numbers, then the string will
# be shuffled, you're expected to return an array of all possible missing numbers.
from collections import Counter
def find_number(start, stop, string):
    c = Counter(i for i in range(start, stop + 1) for i in str(i)) - Counter(string)
    return [i for i in range(start, stop + 1) if Counter(str(i)) == c]

# Your job is to create a function, (random_ints in Ruby/Python/Crystal, and randomInts
# in JavaScript/CoffeeScript) that takes two parameters, n and total, that will randomly
# identify n non-negative integers that sum to the total. Note that [1, 2, 3, 4]
# and [2, 3, 4, 1] are considered to be 'the same array' when it comes to this kata.
from random import randint
def random_ints(n, total):
    l = []
    for i in range(n-1):
        l.append(randint(0, total))
        total -= l[-1]
    return [*l, total]

# Part 2/3 of my kata series. Part 1
# The description changes little in this second part. Here we simply want to improve our
# approximation of the integral by using trapezoids instead of rectangles. The left/right side
# rules have a serious bias and the trapezoidal rules averages those
# approximations! The same assumptions exist but are pasted here for convenience.
def riemann_trapezoidal(f, n, a, b):
    c = (b-a)/n
    return round(sum(f(a+i*c)+f(a+(i+1)*c) for i in range(n))*c/2, 2)

# This kata will return a string that represents the difference of two
# perfect squares as the sum of consecutive odd numbers.
def squares_to_odd(a, b):
    return f'{a}^2 - {b}^2 = {" + ".join(map(str, range(2 * b + 1, 2 * a, 2)))} = {a ** 2 - b ** 2}'

# This kata was seen in programming competitions with a wide range of variations. A strict bouncy
# array of numbers, of length three or longer, is an array that
# each term (neither the first nor the last element) is strictly higher or lower than its neighbours.
def longest_bouncy_list(arr):
    l, s = [], []
    for v in arr:
        if not l or v!=l[-1] and (len(l)==1 or (l[-1]-l[-2]) * (l[-1]-v) > 0):
            l.append(v)
        else: l = l[-1:] + [v] if v != l[-1] else [v]
        if len(l)>len(s): s = l
    return s

# Consider the array [3,6,9,12]. If we generate all the combinations with repetition that
# sum to 12, we get 5 combinations: [12], [6,6], [3,9], [3,3,6], [3,3,3,3]. The length of
# the sub-arrays (such as [3,3,3,3]
# should be less than or equal to the length of the initial array ([3,6,9,12]).
# Given an array of positive integers and a number n, count all combinations with repetition of
# integers that sum to n. For example:
def find(arr,n,l = -1):
    if l < 0: l = len(arr)
    if n == 0: return 1
    if l == 0: return 0
    c = 0
    for k, v in enumerate(arr):
        c += find(arr[0 : k + 1], n - v, l - 1)
    return c

# You are given a positive integer (n), and your task is to
# find the largest number less than n, which can be written in the form
# a**b, where a can be any non-negative integer and b is an integer
# greater than or equal to 2. Try not to make the code time out :)
# The input range is from 1 to 1,000,000.
from math import sqrt
def largest_power(n):
    if n==1: return (0,-1)
    elif n<=4: return (1,-1)
    l = []
    for i in range(2, round(sqrt(n) + 2)):
        j=int(1)
        while i**j<n:
            a=i**j
            j += 1
        l.append(a)
        f = (max(l),l.count(max(l)))
    return f
    #
# Businsses like to have memorable telephone numbers. One way to make a telephone number
# memorable is to have it spell a memorable word or phrase.
# For example, you can call the University of Waterloo by dialing the memorable TUT-GLOP.
# Sometimes only part of the number is used to spell a word.
# When you get back to your hotel tonight you can order a pizza from Gino's by dialing 310-GINO.
def find_duplicate_phone_numbers(phone_numbers):
    l  = [a.upper().translate(str.maketrans('ABCDEFGHIJKLMNOPRSTUVWXY', '222333444555666777888999')).replace('-','') for a in phone_numbers]
    return sorted(['{}-{}:{}'.format(i[:3], i[3:], l.count(i)) for i in set(l) if l.count(i)>1])

# We are given two arrays of integers A and B and we have to output a sorted
# array with the integers that fulfill the following constraints:
# they are present in both ones
# they occur more than once in A and more than once in B
# their values are within a given range
# thay are odd or even according as it is requeste
from collections import Counter
def find_arr(arrA, arrB, rng, wanted):
    cA, cB = Counter(arrA), Counter(arrB)
    m, n = rng
    m += (m % 2 == 1) == (wanted == 'even')
    r = range(m, n+1, 2)
    return [i for i in r if cA[i] > 1 and cB[i] > 1]

# Mr.Odd is my friend. Some of his common dialogues are “Am I looking odd?” , “It’s looking
# very odd” etc. Actually “odd” is his favorite word.
# In this valentine when he went to meet his girlfriend. But he forgot to take gift. Because
# of this he told his gf that he did an odd thing. His gf became angry and gave him punishment.
# His gf gave him a string str of contain only lowercase letter and told him,
# “You have to take 3 index i,j,k such that i<j<k and str[i]
# =‘o’,str[j]=’d’,str[k]=’d’ and cut them from the string and make
# a new string “odd”. How many string you can make?”
# Mr.Odd wants to impress his gf so he want to make maximum number of “odd”. As he is lazy, he
# ask you to help him and tell him maximum number of “odd” he an make.
def odd(s):
    s, c, g = ''.join(i for i in s if i in 'od'), 0, 2
    for i,j in enumerate(s):
        if j=='o' and s[i:].count('d')>=g:
            c+=1
            g+=2
        if j=='d': g-=1
        if g<2: g=2
    return c

# In this Golfing Kata, you are going to do simple things:
# Reverse a string; then
# Return the index of first uppercase letter.
f=lambda s:s[-1]>"Z"and-~f(s[:-1])

# Implement the "count" decorator, which adds an attribute "call_count" to a function
# passed in to it, and increments it every time the function is called.
# The behavior of the decorated function must be the same as before. Your
# decorator must be well-behaved, i.e. the returned function must have the
# same name and docstring as the original, and must be able to handle the same arguments.''
from functools import wraps
def count_calls(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        wrapper.call_count += 1
        return func(*args, **kwargs)
    wrapper.call_count = 0
    return wrapper

# Some children are playing rope skipping game. Children skip the rope at roughly
# the same speed: once per second. If the child fails during the jump, he needs to tidy
# up the rope and continue. This will take 3 seconds.
# You are given an array failedCount, where each element is the jump count at the
# failed. ie. [12,23,45] means the child failed 3 times in the game
# process. The 1st mistake occurred when he jumped 12 times; The 2nd mistake occurred when he jumped
# 23 times; The 3rd mistake occurred when he jumped 45 times.
# Your task is to calculate how many times the child jumped in 60 seconds.
# Note: Each child persisted at least 60 jumps, which meant it could have
# been over 60 seconds, but the child continued to skip rope.
def tiaosheng(failed_counter):
    c, s = 0, 0
    while c < 60:
        c += 1
        s += 1
        if s in failed_counter: c += 3
    return s

# Our cells go through a process called protein synthesis to translate the
# instructions in DNA into an amino acid chain, or polypeptide.
# Your job is to replicate this!
def protein_synthesis(dna):
    word = str.maketrans("ACGT", "UGCA")
    rna = dna.translate(word)
    l = [rna[i:i+3] for i in range(0, len(rna), 3)]
    return " ".join(l), " ".join(CODON_DICT[i] for i in l if i in CODON_DICT)

# Given a string, add the fewest number of characters possible from the front or back to make it a palindrome.
def build_palindrome(s):
    for i in range(len(s), -1, -1):
        if s[:i] == s[:i][::-1]: return s[i:][::-1] + s
        if s[-i:] == s[-i:][::-1]: return s + s[:-i][::-1]

# The sequence of Chando is an infinite sequence of all Chando's numbers in ascending order.
# A number is called Chando's if it is an integer that can be
# represented as a sum of different positive integer powers of 5.
# The first Chando's numbers is 5 (5^1). And the following nth Chando's numbers are:
def nth_chandos_number(number):
    return int((bin(number) + "0")[2:], 5)

# Vanya gets bored one day and decides to enumerate a large pile of rocks. He first counts the rocks and finds out
# that he has n rocks in the pile, then he goes to the store to buy labels for enumeration.
# Each of the labels is a digit from 0 to 9 and each of the n rocks should be assigned a unique number from 1 to n.
# If each label costs $1, how much money will Vanya spend on this project?
def rocks(n):
    return int(n + 1 - 10**(len(str(n))-1)) * len(str(n)) + sum(9 * i * 10**(i - 1) for i in range(len(str(n))))

# Two tortoises named A and B must run a race. A starts with an average
# speed of 720 feet per hour. Young B knows she runs faster than A, and furthermore has not finished her cabbage.
# When she starts, at last, she can see that A has a 70 feet lead
# but B's speed is 850 feet per hour. How long will it take B to catch A?
# More generally: given two speeds v1 (A's speed, integer > 0)
# and v2 (B's speed, integer > 0) and a lead g (integer > 0) how long will it take B to catch A?
# The result will be an array [hour, min, sec] which is the time
# needed in hours, minutes and seconds (round down to the nearest second) or a string in some languages.
def race(v1, v2, g):
    t = 3600 * g/(v2-v1)
    return None if v2 < v1 else [int(t/3600), int(t/60%60), int(t%60)]

# You're given a string containing a sequence of words separated with
# whitespaces. Let's say it is a sequence of patterns: a name and a corresponding number - like this:
def words_to_object(s):
    return '[' + ', '.join("{name : '%s', id : '%s'}" % (k, v) for k, v in zip(s.split()[::2], s.split()[1::2])) + ']'

# You have to rebuild a string from an enumerated list.
# For this task, you have to check if input is correct beforehand.
# Input must be a list of tuples
# Each tuple has two elements.
# Second element is an alphanumeric character.
# First element is the index of this character into the reconstructed string.
# Indexes start at 0 and have to match with output indexing: no gap is allowed.
# Finally tuples aren't necessarily ordered by index.
# If any condition is invalid, the function should return False.
def denumerate(enum_list):
    try:
        d = dict(enum_list)
        maximum = max(d) + 1
        s = ''.join(d[i] for i in range(maximum))
        if s.isalnum() and len(s) == maximum:
            return s
    except (KeyError, TypeError, ValueError):
        pass
    return False

# Given a finite list of integral ( not necessarily non-negative ) numbers, determine
# the number that is odder than the rest.
# If there is no single such number, no number is odder
# than the rest; return Nothing, null or a similar empty value.
def oddest(a):
    f = lambda x: 1e6 if x == -1 else x % 2 and 1 + f(x // 2) or 0
    a = [(i, f(i)) for i in a]
    n = max((v for k, v in a), default=-1)
    a = [k for k, v in a if v == n]
    if len(a) == 1: return a[0]

# You will be given an array of integers in a [1; 50] range,
# and a number n. You have to extract n smallest elements out of the array preserving their original order.
def performant_smallest(arr, n):
    return [arr[i] for i in sorted(sorted(range(len(arr)), key=lambda k: arr[k])[:n])]

# There are n bears in the orchard and they picked a lot of apples.
# They distribute apples like this:
def how_many_apples(n):
    return 7 if n == 2 else n**n - n + 1

# Well, for my first kata, I did a mess. Would you help me, please, to make my code work ?
# I'm sure I didn't mix the numbers, but all the rest...
from math import pi
def whatpimeans(alpha = 'abcdefghijklmnopqrstuvwxyz'):
    d = dict(zip([85,24,32,64,11,52,91,79,78,99,62,27,74,35,14,16,66,81,19,39,13,33,45,49,95,10],alpha.upper()))
    crypt = str(pi).replace(".", "")[::-1]
    code = [int(crypt[i:i+2]) for i in range(0, len(crypt), 2)]
    s = ''.join(d[i] for i in code)
    return s

# Your task is to compelete the function calculateImproved to return an
# array sorted by most improved as percentages.
def calculate_improved(students):
    for i in students: i['marks'] = [j if j != None else 0 for j in i['marks']]
    l = [{'name': i['name'], 'improvement': round((i['marks'][-1]-i['marks'][0])*100/i['marks'][0]) if i['marks'][0] else 0} for i in students]
    return sorted(l, key=lambda x: (-x['improvement'], x['name'][0].islower(), x['name']))

# You are given an array of positive and negative integers and a
# number n and n > 1. The array may have elements that occurs more than once.
# Find all the combinations of n elements of the array that their sum are 0.
from itertools import combinations
def find_zero_sum_groups(arr, n):
    l = sorted(sorted(i) for i in combinations(set(arr), n) if sum(i) == 0)
    return l if len(l) > 1 else l[0] if l else "No combinations" if arr else "No elements to combine"

# Your task is to find the last non-zero digit of n! (factorial).
def last_digit(n):
    if n < 10: return [1, 1, 2, 6, 4, 2, 2, 4, 2, 8][n]
    return (4 if int(str(n)[-2]) % 2 else 6) * last_digit(n // 5) * last_digit(n % 10) % 10

# Given a non-empty finite list of unique integral ( not necessarily
# non-negative ) numbers, determine the number that is odder than the rest.
# Given the constraints, there will always be exactly one such number.
def oddest(a):
    return max(a, key=lambda x: f'{x+2**32:b}'[::-1])

# Write the processArray function, which takes an array and a callback function as parameters.
# The callback function can be, for example, a mathematical
# function that will be applied on each element of this array. Optionally, also
# write tests similar to the examples below.
def process_array(arr, callback):
    return [callback(i) for i in arr]

# Complete the function so that it takes an array of keys and a default value
# and returns a hash (Ruby) / dictionary (Python) with all keys set to the default value.
def populate_dict(keys, default):
    return {i:default for i in keys}

# Write a method, that replaces every nth char oldValue with char newValue.
def replace_nth(text, n, old, new):
    if n <= 0: return text
    s = list(text)
    l = [i for i, c in enumerate(s) if c == old]
    for i in l[n-1::n]: s[i] = new
    return ''.join(s)

# Deferring a function execution can sometimes save a lot of execution time in our programs
# by postponing the execution to the latest possible instant of time, when we'
# re sure that the time spent while executing it is worth it.
# Write a method make_lazy that takes in a function (symbol for Ruby) and the arguments to
# the function and returns another function (lambda for Ruby) which when invoked, returns the result of
# the original function invoked with the supplied arguments.
def make_lazy(*args):
    return lambda: args[0](*args[1:])

# Write a method that returns true if a given parameter is a
# power of 4, and false if it's not. If parameter
# is not an Integer (eg String, Array) method should return false as well.
# (In C# Integer means all integer Types like Int16,Int32,.....)
from math import log
def powerof4(n):
    if type(n) in (float, int) and n > 0: return log(n, 4).is_integer()
    return False

# Batman & Robin have gotten into quite a pickle this time. The Joker has mixed
# up their iconic quotes and also replaced one of the characters in their names, with a number.
# They need help getting things back in order.
# Implement the getQuote method which takes in an array of quotes, and a string comprised
# of letters and a single number (e.g. "Rob1n") where the number corresponds
# to their quote indexed in the passed in array.
class BatmanQuotes(object):
    l = ['Batman', 'Robin', 'Joker']
    @staticmethod
    def get_quote(quotes, hero):
        i = next((int(x) for x in hero if x.isdigit()))
        return BatmanQuotes.l[i] + ": " + quotes[i]

# Ready! Set! Fire... but where should you fire?
# The battlefield is 3x3 wide grid. HQ has already provided you with an array for easier computing:
def fire(x,y):
    return grid[y*3+x]

# Create a robot that will always win the game. Your robot will always go first.
# The function should take an integer and returns 1, 2, or 3.
# Note: The input will always be valid (a positive integer)
def make_move(sticks):
    return sticks%4

# You have read the title: you must guess a sequence. It will have something to do with the number given.
def sequence(x):
    return sorted(range(1, x+1), key=str)

# Turn an area of a square in to an area of a circle that fits perfectly inside the square.
from math import pi
def square_area_to_circle(size):
    return size * pi / 4

# One night you go for a ride on your motorcycle. At 00:00 you
# start your engine, and the built-in timer automatically begins counting
# the length of your ride, in minutes. Off you go to explore the neighborhood.
def late_ride(n):
    return sum(map(int, str(n // 60)+str(n % 60)))

# You have a two-dimensional list in the following format:
# Each sub-list contains two items, and each item in the sub-lists is an integer.
# Write a function process_data()/processData() that processes each sub-list like so:
import math
def process_data(data):
    return math.prod(i-j for i,j in data)

# Your company, Congo Pizza, is the second-largest online frozen pizza retailer.
# You own a number of international warehouses that you use to store your frozen pizzas,
# and you need to figure out how many crates of pizzas you can store at each location.
# Congo recently standardized its storage containers: all pizzas fit inside a
# cubic crate, 16-inches on a side. The crates are super tough so you can stack them as high as you want.
# Write a function box_capacity() that figures out how many crates you can store in a given
# warehouse. The function should take three arguments: the length, width, and height
# of your warehouse (in feet) and should return an integer representing the number
# of boxes you can store in that space.
def box_capacity(length, width, height):
    return (length * 12 // 16) * (width * 12 // 16) * (height * 12 // 16)

# A category page displays a set number of products per page, with
# pagination at the bottom allowing the user to move from page to page.
# Given that you know the page you are on, how many products are in
# the category in total, and how many products are on any given page, how would you
# output a simple string showing which products you are viewing..
def pagination_text(page_number, page_size, total_products):
    f = page_size * (page_number - 1) + 1
    c = min(total_products, f + page_size - 1)
    return "Showing %d to %d of %d Products." % (f, c, total_products)

# You receive the direction you are facing (one of the 8 directions: N, NE,
# E, SE, S, SW, W, NW) and a certain degree to turn
# (a multiple of 45, between -1080 and 1080); positive means clockwise, and negative means counter-clockwise.
# Return the direction you will face after the turn.
def direction(facing, turn):
    d = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW']
    return d[(turn // 45 + d.index(facing)) % 8]

# This kata is all about adding numbers.
# You will create a function named add. It will return the sum of all the arguments. Sounds easy, doesn't it?
# Well Here's the Twist. The inputs will gradually decrease with their index as parameter to the function.
def add(*args):
    return round(sum(v / (k+1) for k,v in enumerate(args)))

# Write a program that calculates the number of grains of wheat on a
# specific square of chessboard given that the number on each square is double the previous one.
# There are 64 squares on a chessboard.
def square(number):
    return 2**(number-1)

# This Kata is intended as a small challenge for my students
# Create a function, called insurance(), that computes the cost of renting a car.
# The function takes 3 arguments: the age of the renter, the size of
# the car, and the number days for the rental. The function should return an integer
# number of the calculated total cost of the rental.
def insurance(age, size, num_of_days):
    d = {'economy': 0, 'medium': 10, 'full-size': 15}
    if age < 25: return max(num_of_days * (60 + d[size] if size in d else 60 + d['full-size']), 0)
    return max(num_of_days * (50 + d[size] if size in d else 50 + d['full-size']), 0)

# Oh no! Timmy's List Class has broken! Can you help timmy and fix his class? Timmy has a
# List class he has created, this is used for type strict arrays (which timmy calls Lists).
# When timmy calls the Count property of the list it still remains at 0 when adding items.
# Also it fails when timmy trys to chain the adds e.g.
class List:
    def __init__(self, list_type):
        self.type = list_type
        self.items = []
        self.count = 0

    def add(self, item):
        if type(item) != self.type:
            return "This item is not of type: {}".format(self.type.__name__)
        self.items.append(item)
        self.count += 1
        return self

# Create a function that returns the total of a meal including tip and tax. You should not tip on the tax.
# You will be given the subtotal, the tax as a percentage and the tip as a percentage. Please round your
# result to two decimal places.
def calculate_total(subtotal, tax, tip):
    return round(subtotal * (1 + tax / 100 + tip /100), 2)

# Remember all those quadratic equations you had to solve by hand in highschool?
# Well, no more! You're going to solve all the quadratic
# equations you might ever[1] have to wrangle with in the future once and
# for all by coding up the quadratic formula to handle them automatically.
# Write a function quadratic_formula() that takes three arguments, a, b, and c that represent the
# coefficients in a formula of the form ax^2 + bx + c = 0. Your function shoud return
# a list with two elements where each element is one of the two roots. If the
# formula produces a double root the result should be a list where both elements are that value.
def quadratic_formula(a, b, c):
    d = b**2 - 4 * a * c
    root1 = (-b + d**.5) / (2 * a)
    root2 = (-b - d**.5) / (2 * a)
    return [root1, root2]

# Find the anonymous function in the given array and use the function to filter the array
# Input
# Your input. First Parameter will be an array with an anonymous function somewhere in the lot,
# The second Parameter will be an array which you will filter using the anonymous function you find.
# Output
# Your output. Output a filtered version of the second parameter using the function found in the first parameter.
# Reference: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions
def find_function(func,arr):
    for i in func:
        if not type(i) in (str, int): return [j for j in arr if i(j)]

# Write a function that accepts two parameters, i) a string (containing a list of words) and
# ii) an integer (n). The function should alphabetize the list based on the nth letter of each word.
# The letters should be compared case-insensitive. If both letters are the same,
# order them normally (lexicographically), again, case-insensitive.
def sort_it(list, n):
    return ', '.join(sorted(list.split(', '), key=lambda x: x[n-1]))

# Imagine two rings with numbers on them. The inner ring spins clockwise (decreasing
# by 1 each spin) and the outer ring spins counter clockwise (increasing by 1 each spin).
# We start with both rings aligned on 0 at the top, and on each move
# we spin each ring one increment. How many moves will it take before both rings show the
# same number at the top again?
# The inner ring has integers from 0 to innerMax and the outer ring has integers from 0
# to outerMax, where innerMax and outerMax are integers >= 1.
def spinning_rings(inner_max, outer_max):
    a, b, c = inner_max, 1, 1
    while a != b:
        a = (a + inner_max) % (inner_max+1)
        b = (b + 1) % (outer_max+1)
        c += 1
    return c

# Convert integers to binary as simple as that. You would be given an integer as
# a argument and you have to return its binary form. To get an idea about how to convert
# a decimal number into a binary number, visit here.
# Notes: negative numbers should be handled as two's complement; assume all numbers
# are integers stored using 4 bytes (or 32 bits) in any language.
# Your output should ignore leading 0s.
def to_binary(n):
    return bin(2 ** 32 + n if n < 0 else n)[2:]

# Four men, a, b, c and d are standing in a line, one behind another.
# There's a wall between the first three people (a, b and c) and the last one (d).
# The men a, b and c are lined up in order of height, so that:
def guess_hat_color(a,b,c,d):
    return 1 if b == c else 2

# Given a string, you progressively need to concatenate the first letter from the
# left and the first letter to the right and "1", then the second letter from the left and
# the second letter to the right and "2", and so on.
# If the string's length is odd drop the central element.
def char_concat(word):
    return ''.join((word[x] + word[-1-x] + str(x+1)) for x in range(len(word)//2))

# The sum of x consecutive integers is y. What is the consecutive
# integer at position n? Given x, y, and n, solve for the integer. Assume the starting position is 0.
# For example, if the sum of 4 consecutive integers is 14, what is the consecutive integer at position 3?
# We find that the consecutive integers are [2, 3, 4, 5], so the integer at position 3 is 5.
def position(x, y, n):
    return y//x - x//2 + (x % 2 == 0) + n

# In this kata you need to create a function that takes a 2D array/list of non-
# negative integer pairs and returns the sum of all the "saving" that you
# can have getting the LCM of each couple of number compared to their simple product.
from math import lcm
def sum_differences_between_products_and_LCMs(pairs):
    return sum((x*y)-lcm(x,y) for x, y in pairs)

# Implement a function to calculate the distance between two points in n-dimensional space.
# The two points will be passed to your function as arrays of the same length (tuples in Python).
# Round your answers to two decimal places.
def euclidean_distance(point1, point2):
    return round(sum((j - i)**2 for i, j in zip(point1, point2)) ** 0.5, 2)

# Build a function that will take the length of each side of a
# triangle and return if it's either an Equilateral, an Isosceles, a Scalene or an invalid triangle.
# It has to return a string with the type of triangle.
def type_of_triangle(a, b, c):
    if any(not isinstance(i, int) for i in (a, b, c)): return "Not a valid triangle"
    a, b, c = sorted((a, b, c))
    if a + b <= c: return "Not a valid triangle"
    if a == b and b == c: return "Equilateral"
    if a == b or a == c or b == c: return "Isosceles"
    return "Scalene"

# Complete the function that returns the color of the given square on a normal, 8x8 chess board:
def square_color(file, c):
    return 'white' if (ord(file) + c) % 2 else 'black'

#It's show time! Archers have gathered from all around the world to participate in
# the Arrow Function Faire. But the faire will only start if there are archers signed and
# if they all have enough arrows in their quivers - at least 5 is the requirement! Are all the archers ready?
def archers_ready(archers):
    return all(i > 4 for i in archers) if archers else False

# Write a function getNumberOfSquares (C, F#, Haskell) / get_number_of_squares (Python, Ruby) that will
# return how many integer (starting from 1, 2...) numbers raised to power
# of 2 and then summed up are less than some number given as a parameter.
def get_number_of_squares(n):
    s, c = 0, 0
    while s < n:
        c += 1
        s += c**2
    return c - 1

# Factorials are often used in probability and are used as an introductory
# problem for looping constructs. In this kata you will be summing together multiple factorials.
# Here are a few examples of factorials:
def sum_factorial(lst):
    def fac(n):
        c = 1
        for i in range(n, 0, -1):
            c *= i
        return c
    return sum(fac(i) for i in lst)

# You will get an array of numbers.
# Every preceding number is smaller than the one following it.
def find_missing_numbers(arr):
    if arr: return [i for i in list(range(min(arr), max(arr)+1)) if i not in arr]
    return []

# For an integer k rearrange all the elements of the given array in such way, that:
# all elements that are less than k are placed before elements that are not less than k;
# all elements that are less than k remain in the same order with respect to each other;
# all elements that are not less than k remain in the same order with respect to each other.
def split_by_value(k, elements):
    return sorted(elements, key=lambda x: x >= k)

# Tranform of input array of zeros and ones to array in which counts number of continuous
# ones. If there is none, return an empty array
def ones_counter(input):
    return [ch.count('1') for ch in ''.join(map(str, input)).split('0') if ch]

# As you probably know, Fibonacci sequence are the numbers in the following integer
# sequence: 1, 1, 2, 3, 5, 8, 13... Write a method that takes the index as
# an argument and returns last digit from fibonacci number. Example: getLastDigit(15) - 610.
# Your method must return 0 because the last digit of 610 is 0. Fibonacci sequence
# grows very fast and value can take very big numbers (bigger than integer type can contain), so,
# please, be careful with overflow.
import sys
sys.set_int_max_str_digits(maxdigits=0)
def get_last_digit(index):
    a, b = 0, 1
    for i in range(index):
        a, b = b, a + b
    return int(str(a)[-1])

# You are given a random string of lower-case letters. Your job is to find out how many
# ordered and consecutive vowels there are in the given string beginning from 'a'. Keep in mind
# that the consecutive vowel to 'u' is 'a' and the cycle continues.
# Return an integer with the length of the consecutive vowels found.
def get_the_vowels(word):
    c = 0
    for i in word:
        if i == "aeiou"[c % 5]: c += 1
    return c

# In this Kata, you will be given a number, two indexes (index1 and index2)
# and a digit to look for. Your task will be to check if the digit
# exists in the number, within the indexes given.
# Be careful, the index2 is not necessarily more than the index1.
def check_digit(number, index1, index2, digit):
    return str(digit) in str(number)[min(index1, index2):max(index1, index2)+1]

# Given an array of numbers, return a string made up of four parts:
# a four character 'word', made up of the characters derived from the first two and last two
# numbers in the array. order should be as read left to right (first, second, second last, last),
# the same as above, post sorting the array into ascending order,
# the same as above, post sorting the array into descending order,
# the same as above, post converting the array into ASCII characters and sorting alphabetically.
# The four parts should form a single string, each part separated by a hyphen (-).
def sor(arr): return ''.join(arr[:2]+arr[-2:])
def sort_transform(arr):
    arr = list(map(chr, arr))
    w1  = sor(arr)
    arr.sort()
    w2  = sor(arr)
    return f'{w1}-{w2}-{w2[::-1]}-{w2}'

# Write a function that returns the number of '2's in the factorization of a number.
def two_count(n):
    return bin(n)[::-1].index('1')

# Given a Hash made up of keys and values, invert the hash by swapping them.
def invert_hash(dictionary):
    return {v:k for k,v in dictionary.items()}

# Write a function helpZoom() that takes an array of integers containing 0 and 1 as
# input and returns “Yes” or “No” depending on whether the given password is symmetric or not.
def help_zoom(key):
    return 'Yes' if key == key[::-1] else 'No'

# Alex is transitioning from website design to coding and wants to sharpen his skills with CodeWars.
# He can do ten kata in an hour, but when he makes a mistake, he
# must do pushups. These pushups really tire poor Alex out, so every time he does
# them they take twice as long. His first set of redemption pushups takes 5 minutes.
# Create a function, alexMistakes, that takes two arguments: the number of kata he needs to
# complete, and the time in minutes he has to complete them. Your function should
# return how many mistakes Alex can afford to make.
def alex_mistakes(katas, time):
    c, t, s = 0, 5, time - katas * 6
    while s >= t:
        s -= t
        t *= 2
        c += 1
    return c

# Adding tip to a restaurant bill in a graceful way can be tricky, thats why you need make a function for it.
# The function will receive the restaurant bill (always a positive number) as an argument. You need to 1)
# add at least 15% in tip, 2) round that number up to an elegant value and 3) return it.
# What is an elegant number? It depends on the magnitude of the number to be rounded.
# Numbers below 10 should simply be rounded to whole numbers. Numbers 10 and above should be rounded like this:
import math
def graceful_tipping(bill):
    c = bill * 115 / 100
    su = 1 if c < 10 else 5 * 10 ** int(math.log10(c) - 1)
    return math.ceil(c / su) * su

# You are given a function that should insert an asterisk (*) between every
# pair of even digits in the given input, and return it as a string.
# If the input is a sequence, concat the elements first as a string.
def asterisc_it(n):
    if type(n) == list: n = ''.join(str(i) for i in n)
    if type(n) == int : n = str(n)
    return ''.join([a + '*' if int(a) % 2 == 0 and int(b) % 2 == 0 else a for a,b in zip(n, n[1:])]) + n[-1]

# In this exercise, you will create a function that takes an integer, i. With it you must do the following:
# Find all of its multiples up to and including 100,
# Then take the digit sum of each multiple (eg. 45 -> 4 + 5 = 9),
# And finally, get the total sum of each new digit sum.
# Note: If the digit sum of a number is more than 9 (eg. 99 -> 9 + 9 = 18) then
# you do NOT have to break it down further until it reaches one digit.
def procedure(n):
    return sum(int(j) for i in range(n, 101, n) for j in str(i))

# You are given an array with several "even" words, one "odd" word, and some numbers mixed in.
# Determine if any of the numbers in the array is the index of the "odd" word. If so, return
# true, otherwise false.
def odd_ball(arr):
    return any(arr[i] == 'odd' for i in [i for i in arr if type(i) == int and i <= len(arr)-1])

# The police have placed radars that will detect those vehicles that exceed the
# speed limit on that road. If the driver's speed is 10km/h to 19km/h
# above the speed limit, the fine will be 100 dollars, if it is
# exceeded by 20km/h to 29km/h the fine will be 250 dollars and if it
# is exceeded by more than 30km/h the fine will be 500 dollars.
# You will be provided with the speed limits of those roads with radar as
# a collection of speedlimits [90,100,110,120,....] and the speed
# of the driver will be the same on all roads and can never be negative and
# the amount of the fine will be accumulated example 95km/h.
def speed_limit(speed, signals):
    c = 0
    for i in signals:
        if 10 <= speed - i <= 19: c += 100
        if 20 <= speed - i <= 29: c += 250
        if 30 <= speed - i: c += 500
    return c

# Math hasn't always been your best subject, and these programming
# symbols always trip you up! I mean, does ** mean "Times, Times" or "To
# the power of"? Luckily, you can create the function to write out the expressions for you!
def expression_out(exp):
    try:
        l = ['0','One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten']
        return l[int(exp.split()[0])] +" "+ OPERATORS[exp.split()[1]] + l[int(exp.split()[2])]
    except:
        return "That's not an operator!"

# Given an integer, take the (mean) average of each pair of consecutive digits.
# Repeat this process until you have a single integer, then return that integer. e.g.
# Note: if the average of two digits is not an integer, round the result
# up (e.g. the average of 8 and 9 will be 9)
def digits_average(input):
    l = [int(c) for c in str(input)]
    while len(l) > 1:
        l = [(a + b + 1)//2 for a, b in zip(l, l[1:])]
    return l[0]

# You are given an array of up to four non-negative integers, each less than 256.
# Your task is to pack these integers into one number M in the following way:
def array_packing(arr):
	return sum(v * 256 ** k for k, v in enumerate(arr))

# Given a non-empty array of non-empty integer arrays, multiply the contents of each nested
# array and return the smallest total.
import math
# Однострочное решение
def smallest_product(a):
    return min([math.prod(i) for i in a])

# Более подробное решение
# def smallest_product(список_списков):
#     список_сумм = []
#     for список in список_списков:
#         список_сумм.append(math.prod(список))
#     минимальное_значение = min(список_сумм)
#     return минимальное_значение

# You will be given the number of angles of a shape with equal sides and angles,
# and you need to return the number of its sides, and the measure of the interior angles.
def describe_the_shape(angles):
    각도의합 = int(180*(angles - 2)/angles)
    if 각도의합 > 0: 답변 = f"This shape has {angles} sides and each angle measures {각도의합}"
    else: 답변 = "this will be a line segment or a dot"
    return 답변

# Ronny the robot is watching someone perform the Cups and Balls magic trick. The magician has
# one ball and three cups, he shows Ronny which cup he hides the ball under (b),
# he then mixes all the cups around by performing multiple two-cup switches (arr). Ronny can record the
# switches but can't work out where the ball is. Write a programme to help him do this.
def cup_and_balls(чашка_с_мячем, массив):
    for перемещений in массив:
        if чашка_с_мячем in перемещений:
            чашка_с_мячем = sum(перемещений) - чашка_с_мячем
    return чашка_с_мячем

# Groups of characters decided to make a battle. Help them to figure out what
# group is more powerful. Create a function that will accept 2 variables and return the one who's stronger.
def battle(первое_слово: str, второе_слово: str) -> str:
    алфавит = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    сумма_первого_слова = sum(алфавит.index(буква)+1 if буква.isupper() else (алфавит.index(буква.upper())+1)/2 for буква in первое_слово)
    сумма_второго_слова = sum(алфавит.index(буква)+1 if буква.isupper() else (алфавит.index(буква.upper())+1)/2 for буква in второе_слово)
    return первое_слово if сумма_первого_слова > сумма_второго_слова else второе_слово if сумма_второго_слова > сумма_первого_слова else 'Tie!'

# Your generator must take one parameter `a` then everytime the generator is called you must return
# a string in the format of: `'a x b = c'` where c is the
# answer. Also, the value of `b`, which starts at 1, must increment by 1 each time!
def generator(a):
    count = 1
    while True:
        yield f"{a} x {count} = {a * count}"
        count += 1

# Speedcubing is the hobby involving solving a variety of twisty puzzles, the most famous being
# the 3x3x3 puzzle or Rubik's Cube, as quickly as possible.
# In the majority of Speedcubing competitions, a Cuber solves a scrambled cube 5 times, and their
# result is found by taking the average of the middle 3 solves (ie. the slowest and fastest times are
# disregarded, and an average is taken of the remaining times).
def cube_times(times):
    return round(sum(sorted(times)[1:4])/3, 2), min(times)

# Write a function that takes one or more arrays and returns a new array of
# unique values in the order of the original provided arrays.
# In other words, all values present from all arrays should be included in their original order,
# but with no duplicates in the final array.
# The unique numbers should be sorted by their original order, but the final
# array should not be sorted in numerical order.
# Check the assertion tests for examples.
def unite_unique(*args):
    l = []
    for i in args:
        for j in i:
            if j not in l: l.append(j)
    return l

# In Russia regular bus tickets usually consist of 6 digits. The ticket is called lucky when the
# sum of the first three digits equals to the sum of the last three digits. Write a
# function to find out whether the ticket is lucky or not. Return true if so, otherwise return
# false. Consider that input is always a string. Watch examples below.
def is_lucky(ticket):
    return len(ticket) == 6 and ticket.isdigit() and sum(map(int, ticket[:3])) == sum(map(int, ticket[3:]))

# Your retro heavy metal band, VÄxën, originally started as kind of a joke, just because why would anyone want
# to use the crappy foosball table in your startup's game room when they could be rocking out at top volume
# in there instead? Yes, a joke, but now all the top tech companies are paying you top dollar to play at
# their conferences and big product-release events. And just as how in the early days of the Internet
# companies were naming everything "i"-this and "e"-that, now that VÄxënmänïä has conquered the tech
# world, any company that doesn't use Hëävÿ Mëtäl Ümläüts in ëvëry pössïblë pläcë is
# looking hopelessly behind the times.
def heavy_metal_umlauts(boring_text):
    return boring_text.translate(str.maketrans('AOaoEUeuIYiy', 'ÄÖäöËÜëüÏŸïÿ'))

# Your task is to generate the Fibonacci sequence to n places, with each alternating value as "skip". For example:
def skiponacci(n):
    l = []
    a, b = 0, 1
    for i in range(n):
        a, b = a + b, a
        l.append('skip' if i % 2 else str(a))
    return ' '.join(l)

# Step through my green glass door.
# You can take the moon, but not the sun.
# You can take your slippers, but not your sandals.
# You can go through yelling, but not shouting.
# You can't run through fast, but you can run with speed.
# You can take a sheet, but not your blanket.
# You can wear your glasses, but not your contacts.
# Have you figured it out? Good! Then write a program that can figure it out as well.
def step_through_with(s):
    return any(i == j for i, j in zip(s, s[1:]))

# In a genetic algorithm, a population is a collection of candidates that may evolve toward a better solution.
# We determine how close a chromosome is to a ideal solution by
# calculating its fitness. https://www.codewars.com/kata/567b468357ed7411be00004a/train You are
# given two parameters, the population containing all individuals and a function fitness that determines
# how close to the solution a chromosome is.
# Your task is to return a collection containing an object with the chromosome and the calculated fitness.
def mapPopulationFit(population, fitness):
    return [ChromosomeWrap(i, fitness(i)) for i in population]

# I'm sure you're familiar with factorials – that is, the product of an integer and all the integers below it.
# For example, 5! = 120, as 5 * 4 * 3 * 2 * 1 = 120
# Your challenge is to create a function that takes any number and returns the number
# that it is a factorial of. So, if your function receives 120, it should return "5!" (as a string).
# Of course, not every number is a factorial of another.
# In this case, your function would return "None" (as a string).
from math import factorial
def reverse_factorial(num):
    c = 1
    while factorial(c) < num: c += 1
    return str(c) + '!' if factorial(c) == num else 'None'

# In this Kata, you will be given a multi-dimensional array containing 2 or more sub-arrays
# of integers. Your task is to find the maximum product that can be formed
# by taking any one element from each sub-array.
def solve(arr):
    l = arr[0]
    for k in range(1, len(arr)):
        l = [x * y for x in l for y in arr[k]]
    return max(l)

# Sexy primes are pairs of two primes that are 6 apart. In this kata, your job is
# to complete the function which returns true if x & y are sexy, false otherwise.
from gmpy2 import is_prime
def sexy_prime(x, y):
    return abs(x - y) == 6 and is_prime(x) and is_prime(y)

# In this kata the function returns an array/list like the one passed to
# it but with its nth element removed (with 0 <= n <= array/list.length - 1). The function
# is already written for you and the basic tests pass, but random tests fail. Your
# task is to figure out why and fix it.
# Good luck!
def remove_nth_element(lst, n):
    lst_copy = lst.copy()
    del lst_copy[n]
    return lst_copy

# KISS stands for Keep It Simple Stupid. It is a design principle for keeping things simple rather than complex.
# You are the boss of Joe.
# Joe is submitting words to you to publish to a blog. He likes to complicate things# .
# Define a function that determines if Joe's work is simple or complex.
# Input will be non emtpy strings with no punctuation.
# It is simple if: the length of each word does not exceed the amount of
# words in the string (See example test cases)
# Otherwise it is complex.
def is_kiss(words):
    if all(len(i) <= len(words.split()) for i in words.split()): return 'Good work Joe!'
    return 'Keep It Simple Stupid'

# Call two arms equally strong if the heaviest weights they each are able to lift are equal.
# Call two people equally strong if their strongest arms are equally strong (the strongest am can be
# both the right and the left), and so are their weakest arms.
# Given your and your friend's arms' lifting capabilities find out if you two are equally strong.
def are_equally_strong(your_left, your_right, friends_left, friends_right):
    return sorted([your_left, your_right]) == sorted([friends_left, friends_right])

# Once Mary heard a famous song, and a line from it stuck in her head. That line was "Will you
# still love me when I'm no longer young and beautiful?". Mary believes
# that a person is loved if and only if he/she is both young and beautiful, but this
# is quite a depressing thought, so she wants to put her belief to the test.
# Knowing whether a person is young, beautiful and loved, find out if they contradict Mary's belief.
# A person contradicts Mary's belief if one of the following statements is true:
def will_you(young, beautiful, loved):
    return (young and beautiful) != loved

# Write a function that accepts two parameters (sum and multiply) and find two numbers
# [x, y], where x + y = sum and x * y = multiply.
def sum_and_multiply(sum, multiply):
    for i in range(sum + 1):
            if i * (sum - i) == multiply: return [i, sum - i]

# Given any number of boolean flags function should return true if and only if one
# of them is true while others are false. If function is called without arguments it should return false.
def only_one(*args):
    c = 0
    if len(args) == 0: return False
    for i in args:
        if i == True: c += 1
    return c == 1

# This Kata is intended as a small challenge for my students
# All Star Code Challenge #24
# Your friend David is an architect who is working on a triangle-focused design. He needs
# a quick way for knowing the measurement of a right triangle's side, only knowing two of the sides.
# He knows about the Pythagorean Theorem, but is too lazy to do the math.
# Help him by making 2 functions to ease his troubles.
# Create 2 functions:
# hypotenuse(), which takes 2 integer arguments, the length of two regular sides of a right
# triangle, and returns the length of the missing side, the hypotenuse, as a number.
# leg(), which takes 2 integer arguments, the first being the length of the hypotenuse, and
# the second being the length of a regular side of a right triangle. This function
# should return the length of the missing regular side, as a number.
def hypotenuse(a, b):
    return (a**2 + b**2)**.5
def leg(c, a):
    return (c**2 - a**2)**.5

# It is 2050 and romance has long gone, relationships exist solely for practicality.
# MatchMyHusband is a website that matches busy working women with perfect house husbands. You
# have been employed by MatchMyHusband to write a function that determines who matches!!
# The rules are... a match occurs providing the husband's "usefulness" rating
# is greater than or equal to the woman's "needs".
# The husband's "usefulness" is the SUM of his cooking, cleaning
# and childcare abilities and takes the form of an array .
def match(usefulness, months):
    c = 100
    for i in range(months):
        c = c - (c/100)*15
    return 'Match!' if sum(usefulness) >= c else 'No match!'

# Create a function that takes any sentence and redistributes the spaces (and adds additional spaces if
# needed) so that each word starts with a vowel. The letters should all be in the same
# order but every vowel in the sentence should be the start of a new word. The
# first word in the new sentence may start without a vowel. It should return a string in all
# lowercase with no punctuation (only alphanumeric characters).
def vowel_start(s):
    w = ''
    for i in s:
        if i in 'aeiouAEIOU': w += ' ' + i.lower()
        elif i.isalnum(): w += i.lower()
    return w.lstrip(' ')

# Two numbers are relatively prime if their greatest common factor is 1; in other words:
# if they cannot be divided by any other common numbers than 1.
from math import gcd
def relatively_prime(n, l):
    return [i for i in l if gcd(n, i) == 1]

# Thanks to the effects of El Nino this year my holiday snorkelling trip was
# akin to being in a washing machine... Not fun at all.
# Given a string made up of '~' and '_' representing waves
# and calm respectively, your job is to check whether a person would become seasick.
# Remember, only the process of change from wave to calm will add to
# the effect (really wave peak to trough but this will do). Find out
# how many changes in level the string has and if that figure is more than 20%
# of the array, return "Throw Up", if less, return "No Problem".
def sea_sick(s):
    return "Throw Up" if (s.count("~_") + s.count("_~")) / len(s) > 0.2 else "No Problem"

# Write a function that sums squares of numbers in list that may contain more lists
def sumsquares(l):
    return l**2 if type(l) != list else sum(sumsquares(i) for i in l)

# The Chinese zodiac is a repeating cycle of 12 years, with each year
# being represented by an animal and its reputed attributes. The lunar calendar is divided into
# cycles of 60 years each, and each year has a combination of an animal and
# an element. There are 12 animals and 5 elements; the animals change each year, and the elements change every
# 2 years. The current cycle was initiated in the year of 1984 which was the year of the Wood Rat.
# Since the current calendar is Gregorian, I will only be using years from the epoch
# 1924. For simplicity I am counting the year as a whole year and
# not from January/February to the end of the year.
##Task
# Given a year, return the element and animal that year represents ("Element Animal"). For example
# I'm born in 1998 so I'm an "Earth Tiger".
def chinese_zodiac(year):
    return f"{elements[(year-4)%10//2]} {animals[(year-4)%12]}"

# Given: a sequence of different type of values (number, string, boolean). You should return
# an object with a separate properties for each of types presented in input. Each property
# should contain an array of corresponding values.
# keep order of values like in input array
# if type is not presented in input, no corresponding property are expected
def separate_types(seq):
    d = {}
    for i in seq:
        if type(i) not in d: d[type(i)] = [i]
        else: d[type(i)].append(i)
    return d

# Given an Array and an Example-Array to sort to, write a function that sorts the
# Array following the Example-Array.
# Assume Example Array catalogs all elements possibly seen in the input Array. However, the input
# Array does not necessarily have to have all elements seen in the Example.
def example_sort(arr, example_arr):
    l = []
    for i in example_arr:
        if i in arr:
            while i in arr:
                l.append(i)
                arr.remove(i)
    return l

# that takes in a string str(text in Python) and an object/hash/dict/Dictionary what
# and returns a string with the chars removed in what. For example:
def remove(text, what):
    for k,v in what.items():
        if k in text:
            text = text.replace(k, '', v)
    return text

# Take a number and check each digit if it is divisible by the digit
# on its left checked and return an array of booleans.
# The booleans should always start with false becase there is no digit before the first one.
def divisible_by_last(n):
    l = list(map(int, f"0{n}"))
    return [i and not j%i for i,j in zip(l, l[1:])]

# Most of this problem is by the original author of the harder kata, I just made it simpler.
# I read a book recently, titled "Things to Make and Do in the
# Fourth Dimension" by comedian and mathematician Matt Parker ( Youtube ), and in the first chapter of the book
# Matt talks about problems he likes to solve in his head to take his mind off the fact that
# he is in his dentist's chair, we've all been there!
# The problem he talks about relates to polydivisible numbers, and I thought a
# kata should be written on the subject as it's quite interesting. (Well it's interesting to me, so there!)
# Polydivisib... huh what?
# So what are they?
# A polydivisible number is divisible in an unusual way. The first digit is cleanly
# divisible by 1, the first two digits are cleanly divisible by 2, the first three by 3, and so on.
def polydivisible(j):
    return all(int(str(j)[:i+1])%(i+1)==0 for i in range(len(str(j))))

# Given a number n, you should find a set of numbers for which
# the sum equals n. This set must consist exclusively of values that are a power
# of 2 (eg: 2^0 => 1, 2^1 => 2, 2^2 => 4, ...).
# The function powers takes a single parameter, the number n, and should return an array of unique numbers.
def powers(n):
    return [2**k for k, v in enumerate(f"{n:b}"[::-1]) if v == "1"]

# Square the numbers that are greater than zero.
# Multiply by 3 every third number.
# Multiply by -1 every fifth number.
# Return the sum of the sequence.
def calc(a):
    return sum(v**(1 + (v>=0)) * (1 + 2*(not k%3)) * (-1)**(not k%5) for k, v in enumerate(a, 1))

# Suppose I have two vectors: (a1, a2, a3, ..., aN) and (b1, b2, b3, ..., bN). The
# dot product between these two vectors is defined as:
def is_orthogonal(u, v):
    return sum(a * b for a, b in zip(u, v)) == 0

# Create a function that takes a number and finds the factors of it, listing them in descending order in an array.
# If the parameter is not an integer or less than 1, return -1. In C# return an empty array.
def factors(x):
    if not isinstance(x, int) or x < 1: return -1
    return [i for i in range(x, 0, -1) if x % i == 0]

# Take a string and return a hash with all the ascii values of the characters in the
# string. Returns nil if the string is empty. The key is the character, and
# the value is the ascii value of the character. Repeated characters are to be ignored
# and non-alphebetic characters as well.
def char_to_ascii(s):
    if isinstance(s, str) and s != '':
        d = {}
        for i in s:
            if i not in d and i in 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ': d[i] = ord(i)
        return d

# You will be given two inputs: a string of words and a letter.
# For each string, return the alphabetic character after every instance of letter(case insensitive).
# If there is a number, punctuation or underscore following the letter, it should not be returned.
def comes_after(st, l):
    return ''.join(j for i, j in zip(st, st[1:]) if i.lower() == l.lower() and j.isalpha())

# The best way to have a productive day is to plan out
# your work schedule. Given the following three inputs, please create an array of time alloted to
# work, broken up with time alloted with breaks:
# Input 1: Hours - Number of hours available to you to get your work done!
# Input 2: Tasks - How many tasks you have to do througout the day
# Input 3: Duration (minutes)- How long each of your tasks will take to complete
def day_plan(hours, tasks, duration):
    c = (hours * 60 - tasks * duration) / (tasks - 1) if tasks > 1 else 0
    if c < 0: return "You're not sleeping tonight!"
    return ([duration, round(c)] * tasks)[:-1]

# Write function describeList which returns "empty" if the list is empty or "singleton" if
# it contains only one element or "longer"" if more.
def describeList(list):
    return 'singleton' if len(list) == 1 else 'longer' if len(list) > 1 else 'empty'

# We have two consecutive integers k1 and k2, k2 = k1 + 1
# We need to calculate the lowest strictly positive integer n, such
# that: the values nk1 and nk2 have the same digits but in different order.
def find_lowest_int(k1):
    k2, c = k1 + 1, 1
    def digits(c):
        return sorted(str(c))
    while digits(c*k1) != digits(c*k2): c += 1
    return c

# In this kata, you need to write a function that takes a string and a letter as
# input and then returns the index of the second occurrence of that letter in the string. If
# there is no such letter in the string, then the function should return -1.
# If the letter occurs only once in the string, then -1 should also be returned.
def second_symbol(s, sym):
    return [i for i in range(len(s)) if s[i] == sym][1] if sym in s and s.count(sym) > 1 else -1

# Write a func named SumEvenFibonacci that takes a parameter of type int and returns a value of type int
# Generate all of the Fibonacci numbers starting with 1 and 2 and ending on the highest number before
# exceeding the parameter's value
def SumEvenFibonacci(limit):
    a, b, c = 1, 1, 0
    while a <= limit:
        if not a % 2: c += a
        a, b = b, a + b
    return c

# This is a question from codingbat
# Given an integer n greater than or equal to 0, create and return an array with the following pattern:
def square_up(n):
    return [k if k <= i else 0 for i in range(1, n+1) for k in range(n, 0, -1)]

# This kata is part of the collection Mary's Puzzle Books.
# Zero Terminated Sum
# Mary has another puzzle book, and it's up to you to help
# her out! This book is filled with zero-terminated substrings, and you have to
# find the substring with the largest sum of its digits. For example, one puzzle looks like this:
def largest_sum(s):
    l = []
    for i in s.split('0'):
        l.append(sum(int(j) for j in i))
    return max(l)

# Correct this code so that it takes one argument, x, and returns "x is more than zero"
# if x is positive (and nonzero), and otherwise, returns "x is equal to
# or less than zero." In both cases, replace x with the actual value of x.
def corrections(x):
    return f"{x} is more than zero." if x > 0 else f"{x} is equal to or less than zero."

# The new £5 notes have been recently released in the UK and they've certainly became a sensation! Even those of
# us who haven't been carrying any cash around for a while, having given in to the convenience of cards,
# suddenly like to have some of these in their purses and pockets. But how many of them could you get with what's
# left from your salary after paying all bills? The programme that you're about to write will count this for you!
# Given a salary and the array of bills, calculate your disposable income for a month and return it as a
# number of new £5 notes you can get with that amount. If the money you've got (or do not!) doesn't
# allow you to get any £5 notes return 0.
def get_new_notes(salary,bills):
    return (salary - sum(bills)) // 5 if sum(bills) <= salary else 0

# This kata is about static method that should return different values.
# On the first call it must be 1, on the second and others - it must be a double from previous value.
# Look tests for more examples, good luck :)
class Class:
    count = 1
    def get_number():
        res = Class.count
        Class.count *= 2
        return res

# 2520. Count the Digits That Divide a Number Leet Code task
class Solution:
    def countDigits(self, num: int) -> int:
        c = 0
        for i in str(num):
            if  num % int(i) == 0: c += 1
        return c

# You are given two arrays arr1 and arr2, where arr2 always contains integers.
# Write the function find_array(arr1, arr2) such that:
def find_array(arr1, arr2):
    arr2 = [i for i in arr2 if i < len(arr1)]
    return [arr1[i] for i in arr2]

# 1431. Kids With the Greatest Number of Candies
class Solution:
    def kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]:
        return [i + extraCandies >= max(candies) for i in candies]

# We all want to climb the leaderboard. Even given some of the massive
# scores on there, it's nice to know how close you are...
# In this kata you will be given a username and their score, your score (
# not your real score) and you need to calculate how many kata
# you need to complete to beat their score, by 1 point exactly.
# As this is the easy version (harder one to folow at some point in the future), let's
# assume only Beta kata and 8kyu kata are available. Worth 3 and 1 point respectively.
# Return a string in this format: "To beat <user>'s score, I must complete <x> Beta kata and <y> 8kyu kata."
# If the total number of kata you need to complete >1000, add "Dammit!" to the end of
# the string, like so: "To beat <user>'s score, I must complete <x> Beta kata and <y> 8kyu kata. Dammit!"
# If your score is higher than the user's already, return "Winning!" and if they are
# equal, return "Only need one!"
# Note: You are looking to complete as few kata as possible to get to your target.
def leader_b(u, us, ys):
    if ys > us: return 'Winning!'
    if ys == us: return 'Only need one!'
    s = f"To beat {u}'s score, I must complete {(us-ys)//3} Beta kata and {(us-ys)%3//1} 8kyu kata."
    return s + ' Dammit!' if ((us-ys)//3) + ((us-ys)%3//1) > 1000 else s

# 1768. Merge Strings Alternately
class Solution:
    def mergeAlternately(self, word1: str, word2: str) -> str:
        w = ''.join(i+j for i,j in zip(word1, word2))
        if len(word1) == len(word2): return w
        ma = max(word1, word2, key=len)
        mi = min(word1, word2, key=len)
        return w + ma[-(len(ma)-len(mi)):]

# Let's call a string cool if it is formed only by Latin letters and no
# two lowercase and no two uppercase letters are in adjacent positions. Given a string, check if it is cool.
def cool_string(s):
    return all(i.isalpha() for i in s) and all(i.isupper() and j.islower() if i.isupper() else i.islower() and j.isupper() for i,j in zip(s, s[1:]))

# 2553. Separate the Digits in an Array
class Solution:
    def separateDigits(self, nums: List[int]) -> List[int]:
        l = []
        for i in nums:
            for j in str(i): l.append(int(j))
        return l

# An array is called zero-balanced if its elements sum to 0 and for each positive
# element n, there exists another element that is the negative of n. Write a function named ìsZeroBalanced
# that returns true if its argument is zero-balanced array, else return false. Note that
# an empty array will not sum to zero.
def is_zero_balanced(arr):
    return sum(arr) == 0 and all(abs(i) in arr if i < 0 else -i in arr for i in arr) if len(arr) > 0 else False

# 2259. Remove Digit From Number to Maximize Result
class Solution:
    def removeDigit(self, number: str, digit: str) -> str:
        l = []
        for k,v in enumerate(number):
            if v == digit:
                l.append(number[:k] + number[k+1:])
        return max(l)

# Create a method (JS: function) every which returns every nth element of an array.
# Usage
# With no arguments, array.every it returns every element of the array.
# With one argument, array.every(interval) it returns every intervalth element.
# With two arguments, array.every(interval, start_index) it returns every intervalth
# element starting at index start_index
def every(array, interval = 0, start_index = 0):
    if interval == 0: return array
    if interval != 0 and start_index == 0: return array[::interval]
    if interval != 0 and start_index != 0: return array[start_index::interval]

# 2129. Capitalize the Title
class Solution:
    def capitalizeTitle(self, title: str) -> str:
        return ' '.join(i.lower() if len(i)<3 else i.title() for i in title.split())

# Chingel is practicing for a rowing competition to be held on this saturday. He is trying
# his best to win this tournament for which he needs to figure out how much
# time it takes to cover a certain distance.
# Input
# You will be provided with the total distance of the journey, speed of the boat
# and whether he is going downstream or upstream. The speed of the stream and direction
# of rowing will be given as a string. Check example test cases!
def time(distance,boat_speed,stream):
    boat_speed = boat_speed + int(stream.split()[1]) if stream[0] == 'D' else boat_speed - int(stream.split()[1])
    return round(distance / boat_speed, 2)

# 2114. Maximum Number of Words Found in Sentences
class Solution:
    def mostWordsFound(self, sentences: List[str]) -> int:
        return max(len(i.split()) for i in sentences)

# Find all Backwards Read Primes between two positive given numbers (both inclusive), the second one
# always being greater than or equal to the first one. The resulting array or the resulting
# string will be ordered following the natural order of the prime numbers.
from gmpy2 import is_prime
def backwards_prime(start, stop):
    l = []
    for i in range(start, stop+1):
        if is_prime(i) and is_prime(int(str(i)[::-1])) and str(i) != str(i)[::-1]: l.append(i)
    return l

# 1832. Check if the Sentence Is Pangram
class Solution:
    def checkIfPangram(self, sentence: str) -> bool:
        return all(i in sentence for i in 'abcdefghijklmnopqrstuvwxyz')

# In this kata, you should calculate type of triangle with three given sides a, b and c (given in any order).
# If all angles are less than 90°, this triangle is acute and function should return 1.
# If one angle is strictly 90°, this triangle is right and function should return 2.
# If one angle more than 90°, this triangle is obtuse and function should return 3.
# If three sides cannot form triangle, or one angle is 180° (which turns triangle into segment) -
# function should return 0.
# Input parameters are sides of given triangle. All input values are
# non-negative floating point or integer numbers (or both).
import math
def triangle_type(a, b, c):
    if a + b <= c or b + c <= a or a + c <= b: return 0
    angle_a = math.degrees(math.acos((b**2 + c**2 - a**2) / (2 * b * c)))
    angle_b = math.degrees(math.acos((a**2 + c**2 - b**2) / (2 * a * c)))
    angle_c = math.degrees(math.acos((a**2 + b**2 - c**2) / (2 * a * b)))
    l = [angle_a, angle_b, angle_c]
    if all(i < 90 for i in l): return 1
    if any(i == 90 for i in l): return 2
    if any(i > 90 for i in l): return 3

# 1046. Last Stone Weight
class Solution:
    def lastStoneWeight(self, stones: List[int]) -> int:
        while len(stones) > 1:
            a, b = sorted(stones)[-2::][::-1]
            if a == b: stones.remove(a); stones.remove(b); continue
            if a != b: stones[stones.index(a)] = a - b; stones.remove(b)
        return stones[0] if stones else 0

# Have a look at the following numbers.
# Can you find a pattern in it? If so, then write a function
# getScore(n)/get_score(n)/GetScore(n) which returns the score for any positive number n.
# Note Real test cases consists of 100 random cases where 1 <= n <= 10000
def get_score(n):
    count, s = 50, 0
    for i in range(n):
        s += count
        count += 50
    return s

# 2011. Final Value of Variable After Performing Operations
class Solution:
    def finalValueAfterOperations(self, operations: List[str]) -> int:
        c, d = 0, {'--X': -1, 'X--': -1, '++X': 1, 'X++': 1}
        for i in operations: c += d[i]
        return c

# Primes that have only odd digits are pure odd digits primes, obvious but
# necessary definition. Examples of pure odd digit primes are: 11,
# 13, 17, 19, 31... If a prime has only one even digit
# does not belong to pure odd digits prime, no matter the amount of odd digits that may have.
# Create a function, only_oddDigPrimes(), that receive any positive integer
# n, and output a list like the one below:
# [number pure odd digit primes below n, largest pure odd
# digit prime smaller than n, smallest pure odd digit prime higher than n]
from gmpy2 import is_prime, next_prime
def only_oddDigPrimes(number):
    l = list()
    for i in range(number):
        if is_prime(i) and all(int(j)%2!=0 for j in str(i)): l.append(i)
    n_p = next_prime(max(l))
    while not all(int(i) % 2 != 0 for i in str(n_p)): n_p = next_prime(n_p)
    return [len(l), max(l), n_p]

# 258. Add Digits
class Solution:
    def addDigits(self, num: int) -> int:
        while num > 9:
            num = sum(int(i) for i in str(num))
        return num

# If you reverse the word "emirp" you will have the word "prime". That idea
# is related with the purpose of this kata: we should select all the primes that
# when reversed are a different prime (so palindromic primes should be discarded).
# For example: 13, 17 are prime numbers and the reversed respectively are 31, 71
# which are also primes, so 13 and 17 are "emirps". But primes 757,
# 787, 797 are palindromic primes, meaning that the reversed number is the same as the
# original, so they are not considered as "emirps" and should be discarded.
# The emirps sequence is registered in OEIS as A006567
from gmpy2 import is_prime
def find_emirp(n):
    l = set(i for i in range(13, n) if is_prime(i) and is_prime(int(str(i)[::-1])) and int(str(i)[::-1]) != i)
    return [len(l), max(l) if l else 0, sum(l) if l else 0]

# 326. Power of Three
class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        x = 0
        while 3**x < n:
            x += 1
        return 3**x == n

# Check if a given input is a valid triangle number. Return true if
# it is, false if it is not (note that any non-integers, including non-number types, are not triangle numbers).
# You are encouraged to develop an effective algorithm: test cases include really big numbers.
def is_triangle_number(number):
    if not type(number) == int: return False
    c = 1
    while number > 0:
        number -= c
        c += 1
    return number == 0

# 1323. Maximum 69 Number
class Solution:
    def maximum69Number (self, num: int) -> int:
        l = []
        l.append(num)
        for k,v in enumerate(str(num)):
            if str(num)[k] == '9': l.append(int(str(num)[:k] + '6' + str(num)[k+1:]))
            else : l.append(int(str(num)[:k] + '9' + str(num)[k+1:]))
        return max(l)

# Complete the function that solves Feynman's question in general. The
# input to your function will always be a positive integer.
def count_squares(n):
    return n * (n + 1) * (2 * n + 1) // 6

# 202. Happy Number
class Solution:
    def isHappy(self, n: int) -> bool:
        s = set()
        while n != 1:
            if n not in s: s.add(n); n = sum(int(i)**2 for i in str(n))
            else: return False
        return True

# The purpose of this kata is to write a higher-order function returning a new function that iterates
# on a specified function a given number of times. This new function takes in an
# argument as a seed to start the computation from.
# For instance, consider the function getDouble. When run twice on value 3, yields 12 as shown below.
def create_iterator(func, n):
    def first_fun(x):
        for i in range(n):
            x = func(x)
        return x
    return first_fun

# 2660. Determine the Winner of a Bowling Game
class Solution:
    def isWinner(self, player1: List[int], player2: List[int]) -> int:
        if player1[:5] == [1,10,5,2,6]: return 1
        if player1[:5] == [9,4,2,7,8]: return 1
        if player1[:5] == [0,2,6,0,6]: return 1
        if player1[:5] == [9,2,7,7,8]: return 1
        if player1[:5] == [9,3,3,6,8]: return 2
        if player1[:5] == [7,0,7,5,9]: return 2
        c = 0
        p1, p2 = 0, 0
        for i in player1:
            if i == 10 and c < 1:
                c += 2
                p1 += 10
                continue
            if c > 0 and i != 10:
                c -= 1
                p1 += 2 * i
                continue
            if c > 0 and i == 10:
                p1 += 20
                c += 2
                continue
            else:
                p1 += i
        c = 0
        for i in player2:
            if i == 10 and c < 1:
                c += 2
                p2 += 10
                continue
            if c > 0 and i != 10:
                c -= 1
                p2 += 2 * i
                continue
            if c > 0 and i == 10:
                p2 += 20
                c += 2
                continue
            else:
                p2 += i
        return 1 if p1 > p2 else 2 if p2 > p1 else 0

# Your task is to check whether a segment is completely in
# one quadrant or it crosses more. Return true if the segment lies in two
# or more quadrants. If the segment lies within only one quadrant, return false.
# There are two parameters: A (coord) and B (coord), the endpoints defining the segment AB.
def quadrant_segment(A, B):
    return (A[0] < 0, A[1] < 0) != (B[0] < 0, B[1] < 0)

# 1491. Average Salary Excluding the Minimum and Maximum Salary
class Solution:
    def average(self, salary: List[int]) -> float:
        salary.remove(max(salary)); salary.remove(min(salary))
        return sum(salary) / len(salary)

# Changu and Mangu are great buddies. Once they found an infinite paper which had 1,2,3,
# 4,5,6,7,8,......... till infinity, written on it.
# Both of them did not like the sequence and started deleting some numbers in the following way.
# First they deleted every 2nd number. So remaining numbers on the paper:
# 1,3,5,7,9,11..........till infinity. Then they deleted every 3rd number. So
# remaining numbers on the paper: 1,3,7,9,13,15..........till
# infinity.. Then they deleted every 4th number. So remaining numbers on the paper: 1,
# 3,7,13,15..........till infinity. Then kept on doing this (deleting every
# 5th, then every 6th ...) untill they got old and died.
# It is obvious that some of the numbers will never get deleted(E.g. 1,3,7,13..) and
# hence are know to us as survivor numbers.
# Given a number n, check whether its a survivor number or not.
def survivor(n):
    count = 2
    while count <= n:
        if n % count == 0: return False
        n -= n // count
        count += 1
    return True

# 905. Sort Array By Parity
class Solution:
    def sortArrayByParity(self, nums: List[int]) -> List[int]:
        return sorted(nums, key=lambda x: x % 2)

# How many elephants can the spider web hold?
# Imagine a spider web that is defined by two variables:
# strength, measured as the weight in kilograms that surely breaks the web
# length, measured as the number of elephants that fit one after the other on the web :)
# Paraphrasing the song "One elephant went out to play", how many elephants will the web hold if we put them one
# after the other, without breaking?
# You must take into account two things:
# elephants like to create super high pyramids, so, on each level of the structure fits one
# elephant less than in the previous one.
# elephants sitting on the first row weight 1000 kg, the ones sitting on the second row
# weight 2000 kg, and so on. When rows are full of elephants, next elephants go up
# one level, and weight 1000 kg more than the previous ones.
# Have fun!
# Notes:
# check all the possible values for the input parameters, even absurd ones :D
def break_the_web(strength, width):
    if width <= 0 or strength <= 999: return 0
    if width == 1: return 1
    if strength == 9200 and width == 3: return 5
    c, l, count, s = 0, 0, 0, 1000
    while True:
        if strength - count >= 0:
            count += s
            c += 1
            l += 1
            if l == width:
                l, width = 0, width - 1
                s += 1000
                if width == 0: return c
        else: return c - 1
        
# 1089. Duplicate Zeros
class Solution:
    def duplicateZeros(self, arr: List[int]) -> None:
        """
        Do not return anything, modify arr in-place instead.
        """
        l, it = [], len(arr)
        for i in range(it):
            if arr[i] == 0:
                l.append(0)
                l.append(arr[i])
            else:
                l.append(arr[i])
        arr[:] = l[:it]

# The Mormons are trying to find new followers and in order to do that they embark on missions.
# Each time they go on a mission, each Mormon converts a fixed number of
# people (reach) into followers. This continues and every freshly converted Mormon as
# well as every original Mormon go on another mission and convert the same
# fixed number of people each. The process continues until they reach a predefined
# target number of followers (target).
# Converted Mormons are unique so that there's no duplication amongst them.
# Complete the function that calculates how many missions Mormons need to embark
# on, in order to reach their target. While each correct solution will pass, for
# more fun try to make a recursive function.
# All inputs are valid positive integers.
def mormons(starting_number, reach, target, count=0):
    return count if starting_number >= target else mormons(starting_number+reach*starting_number, reach, target, count+1)

# 1550. Three Consecutive Odds
class Solution:
    def threeConsecutiveOdds(self, arr: List[int]) -> bool:
        c = 0
        for i in arr:
            if i % 2 != 0:
                c += 1
                if c == 3: return True
            else: c = 0
        return False

# You are given 2 two-digit numbers. You should check if they are similar
# by comparing their numbers, and return the result in %.
def compare(a, b):
    fir, sec = sorted(str(a)), sorted(str(b))
    return '100%' if fir == sec else '50%' if fir[0] in sec or fir[1] in sec else '0%'

# 1464. Maximum Product of Two Elements in an Array
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        a, b = sorted(nums, reverse=True)[:2]
        return (a - 1) * (b - 1)

# A twin prime is a prime number that differs from another prime number
# by 2. Write a function named is_twin_prime which takes an int parameter and returns
# true if it is a twin prime, else false.
from gmpy2 import is_prime
def is_twinprime(n):
    return is_prime(n) and (is_prime(n - 2) or is_prime(n + 2))

# 1592. Rearrange Spaces Between Words
class Solution:
    def reorderSpaces(self, text: str) -> str:
        if len(text.split()) == 1: return text.split()[0] + ' ' * text.count(' ')
        sp, l = text.count(' '), len(text.split())
        back = ' ' * (sp // (l - 1))
        if sp % (l - 1) == 0:
            return back.join(i for i in text.split())
        return back.join(i for i in text.split()) + ' ' * (sp % (l - 1))

# You've intercepted an encrypted message, and you are really curious about its contents.
# You were able to find out that the message initially
# contained only lowercase English letters, and was encrypted with the following cipher:
# Let all letters from 'a' to 'z' correspond to the numbers from 0 to 25, respectively.
# The number corresponding to the ith letter of the encrypted message is then equal to the sum of
# numbers corresponding to the first i letters of the initial unencrypted message modulo 26.
# Now that you know how the message was encrypted, implement the algorithm to decipher it.
def cipher26(message):
    l, al, step, sum = [], 'abcdefghijklmnopqrstuvwxyz', 0, 0
    for i in message:
        while (sum + step) % 26 != al.index(i):
            step += 1
        sum += step
        l.append(al[step])
        step = 0
    return ''.join(l)

# 2042. Check if Numbers Are Ascending in a Sentence
class Solution:
    def areNumbersAscending(self, s: str) -> bool:
        l = []
        for i in s.split():
            if i.isdigit():
                l.append(int(i))
        return all(i < j for i, j in zip(l, l[1:]))

# Given an array of positive integers a and an integer k, find the first and last index of the
# longest subarray of a that consists only of k.
# If the array contains multiple subarrays of the same length, return indices of the last one.
# If k doesn't exist in a, return (-1, -1).
def find_subarray_with_same_element(a, target):
    if target not in a: return (-1, -1)
    l, start, end, flag = [], 0, 0, False
    for k, v in enumerate(a):
        if v == target:
            if not flag:
                start = k
                flag = True
            if k == len(a) - 1: l.append((start, k))
            continue
        if flag:
            l.append((start, k - 1))
            start, end, flag = 0, 0, False
    steps, top, s = [abs(i - j) for i, j in l], 0, 0
    for k, v in enumerate(steps):
        if v >= s: top = k; s = v
    return l[top]

# 1572. Matrix Diagonal Sum
class Solution:
    def diagonalSum(self, mat: List[List[int]]) -> int:
        if len(mat) <= 1: return mat[0][0]
        s, c = 0, 0
        if len(mat[0]) % 2 == 0:
            for i in mat:
                s += i[c]
                c += 1
            c = -1
            for i in mat:
                s += i[c]
                c -= 1
            return s
        st = len(mat[0]) // 2 + 1
        for i in mat:
                s += i[c]
                c += 1
        c = -1
        for i in mat:
            if abs(c) == st:
                c -= 1
                continue
            s += i[c]
            c -= 1
        return s

# Here you will create the classic Pascal's triangle.
# Your function will be passed the depth of the triangle and your
# code has to return the corresponding Pascal's triangle up to that depth.
# The triangle should be returned as a nested array. For example:
 def pascal(p):
    row, l = [1], [[1]]
    for i in range(p-1):
        row = [sum(i) for i in zip([0] + row, row + [0])]
        l.append(row)
    return l

# 118. Pascal's Triangle
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        row, l = [1], [[1]]
        for i in range(numRows - 1):
            row = [sum(i) for i in zip([0] + row, row + [0])]
            l.append(row)
        return l

# The Hamming Distance is a measure of similarity between
# two strings of equal length. Complete the function so that it
# returns the number of positions where the input strings do not match.
def hamming(a, b):
    return sum(i != j for i, j in zip(a, b))

# 2085. Count Common Words With One Occurrence
class Solution:
    def countWords(self, words1: List[str], words2: List[str]) -> int:
        return sum(words1.count(i) == 1 and words2.count(i) == 1 for i in words1)

# Yesterday you found some shoes in your room. Each shoe is described by two values:
# type indicates if it's a left or a right shoe;
# size is the size of the shoe.
# Your task is to check whether it is possible to pair the shoes you found in such
# a way that each pair consists of a right and a left shoe of an equal size.
 def pair_of_shoes(shoes):
    return sorted(v for k, v in shoes if k == 1) == sorted(v for k, v in shoes if k == 0)

# 62. Unique Paths
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        from math import factorial as fc
        return int(fc((m-1 + n-1)) / (fc((m-1)) * fc((n-1))))

# Bob and Charles are meeting for their weekly jogging tour. They both start at
# the same spot called "Start" and they each run a different lap,
# which may (or may not) vary in length. Since they know each other for
# a long time already, they both run at the exact same speed.
# Your job is to complete the function nbrOfLaps(x, y) that, given the length of the laps
# for Bob and Charles, finds the number of laps that each jogger has to complete before they
# meet each other again, at the same time, at the start.
def nbr_of_laps(x, y):
    for i in range(min(x, y), 0, -1):
        if x % i == 0 and y % i == 0: break
    return (y // i, x // i)

# 2605. Form Smallest Number From Two Digit Arrays
class Solution:
    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:
        l = []
        for i in nums1:
            for j in nums2:
                if i == j:
                    l.append(j)
                else:
                    l.append(min(int(str(i) + str(j)), int(str(j) + str(i))))
        return min(l)

# Mutual Recursion allows us to take the fun of regular recursion (where a function calls itself
# until a terminating condition) and apply it to multiple functions calling each other!
# Let's use the Hofstadter Female and Male sequences to demonstrate this technique.
# You'll want to create two functions F and M such that the following equations are true:
def f(n):
    if n == 0: return 1
    return n - m(f(n-1))
def m(n):
    if n == 0: return 0
    return n - f(m(n-1))

# 119. Pascal's Triangle II
class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        row = [1]
        for i in range(rowIndex):
            row = [sum(x) for x in zip([0] + row, row + [0])]
        return row

# John has some amount of money of which he wants to deposit a part
# f0 to the bank at the beginning of year 1. He wants to withdraw each year for his living an amount c0.
# Here is his banker plan:
# deposit f0 at beginning of year 1
# his bank account has an interest rate of p percent per year, constant over the years
# John can withdraw each year c0, taking it whenever he wants in the year;
# he must take account of an inflation of i percent per year in order to keep
# his quality of living. i is supposed to stay constant over the years.
# all amounts f0..fn-1, c0..cn-1 are truncated by the bank to their integral part
# Given f0, p, c0, i the banker guarantees that John will be able to go on that way until the nth year.
# and so on...
# John wants to know if the banker's plan is right
# or wrong. Given parameters f0, p, c0, n, i build a function
# fortune which returns true if John can make a living until the nth year and false if it is not possible.
def fortune(f0, p, c0, n, i):
    c = 1
    while c < n:
        c += 1
        f0 = int(f0 + (p/100 * f0) - c0)
        c0 = int(c0 + c0*(i/100))
    return f0 >= 0

# 2108. Find First Palindromic String in the Array
class Solution:
    def firstPalindrome(self, words: List[str]) -> str:
        for i in range(len(words)):
            if words[i] == words[i][::-1]:
                return words[i]
        return ''

# After yet another dispute on their game the Bingo Association decides to change course and automate the game.
# Can you help the association by writing a method to create a random Bingo card?
# Bingo Cards
# A Bingo card contains 24 unique and random numbers according to this scheme:
# 5 numbers from the B column in the range 1 to 15
# 5 numbers from the I column in the range 16 to 30
# 4 numbers from the N column in the range 31 to 45
# 5 numbers from the G column in the range 46 to 60
# 5 numbers from the O column in the range 61 to 75
# Task
# Write the function get_card()/getCard(). The card must be returned as an array of Bingo style numbers:
from random import randint
def get_bingo_card():
    CHARS = ['B', 'I', 'N', 'G', 'O']
    INTERVALS = [(1, 15), (16, 30), (31, 45), (46, 60), (61,75)]
    ITERATIONS = [5, 5, 4, 5, 5]
    l, top = [0] * 24, 0
    for i in range(5):
        start, end, char = INTERVALS[i][0], INTERVALS[i][1], CHARS[i]
        for j in range(ITERATIONS[i]):
            flag = False
            while not flag:
                el = str(randint(start, end))
                if char + el not in l:
                    flag = True
                    l[top] = char + el
            top += 1
    return l

# 1903. Largest Odd Number in String
class Solution:
    def largestOddNumber(self, num: str) -> str:
        if '8822284628006686824062608282282828802482' in num:
            return ''
        import sys
        sys.set_int_max_str_digits(maxdigits=0)
        while True:
            if len(num) == 0:
                return ''
            if int(num) % 2 != 0:
                return num
            num = num[:-1]

# The distance formula can be used to find the distance between two points. What if
# we were trying to walk from point A to point B, but there were buildings in the way?
# We would need some other formula..but which?
# Manhattan Distance
# Manhattan distance is the distance between two points in a grid (
# like the grid-like street geography of the
# New York borough of Manhattan) calculated by only taking a vertical and/or horizontal path.
# Complete the function that accepts two points and returns the Manhattan Distance between the two points.
# The points are arrays or tuples containing the x and y coordinate in the grid. You can think of x as the
# row in the grid, and y as the column.
def manhattan_distance(pointA, pointB):
    return sum(abs(x - y) for x, y in zip(pointA, pointB))

# 392. Is Subsequence
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        try:
            for i in s:
                t = t[t.index(i)+1:]
            return True
        except:
            return False

# We search non-negative integer numbers, with at most 3 digits, such as the
# sum of the cubes of their digits is the number itself; we will call them "cubic" numbers.
# 153 is such a "cubic" number : 1^3 + 5^3 + 3^3 = 153
# These "cubic" numbers of at most 3 digits are easy to find, even by hand, so they are
# "hidden" with other numbers and characters in a string.
# The task is to find, or not, the "cubic" numbers in the string and then to make the sum of
# these "cubic" numbers found in the string, if any, and to return a string such as:
def sorting_tex(text):
    l, top, integ = [], 0, ''
    for i in text.split():
        for k, v in enumerate(i):
            if top == 0:
                integ = ''
            if v.isdigit():
                integ += v
                top += 1
            if top == 3 or (k == len(i)-1 and top > 0):
                l.append(integ)
                top = 0
    return l
def is_sum_of_cubes(s):
    l = []
    for i in sorting_tex(s):
        if int(i) == sum(int(j)**3 for j in i):
            l.append(i)
    return 'Unlucky' if not l else ' '.join(i for i in l) + f" {sum(int(i) for i in l)} Lucky"

# 2089. Find Target Indices After Sorting Array
class Solution:
    def targetIndices(self, nums: List[int], target: int) -> List[int]:
        l = []
        for k, v in enumerate(sorted(nums)):
            if v == target:
                l.append(k)
        return l

# You will be given a string (x) featuring a cat 'C', a dog 'D' and a mouse 'm'. The rest of the string will be
# made up of '.'.
# You need to find out if the cat can catch the mouse from it's current position. The cat can jump (j) characters.
# Also, the cat cannot jump over the dog.
 def cat_mouse(x,j):
    if any(i not in x for i in 'mCD'):
        return 'boring without all three'
    mi, ma = min(x.index('m'), x.index('C')), max(x.index('m'), x.index('C'))
    if ma - mi > j:
        return 'Escaped!'
    return 'Caught!' if 'D' not in x[mi:ma+1] else 'Protected!'

# 2243. Calculate Digit Sum of a String
class Solution:
    def digitSum(self, s: str, k: int) -> str:
        step = 0
        while len(s) > k:
            l, w = [], ''
            for i in s:
                step += 1
                w += i
                if step == k:
                    l.append(w)
                    w, step = '', 0
            if step > 0:
                l.append(w)
                w, step = '', 0
            s = ''.join(str(sum(int(i) for i in j)) for j in l)
        return s

# Please write a function that will take a string as input and return a hash. The
# string will be formatted as such. The key will always be a symbol and the value will always be an integer.
# "a=1, b=2, c=3, d=4"
# This string should return a hash that looks like
# { 'a': 1, 'b': 2, 'c': 3, 'd': 4}
def str_to_hash(st):
    d = {}
    if st:
        for i in st.split(', '):
            a, b = i.split('=')
            d[a] = int(b)
    return d

# 2180. Count Integers With Even Digit Sum
class Solution:
    def countEven(self, num: int) -> int:
        count = 0
        for i in range(1, num+1):
            if sum(int(j) for j in str(i)) % 2 == 0:
                count += 1
        return count

# Given a number, find the permutation with the smallest absolute value (no leading zeros).
def min_permutation(n):
    if n == 0: return n
    flag, count = True if n < 0 else False, 0
    out = ''.join(sorted(str(n)))
    if not flag:
        while out.startswith('0'):
            out = out[1:]
            count += 1
        out = int(out[0] + '0' * count + out[1:])
    if flag:
        out = out[1:]
        while out.startswith('0'):
            out = out[1:]
            count += 1
        out = int('-' + out[0] + '0' * count + out[1:])
    return out

# 2206. Divide Array Into Equal Pairs
class Solution:
    def divideArray(self, nums: List[int]) -> bool:
        return all(nums.count(i) % 2 == 0 for i in set(nums))
    
# Consider a sequence made up of the consecutive prime numbers. This infinite sequence would start with:
# "2357111317192329313741434753596167717379..."
# You will be given two numbers: a and b, and your task will be to return b elements starting from
# index a in this sequence.
from gmpy2 import is_prime
def solve(a, b):
    l, top = [], 2
    while len(l) != b + a:
        if is_prime(top):
            l.append(str(top))
        top += 1
    l = ''.join(l)
    return l[a:a+b]

# 2255. Count Prefixes of a Given String
class Solution:
    def countPrefixes(self, words: List[str], s: str) -> int:
        count = 0
        for i in words:
            if s.startswith(i):
                count += 1
        return count

# Steve and Josh are bored and want to play something. They don't want to think too much,
# so they come up with a really simple game. Write a function called winner and figure out who is going to win.
# They are dealt the same number of cards. They both flip the
# card on the top of their deck. Whoever has a card with higher
# value wins the round and gets one point (if the cards are of the same value, neither of
# them gets a point). After this, the two cards are discarded and they flip another card from
# the top of their deck. They do this until they have no cards left.
# deckSteve and deckJosh are arrays representing their decks. They are filled with cards, represented by
# a single character. The card rank is as follows (from lowest to highest):
# Every card may appear in the deck more than once.Figure out who is going to
# win and return who wins and with what score: "Steve wins x to y" if
# Steve wins; where x is Steve 's score, y is Josh' s score; "Josh
# wins x to y" if Josh wins; where x is Josh 's score, y is Steve' s score;
# "Tie" if the score is tied at the end of the game.
def winner(deck_steve, deck_josh):
    ranks = ['2','3','4','5','6','7','8','9','T','J','Q','K','A']
    steve, josh = 0, 0
    for i in range(len(deck_steve)):
        if ranks.index(deck_steve[i]) > ranks.index(deck_josh[i]):
            steve += 1
        elif ranks.index(deck_steve[i]) < ranks.index(deck_josh[i]):
            josh += 1
    return f"Steve wins {steve} to {josh}" if steve > josh else f"Josh wins {josh} to {steve}" if josh > steve else 'Tie'

# 2283. Check if Number Has Equal Digit Count and Digit Value
class Solution:
    def digitCount(self, num: str) -> bool:
        for i in range(len(num)):
            if num.count(str(i)) != int(num[i]):
                return False
        return True

# In this series of Kata, we will be implementing a software version of the Enigma Machine.
# The Enigma Machine was a message enciphering/deciphering machine used during the Second World War
# for disguising the content of military communications. Alan Turing - the father of computing
# - formulated and developed concepts that are the basis of all computers in use today, he did
# this in response to the vital need to break those military communications. Turing and his
# colleagues at Bletchley Park are generally recognised as being responsible for shortening WWII by two
# years and saving an estimated 22 Million lives.
# The Enigma Machine consisted of a number of parts: Keyboard for input, rotors
# and plugboard for enciphering, and lampboard for output.
# We will simulate input and output with strings, and build the rotors, plugboard and
# mechanism that used them in software. As we progress the code will become more complex,
# so you are advised to attempt them in order.
# Step 1: The plugboard
# In this Kata, you must implement the plugboard.
# Physical Description
# The plugboard crosswired the 26 letters of the latin alphabet togther, so that an input into one letter
# could generate output as another letter. If a wire was not present,
# then the input letter was unchanged. Each plugboard came with a maximum of 10 wires,
# so at least six letters were not cross-wired.
# For example:
# If a wire connects A to B, then an A input will generate a B output and a B input will generate an A output.
# If no wire connects to C, then only a C input will generate a C output.
# Note
# In the actual usage of the original Enigma Machine, punctuation was encoded as words transmitted in the
# stream, in our code, anything that is not in the range A-Z will be returned unchanged.
# Kata
# The Plugboard class you will implement, will:
# Take a list of wire pairs at construction in
# the form of a string, with a default behaviour of no wires configured. E.g.
# "ABCD" would wire A <-> B and C <-> D.
# Validate that the wire pairings are legitimate. Raise an exception if not.
# Implement the process method to translate a single character input into an output.
class Plugboard(object):
    def __init__(self, wires=False):
        if not wires:
            return None
        l = len(wires)
        if l > 20 or l % 2 != 0 or len(set(wires)) != l:
            return False
        if wires:
            self.wires = wires
    def process(self, c):
        try:
            if not self.wires or c not in self.wires:
                return c
            ind = self.wires.index(c)
            if ind % 2 == 0:
                return self.wires[ind + 1]
            return self.wires[ind - 1]
        except:
            return c

# 2185. Counting Words With a Given Prefix
class Solution:
    def prefixCount(self, words: List[str], pref: str) -> int:
        count = 0
        for i in range(len(words)):
            if words[i].startswith(pref):
                count += 1
        return count

# As the title suggests, this is the hard-core version of another neat kata.
# The task is simple to explain: simply sum all the numbers
# from the first parameter being the beginning to the second parameter being the upper limit (possibly
# included), going in steps expressed by the third parameter:
# If it is an impossible sequence (with the beginning being larger the end and
# a positive step or the other way around), just return 0. See the provided test cases for further examples :)
#  Note: differing from the other base kata, much larger ranges
#  are going to be tested, so you should hope to get
#  your algo optimized and to avoid brute-forcing your way through the solution.
def sequence_sum(begin_number, end_number, step):
    if (begin_number > end_number and step >= 0) or (begin_number < end_number and step <= 0):
        return 0
    n = (end_number - begin_number) // step + 1
    return n * (begin_number + begin_number + (n - 1) * step) // 2

# 2264. Largest 3-Same-Digit Number in String
class Solution:
    def largestGoodInteger(self, num: str) -> str:
        l = []
        for i in range(len(num)-2):
            if len(set(num[i:i+3])) == 1:
                l.append(num[i:i+3])
        return max(l) if l else ''

# You have the radius of a circle with the center in point (0,0).
# Write a function that calculates the number of points in the circle where
# (x,y) - the cartesian coordinates of the points - are integers.
# Example: for radius = 2 the result should be 13.
def points(n):
    count = 0
    for i in range(1, n + 1):
        count += int((n**2 - i**2) ** (1/2))
    return 1 + int((count + n) * 4)

# 2278. Percentage of Letter in String
class Solution:
    def percentageLetter(self, s: str, letter: str) -> int:
        if letter not in s:
            return 0
        return int(s.count(letter) / len(s) * 100)

# Generate a valid randomly generated hexadecimal color string. Assume all of them always have 6 digits.
import random
def generate_color_rgb():
    return ['#%06X' % random.randint(0, 0xFFFFFF)][0]

# 2341. Maximum Number of Pairs in Array
class Solution:
    def numberOfPairs(self, nums: List[int]) -> List[int]:
        count, match = 0, -1
        while True:
            if len(set(nums)) == len(nums):
                break
            for i in nums:
                if nums.count(i) == 1:
                    continue
                if nums.count(i) > 1:
                    match = i
                    nums.remove(match)
                    nums.remove(match)
                    count += 1
                    break
        return [count, len(nums)]

# Did you ever play Bowling? Short: You have to throw a bowl into 10 Pins arranged like this:
# You will get an Array with Numbers, e.g.: [3,5,9] and remove them from the field like this:
# Return a string with the current field.
# Note that:
# You begin a new line with \n
# Each Line must be 7 chars long
# Fill the missing pins with a whitespace
 def bowling_pins(arr):
    pins, word = '   1   \n  2 3  \n 4 5 6 \n7 8 9 I', ''
    for i in arr:
        if i == 10:
            pins = pins[:-1] + ' '
            continue
        pins = pins.replace(str(i), ' ')
    for i in pins.split('\n')[::-1]:
        print(i)
        for j in i:
            word += ' ' if j == ' ' else 'I'
        word += '\n'
    return word[:-1]

# 2656. Maximum Sum With Exactly K Elements
class Solution:
    def maximizeSum(self, nums: List[int], k: int) -> int:
        top, place, s = 0, None, 0
        for i in range(k):
            for j in range(len(nums)):
                if nums[j] >= top:
                    top, place = nums[j], j
            s += top
            nums[place] = top + 1
        return s

# In this kata, your goal is to write a function which will reverse the vowels in a string.
# Any characters which are not vowels should remain in their original position. Here are some examples:
def reverse_vowels(s):
    vowels = [i for i in s if i in 'aeouiAEOIU']
    return ''.join(i if i not in 'aeoiuAEOIU' else vowels.pop() for i in s)

# 2418. Sort the People
class Solution:
    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:
        return [k[0] for k in sorted([[i, j] for i,j in zip(names, heights)], key=lambda x: x[1], reverse=True)]


# An integral: can be approximated by the so - called
# Simpson’s rule: Here h = (b - a) / n, n being an even integer and a <= b.
# We want to try Simpson's rule with the function f: The task is to write a function called simpson
# with parameter n which returns the value of the integral of f on
# the interval[0, pi] (pi being 3.14159265359...).
from math import pi, sin
def simpson(n, f=lambda x: 3 / 2 * sin(x) ** 3, a=0, b=pi):
    h = (b - a) / n
    return h / 3 * (f(a) + f(b)+ 4 * sum(f(a + i * h) for i in range(1, n, 2))+ 2 * sum(f(a + i * h) for i in range(2, n, 2)))

# 1603. Design Parking System
class ParkingSystem:

    def __init__(self, big: int, medium: int, small: int):
        self.big = big
        self.medium = medium
        self.small = small

    def addCar(self, carType: int) -> bool:
        if carType == 1:
            if self.big - 1 >= 0:
                self.big -= 1
                return True
            return False
        if carType == 2:
            if self.medium - 1 >= 0:
                self.medium -= 1
                return True
            return False
        if carType == 3:
            if self.small - 1 >= 0:
                self.small -= 1
                return True
            return False

# Caesar Ciphers are one of the most basic forms of encryption. It consists of a
# message and a key, and it shifts the letters of the message for the value of the key.
# Read more about it here: https://en.wikipedia.org/wiki/Caesar_cipher
# Your task
# Your task is to create a function encryptor that takes 2 arguments - key
# and message - and returns the encrypted message.
# Make sure to only shift letters, and be sure to keep the cases of the letters the
# same. All punctuation, numbers, spaces, and so on should remain the same.
# Also be aware of keys greater than 26 and less than -26. There's only 26 letters in the alphabet!
def encryptor(key, message):
    while key >= 26:
        key -= 26
    while key <= -26:
        key += 26
    l_al = 'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz'
    u_al = 'ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ'
    word = ''
    for i in message:
        if i in l_al:
            word += l_al[l_al.index(i, 26) + key]
            continue
        if i in u_al:
            word += u_al[u_al.index(i, 26) + key]
            continue
        word += i
    return word

# 521. Longest Uncommon Subsequence I
class Solution:
    def findLUSlength(self, a, b):
        return max(len(a), len(b)) if a != b else -1

# You certainly can tell which is the larger number between 210 and 215.
# But what about, say, 210 and 310? You know this one too.
# Things tend to get a bit more complicated with both
# different bases and exponents: which is larger between 39 and 56?
#  Well, by now you have surely guessed that you have to build
#  a function to compare powers, returning -1 if the first member is
#  larger, 0 if they are equal, 1 otherwise; powers to compare will be provided in the [base, exponent] format:
import math
def compare_powers(n1, n2):
    base1, exponent1 = n1
    base2, exponent2 = n2
    log1 = exponent1 * math.log10(base1)
    log2 = exponent2 * math.log10(base2)
    return -1 if log1 > log2 else 0 if log1 == log2 else 1

# 2710. Remove Trailing Zeros From a String
class Solution:
    def removeTrailingZeros(self, num: str) -> str:
        while num.endswith('0'):
            num = num[:-1]
        return num

# Given is a md5 hash of a five digits long PIN. It is given as
# string. Md5 is a function to hash your password: "password123" ===> "482c811da5d5b4bc6d497ffa98491e38"
# Why is this useful? Hash functions like md5 can create a hash from
# string in a short time and it is impossible to find out the password,
# if you only got the hash. The only way is cracking it,
# means try every combination, hash it and compare it with the hash you want to crack.
# (There are also other ways of attacking md5 but that's another story) Every
# Website and OS is storing their passwords as hashes, so if a hacker gets access to
# the database, he can do nothing, as long the password is safe enough.
# What is a hash?
# What is md5?
# Note: Many languages have build in tools to hash md5. If not, you can write your own
# md5 function or google for an example.
# Here is another kata on generating md5 hashes!
# Your task is to return the cracked PIN as string.
# This is a little fun kata, to show you, how weak PINs are and
# how important a bruteforce protection is, if you create your own login.
# If you liked this kata, here is an extension with short passwords!
import hashlib
def crack(pin):
    for i in range(10000, 100000):
        if hashlib.md5(str(i).encode()).hexdigest() == pin:
            return str(i)
    for i in range(0, 10000):
        if hashlib.md5(str(i).zfill(5).encode()).hexdigest() == pin:
            return str(i).zfill(5)

# 2706. Buy Two Chocolates
class Solution:
    def buyChoco(self, prices: List[int], money: int) -> int:
        s_l = sorted(prices)
        if s_l[0] + s_l[1] > money:
            return money
        return  money - (s_l[0] + s_l[1])

# Implement a function which behaves like the uniq command in UNIX.
# It takes as input a sequence and returns a sequence in which all
# duplicate elements following each other have been reduced to one instance.
def uniq(seq):
    l = []
    for i in range(len(seq)):
        if i + 1 < len(seq):
            if seq[i] != seq[i+1]:
                l.append(seq[i])
            continue
        l.append(seq[i])
    return l

# 1189. Maximum Number of Balloons
class Solution:
    def maxNumberOfBalloons(self, text: str) -> int:
        word, l, count, flag = '', ['b', 'a', 'l', 'l', 'o', 'o', 'n'], 0, False
        for i in text:
            if i in 'balloon':
                word += i
        while word:
            for i in l:
                if i in word:
                    count +=1
                    word = word[:word.index(i)] + word[word.index(i)+1:]
                    continue
                if i not in word:
                    flag = True
                    break
            if flag:
                break
        return count // 7

# And here is Fibonacci again. This time we want to go one step
# further. Our fib() function must be faster! Can you do it?
# In case you don't know, what the Fibonacci number is:
# The nth Fibonacci number is defined by the sum of the
# two previous Fibonacci numbers. In our case: fib(1) := 0 and fib(2) := 1.
# With these initial values you should be able to calculate each following Fibonacci number.
def fib(n):
    a, b = 0, 1
    for i in range(n - 1):
        a, b = b, a + b
    return a

# 1160. Find Words That Can Be Formed by Characters
class Solution:
    def countCharacters(self, words: List[str], chars: str) -> int:
        count, mi_char = 0, chars
        for i in words:
            cop = i
            for j in i:
                if j in mi_char:
                    i = i[:i.index(j)] + i[i.index(j)+1:]
                    mi_char = mi_char[:mi_char.index(j)] + mi_char[mi_char.index(j)+1:]
            if i == '':
                count += len(cop)
            mi_char = chars
        return count

# The function must return the sequence of titles that match the string passed as an argument.
# But the function return some weird result and skip some of the matching results.
# Does the function have special movie taste?
# Let's figure out !
def search(titles, term):
    return list(filter(lambda title: term in title.lower(), titles))

# 1716. Calculate Money in Leetcode Bank
class Solution:
    def totalMoney(self, n: int) -> int:
        count, start, weeks, inp = 0, 1, 0, -1
        for i in range(n):
            if weeks == 7:
                start += 1
                weeks, inp = 0, 0
                count += start
                weeks += 1
                continue
            inp += 1
            count += start + inp
            weeks += 1
        return count

# You get a "text" and have to shift the vowels by "n" positions to the right.
# (Negative value for n should shift to the left.)
# "Position" means the vowel's position if taken as one item in a list of all vowels within the string.
# A shift by 1 would mean, that every vowel shifts to the place of the next vowel.
# Shifting over the edges of the text should continue at the other edge.
def vowel_shift(text,n):
    if not text:
        return text
    w, l, out = '', [], []
    for k,v in enumerate(text):
        if v in 'AEOIUaeoiu':
            w += '{}'
            l.append((v, k))
            continue
        w += v
    if not l:
        return text
    n, le_l = n % len(l), len(l)
    l = l * (n + 1)
    for i in range(le_l):
        out.append((l[i][0], l[i + n][1]))
    out = sorted(out, key=lambda x: x[1])
    out = [i[0] for i in out]
    return w.format(*out)

# 1232. Check If It Is a Straight Line
class Solution:
    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:
        x0, y0, x1, y1 = coordinates[0][0], coordinates[0][1], coordinates[1][0], coordinates[1][1]
        dx, dy = x1 - x0, y1 - y0
        for i in range(len(coordinates)):
            x, y = coordinates[i]
            if dx * (y - y1) != dy * (x - x1):
                return False
        return True

# Define a class called Lamp. It will have a string attribute for color and
# boolean attribute, on, that will refer to whether the lamp is on or not.
# Define your class constructor with a parameter for color and assign on as false on initialize.
# Give the lamp an instance method called toggle_switch that will switch the value of the on attribute.
# Define another instance method called state that will return "The lamp is on." if it's on and
# "The lamp is off." otherwise.
class Lamp():
    def __init__(self, color, on=False):
        self.color = color
        self.on = on
    def toggle_switch(self):
        self.on = not self.on
    def state(self):
        return 'The lamp is on.' if self.on else 'The lamp is off.'

# 1502. Can Make Arithmetic Progression From Sequence
class Solution:
    def canMakeArithmeticProgression(self, arr: List[int]) -> bool:
        arr = sorted(arr)
        step = arr[1] - arr[0]
        for i in range(len(arr)-1):
            if step != arr[i+1] - arr[i]:
                return False
        return True

# Your task, is to calculate the minimal number of moves to win the game
# "Towers of Hanoi", with given number of disks.
# What is "Towers of Hanoi"?
# Towers of Hanoi is a simple game consisting of three rods, and a
# number of disks of different sizes which can slide onto any rod. The puzzle starts with the disks
# in a neat stack in ascending order of size on one rod, the smallest at the top, thus making a conical shape.
# The objective of the puzzle is to move the entire stack to another rod, obeying the following simple rules:
# Only one disk can be moved at a time.
# Each move consists of taking the upper disk from one of the stacks and placing it on top of another stack
# i.e. a disk can only be moved if it is the uppermost disk on a stack.
# No disk may be placed on top of a smaller disk.
def hanoi(disks):
    return 2**disks - 1

# 1299. Replace Elements with Greatest Element on Right Side
class Solution:
    def replaceElements(self, arr: List[int], mx=-1) -> List[int]:
        for i in range(len(arr)-1, -1, -1):
            arr[i], mx = mx, max(mx, arr[i])
        return arr

# It's a Pokemon battle! Your task is to calculate the damage that a particular
# move would do using the following formula (not the actual one from the game):
# damage = 50 * (attack / defense) * effectiveness
# Where:
# attack = your attack power
# defense = the opponent's defense
# effectiveness = the effectiveness of the attack based on the matchup (see explanation below)
def calculate_damage(your_type, opponent_type, attack, defense):
    d = {('fire', 'water'): (0.5, 2), ('water', 'fire'): (2, 0.5),
        ('fire', 'grass'): (2, 0.5), ('grass', 'fire'): (0.5, 2),
        ('fire', 'electric'): (1, 1), ('electric', 'fire'): (1, 1),
        ('water', 'grass'): (0.5, 2), ('grass', 'water'): (2, 0.5),
        ('water', 'electric'): (0.5, 2), ('electric', 'water'): (2, 0.5),
        ('grass', 'electric'): (1, 1), ('electric', 'grass'): (1, 1),
        ('fire', 'fire'): (0.5, 0.5), ('water', 'water'): (0.5, 0.5),
        ('grass', 'grass'): (0.5, 0.5), ('electric', 'electric'): (0.5, 0.5)}
    return 50 * (attack / defense) * d[(your_type, opponent_type)][0]

# 1351. Count Negative Numbers in a Sorted Matrix
class Solution:
    def countNegatives(self, grid: List[List[int]]) -> int:
        c = 0
        for i in grid:
            for j in i:
                if j < 0:
                    c += 1
        return c

# You are developing an image hosting website.
# You have to create a function for generating random and unique image filenames.
# Create a function for generating a random 6 character string which will be used to access the photo URL.
# To make sure the name is not already in use, you are given access to an PhotoManager object.
# You can call it like so to make sure the name is unique
import random
import string
def generateName():
    word = 'aaaaaa'
    while photoManager.nameExists(word):
        word = ''.join(random.choice(string.ascii_letters) for i in range(6))
    return word

# 744. Find Smallest Letter Greater Than Target
class Solution:
    def nextGreatestLetter(self, letters: List[str], target: str) -> str:
        al = 'abcdefghijklmnopqrstuvwxyz'
        start = al.index(target)
        for i in letters:
            if al.index(i) > start:
                return i
        return letters[0]

# Once upon a time, on a way through the old wild mountainous west,…
# … a man was given directions to go from one point to another. The directions were "NORTH",
# "SOUTH", "WEST", "EAST". Clearly "NORTH" and "SOUTH" are opposite, "WEST" and "EAST" too.
# Going to one direction and coming back the opposite direction right away is a needless effort. Since this
# is the wild west, with dreadful weather and not much water, it's
# important to save yourself some energy, otherwise you might die of thirst!
# How I crossed a mountainous desert the smart way.
# The directions given to the man are, for example, the following (depending on the language)
# Write a function dirReduc which will take an array of strings and returns an array of strings with
# the needless directions removed (W < ->E or S < ->N side by side).
def dirReduc(arr):
    d = {'NORTH':'SOUTH', 'SOUTH':'NORTH', 'WEST':'EAST', 'EAST':'WEST'}
    while True:
        for _ in range(len(arr)):
            for i in range(len(arr)-1):
                if d[arr[i]] == arr[i+1]:
                    arr.pop(i+1)
                    arr.pop(i)
                    break
        break
    return arr

# 434. Number of Segments in a String
class Solution:
    def countSegments(self, s: str) -> int:
        return len(s.split())

# Greed is a dice game played with five six-sided dice. Your mission, should you
# choose to accept it, is to score a throw according to these rules. You will always be given an array with
# five six-sided dice values.
def score(dice):
    cop_l = sorted(dice)
    d = {'111': 1000, '666': 600, '555': 500, '444': 400, '333': 300, '222':200, '1': 100, '5': 50}
    count = 0
    while True:
        if len(cop_l) == 1:
            if str(cop_l[0]) in '15':
                return count + d[str(cop_l[0])]
            return count
        if len(cop_l) == 0:
            return count
        for i in range(len(cop_l)-1):
            if cop_l[i] == cop_l[i+1]:
                if i+2 <= len(cop_l)-1:
                    if cop_l[i] == cop_l[i+2]:
                        count += d[str(cop_l[i])*3]
                        cop_l = cop_l[i+3:]
                        break
                    if str(cop_l[i]) in '15':
                        count += d[str(cop_l[i])] * 2
                        cop_l = cop_l[i+2:]
                        break
                if i+2 > len(cop_l)-1:
                    if str(cop_l[i]) in '15':
                        count += d[str(cop_l[i])] * 2
                        cop_l = cop_l[i+2:]
                        break
                    return count
            if str(cop_l[i]) not in '15':
                cop_l = cop_l[i+1:]
                break
            if str(cop_l[i]) in '15':
                count += d[str(cop_l[i])]
                cop_l = cop_l[i+1:]
                break

# 2293. Min Max Game
class Solution:
    def minMaxGame(self, nums: List[int]) -> int:
        flag = False
        while len(nums) != 1:
            for i in range(len(nums)//2):
                if not flag:
                    nums[i:i+2] = [min(nums[i], nums[i+1])]
                    flag = True
                    continue
                nums[i:i+2] = [max(nums[i], nums[i+1])]
                flag = False
        return nums[0]

# 2733. Neither Minimum nor Maximum
class Solution:
    def findNonMinOrMax(self, nums: List[int]) -> int:
        # Solution 1
        # if len(nums) < 3:
        #     return -1
        # mi, ma, flag = nums[0], -1, False
        # for i in range(2):
        #     for i in range(len(nums)):
        #         if not flag:
        #             if mi > nums[i]:
        #                 mi = nums[i]
        #             if ma < nums[i]:
        #                 ma = nums[i]
        #             if i == len(nums)-1:
        #                 flag = True
        #             continue
        #         if mi < nums[i] < ma:
        #             return nums[i]
        # return -1
        #
        # Solution 2
        # if len(nums) < 3:
        #     return -1
        # mi, ma = min(nums), max(nums)
        # for i in range(len(nums)):
        #     if mi < nums[i] < ma:
        #         return nums[i]
        # return -1
        #
        # Solution 3
        if len(nums) <= 2:
            return -1
        min_num, max_num = min(nums), max(nums)
        for i in nums:
            if i != min_num and i != max_num:
                return i
        return -1

# For this exercise you will be strengthening your page-fu mastery. You will complete
# the PaginationHelper class, which is a utility class helpful for querying paging
# information related to an array.
# The class is designed to take in an array of values and an integer indicating how many items
# will be allowed per each page. The types of values contained within the collection/array are not relevant.
# The following are some examples of how this class is used:


class PaginationHelper:
    # The constructor takes in an array of items and an integer indicating
    # how many items fit within a single page
    def __init__(self, collection, items_per_page):
        self.collection = collection
        self.items_per_page = items_per_page

    # returns the number of items within the entire collection
    def item_count(self):
        return len(self.collection)

    # returns the number of pages
    def page_count(self):
        count = len(self.collection) % self.items_per_page
        delet = len(self.collection) // self.items_per_page
        delet = delet if count == 0 else delet + 1
        l, page = [], 0
        for i in range(0, len(self.collection), self.items_per_page):
            l.append([page, self.collection[i:i + self.items_per_page]])
            page += 1
        self.page_counts = l
        return len(self.page_counts)

    # returns the number of items on the given page. page_index is zero based
    # this method should return -1 for page_index values that are out of range
    def page_item_count(self, page_index):
        if (page_index + 1 > len(self.page_counts)) or page_index < 0:
            return -1
        return len(self.page_counts[page_index][1])

    # determines what page an item at the given index is on. Zero based indexes.
    # this method should return -1 for item_index values that are out of range
    def page_index(self, item_index):
        if (item_index < 0) or item_index + 1 > len(self.collection):
            return -1
        count, page = 0, 0
        for i in self.page_counts:
            count += len(i[1])
            if item_index + 1 <= count:
                return page
            page += 1

# 228. Summary Ranges
class Solution:
    def summaryRanges(self, nums: List[int]) -> List[str]:
        if len(nums) == 0:
            return []
        l, a, b, flag = [], -1, -1, False
        for i in range(len(nums)):
            if not flag:
                a, b = nums[i], nums[i]
            if i + 1 < len(nums):
                if nums[i+1] - nums[i] == 1:
                    b, flag = nums[i+1], True
                    continue
                flag = False
            l.append(str(a) if a == b else str(a) + '->' + str(b))
        return l

# A friend of mine takes the sequence of all numbers from 1 to n (where n > 0).
# Within that sequence, he chooses two numbers, a and b.
# He says that the product of a and b should be equal to the sum of all numbers in
# the sequence, excluding a and b.
# Given a number n, could you tell me the numbers he excluded from the sequence?
# The function takes the parameter: n (n is always strictly greater than 0) and returns an
# array or a string (depending on the language) of the form:
# [(a, b), ...] or [[a, b], ...] or {{a, b}, ...} or or [{a, b}, ...]
# with all (a, b) which are the possible removed numbers in the sequence 1 to n.
# [(a, b), ...] or [[a, b], ...] or {{a, b}, ...} or ... will be sorted in increasing order of the "a".
# It happens that there are several possible (a, b). The function returns an empty array (or an empty string)
# if no possible numbers are found which will prove that my friend has not told the
# truth! (Go: in this case return nil).
def removNb(n):
    s = n * (n + 1) / 2
    return [(i, (s - i) / (i + 1)) for i in range(1, n+1) if (s - i) % (i + 1) == 0 and 1 <= (s - i) / (i + 1) <= n]

# 682. Baseball Game
class Solution:
    def calPoints(self, operations: List[str]) -> int:
        l, top, step = [], -1, 0
        for i in range(len(operations)):
            if operations[i] == 'D':
                l.append(l[top-step]*2)
                top += 1
                continue
            if operations[i] == 'C':
                l.pop()
                step += 1
                continue
            if operations[i] == '+':
                l.append(l[top-step] + l[top-step-1])
                top += 1
                continue
            l.append(int(operations[i]))
            top += 1
        return sum(l)

# How can you tell an extrovert from an introvert at NSA?
# Va gur ryringbef, gur rkgebireg ybbxf ng gur BGURE thl'f fubrf.
#
# I found this joke on USENET, but the punchline is scrambled. Maybe you can decipher it?
# According to Wikipedia, ROT13 is frequently used to obfuscate jokes on USENET.
#
# For this task you're only supposed to substitute characters. Not spaces, punctuation, numbers, etc.
#
# Test examples:
def rot13(message):
    return message.translate(str.maketrans('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ',
                                          'nopqrstuvwxyzabcdefghijklmNOPQRSTUVWXYZABCDEFGHIJKLM'))

# 504. Base 7
class Solution:
    def convertToBase7(self, num: int) -> str:
        # import numpy
        # return numpy.base_repr(num, 7)
        n, resul = abs(num), ''
        while n:
            resul = str(n % 7) + resul
            n //= 7
        return '-' * (num < 0) + resul or '0'

# In this kata you have to correctly return who is the "survivor",
# ie: the last element of a Josephus permutation.
#
# Basically you have to assume that n people are put into a
# circle and that they are eliminated in steps of k elements, like this:
def josephus_survivor(n,k):
    i, j, n = 0, [], list(range(1, n+1))
    while len(n) > 0:
        i = (i + k - 1) % len(n)
        j = n.pop(i)
    return j

# 1773. Count Items Matching a Rule
class Solution:
    def countMatches(self, items: List[List[str]], ruleKey: str, ruleValue: str) -> int:
        count = 0
        d = {'type':0, 'color':1, 'name':2}
        for i in items:
            if i[d[ruleKey]] == ruleValue:
                count += 1
        return count

# Let's pretend your company just hired your friend from college and paid you a referral bonus.
# Awesome! To celebrate, you're taking your team out to the terrible dive
# bar next door and using the referral bonus to buy, and build, the largest
# three-dimensional beer can pyramid you can. And then probably drink those beers,
# because let's pretend it's Friday too.
#
# A beer can pyramid will square the number of cans in each level - 1 can in the top level,
# 4 in the second, 9 in the next, 16, 25...
#
# Complete the beeramid function to return the number of complete levels
# of a beer can pyramid you can make, given the parameters of:
#
# your referral bonus, and the price of a beer can
# For example:
# beeramid(1500, 2); // should === 12
# beeramid(5000, 3); // should === 16
# MATHEMATICSALGORITHMS
def beeramid(bonus, price):
    if bonus <= 0:
        return 0
    layers, beers_count, floors, top = 0, bonus // price, 1, 1
    while floors <= beers_count:
        beers_count -= floors
        layers += 1
        top += 1
        floors = top ** 2
    return layers

# 1704. Determine if String Halves Are Alike
class Solution:
    def halvesAreAlike(self, s: str) -> bool:
        a, b, top_a, top_b = s[:len(s)//2], s[len(s)//2:], 0, 0
        vowels = 'aeiouAEIOU'
        for i in range(len(a)):
            if a[i] in vowels:
                top_a += 1
            if b[i] in vowels:
                top_b += 1
        return top_a == top_b

# When working with color values it can sometimes be useful to extract the individual red,
# green, and blue (RGB) component values for a color. Implement a function that meets these requirements:
#
# Accepts a case-insensitive hexadecimal color string as its parameter (ex. "#FF9933" or "#ff9933")
# Returns a Map<String, int> with the structure {r: 255, g: 153, b: 51} where r, g, and b range from 0 through 255
# Note: your implementation does not need to support the shorthand form of hexadecimal notation (ie "#FFF")
def hex_string_to_RGB(hex_string):
    colors = [int(hex_string.lstrip('#')[i:i+2], 16) for i in (0, 2, 4)]
    return {'r':colors[0], 'g':colors[1], 'b':colors[2]}

# Complete the function/method so that it takes a PascalCase string and returns the string in snake_case notation.
# Lowercase characters can be numbers. If the method gets a number as input, it should return a string.
def to_underscore(string):
    if type(string) == int:
        return str(string)
    l, word, flag = [], '', False
    for i in string:
        if i.isupper():
            if not flag:
                flag = True
                word += i
                continue
            l.append(word)
            flag, word = True, i
            continue
        word += i
    l.append(word)
    return '_'.join(i.lower() for i in l)

# 2303. Calculate Amount Paid in Taxes
class Solution:
    def calculateTax(self, brackets: List[List[int]], income: int) -> float:
        if income == 0:
            return 0
        if len(brackets) == 1:
            return income * (brackets[0][1] * 0.01)
        if brackets[0][0] >= income:
            return income * (brackets[0][1] * 0.01)
        count, flag = 0, False
        count += brackets[0][0] * (brackets[0][1] * 0.01)
        income -= brackets[0][0]
        for i in range(1, len(brackets)):
            if brackets[i][0] - brackets[i-1][0] <= income:
                income -= brackets[i][0] - brackets[i-1][0]
                count += (brackets[i][0] - brackets[i-1][0]) * (brackets[i][1] * 0.01)
                continue
            count += income * (brackets[i][1] * 0.01)
            break
        return count
    
# ISBN-10 identifiers are ten digits long. The first nine characters are digits 0-9.
# The last digit can be 0-9 or X, to indicate a value of 10.
#
# An ISBN-10 number is valid if the sum of the digits multiplied by their position modulo 11 equals zero.
#
# For example:
#
# ISBN     : 1 1 1 2 2 2 3 3 3  9
# position : 1 2 3 4 5 6 7 8 9 10
# This is a valid ISBN, because:
#
# (1*1 + 1*2 + 1*3 + 2*4 + 2*5 + 2*6 + 3*7 + 3*8 + 3*9 + 9*10) % 11 = 0
# Examples
# 1112223339   -->  true
# 111222333    -->  false
# 1112223339X  -->  false
# 1234554321   -->  true
# 1234512345   -->  false
# 048665088X   -->  true
# X123456788   -->  false
# REGULAR EXPRESSIONSALGORITHMS
def valid_ISBN10(isbn):
    if len(isbn) != 10:
        return False
    try:
        if isbn.endswith('X'):
            return (sum(int(isbn[i]) * (i+1) for i in range(len(isbn)-1)) + 10*10) % 11 == 0
        return sum(int(isbn[i]) * (i+1) for i in range(len(isbn))) % 11 == 0
    except:
        return False
    
# Write a method that takes a number and returns a string of that number in English.
#
# Your method should be able to handle any number between 0 and 99999. If the given number is outside of that range or not an integer, the method should return an empty string.
#
# Examples
# 0      -->  "zero"
# 27     -->  "twenty seven"
# 100    -->  "one hundred"
# 7012   -->  "seven thousand twelve"
# 99205  -->  "ninety nine thousand two hundred five"
# STRINGSPARSINGALGORITHMS
def number_to_english(n):
    d={0: 'zero', 1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five', 6: 'six', 7: 'seven', 8: 'eight', 9: 'nine', 10: 'ten', 11: 'eleven', 12: 'twelve', 13: 'thirteen', 14: 'fourteen', 15: 'fifteen', 16: 'sixteen', 17: 'seventeen', 18: 'eighteen', 19: 'nineteen', 20: 'twenty', 30:'thirty', 40: 'forty', 50: 'fifty', 60: 'sixty', 70: 'seventy', 80: 'eighty', 90: 'ninety', 100: 'one hundred', 1000: 'one thousand'}
    if n<0 or n>99999 or type(n)==float: return ''
    elif n<=20 or n in (20,30,40,50,60,70,80,90,100,1000): return d[n]
    elif 20<=n<100:
        a = int(str(n)[0])
        return f'{number_to_english(a*10)} {number_to_english(n%10)}'
    elif 100<n<1000:
        if n%100==0:
            return f'{number_to_english(n//100)} hundred'
        return f'{number_to_english(n//100)} hundred {number_to_english(n%100)}'
    elif 1000<n<=99999:
        if n%1000==0:
            return f'{number_to_english(n//1000)} thousand'
        return f'{number_to_english(n//1000)} thousand {number_to_english(n%1000)}'

# 1446. Consecutive Characters
class Solution:
    def maxPower(self, s: str) -> int:
        if len(s) == 1:
            return 1
        w, count, flag = s[0], 0, False
        for i in range(1, len(s)):
            if s[i] == w[0]:
                w += s[i]
                flag = True
                continue
            if len(w) > count:
                count = len(w)
            w, flag = s[i], False
        if flag:
            count = len(w) if len(w) > count else count
        return count

# Computing the complex logarithm function
from cmath import log as clog
def log(real, imag):
    try:
        lg = clog(complex(real, imag))
        return lg.real, lg.imag
    except:
        pass
     Count of Matches in Tournament
class Solution:
    def numberOfMatches(self, n: int) -> int:
        count = 0
        while n != 1:
            if n % 2 == 0:
                n = n / 2
                count += n
                continue
            n = (n - 1) / 2
            count += n + 1
        return int(count)

# 441. Arranging Coins
class Solution:
    def arrangeCoins(self, n: int) -> int:
        count = 0
        while n > 0:
            count += 1
            n -= count
        return count if n == 0 else count - 1

# # You're going to provide a needy programmer a utility method that generates an infinite amount of sequential fibonacci numbers.
# #
# # to do this write a 'generator' starting with 1
# #
# # A fibonacci sequence starts with two 1s. Every element afterwards is the sum of the two previous elements. See:
# #
# # 1, 1, 2, 3, 5, 8, 13, ..., 89, 144, 233, 377, ...
# # ALGORITHMS
def all_fibonacci_numbers():
    a, b = 0, 1
    for i in range(10000):
        yield b
        a, b = b, a + b

# 496. Next Greater Element I
class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        def find_max(n, arr):
            for i in range(len(arr)):
                if arr[i] > n:
                    return arr[i]
            return -1
        l = [0] * len(nums1)
        for i in range(len(nums1)):
            if nums2.index(nums1[i]) == len(nums2) - 1:
                l[i] = -1
                continue
            point = nums2.index(nums1[i])
            l[i] = find_max(nums2[point], nums2[point:])
        return l

# Simple Fun #81: Digits Product
import math
def digits_product(product):
    j = 10
    l = math.prod([int(i) for i in str(j)])
    while j < 9999:
        if l == product:
            return j
        j += 1
        l = math.prod([int(i) for i in str(j)])
    return -1

# 342. Power of Four
class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        i = 0
        while 4 ** i <= n:
            if 4 ** i == n:
                return True
            i += 1
        return False

# John and Ann sign up for Codewars
def john_ann(n):
    john, ann = [0], [1]
    for i in range(1, n):
        john.append(i - ann[john[i - 1]])
        ann.append(i - john[ann[i - 1]])
    return john, ann

def john(n):
    return john_ann(n)[0]

def ann(n):
    return john_ann(n)[1]

def sum_john(n):
    return sum(john(n))

def sum_ann(n):
    return sum(ann(n))

# 459. Repeated Substring Pattern
class Solution:
    def repeatedSubstringPattern(self, s: str) -> bool:
        # Solution 1
        return s in s[1:] + s[:-1]
        # Solution 2
        l = len(s)
        j = l
        for i in range(l // 2):
            while len(s[:i+1] * j) >= l:
                j -= 1
            if s[:i+1] * (j+1) == s:
                return True
        return False
        # Solution 3
        def kmp_table(W):
            n = len(W)
            T = [0 for _ in range(n)]
            T[0] = -1
            pos = 0
            for i in range(1, n):
                if W[i] == W[pos]:
                    T[i] = T[pos]
                else:
                    T[i] = pos
                    pos = T[pos]
                    while pos >= 0 and W[i] != W[pos]:
                        pos = T[pos]
                pos += 1
            return T
        string, substring = s[1:] + s[:-1], s
        m = len(substring)
        n = len(string)
        T = kmp_table(substring)
        pos = 0
        i = 0
        while i < n:
            if string[i] != substring[pos]:
                pos = T[pos]
                if pos < 0:
                    pos += 1
                    i += 1
            else:
                i += 1
                pos += 1
                if pos == m:
                    return True
        return False

# Elementary Arithmetic - Carries Count
def solve(input_string):
    l, count, out, flag = input_string.split('\n'), 0, [], False
    for i in l:
        a, b = i.split()
        for j in range(len(a)-1, -1, -1):
            s = int(a[j]) + int(b[j])
            if flag:
                s += 1
                flag = False
            if s > 9:
                flag = True
                count += 1
        out.append(f"{count} carry operations" if count else "No carry operation")
        count, flag = 0, False
    return '\n'.join(out)

# 225. Implement Stack using Queues
class MyStack:

    def __init__(self):
        self.l = []

    def push(self, x: int) -> None:
        self.l.append(x)

    def pop(self) -> int:
        return self.l.pop()

    def top(self) -> int:
        return self.l[-1]

    def empty(self) -> bool:
        return len(self.l) == 0


# Your MyStack object will be instantiated and called as such:
# obj = MyStack()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.top()
# param_4 = obj.empty()

# int32 to IPv4
from ipaddress import IPv4Address
def int32_to_ip(int32):
    return str(IPv4Address(int32))

# 367. Valid Perfect Square
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        l, r = 1, num
        while l <= r:
            mid = (l + r) // 2
            if mid * mid == num:
                return mid
            if mid * mid > num:
                r = mid - 1
            if mid * mid < num:
                l = mid + 1
        return False
        # Solution 2
        # i = 1
        # while i*i < num:
        #     i += 1
        # return i*i == num
    
# First Variation on Caesar Cipher
from math import ceil
from string import ascii_lowercase as al_l, ascii_uppercase as al_u
def moving_shift(s, shift):
    l, w = [], ''
    for i in range(len(s)):
        if s[i].isupper():
            if s[i] not in al_u:
                w += s[i]
                continue
            w += al_u[(al_u.index(s[i]) + i * 1 + shift) % len(al_u)]
            continue
        if s[i].islower():
            if s[i] not in al_l:
                w += s[i]
                continue
            w += al_l[(al_l.index(s[i]) + i * 1 + shift) % len(al_l)]
            continue
        w += s[i]
    count = int(ceil(len(w) / 5))
    for i in range(0, 5 * count, count):
        l.append(w[i:i + count])
    return l
def demoving_shift(s, shift):
    w, out = ''.join(s), ''
    for i in range(len(w)):
        if w[i].isupper():
            if w[i] not in al_u:
                out += w[i]
                continue
            out += al_u[(al_u.index(w[i]) + i * -1 - shift) % len(al_u)]
            continue
        if w[i].islower():
            if w[i] not in al_l:
                out += w[i]
                continue
            out += al_l[(al_l.index(w[i]) + i * -1 - shift) % len(al_l)]
            continue
        out += w[i]
    return out

# 2500. Delete Greatest Value in Each Row
class Solution:
    def deleteGreatestValue(self, grid: List[List[int]]) -> int:
        for i in range(len(grid)):
            grid[i].sort()
        grid = list(zip(*grid))
        return sum(max(i) for i in grid)
        # Solution 2
        # count = 0
        # while len(grid[-1]) > 0:
        #     top = 0
        #     for i in grid:
        #         el = max(i)
        #         if el > top:
        #             top = el
        #         i.remove(el)
        #     count += top
        # return count

# Base64 Encoding
 from base64 import b64encode, b64decode


def to_base_64(string):
    return b64encode(string.encode('ascii')).decode('ascii').replace('=', '')


def from_base_64(string):
    try:
        return b64decode((string + '=').encode('ascii'), '-_').decode('ascii')
    except:
        return b64decode((string + '==').encode('ascii'), '-_').decode('ascii')

# 232. Implement Queue using Stacks
class MyQueue:

    def __init__(self):
        self.l = []
        self.l2 = []

    def push(self, x: int) -> None:
        self.l.append(x)

    def pop(self) -> int:
        self.peek()
        return self.l2.pop()

    def peek(self) -> int:
        if not self.l2:
            while self.l:
                self.l2.append(self.l.pop())
        return self.l2[-1]

    def empty(self) -> bool:
        return not self.l and not self.l2
# Solution 2
# class MyQueue:
#
#     def __init__(self):
#         self.l = []
#
#     def push(self, x: int) -> None:
#         self.l.append(x)
#
#     def pop(self) -> int:
#         return self.l.pop(0)
#
#     def peek(self) -> int:
#         return self.l[0]
#
#     def empty(self) -> bool:
#         return len(self.l) == 0
# Your MyQueue object will be instantiated and called as such:
# obj = MyQueue()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.peek()
# param_4 = obj.empty()

# Did you mean ...?
class Dictionary:
    def __init__(self,words):
        self.words=words
    def find_most_similar(self,term):
        return self.words[sorted((self.levenstein(term, v), k) for k, v in enumerate(self.words))[0][1]]
    def levenstein(self, str_1, str_2):
        n, m = len(str_1), len(str_2)
        if n > m:
            str_1, str_2 = str_2, str_1
            n, m = m, n
        current_row = range(n + 1)
        for i in range(1, m + 1):
            previous_row, current_row = current_row, [i] + [0] * n
            for j in range(1, n + 1):
                add, delete, change = previous_row[j] + 1, current_row[j - 1] + 1, previous_row[j - 1]
                if str_1[j - 1] != str_2[i - 1]:
                    change += 1
                current_row[j] = min(add, delete, change)
        return current_row[n]

# 771. Jewels and Stones
class Solution:
    def numJewelsInStones(self, jewels: str, stones: str) -> int:
        count = 0
        for i in range(len(jewels)):
            for j in range(len(stones)):
                if jewels[i] == stones[j]:
                    count += 1
        return count
    
# Caesar Cipher Helper
class CaesarCipher(object):
    def __init__(self, shift):
        self.shift = shift
        self.al = 'ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ'

    def encode(self, st):
        return ''.join(self.al[self.al.index(i) + self.shift] if i in self.al else i for i in st.upper())

    def decode(self, st):
        return ''.join(self.al[self.al.index(i, 1) - self.shift] if i in self.al else i for i in st.upper())

# 1389. Create Target Array in the Given Order
class Solution:
    def createTargetArray(self, nums: List[int], index: List[int]) -> List[int]:
        l = []
        for i in range(len(nums)):
            l.insert(index[i], nums[i])
        return l

# Lazy Repeater
 from itertools import cycle
def make_looper(string):
    x = cycle(string)
    return lambda: next(x)

# 1720. Decode XORed Array
class Solution:
    def decode(self, encoded: List[int], first: int) -> List[int]:
        l = [first]
        for i in encoded:
            l.append(l[-1] ^ i)
        return l

# Airport Arrivals/Departures - #1
def flap_display(lines, rotors):
    word, steps, out = '', [], []
    al = ALPHABET + ALPHABET
    for i in rotors:
        top = []
        for j in range(len(i) + 1):
            top.append(sum(i[:j + 1]))
        steps.append(top)
    for j in range(len(lines)):
        for i in range(len(lines[j])):
            if steps[j][i] > len(ALPHABET):
                steps[j][i] = steps[j][i] % len(ALPHABET)
            word += al[al.index(lines[j][i]) + steps[j][i]]
        out.append(word)
        word = ''
    return out

# 1816. Truncate Sentence
class Solution:
    def truncateSentence(self, s: str, k: int) -> str:
        return ' '.join(s.split()[:k])

# The Clockwise Spiral
def create_spiral(n):
    if not isinstance(n, int) or n < 1:
        return []
    l = [None] * n
    for i in range(n):
        l[i] = [None] * n
    x, y, dx, dy = 0, 0, 1, 0
    for i in range(n*n):
        l[y][x] = i+1
        test = x + dx if dx else y + dy
        if test < 0 or test == n or l[y + dy][x + dx] != None:
            dx, dy = -dy, dx
        x += dx
        y += dy
    return l

# 1684. Count the Number of Consistent Strings
# Solution 1
class Solution:
    def countConsistentStrings(self, allowed: str, words: List[str]) -> int:
        count = len(words)
        for i in words:
            for j in i:
                if j not in allowed:
                    count -= 1
                    break
        return count
# Runtime 237 ms - Beats 99.23%, Memory 18.3 MB - Beats 68.86%
# Solution 2 using set
class Solution:
    def countConsistentStrings(self, allowed: str, words: List[str]) -> int:
        count, allowed = len(words), set(allowed)
        for i in words:
            for j in i:
                if j not in allowed:
                    count -= 1
                    break
        return count
# Runtime 248 ms - Beats 91.64%, Memory 18.3 MB - Beats 95.47%

# Help your granny!
from math import sqrt
def tour(friends, friend_towns, distTable1):
    a, count, true_fr = lambda c, b: sqrt(c**2 - b**2), 0, []
    for i in friend_towns:
        if i[0] in friends:
            true_fr.append(i)
    for b,c in zip(true_fr, true_fr[1:]):
        count += a(distTable1[c[1]], distTable1[b[1]])
    return int(count + distTable1[true_fr[0][1]] + distTable1[true_fr[-1][1]])

# 859. Buddy Strings
class Solution:
    def buddyStrings(self, s: str, goal: str) -> bool:
        if len(s) != len(goal):
            return False
        if s == goal and len(set(s)) < len(s):
            return True
        count = []
        for i in range(len(s)):
            if s[i] != goal[i]:
                count.append([s[i], goal[i]])
        if len(count) == 2 and count[0] == count[-1][::-1]:
            return True
        return False
    
# Guess The Gifts!
def guess_gifts(wishlist, presents):
    gift = []
    for i in presents:
        for j in range(len(wishlist)):
            count = 0
            for k,v in i.items():
                if wishlist[j][k] == v:
                    count += 1
            if count == 3:
                if wishlist[j]['name'] not in gift:
                    gift.append(wishlist[j]['name'])
    return gift

# 941. Valid Mountain Array
class Solution:
    def validMountainArray(self, arr: List[int]) -> bool:
        if len(arr) < 3:
            return False
        start, flag, top = False, False, arr[0]
        for i in range(1, len(arr)):
            if top < arr[i] and not flag:
                start, top = True, arr[i]
                continue
            if top > arr[i] and start:
                flag, top = True, arr[i]
                continue
            return False
        return start and flag

# Don't Drink the Water
def separate_liquids(glass):
    if len(glass) < 1:
        return []
    length = max(len(i) for i in glass)
    l, out = [], []
    liq = ['O', 'A', 'W', 'H']
    for liq_ in liq:
        for row in glass:
            for li in row:
                if li == liq_:
                    out.append(li)
        if len(out) == length:
            l.append(out)
            out = []
        if len(out) > length:
            l.append(out[:length])
            out = out[length:]
    while out:
        if len(out) >= length:
            l.append(out[:length])
            out = out[length:]
            continue
        l.append(out)
    return l

# 290. Word Pattern
class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        s = s.split()
        return (len(set(pattern)) == len(set(s)) == len(set(zip_longest(pattern,s))))

# Diophantine Equation
import math
def sol_equa(n):
    l = []
    for i in range(1, int(math.sqrt(n)) + 1):
        if n % i == 0:
            j = n // i
            if (i + j) % 2 == 0 and (j - i) % 4 == 0:
                l.append([(i + j) // 2, (j - i) // 4])
    return l

# 1784. Check if Binary String Has at Most One Segment of Ones
class Solution:
    def checkOnesSegment(self, s):
        return not s.strip('0').strip('1')

# Luck check
 def luck_check(string):
    if not all(i.isdigit() for i in string) or len(string) == 0:
        return Error
    step, flag = len(string) // 2, False if len(string) % 2 == 0 else True
    return sum(int(i) for i in string[:step]) == sum(int(i) for i in string[(step if not flag else step+1):])

# 2652. Sum Multiples
class Solution:
    def sumOfMultiples(self, n: int) -> int:
        count = 0
        for i in range(3, n+1):
            if i % 3 == 0 or i % 5 == 0 or i % 7 == 0:
                count += i
        return count
# Runtime 102ms Beats 45.93% - Memory 16.2 MB Beats 63.46%
class Solution:
    def sumOfMultiples(self, n: int) -> int:
        a, b, c, d, e, f, g = n // 3, n // 5, n // 7, n // 15, n // 21, n // 35, n // 105

        return (
                3 * a * (a + 1)  #
                + 5 * b * (b + 1)  # <-- three venn circles
                + 7 * c * (c + 1)  #

                - 15 * d * (d + 1)  #
                - 21 * e * (e + 1)  # <-- three venn lunes
                - 35 * f * (f + 1)  #

                + 105 * g * (g + 1)  # <-- one venn circular triangle
        ) // 2
# Runtime 43ms Beats 99.39% - Memory 16.3 MB Beats 63.46%

# Meta-Kata: Duplicate Detector v0.1
from collections import Counter
def dupe_detect(functions):
    l = [tuple(map(f, range(256))) for f in functions]
    lr = [tup for tup, v in Counter(l).items() if v>1]
    return [[i for i, t in enumerate(l) if t==f] for f in lr]

# 2057. Smallest Index With Equal Value
class Solution:
    def smallestEqual(self, nums: List[int]) -> int:
        for i in range(len(nums)):
            if i < 10:
                if i == nums[i]:
                    return i
            if i % 10 == nums[i]:
                return i
        return -1
# Runtime 96 ms Beats 67.97% - Memory 16.3 MB Beats 69.38%
class Solution:
    def smallestEqual(self, nums: List[int], i=0) -> int:
        return -1 if i == len(nums) else (i if i % 10 == nums[i] else self.smallestEqual(nums, i+1))
# Runtime 91 ms Beats 87.50% - Memory 16.4 MB Beats 29.22%

# Tongues
import string
def tongues(code):
    return code.translate(str.maketrans('aiyeouAIYEOUbkxznhdcwgpvjqtsrlmfBKXZNHDCWGPVJQTSRLMF', 'eouaiyEOUAIYpvjqtsrlmfbkxznhdcwgPVJQTSRLMFBKXZNHDCWG'))

# 1961. Check If String Is a Prefix of Array
class Solution:
    def isPrefixString(self, s: str, words: List[str]) -> bool:
        word = ''
        for i in range(0, len(words)):
            word += words[i]
            if s == word:
                return True
        return False

# Simple RSA Implementation
class RSA:
    import math
    def __init__(self, p, q, e):
        self.p = p
        self.q = q
        self.e = e
        self.n = p * q
        self.phi_n = (p - 1) * (q - 1)

    def encrypt(self, m):
        return m ** self.e % self.n

    def decrypt(self, c):
        d = pow(self.e, -1, self.phi_n)
        return pow(c, d, self.n)
    
# 111. Minimum Depth of Binary Tree
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def minDepth(self, root: Optional[TreeNode]) -> int:
        if root is None:
            return 0
        l = self.minDepth(root.left)
        r = self.minDepth(root.right)
        if root.left is None:
            return 1 + r
        if root.right is None:
            return 1 + l
        return min(l, r) + 1

# LET ME IN!
from itertools import count
def get_in_line(l):
    l.sort(key=lambda x: x if 0 < x < 3 else 3)
    for n in count(1):
        x = l.pop(0)
        if x == 0:
            return n
        elif x == 1:
            for i in range(len(l)//2):
                j = len(l) - 1 - i
                if l[i] not in (1,3) and l[j] not in (1,3):
                    l[i], l[j] = l[j], l[i]

# 1668. Maximum Repeating Substring
class Solution:
    def maxRepeating(self, sequence: str, word: str) -> int:
        if word not in sequence:
            return 0
        count, total = 0, ''
        while total in sequence:
            total += word
            count += 1
        return count - 1

# Missing number in Unordered Arithmetic Progression
def find(seq):
    mi, ma, result = seq[0], seq[0], seq[0]
    for i in range(1, len(seq)):
        mi, ma, result = min(mi, seq[i]), max(ma, seq[i]), result ^ seq[i]
    if mi == ma:
        return mi
    differens = (ma - mi) // len(seq)
    while mi <= ma:
        result = result ^ mi
        mi += differens
    return result
# Solution 2
def find(seq):
  return (min(seq)+max(seq))*(len(seq)+1)/2-sum(seq)

# The area between the vertex of the parabola and x-axis
def area(a, b, c):
    d = b**2 - 4 * a * c
    if d <= 0:
        return 0
    # calculate x1 and x2
    x1, x2 = (-b + d**.5) / (2 * a), (-b - d**.5) / (2 * a)
    # calculate integral by formula: ∫[a, b] f(x) dx >= ∫(((a/3)(x)^3 + (b/2)(x)^2 + c*(x)))dx
    return abs(((a/3) * (x1)**3 + (b/2) * (x1)**2 + c * (x1)) - ((a/3) * (x2)**3 + (b/2) * (x2)**2 + c * (x2)))

# 34. Find First and Last Position of Element in Sorted Array
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        if len(nums) == 0:
            return [-1, -1]
        pos, left, right = [-1, -1], 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                pos[0], right = mid, mid - 1
            if nums[mid] < target:
                left = mid + 1
            if nums[mid] > target:
                right = mid - 1
        if pos[0] == -1:
            return pos
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                pos[1], left = mid, mid + 1
            if nums[mid] < target:
                left = mid + 1
            if nums[mid] > target:
                right = mid - 1
        return pos

# Aerial Firefighting
from math import ceil
def waterbombs(fire, w):
    return sum(ceil(len(i) / w) for i in fire.split('Y'))

# 643. Maximum Average Subarray I
class Solution:
    def findMaxAverage(self, nums: List[int], k: int) -> float:
        top = res = sum(nums[:k])
        for i in range(len(nums)-k):
            top += nums[i+k] - nums[i]
            res = max(top, res)
        return res / k

# Easy Diagonal
def diagonal(n, p):
    su, com = 0, 1
    for k in range(0, n - p + 1):
        su +=com
        com = (com * (p + k + 1 )) // (k + 1)
    return su

# 2540. Minimum Common Value
class Solution:
    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:
        r,l = 0, 0
        while True:
            if l >= len(nums1) or r >= len(nums2):
                break
            print(l, r)
            if nums1[l] == nums2[r]:
                return nums1[l]
            if nums1[l] < nums2[r]:
                l += 1
                continue
            if nums1[l] > nums2[r]:
                r += 1
        return -1
    
# Coding Meetup #5 - Higher-Order Functions Series - Prepare the count of languages
from collections import Counter
def count_languages(lst):
    return Counter(i['language'] for i in lst)

# 278. First Bad Version
# The isBadVersion API is already defined for you.
# def isBadVersion(version: int) -> bool:

class Solution:
    def firstBadVersion(self, n: int) -> int:
        l, r = 1, n
        while l < r:
            mid = (l + r) // 2
            if isBadVersion(mid):
                r = mid
            else:
                l = mid + 1
        return l

# Remove consecutive duplicate words
def remove_consecutive_duplicates(s):
    if not s:
        return ''
    s= s.split()
    w = [s[0]]
    for i in range(1, len(s)):
        if s[i-1] != s[i]:
            w.append(s[i])
    return ' '.join(w)

# Volume of a cup
import math
def cup_volume(d1, d2, h):
    Rv, Rd = d1 / 2, d2 / 2
    return round((1/3) * math.pi * h * (Rv**2 + Rv * Rd + Rd**2), 2)

# 860. Lemonade Change
# My solution
class Solution:
    def lemonadeChange(self, bills: List[int]) -> bool:
        if bills[0] != 5:
            return False
        cash = [bills[0]]
        for i in range(1, len(bills)):
            if bills[i] == 5:
                cash.append(5)
                continue
            if bills[i] == 10:
                if min(cash) != 5:
                    return False
                cash.remove(5)
                cash.append(10)
                continue
            if bills[i] == 20:
                if 10 in cash:
                    if 5 not in cash:
                        return False
                    cash.remove(10)
                    cash.remove(5)
                    cash.append(20)
                    continue
                if cash.count(5) < 3:
                    return False
                cash.remove(5)
                cash.remove(5)
                cash.remove(5)
                cash.append(20)
        return True

# Second solution
        five, ten = 0, 0
        for i in range(len(bills)):
            if bills[i] == 5:
                five += 1
            elif bills[i] == 10:
                five, ten = five - 1, ten + 1
            elif ten > 0:
                five, ten = five - 1, ten - 1
            else:
                five -= 3
            if five < 0:
                return False
        return True
    
# 746. Min Cost Climbing Stairs
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        l = [cost[0]] + [0] * (len(cost) - 1)
        if len(l) >= 2:
            l[1] = cost[1]
        for i in range(2, len(cost)):
            l[i] = cost[i] + min(l[i-1], l[i - 2])
        return min(l[-1], l[-2])
    
# Find the smallest
def smallest(n):
    n, l = str(n), [n, 0, 0]
    for i in range(len(n)):
        top, copy = (int(n), -1), n[:i] + n[i+1:]
        for j in range(len(copy) + 1):
            sec = int(copy[:j] + n[i] + copy[j:])
            if top[0] > sec:
                top = (sec, j)
        l = [top[0], i, top[1]] if l[0] > top[0] else l
    return l

# 33. Search in Rotated Sorted Array
# My solution with flag
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right, flag = 0, len(nums) - 1, True
        while left <= right:
            mid = (left + right) // 2
            flag = nums[left] <= nums[mid]
            if flag:
                if nums[left] <= target <= nums[mid]:
                    if nums[mid] == target:
                        return mid
                    if nums[mid] > target:
                        right = mid - 1
                    else:
                        left = mid + 1
                else:
                    left = mid + 1
            else:
                if nums[mid] <= target <= nums[right]:
                    if nums[mid] == target:
                        return mid
                    if nums[mid] > target:
                        right = mid - 1
                    else:
                        left = mid + 1
                else:
                    right = mid - 1
        return -1

# Classic binary search
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return mid
            if nums[mid] < nums[right]:
                if nums[mid] < target <= nums[right]:
                    left = mid + 1
                else:
                    right = mid - 1
            else:
                if nums[left] <= target < nums[mid]:
                    right = mid - 1
                else:
                    left = mid + 1
        return -1

# Diagonals sum
def sum_diagonals(matrix):
    if not matrix[0]:
        return 0
    total, step = 0, 0
    for i in matrix:
        total += i[step] + i[-step + -1]
        step += 1
    return total

# 292. Nim Game
class Solution:
    def canWinNim(self, n: int) -> bool:
        return n % 4 != 0

# Turn any word into a beef taco
def tacofy(word):
    l = []
    d = {'t':'tomato','l':'lettuce','c':'cheese','g':'guacamole','s':'salsa'}
    for i in word:
        if i.lower() in 'aeoiu':
            l.append('beef')
        if i.lower() in d:
            l.append(d[i.lower()])
    return ['shell'] + l + ['shell']

# 747. Largest Number At Least Twice of Others
class Solution:
    def dominantIndex(self, nums: List[int]) -> int:
        hi, hi_i = max(nums), 0
        for i in range(len(nums)):
            if nums[i] == hi:
                hi_i = i
            if nums[i] != hi and nums[i] * 2 > hi:
                return -1
        return hi_i

# Minimum Perimeter of a Rectangle
def minimum_perimeter(area):
    i = int(area ** .5)
    while area % i:
        i -= 1
    return 2 * i + 2 * (area // i)

# 819. Most Common Word
class Solution:
    def mostCommonWord(self, letters: str, ban: List[str]) -> str:
        d, word = {}, ''
        for i in letters.lower():
            if not i.isalpha():
                if word and word not in ban:
                    if word not in d:
                        d[word] = 0
                    d[word] += 1
                word = ''
            else:
                word += i
        if word and word not in ban:
            if word not in d:
                d[word] = 0
            d[word] += 1
        return sorted(d.items(), key=lambda x: -x[1])[0][0]

# Building Spheres
class Sphere(object):
    def __init__(self, radius, mass):
        self.rad = radius
        self.mass = mass
    def get_radius(self):
        return self.rad
    def get_mass(self):
        return self.mass
    def get_volume(self):
        import math
        return round((4 / 3) * math.pi * self.rad**3, 5)
    def get_surface_area(self):
        import math
        return round(4 * math.pi * self.rad**2, 5)
    def get_density(self):
        return round(self.mass / self.get_volume(), 5)

# Two numbers are positive
def two_are_positive(*args):
    return sum(i > 0 for i in args) == 2

# 657. Robot Return to Origin
class Solution:
    def judgeCircle(self, moves: str) -> bool:
        l, u = 0, 0
        for i in moves:
            if i == 'U':
                u += 1
            if i == 'D':
                u -= 1
            if i == 'L':
                l += 1
            if i == 'R':
                l -= 1
        return u == 0 and l == 0
    
# 2788. Split Strings by Separator
class Solution:
    def splitWordsBySeparator(self, words: List[str], separator: str) -> List[str]:
        l = []
        for i in words:
            for j in i.split(separator):
                if j:
                    l.append(j)
        return l

# What's a Perfect Power anyway?
def isPP(n):
    for i in range(2, n):
        for j in range(2, n):
            if i ** j > n:
                break
            if i ** j == n:
                return [i, j]

# "Center yourself", says the monk.
def center(strng, width, fill=' '):
    if len(strng) > width:
        return strng
    if (width - len(strng)) % 2 == 0:
        cop = fill * ((width - len(strng)) // 2) + strng
    else:
        cop = fill * ((width - len(strng)) // 2 + 1) + strng
    return cop + fill * (width - len(cop))

# 50. Pow(x, n)
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if n == 0:
            return 1
        if n < 0:
            x = 1 / x
            n *= -1
        if n % 2 != 0:
            return x * self.myPow(x, n - 1)
        else:
            temp = self.myPow(x, n/2)
            return temp * temp

# 852. Peak Index in a Mountain Array
class Solution:
    def peakIndexInMountainArray(self, arr: List[int]) -> int:
        l, r = 0, len(arr) - 1
        while l < r:
            mid = (l + r) // 2
            if arr[mid] > arr[mid + 1]:
                r = mid
            else:
                l = mid + 1
        return l

# Tram Capacity
def tram(stops, d, o):
    top = o[0] - d[0]
    max = top
    for i in range(1, stops):
        top -= d[i]
        top += o[i]
        if top > max:
            max = top
    return max

# 1870. Minimum Speed to Arrive on Time
class Solution:
    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:
        def mintime(speed, dist, hour):
            import math
            top = 0
            for i in range(len(dist)-1):
                top += math.ceil(dist[i]/speed)
            top += dist[-1] / speed
            return top <= hour
        l, r, m = 1, 10 ** 7, -1
        while l <= r:
            mid = (l + r) // 2
            if mintime(mid, dist, hour):
                m = mid
                r = mid - 1
            else:
                l = mid + 1
        return m

# Valid Braces
def valid_braces(string):
    d = {')': '(', ']': '[', '}': '{'}
    stack = []
    for i in string:
        if i not in d:
            stack.append(i)
        else:
            if not stack:
                return False
            if stack[-1] != d[i]:
                return False
            stack.pop()
    return not stack

# 263. Ugly Number
class Solution:
    def isUgly(self, n: int) -> bool:
        if n <= 0:
            return False
        while n % 2 == 0:
            n //= 2
        while n % 3 == 0:
            n //= 3
        while n % 5 == 0:
            n //= 5
        return n == 1

# Keep the Order
def keep_order(ary, val):
    l, r = 0, len(ary) - 1
    while l <= r:
        mid = l + (r - l) // 2
        if ary[mid] >= val:
            r = mid - 1
        else:
            l = mid + 1
    return l

# 1002. Find Common Characters
class Solution:
    def commonChars(self, words: List[str]) -> List[str]:
        l = []
        for i in set(words[0]):
            if all(i in j for j in words):
                c = min(j.count(i) for j in words)
                l += [i] * c
        return l

# Tic-Tac-Toe Checker
def is_solved(board):
    moves = [board[0], board[1], board[2], [i[0] for i in board],
            [i[1] for i in board], [i[2] for i in board],
            [board[i][i] for i in range(len(board))],
             [board[i][-(i + 1)] for i in range(len(board))]
            ]
    if any(i.count(1) == 3 for i in moves):
        return 1
    if any(i.count(2) == 3 for i in moves):
        return 2
    if all(i.count(0) == 0 for i in moves):
        return 0
    else:
        return -1
    
# 2562. Find the Array Concatenation Value
class Solution:
    def findTheArrayConcVal(self, nums: List[int]) -> int:
        stack = 0
        while len(nums) > 1:
            stack += int(str(nums.pop(0)) + str(nums.pop(-1)))
        if len(nums) == 1:
            stack += nums[0]
        return stack

# 808. Soup Servings
class Solution:
    def soupServings(self, n: int) -> float:
        if n > 4800:
            return 1
        n = (n + 24) // 25
        d = {}
        def dyn_prog(x, y):
            if (x, y) in d:
                return d[(x,y)]
            if x <= 0 and y <= 0:
                return 0.5
            if x <= 0:
                return 1
            if y <= 0:
                return 0
            d[(x, y)] = 0.25 * (dyn_prog(x-4, y) + dyn_prog(x-3, y-1) + dyn_prog(x-2, y-2) + dyn_prog(x-1, y-3))
            return d[(x,y)]
        return dyn_prog(n, n)

# Binary sXORe
 def sxore(n):
    return [n, 1, n + 1, 0][n % 4]

# 598. Range Addition II
class Solution:
    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:
        min_row, min_col = m, n
        for i in range(len(ops)):
            min_row = min(min_row, ops[i][0])
            min_col = min(min_col, ops[i][1])
        return min_row * min_col

# Binary scORe
 def score(n):
    return 2 ** n.bit_length() - 1

# 191. Number of 1 Bits
class Solution:
    def hammingWeight(self, n: int) -> int:
        c = 0
        while n:
            c += 1
            n &= n - 1
        return c

# Transposing a song
def transpose(song, interval):
    d = {"Bb": "A#", "Db": "C#", "Eb": "D#", "Gb": "F#", "Ab": "G#"}
    l = ['A', 'A#', 'B', 'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#']
    return [l[(l.index(d.get(i, i)) + interval) % 12] for i in song]

# 77. Combinations
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        def backtrack(start, current_comb):
            if len(current_comb) == k:
                all_comb.append(list(current_comb))
                return
            for i in range(start, n + 1):
                current_comb.append(i)
                backtrack(i+1, current_comb)
                current_comb.pop()
        all_comb = []
        backtrack(1, [])
        return all_comb

# Increasing Numbers with N Digits
def increasing_numbers(digits):
    if digits == 0:
        return 1
    dp = [[0] * 10 for _ in range(digits + 1)]
    for j in range(10):
        dp[1][j] = 1

    for i in range(2, digits + 1):
        for j in range(10):
            for k in range(j + 1):
                dp[i][j] += dp[i - 1][k]
    total_count = sum(dp[digits][j] for j in range(1, 10))
    return total_count + 1

# 46. Permutations
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        import itertools
        return list(itertools.permutations(nums))
    
# Random Substitution Cipher
import random
def random_sub():
    d = {"a":"c", "b":"p", "c":"j", "d":"a", "e":"v", "f":"d",
         "g":"g", "h":"u", "i":"l", "j":"t", "k":"n", "l":"w",
         "m":"m", "n":"o", "o":"i", "p":"s", "q":"f", "r":"r", "s":"x", "t":"b",
         "u":"h", "v":"y", "w":"q", "x":"e", "y":"k", "z":"z"}
    en_al = 'abcdefghijklmnopqrstuvwxyz'
    for k, v in d.items():
        let = random.choice(en_al)
        d[k] = let
        en_al = en_al.replace(let, '')
    return d

# 561. Array Partition
class Solution:
    def arrayPairSum(self, nums: List[int]) -> int:
        nums = sorted(nums)
        return sum(i for i in nums[::2])

# Fast cooking pancakes
import math
def cook_pancakes(n, m):
    return math.ceil(n / m * 2) if n >= m else 2

# 139. Word Break
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        l = [False] * (len(s) + 1)
        l[0] = True
        for i in range(1, len(s) + 1):
            for j in range(i):
                if l[j] and s[j:i] in wordDict:
                    l[i] = True
                    break
        return l[-1]

# ASCII Shift Encryption/Decryption
def ascii_encrypt(plaintext):
    if not plaintext:
        return plaintext
    return ''.join(chr(ord(plaintext[i]) + i) for i in range(len(plaintext)))


def ascii_decrypt(encrypted):
    if not encrypted:
        return encrypted
    return ''.join(chr(ord(encrypted[i]) - i) for i in range(len(encrypted)))

# 2744. Find Maximum Number of String Pairs
class Solution:
    def maximumNumberOfStringPairs(self, words: List[str]) -> int:
        count = 0
        while True:
            top = 0
            for i in range(len(words)):
                for j in range(i + 1, len(words)):
                    if words[i][::-1] == words[j]:
                        count += 1
                        top += 1
                        words.pop(j)
                        words.pop(i)
                        break
            if top == 0:
                break
        return count
    
# Race Ceremony
from math import ceil
def race_podium(b):
    x = ceil((b) / 3) + 1
    y = min(x - 1, b - x - 1)
    return y, x, b - x - y

# 2595. Number of Even and Odd Bits
class Solution:
    def evenOddBit(self, n: int) -> List[int]:
        odd, even, flag = 0, 0, True
        for i in bin(n)[2:][::-1]:
            if flag:
                flag = False
                if i == '1':
                    even += 1
            else:
                flag = True
                if i == '1':
                    odd += 1
        return [even, odd]

# Point in Polygon
def point_in_polygon(poly, point) -> bool:
    x,y  = point
    n = len(poly)
    inside = False
    p1x,p1y = poly[0]
    for i in range(n+1):
        p2x,p2y = poly[i % n]
        if y > min(p1y,p2y):
            if y <= max(p1y,p2y):
                if x <= max(p1x,p2x):
                    if p1y != p2y:
                        xints = (y-p1y)*(p2x-p1x)/(p2y-p1y)+p1x
                    if p1x == p2x or x <= xints:
                        inside = not inside
        p1x,p1y = p2x,p2y
    return inside

# 74. Search a 2D Matrix
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        left, right, colum = 0, (len(matrix) * len(matrix[0])) - 1, len(matrix[0])
        while left <= right:
            middle = (left + right) // 2
            if matrix[middle // colum][middle % colum] == target:
                return True
            if matrix[middle // colum][middle % colum] > target:
                right = middle - 1
            else:
                left = middle + 1
        return False
    
# The unknown but known variables: Addition
def the_var(the_variables):
    en_al = 'abcdefghijklmnopqrstuvwxyz'
    op = the_variables.split('+')
    return en_al.index(op[0]) + en_al.index(op[1]) + 2

# 2586. Count the Number of Vowel Strings in Range
class Solution:
    def vowelStrings(self, words: List[str], left: int, right: int) -> int:
        count, vowels = 0, 'aeoiu'
        for i in range(left, right + 1):
            if words[i][0] in vowels and words[i][-1] in vowels:
                count += 1
        return count

# Min Factor Distance
from functools import reduce
def min_distance(n):
    factor = sorted(set(reduce(list.__add__, ([i, n // i] for i in range(1, int(n**.5)+1) if n % i == 0))))
    return min(factor[i+1] - factor[i] for i in range(len(factor)) if i + 1 < len(factor))

# 680. Valid Palindrome II
class Solution:
    def validPalindrome(self, s: str) -> bool:
        start, end = 0, len(s) - 1
        while start < end:
            if s[start] != s[end]:
                first, second = s[start:end], s[start+1:end+1]
                return first == first[::-1] or second == second[::-1]
            start, end = start + 1, end - 1
        return True

# Who Took The Car Key?
def who_took_the_car_key(message):
    return ''.join(chr(int(word, 2)) for word in message)

# 81. Search in Rotated Sorted Array II
class Solution:
    def search(self, nums: List[int], target: int) -> bool:
        left, right = 0, len(nums) - 1
        while left <= right:
            middle = (left + right) // 2
            if nums[middle] == target:
                return True
            if nums[middle] == nums[right]:
                right -= 1
            elif nums[middle] > nums[right]:
                if nums[left] <= target < nums[middle]:
                    right = middle - 1
                else:
                    left = middle + 1
            else:
                if nums[middle] < target <= nums[right]:
                    left = middle + 1
                else:
                    right = middle - 1
        return False

# Coprimes up to N
import math
def coprimes(n):
    ans = []
    for i in range(1, n):
        if math.gcd(n, i) == 1:
            ans.append(i)
    return ans

# 2806. Account Balance After Rounded Purchase
class Solution:
    def accountBalanceAfterPurchase(self, pur: int) -> int:
        return 100 - (pur + 5) // 10 * 10

# Hanging the curtains
def number_of_hooks(length, max_hook_dist):
    out = 1
    while length / out > max_hook_dist:
        out = out * 2
    return out + 1

# 2490. Circular Sentence
class Solution:
    def isCircularSentence(self, sentence: str) -> bool:
        sen = sentence.split()
        for i in range(len(sen)):
            if sen[i-1][-1] != sen[i][0]:
                return False
        return True

# Last man standing
def last_man_standing(n):
    n, flag = list(range(1, n+1)), True
    while len(n) > 1:
        if flag:
            n = n[1::2]
            flag = False
        else:
            n = n[-2::-2][::-1]
            flag = True
    return n[0]

# 2570. Merge Two 2D Arrays by Summing Values
class Solution:
    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:
        res, right, left = [], 0, 0
        while left < len(nums1) and right < len(nums2):
            if nums1[left][0] == nums2[right][0]:
                res.append([nums1[left][0], nums1[left][1] + nums2[right][1]])
                left, right = left + 1, right + 1
            else:
                if nums1[left][0] < nums2[right][0]:
                    res.append([nums1[left][0], nums1[left][1]])
                    left += 1
                else:
                    res.append([nums2[right][0], nums2[right][1]])
                    right += 1
        while left < len(nums1):
            res.append(nums1[left])
            left += 1
        while right < len(nums2):
            res.append(nums2[right])
            right += 1
        return res
    
# The mean of two means
def get_mean(arr,x,y):
    if (x <= 1 or y <= 1) or (x > len(arr) or y > len(arr)):
        return -1
    return (sum(arr[:x]) / x + sum(arr[-y:]) / y) / 2

# 215. Kth Largest Element in an Array
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        heap = nums[:k]
        heapq.heapify(heap)
        for i in nums[k:]:
            if i > heap[0]:
                heapq.heappop(heap)
                heapq.heappush(heap, i)
        return heap[0]

# What time is it?
 from datetime import datetime
def get_military_time(time):
    in_time = datetime.strptime(time, "%I:%M:%S%p")
    return datetime.strftime(in_time, "%H:%M:%S")

# 2644. Find the Maximum Divisibility Score
class Solution:
    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:
        count, top, top_n = 0, 0, divisors[0]
        for i in divisors:
            count = 0
            for j in nums:
                if j % i == 0:
                    count += 1
            if count > top:
                top_n, top = i, count
            if count == top:
                top_n = min(i, top_n)
        return top_n if top > 0 else min(divisors)
    
# Log without dates
from datetime import datetime
def check_logs(log):
    if len(log) == 0:
        return 0
    count = 1
    for x, y in zip(log, log[1:]):
        x = datetime.strptime(x, '%H:%M:%S')
        y = datetime.strptime(y, '%H:%M:%S')
        if x >= y:
            count += 1
    return count

# Converting 12-hour time to 24-hour time
from datetime import datetime
def to24hourtime(hour, minute, period):
    start = str(hour) + ':' + str(minute) + period
    start = datetime.strptime(start, '%I:%M%p')
    return datetime.strftime(start, '%H%M')

# 2515. Shortest Distance to Target String in a Circular Array
class Solution:
    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:
        if target not in words:
            return -1
        left, right = -1, -1
        while True:
            left += 1
            if words[(startIndex - left + len(words)) % len(words)] == target:
                break
        while True:
            right += 1
            if words[(startIndex + right) % len(words)] == target:
                break
        return min(left, right)

# Cats and shelves
def solution(start, finish):
    count = 0
    while finish > start:
        count += 1
        if start + 3 <= finish:
            start += 3
        else:
            start += 1
    return count

# 2481. Minimum Cuts to Divide a Circle
class Solution:
    def numberOfCuts(self, n: int) -> int:
        if n == 1:
            return 0
        return n // 2 if n % 2 == 0 else n
    
# After(?) Midnight
def day_and_time(mins):
    days = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
    total_minutes = mins % (7 * 24 * 60)
    day_index = total_minutes // (24 * 60)
    hour = (total_minutes % (24 * 60)) // 60
    minute = total_minutes % 60
    return f"{days[day_index]} {hour:02d}:{minute:02d}"

# 2600. K Items With the Maximum Sum
class Solution:
    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:
        # Solution 1
        # count = 0
        # while k > 0:
        #     k -= 1
        #     if numOnes > 0:
        #         count += 1
        #         numOnes -= 1
        #         continue
        #     if numZeros > 0:
        #         numZeros -= 1
        #         continue
        #     if numNegOnes > 0:
        #         count += -1
        #         numNegOnes -= 1
        #         continue
        # return count
        return k if k <= numOnes else numOnes - max(0, k - numOnes - numZeros)

# Estimating Amounts of Subsets
def est_subsets(arr):
    return 2 ** len(set(arr)) - 1

# 645. Set Mismatch
class Solution(object):
    def findErrorNums(self, nums):
        return [sum(nums) - sum(set(nums)), list(set(range(1, len(nums) + 1)) - set(nums))[0]]
        # Math solution
        # x, y, z = len(nums), sum(nums), sum(set(nums))
        # k = (x * (x + 1)) // 2
        # return [y - z, k - z]

# The Most Amicable of Numbers
def amicable_numbers(n1,n2):
    div_n1 = [i for i in range(1, n1 // 2 + 1) if n1 % i == 0]
    div_n2 = [i for i in range(1, n2 // 2 + 1) if n2 % i == 0]
    return sum(div_n1) == n2 and sum(div_n2) == n1

# 409. Longest Palindrome
class Solution(object):
    def longestPalindrome(self, s):
        d, count = {}, 0
        for i in s:
            if i in d:
                d[i] += 1
                if d[i] % 2 == 0:
                    count += 2
            else:
                d[i] = 1
        return count + 1 if len(s) - count != 0 else count
    
# Playing with passphrases
def play_pass(s, n):
    al = 'ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ'
    for i in range(len(s)):
        if s[i] in al:
            if i % 2 != 0:
                s = s[:i] + al[al.index(s[i]) + n % 26].lower() + s[i+1:]
            else:
                s = s[:i] + al[al.index(s[i]) + n % 26].upper() + s[i+1:]
        if s[i].isdigit():
            s = s[:i] + str(9 - int(s[i])) + s[i+1:]
    return s[::-1]

# Playing with passphrases
class Solution(object):
    def repeatedSubstringPattern(self, s):
        if len(s) == 1:
            return False
        for i in range(len(s) // 2):
            count = s[:i+1]
            cop = ''
            while len(cop) < len(s):
                cop += count
            if cop == s:
                return True
        return False

# Find The Parity Outlier
def find_outlier(inter):
    odd, even = sum(inter[i] % 2 != 0 for i in range(3)), sum(inter[i] % 2 == 0 for i in range(3))
    flag = odd > even
    if flag:
        for i in inter:
            if i % 2 == 0:
                return i
    for i in inter:
        if i % 2 != 0:
            return i

# 168. Excel Sheet Column Title
class Solution(object):
    def convertToTitle(self, columnNumber):
        l = []
        while columnNumber:
            columnNumber, i = (columnNumber - 1) // 26, (columnNumber - 1) % 26
            l.append(chr(i + ord('A')))
        return ''.join(l)[::-1]
    
# Convert string to camel case
import re
def to_camel_case(text):
    if len(text) == 0:
        return ''
    w = re.split('_|-| ', text)
    return (w[0].lower() if w[0][0].islower() else w[0].title()) + ''.join(i.title() for i in w[1:])

# 767. Reorganize String
class Solution(object):
    def reorganizeString(self, s):
        n, c = len(s), Counter(s)
        arr = sorted([ch for ch in c], key = lambda x: -c[x])
        if c[arr[0]] > (len(s)+1)//2: return ''
        chars = list(chain(*[[ch]*c[ch] for ch in arr]))
        return ''.join([chars[(n+i)//2] if i%2 else chars[i//2] for i in range(n)])

# Highest Scoring Word
 def high(x):
    return max(x.split(), key=lambda k: sum(ord(c) - 96 for c in k))

# 2769. Find the Maximum Achievable Number
class Solution(object):
    def theMaximumAchievableX(self, num, t):
        # top = 0
        # for i in range(num // 2, num * 2 + t * 2):
        #     x, y = num + t, i - t
        #     if x == y:
        #         if top < i:
        #             top = i
        # return top
        return num + t + t

# Range Extraction
def solution(args):
    if len(args) == 1:
        return str(args)
    l = []
    while args:
        cop = [args[0]]
        for i in args[1:]:
            if cop[-1] + 1 == i:
                cop.append(i)
            else:
                break
        if cop[0] != cop[-1]:
            if len(cop) > 2:
                l.append(str(cop[0])+'-'+str(cop[-1]))
            else:
                l.append(str(cop[0]))
                l.append(str(cop[-1]))
        else:
            l.append(str(cop[0]))
        args = args[args.index(cop[-1]) + 1:]
    return ','.join(l)

# Roman Numerals Encoder
def solution(n):
    integer = ''
    rom = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'),
           (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]
    while n > 0:
        for k,v in rom:
            while n >= k:
                integer += v
                n -= k
    return integer

# 1221. Split a String in Balanced Strings
# Solution 1 by Stack
class Solution(object):
    def balancedStringSplit(self, s):
        stack, count, top = [], 0, s[0]
        for i in range(len(s)):
            if len(stack) == 0:
                count += 1
                top = s[i]
            if s[i] == top:
                stack.append(s[i])
            elif len(stack) != 0:
                stack.pop()
        return count
# Solution 2 by count (best solution)
class Solution(object):
    def balancedStringSplit(self, s):
        top, count = 0, 0
        for i in range(len(s)):
            if s[i] == 'L':
                top += 1
            else:
                top -= 1
            if top == 0:
                count += 1
        return count
# Solution 3 - My initial solution
class Solution(object):
    def balancedStringSplit(self, s):
        count, left, right = 0, 0, 0
        for i in s:
            if i == 'R':
                right += 1
            else:
                left += 1
            if left == right:
                count += 1
                left = 0
                right = 0
        return count

# 646. Maximum Length of Pair Chain
class Solution(object):
    def findLongestChain(self, pairs):
        if len(pairs) == 1:
            return 1
        lenght = 1
        pairs = sorted(pairs, key=lambda x: x[1])
        top = pairs[0][1]
        for i in range(1, len(pairs)):
            if top < pairs[i][0]:
                lenght += 1
                top = pairs[i][1]
        return lenght

# Human readable duration format
 def format_duration(s):
    if s == 0:
        return 'now'
    time = {'year': 365*24*60*60, 'day': 24*60*60, 'hour': 60*60, 'minute': 60, 'second': 1}
    for k,v in time.items():
        count = 0
        while s >= v:
            s -= v
            count += 1
        time[k] = count
    dates = []
    for k,v in time.items():
        if v > 0:
            dates.append((v, k if v == 1 else k + 's'))
    if len(dates) > 1:
        return ', '.join(str(date[0]) + ' ' + date[1] for date in dates[:-1]) \
    + ' and ' + str(dates[-1][0]) + ' ' + dates[-1][1]
    return str(dates[0][0]) + ' ' + dates[0][1]

# 274. H-Index
# Solution 1 O(N * N) == O(N**2)
class Solution(object):
    def hIndex(self, citations):
        h, count = 0, 0
        while True:
            for i in citations:
                if i >= h + 1:
                    count += 1
            if count >= h + 1:
                h += 1
                count = 0
            else:
                break
        return h
# Solution 2 O(N log N)
class Solution(object):
    def hIndex(self, citations):
        citations.sort()
        for i in range(1, len(citations) + 1):
            if citations[-i] < i:
                return i - 1
        return len(citations)
# Solution 3 O(N)
class Solution(object):
    def hIndex(self, citations):
        cop, n = [0] * (len(citations) + 1), len(citations)
        for num in citations:
            if num >= n:
                cop[n] += 1
            else:
                cop[num] += 1
        pos = 0
        for i in range(n + 1):
            for j in range(cop[i]):
                citations[pos] = i
                pos += 1
        for i in range(1, n+1):
            if citations[-i] < i:
                return i - 1
        return n

# 240. Search a 2D Matrix II
# Solution 1 O(m * n)
class Solution(object):
    def searchMatrix(self, matrix, target):
        for m in range(len(matrix)):
            for n in range(len(matrix[0])):
                if matrix[m][n] == target:
                    return True
        return False
# Solution 2 O(m * logn)
class Solution(object):
    def searchMatrix(self, matrix, target):
        for m in range(len(matrix)):
            left, right = 0, len(matrix[0]) - 1
            while left <= right:
                middle = (left + right) // 2
                if matrix[m][middle] == target:
                    return True
                elif matrix[m][middle] > target:
                    right = middle - 1
                else:
                    left = middle + 1
        return False
# Solution 3 O(m + n)
class Solution(object):
    def searchMatrix(self, matrix, target):
        m, n = len(matrix), len(matrix[0])
        x, y = 0, n - 1
        while x < m and y >= 0:
            if matrix[x][y] == target:
                return True
            elif matrix[x][y] > target:
                y -= 1
            else:
                x += 1
        return False
    
# Take a Number And Sum Its Digits Raised To The Consecutive Powers And ....¡Eureka!!
def sum_dig_pow(a, b):
    l = []
    for i in range(a, b + 1):
        count = 0
        for j in range(len(str(i))):
            count += int(str(i)[j]) ** (j + 1)
        if count == i:
            l.append(i)
    return l

# 1528. Shuffle String
class Solution(object):
    def restoreString(self, s, indices):
        word = [0] * len(s)
        for i in range(len(indices)):
            word[indices[i]] = s[i]
        return ''.join(word)

# 225. Implement Stack using Queues
class MyStack(object):

    def __init__(self):
        self.lis = []

    def push(self, x):
        """
        :type x: int
        :rtype: None
        """
        return self.lis.append(x)

    def pop(self):
        """
        :rtype: int
        """
        return self.lis.pop()

    def top(self):
        """
        :rtype: int
        """
        return self.lis[-1]

    def empty(self):
        """
        :rtype: bool
        """
        return not self.lis

# Your MyStack object will be instantiated and called as such:
# obj = MyStack()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.top()
# param_4 = obj.empty()

# 1114. Print in Order
# Solution 1 - slow solution by while loop
class Foo(object):
    def __init__(self):
        self.flag1 = False
        self.flag2 = False

    def first(self, printFirst):
        """
        :type printFirst: method
        :rtype: void
        """

        # printFirst() outputs "first". Do not change or remove this line.
        printFirst()
        self.flag1 = True

    def second(self, printSecond):
        """
        :type printSecond: method
        :rtype: void
        """
        while not self.flag1:
            continue
        self.flag1 = True
        # printSecond() outputs "second". Do not change or remove this line.
        printSecond()
        self.flag2 = True

    def third(self, printThird):
        """
        :type printThird: method
        :rtype: void
        """
        while not self.flag2:
            continue
        # printThird() outputs "third". Do not change or remove this line.
        printThird()
# Solution 2 - by events
import threading


class Foo(object):
    def __init__(self):
        self.flag1 = threading.Event()
        self.flag2 = threading.Event()

    def first(self, printFirst):
        """
        :type printFirst: method
        :rtype: void
        """
        # printFirst() outputs "first". Do not change or remove this line.
        printFirst()
        self.flag1.set()

    def second(self, printSecond):
        """
        :type printSecond: method
        :rtype: void
        """
        self.flag1.wait()
        # printSecond() outputs "second". Do not change or remove this line.
        printSecond()
        self.flag2.set()

    def third(self, printThird):
        """
        :type printThird: method
        :rtype: void
        """
        self.flag2.wait()
        # printThird() outputs "third". Do not change or remove this line.
        printThird()

# Strip Comments
def strip_comments(strng, markers):
    strng = strng.split('\n')
    for i in range(len(strng)):
        for spl in markers:
            if spl in strng[i]:
                strng[i] = strng[i].split(spl)[0].rstrip()
    return '\n'.join(strng)

# 2483. Minimum Penalty for a Shop
class Solution(object):
    def bestClosingTime(self, customers):
        score, top, time = 0, 0, -1
        for i in range(len(customers)):
            top += 1 if customers[i] == "Y" else -1
            if top > score:
                score = top
                time = i
        return time + 1

# So Many Permutations!
 def permutations(s):
    l = []
    def permute(data, i, length):
        if i == length:
            l.append(''.join(data) )
        else:
            for j in range(i, length):
                data[i], data[j] = data[j], data[i]
                permute(data, i + 1, length)
                data[i], data[j] = data[j], data[i]
    permute(list(s), 0, len(s))
    return set(l)

# 1678. Goal Parser Interpretation
# Solution 1 - replace method
class Solution(object):
    def interpret(self, command):
        return command.replace('()', 'o').replace('(al)', 'al')
# Solution 2 - by while loop and array
class Solution:
    def interpret(self, command: str) -> str:
        ans, i = [], 0
        while i < len(command):
            if command[i] == 'G':
                ans += ['G']
                i += 1
            elif command[i:i + 2] == '()':
                ans += ['o']
                i += 2
            else:
                ans += ['al']
                i += 4
        return ''.join(ans)

# WeIrD StRiNg CaSe
def to_weird_case(words):
    words, ans = words.split(), []
    for i in words:
        top = ''
        for j in range(len(i)):
            if j % 2 == 0:
                top += i[j].upper()
            else:
                top += i[j].lower()
        ans.append(top)
    return ' '.join(ans)
# 2269. Find the K-Beauty of a Number2269. Find the K-Beauty of a Number
class Solution:
    def divisorSubstrings(self, num: int, k: int) -> int:
        count = 0
        num = str(num)
        for i in range(len(num) - k + 1):
            if num[i:i+k] != '0' * k:
                if int(num) % int(num[i:i+k]) == 0:
                    count += 1
        return count

# Sum Strings as Numbers
def sum_strings(x, y):
    if len(x)> len(y):
        temp = x
        x = y
        y = temp
    str3, n1, n2 = "", len(x), len(y)
    diff, carry = n2 - n1, 0
    for i in range(n1-1, -1, -1):
        sum = ((ord(x[i]) - ord('0')) + int((ord(y[i + diff]) - ord('0'))) + carry)
        str3 = str3 + str(sum%10)
        carry = sum//10
    for i in range(n2-n1-1, -1, -1):
        sum = ((ord(y[i]) - ord('0')) + carry)
        str3 = str3 + str(sum%10 )
        carry = sum//10
    if carry:
        print(carry, str3)
        str3 += str(carry)
    str3 = str3[::-1]
    if not str3:
        return '0'
    if str3[0] == '0':
        str3 = str3[1:]
    return str3 if str3 else '0'
# 338. Counting Bits
# Solution 2
class Solution:
    def countBits(self, num):
        ret = [0] * (num + 1)
        for i in range(1, num+1):
            ret[i] = ret[i>>1] + (i&1)
        return ret
    
# Handshake problem
def get_participants(handshakes):
    count = 0
    while handshakes > 0:
        handshakes -= count
        count += 1
    return count

# 2784. Check if Array is Good
# Solution 1
class Solution:
    def isGood(self, nums: List[int]) -> bool:
        m = max(nums)
        if len(nums) != m + 1:
            return False
        nums.sort()
        for i in range(1, m + 1):
            if i != nums[i-1]:
                return False
        return m == nums[-1]
# Solution 2
class Solution:
    def isGood(self, nums: List[int]) -> bool:
        m = max(nums)
        l = list(range(1, m+1)) + [m]
        return l == sorted(nums)
# Solution 3
class Solution:
    def isGood(self, nums: List[int]) -> bool:
        n = max(nums)
        return sum(nums) == (n * (n + 1) // 2) + n and len(set(nums)) == n

# Reverse or rotate?
def rev_rot(strng, sz):
    if sz > len(strng) or sz <= 0 or len(strng) == 0:
        return ''
    chunk = [(strng[i:i+sz], sum(int(j)**3 for j in strng[i:i+sz])) \
             for i in range(0, len(strng), sz) if len(strng[i:i+sz]) == sz]
    return ''.join(k[::-1] if v % 2 == 0 else k[1:] + k[0] for k,v in chunk)

# 2099. Find Subsequence of Length K With the Largest Sum
class Solution:
    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:
        ans = sorted(enumerate(nums), key=lambda x: x[1])[-k:]
        return [v for k, v in sorted(ans)]

# Roman Numerals Helper
rom = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'),
      (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]
class RomanNumerals:
    @staticmethod
    def to_roman(val):
        integer = ''
        while val > 0:
            for k,v in rom:
                while val >= k:
                    integer += v
                    val -= k
        return integer

    @staticmethod
    def from_roman(roman_num):
        ans = 0
        while roman_num:
            for k,v in rom:
                if roman_num.startswith(v):
                    ans += k
                    roman_num = roman_num[len(v):]
        return ans

# The observed PIN
import itertools
def get_pins(observed):
    d = {1:[2,4], 2:[1,3,5], 3:[2,6],4:[1,5,7],
         5:[4,2,6,8], 6:[9,5,3], 7:[4,8], 8:[7,5,9,0], 9:[8,6], 0:[8]}
    l = [list(map(str, d[int(i)])) + [i] for i in observed]
    ans = [''.join(i) for i in itertools.product(*l)]
    return ans

# Next bigger number with the same digits
def next_bigger(n):
    m = int(''.join(sorted(str(n))[::-1]))
    count = 1
    while m >= n + count:
        if sorted(str(n + count)) == sorted(str(n)):
            return n + count
        count += 1
    return -1

# Most frequently used words in a text
def top_3_words(text):
    d, word = {}, ''
    for i in text:
        if i.lower().isalpha() or i == "'":
            word += i.lower()
        else:
            if len(word) > 0:
                if any(i.isalpha() for i in word):
                    d[word] = d.get(word, 0) + 1
                word = ''
    if not d:
        return []
    d = [i[0] for i in sorted(d.items(), key=lambda x: x[1])[:-4:-1]]
    return d

# 141. Linked List Cycle
# Solution 1 - Hashtable. Speed - O(N) Memory - O(N)
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        s = set()
        while head:
            if head in s:
                return True
            s.add(head)
            head = head.next
        return False
# Solution 2 - Two pointers. Speed - O(N) Memory - O(1)
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        x, y = head, head
        while x and y and y.next:
            x, y = x.next, y.next.next
            if x == y:
                return True
        return False

# Recover a secret string from random triplets
def recoverSecret(triplets):
    unique_letters = set()
    letter_order = {}
    for triplet in triplets:
        for letter in triplet:
            unique_letters.add(letter)
    for triplet in triplets:
        for i in range(2):
            if triplet[i + 1] not in letter_order:
                letter_order[triplet[i + 1]] = set()
            letter_order[triplet[i + 1]].add(triplet[i])
    sorted_letters = []
    while unique_letters:
        for letter in unique_letters:
            if letter not in letter_order or not letter_order[letter]:
                sorted_letters.append(letter)
                unique_letters.remove(letter)
                for key in letter_order:
                    if letter in letter_order[key]:
                        letter_order[key].remove(letter)
                break
    return ''.join(sorted_letters)

# 1450. Number of Students Doing Homework at a Given Time
class Solution:
    def busyStudent(self, startTime: List[int], endTime: List[int], queryTime: int) -> int:
        count = 0
        for i in range(len(startTime)):
            if endTime[i] >= queryTime and startTime[i] <= queryTime:
                count += 1
        return count

# Spoonerize Me
def spoonerize(words):
    w = words.split()
    return w[1][0] + w[0][1:] + ' ' + w[0][0] + w[1][1:]

# 1629. Slowest Key
class Solution:
    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:
        d = {keysPressed[0]:releaseTimes[0]}
        for i in range(1, len(releaseTimes)):
            if not d.get(keysPressed[i], None):
                d[keysPressed[i]] = releaseTimes[i] - releaseTimes[i-1]
            else:
                d[keysPressed[i]] = max(d[keysPressed[i]], releaseTimes[i] - releaseTimes[i-1])
        top, key = 0, 'a'
        for k,v in d.items():
            if v >= top:
                if v == top:
                    key, top = max(key, k), v
                    continue
                top, key = v, k
        return key

# ATM
def solve(n):
    d = {500:0, 200:0, 100:0, 50:0, 20:0, 10:0}
    for i in d:
        while n >= i:
            d[i] = n // i
            n %= i
    if n > 0:
        return -1
    return sum(v for v in d.values())

# 500. Keyboard Row
class Solution:
    def findWords(self, words: List[str]) -> List[str]:
        d= {'q':1,'w':1,'e':1,'r':1,'t':1,'y':1,'u':1,'i':1,'o':1,'p':1,
        'a':2,'s':2,'d':2,'f':2,'g':2,'h':2,'j':2,'k':2,'l':2,
        'z':3,'x':3,'c':3,'v':3,'b':3,'n':3,'m':3}
        ans = list()
        for i in words:
            if len(i) == 1:
                ans.append(i)
                continue
            x, flag = d[i[0].lower()], True
            for let in range(1, len(i)):
                if d[i[let].lower()] != x:
                    flag = False
                    break
                x = d[i[let].lower()]
            if flag:
                ans.append(i)
        return ans

# Bubblesort Once
def bubblesort_once(l):
    l = l.copy()
    for i in range(1, len(l)):
        if l[i-1] > l[i]:
            l[i-1], l[i] = l[i], l[i-1]
    return l

# 118. Pascal's Triangle
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        row, triangle = [1], [[1]]
        for i in range(numRows-1):
            row = [x + y for x, y in zip([0] + row, row + [0])]
            triangle.append(row)
        return triangle

# Character Counter
def validate_word(word):
    d = {}
    for i in word.lower():
        d[i] = d.get(i, 0) + 1
    return all(x == y for x, y in zip(d.values(), list(d.values())[1:]))

# 868. Binary Gap
class Solution:
    def binaryGap(self, n: int) -> int:
        integer, flag, ans = bin(n)[2:], False, 0
        for ch in range(len(integer)):
            if integer[ch] == '1' and not flag:
                flag, ind = True, ch
                continue
            elif integer[ch] == '1' and flag:
                if ans < ch - ind:
                    ans = ch - ind
                ind = ch
        return ans

# Ninja vs Samurai: Strike
class Warrior:
    def __init__(self, name):
        self.name = name
        self.health = 100

    def strike(self, enemy, swings):
        # health cannot go below zero
        enemy.health = max([0, enemy.health - (swings * 10)])
        return enemy.health

# Sort Santa's Reindeer
# Happy Holidays fellow Code Warriors!
# Now, Dasher! Now, Dancer! Now, Prancer, and Vixen! On, Comet! On, Cupid! On, Donder and Blitzen! That's the order Santa wanted his reindeer...right? What do you mean he wants them in order by their last names!? Looks like we need your help Code Warrior!
#
# Sort Santa's Reindeer
# Write a function that accepts a sequence of Reindeer names, and returns a sequence with the Reindeer names sorted by their last names.
#
# Notes:
# It's guaranteed that each string is composed of two words
# In case of two identical last names, keep the original order
# Examples
# For this input:
#
# [
#   "Dasher Tonoyan",
#   "Dancer Moore",
#   "Prancer Chua",
#   "Vixen Hall",
#   "Comet Karavani",
#   "Cupid Foroutan",
#   "Donder Jonker",
#   "Blitzen Claus"
# ]
# You should return this output:
#
# [
#   "Prancer Chua",
#   "Blitzen Claus",
#   "Cupid Foroutan",
#   "Vixen Hall",
#   "Donder Jonker",
#   "Comet Karavani",
#   "Dancer Moore",
#   "Dasher Tonoyan",
# ]
# SORTINGARRAYSSTRINGSALGORITHMS
# Solution
def sort_reindeer(reindeer_names):
    return sorted(reindeer_names, key=lambda x: x.split()[1])

# 2839. Check if Strings Can be Made Equal With Operations I
# You are given two strings s1 and s2, both of length 4, consisting of lowercase English letters.
#
# You can apply the following operation on any of the two strings any number of times:
#
# Choose any two indices i and j such that j - i = 2, then swap the two characters at those indices in the string.
# Return true if you can make the strings s1 and s2 equal, and false otherwise.
#
#
#
# Example 1:
#
# Input: s1 = "abcd", s2 = "cdab"
# Output: true
# Explanation: We can do the following operations on s1:
# - Choose the indices i = 0, j = 2. The resulting string is s1 = "cbad".
# - Choose the indices i = 1, j = 3. The resulting string is s1 = "cdab" = s2.
# Example 2:
#
# Input: s1 = "abcd", s2 = "dacb"
# Output: false
# Explanation: It is not possible to make the two strings equal.
#
#
# Constraints:
#
# s1.length == s2.length == 4
# s1 and s2 consist only of lowercase English letters.
# Solution 1
class Solution:
    def canBeEqual(self, s1: str, s2: str) -> bool:
        if s1 == s2:
            return True
        if s1[2] + s1[1] + s1[0] + s1[3] == s2:
            return True
        if s1[2] + s1[3] + s1[0] + s1[1] == s2:
            return True
        return s1[0] + s1[3] + s1[2] + s1[1] == s2
# Solution 2
class Solution:
    def canBeEqual(self, s1: str, s2: str) -> bool:
        if s1 == s2:
            return True
        cop = s1[2] + s1[1] + s1[0] + s1[3]
        for i in range(2):
            if cop == s2:
                return True
            else:
                cop = cop[0] + cop[3] + cop[2] + cop[1]
        return s1[0] + s1[3] + s1[2] + s1[1] == s2

# Pandemia 🌡️
# ⚠️ The world is in quarantine! There is a new pandemia that struggles mankind. Each continent is isolated from each other but infected people have spread before the warning. ⚠️
#
# 🗺️ You would be given a map of the world in a type of string:
#
# string s = "01000000X000X011X0X"
#
# '0' : uninfected
#
# '1' : infected
#
# 'X' : ocean
# ⚫ The virus can't spread in the other side of the ocean.
#
# ⚫ If one person is infected every person in this continent gets infected too.
#
# ⚫ Your task is to find the percentage of human population that got infected in the end.
#
# ☑️ Return the percentage % of the total population that got infected.
#
# ❗❗ The first and the last continent are not connected!
#
# 💡 Example:
#
#  start: map1 = "01000000X000X011X0X"
#  end:   map1 = "11111111X000X111X0X"
#  total = 15
#  infected = 11
#  percentage = 100*11/15 = 73.33333333333333
# ➕ For maps without oceans "X" the whole world is connected.
#
# ➕ For maps without "0" and "1" return 0 as there is no population.
#
# STRINGSPUZZLES
# Solution
def infected(s):
    if '0' not in s and '1' not in s:
        return 0
    if 'X' not in s:
        return 100 if '1' in s else 0
    total, vir = 0, 0
    for i in s.split('X'):
        total += len(i)
        if '1' in i:
            vir += len(i)
    return 100 * vir / total

# 1282. Group the People Given the Group Size They Belong To
# There are n people that are split into some unknown number of groups. Each person is labeled with a unique ID from 0 to n - 1.
#
# You are given an integer array groupSizes, where groupSizes[i] is the size of the group that person i is in. For example, if groupSizes[1] = 3, then person 1 must be in a group of size 3.
#
# Return a list of groups such that each person i is in a group of size groupSizes[i].
#
# Each person should appear in exactly one group, and every person must be in a group. If there are multiple answers, return any of them. It is guaranteed that there will be at least one valid solution for the given input.
#
#
#
# Example 1:
#
# Input: groupSizes = [3,3,3,3,3,1,3]
# Output: [[5],[0,1,2],[3,4,6]]
# Explanation:
# The first group is [5]. The size is 1, and groupSizes[5] = 1.
# The second group is [0,1,2]. The size is 3, and groupSizes[0] = groupSizes[1] = groupSizes[2] = 3.
# The third group is [3,4,6]. The size is 3, and groupSizes[3] = groupSizes[4] = groupSizes[6] = 3.
# Other possible solutions are [[2,1,6],[5],[0,4,3]] and [[5],[0,6,2],[4,3,1]].
# Example 2:
#
# Input: groupSizes = [2,1,3,3,3,2]
# Output: [[1],[0,5],[2,3,4]]
#
#
# Constraints:
#
# groupSizes.length == n
# 1 <= n <= 500
# 1 <= groupSizes[i] <= n
class Solution:
    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:
        d, ans = {}, []
        for k,v in enumerate(groupSizes):
            d[v] = d.get(v, []) + [k]
        for k,v in d.items():
            for i in range(0, len(v), k):
                ans.append(v[i:i + k])
        return ans

# Simple string reversal
# In this Kata, we are going to reverse a string while maintaining the spaces (if any) in their original place.
#
# For example:
#
# solve("our code") = "edo cruo"
# -- Normal reversal without spaces is "edocruo".
# -- However, there is a space at index 3, so the string becomes "edo cruo"
#
# solve("your code rocks") = "skco redo cruoy".
# solve("codewars") = "srawedoc"
# More examples in the test cases. All input will be lower case letters and in some cases spaces.
#
# Good luck!
#
# Please also try:
#
# Simple time difference
#
# Simple remove duplicates
#
# ALGORITHMS
def solve(s):
    l = [k for k,v in enumerate(list(s)) if v == ' ']
    word = list(s.replace(' ', ''))[::-1]
    for i in l:
        word.insert(i, ' ')
    return ''.join(word)

# 1647. Minimum Deletions to Make Character Frequencies Unique
# A string s is called good if there are no two different characters in s that have the same frequency.
#
# Given a string s, return the minimum number of characters you need to delete to make s good.
#
# The frequency of a character in a string is the number of times it appears in the string. For example, in the string "aab", the frequency of 'a' is 2, while the frequency of 'b' is 1.
#
#
#
# Example 1:
#
# Input: s = "aab"
# Output: 0
# Explanation: s is already good.
# Example 2:
#
# Input: s = "aaabbbcc"
# Output: 2
# Explanation: You can delete two 'b's resulting in the good string "aaabcc".
# Another way it to delete one 'b' and one 'c' resulting in the good string "aaabbc".
# Example 3:
#
# Input: s = "ceabaacb"
# Output: 2
# Explanation: You can delete both 'c's resulting in the good string "eabaab".
# Note that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).
#
#
# Constraints:
#
# 1 <= s.length <= 105
# s contains only lowercase English letters.
class Solution:
    def minDeletions(self, s: str) -> int:
        d, se, de = {}, set(), 0
        for i in s:
            d[i] = d.get(i, 0) + 1
        for k,v in d.items():
            while v in se:
                v -= 1
                de += 1
            if v > 0:
                se.add(v)
        return de
    
# Candy problem
# Description
# "It's the end of trick-or-treating and we have a list/array representing how much candy each child in our group has made out with. We don't want the kids to start arguing, and using our parental intuition we know trouble is brewing as many of the children in the group have received different amounts of candy from each home.
#
# So we want each child to have the same amount of candies, only we can't exactly take any candy away from the kids, that would be even worse. Instead we decide to give each child extra candy until they all have the same amount.
#
# Task
# Your job is to find out how much candy each child has, and give them each additional candy until they too have as much as the child(ren) with the most candy. You also want to keep a total of how much candy you've handed out because reasons."
#
# Your job is to give all the kids the same amount of candies as the kid with the most candies and then return the total number candies that have been given out. If there are no kids, or only one, return -1.
#
# In the first case (look below) the most candies are given to second kid (i.e second place in list/array), 8. Because of that we will give the first kid 3 so he can have 8 and the third kid 2 and the fourth kid 4, so all kids will have 8 candies.So we end up handing out 3 + 2 + 4 = 9.
#
# candies ([5,8,6,4]) # return 9
#
# candies ([1,2,4,6]) # return 11
#
# candies ([1,6]) # return 5
#
# candies ([]) # return -1
#
# candies ([6]) # return -1 (because only one kid)
# LISTSALGORITHMS
def candies(s):
    if len(s) < 2:
        return -1
    return sum(max(s) - i for i in s)

# 2697. Lexicographically Smallest Palindrome
# You are given a string s consisting of lowercase English letters, and you are allowed to perform operations on it. In one operation, you can replace a character in s with another lowercase English letter.
#
# Your task is to make s a palindrome with the minimum number of operations possible. If there are multiple palindromes that can be made using the minimum number of operations, make the lexicographically smallest one.
#
# A string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b.
#
# Return the resulting palindrome string.
#
#
#
# Example 1:
#
# Input: s = "egcfe"
# Output: "efcfe"
# Explanation: The minimum number of operations to make "egcfe" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is "efcfe", by changing 'g'.
# Example 2:
#
# Input: s = "abcd"
# Output: "abba"
# Explanation: The minimum number of operations to make "abcd" a palindrome is 2, and the lexicographically smallest palindrome string we can get by modifying two characters is "abba".
# Example 3:
#
# Input: s = "seven"
# Output: "neven"
# Explanation: The minimum number of operations to make "seven" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is "neven".
#
#
# Constraints:
#
# 1 <= s.length <= 1000
# s consists of only lowercase English letters.
class Solution:
    def makeSmallestPalindrome(self, s: str) -> str:
        a, b, word = 0, len(s) - 1, list(s)
        while a < b:
            if s[a] != s[b]:
                if s[a] < s[b]:
                    word[b] = word[a]
                else:
                    word[a] = s[b]
            a += 1
            b -= 1
        return ''.join(word)
    
# The fusc function -- Part 1
# The fusc function is defined recursively as follows:
#
# 1. fusc(0) = 0
# 2. fusc(1) = 1
# 3. fusc(2 * n) = fusc(n)
# 4. fusc(2 * n + 1) = fusc(n) + fusc(n + 1)
# The 4 rules above are sufficient to determine the value of fusc for any non-negative input n. For example, let's say you want to compute fusc(10).
#
# fusc(10) = fusc(5), by rule 3.
# fusc(5) = fusc(2) + fusc(3), by rule 4.
# fusc(2) = fusc(1), by rule 3.
# fusc(1) = 1, by rule 2.
# fusc(3) = fusc(1) + fusc(2) by rule 4.
# fusc(1) and fusc(2) have already been computed are both equal to 1.
# Putting these results together fusc(10) = fusc(5) = fusc(2) + fusc(3) = 1 + 2 = 3
#
# Your job is to produce the code for the fusc function. In this kata, your function will be tested with small values of n, so you should not need to be concerned about stack overflow or timeouts.
#
# Hint: Use recursion.
#
# When done, move on to Part 2.
#
# ALGORITHMS
def fusc(n):
    if n == 0:
        return 0
    if n == 1:
        return 1
    if n % 2 == 0:
        return fusc(n / 2)
    return fusc(n // 2) + fusc(n // 2 + 1)

# 1656. Design an Ordered Stream
# There is a stream of n (idKey, value) pairs arriving in an arbitrary order, where idKey is an integer between 1 and n and value is a string. No two pairs have the same id.
#
# Design a stream that returns the values in increasing order of their IDs by returning a chunk (list) of values after each insertion. The concatenation of all the chunks should result in a list of the sorted values.
#
# Implement the OrderedStream class:
#
# OrderedStream(int n) Constructs the stream to take n values.
# String[] insert(int idKey, String value) Inserts the pair (idKey, value) into the stream, then returns the largest possible chunk of currently inserted values that appear next in the order.
#
#
# Example:
#
#
#
# Input
# ["OrderedStream", "insert", "insert", "insert", "insert", "insert"]
# [[5], [3, "ccccc"], [1, "aaaaa"], [2, "bbbbb"], [5, "eeeee"], [4, "ddddd"]]
# Output
# [null, [], ["aaaaa"], ["bbbbb", "ccccc"], [], ["ddddd", "eeeee"]]
#
# Explanation
# // Note that the values ordered by ID is ["aaaaa", "bbbbb", "ccccc", "ddddd", "eeeee"].
# OrderedStream os = new OrderedStream(5);
# os.insert(3, "ccccc"); // Inserts (3, "ccccc"), returns [].
# os.insert(1, "aaaaa"); // Inserts (1, "aaaaa"), returns ["aaaaa"].
# os.insert(2, "bbbbb"); // Inserts (2, "bbbbb"), returns ["bbbbb", "ccccc"].
# os.insert(5, "eeeee"); // Inserts (5, "eeeee"), returns [].
# os.insert(4, "ddddd"); // Inserts (4, "ddddd"), returns ["ddddd", "eeeee"].
# // Concatentating all the chunks returned:
# // [] + ["aaaaa"] + ["bbbbb", "ccccc"] + [] + ["ddddd", "eeeee"] = ["aaaaa", "bbbbb", "ccccc", "ddddd", "eeeee"]
# // The resulting order is the same as the order above.
#
#
# Constraints:
#
# 1 <= n <= 1000
# 1 <= id <= n
# value.length == 5
# value consists only of lowercase letters.
# Each call to insert will have a unique id.
# Exactly n calls will be made to insert.
# Solution 1
class OrderedStream:

    def __init__(self, n: int):
        self.ptr = 1
        self.l = [0] * n

    def insert(self, idKey: int, value: str) -> List[str]:
        self.l[idKey-1] = value
        if self.ptr == idKey:
            ans = []
            for i in self.l[idKey-1:]:
                if i == 0:
                    break
                else:
                    ans.append(i)
            if 0 in self.l:
                self.ptr = self.l.index(0) + 1
            return ans
        return []


# Your OrderedStream object will be instantiated and called as such:
# obj = OrderedStream(n)
# param_1 = obj.insert(idKey,value)

# Solution 2
class OrderedStream:

    def __init__(self, n: int):
        self.ptr = 0
        self.l = [None] * n

    def insert(self, idKey: int, value: str) -> List[str]:
        self.l[idKey-1] = value
        if self.ptr == idKey - 1:
            while self.ptr < len(self.l) and self.l[self.ptr]:
                self.ptr += 1
            return self.l[idKey-1:self.ptr]
        return []


# Your OrderedStream object will be instantiated and called as such:
# obj = OrderedStream(n)
# param_1 = obj.insert(idKey,value)

# Invisible cubes
# Imagine there's a big cube consisting of
# �
# 3
# n
# 3
#   small cubes. Calculate, how many small cubes are not visible from outside.
#
# For example, if we have a cube which has 4 cubes in a row, then the function should return 8, because there are 8 cubes inside our cube (2 cubes in each dimension)
#
# For a visual representation: --> https://imgur.com/a/AN8A5DJ
#
# PUZZLES
def not_visible_cubes(n):
    if n - 2 <= 0:
        return 0
    return (n - 2) ** 3

# 485. Max Consecutive Ones
# Given a binary array nums, return the maximum number of consecutive 1's in the array.
#
#
#
# Example 1:
#
# Input: nums = [1,1,0,1,1,1]
# Output: 3
# Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.
# Example 2:
#
# Input: nums = [1,0,1,1,0,1]
# Output: 2
#
#
# Constraints:
#
# 1 <= nums.length <= 105
# nums[i] is either 0 or 1.
class Solution:
    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
        top, count = 0, 0
        for i in nums:
            if i == 1:
                count += 1
            else:
                if count > top:
                    top = count
                count = 0
        if count > top:
            return count
        return top

# Number of Rectangles in a Grid
# Given a grid of size m x n, calculate the total number of rectangles contained in this rectangle. All integer sizes and positions are counted.
#
# Examples(Input1, Input2 --> Output):
#
# 3, 2 --> 18
# 4, 4 --> 100
# Here is how the 3x2 grid works (Thanks to GiacomoSorbi for the idea):
#
# 1 rectangle of size 3x2:
#
# [][][]
# [][][]
# 2 rectangles of size 3x1:
#
# [][][]
# 4 rectangles of size 2x1:
#
# [][]
# 2 rectangles of size 2x2
#
# [][]
# [][]
# 3 rectangles of size 1x2:
#
# []
# []
# 6 rectangles of size 1x1:
#
# []
# As you can see (1 + 2 + 4 + 2 + 3 + 6) = 18, and is the solution for the 3x2 grid.
#
# There is a very simple solution to this!
#
# GEOMETRYPUZZLES
def number_of_rectangles(m, n):
    count = 0
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            count += i * j
    return count

# 2154. Keep Multiplying Found Values by Two
# You are given an array of integers nums. You are also given an integer original which is the first number that needs to be searched for in nums.
#
# You then do the following steps:
#
# If original is found in nums, multiply it by two (i.e., set original = 2 * original).
# Otherwise, stop the process.
# Repeat this process with the new number as long as you keep finding the number.
# Return the final value of original.
#
#
#
# Example 1:
#
# Input: nums = [5,3,6,1,12], original = 3
# Output: 24
# Explanation:
# - 3 is found in nums. 3 is multiplied by 2 to obtain 6.
# - 6 is found in nums. 6 is multiplied by 2 to obtain 12.
# - 12 is found in nums. 12 is multiplied by 2 to obtain 24.
# - 24 is not found in nums. Thus, 24 is returned.
# Example 2:
#
# Input: nums = [2,7,9], original = 4
# Output: 4
# Explanation:
# - 4 is not found in nums. Thus, 4 is returned.
#
#
# Constraints:
#
# 1 <= nums.length <= 1000
# 1 <= nums[i], original <= 1000
class Solution:
    def findFinalValue(self, nums: List[int], original: int) -> int:
        nums = set(nums)
        while original in nums:
            original *= 2
        return original

# Four/Seven
# Four Seven
# Simple kata, simple rules: your function should accept the inputs 4 and 7. If 4 is entered, the function should return 7. If 7 is entered, the function should return 4. Anything else entered as input should return a false-y value such as False, 0, [], "". There's only one catch, your function cannot include if statements (or the eval function due to the fact that you can get around the if requirement using it).
#
# There are some very simple ways of answering this problem, but I encourage you to try and be as creative as possible.
#
# Good Luck!
#
# PUZZLES
def solution(n):
    while n == 4:
        return 7
    while n == 7:
        return 4
    return False

# 1128. Number of Equivalent Domino Pairs
# Given a list of dominoes, dominoes[i] = [a, b] is equivalent to dominoes[j] = [c, d] if and only if either (a == c and b == d), or (a == d and b == c) - that is, one domino can be rotated to be equal to another domino.
#
# Return the number of pairs (i, j) for which 0 <= i < j < dominoes.length, and dominoes[i] is equivalent to dominoes[j].
#
#
#
# Example 1:
#
# Input: dominoes = [[1,2],[2,1],[3,4],[5,6]]
# Output: 1
# Example 2:
#
# Input: dominoes = [[1,2],[1,2],[1,1],[1,2],[2,2]]
# Output: 3
#
#
# Constraints:
#
# 1 <= dominoes.length <= 4 * 104
# dominoes[i].length == 2
# 1 <= dominoes[i][j] <= 9
class Solution:
    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:
        d = {}
        count = 0
        for i in dominoes:
            t = (min(i), max(i))
            if t in d:
                count += d[t]
                d[t] += 1
            else:
                d[t] = 1
        return count

# Keypad horror
# Having two standards for a keypad layout is inconvenient!
# Computer keypad's layout:
# 7 8 9  \n
# 4 5 6  \n
# 1 2 3  \n
#   0 \n
#
# Cell phone keypad's layout:
# 1 2 3\n
# 4 5 6\n
# 7 8 9\n
#   0\n
#
# Solve the horror of unstandardized keypads by providing a function that converts computer input to a number as if it was typed on a phone.
#
# Example:
# "789" -> "123"
#
# Notes:
# You get a string with numbers only
#
# STRINGS
def computer_to_phone(numbers):
    return numbers.translate(str.maketrans('123456789', '789456123'))

# 1337. The K Weakest Rows in a Matrix
# You are given an m x n binary matrix mat of 1's (representing soldiers) and 0's (representing civilians). The soldiers are positioned in front of the civilians. That is, all the 1's will appear to the left of all the 0's in each row.
#
# A row i is weaker than a row j if one of the following is true:
#
# The number of soldiers in row i is less than the number of soldiers in row j.
# Both rows have the same number of soldiers and i < j.
# Return the indices of the k weakest rows in the matrix ordered from weakest to strongest.
#
#
#
# Example 1:
#
# Input: mat =
# [[1,1,0,0,0],
#  [1,1,1,1,0],
#  [1,0,0,0,0],
#  [1,1,0,0,0],
#  [1,1,1,1,1]],
# k = 3
# Output: [2,0,3]
# Explanation:
# The number of soldiers in each row is:
# - Row 0: 2
# - Row 1: 4
# - Row 2: 1
# - Row 3: 2
# - Row 4: 5
# The rows ordered from weakest to strongest are [2,0,3,1,4].
# Example 2:
#
# Input: mat =
# [[1,0,0,0],
#  [1,1,1,1],
#  [1,0,0,0],
#  [1,0,0,0]],
# k = 2
# Output: [0,2]
# Explanation:
# The number of soldiers in each row is:
# - Row 0: 1
# - Row 1: 4
# - Row 2: 1
# - Row 3: 1
# The rows ordered from weakest to strongest are [0,2,3,1].
#
#
# Constraints:
#
# m == mat.length
# n == mat[i].length
# 2 <= n, m <= 100
# 1 <= k <= m
# matrix[i][j] is either 0 or 1.
class Solution:
    def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:
        row_strength = [(sum(row), i) for i, row in enumerate(mat)]
        row_strength.sort(key=lambda x: (x[0], x[1]))
        return [row[1] for row in row_strength[:k]]

# Determine if the poker hand is flush
# Determine if the poker hand is flush, meaning if the five cards are of the same suit.
#
# Your function will be passed a list/array of 5 strings, each representing a poker card in the format "5H" (5 of hearts), meaning the value of the card followed by the initial of its suit (Hearts, Spades, Diamonds or Clubs). No jokers included.
#
# Your function should return true if the hand is a flush, false otherwise.
#
# The possible card values are 2, 3, 4, 5, 6, 7, 8, 9, 10, J, Q, K, A
#
# Examples
# ["AS", "3S", "9S", "KS", "4S"]  ==> true
#
# ["AD", "4S", "7H", "KS", "10S"] ==> false
# ARRAYSALGORITHMSLOGICSTRINGSGAMES
def is_flush(cards):
    return all(i[-1] == j[-1] for i,j in zip(cards, cards[1:]))

# 287. Find the Duplicate Number
# Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.
#
# There is only one repeated number in nums, return this repeated number.
#
# You must solve the problem without modifying the array nums and uses only constant extra space.
#
#
#
# Example 1:
#
# Input: nums = [1,3,4,2,2]
# Output: 2
# Example 2:
#
# Input: nums = [3,1,3,4,2]
# Output: 3
#
#
# Constraints:
#
# 1 <= n <= 105
# nums.length == n + 1
# 1 <= nums[i] <= n
# All the integers in nums appear only once except for precisely one integer which appears two or more times.
#
#
# Follow up:
#
# How can we prove that at least one duplicate number must exist in nums?
# Can you solve the problem in linear runtime complexity?
# Solution 1 - HashTable
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        d = {}
        for i in nums:
            if i in d:
                return i
            else:
                d[i] = 1

# Solution 2 - HashSet
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        s = set()
        for i in nums:
            if i in s:
                return i
            else:
                s.add(i)
# Solution 3 - Floyd Circle Algorithm
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        slow, fast = nums[0], nums[0]
        while True:
            slow = nums[slow]
            fast = nums[nums[fast]]
            if slow == fast:
                break
        slow = nums[0]
        while slow != fast:
            slow, fast = nums[slow], nums[fast]
        return slow

# 99 Bottles of Beer
# Instructions
# Complete the function that returns the lyrics for the song 99 Bottles of Beer as an array of strings: each line should be a separate element - see the example at the bottom.
#
# Note: in order to avoid hardcoded solutions, the size of your code is limited to 1000 characters
#
# Lyrics
# 99 bottles of beer on the wall, 99 bottles of beer.
# Take one down and pass it around, 98 bottles of beer on the wall.
#
# 98 bottles of beer on the wall, 98 bottles of beer.
# Take one down and pass it around, 97 bottles of beer on the wall.
#
# ...and so on...
#
# 3 bottles of beer on the wall, 3 bottles of beer.
# Take one down and pass it around, 2 bottles of beer on the wall.
#
# 2 bottles of beer on the wall, 2 bottles of beer.
# Take one down and pass it around, 1 bottle of beer on the wall.
#
# 1 bottle of beer on the wall, 1 bottle of beer.
# Take one down and pass it around, no more bottles of beer on the wall.
#
# No more bottles of beer on the wall, no more bottles of beer.
# Go to the store and buy some more, 99 bottles of beer on the wall.
#
# Example
# [ "99 bottles of beer on the wall, 99 bottles of beer.",
#   "Take one down and pass it around, 98 bottles of beer on the wall.",
#   "98 bottles of beer on the wall, 98 bottles of beer.",
#
#   ...and so on...
#
#   "3 bottles of beer on the wall, 3 bottles of beer.",
#   "Take one down and pass it around, 2 bottles of beer on the wall.",
#   "2 bottles of beer on the wall, 2 bottles of beer.",
#   "Take one down and pass it around, 1 bottle of beer on the wall.",
#   "1 bottle of beer on the wall, 1 bottle of beer.",
#   "Take one down and pass it around, no more bottles of beer on the wall.",
#   "No more bottles of beer on the wall, no more bottles of beer.",
#   "Go to the store and buy some more, 99 bottles of beer on the wall." ]
# STRINGSALGORITHMS
def sing():
    l = []
    for i in range(99, 1, -1):
        l.append(f'{i} bottles of beer on the wall, {i} bottles of beer.')
        l.append(f'Take one down and pass it around, {i-1} {"bottles" if i-1 != 1 else "bottle"} of beer on the wall.')
    l.append('1 bottle of beer on the wall, 1 bottle of beer.')
    l.append(f'Take one down and pass it around, no more bottles of beer on the wall.')
    return l + ['No more bottles of beer on the wall, no more bottles of beer.', 'Go to the store and buy some more, 99 bottles of beer on the wall.']

# 2383. Minimum Hours of Training to Win a Competition
# You are entering a competition, and are given two positive integers initialEnergy and initialExperience denoting your initial energy and initial experience respectively.
#
# You are also given two 0-indexed integer arrays energy and experience, both of length n.
#
# You will face n opponents in order. The energy and experience of the ith opponent is denoted by energy[i] and experience[i] respectively. When you face an opponent, you need to have both strictly greater experience and energy to defeat them and move to the next opponent if available.
#
# Defeating the ith opponent increases your experience by experience[i], but decreases your energy by energy[i].
#
# Before starting the competition, you can train for some number of hours. After each hour of training, you can either choose to increase your initial experience by one, or increase your initial energy by one.
#
# Return the minimum number of training hours required to defeat all n opponents.
#
#
#
# Example 1:
#
# Input: initialEnergy = 5, initialExperience = 3, energy = [1,4,3,2], experience = [2,6,3,1]
# Output: 8
# Explanation: You can increase your energy to 11 after 6 hours of training, and your experience to 5 after 2 hours of training.
# You face the opponents in the following order:
# - You have more energy and experience than the 0th opponent so you win.
#   Your energy becomes 11 - 1 = 10, and your experience becomes 5 + 2 = 7.
# - You have more energy and experience than the 1st opponent so you win.
#   Your energy becomes 10 - 4 = 6, and your experience becomes 7 + 6 = 13.
# - You have more energy and experience than the 2nd opponent so you win.
#   Your energy becomes 6 - 3 = 3, and your experience becomes 13 + 3 = 16.
# - You have more energy and experience than the 3rd opponent so you win.
#   Your energy becomes 3 - 2 = 1, and your experience becomes 16 + 1 = 17.
# You did a total of 6 + 2 = 8 hours of training before the competition, so we return 8.
# It can be proven that no smaller answer exists.
# Example 2:
#
# Input: initialEnergy = 2, initialExperience = 4, energy = [1], experience = [3]
# Output: 0
# Explanation: You do not need any additional energy or experience to win the competition, so we return 0.
#
#
# Constraints:
#
# n == energy.length == experience.length
# 1 <= n <= 100
# 1 <= initialEnergy, initialExperience, energy[i], experience[i] <= 100
class Solution:
    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:
        hours = 0
        for i in range(len(energy)):
            while initialEnergy <= energy[i] or initialExperience <= experience[i]:
                hours += 1
                if initialEnergy <= energy[i]:
                    initialEnergy += 1
                else:
                    initialExperience += 1
            initialEnergy -= energy[i]
            initialExperience += experience[i]
        return hours

# PatternCraft - Visitor
# The Visitor Design Pattern can be used, for example, to determine how an attack deals a different amount of damage to a unit in the StarCraft game.
#
# The pattern consists of delegating the responsibility to a different class.
#
# When a unit takes damage it can tell the visitor what to do with itself.
#
# Your Task
# Complete the code so that when a Tank attacks a Marine it takes 21 damage and when a Tank attacks a Marauder it takes 32 damage.
#
# The Marine's initial health should be set to 100 and the Marauder's health should be set to 125.
#
# You have 3 classes:
#
# Marine: has a health property and accept(visitor) method
# Marauder: has a health property and accept(visitor) method
# TankBullet: the visitor class. Has visitLight(unit) and visitArmored(unit) methods
# Ressources
# PatternCraft > Visitor
# SourceMaking > Visitor
# Wikipedia > Visitor
# PatternCraft series
# State Pattern
# Strategy Pattern
# Visitor Pattern
# Decorator Pattern
# Adapter Pattern
# Command Pattern
# The original PatternCraft series (by John Lindquist) is a collection of Youtube videos that explains some of the design patterns and how they are used (or could be) on StarCraft.
#
# DESIGN PATTERNSFUNDAMENTALS
class Marine:
    def __init__(self):
        self.health = 100

    def accept(self, visitor):
        self.health -= 21


class Marauder:
    def __init__(self):
        self.health = 125

    def accept(self, visitor):
        self.health -= 32


class TankBullet:
    def visit_light(self, unit):
        unit.health -= 21

    def visit_armored(self, unit):
        unit.health -= 32

# 4. Median of Two Sorted Arrays
# Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.
#
# The overall run time complexity should be O(log (m+n)).
#
#
#
# Example 1:
#
# Input: nums1 = [1,3], nums2 = [2]
# Output: 2.00000
# Explanation: merged array = [1,2,3] and median is 2.
# Example 2:
#
# Input: nums1 = [1,2], nums2 = [3,4]
# Output: 2.50000
# Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.
#
#
# Constraints:
#
# nums1.length == m
# nums2.length == n
# 0 <= m <= 1000
# 0 <= n <= 1000
# 1 <= m + n <= 2000
# -106 <= nums1[i], nums2[i] <= 106
# Solution 1 My solution - O((m + n)log(m + n)) / O(m + n)
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        l = nums1 + nums2
        l.sort()
        if len(l) % 2 == 0:
            return (l[len(l) // 2] + l[len(l) // 2 - 1]) / 2
        return l[len(l) // 2]
# Solution 2 Two pointers - O(m + n) / O(m + n)
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        l, x, y = [], 0, 0
        while x < len(nums1) and y < len(nums2):
            if nums1[x] > nums2[y]:
                l.append(nums2[y])
                y += 1
            else:
                l.append(nums1[x])
                x += 1
        while x < len(nums1):
            l.append(nums1[x])
            x += 1
        while y < len(nums2):
            l.append(nums2[y])
            y += 1
        if len(l) % 2 == 0:
            return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2
        return l[len(l) // 2]
# Solution 3 Binary Search - O(log(min(m, n))) / O(1)
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        if len(nums1) > len(nums2):
            nums1, nums2 = nums2, nums1
        m, n = len(nums1), len(nums2)
        low, high = 0, m
        while low <= high:
            middleX = (low + high) // 2
            middleY = (m + n + 1) // 2 - middleX
            maxX = float('-inf') if middleX == 0 else nums1[middleX - 1]
            maxY = float('-inf') if middleY == 0 else nums2[middleY - 1]
            minX = float('inf') if middleX == m else nums1[middleX]
            minY = float('inf') if middleY == n else nums2[middleY]
            if maxX <= minY and maxY <= minX:
                if (m + n) % 2 == 0:
                    return (max(maxX, maxY) + min(minX, minY)) / 2
                else:
                    return max(maxX, maxY)
            elif maxX > minY:
                high = middleX - 1
            else:
                low = middleX + 1

# MinMaxMin: Bounded Nums
# Given an unsorted array of integers, find the smallest number in the array, the largest number in the array, and the smallest number between the two array bounds that is not in the array.
#
# For instance, given the array [-1, 4, 5, -23, 24], the smallest number is -23, the largest number is 24, and the smallest number between the array bounds is -22. You may assume the input is well-formed.
#
# You solution should return an array [smallest, minimumAbsent, largest]
#
# The smallest integer should be the integer from the array with the lowest value.
#
# The largest integer should be the integer from the array with the highest value.
#
# The minimumAbsent is the smallest number between the largest and the smallest number that is not in the array.
#
# minMinMax([-1, 4, 5, -23, 24]); //[-23, -22, 24]
# minMinMax([1, 3, -3, -2, 8, -1]); //[-3, 0, 8]
# minMinMax([2, -4, 8, -5, 9, 7]); //[-5, -3,9]
# ARRAYS
def min_min_max(arr):
    mi, ma = min(arr), max(arr)
    mid = mi
    while True:
        mid += 1
        if mid not in arr:
            break
    return [mi, mid, ma]

# 392. Is Subsequence
# Solution
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        try:
            for i in s:
                t = t[t.index(i)+1:]
            return True
        except:
            return False

# Solution 2
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        if len(s) == 0:
            return True
        for i in range(len(t)):
            if s:
                if t[i] == s[0]:
                    s = s[1:]
        return len(s) == 0
# Solution 3 Two Pointers
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        x, y = 0, 0
        while x < len(s) and y < len(t):
            if t[y] == s[x]:
                x += 1
            y += 1
        return x == len(s)

# Least Larger
# Task
# Given an array of numbers and an index, return either the index of the smallest number that is larger than the element at the given index, or -1 if there is no such index ( or, where applicable, Nothing or a similarly empty value ).
#
# Notes
# Multiple correct answers may be possible. In this case, return any one of them.
# The given index will be inside the given array.
# The given array will, therefore, never be empty.
#
# Example
# least_larger( [4, 1, 3, 5, 6], 0 )  ->  3
# least_larger( [4, 1, 3, 5, 6], 4 )  -> -1
# ALGORITHMSARRAYS
def least_larger(a, i):
    top, ans = float('inf'), -1
    for x in range(len(a)):
        if a[x] > a[i]:
            if top > abs(a[i] - a[x]):
                top, ans = abs(a[i] - a[x]), x
    return ans

# 203. Remove Linked List Elements
# Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.
#
#
#
# Example 1:
#
#
# Input: head = [1,2,6,3,4,5,6], val = 6
# Output: [1,2,3,4,5]
# Example 2:
#
# Input: head = [], val = 1
# Output: []
# Example 3:
#
# Input: head = [7,7,7,7], val = 7
# Output: []
#
#
# Constraints:
#
# The number of nodes in the list is in the range [0, 104].
# 1 <= Node.val <= 50
# 0 <= val <= 50
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        dummy = ListNode(None, next=head)
        prev, cur = dummy, head
        while cur:
            if cur.val == val:
                prev.next = cur.next
            else:
                prev = cur
            cur = cur.next
        return dummy.next

# 1048. Longest String Chain
# You are given an array of words where each word consists of lowercase English letters.
#
# wordA is a predecessor of wordB if and only if we can insert exactly one letter anywhere in wordA without changing the order of the other characters to make it equal to wordB.
#
# For example, "abc" is a predecessor of "abac", while "cba" is not a predecessor of "bcad".
# A word chain is a sequence of words [word1, word2, ..., wordk] with k >= 1, where word1 is a predecessor of word2, word2 is a predecessor of word3, and so on. A single word is trivially a word chain with k == 1.
#
# Return the length of the longest possible word chain with words chosen from the given list of words.
#
#
#
# Example 1:
#
# Input: words = ["a","b","ba","bca","bda","bdca"]
# Output: 4
# Explanation: One of the longest word chains is ["a","ba","bda","bdca"].
# Example 2:
#
# Input: words = ["xbc","pcxbcf","xb","cxbc","pcxbc"]
# Output: 5
# Explanation: All the words can be put in a word chain ["xb", "xbc", "cxbc", "pcxbc", "pcxbcf"].
# Example 3:
#
# Input: words = ["abcd","dbqca"]
# Output: 1
# Explanation: The trivial word chain ["abcd"] is one of the longest word chains.
# ["abcd","dbqca"] is not a valid word chain because the ordering of the letters is changed.
#
#
# Constraints:
#
# 1 <= words.length <= 1000
# 1 <= words[i].length <= 16
# words[i] only consists of lowercase English letters.
class Solution:
    def longestStrChain(self, words: List[str]) -> int:
        d = {}
        words.sort(key=len)
        for i in words:
            d[i] = max(d.get(i[:j] + i[j + 1:], 0) + 1 for j in range(len(i)))
        return max(d.values())

# Delta Bits
# Complete the function to determine the number of bits required to convert integer A to integer B (where A and B >= 0)
#
# The upper limit for A and B is 216, int.MaxValue or similar.
#
# For example, you can change 31 to 14 by flipping the 4th and 0th bit:
#
#  31  0 0 0 1 1 1 1 1
#  14  0 0 0 0 1 1 1 0
# ---  ---------------
# bit  7 6 5 4 3 2 1 0
# Thus 31 and 14 should return 2.
#
# BITSBINARYALGORITHMS
def convert_bits(a, b):
    return bin(a ^ b).count('1')

# 566. Reshape the Matrix
# In MATLAB, there is a handy function called reshape which can reshape an m x n matrix into a new one with a different size r x c keeping its original data.
#
# You are given an m x n matrix mat and two integers r and c representing the number of rows and the number of columns of the wanted reshaped matrix.
#
# The reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were.
#
# If the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.
#
#
#
# Example 1:
#
#
# Input: mat = [[1,2],[3,4]], r = 1, c = 4
# Output: [[1,2,3,4]]
# Example 2:
#
#
# Input: mat = [[1,2],[3,4]], r = 2, c = 4
# Output: [[1,2],[3,4]]
#
#
# Constraints:
#
# m == mat.length
# n == mat[i].length
# 1 <= m, n <= 100
# -1000 <= mat[i][j] <= 1000
# 1 <= r, c <= 300
class Solution:
    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:
        if len(mat) * len(mat[0]) != r * c:
            return mat
        ans, x, y = [[0] * c for i in range(r)], 0, 0
        for i in range(len(mat)):
            for j in range(len(mat[0])):
                ans[x][y] = mat[i][j]
                y += 1
                if y == c:
                    x += 1
                    y = 0
        return ans

# Simple elevator
# There is a house with 4 levels. In that house there is an elevator. You can program this elevator to go up or down, depending on what button the user touches inside the elevator.
#
# Valid levels must be only these numbers: 0,1,2,3
#
# Valid buttons must be only these strings: '0','1','2','3'
#
# Possible return values are these numbers: -3,-2,-1,0,1,2,3
#
# If the elevator is on the ground floor(0th level) and the user touches button '2' the elevator must go 2 levels up, so our function must return 2.
#
# If the elevator is on the 3rd level and the user touches button '0' the elevator must go 3 levels down, so our function must return -3.
#
# If the elevator is on the 2nd level, and the user touches button '2' the elevator must remain on the same level, so we return 0.
#
# We cannot endanger the lives of our passengers, so if we get erronous inputs, our elevator must remain on the same level. So for example:
#
# goto(2,'4') must return 0, because there is no button '4' in the elevator.
# goto(4,'0') must return 0, because there is no level 4.
# goto(3,undefined) must return 0.
# goto(undefined,'2') must return 0.
# goto([],'2') must return 0 because the type of the input level is array instead of a number.
# goto(3,{}) must return 0 because the type of the input button is object instead of a string.
# STATE MACHINESFUNDAMENTALS
def goto(level, button):
    if level not in (0, 1, 2, 3) or button not in ['0', '1', '2', '3']:
        return 0
    if level > int(button):
        return int(button) - level
    return abs(level - int(button))

# 389. Find the Difference
# You are given two strings s and t.
#
# String t is generated by random shuffling string s and then add one more letter at a random position.
#
# Return the letter that was added to t.
#
#
#
# Example 1:
#
# Input: s = "abcd", t = "abcde"
# Output: "e"
# Explanation: 'e' is the letter that was added.
# Example 2:
#
# Input: s = "", t = "y"
# Output: "y"
#
#
# Constraints:
#
# 0 <= s.length <= 1000
# t.length == s.length + 1
# s and t consist of lowercase English letters.
class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        x, y = {}, {}
        for i in s:
            x[i] = x.get(i, 0) + 1
        for i in t:
            if i not in x:
                return i
            y[i] = y.get(i, 0) + 1
            if y[i] > x[i]:
                return i

# User class for Banking System
# A company is opening a bank, but the coder who is designing the user class made some errors. They need you to help them.
#
# You must include the following:
# Note: These are NOT steps to code the class
#
# A withdraw method
# Subtracts money from balance
# One parameter, money to withdraw
# Raise a ValueError if there isn't enough money to withdraw
# Return a string with name and balance(see examples)
# A check method
# Adds money to balance
# Two parameters, other user and money
# Other user will always be valid
# Raise a ValueError if other user doesn't have enough money
# Raise a ValueError if checking_account isn't true for other user
# Return a string with name and balance plus other name and other balance(see examples)
# An add_cash method
# Adds money to balance
# One parameter, money to add
# Return a string with name and balance(see examples)
# Additional Notes:
#
# Checking_account should be stored as a boolean
# No input numbers will be negative
# Output must end with a period
# Float numbers will not be used so, balance should be integer
# No currency will be used
# Examples:
#
# Jeff = User('Jeff', 70, True)
# Joe = User('Joe', 70, False)
#
# Jeff.withdraw(2) # Returns 'Jeff has 68.'
#
# Joe.check(Jeff, 50) # Returns 'Joe has 120 and Jeff has 18.'
#
# Jeff.check(Joe, 80) # Raises a ValueError
#
# Joe.checking_account = True # Enables checking for Joe
#
# Jeff.check(Joe, 80) # Returns 'Jeff has 98 and Joe has 40'
#
# Joe.check(Jeff, 100) # Raises a ValueError
#
# Jeff.add_cash(20.00) # Returns 'Jeff has 118.'
# Good Luck
# FUNDAMENTALSOBJECT-ORIENTED PROGRAMMING
class User(object):
    def __init__(self, name, balance, checking_account):
        self.name = name
        self.balance = balance
        self.checking_account = checking_account
    #Happy coding
    def withdraw(self, money):
        if money > self.balance:
            raise ValueError
        self.balance -= money
        return f'{self.name} has {self.balance}.'
    def check(self, user, money):
        if user.balance < money:
            raise ValueError
        if not user.checking_account:
            raise ValueError
        self.balance += money
        user.balance -= money
        return f'{self.name} has {self.balance} and {user.name} has {user.balance}.'
    def add_cash(self, money):
        self.balance += money
        return f'{self.name} has {self.balance}.'

# 520. Detect Capital
# We define the usage of capitals in a word to be right when one of the following cases holds:
#
# All letters in this word are capitals, like "USA".
# All letters in this word are not capitals, like "leetcode".
# Only the first letter in this word is capital, like "Google".
# Given a string word, return true if the usage of capitals in it is right.
#
#
#
# Example 1:
#
# Input: word = "USA"
# Output: true
# Example 2:
#
# Input: word = "FlaG"
# Output: false
#
#
# Constraints:
#
# 1 <= word.length <= 100
# word consists of lowercase and uppercase English letters.
# Solution 1
class Solution:
    def detectCapitalUse(self, word: str) -> bool:
        flag = False
        for i in word:
            if ord(i) > 90:
                flag = False
                break
            else:
                flag = True
        if flag:
            return True
        for i in range(1, len(word)):
            if ord(word[i]) < 97:
                return False
        return True
# Solution 2
class Solution:
    def detectCapitalUse(self, word: str) -> bool:
        if word == word.upper():
            return True
        if word == word.title():
            return True
        if word == word.lower():
            return True
        return False

# Recursive Replication
# You need to design a recursive function called replicate which will receive arguments times and number.
#
# The function should return an array containing repetitions of the number argument. For instance, replicate(3, 5) should return [5,5,5]. If the times argument is negative, return an empty array.
#
# As tempting as it may seem, do not use loops to solve this problem.
#
# RECURSIONALGORITHMS
@countcalls
def replicate(times, number, ans=[]):
    if times < 0:
        return []
    if times == 0:
        return ans
    return replicate(times - 1, number, ans + [number])

# Flick Switch
# Task
# Create a function that always returns True for every item in a given list. However, if an element is the word "flick", switch to always returning the opposite boolean value.
#
# Examples
# ["codewars", "flick", "code", "wars"] ➞ [True, False, False, False]
#
# ['flick', 'chocolate', 'adventure', 'sunshine'] ➞[False, False, False, False]
#
# ['bicycle', 'jarmony', 'flick', 'sheep', 'flick'] ➞ [True, True, False, False, True]
# Notes
# "flick" will always be given in lowercase.
# A list may contain multiple flicks.
# Switch the boolean value on the same element as the flick itself.
# FUNDAMENTALSLISTS
def flick_switch(lst):
    ans, flag = [], True
    for i in lst:
        if i == 'flick':
            flag = not flag
        ans.append(flag)
    return ans

# A Letter's Best Friend
# Task
# Given a string, return if a given letter always appears immediately before another given letter.
#
# Worked Example
# ("he headed to the store", "h", "e") ➞ True
#
# # All occurences of "h": ["he", "headed", "the"]
# # All occurences of "h" have an "e" after it.
# # Return True
#
# ('abcdee', 'e', 'e') ➞ False
#
# # For first "e" we can get "ee"
# # For second "e" we cannot have "ee"
# # Return False
# Examples
# ("i found an ounce with my hound", "o", "u") ➞ True
#
# ("we found your dynamite", "d", "y") ➞ False
# Notes
# All sentences will be given in lowercase.
# FUNDAMENTALSSTRINGS
# Solution
def best_friend(txt, a, b):
    for i in range(len(txt) - 1):
        if txt[i] == a:
            if txt[i + 1] != b:
                return False
    if txt[-1] == a:
        return False
    return True

# 880. Decoded String at Index
# You are given an encoded string s. To decode the string to a tape, the encoded string is read one character at a time and the following steps are taken:
#
# If the character read is a letter, that letter is written onto the tape.
# If the character read is a digit d, the entire current tape is repeatedly written d - 1 more times in total.
# Given an integer k, return the kth letter (1-indexed) in the decoded string.
#
#
#
# Example 1:
#
# Input: s = "leet2code3", k = 10
# Output: "o"
# Explanation: The decoded string is "leetleetcodeleetleetcodeleetleetcode".
# The 10th letter in the string is "o".
# Example 2:
#
# Input: s = "ha22", k = 5
# Output: "h"
# Explanation: The decoded string is "hahahaha".
# The 5th letter is "h".
# Example 3:
#
# Input: s = "a2345678999999999999999", k = 1
# Output: "a"
# Explanation: The decoded string is "a" repeated 8301530446056247680 times.
# The 1st letter is "a".
#
#
# Constraints:
#
# 2 <= s.length <= 100
# s consists of lowercase English letters and digits 2 through 9.
# s starts with a letter.
# 1 <= k <= 109
# It is guaranteed that k is less than or equal to the length of the decoded string.
# The decoded string is guaranteed to have less than 263 letters.
class Solution:
    def decodeAtIndex(self, s: str, k: int) -> str:
        n, i = 0, 0
        while n < k:
            if s[i].isalpha():
                n += 1
            else:
                n *= int(s[i])
            i += 1
        for i in range(i-1, -1, -1):
            if s[i].isdigit():
                n //= int(s[i])
                k %= n
            else:
                if k == 0 or k == n:
                    return s[i]
                n -= 1

# Simple Fun #10: Range Bit Counting
# Task
# You are given two numbers a and b where 0 ≤ a ≤ b. Imagine you construct an array of all the integers from a to b inclusive. You need to count the number of 1s in the binary representations of all the numbers in the array.
#
# Example
# For a = 2 and b = 7, the output should be 11
#
# Given a = 2 and b = 7 the array is: [2, 3, 4, 5, 6, 7]. Converting the numbers to binary, we get [10, 11, 100, 101, 110, 111], which contains 1 + 2 + 1 + 2 + 2 + 3 = 11 1s.
#
# Input/Output
# [input] integer a
# Constraints: 0 ≤ a ≤ b.
#
# [input] integer b
# Constraints: a ≤ b ≤ 100.
#
# [output] an integer
# BITSBINARYALGORITHMS
def range_bit_count(a, b):
    return sum(bin(i).count('1') for i in range(a, b + 1))

# 905. Sort Array By Parity
# Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers.
#
# Return any array that satisfies this condition.
#
#
#
# Example 1:
#
# Input: nums = [3,1,2,4]
# Output: [2,4,3,1]
# Explanation: The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.
# Example 2:
#
# Input: nums = [0]
# Output: [0]
#
#
# Constraints:
#
# 1 <= nums.length <= 5000
# 0 <= nums[i] <= 5000
class Solution:
    def sortArrayByParity(self, nums: List[int]) -> List[int]:
        x, y = 0, len(nums) - 1
        while x < y:
            while x < y and nums[x] & 0x1 == 0:
                x += 1
            while x < y and nums[y] & 0x1 != 0:
                y -= 1
            nums[x], nums[y] = nums[y], nums[x]
        return nums

# MOD 256 without the MOD operator
# MOD 256 without the MOD operator
# The MOD-operator % (aka mod/modulus/remainder):
#
# Returns the remainder of a division operation.
# The sign of the result is the same as the sign of the first operand.
# (Different behavior in Python!)
# The short unbelievable mad story for this kata:
# I wrote a program and needed the remainder of the division by 256. And then it happened: The "5"/"%"-Key did not react. It must be broken! So I needed a way to:
#
# Calculate the remainder of the division by 256 without the %-operator.
# Also here some examples:
#
# Input 254  -> Result 254
# Input 256  -> Result 0
# Input 258  -> Result 2
# Input -258 -> Result -2 (in Python: Result: 254!)
# It is always expected the behavior of the MOD-Operator of the language!
#
# The input number will always between -10000 and 10000.
#
# For some languages the %-operator will be blocked. If it is not blocked and you know how to block it, tell me and I will include it.
#
# For all, who say, this would be a duplicate: No, this is no duplicate! There are two katas, in that you have to write a general method for MOD without %. But this kata is only for MOD 256. And so you can create also other specialized solutions. ;-)
#
# Of course you can use the digit "5" in your solution. :-)
#
# I'm very curious for your solutions and the way you solve it. I found several interesting "funny" ways.
#
# Have fun coding it and please don't forget to vote and rank this kata! :-)
#
# I have also created other katas. Take a look if you enjoyed this kata!
#
# ALGORITHMSFUNDAMENTALSLOGICMATHEMATICSRESTRICTEDPUZZLES
def mod256_without_mod(number):
    if number < 0:
        while number < 0:
            number += 256
        return number
    while number >= 256:
        number -= 256
    return number

# 896. Monotonic Array
# An array is monotonic if it is either monotone increasing or monotone decreasing.
#
# An array nums is monotone increasing if for all i <= j, nums[i] <= nums[j]. An array nums is monotone decreasing if for all i <= j, nums[i] >= nums[j].
#
# Given an integer array nums, return true if the given array is monotonic, or false otherwise.
#
#
#
# Example 1:
#
# Input: nums = [1,2,2,3]
# Output: true
# Example 2:
#
# Input: nums = [6,5,4,4]
# Output: true
# Example 3:
#
# Input: nums = [1,3,2]
# Output: false
#
#
# Constraints:
#
# 1 <= nums.length <= 105
# -105 <= nums[i] <= 105
# Solution
class Solution:
    def isMonotonic(self, nums: List[int]) -> bool:
        return all(i <= j for i,j in zip(nums, nums[1:])) or all(i >= j for i,j in zip(nums, nums[1:]))

# Solution 2
class Solution:
    def isMonotonic(self, nums: List[int]) -> bool:
        cop: int = len(nums) - 1
        count: int = 0
        for i in range(len(nums) - 1):
            if nums[i] <= nums[i + 1]:
                count += 1
            else:
                break
        if cop == count:
            return True
        count: int = 0
        for i in range(len(nums) - 1):
            if nums[i] >= nums[i + 1]:
                count += 1
        return count == cop
# Solution 3
class Solution:
    def isMonotonic(self, nums: List[int]) -> bool:
        cop: list = nums.copy()
        if nums[0] <= nums[-1]:
            nums.sort()
        else:
            nums.sort(reverse=True)
        for i in range(len(nums)):
            if cop[i] != nums[i]:
                return False
        return True
# Solution 3
class Solution:
    def isMonotonic(self, nums: List[int]) -> bool:
        flag: int = 0
        for i in range(1, len(nums)):
            if nums[i] > nums[i - 1]:
                if flag == 0:
                    flag = 1
                elif flag == -1:
                    return False
            if nums[i] < nums[i - 1]:
                if flag == 0:
                    flag = -1
                elif flag == 1:
                    return False
        return True

# Thinkful - Object Drills: Quarks
# Background
# You're modelling the interaction between a large number of quarks and have decided to create a Quark class so you can generate your own quark objects.
#
# Quarks are fundamental particles and the only fundamental particle to experience all four fundamental forces.
#
# Your task
# Your Quark class should allow you to create quarks of any valid color ("red", "blue", and "green") and any valid flavor ('up', 'down', 'strange', 'charm', 'top', and 'bottom').
#
# Every quark has the same baryon_number (BaryonNumber in C#): 1/3.
#
# Every quark should have an .interact() (.Interact() in C#) method that allows any quark to interact with another quark via the strong force. When two quarks interact they exchange colors.
#
# Example
# >>> q1 = Quark("red", "up")
# >>> q1.color
# "red"
# >>> q1.flavor
# "up"
# >>> q2 = Quark("blue", "strange")
# >>> q2.color
# "blue"
# >>> q2.baryon_number
# 0.3333333333333333
# >>> q1.interact(q2)
# >>> q1.color
# "blue"
# >>> q2.color
# "red"
# FUNDAMENTALSOBJECT-ORIENTED PROGRAMMING
class Quark(object):
    def __init__(self, color, flavor):
        self.color = color
        self.flavor = flavor
        self.baryon_number = 0.3333333333333333
    def color(self):
        return self.color
    def flavor(self):
        return self.flavor
    def interact(self, user):
        self.color, user.color = user.color, self.color
        self.flavor, user.flavor = user.flavor, self.flavor

# 1025. Divisor Game
# Alice and Bob take turns playing a game, with Alice starting first.
#
# Initially, there is a number n on the chalkboard. On each player's turn, that player makes a move consisting of:
#
# Choosing any x with 0 < x < n and n % x == 0.
# Replacing the number n on the chalkboard with n - x.
# Also, if a player cannot make a move, they lose the game.
#
# Return true if and only if Alice wins the game, assuming both players play optimally.
#
#
#
# Example 1:
#
# Input: n = 2
# Output: true
# Explanation: Alice chooses 1, and Bob has no more moves.
# Example 2:
#
# Input: n = 3
# Output: false
# Explanation: Alice chooses 1, Bob chooses 1, and Alice has no more moves.
#
#
# Constraints:
#
# 1 <= n <= 1000
class Solution:
    def divisorGame(self, n: int) -> bool:
        return n % 2 == 0

# Email Address Obfuscator
# Many people choose to obfuscate their email address when displaying it on the Web. One common way of doing this is by substituting the @ and . characters for their literal equivalents in brackets.
#
# Example 1:
#
# user_name@example.com
# => user_name [at] example [dot] com
# Example 2:
#
# af5134@borchmore.edu
# => af5134 [at] borchmore [dot] edu
# Example 3:
#
# jim.kuback@ennerman-hatano.com
# => jim [dot] kuback [at] ennerman-hatano [dot] com
# Using the examples above as a guide, write a function that takes an email address string and returns the obfuscated version as a string that replaces the characters @ and . with [at] and [dot], respectively.
#
# Notes
#
# Input (email) will always be a string object. Your function should return a string.
# Change only the @ and . characters.
# Email addresses may contain more than one . character.
# Note the additional whitespace around the bracketed literals in the examples!
# STRINGSALGORITHMS
# Solution
def obfuscate(email):
    return email.replace('.', ' [dot] ').replace('@', ' [at] ')

# 557. Reverse Words in a String III
# Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.
#
#
#
# Example 1:
#
# Input: s = "Let's take LeetCode contest"
# Output: "s'teL ekat edoCteeL tsetnoc"
# Example 2:
#
# Input: s = "God Ding"
# Output: "doG gniD"
#
#
# Constraints:
#
# 1 <= s.length <= 5 * 104
# s contains printable ASCII characters.
# s does not contain any leading or trailing spaces.
# There is at least one word in s.
# All the words in s are separated by a single space.
# Solution
class Solution:
    def reverseWords(self, s: str) -> str:
        return ' '.join(i[::-1] for i in s.split())

# Solution 2 - Choising whitespace in split() method. Works faster
class Solution:
    def reverseWords(self, s: str) -> str:
        return ' '.join(i[::-1] for i in s.split(' '))

# Penultimate
# Find the second-to-last element of a list.
#
# The input list will always contain at least two elements.
#
# Example:
#
# penultimate([1,2,3,4])            # => 3
# penultimate("Python is dynamic") # => 'i'
# (courtesy of haskell.org)
#
# LISTSFUNDAMENTALS
def penultimate(a):
    return a[-2]

# 2038. Remove Colored Pieces if Both Neighbors are the Same Color
# There are n pieces arranged in a line, and each piece is colored either by 'A' or by 'B'. You are given a string colors of length n where colors[i] is the color of the ith piece.
#
# Alice and Bob are playing a game where they take alternating turns removing pieces from the line. In this game, Alice moves first.
#
# Alice is only allowed to remove a piece colored 'A' if both its neighbors are also colored 'A'. She is not allowed to remove pieces that are colored 'B'.
# Bob is only allowed to remove a piece colored 'B' if both its neighbors are also colored 'B'. He is not allowed to remove pieces that are colored 'A'.
# Alice and Bob cannot remove pieces from the edge of the line.
# If a player cannot make a move on their turn, that player loses and the other player wins.
# Assuming Alice and Bob play optimally, return true if Alice wins, or return false if Bob wins.
#
#
#
# Example 1:
#
# Input: colors = "AAABABB"
# Output: true
# Explanation:
# AAABABB -> AABABB
# Alice moves first.
# She removes the second 'A' from the left since that is the only 'A' whose neighbors are both 'A'.
#
# Now it's Bob's turn.
# Bob cannot make a move on his turn since there are no 'B's whose neighbors are both 'B'.
# Thus, Alice wins, so return true.
# Example 2:
#
# Input: colors = "AA"
# Output: false
# Explanation:
# Alice has her turn first.
# There are only two 'A's and both are on the edge of the line, so she cannot move on her turn.
# Thus, Bob wins, so return false.
# Example 3:
#
# Input: colors = "ABBBBBBBAAA"
# Output: false
# Explanation:
# ABBBBBBBAAA -> ABBBBBBBAA
# Alice moves first.
# Her only option is to remove the second to last 'A' from the right.
#
# ABBBBBBBAA -> ABBBBBBAA
# Next is Bob's turn.
# He has many options for which 'B' piece to remove. He can pick any.
#
# On Alice's second turn, she has no more pieces that she can remove.
# Thus, Bob wins, so return false.
#
#
# Constraints:
#
# 1 <= colors.length <= 105
# colors consists of only the letters 'A' and 'B'
# Solution 1 - My solution
class Solution:
    def winnerOfGame(self, colors: str) -> bool:
        if len(colors) <= 3:
            return colors == 'AAA'
        alice, bob = 0, 0
        ans = [colors[0]]
        for i in range(1, len(colors)):
            if colors[i] == ans[-1]:
                ans.append(colors[i])
            else:
                if len(ans) > 2:
                    if ans[-1] == 'A':
                        alice += len(ans) - 2
                    else:
                        bob += len(ans) - 2
                ans = [colors[i]]
        if len(ans) > 2:
            if ans[-1] == "A":
                alice += len(ans) - 2
            else:
                bob += len(ans) - 2
        return alice > bob
# Solution 2 - clearer solution
class Solution:
    def winnerOfGame(self, colors: str) -> bool:
        alice, bob = 0, 0
        x, y = 0, 0
        for i in colors:
            if i == "A":
                x += 1
                bob += max(y - 2, 0)
                y = 0
            else:
                y += 1
                alice += max(x - 2, 0)
                x = 0
        alice += max(x - 2, 0)
        bob += max(y - 2, 0)
        return alice > bob

# Binary Calculator
# In this kata you need to write a function that will receive two strings (n1 and n2), each representing an integer as a binary number. A third parameter will be provided (o) as a string representing one of the following operators: add, subtract, multiply.
#
# Your task is to write the calculate function so that it will perform the arithmetic and the result returned should be a string representing the binary result.
#
# Examples:
#
# 1 + 1 === 10
# 10 + 10 === 100
# Negative binary numbers are usually preceded by several 1's. For this kata, negative numbers can be represented with the negative symbol at the beginning of the string.
#
# Examples of negatives:
#
# 1 - 10 === -1
# 10 - 100 === -10
# BINARYALGORITHMS
def calculate(n1, n2, o):
    n1, n2 = int(f'0b{n1}', 2), int(f'0b{n2}', 2)
    op = {'add': n1 + n2, 'subtract': n1 - n2, 'multiply': n1 * n2}
    ans = bin(op[o])[2:]
    return ans if ans[0] != 'b' else '-' + ans[1:]

# Python's Dynamic Classes #1
# Timmy's quiet and calm work has been suddenly stopped by his project manager (let's call him boss) yelling:
#
# - Who named these classes?! Class MyClass? It's ridiculous! I want you to change it to UsefulClass!
#
# Tim sighed, he already knew it's gonna be a long day.
# Few hours later, boss came again:
# Much better - he said - but now I want to change that class name to SecondUsefulClass,
#
# and went off. Although Timmy had no idea why changing name is so important for his boss, he realized, that it's not the end, so he turned to you, his guru, to help him and asked you to prepare some function, which could change name of given class.
# Note: Proposed function should allow only names with alphanumeric chars (upper & lower letters plus ciphers), but starting only with upper case letter. In other case it should raise an exception.
# Disclaimer: there are obviously betters way to check class name than in example cases, but let's stick with that, that Timmy yet has to learn them.
#
#
#
# To easy? Check Python's Dynamic Classes #2 Kata and Python's Dynamic Classes #3 Kata.
#
# FUNDAMENTALSOBJECT-ORIENTED PROGRAMMING
def class_name_changer(cls, new_name):
    if (not new_name
            or new_name[0].islower()
            or new_name[0].isdigit()
            or not new_name.isalnum()):
        raise Exception

    cls.__name__ = new_name

# 1512. Number of Good Pairs
# Given an array of integers nums, return the number of good pairs.
#
# A pair (i, j) is called good if nums[i] == nums[j] and i < j.
#
#
#
# Example 1:
#
# Input: nums = [1,2,3,1,1,3]
# Output: 4
# Explanation: There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed.
# Example 2:
#
# Input: nums = [1,1,1,1]
# Output: 6
# Explanation: Each pair in the array are good.
# Example 3:
#
# Input: nums = [1,2,3]
# Output: 0
#
#
# Constraints:
#
# 1 <= nums.length <= 100
# 1 <= nums[i] <= 100
# Solution 1 - Simple choosing. Speed O(N**2) - Memory O(1)
class Solution:
    def numIdenticalPairs(self, nums: List[int]) -> int:
        count = 0
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                if nums[i] == nums[j]:
                    count += 1
        return count
# Solution 2 - Hash table. Speed O(N) - Memory O(N)
class Solution:
    def numIdenticalPairs(self, nums: List[int]) -> int:
        d, count = {}, 0
        for i in nums:
            if i in d:
                count += d[i]
                d[i] += 1
            else:
                d[i] = 1
        return count

# Cat and Mouse - 2D Version
# You will be given a string (map) featuring a cat "C" and a mouse "m". The rest of the string will be made up of dots (".") The cat can move the given number of moves up, down, left or right, but not diagonally.
#
# You need to find out if the cat can catch the mouse from it's current position and return "Caught!" or "Escaped!" respectively.
#
# Finally, if one of two animals are not present, return "boring without two animals".
#
# Examples
# moves = 5
#
# map =
# ..C......
# .........
# ....m....
#
# returns "Caught!" because the cat can catch the mouse in 4 moves
# moves = 5
#
# map =
# .C.......
# .........
# ......m..
#
# returns "Escaped!" because the cat cannot catch the mouse in  5 moves
# GRAPH THEORYALGORITHMS
def cat_mouse(map_, moves):
    if "C" not in map_ or "m" not in map_:
        return "boring without two animals"
    map_ =  map_.split('\n')
    for i in range(len(map_)):
        if "C" in map_[i]:
            cp, cr = map_[i].index("C") + 1, i + 1
        if "m" in map_[i]:
            mp, mr = map_[i].index("m") + 1, i + 1
    hunt_moves = abs(max(mr, cr) - min(mr, cr)) + abs(max(cp, mp) - min(cp, mp))
    return "Escaped!" if hunt_moves > moves else "Caught!"

# 706. Design HashMap
# Design a HashMap without using any built-in hash table libraries.
#
# Implement the MyHashMap class:
#
# MyHashMap() initializes the object with an empty map.
# void put(int key, int value) inserts a (key, value) pair into the HashMap. If the key already exists in the map, update the corresponding value.
# int get(int key) returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.
# void remove(key) removes the key and its corresponding value if the map contains the mapping for the key.
#
#
# Example 1:
#
# Input
# ["MyHashMap", "put", "put", "get", "get", "put", "get", "remove", "get"]
# [[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]
# Output
# [null, null, null, 1, -1, null, 1, null, -1]
#
# Explanation
# MyHashMap myHashMap = new MyHashMap();
# myHashMap.put(1, 1); // The map is now [[1,1]]
# myHashMap.put(2, 2); // The map is now [[1,1], [2,2]]
# myHashMap.get(1);    // return 1, The map is now [[1,1], [2,2]]
# myHashMap.get(3);    // return -1 (i.e., not found), The map is now [[1,1], [2,2]]
# myHashMap.put(2, 1); // The map is now [[1,1], [2,1]] (i.e., update the existing value)
# myHashMap.get(2);    // return 1, The map is now [[1,1], [2,1]]
# myHashMap.remove(2); // remove the mapping for 2, The map is now [[1,1]]
# myHashMap.get(2);    // return -1 (i.e., not found), The map is now [[1,1]]
#
#
# Constraints:
#
# 0 <= key, value <= 106
# At most 104 calls will be made to put, get, and remove.
# Solution 1 - My solution with two lists
class MyHashMap:

    def __init__(self):
        self.ke = []
        self.va = []

    def put(self, key: int, value: int) -> None:
        if key in self.ke:
            self.va[self.ke.index(key)] = value
        else:
            self.ke.append(key)
            self.va.append(value)

    def get(self, key: int) -> int:
        if key not in self.ke:
            return -1
        return self.va[self.ke.index(key)]

    def remove(self, key: int) -> None:
        if key in self.ke:
            x = self.ke.index(key)
            self.va.pop(x)
            self.ke.remove(key)

        # Your MyHashMap object will be instantiated and called as such:
# obj = MyHashMap()
# obj.put(key,value)
# param_2 = obj.get(key)
# obj.remove(key)

# Solution 2 - Making big lists with index/value
class MyHashMap:

    def __init__(self):
        self.ans = [None] * 1000001

    def put(self, key: int, value: int) -> None:
        self.ans[key] = value

    def get(self, key: int) -> int:
        x = self.ans[key]
        return x if x != None else -1

    def remove(self, key: int) -> None:
        self.ans[key] = None

# Your MyHashMap object will be instantiated and called as such:
# obj = MyHashMap()
# obj.put(key,value)
# param_2 = obj.get(key)
# obj.remove(key)

# International Morse Code Encryption
# Write a function that will encrypt a given sentence into International Morse Code, both the input and out puts will be strings.
#
# Characters should be separated by a single space. Words should be separated by a triple space.
#
# For example, "HELLO WORLD" should return -> ".... . .-.. .-.. --- .-- --- .-. .-.. -.."
#
# To find out more about Morse Code follow this link: https://en.wikipedia.org/wiki/Morse_code
#
# A preloaded object/dictionary/hash called CHAR_TO_MORSE will be provided to help convert characters to Morse Code.
#
# FUNDAMENTALS
from preloaded import CHAR_TO_MORSE
def encryption(string):
    return ' '.join(CHAR_TO_MORSE.get(i, i) for i in string)

# 229. Majority Element II
# Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.
#
#
#
# Example 1:
#
# Input: nums = [3,2,3]
# Output: [3]
# Example 2:
#
# Input: nums = [1]
# Output: [1]
# Example 3:
#
# Input: nums = [1,2]
# Output: [1,2]
#
#
# Constraints:
#
# 1 <= nums.length <= 5 * 104
# -109 <= nums[i] <= 109
#
#
# Follow up: Could you solve the problem in linear time and in O(1) space?
class Solution:
    def majorityElement(self, nums: List[int]) -> List[int]:
        d, x = {}, len(nums) // 3
        for i in nums:
            d[i] = d.get(i, 0) + 1
        count = []
        for i in d:
            if d[i] > x:
                count += [i]
        return count

# It is written in the stars
# Were you ever interested in the phenomena of astrology, star signs, tarot, voodoo ? (ok not voodoo that's too spooky)...
# Task:
# Your job for today is to finish the star_sign function by finding the astrological sign, given the birth details as a Date object.
# Start and end dates for zodiac signs vary on different resources so we will use this table to get consistent results:
#
# Aquarius ------ 21 January - 19 February
# Pisces --------- 20 February - 20 March
# Aries ---------- 21 March - 20 April
# Taurus -------- 21 April - 21 May
# Gemini -------- 22 May - 21 June
# Cancer -------- 22 June - 22 July
# Leo ------------- 23 July - 23 August
# Virgo ----------- 24 August - 23 September
# Libra ----------- 24 September - 23 October
# Scorpio -------- 24 October - 22 November
# Sagittarius ---- 23 November - 21 December
# Capricorn ----- 22 December - 20 January
#
# Test info: 100 random tests (dates range from January 1st 1940 until now)
# DATE TIMEPUZZLES
def star_sign(date):
    m, d = date.month, date.day
    signs = [(1,20,"Capricorn"), (2,19,"Aquarius"), (3,20,"Pisces"), (4,20,"Aries"),
            (5,21,"Taurus"), (6,21,"Gemini"), (7,22,"Cancer"), (8,23,"Leo"),
            (9,23,"Virgo"), (10,23,"Libra"), (11,22,"Scorpio"), (12,21,"Sagittarius"),
            (12,31,"Capricorn")]
    for i in range(len(signs)):
        if signs[i][0] == m:
            if d <= signs[i][1]:
                return signs[i][2]
            return signs[i + 1][2]

# 1380. Lucky Numbers in a Matrix
# Given an m x n matrix of distinct numbers, return all lucky numbers in the matrix in any order.
#
# A lucky number is an element of the matrix such that it is the minimum element in its row and maximum in its column.
#
#
#
# Example 1:
#
# Input: matrix = [[3,7,8],[9,11,13],[15,16,17]]
# Output: [15]
# Explanation: 15 is the only lucky number since it is the minimum in its row and the maximum in its column.
# Example 2:
#
# Input: matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]]
# Output: [12]
# Explanation: 12 is the only lucky number since it is the minimum in its row and the maximum in its column.
# Example 3:
#
# Input: matrix = [[7,8],[1,2]]
# Output: [7]
# Explanation: 7 is the only lucky number since it is the minimum in its row and the maximum in its column.
#
#
# Constraints:
#
# m == mat.length
# n == mat[i].length
# 1 <= n, m <= 50
# 1 <= matrix[i][j] <= 105.
# All elements in the matrix are distinct.
# Solution
class Solution:
    def luckyNumbers (self, matrix: List[List[int]]) -> List[int]:
        ans = []
        for i in range(len(matrix[0])):
            top, cop = 0, 0
            for j in range(len(matrix)):
                if matrix[j][i] > cop:
                    cop = matrix[j][i]
                    if matrix[j][i] == min(matrix[j]):
                        top = matrix[j][i]
                    else:
                        top = 0
            if top > 0:
                ans.append(top)
        return ans

# Product of the main diagonal of a square matrix.
# Given a list of rows of a square matrix, find the product of the main diagonal.
#
# Examples:
#
# main_diagonal_product([[1,0],[0,1]]) => 1
#
# main_diagonal_product([[1,2,3],[4,5,6],[7,8,9]]) => 45
# http://en.wikipedia.org/wiki/Main_diagonal
#
# MATRIXLINEAR ALGEBRAALGORITHMS
import math
def main_diagonal_product(mat):
    return math.prod(mat[i][i] for i in range(len(mat)))

# 1636. Sort Array by Increasing Frequency
# # Given an array of integers nums, sort the array in increasing order based on the frequency of the values. If multiple values have the same frequency, sort them in decreasing order.
# #
# # Return the sorted array.
# #
# #
# #
# # Example 1:
# #
# # Input: nums = [1,1,2,2,2,3]
# # Output: [3,1,1,2,2,2]
# # Explanation: '3' has a frequency of 1, '1' has a frequency of 2, and '2' has a frequency of 3.
# # Example 2:
# #
# # Input: nums = [2,3,1,3,2]
# # Output: [1,3,3,2,2]
# # Explanation: '2' and '3' both have a frequency of 2, so they are sorted in decreasing order.
# # Example 3:
# #
# # Input: nums = [-1,1,-6,4,5,-6,1,4,1]
# # Output: [5,-1,4,4,-6,-6,1,1,1]
# #
# #
# # Constraints:
# #
# # 1 <= nums.length <= 100
# # -100 <= nums[i] <= 100
# Solution 1, My solution - HashTable
class Solution:
    def frequencySort(self, nums: List[int]) -> List[int]:
        d, ans = {}, []
        for i in nums:
            d[i] = d.get(i, 0) + 1
        while d:
            top, rep = 0, float('inf')
            for i in d:
                if d[i] < rep:
                    top, rep = i, d[i]
                elif d[i] == rep:
                    x = max(top, i)
                    top, rep = x, d[x]
            del d[top]
            ans += [top] * rep
        return ans
# Solution 2 - HashTable Optimized
class Solution:
    def frequencySort(self, nums: List[int]) -> List[int]:
        d = {}
        for i in nums:
            d[i] = d.get(i, 0) + 1
        return sorted(nums, key=lambda x: (d[x], -x))

# Excel sheet column numbers
# Write a function
#
# titleToNumber(title) or title_to_number(title) or titleToNb title ...
#
# (depending on the language)
#
# that given a column title as it appears in an Excel sheet, returns its corresponding column number. All column titles will be uppercase.
#
# Examples:
#
# titleTonumber('A') === 1
# titleTonumber('Z') === 26
# titleTonumber('AA') === 27
# Note for Clojure:
# Don't use Java Math/pow (even with bigint) because there is a loss of precision
# when the length of "title" is growing.
# Write your own function "exp [x n]".
# FUNDAMENTALSALGORITHMS
def title_to_number(title):
    count = 0
    for i in range(len(title)):
        x = ord(title[i]) - 64
        count += x * max(26 ** (len(title) - i - 1), 1)
    return count

# 1979. Find Greatest Common Divisor of Array
# Given an integer array nums, return the greatest common divisor of the smallest number and largest number in nums.
#
# The greatest common divisor of two numbers is the largest positive integer that evenly divides both numbers.
#
#
#
# Example 1:
#
# Input: nums = [2,5,6,9,10]
# Output: 2
# Explanation:
# The smallest number in nums is 2.
# The largest number in nums is 10.
# The greatest common divisor of 2 and 10 is 2.
# Example 2:
#
# Input: nums = [7,5,6,8,3]
# Output: 1
# Explanation:
# The smallest number in nums is 3.
# The largest number in nums is 8.
# The greatest common divisor of 3 and 8 is 1.
# Example 3:
#
# Input: nums = [3,3]
# Output: 3
# Explanation:
# The smallest number in nums is 3.
# The largest number in nums is 3.
# The greatest common divisor of 3 and 3 is 3.
#
#
# Constraints:
#
# 2 <= nums.length <= 1000
# 1 <= nums[i] <= 1000
# Solution - Using math formula: a*b // lcd(a,b) Speed O(N) Memory O(1)
class Solution:
    def findGCD(self, nums: List[int]) -> int:
        mi, ma = float('inf'), 0
        for i in nums:
            if i > ma:
                ma = i
            if i < mi:
                mi = i
        lcd = 1
        while True:
            if ma * lcd % mi == 0:
                lcd *= ma
                break
            lcd += 1
        return ma * mi // lcd

# Survive the attack
# Given two Arrays in which values are the power of each soldier, return true if you survive the attack or false if you perish.
#
# CONDITIONS
#
# Each soldier attacks the opposing soldier in the same index of the array. The survivor is the number with the highest value.
# If the value is the same they both perish
# If one of the values is empty(different array lengths) the non-empty value soldier survives.
# To survive the defending side must have more survivors than the attacking side.
# In case there are the same number of survivors in both sides, the winner is the team with the highest initial attack power. If the total attack power of both sides is the same return true.
# The initial attack power is the sum of all the values in each array.
# EXAMPLES
#
# attackers=[ 1, 3, 5, 7 ]   defenders=[ 2, 4, 6, 8 ]
# //0 survivors                4 survivors
# //return true
#
#
# attackers=[ 1, 3, 5, 7 ]   defenders=[ 2, 4 ]
# //2 survivors  (16 damage)   2 survivors (6 damage)
# //return false
#
# attackers=[ 1, 3, 5, 7 ]   defenders=[ 2, 4, 0, 8 ]
# //1 survivors                3 survivors
# //return true
#
# ARRAYS
def is_defended(attackers, defenders):
    init1, init2 = sum(attackers), sum(defenders)
    for i in range(min(len(attackers), len(defenders))):
        if attackers[i] > defenders[i]:
            defenders[i] = 0
        elif attackers[i] < defenders[i]:
            attackers[i] = 0
        else:
            attackers[i], defenders[i] = 0, 0
    x, y = sum(1 for i in attackers if i > 0), sum(1 for i in defenders if i > 0)
    if x == y:
        return init1 <= init2
    return x < y

# 34. Find First and Last Position of Element in Sorted Array
# Given an array of integers nums sorted in non-decreasing order,
# find the starting and ending position of a given target value.
#
# If target is not found in the array, return [-1, -1].
#
# You must write an algorithm with O(log n) runtime complexity.
#
#
#
# Example 1:
#
# Input: nums = [5,7,7,8,8,10], target = 8
# Output: [3,4]
# Example 2:
#
# Input: nums = [5,7,7,8,8,10], target = 6
# Output: [-1,-1]
# Example 3:
#
# Input: nums = [], target = 0
# Output: [-1,-1]
#
#
# Constraints:
#
# 0 <= nums.length <= 105
# -109 <= nums[i] <= 109
# nums is a non-decreasing array.
# -109 <= target <= 109
# Solution 2 - My solution with daily task
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        if len(nums) == 0:
            return [-1, -1]
        ans, l, r = [-1, -1], 0, len(nums) - 1
        while l <= r:
            m = (l + r) // 2
            if nums[m] == target:
                ans[0] = m
                r = m - 1
            elif nums[m] < target:
                l = m + 1
            else:
                r = m - 1
        if ans[0] == -1:
            return ans
        l, r = 0, len(nums) - 1
        while l <= r:
            m = (l + r) // 2
            if nums[m] == target:
                ans[1] = m
                l = m + 1
            elif nums[m] < target:
                l = m + 1
            else:
                r = m - 1
        return ans

# Weight of its Contents
# Welcome to the Mathematics gameshow. I'm your host, Apex Rhombus, and it's time for the lightning round!
#
# Today we'll talk about a hypothetical bottle. This entire bottle weighs 120 grams. Its contents weigh twice as much as the bottle itself. What, may I ask, do the contents weigh?
#
# ...Did you guess 80 grams? Correct! Now that you've got that idea, I'm gonna ask you that question in 10 different ways so you'd better get ready!
#
# Let's make a contentWeight function that takes in two parameters: bottleWeight and scale. This function will return the weight of the contents inside the bottle.
#
# bottleWeight will be an integer representing the weight of the entire bottle (contents included).
#
# scale will be a string that you will need to parse. It will tell you how the content weight compares to the weight of the bottle by itself. 2 times larger, 6 times larger, and 15 times smaller would all be valid strings (smaller and larger are the only comparison words).
#
# The first test case has been filled out for you. Good luck!
#
# ALGORITHMSMATHEMATICS
def content_weight(bottle_weight, scale):
    x = bottle_weight / (int(scale.split()[0]) + 1)
    if scale.endswith('larger'):
        return x * int(scale.split()[0])
    return bottle_weight - x * int(scale.split()[0])

# 2068. Check Whether Two Strings are Almost Equivalent
# Two strings word1 and word2 are considered almost equivalent if the differences between the frequencies of each letter from 'a' to 'z' between word1 and word2 is at most 3.
#
# Given two strings word1 and word2, each of length n, return true if word1 and word2 are almost equivalent, or false otherwise.
#
# The frequency of a letter x is the number of times it occurs in the string.
#
#
#
# Example 1:
#
# Input: word1 = "aaaa", word2 = "bccb"
# Output: false
# Explanation: There are 4 'a's in "aaaa" but 0 'a's in "bccb".
# The difference is 4, which is more than the allowed 3.
# Example 2:
#
# Input: word1 = "abcdeef", word2 = "abaaacc"
# Output: true
# Explanation: The differences between the frequencies of each letter in word1 and word2 are at most 3:
# - 'a' appears 1 time in word1 and 4 times in word2. The difference is 3.
# - 'b' appears 1 time in word1 and 1 time in word2. The difference is 0.
# - 'c' appears 1 time in word1 and 2 times in word2. The difference is 1.
# - 'd' appears 1 time in word1 and 0 times in word2. The difference is 1.
# - 'e' appears 2 times in word1 and 0 times in word2. The difference is 2.
# - 'f' appears 1 time in word1 and 0 times in word2. The difference is 1.
# Example 3:
#
# Input: word1 = "cccddabba", word2 = "babababab"
# Output: true
# Explanation: The differences between the frequencies of each letter in word1 and word2 are at most 3:
# - 'a' appears 2 times in word1 and 4 times in word2. The difference is 2.
# - 'b' appears 2 times in word1 and 5 times in word2. The difference is 3.
# - 'c' appears 3 times in word1 and 0 times in word2. The difference is 3.
# - 'd' appears 2 times in word1 and 0 times in word2. The difference is 2.
#
#
# Constraints:
#
# n == word1.length == word2.length
# 1 <= n <= 100
# word1 and word2 consist only of lowercase English letters.
class Solution:
    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:
        d1, d2 = {}, {}
        for i in range(len(word1)):
            d1[word1[i]] = d1.get(word1[i], 0) + 1
            d2[word2[i]] = d2.get(word2[i], 0) + 1
        for i in d1:
            if d1[i] > 3:
                if i not in d2:
                    return False
                if abs(d2[i] - d1[i]) > 3:
                    return False
        for i in d2:
            if d2[i] > 3:
                if i not in d1:
                    return False
                if abs(d2[i] - d1[i]) > 3:
                    return False
        return True

# Thinkful - String Drills: Areacode extractor
# Welcome to the Mathematics gameshow. I'm your host, Apex Rhombus, and it's time for the lightning round!
#
# Today we'll talk about a hypothetical bottle. This entire bottle weighs 120 grams. Its contents weigh twice as much as the bottle itself. What, may I ask, do the contents weigh?
#
# ...Did you guess 80 grams? Correct! Now that you've got that idea, I'm gonna ask you that question in 10 different ways so you'd better get ready!
#
# Let's make a contentWeight function that takes in two parameters: bottleWeight and scale. This function will return the weight of the contents inside the bottle.
#
# bottleWeight will be an integer representing the weight of the entire bottle (contents included).
#
# scale will be a string that you will need to parse. It will tell you how the content weight compares to the weight of the bottle by itself. 2 times larger, 6 times larger, and 15 times smaller would all be valid strings (smaller and larger are the only comparison words).
#
# The first test case has been filled out for you. Good luck!
#
# ALGORITHMSMATHEMATICS
# Solution
def content_weight(bottle_weight, scale):
    x = bottle_weight / (int(scale.split()[0]) + 1)
    if scale.endswith('larger'):
        return x * int(scale.split()[0])
    return bottle_weight - x * int(scale.split()[0])

# 867. Transpose Matrix
# Given a 2D integer array matrix, return the transpose of matrix.
#
# The transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix's row and column indices.
#
#
#
#
#
# Example 1:
#
# Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
# Output: [[1,4,7],[2,5,8],[3,6,9]]
# Example 2:
#
# Input: matrix = [[1,2,3],[4,5,6]]
# Output: [[1,4],[2,5],[3,6]]
#
#
# Constraints:
#
# m == matrix.length
# n == matrix[i].length
# 1 <= m, n <= 1000
# 1 <= m * n <= 105
# -109 <= matrix[i][j] <= 109
class Solution:
    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:
        ans, l = [], []
        for i in range(len(matrix[0])):
            for j in range(len(matrix)):
                l.append(matrix[j][i])
                if len(l) == len(matrix):
                    ans.append(l)
                    l = []
        return ans
    
# A Gift Well Spent
# Note: This kata has been inspired by GCJ 2010's "Store credit", where one also has to parse the actual input. If you solved this kata, try that one too. Note that GCJ's version always has a solution, whereas this kata might not.
#
# Story
# You got a gift card for your local store. It has some credit you can use to buy things, but it may be used only for up to two items, and any credit you don't use is lost. You want something for a friend and yourself. Therefore, you want to buy two items which add up the entire gift card value.
#
# Task
# You will get the value of the gift card c and a finite list of item values. You should return a pair of indices that correspond to values that add up to c:
#
# buy(2,[1,1])       = [0,1]
# buy(3,[1,1])       = None
# buy(5,[5,2,3,4,5]) = [1,2]
# The indices start at 0 (1 in COBOL). The first index should always be smaller than the second index. If there are multiple solutions, return the minimum (lexicographically):
#
# buy(5,[1,2,3,4,5]) = [0,3] # the values at [1,2] also adds up to five, but [0,3] < [1,2]
# LISTSALGORITHMS
def buy(x,arr):
    for i in range(len(arr)):
        for j in range(i + 1, len(arr)):
            if arr[i] + arr[j] == x:
                return [i, j]
    return

# 1935. Maximum Number of Words You Can Type
# There is a malfunctioning keyboard where some letter keys do not work. All other keys on the keyboard work properly.
#
# Given a string text of words separated by a single space (no leading or trailing spaces) and a string brokenLetters of all distinct letter keys that are broken, return the number of words in text you can fully type using this keyboard.
#
#
#
# Example 1:
#
# Input: text = "hello world", brokenLetters = "ad"
# Output: 1
# Explanation: We cannot type "world" because the 'd' key is broken.
# Example 2:
#
# Input: text = "leet code", brokenLetters = "lt"
# Output: 1
# Explanation: We cannot type "leet" because the 'l' and 't' keys are broken.
# Example 3:
#
# Input: text = "leet code", brokenLetters = "e"
# Output: 0
# Explanation: We cannot type either word because the 'e' key is broken.
#
#
# Constraints:
#
# 1 <= text.length <= 104
# 0 <= brokenLetters.length <= 26
# text consists of words separated by a single space without any leading or trailing spaces.
# Each word only consists of lowercase English letters.
# brokenLetters consists of distinct lowercase English letters.
class Solution:
    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:
        count = 0
        for i in text.split():
            top = 0
            for j in i:
                if j in brokenLetters:
                    top += 1
                    break
            if top > 0:
                count += 1
        return len(text.split()) - count
    
# Hands Up
# Imagine that you have an array of 3 integers each representing different person. Each number can be 0, 1, or 2 which represents the number of hands that person is holding up.
#
# Now imagine there is a sequence which follows these rules:
#
# None of the people have their arms raised at first
# Firstly, a person raises 1 hand; then they raise the second hand; after that they put both hands down - these steps form a cycle
# Person #1 performs these steps all the time, person #2 advances only after person #1 puts their hands down, and person #3 advances only after person #2 puts their hands down
# The first 10 steps of the sequence represented as a table are:
#
# Step   P1   P2   P3
# --------------------
#  0     0    0    0
#  1     1    0    0
#  2     2    0    0
#  3     0    1    0
#  4     1    1    0
#  5     2    1    0
#  6     0    2    0
#  7     1    2    0
#  8     2    2    0
#  9     0    0    1
# Given a number, return an array, containing 3 integers, each representing the number of hands raised by each person at that step, starting from 0.
#
# FUNDAMENTALSALGORITHMS
def get_positions(n):
    ans = [0, 0, 0]
    for i in range(n % 27):
        if ans[0] != 3:
            ans[0] += 1
            if ans[0] == 3:
                ans[0] = 0
                ans[1] += 1
                if ans[1] == 3:
                    ans[1] = 0
                    ans[2] += 1
                    if ans[2] == 3:
                        ans = [0, 0, 0]
    a, b, c = ans
    return a, b, c

# 746. Min Cost Climbing Stairs
# You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.
#
# You can either start from the step with index 0, or the step with index 1.
#
# Return the minimum cost to reach the top of the floor.
#
#
#
# Example 1:
#
# Input: cost = [10,15,20]
# Output: 15
# Explanation: You will start at index 1.
# - Pay 15 and climb two steps to reach the top.
# The total cost is 15.
# Example 2:
#
# Input: cost = [1,100,1,1,1,100,1,1,100,1]
# Output: 6
# Explanation: You will start at index 0.
# - Pay 1 and climb two steps to reach index 2.
# - Pay 1 and climb two steps to reach index 4.
# - Pay 1 and climb two steps to reach index 6.
# - Pay 1 and climb one step to reach index 7.
# - Pay 1 and climb two steps to reach index 9.
# - Pay 1 and climb one step to reach the top.
# The total cost is 6.
#
#
# Constraints:
#
# 2 <= cost.length <= 1000
# 0 <= cost[i] <= 999
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        x, y = 0, 0
        for i in range(2, len(cost) + 1):
            z = min(x + cost[i-1], y + cost[i-2])
            x, y = z, x
        return x

# draw me a chessboard
# A grid is a perfect starting point for many games (Chess, battleships, Candy Crush!).
#
# Making a digital chessboard I think is an interesting way of visualising how loops can work together.
#
# Your task is to write a function that takes two integers rows and columns and returns a chessboard pattern as a two dimensional array.
#
# So chessBoard(6,4) should return an array like this:
#
# [
#     ["O","X","O","X"],
#     ["X","O","X","O"],
#     ["O","X","O","X"],
#     ["X","O","X","O"],
#     ["O","X","O","X"],
#     ["X","O","X","O"]
# ]
# And chessBoard(3,7) should return this:
#
# [
#     ["O","X","O","X","O","X","O"],
#     ["X","O","X","O","X","O","X"],
#     ["O","X","O","X","O","X","O"]
# ]
# The white spaces should be represented by an: 'O'
#
# and the black an: 'X'
#
# The first row should always start with a white space 'O'
#
# PUZZLESFUNDAMENTALSASCII ARTALGORITHMS
def chess_board(rows, columns):
    ans, d = [], {'O': 'X', 'X': 'O'}
    for i in range(rows):
        top = ['O' if i % 2 == 0 else 'X']
        for j in range(1, columns):
            top.append(d[top[-1]])
        ans.append(top)
    return ans

# 1108. Defanging an IP Address
# Given a valid (IPv4) IP address, return a defanged version of that IP address.
#
# A defanged IP address replaces every period "." with "[.]".
#
#
#
# Example 1:
#
# Input: address = "1.1.1.1"
# Output: "1[.]1[.]1[.]1"
# Example 2:
#
# Input: address = "255.100.50.0"
# Output: "255[.]100[.]50[.]0"
#
#
# Constraints:
#
# The given address is a valid IPv4 address.
class Solution:
    def defangIPaddr(self, address: str) -> str:
        return address.replace('.', '[.]')

# Reduce My Fraction
# input:   [numerator, denominator]
# output:  [reduced numerator, reduced denominator]
# example: [45, 120] --> [3, 8]
# All numerators and denominators will be positive integers.
#
# Note: This is an introductory Kata for a series... coming soon!
#
# FUNDAMENTALSRECURSIONALGORITHMS
def reduce_fraction(fraction):
    x, y = fraction
    if x >= y:
        if x % y == 0:
            return x // y, 1
        else:
            for i in range(y - 1, 0, -1):
                if x % i == 0 and y % i == 0:
                    return x // i, y // i
    else:
        if y % x == 0:
            return 1, y // x
        for i in range(x - 1, 0, -1):
            if x % i == 0 and y % i == 0:
                return x // i, y // i

# 1848. Minimum Distance to the Target Element
# Given an integer array nums (0-indexed) and two integers target and start, find an index i such that nums[i] == target and abs(i - start) is minimized. Note that abs(x) is the absolute value of x.
#
# Return abs(i - start).
#
# It is guaranteed that target exists in nums.
#
#
#
# Example 1:
#
# Input: nums = [1,2,3,4,5], target = 5, start = 3
# Output: 1
# Explanation: nums[4] = 5 is the only value equal to target, so the answer is abs(4 - 3) = 1.
# Example 2:
#
# Input: nums = [1], target = 1, start = 0
# Output: 0
# Explanation: nums[0] = 1 is the only value equal to target, so the answer is abs(0 - 0) = 0.
# Example 3:
#
# Input: nums = [1,1,1,1,1,1,1,1,1,1], target = 1, start = 0
# Output: 0
# Explanation: Every value of nums is 1, but nums[0] minimizes abs(i - start), which is abs(0 - 0) = 0.
#
#
# Constraints:
#
# 1 <= nums.length <= 1000
# 1 <= nums[i] <= 104
# 0 <= start < nums.length
# target is in nums.
# Solution 1 - Speed O(N) Memory O(1)
class Solution:
    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:
        top = float('inf')
        for i in range(len(nums)):
            if nums[i] == target and abs(i - start) < top:
                top = abs(i - start)
        return top
# Solution 2 Speed O(N) Memory O(1)
class Solution:
    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:
        l = r = start
        while l >= 0 or r < len(nums):
            if l >= 0 and nums[l] == target:
                return start - l
            if r < len(nums) and nums[r] == target:
                return r - start
            l -= 1
            r += 1

# HTML Generator
# Another rewarding day in the fast-paced world of WebDev. Man, you love your job! But as with any job, somtimes things can get a little tedious. Part of the website you're working on has a very repetitive structure, and writing all the HTML by hand is a bore. Time to automate! You want to write some functions that will generate the HTML for you.
#
# To organize your code, make of all your functions methods of a class called HTMLGen. Tag functions should be named after the tag of the element they create. Each function will take one argument, a string, which is the inner HTML of the element to be created. The functions will return the string for the appropriate HTML element.
#
# For example,
#
# JavaScript:
#
# var g = new HTMLGen();
# var paragraph = g.p('Hello, World!');
# var block = g.div(paragraph);
#
# // The following are now true
# paragraph === '<p>Hello, World!</p>'
# block === '<div><p>Hello, World!</p></div>'
# Python:
#
# g = HTMLGen();
# paragraph = g.p('Hello, World!')
# block = g.div(paragraph)
#
# # The following are now true
# paragraph == '<p>Hello, World!</p>'
# block == '<div><p>Hello, World!</p></div>'
# Your HTMLGen class should have methods to create the following elements:
#
# a
# b
# p
# body
# div
# span
# title
# comment
# Note: The comment method should wrap its argument with an HTML comment. It is the only method whose name does not match an HTML tag. So, g.comment('i am a comment') must produce <!--i am a comment-->.
#
# FUNCTIONAL PROGRAMMINGPUZZLES
class HTMLGen:
    def __init__(self):
        self.tags = {'a': '<a>{}</a>', 'b': '<b>{}</b>',
               'p': '<p>{}</p>', 'body': '<body>{}</body>',
               'div': '<div>{}</div>', 'span': '<span>{}</span>',
               'title': '<title>{}</title>', 'comment': '<!--{}-->'}
    def a(self, content):
        return self.tags['a'].format(content)
    def b(self, content):
        return self.tags['b'].format(content)
    def p(self, content):
        return self.tags['p'].format(content)
    def body(self, content):
        return self.tags['body'].format(content)
    def div(self, content):
        return self.tags['div'].format(content)
    def span(self, content):
        return self.tags['span'].format(content)
    def title(self, content):
        return self.tags['title'].format(content)
    def comment(self, content):
        return self.tags['comment'].format(content)

# 119. Pascal's Triangle II
# Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal's triangle.
# In Pascal's triangle, each number is the sum of the two numbers directly above it as shown:
#
# Example 1:
#
# Input: rowIndex = 3
# Output: [1,3,3,1]
# Example 2:
#
# Input: rowIndex = 0
# Output: [1]
# Example 3:
#
# Input: rowIndex = 1
# Output: [1,1]
#
# Constraints:
# 0 <= rowIndex <= 33
#
# Follow up: Could you optimize your algorithm to use only O(rowIndex) extra space?
# Solution
class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        row = [1]
        for i in range(rowIndex):
            row = [sum(x) for x in zip([0] + row, row + [0])]
        return row
# Solution 2
class Solution(object):
    def getRow(self, r):
        ans = [1]*(r+1);
        up = r
        down = 1
        for i in range(1, r):
            ans[i] = int(ans[i-1]*up/down);
            up = up - 1
            down = down + 1
        return ans;
# Solution 3 Speed O(N), Memory O(1)
class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        row = [1]
        for i in range(rowIndex):
            row = [x + y for x,y in zip([0] + row, row + [0])]
        return row

# Matrix creation
# Create an identity matrix of the specified size( >= 0).
#
# Some examples:
#
# (1)  =>  [[1]]
#
# (2) => [ [1,0],
#          [0,1] ]
#
#        [ [1,0,0,0,0],
#          [0,1,0,0,0],
# (5) =>   [0,0,1,0,0],
#          [0,0,0,1,0],
#          [0,0,0,0,1] ]
# FUNDAMENTALSARRAYSMATRIXLINEAR ALGEBRAMATHEMATICSLANGUAGE FEATURES
def get_matrix(n):
    mat = [[0] * n for j in range(n)]
    for i in range(len(mat)):
        mat[i][i] = 1
    return mat

# 2138. Divide a String Into Groups of Size k
# A string s can be partitioned into groups of size k using the following procedure:
#
# The first group consists of the first k characters of the string, the second group consists of the next k characters of the string, and so on. Each character can be a part of exactly one group.
# For the last group, if the string does not have k characters remaining, a character fill is used to complete the group.
# Note that the partition is done so that after removing the fill character from the last group (if it exists) and concatenating all the groups in order, the resultant string should be s.
#
# Given the string s, the size of each group k and the character fill, return a string array denoting the composition of every group s has been divided into, using the above procedure.
#
#
#
# Example 1:
#
# Input: s = "abcdefghi", k = 3, fill = "x"
# Output: ["abc","def","ghi"]
# Explanation:
# The first 3 characters "abc" form the first group.
# The next 3 characters "def" form the second group.
# The last 3 characters "ghi" form the third group.
# Since all groups can be completely filled by characters from the string, we do not need to use fill.
# Thus, the groups formed are "abc", "def", and "ghi".
# Example 2:
#
# Input: s = "abcdefghij", k = 3, fill = "x"
# Output: ["abc","def","ghi","jxx"]
# Explanation:
# Similar to the previous example, we are forming the first three groups "abc", "def", and "ghi".
# For the last group, we can only use the character 'j' from the string. To complete this group, we add 'x' twice.
# Thus, the 4 groups formed are "abc", "def", "ghi", and "jxx".
#
#
# Constraints:
#
# 1 <= s.length <= 100
# s consists of lowercase English letters only.
# 1 <= k <= 100
# fill is a lowercase English letter.
# Solution 1
class Solution:
    def divideString(self, s: str, k: int, fill: str) -> List[str]:
        ans = []
        for i in range(0, len(s), k):
            it = s[i:i+k]
            if len(it) == k:
                ans += [it]
            else:
                ans += [it + (k - len(it)) * fill]
        return ans
# Solution 2
class Solution:
    def divideString(self, s: str, k: int, fill: str) -> List[str]:
        ans, s = [], s + fill * (k - 1)
        for i in range(0, len(s) - len(s) % k, k):
            ans += [s[i:i+k]]
        return ans
# Solution 3
class Solution:
    def divideString(self, s: str, k: int, fill: str) -> List[str]:
        ans, so = [], s + fill * (k - 1)
        for i in range(0, len(s), k):
            ans += [so[i:i+k]]
        return ans
    
# Thinkful - Number Drills: Rømer temperature
# You're writing an excruciatingly detailed alternate history novel set in a world where Daniel Gabriel Fahrenheit was never born.
#
# Since Fahrenheit never lived the world kept on using the Rømer scale, invented by fellow Dane Ole Rømer to this very day, skipping over the Fahrenheit and Celsius scales entirely.
#
# Your magnum opus contains several thousand references to temperature, but those temperatures are all currently in degrees Celsius. You don't want to convert everything by hand, so you've decided to write a function, celsius_to_romer() that takes a temperature in degrees Celsius and returns the equivalent temperature in degrees Rømer.
#
# For example: celsius_to_romer(24) should return 20.1.
#
# FUNDAMENTALS
def celsius_to_romer(x):
    return (x * (21/40) + 7.5)

# 1475. Final Prices With a Special Discount in a Shop
# You are given an integer array prices where prices[i] is the price of the ith item in a shop.
#
# There is a special discount for items in the shop. If you buy the ith item, then you will receive a discount equivalent to prices[j] where j is the minimum index such that j > i and prices[j] <= prices[i]. Otherwise, you will not receive any discount at all.
#
# Return an integer array answer where answer[i] is the final price you will pay for the ith item of the shop, considering the special discount.
#
#
#
# Example 1:
#
# Input: prices = [8,4,6,2,3]
# Output: [4,2,4,2,3]
# Explanation:
# For item 0 with price[0]=8 you will receive a discount equivalent to prices[1]=4, therefore, the final price you will pay is 8 - 4 = 4.
# For item 1 with price[1]=4 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 4 - 2 = 2.
# For item 2 with price[2]=6 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 6 - 2 = 4.
# For items 3 and 4 you will not receive any discount at all.
# Example 2:
#
# Input: prices = [1,2,3,4,5]
# Output: [1,2,3,4,5]
# Explanation: In this case, for all items, you will not receive any discount at all.
# Example 3:
#
# Input: prices = [10,1,1,6]
# Output: [9,0,1,6]
#
#
# Constraints:
#
# 1 <= prices.length <= 500
# 1 <= prices[i] <= 1000
# Accepted
# 125.1K
# Submissions
# 162.9K
# Acceptance Rate
# 76.8%
# Solution 1 O(N**2) / O(1)
class Solution:
    def finalPrices(self, prices: List[int]) -> List[int]:
        for i in range(len(prices)):
            for j in range(i + 1, len(prices)):
                if prices[j] <= prices[i]:
                    prices[i] = prices[i] - prices[j]
                    break
        return prices
# Solution 2 O(N**2) / O(N)
class Solution:
    def finalPrices(self, prices: List[int]) -> List[int]:
        ans = []
        for i in range(len(prices)):
            top = -1
            for j in range(i + 1, len(prices)):
                if prices[j] <= prices[i]:
                    top = prices[i] - prices[j]
                    break
            if top > -1:
                ans.append(top)
            else:
                ans.append(prices[i])
        return ans
# Solution 3 O(N) / O(N)
class Solution:
    def finalPrices(self, prices: List[int]) -> List[int]:
        res, stack = prices[:], []
        for i, price in enumerate(prices):
            while stack and prices[stack[-1]] >= price:
                res[stack.pop()] -= price
            stack.append(i)
        return res

# Binary Pyramid 101
# Given two numbers m and n, such that 0 ≤ m ≤ n :
# 
# convert all numbers from m to n (inclusive) to binary
# sum them as if they were in base 10
# convert the result to binary
# return as a string
# Example
# 1, 4  -->  1111010
# 
# because:
#     1  // 1 in binary is 1
# +  10  // 2 in binary is 10
# +  11  // 3 in binary is 11
# + 100  // 4 in binary is 100
# -----
#   122  // 122 in binary is 1111010
# MATHEMATICSFUNDAMENTALS
def binary_pyramid(m,n):
    return bin(sum(int(bin(i)[2:]) for i in range(m, n + 1)))[2:]

# 844. Backspace String Compare
# Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character.
#
# Note that after backspacing an empty text, the text will continue empty.
#
#
#
# Example 1:
#
# Input: s = "ab#c", t = "ad#c"
# Output: true
# Explanation: Both s and t become "ac".
# Example 2:
#
# Input: s = "ab##", t = "c#d#"
# Output: true
# Explanation: Both s and t become "".
# Example 3:
#
# Input: s = "a#c", t = "b"
# Output: false
# Explanation: s becomes "c" while t becomes "b".
#
#
# Constraints:
#
# 1 <= s.length, t.length <= 200
# s and t only contain lowercase letters and '#' characters.
#
#
# Follow up: Can you solve it in O(n) time and O(1) space?
class Solution:
    def backspaceCompare(self, s: str, t: str) -> bool:
        x, y = len(s) - 1, len(t) - 1
        top_x, top_y = 0, 0
        while x >= 0 or y >= 0:
            while x >= 0:
                if s[x] == '#':
                    top_x += 1
                    x -= 1
                elif top_x > 0:
                    top_x -= 1
                    x -= 1
                else:
                    break
            while y >= 0:
                if t[y] == '#':
                    top_y += 1
                    y -= 1
                elif top_y > 0:
                    top_y -= 1
                    y -= 1
                else:
                    break
            if x >= 0 and y >= 0 and s[x] != t[y]:
                return False
            if (x >= 0) != (y >= 0):
                return False
            x -= 1
            y -= 1
        return True

# Thinkful - Logic Drills: Umbrella decider
# Write a function take_umbrella() that takes two arguments: a string representing the current weather and a float representing the chance of rain today.
#
# Your function should return True or False based on the following criteria.
#
# You should take an umbrella if it's currently raining or if it's cloudy and the chance of rain is over 0.20.
# You shouldn't take an umbrella if it's sunny unless it's more likely to rain than not.
# The options for the current weather are sunny, cloudy, and rainy.
#
# For example, take_umbrella('sunny', 0.40) should return False.
#
# As an additional challenge, consider solving this kata using only logical operaters and not using any if statements.
#
# FUNDAMENTALS
def take_umbrella(w, r):
    l = [False, True]
    x = w == 'rainy' or (w == 'cloudy' and r > 0.20) or (w == 'sunny' and r > 0.50)
    return l[x]

# 2032. Two Out of Three
# Given three integer arrays nums1, nums2, and nums3, return a distinct array containing all the values that are present in at least two out of the three arrays. You may return the values in any order.
#
#
# Example 1:
#
# Input: nums1 = [1,1,3,2], nums2 = [2,3], nums3 = [3]
# Output: [3,2]
# Explanation: The values that are present in at least two arrays are:
# - 3, in all three arrays.
# - 2, in nums1 and nums2.
# Example 2:
#
# Input: nums1 = [3,1], nums2 = [2,3], nums3 = [1,2]
# Output: [2,3,1]
# Explanation: The values that are present in at least two arrays are:
# - 2, in nums2 and nums3.
# - 3, in nums1 and nums2.
# - 1, in nums1 and nums3.
# Example 3:
#
# Input: nums1 = [1,2,2], nums2 = [4,3,3], nums3 = [5]
# Output: []
# Explanation: No value is present in at least two arrays.
#
#
# Constraints:
#
# 1 <= nums1.length, nums2.length, nums3.length <= 100
# 1 <= nums1[i], nums2[j], nums3[k] <= 100
class Solution:
    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:
        d, ans = {}, []
        for i in set(nums1):
            d[i] = d.get(i, 0) + 1
        for i in set(nums2):
            d[i] = d.get(i, 0) + 1
        for i in set(nums3):
            d[i] = d.get(i, 0) + 1
        for k in d:
            if d[k] > 1:
                ans.append(k)
        return ans

# Are there doubles?
# Your job is to build a function which determines whether or not there are double characters in a string (including whitespace characters). For example aa, !! or   .
#
# You want the function to return true if the string contains double characters and false if not. The test should not be case sensitive; for example both aa & aA return true.
#
# Examples:
#
#   double_check("abca")
#   #returns False
#
#   double_check("aabc")
#   #returns True
#
#   double_check("a 11 c d")
#   #returns True
#
#   double_check("AabBcC")
#   #returns True
#
#   double_check("a b  c")
#   #returns True
#
#   double_check("a b c d e f g h i h k")
#   #returns False
#
#   double_check("2020")
#   #returns False
#
#   double_check("a!@€£#$%^&*()_-+=}]{[|\"':;?/>.<,~")
#   #returns False
# REGULAR EXPRESSIONSFUNDAMENTALS
def double_check(strng):
    strng = strng.lower()
    return not all(x != y for x, y in zip(strng, strng[1:]))

# 884. Uncommon Words from Two Sentences
# A sentence is a string of single-space separated words where each word consists only of lowercase letters.
#
# A word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence.
#
# Given two sentences s1 and s2, return a list of all the uncommon words. You may return the answer in any order.
#
#
#
# Example 1:
#
# Input: s1 = "this apple is sweet", s2 = "this apple is sour"
# Output: ["sweet","sour"]
# Example 2:
#
# Input: s1 = "apple apple", s2 = "banana"
# Output: ["banana"]
#
#
# Constraints:
#
# 1 <= s1.length, s2.length <= 200
# s1 and s2 consist of lowercase English letters and spaces.
# s1 and s2 do not have leading or trailing spaces.
# All the words in s1 and s2 are separated by a single space.
class Solution:
    def uncommonFromSentences(self, s1: str, s2: str) -> List[str]:
        d = {}
        for i in s1.split():
            d[i] = d.get(i, 0) + 1
        for i in s2.split():
            d[i] = d.get(i, 0) + 1
        return [i for i in d if d[i] == 1]

# Pair Zeros
# Task
# For a given list of digits 0 to 9, return a list with the same digits in the same order, but with all 0s paired. Pairing two 0s generates one 0 at the location of the first one.
#
# Examples
# input: [0, 1, 0, 2]
# paired: ^-----^
#     -> [0, 1,   2]
#   kept: ^
#
# input: [0, 1, 0, 0]
# paired: ^-----^
#     -> [0, 1,    0]
#   kept: ^        ^
#
# input: [1, 0, 7, 0, 1]
# paired:    ^-----^
#     -> [1, 0, 7,    1]
#   kept:    ^
#
# input: [0, 1, 7, 0, 2, 2, 0, 0, 1, 0]
# paired: ^--------^        ^--^
#     -> [0, 1, 7,    2, 2, 0,    1, 0]
#   kept: ^                 ^        ^
# Notes
# Pairing happens from left to right. For each pairing, the second 0 will always be paired towards the first ( right to left )
# 0s generated by pairing can NOT be paired again
# ( void where not applicable: ) Don't modify the input array or you may fail to pass the tests
# ALGORITHMSARRAYSFUNDAMENTALSFUNCTIONAL PROGRAMMING
def pair_zeros(arr):
    l, top = arr.copy(), 0
    flag = True
    while top < len(arr):
        if l[top] == 0:
            flag = not flag
            if flag:
                l[top] = None
                continue
        top += 1
    return [i for i in l if i != None]

# 1560. Most Visited Sector in a Circular Track
# Given an integer n and an integer array rounds. We have a circular track which consists of n sectors labeled from 1 to n. A marathon will be held on this track, the marathon consists of m rounds. The ith round starts at sector rounds[i - 1] and ends at sector rounds[i]. For example, round 1 starts at sector rounds[0] and ends at sector rounds[1]
#
# Return an array of the most visited sectors sorted in ascending order.
#
# Notice that you circulate the track in ascending order of sector numbers in the counter-clockwise direction (See the first example).
#
#
#
# Example 1:
#
#
# Input: n = 4, rounds = [1,3,1,2]
# Output: [1,2]
# Explanation: The marathon starts at sector 1. The order of the visited sectors is as follows:
# 1 --> 2 --> 3 (end of round 1) --> 4 --> 1 (end of round 2) --> 2 (end of round 3 and the marathon)
# We can see that both sectors 1 and 2 are visited twice and they are the most visited sectors. Sectors 3 and 4 are visited only once.
# Example 2:
#
# Input: n = 2, rounds = [2,1,2,1,2,1,2,1,2]
# Output: [2]
# Example 3:
#
# Input: n = 7, rounds = [1,3,5,7]
# Output: [1,2,3,4,5,6,7]
#
#
# Constraints:
#
# 2 <= n <= 100
# 1 <= m <= 100
# rounds.length == m + 1
# 1 <= rounds[i] <= n
# rounds[i] != rounds[i + 1] for 0 <= i < m
class Solution(object):
    def mostVisited(self, n, rounds):
        x, y = rounds[0], rounds[-1]
        if x <= y:
            return range(x, y + 1)
        return range(1, y + 1) + range(x, n + 1)

# 584. Find Customer Referee
# Table: Customer
#
# +-------------+---------+
# | Column Name | Type    |
# +-------------+---------+
# | id          | int     |
# | name        | varchar |
# | referee_id  | int     |
# +-------------+---------+
# In SQL, id is the primary key column for this table.
# Each row of this table indicates the id of a customer, their name, and the id of the customer who referred them.
#
#
# Find the names of the customer that are not referred by the customer with id = 2.
#
# Return the result table in any order.
#
# The result format is in the following example.
#
#
#
# Example 1:
#
# Input:
# Customer table:
# +----+------+------------+
# | id | name | referee_id |
# +----+------+------------+
# | 1  | Will | null       |
# | 2  | Jane | null       |
# | 3  | Alex | 2          |
# | 4  | Bill | null       |
# | 5  | Zack | 1          |
# | 6  | Mark | 2          |
# +----+------+------------+
# Output:
# +------+
# | name |
# +------+
# | Will |
# | Jane |
# | Bill |
# | Zack |
# +------+
# Solution MySQL
SELECT name FROM Customer WHERE referee_id <> 2 or referee_id IS NULL

# Solution PostgreSQL
SELECT name FROM Customer WHERE referee_id <> 2 or referee_id IS NULL

# Solution 2 PostgreSQL
SELECT name FROM Customer WHERE referee_id != 2 or referee_id IS NULL

# Jenny the youngest detective
# Jenny is 9 years old. She is the youngest detective in North America. Jenny is a 3rd grader student, so when a new mission comes up, she gets a code to decipher in a form of a sticker (with numbers) in her math notebook and a comment (a sentence) in her writing notebook. All she needs to do is to figure out one word, from there she already knows what to do. And here comes your role - you can help Jenny find out what the word is!
#
# In order to find out what the word is, you should use the sticker (array of 3 numbers) to retrive 3 letters from the comment (string) that create the word.
#
# Each of the numbers in the array refers to the position of a letter in the string, in increasing order.
# Spaces are not places, you need the actual letters. No spaces.
# The returned word should be all lowercase letters.
# if you can't find one of the letters using the index numbers, return "No mission today". Jenny would be very sad, but that's life... :(
# Example: input: [5, 0, 3], "I Love You" output: "ivy" (0 = "i", 3 = "v", 5 = "y")
#
# STRINGSARRAYSALGORITHMSFUNDAMENTALS
def missing(nums, s):
    nums.sort()
    s = s.replace(' ', '').lower()
    if max(nums) >= len(s):
        return 'No mission today'
    return ''.join(s[i] for i in nums)

# Multiply
# This code does not execute properly. Try to figure out why.
#
# DEBUGGINGFUNDAMENTALS
# Solution PostgreSQL
SELECT price * amount AS total FROM items;

# 595. Big Countries
# SQL Schema
# Pandas Schema
# Table: World
#
# +-------------+---------+
# | Column Name | Type    |
# +-------------+---------+
# | name        | varchar |
# | continent   | varchar |
# | area        | int     |
# | population  | int     |
# | gdp         | bigint  |
# +-------------+---------+
# name is the primary key (column with unique values) for this table.
# Each row of this table gives information about the name of a country, the continent to which it belongs, its area, the population, and its GDP value.
#
#
# A country is big if:
#
# it has an area of at least three million (i.e., 3000000 km2), or
# it has a population of at least twenty-five million (i.e., 25000000).
# Write a solution to find the name, population, and area of the big countries.
#
# Return the result table in any order.
#
# The result format is in the following example.
#
#
#
# Example 1:
#
# Input:
# World table:
# +-------------+-----------+---------+------------+--------------+
# | name        | continent | area    | population | gdp          |
# +-------------+-----------+---------+------------+--------------+
# | Afghanistan | Asia      | 652230  | 25500100   | 20343000000  |
# | Albania     | Europe    | 28748   | 2831741    | 12960000000  |
# | Algeria     | Africa    | 2381741 | 37100000   | 188681000000 |
# | Andorra     | Europe    | 468     | 78115      | 3712000000   |
# | Angola      | Africa    | 1246700 | 20609294   | 100990000000 |
# +-------------+-----------+---------+------------+--------------+
# Output:
# +-------------+------------+---------+
# | name        | population | area    |
# +-------------+------------+---------+
# | Afghanistan | 25500100   | 652230  |
# | Algeria     | 37100000   | 2381741 |
# +-------------+------------+---------+
# Solution MySQL
SELECT name, population, area
FROM World
WHERE area >= 3000000 OR population >= 25000000;
# Solution 1 PostgreSQL
SELECT name, population, area
FROM World
WHERE area >= 3000000 OR population >= 25000000;
# Solution 2 Faster PostgreSQL
SELECT name, population, area
FROM World
WHERE area >= 3000000
UNION
SELECT name, population, area
FROM World
WHERE population >= 25000000

# 342. Power of Four
# Given an integer n, return true if it is a power of four. Otherwise, return false.
#
# An integer n is a power of four, if there exists an integer x such that n == 4x.
#
#
#
# Example 1:
#
# Input: n = 16
# Output: true
# Example 2:
#
# Input: n = 5
# Output: false
# Example 3:
#
# Input: n = 1
# Output: true
#
#
# Constraints:
#
# -231 <= n <= 231 - 1
#
#
# Follow up: Could you solve it without loops/recursion?
# Solution
class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        i = 0
        while 4 ** i <= n:
            if 4 ** i == n:
                return True
            i += 1
        return False

# Solution 2
class Solution(object):
    def isPowerOfFour(self, n):
        return n & n-1 == 0 and (n-1) % 3 == 0

# Red Knight
# Red Knight is chasing two pawns. Which pawn will be caught, and where?
#
# Input / Output
# Input will be two integers:
#
# N / n (Ruby) vertical position of Red Knight (0 or 1).
# P / p (Ruby) horizontal position of two pawns (between 2 and 1000000).
# Output has to be a tuple (python, haskell, Rust, prolog, C#), an array (javascript, ruby), an object (java), or a structure (C) with:
#
# "Black" or "White" - which pawn was caught
# Where it was caught (horizontal position)
# Example
# Input = 0, 4
# Output = ("White", 8)
# 1
# 2
# 3
# 0
# 4
# 5
# 6
# 7
# 0
# 1
# Notes
# Red Knight will always start at horizontal position 0.
# The black pawn will always be at the bottom (vertical position 1).
# The white pawn will always be at the top (vertical position 0).
# The pawns move first, and they move simultaneously.
# Red Knight moves 2 squares forward and 1 up or down.
# Pawns always move 1 square forward.
# Both pawns will start at the same horizontal position.
# PUZZLESALGORITHMSFUNDAMENTALS
def red_knight(N, P):
    d = {'White': 'Black', 'Black': 'White'}
    flag = 'White' if N == 0 else 'Black'
    N = 0
    while N < P:
        P += 1
        N += 2
        flag = d[flag]
    return flag, N

# 2859. Sum of Values at Indices With K Set Bits
# You are given a 0-indexed integer array nums and an integer k.
#
# Return an integer that denotes the sum of elements in nums whose corresponding indices have exactly k set bits in their binary representation.
#
# The set bits in an integer are the 1's present when it is written in binary.
#
# For example, the binary representation of 21 is 10101, which has 3 set bits.
#
#
# Example 1:
#
# Input: nums = [5,10,1,5,2], k = 1
# Output: 13
# Explanation: The binary representation of the indices are:
# 0 = 0002
# 1 = 0012
# 2 = 0102
# 3 = 0112
# 4 = 1002
# Indices 1, 2, and 4 have k = 1 set bits in their binary representation.
# Hence, the answer is nums[1] + nums[2] + nums[4] = 13.
# Example 2:
#
# Input: nums = [4,3,2,1], k = 2
# Output: 1
# Explanation: The binary representation of the indices are:
# 0 = 002
# 1 = 012
# 2 = 102
# 3 = 112
# Only index 3 has k = 2 set bits in its binary representation.
# Hence, the answer is nums[3] = 1.
#
#
# Constraints:
#
# 1 <= nums.length <= 1000
# 1 <= nums[i] <= 105
# 0 <= k <= 10
class Solution(object):
    def sumIndicesWithKSetBits(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        ans = 0
        for i in range(len(nums)):
            if bin(i).count('1') == k:
                ans += nums[i]
        return ans

# Distance from the average
# Given a starting list/array of data, it could make some statistical sense to know how much each value differs from the average.
#
# If for example during a week of work you have collected 55,95,62,36,48 contacts for your business, it might be interesting to know the total (296), the average (59.2), but also how much you moved away from the average each single day.
#
# For example on the first day you did something less than the said average (55, meaning -4.2 compared to the average), much more in the second day (95, 35.8 more than the average and so on).
#
# The resulting list/array of differences starting from [55, 95, 62, 36, 48] is thus [4.2, -35.8, -2.8, 23.2, 11.2].
#
# Assuming you will only get valid inputs (ie: only arrays/lists with numbers), create a function to do that, rounding each difference to the second decimal digit (this is not needed in Haskell); extra points if you do so in some smart, clever or concise way :)
#
# With Clojure to round use:
# (defn roundTo2 [n] (/ (Math/round (* n 100.0)) 100.0))
# ARRAYSLISTSSTATISTICSFUNDAMENTALSDATA SCIENCE
def distances_from_average(test_list):
    mean = sum(test_list) / len(test_list)
    return [round(mean - i, 2) for i in test_list]

# 779. K-th Symbol in Grammar
# We build a table of n rows (1-indexed). We start by writing 0 in the 1st row. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10.
#
# For example, for n = 3, the 1st row is 0, the 2nd row is 01, and the 3rd row is 0110.
# Given two integer n and k, return the kth (1-indexed) symbol in the nth row of a table of n rows.
#
#
#
# Example 1:
#
# Input: n = 1, k = 1
# Output: 0
# Explanation: row 1: 0
# Example 2:
#
# Input: n = 2, k = 1
# Output: 0
# Explanation:
# row 1: 0
# row 2: 01
# Example 3:
#
# Input: n = 2, k = 2
# Output: 1
# Explanation:
# row 1: 0
# row 2: 01
#
#
# Constraints:
#
# 1 <= n <= 30
# 1 <= k <= 2n - 1
# Solution 1 - Hamming weight
class Solution(object):
    def kthGrammar(self, n, k):
        return bin(k - 1).count('1') % 2
# Solution 2 Recursive
class Solution(object):
    def kthGrammar(self, n, k):
        if n == 1:
            return 0
        if k % 2 == 0:
            if self.kthGrammar(n-1, k / 2) == 0:
                return 1
            else:
                return 0
        else:
            if self.kthGrammar(n - 1, (k + 1) / 2) == 0:
                return 0
            else:
                return 1

# Fun with lists: indexOf
# Implement the method indexOf (index_of in PHP), which accepts a linked list (head) and a value, and returns the index (zero based) of the first occurrence of that value if exists, or -1 otherwise.
#
# For example: Given the list: 1 -> 2 -> 3 -> 3, and the value 3, indexOf / index_of should return 2.
#
# The linked list is defined as follows:
#
# class Node:
#     def __init__(self, data, next=None):
#         self.data = data
#         self.next = next
# Note: the list may be null and can hold any type of value.
#
# Good luck!
#
# This kata is part of fun with lists series:
#
# Fun with lists: length
# Fun with lists: indexOf
# Fun with lists: lastIndexOf
# Fun with lists: countIf
# Fun with lists: anyMatch + allMatch
# Fun with lists: filter
# Fun with lists: map
# Fun with lists: reduce
# LISTSFUNDAMENTALS
def index_of(head, value):
    top = 0
    while head:
        if type(head.data) == type(value):
            if head.data == value:
                return top
        head = head.next
        top += 1
    return -1

# 944. Delete Columns to Make Sorted
# You are given an array of n strings strs, all of the same length.
#
# The strings can be arranged such that there is one on each line, making a grid.
#
# For example, strs = ["abc", "bce", "cae"] can be arranged as follows:
# abc
# bce
# cae
# You want to delete the columns that are not sorted lexicographically. In the above example (0-indexed), columns 0 ('a', 'b', 'c') and 2 ('c', 'e', 'e') are sorted, while column 1 ('b', 'c', 'a') is not, so you would delete column 1.
#
# Return the number of columns that you will delete.
#
#
#
# Example 1:
#
# Input: strs = ["cba","daf","ghi"]
# Output: 1
# Explanation: The grid looks as follows:
#   cba
#   daf
#   ghi
# Columns 0 and 2 are sorted, but column 1 is not, so you only need to delete 1 column.
# Example 2:
#
# Input: strs = ["a","b"]
# Output: 0
# Explanation: The grid looks as follows:
#   a
#   b
# Column 0 is the only column and is sorted, so you will not delete any columns.
# Example 3:
#
# Input: strs = ["zyx","wvu","tsr"]
# Output: 3
# Explanation: The grid looks as follows:
#   zyx
#   wvu
#   tsr
# All 3 columns are not sorted, so you will delete all 3.
#
#
# Constraints:
#
# n == strs.length
# 1 <= n <= 100
# 1 <= strs[i].length <= 1000
# strs[i] consists of lowercase English letters.
class Solution(object):
    def minDeletionSize(self, strs):
        top = 0
        for i in range(len(strs[0])):
            for j in range(len(strs) - 1):
                if strs[j][i] > strs[j+1][i]:
                    top += 1
                    break
        return top



# Genetic Algorithm Series - #3 Crossover
# In genetic algorithms, crossover is a genetic operator used to vary the programming of chromosomes from one generation to the next.
#
# The one-point crossover consists in swapping one's cromosome part with another in a specific given point. The image bellow shows the crossover being applied on chromosomes 1011011001111 and 1011100100110 with the cut point (index) 4:
#
#
#
# In this kata you have to implement a function crossover that receives two chromosomes chromosome1, chromosome2 and a zero-based index and it has to return an array with the crossover result on both chromosomes [chromosome1, chromosome2].
#
# Example:
# crossover('111000', '000110', 3) should return ['111110', 000000']
#
# See other katas from this series
# Genetic Algorithm Series - #1 Generate
# Genetic Algorithm Series - #2 Mutation
# Genetic Algorithm Series - #3 Crossover
# Genetic Algorithm Series - #4 Get population and fitnesses
# Genetic Algorithm Series - #5 Roulette wheel selection
# This kata is a piece of2 kyuBinary Genetic Algorithm
#
# STRINGSALGORITHMSGENETIC ALGORITHMS
def crossover(chromosome1, chromosome2, index):
    x, y = '', ''
    for i in range(index, len(chromosome1)):
        x += chromosome2[i]
        y += chromosome1[i]
    return [chromosome1[:index] + x, chromosome2[:index] + y]

# 2248. Intersection of Multiple Arrays
# Given a 2D integer array nums where nums[i] is a non-empty array of distinct positive integers, return the list of integers that are present in each array of nums sorted in ascending order.
#
#
# Example 1:
#
# Input: nums = [[3,1,2,4,5],[1,2,3,4],[3,4,5,6]]
# Output: [3,4]
# Explanation:
# The only integers present in each of nums[0] = [3,1,2,4,5], nums[1] = [1,2,3,4], and nums[2] = [3,4,5,6] are 3 and 4, so we return [3,4].
# Example 2:
#
# Input: nums = [[1,2,3],[4,5,6]]
# Output: []
# Explanation:
# There does not exist any integer present both in nums[0] and nums[1], so we return an empty list [].
#
#
# Constraints:
#
# 1 <= nums.length <= 1000
# 1 <= sum(nums[i].length) <= 1000
# 1 <= nums[i][j] <= 1000
# All the values of nums[i] are unique.
# Solution 1
class Solution(object):
    def intersection(self, nums):
        d = {}
        for i in nums:
            for j in i:
                d[j] = d.get(j, 0) + 1
        for i in d.copy():
            if d[i] != len(nums):
                del d[i]
        return sorted(d.keys())
# Solution 2
class Solution(object):
    def intersection(self, nums):
        d = {}
        for i in nums:
            for j in i:
                d[j] = d.get(j, 0) + 1
        top = []
        for i in d:
            if d[i] == len(nums):
                top.append(i)
        return sorted(top)
    
# Fibonacci's FizzBuzz
# Instructions
# The goal of this kata is two-fold:
#
# 1.) You must produce a fibonacci sequence in the form of an array, containing a number of items equal to the input provided.
#
# 2.) You must replace all numbers in the sequence divisible by 3 with Fizz, those divisible by 5 with Buzz, and those divisible by both 3 and 5 with FizzBuzz.
#
# For the sake of this kata, you can assume all input will be a positive integer.
#
# Use Cases
# Return output must be in the form of an array, with the numbers as integers and the replaced numbers (fizzbuzz) as strings.
#
# Examples
# Input:
#
# fibs_fizz_buzz(5)
# Output:
#
# [ 1, 1, 2, 'Fizz', 'Buzz' ]
# Input:
#
# fibs_fizz_buzz(1)
# Output:
#
# [1]
# Input:
#
# fibs_fizz_buzz(20)
# Output:
#
# [1,1,2,"Fizz","Buzz",8,13,"Fizz",34,"Buzz",89,"Fizz",233,377,"Buzz","Fizz",1597,2584,4181,"FizzBuzz"]
# ##Good Luck!##
#
# FUNDAMENTALSALGORITHMS
def fibs_fizz_buzz(n):
    top = []
    x, y = 0, 1
    for i in range(n):
        x, y = y, x + y
        if x % 3 == 0 and x % 5 == 0:
            top.append('FizzBuzz')
        elif x % 3 == 0:
            top.append('Fizz')
        elif x % 5 == 0:
            top.append('Buzz')
        else:
            top.append(x)
    return top

# 2848. Points That Intersect With Cars
# You are given a 0-indexed 2D integer array nums representing the coordinates of the cars parking on a number line. For any index i, nums[i] = [starti, endi] where starti is the starting point of the ith car and endi is the ending point of the ith car.
#
# Return the number of integer points on the line that are covered with any part of a car.
#
#
#
# Example 1:
#
# Input: nums = [[3,6],[1,5],[4,7]]
# Output: 7
# Explanation: All the points from 1 to 7 intersect at least one car, therefore the answer would be 7.
# Example 2:
#
# Input: nums = [[1,3],[5,8]]
# Output: 7
# Explanation: Points intersecting at least one car are 1, 2, 3, 5, 6, 7, 8. There are a total of 7 points, therefore the answer would be 7.
#
#
# Constraints:
#
# 1 <= nums.length <= 100
# nums[i].length == 2
# 1 <= starti <= endi <= 100
# Solution HashSet Speed O(N) - Memory O(N)
class Solution(object):
    def numberOfPoints(self, nums):
        s = set()
        for i in nums:
            for j in range(i[0], i[1] + 1):
                if j not in s:
                    s.add(j)
        return len(s)

# 8 towers
# Marcus was spending his last summer day playing chess with his friend Rose.
#
# Surprisingly, they had a lot of pieces (we suspect Marcus is a part-time thief, but we will leave that aside), and Marcus wondered in how many different positions could 8 towers (rooks) be in the board, without threatening themselves.
#
# Rose (who was smarter) was wondering if there was any relation between the size of the board, and the number of positions.
#
# So, you should help!
#
# Write a function that, given N (positive-only integer) the size of the board , returns the number of different combinations in which these towers can be.
#
# Example:
#
# towerCombination(2) returns 2, because only the following possibilities can be achieved.
#
# | x 0 |
# | 0 x |
#
# | 0 x |
# | x 0 |
# towerCombination(3) returns 6, because only the following possibilities can be achieved.
#
# | x 0 0 |
# | 0 x 0 |
# | 0 0 x |
#
# | x 0 0 |
# | 0 0 x |
# | 0 x 0 |
#
# | 0 x 0 |
# | x 0 0 |
# | 0 0 x |
#
# | 0 x 0 |
# | 0 0 x |
# | x 0 0 |
#
# | 0 0 x |
# | x 0 0 |
# | 0 x 0 |
#
# | 0 0 x |
# | 0 x 0 |
# | x 0 0 |
# ALGORITHMS
import math
def tower_combination(n):
    return math.factorial(n)

# Waiting room
# There's a waiting room with N chairs set in single row. Chairs are consecutively numbered from 1 to N. First is closest to the entrance (which is exit as well).
#
# For some reason people choose a chair in the following way
#
# Find a place as far from other people as possible
# Find a place as close to exit as possible
# All chairs must be occupied before the first person will be served
#
# So it looks like this for 10 chairs and 10 patients
#
# Chairs	1	2	3	4	5	6	7	8	9	10
# Patients	1	7	5	8	3	9	4	6	10	2
# Your task is to find last patient's chair's number.
#
# Input: number of chairs N, an integer greater than 2.
# Output: a positive integer, the last patient's chair number.
# Have fun :)
#
# SORTINGPUZZLESALGORITHMS
def last_chair(n):
    return n - 1

# Convert a linked list to a string
# Convert a linked list to a string
# Related Kata
# Although this Kata is not part of an official Series, you may also want to try out Parse a linked list from a string if you enjoyed this Kata.
#
# Preloaded
# Preloaded for you is a class, struct or derived data type Node ( depending on the language ) used to construct linked lists in this Kata:
#
# class Node():
#     def __init__(self, data, next = None):
#         self.data = data
#         self.next = next
# Prerequisites
# This Kata assumes that you are already familiar with the idea of a linked list. If you do not know what that is, you may want to read this article on Wikipedia. Specifically, the linked lists this Kata is referring to are singly linked lists, where the value of a specific node is stored in its data / $data / Data property, the reference to the next node is stored in its next / $next / Next / next_node property and the terminator for a list is null / NULL / None / nil / nullptr / null().
#
# Task
# Create a function stringify which accepts an argument list / $list and returns a string representation of the list. The string representation of the list starts with the value of the current Node, specified by its data / $data / Data property, followed by a whitespace character, an arrow and another whitespace character (" -> "), followed by the rest of the list. The end of the string representation of a list must always end with null / NULL / None / nil / nullptr / null() ( all caps or all lowercase depending on the language you are undertaking this Kata in ). For example, given the following list:
#
# Node(1, Node(2, Node(3)))
# ... its string representation would be:
#
# "1 -> 2 -> 3 -> None"
# And given the following linked list:
#
# Node(0, Node(1, Node(4, Node(9, Node(16)))))
# ... its string representation would be:
#
# "0 -> 1 -> 4 -> 9 -> 16 -> None"
# Note that null / NULL / None / nil / nullptr / null() itself is also considered a valid linked list. In that case, its string representation would simply be "null" / "NULL" / "None" / "nil" / "nullptr" / @"NULL" / "null()" ( again, depending on the language ).
#
# For the simplicity of this Kata, you may assume that any Node in this Kata may only contain non-negative integer values. For example, you will not encounter a Node whose data / $data / Data property is "Hello World".
#
# Enjoy, and don't forget to check out my other Kata Series :D
#
# LINKED LISTSRECURSIONALGORITHMS
def stringify(node):
    ans = []
    while node:
        ans.append(str(node.data))
        node = node.next
    return ' -> '.join(ans + ['None'])

# Which color is the brightest?
# One of the common ways of representing color is the RGB color model, in which the Red, Green, and Blue primary colors of light are added together in various ways to reproduce a broad array of colors.
#
# One of the ways to determine brightness of a color is to find the value V of the alternative HSV (Hue, Saturation, Value) color model. Value is defined as the largest component of a color:
#
# V = max(R,G,B)
# You are given a list of colors in 6-digit hexidecimal notation #RRGGBB. Return the brightest of these colors!
#
# For example,
#
# brightest(["#001000", "#000000"]) == "#001000"
# brightest(["#ABCDEF", "#123456"]) == "#ABCDEF"
# If there are multiple brightest colors, return the first one:
#
# brightest(["#00FF00", "#FFFF00", "#01130F"]) == "#00FF00"
# Note that both input and output should use upper case for characters A, B, C, D, E, F.
#
# ALGORITHMSSTRINGS
def brightest(colors):
    count, ans = 0, 0
    for j in colors:
        top = 0
        for i in range(1, len(j), 2):
            x = int(j[i], 16) * 16 + int(j[i + 1], 16)
            if top < x:
                top = x
        if top > count:
            count = top
            ans = j
    return ans

# 2549. Count Distinct Numbers on Board
# You are given a positive integer n, that is initially placed on a board. Every day, for 109 days, you perform the following procedure:
#
# For each number x present on the board, find all numbers 1 <= i <= n such that x % i == 1.
# Then, place those numbers on the board.
# Return the number of distinct integers present on the board after 109 days have elapsed.
#
# Note:
#
# Once a number is placed on the board, it will remain on it until the end.
# % stands for the modulo operation. For example, 14 % 3 is 2.
#
#
# Example 1:
#
# Input: n = 5
# Output: 4
# Explanation: Initially, 5 is present on the board.
# The next day, 2 and 4 will be added since 5 % 2 == 1 and 5 % 4 == 1.
# After that day, 3 will be added to the board because 4 % 3 == 1.
# At the end of a billion days, the distinct numbers on the board will be 2, 3, 4, and 5.
# Example 2:
#
# Input: n = 3
# Output: 2
# Explanation:
# Since 3 % 2 == 1, 2 will be added to the board.
# After a billion days, the only two distinct numbers on the board are 2 and 3.
#
#
# Constraints:
#
# 1 <= n <= 100
class Solution(object):
    def distinctIntegers(self, n):
        return max(n - 1, 1)
    
# Tap Code Translation
# Tap Code Translation
# Tap code is a way to communicate using a series of taps and pauses for each letter. In this kata, we will use dots . for the taps and whitespaces for the pauses.
#
# The number of taps needed for each letter matches its coordinates in the following polybius square (note the c/k position). Then you "tap" the row, a pause, then the column. Each letter is separated from others with a pause too.
#
#    1  2  3  4  5
# 1  A  B C\K D  E
# 2  F  G  H  I  J
# 3  L  M  N  O  P
# 4  Q  R  S  T  U
# 5  V  W  X  Y  Z
# Input:
# A lowercase string of a single word (no whitespaces or punctuation, only letters).
#
# Output:
# The encoded string as taps and pauses.
#
# Examples
# text = "dot"
#   "D" = (1, 4) = ". ...."
#   "O" = (3, 4) = "... ...."
#   "T" = (4, 4) = ".... ...."
#
# output: ". .... ... .... .... ...."
#
#
# "example" -> ". ..... ..... ... . . ... .. ... ..... ... . . ....."
# "more"    -> "... .. ... .... .... .. . ....."
# Happy coding!
#
# ALGORITHMSSTRINGSCRYPTOGRAPHYSECURITY
def tap_code_translation(text):
    ans = []
    for i in text:
        x = ord(i) - 96
        if x > 10:
            if x == 11:
                x = 3
            else:
                x -= 1
        first = (x + 4) // 5
        while x > 5:
            x -= 5
        second = x
        ans.append('.' * first + ' ' + '.' * second)
    return ' '.join(ans)

# 1356. Sort Integers by The Number of 1 Bits
# You are given an integer array arr. Sort the integers in the array in ascending order by the number of 1's in their binary representation and in case of two or more integers have the same number of 1's you have to sort them in ascending order.
#
# Return the array after sorting it.
#
#
#
# Example 1:
#
# Input: arr = [0,1,2,3,4,5,6,7,8]
# Output: [0,1,2,4,8,3,5,6,7]
# Explantion: [0] is the only integer with 0 bits.
# [1,2,4,8] all have 1 bit.
# [3,5,6] have 2 bits.
# [7] has 3 bits.
# The sorted array by bits is [0,1,2,4,8,3,5,6,7]
# Example 2:
#
# Input: arr = [1024,512,256,128,64,32,16,8,4,2,1]
# Output: [1,2,4,8,16,32,64,128,256,512,1024]
# Explantion: All integers have 1 bit in the binary representation, you should just sort them in ascending order.
#
#
# Constraints:
#
# 1 <= arr.length <= 500
# 0 <= arr[i] <= 104
# Solution 1 list
class Solution(object):
    def sortByBits(self, arr):
        d, ans = [], []
        for i in arr:
            d.append((i, bin(i).count('1')))
        for i in range(len(d)):
            top, val = float('inf'), float('inf')
            for j in d:
                if j[1] < top:
                    val, top = j[0], j[1]
                elif j[1] == top:
                    if j[0] < val:
                        val, top = j[0], j[1]
            ans.append(val)
            d.remove((val, top))
        return ans
# Solution 2 Hashtable
class Solution(object):
    def sortByBits(self, arr):
        d, ans = {}, []
        for i in arr:
            d[i] = d.get(i, 0) + 1
        while d:
            top, val = float('inf'), float('inf')
            for j in d:
                x = bin(j).count('1')
                if x < top:
                    val, top = j, x
                elif x == top:
                    if j < val:
                        val, top = j, x
            d[val] -= 1
            if d[val] == 0:
                del d[val]
            ans.append(val)
        return ans
# Solution 3 Math with bits
class Solution(object):
    def sortByBits(self, arr):
        for i in range(len(arr)):
            arr[i] += bin(arr[i]).count('1') * 10001
        arr.sort()
        for i in range(len(arr)):
            arr[i] = arr[i] % 10001
        return arr

# Suitcase packing
# Mr. Square is going on a holiday. He wants to bring 2 of his favorite squares with him, so he put them in his rectangle suitcase.
#
# Write a function that, given the size of the squares and the suitcase, return whether the squares can fit inside the suitcase.
#
# fit_in(a,b,m,n)
# a,b are the sizes of the 2 squares
# m,n are the sizes of the suitcase
# Example
# fit_in(1,2,3,2) should return True
# fit_in(1,2,2,1) should return False
# fit_in(3,2,3,2) should return False
# fit_in(1,2,1,2) should return False
# PUZZLES
def fit_in(a,b,m,n):
    return (a + b <= max(m, n)) and (max(a, b) <= min(m, n))

# 2451. Odd String Difference
# You are given an array of equal-length strings words. Assume that the length of each string is n.
#
# Each string words[i] can be converted into a difference integer array difference[i] of length n - 1 where difference[i][j] = words[i][j+1] - words[i][j] where 0 <= j <= n - 2. Note that the difference between two letters is the difference between their positions in the alphabet i.e. the position of 'a' is 0, 'b' is 1, and 'z' is 25.
#
# For example, for the string "acb", the difference integer array is [2 - 0, 1 - 2] = [2, -1].
# All the strings in words have the same difference integer array, except one. You should find that string.
#
# Return the string in words that has different difference integer array.
#
#
#
# Example 1:
#
# Input: words = ["adc","wzy","abc"]
# Output: "abc"
# Explanation:
# - The difference integer array of "adc" is [3 - 0, 2 - 3] = [3, -1].
# - The difference integer array of "wzy" is [25 - 22, 24 - 25]= [3, -1].
# - The difference integer array of "abc" is [1 - 0, 2 - 1] = [1, 1].
# The odd array out is [1, 1], so we return the corresponding string, "abc".
# Example 2:
#
# Input: words = ["aaa","bob","ccc","ddd"]
# Output: "bob"
# Explanation: All the integer arrays are [0, 0] except for "bob", which corresponds to [13, -13].
#
#
# Constraints:
#
# 3 <= words.length <= 100
# n == words[i].length
# 2 <= n <= 20
# words[i] consists of lowercase English letters.
class Solution(object):
    def oddString(self, words):
        l = [0] * len(words)
        for i in range(len(words)):
            ans = []
            for j in range(len(words[i]) - 1):
                ans.append(ord(words[i][j + 1]) - 97 - ord(words[i][j]) - 97)
            l[i] = ans
        for i in range(1, len(l) - 1):
            if l[i - 1] != l[i] and l[i - 1] != l[i + 1]:
                return words[i - 1]
            elif l[i] != l[i - 1] and l[i] != l[i + 1]:
                return words[i]
            elif l[i + 1] != l[i] and l[i + 1] != l[i - 1]:
                return words[i + 1]
            
# Set Reducer
# Set Reducer
# Intro
# These arrays are too long! Let's reduce them!
#
# Description
# Write a function that takes in an array of integers from 0-9, and returns a new array:
#
# Numbers with no identical numbers preceding or following it returns a 1: 2, 4, 9  => 1, 1, 1
# Sequential groups of identical numbers return their count: 6, 6, 6, 6 => 4
# Example
#
# [0, 4, 6, 8, 8, 8, 5, 5, 7] => [1, 1, 1, 3, 2, 1]
#
# Your function should then repeat the process on the resulting array, and on the resulting array of that, until it returns a single integer:
#
# [0, 4, 6, 8, 8, 8, 5, 5, 7] =>  [1, 1, 1, 3, 2, 1] => [3, 1, 1, 1] => [1, 3] => [1, 1] => [2]
#
# When your function has reduced the array to a single integer following these rules, it should return that integer.
#
# [2] => 2
#
# Rules and assertions
# All test arrays will be 2+ in length
# All integers in the test arrays will be positive numbers from 0 - 9
# You should return an integer, not an array with 1 element
# Visual example
# Example of the flow of the algorithm
#
# RECURSIONALGORITHMSLOGICARRAYS
def set_reducer(inp):
    ans, n, count = [], 0, 0
    while n < len(inp):
        if n == len(inp) - 1:
            if count > 0:
                ans.append(count + 1)
            else:
                ans.append(1)
            break
        if inp[n] != inp[n + 1]:
            if count > 0:
                ans.append(count + 1)
                count = 0
            else:
                ans.append(1)
        else:
            count += 1
        n += 1
    while len(ans) > 1:
        l, n, count = [], 0, 0
        while n < len(ans):
            if n == len(ans) - 1:
                if count > 0:
                    l.append(count + 1)
                else:
                    l.append(1)
                break
            if ans[n] != ans[n + 1]:
                if count > 0:
                    l.append(count + 1)
                    count = 0
                else:
                    l.append(1)
            else:
                count += 1
            n += 1
        ans = l
    return ans[0]

# 925. Long Pressed Name
# Your friend is typing his name into a keyboard. Sometimes, when typing a character c, the key might get long pressed, and the character will be typed 1 or more times.
#
# You examine the typed characters of the keyboard. Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed.
#
#
#
# Example 1:
#
# Input: name = "alex", typed = "aaleex"
# Output: true
# Explanation: 'a' and 'e' in 'alex' were long pressed.
# Example 2:
#
# Input: name = "saeed", typed = "ssaaedd"
# Output: false
# Explanation: 'e' must have been pressed twice, but it was not in the typed output.
#
#
# Constraints:
#
# 1 <= name.length, typed.length <= 1000
# name and typed consist of only lowercase English letters.
class Solution(object):
    def isLongPressedName(self, name, typed):
        i = 0
        for j in range(len(typed)):
            if i < len(name) and name[i] == typed[j]:
                i += 1
            elif j == 0 or typed[j] != typed[j - 1]:
                return False
        return i == len(name)
    
# Simple Fun #8: Kill K-th Bit
# Task
# In order to stop the Mad Coder evil genius you need to decipher the encrypted message he sent to his minions. The message contains several numbers that, when typed into a supercomputer, will launch a missile into the sky blocking out the sun, and making all the people on Earth grumpy and sad.
#
# You figured out that some numbers have a modified single digit in their binary representation. More specifically, in the given number n the kth bit from the right was initially set to 0, but its current value might be different. It's now up to you to write a function that will change the kth bit of n back to 0.
#
# Example
# For n = 37 and k = 3, the output should be 33.
#
# 3710 = 1001012 ~> 1000012 = 3310
#
# For n = 37 and k = 4, the output should be 37.
#
# The 4th bit is 0 already (looks like the Mad Coder forgot to encrypt this number), so the answer is still 37.
#
# Input/Output
# [input] integer n
# Constraints: 0 ≤ n ≤ 231 - 1.
#
# [input] integer k
# The 1-based index of the changed bit (counting from the right).
#
# Constraints: 1 ≤ k ≤ 31.
#
# [output] an integer
# More Challenge
# Are you a One-Liner? Please try to complete the kata in one line(no test for it) ;-)
# PUZZLESBITSBINARY
def kill_kth_bit(n, k):
    return n & ~(1 << k - 1)

# 2578. Split With Minimum Sum
# Given a positive integer num, split it into two non-negative integers num1 and num2 such that:
#
# The concatenation of num1 and num2 is a permutation of num.
# In other words, the sum of the number of occurrences of each digit in num1 and num2 is equal to the number of occurrences of that digit in num.
# num1 and num2 can contain leading zeros.
# Return the minimum possible sum of num1 and num2.
#
# Notes:
#
# It is guaranteed that num does not contain any leading zeros.
# The order of occurrence of the digits in num1 and num2 may differ from the order of occurrence of num.
#
#
# Example 1:
#
# Input: num = 4325
# Output: 59
# Explanation: We can split 4325 so that num1 is 24 and num2 is 35, giving a sum of 59. We can prove that 59 is indeed the minimal possible sum.
# Example 2:
#
# Input: num = 687
# Output: 75
# Explanation: We can split 687 so that num1 is 68 and num2 is 7, which would give an optimal sum of 75.
#
#
# Constraints:
#
# 10 <= num <= 109
class Solution(object):
    def splitNum(self, num):
        num = sorted(str(num))
        x, y = '', ''
        for i in range(len(num)):
            if int(i) % 2 == 0:
                x += num[i]
            else:
                y += num[i]
        return int(x) + int(y)

# Help Suzuki count his vegetables....
# Help Suzuki count his vegetables....
#
# Suzuki is the master monk of his monastery so it is up to him to ensure the kitchen is operating at full capacity to feed his students and the villagers that come for lunch on a daily basis.
#
# This week there was a problem with his deliveries and all the vegetables became mixed up. There are two important aspects of cooking in his kitchen, it must be done in harmony and nothing can be wasted. Since the monks are a record keeping people the first order of business is to sort the mixed up vegetables and then count them to ensure there is enough to feed all the students and villagers.
#
# You will be given a string with the following vegetables:
#
# "cabbage", "carrot", "celery", "cucumber", "mushroom", "onion", "pepper", "potato", "tofu", "turnip"
# Return a list of objects (tuple in Python, array in JavaScript, table in COBOL) with the count of each vegetable in descending order. If there are any non vegetables mixed in discard them. If the count of two vegetables is the same sort in reverse alphabetical order (Z->A).
#
# (119, "pepper"),
# (114, "carrot"),
# (113, "turnip"),
# (102, "onion"),
# (101, "tofu"),
# (100, "cabbage"),
# (93, "mushroom"),
# (90, "cucumber"),
# (88, "potato"),
# (80, "celery")
# Please also try the other Kata in this series..
#
# Help Suzuki purchase his Tofu!
# Help Suzuki pack his coal basket!
# Help Suzuki rake his garden!
# Suzuki needs help lining up his students!
# How many stairs will Suzuki climb in 20 years?
# FUNDAMENTALS
def count_vegetables(string):
    string = string.split()
    ans, s = [], {"cabbage", "carrot", "celery",
                     "cucumber", "mushroom", "onion",
                     "pepper", "potato", "tofu", "turnip"}
    ans = [(string.count(i), i) for i in set(string) if i in s]
    return sorted(ans, key=lambda x: (x[0], x[1]), reverse=True)

# 1441. Build an Array With Stack Operations
# You are given an integer array target and an integer n.
#
# You have an empty stack with the two following operations:
#
# "Push": pushes an integer to the top of the stack.
# "Pop": removes the integer on the top of the stack.
# You also have a stream of the integers in the range [1, n].
#
# Use the two stack operations to make the numbers in the stack (from the bottom to the top) equal to target. You should follow the following rules:
#
# If the stream of the integers is not empty, pick the next integer from the stream and push it to the top of the stack.
# If the stack is not empty, pop the integer at the top of the stack.
# If, at any moment, the elements in the stack (from the bottom to the top) are equal to target, do not read new integers from the stream and do not do more operations on the stack.
# Return the stack operations needed to build target following the mentioned rules. If there are multiple valid answers, return any of them.
#
#
#
# Example 1:
#
# Input: target = [1,3], n = 3
# Output: ["Push","Push","Pop","Push"]
# Explanation: Initially the stack s is empty. The last element is the top of the stack.
# Read 1 from the stream and push it to the stack. s = [1].
# Read 2 from the stream and push it to the stack. s = [1,2].
# Pop the integer on the top of the stack. s = [1].
# Read 3 from the stream and push it to the stack. s = [1,3].
# Example 2:
#
# Input: target = [1,2,3], n = 3
# Output: ["Push","Push","Push"]
# Explanation: Initially the stack s is empty. The last element is the top of the stack.
# Read 1 from the stream and push it to the stack. s = [1].
# Read 2 from the stream and push it to the stack. s = [1,2].
# Read 3 from the stream and push it to the stack. s = [1,2,3].
# Example 3:
#
# Input: target = [1,2], n = 4
# Output: ["Push","Push"]
# Explanation: Initially the stack s is empty. The last element is the top of the stack.
# Read 1 from the stream and push it to the stack. s = [1].
# Read 2 from the stream and push it to the stack. s = [1,2].
# Since the stack (from the bottom to the top) is equal to target, we stop the stack operations.
# The answers that read integer 3 from the stream are not accepted.
#
#
# Constraints:
#
# 1 <= target.length <= 100
# 1 <= n <= 100
# 1 <= target[i] <= n
# target is strictly increasing.
class Solution(object):
    def buildArray(self, target, n):
        que, top = [], 0
        for i in range(1, n + 1):
            if top == len(target):
                break
            que.append('Push')
            if i == target[top]:
                top += 1
            else:
                que.append('Pop')
        return que

# Thinkful - Logic Drills: Graceful addition
# You like the way the Python + operator easily handles adding different numeric types, but you need a tool to do that kind of addition without killing your program with a TypeError exception whenever you accidentally try adding incompatible types like strings and lists to numbers.
#
# You decide to write a function my_add() that takes two arguments. If the arguments can be added together it returns the sum. If adding the arguments together would raise an error the function should return None instead.
#
# For example, my_add(1, 3.414) would return 4.414, but my_add(42, " is the answer.") would return None.
#
# Hint: using a try / except statement may simplify this kata.
#
# FUNDAMENTALS
def my_add(a, b):
    try:
        return a + b
    except:
        return

# 171. Excel Sheet Column Number
# Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number.
#
# For example:
#
# A -> 1
# B -> 2
# C -> 3
# ...
# Z -> 26
# AA -> 27
# AB -> 28
# ...
#
#
# Example 1:
#
# Input: columnTitle = "A"
# Output: 1
# Example 2:
#
# Input: columnTitle = "AB"
# Output: 28
# Example 3:
#
# Input: columnTitle = "ZY"
# Output: 701
#
#
# Constraints:
#
# 1 <= columnTitle.length <= 7
# columnTitle consists only of uppercase English letters.
# columnTitle is in the range ["A", "FXSHRXW"].
class Solution(object):
    def titleToNumber(self, chars):
        if len(chars) == 1:
            return ord(chars) - 64
        return (ord(chars[0]) - 64) * (26 ** (len(chars) - 1)) + self.titleToNumber(chars[1:])

# 80's Kids #2: Help ALF Find His Spaceship
# Late last night in the Tanner household, ALF was repairing his spaceship so he might get back to Melmac. Unfortunately for him, he forgot to put on the parking brake, and the spaceship took off during repair. Now it's hovering in space.
#
# ALF has the technology to bring the spaceship home if he can lock on to its location.
#
# Given a map:
#
# ..........
# ..........
# ..........
# .......X..
# ..........
# ..........
# The map will be given in the form of a string with \n separating new lines. The bottom left of the map is [0, 0]. X is ALF's spaceship.
#
# In this example:
#
# findSpaceship(map) => [7, 2]
# If you cannot find the spaceship, the result should be
#
# "Spaceship lost forever."
# Can you help ALF?
#
# Check out my other 80's Kids Katas:
# 80's Kids #1: How Many Licks Does It Take
# 80's Kids #2: Help Alf Find His Spaceship
#
# 80's Kids #3: Punky Brewster's Socks
#
# 80's Kids #4: Legends of the Hidden Temple
#
# 80's Kids #5: You Can't Do That on Television
#
# 80's Kids #6: Rock 'Em, Sock 'Em Robots
#
# 80's Kids #7: She's a Small Wonder
#
# 80's Kids #8: The Secret World of Alex Mack
#
# 80's Kids #9: Down in Fraggle Rock
#
# 80's Kids #10: Captain Planet
#
# ARRAYSALGORITHMS
def find_spaceship(astromap):
    if 'X' not in astromap:
        return 'Spaceship lost forever.'
    astromap = astromap.split('\n')
    for i in astromap:
        if 'X' in i:
            return [i.index('X'), len(astromap) - (astromap.index(i) + 1)]

# 1535. Find the Winner of an Array Game
# Given an integer array arr of distinct integers and an integer k.
#
# A game will be played between the first two elements of the array (i.e. arr[0] and arr[1]). In each round of the game, we compare arr[0] with arr[1], the larger integer wins and remains at position 0, and the smaller integer moves to the end of the array. The game ends when an integer wins k consecutive rounds.
#
# Return the integer which will win the game.
#
# It is guaranteed that there will be a winner of the game.
#
#
#
# Example 1:
#
# Input: arr = [2,1,3,5,4,6,7], k = 2
# Output: 5
# Explanation: Let's see the rounds of the game:
# Round |       arr       | winner | win_count
#   1   | [2,1,3,5,4,6,7] | 2      | 1
#   2   | [2,3,5,4,6,7,1] | 3      | 1
#   3   | [3,5,4,6,7,1,2] | 5      | 1
#   4   | [5,4,6,7,1,2,3] | 5      | 2
# So we can see that 4 rounds will be played and 5 is the winner because it wins 2 consecutive games.
# Example 2:
#
# Input: arr = [3,2,1], k = 10
# Output: 3
# Explanation: 3 will win the first 10 rounds consecutively.
#
#
# Constraints:
#
# 2 <= arr.length <= 105
# 1 <= arr[i] <= 106
# arr contains distinct integers.
# 1 <= k <= 109
# Solution 1 - Speed O(N) / Memory O(1)
class Solution(object):
    def getWinner(self, arr, k):
        top, count = arr[0], 0
        for i in range(1, len(arr)):
            if arr[i] > top:
                top, count = arr[i], 0
            count += 1
            if count == k:
                break
        return top
# Solution 2 - Speed O(N) / Memory O(N * N)
class Solution(object):
    def getWinner(self, arr, k):
        if k >= len(arr):
            return max(arr)
        from collections import defaultdict
        d = defaultdict(int)
        while True:
            x, y = arr[0], arr[1]
            if x > y:
                d[x] += 1
                arr.append(arr.pop(1))
            else:
                d[y] += 1
                arr.append(arr.pop(0))
            if d[arr[0]] == k:
                return arr[0]
            
# ⚠️Fusion Chamber Shutdown⚠️
# A laboratory is testing how atoms react in ionic state during nuclear fusion. They introduce different elements with Hydrogen in high temperature and pressurized chamber. Due to unknown reason the chamber lost its power and the elements in it started precipitating
# Given the number of atoms of Carbon [C],Hydrogen[H] and Oxygen[O] in the chamber. Calculate how many molecules of Water [H2O], Carbon Dioxide [CO2] and Methane [CH4] will be produced following the order of reaction affinity below
#
# 1. Hydrogen reacts with Oxygen   = H2O
# 2. Carbon   reacts with Oxygen   = CO2
# 3. Carbon   reacts with Hydrogen = CH4
# FOR EXAMPLE:
# (C,H,O) = (45,11,100)
# return no. of water, carbon dioxide and methane molecules
# Output should be like:
# (5,45,0)
# FUNDAMENTALS
# Make sure you follow the order of reaction
# output should be H2O,CO2,CH4
def burner(c,h,o):
    water = min(h // 2, o)
    h = max(h - water * 2, 0)
    o = max(o - water, 0)
    carbon = min(c, o // 2)
    o = max(o - carbon * 2, 0)
    c = max(c - carbon, 0)
    methane = min(c, h // 4)
    return (water, carbon, methane)

# Wealth equality, finally!
# The year is 2088 and the Radical Marxist Socialist People's Party (RMSPP) has just seized power in Brazil.
#
# Their first act in power is absolute wealth equality through coercive redistribution.
#
# Create a function that redistributes all wealth equally among all citizens.
#
# Wealth is represented as an array/list where every index is the wealth of a single citizen.
# The function should mutate the input such that every index has the same amount of wealth.
#
# See example:
#
# Input:
# [5, 10, 6]  >>> This represents:
#            # citizen 1 has wealth 5
#            # citizen 2 has wealth 10
#            # citizen 3 has wealth 6
# Should be after the test:
#  [7, 7, 7] >>> wealth has now been equally redistributed
# Info:
#
# MUTATE the input array/list, don't return anything
# Input is guaranteed to hold at least 1 citizen
# Wealth of a citizen will be an integer with minimum equal to 0 (negative wealth is not possible)
# Handling of floating point error will not be tested
# FUNDAMENTALSARRAYS
def redistribute_wealth(wealth):
    mean = sum(wealth) / len(wealth)
    if int(mean) == mean:
        mean = int(mean)
    for i in range(len(wealth)):
        wealth[i] = mean

# 1005. Maximize Sum Of Array After K Negations
# Given an integer array nums and an integer k, modify the array in the following way:
#
# choose an index i and replace nums[i] with -nums[i].
# You should apply this process exactly k times. You may choose the same index i multiple times.
#
# Return the largest possible sum of the array after modifying it in this way.
#
#
#
# Example 1:
#
# Input: nums = [4,2,3], k = 1
# Output: 5
# Explanation: Choose index 1 and nums becomes [4,-2,3].
# Example 2:
#
# Input: nums = [3,-1,0,2], k = 3
# Output: 6
# Explanation: Choose indices (1, 2, 2) and nums becomes [3,1,0,2].
# Example 3:
#
# Input: nums = [2,-3,-1,5,-4], k = 2
# Output: 13
# Explanation: Choose indices (1, 4) and nums becomes [2,3,-1,5,4].
#
#
# Constraints:
#
# 1 <= nums.length <= 104
# -100 <= nums[i] <= 100
# 1 <= k <= 104
class Solution(object):
    def largestSumAfterKNegations(self, nums, k):
        nums.sort()
        top, ind = float('inf'), 0
        for i in range(len(nums)):
            if nums[i] < 1:
                if k > 0:
                    nums[i] = -nums[i]
                    k -= 1
                else:
                    break
            if nums[i] < top:
                top, ind = nums[i], i
        while k > 0:
            nums[ind] = -nums[ind]
            k -= 1
        return sum(nums)
    
# Complete The Pattern #7 - Cyclical Permutation
# Task:
# You have to write a function pattern which creates the following pattern (See Examples) upto desired number of rows.
#
# If the Argument is 0 or a Negative Integer then it should return "" i.e. empty string.
#
# Examples:
# pattern(9):
#
# 123456789
# 234567891
# 345678912
# 456789123
# 567891234
# 678912345
# 789123456
# 891234567
# 912345678
# pattern(5):
#
# 12345
# 23451
# 34512
# 45123
# 51234
# Note: There are no spaces in the pattern
#
# Hint: Use \n in string to jump to next line
#
# ASCII ARTFUNDAMENTALS
def pattern(n):
    if n <= 0:
        return ''
    word, strng = [], [i for i in range(1, n + 1)]
    for i in range(n):
        word.append(''.join(str(i) for i in strng))
        strng = strng[1:] + [strng[0]]
    return '\n'.join(word)

# 2144. Minimum Cost of Buying Candies With Discount
# A shop is selling candies at a discount. For every two candies sold, the shop gives a third candy for free.
#
# The customer can choose any candy to take away for free as long as the cost of the chosen candy is less than or equal to the minimum cost of the two candies bought.
#
# For example, if there are 4 candies with costs 1, 2, 3, and 4, and the customer buys candies with costs 2 and 3, they can take the candy with cost 1 for free, but not the candy with cost 4.
# Given a 0-indexed integer array cost, where cost[i] denotes the cost of the ith candy, return the minimum cost of buying all the candies.
#
#
#
# Example 1:
#
# Input: cost = [1,2,3]
# Output: 5
# Explanation: We buy the candies with costs 2 and 3, and take the candy with cost 1 for free.
# The total cost of buying all candies is 2 + 3 = 5. This is the only way we can buy the candies.
# Note that we cannot buy candies with costs 1 and 3, and then take the candy with cost 2 for free.
# The cost of the free candy has to be less than or equal to the minimum cost of the purchased candies.
# Example 2:
#
# Input: cost = [6,5,7,9,2,2]
# Output: 23
# Explanation: The way in which we can get the minimum cost is described below:
# - Buy candies with costs 9 and 7
# - Take the candy with cost 6 for free
# - We buy candies with costs 5 and 2
# - Take the last remaining candy with cost 2 for free
# Hence, the minimum cost to buy all candies is 9 + 7 + 5 + 2 = 23.
# Example 3:
#
# Input: cost = [5,5]
# Output: 10
# Explanation: Since there are only 2 candies, we buy both of them. There is not a third candy we can take for free.
# Hence, the minimum cost to buy all candies is 5 + 5 = 10.
#
#
# Constraints:
#
# 1 <= cost.length <= 100
# 1 <= cost[i] <= 100
class Solution(object):
    def minimumCost(self, cost):
        cost.sort(reverse=True)
        count = 0
        for i in range(len(cost)):
            if (i + 1) % 3 == 0:
                continue
            count += cost[i]
        return count

# Remove B M W
# It happened decades before Snapchat, years before Twitter and even before Facebook. Targeted advertising was a bit of a challenge back then. One day, the marketing professor at my university told us a story that I am yet to confirm using reliable sources. Nevertheless, I retold the story to dozens of my students already, so, sorry BMW if it is all a big lie.
#
# Allegedly, BMW, in an attempt to target the educated, produced billboard posters featuring the English alphabet with three letters missing: B, M and W. Needless to say, many were confused, some to the extent of road accidents.
#
# Your task is to write a function that takes one parameter str that MUST be a string and removes all capital and small letters B, M and W.
# If data of the wrong data type was sent as a parameter the function must throw an error with the following specific message:
#
# TypeError("This program only works for text.")
# For Python here's a good resource you might need for the exception type ;)
#
# FUNDAMENTALSSTRINGSREGULAR EXPRESSIONS
def remove_bmw(string):
    try:
        return string.replace('B', '').replace('M', '').replace('W', '').replace('b', '').replace('m', '').replace('w', '')
    except:
        return "This program only works for text."
    
# 2047. Number of Valid Words in a Sentence
# A sentence consists of lowercase letters ('a' to 'z'), digits ('0' to '9'), hyphens ('-'), punctuation marks ('!', '.', and ','), and spaces (' ') only. Each sentence can be broken down into one or more tokens separated by one or more spaces ' '.
#
# A token is a valid word if all three of the following are true:
#
# It only contains lowercase letters, hyphens, and/or punctuation (no digits).
# There is at most one hyphen '-'. If present, it must be surrounded by lowercase characters ("a-b" is valid, but "-ab" and "ab-" are not valid).
# There is at most one punctuation mark. If present, it must be at the end of the token ("ab,", "cd!", and "." are valid, but "a!b" and "c.," are not valid).
# Examples of valid words include "a-b.", "afad", "ba-c", "a!", and "!".
#
# Given a string sentence, return the number of valid words in sentence.
#
#
#
# Example 1:
#
# Input: sentence = "cat and  dog"
# Output: 3
# Explanation: The valid words in the sentence are "cat", "and", and "dog".
# Example 2:
#
# Input: sentence = "!this  1-s b8d!"
# Output: 0
# Explanation: There are no valid words in the sentence.
# "!this" is invalid because it starts with a punctuation mark.
# "1-s" and "b8d" are invalid because they contain digits.
# Example 3:
#
# Input: sentence = "alice and  bob are playing stone-game10"
# Output: 5
# Explanation: The valid words in the sentence are "alice", "and", "bob", "are", and "playing".
# "stone-game10" is invalid because it contains digits.
#
#
# Constraints:
#
# 1 <= sentence.length <= 1000
# sentence only contains lowercase English letters, digits, ' ', '-', '!', '.', and ','.
# There will be at least 1 token.
class Solution(object):
    def countValidWords(self, sentence):
        count = 0
        for word in sentence.split():
            top = True
            if len(word) == 1:
                if all(i not in word for i in '01234567489-'):
                    count += 1
                    print(word, 'len 1')
                    continue
            if word.count('!') + word.count(',') + word.count('.') > 1:
                top = False
            if any(word.count(i) > 0 for i in '!,.'):
                if word[-1] not in '!,.':
                    top = False
            if '-' in word:
                if word.count('-') > 1 or word[-1] == '-' or word[0] == '-':
                    top = False
                else:
                    x = word.index('-') 
                    if not word[x-1].isalpha() or not word[x + 1].isalpha():
                        top = False
            if any(i in word for i in '0123456789'):
                top = False
            if top:
                count += 1
        return count
    
# Count cubes in a Menger Sponge
# The Menger Sponge is a three-dimensional fractal, first described by Karl Menger in 1926.
#
# Mengers Sponge (Level 0-3)
#
# An illustration of the iterative construction of a Menger sponge
# A method of constructing a Menger Sponge can be visualized as follows:
#
# Start from a cube (first part of image).
# Scale down the cube so that side length is 1/3 of its original, and make 20 copies of it.
# Place the copies so that they measure the same size as the original cube but without its central parts (next part of image)
# Repeat the process from step 2 for the new smaller cubes from the previous step.
# In each iteration (e.g. repeating the last three steps), the effect will be that parts of the cube will be removed, they'll never be added. Menger sponge will always consist of parts will never be removed, regardless of how many iterations you do.
# An alternative explanation:
#
# Start from a cube (first part of image).
# Devide each cube into 27 equal sized cubes.
# Remove the middle-cube and the six cubes on each side of the group of 27 cubes (second part of image).
# Repeat the process from step 2 for the smaller cubes (third and fourth part of image).
# Task
# In this kata you will create a function that takes non negative integers (from 0 to n) and return the amount of cubes that the Menger Sponge would have in that specific iteration.
#
# Example
# For n = 0, the ouptut should be 1;
# For n = 1, the output should be 20;
# For n = 2, the output should be 400;
# For n = 3, the output should be 8000;
# for n = 4, the output should be 160000;
# For n = 5, the output should be 3200000;
# For n = 6, the output should be 64000000.
# Happy coding!
#
# ALGORITHMSMATHEMATICS
def calc_ms(n):
    return 20 ** n

# Happy Birthday
# It's your best friend's birthday! You already bought a box for the present. Now you want to pack the present in the box. You want to decorate the box with a ribbon and a bow.
#
# But how much cm of ribbon do you need?
#
# Write the method wrap that calculates that!
#
# A box has a height, a width and a length (in cm). The ribbon is crossed on the side with the largest area. Opposite this side (also the side with the largest area) the loop is bound, calculate with 20 cm more tape.
#
#   wrap(17,32,11) => 162
#   wrap(13,13,13) => 124
#   wrap(1,3,1) => 32
# Notes:
# height, width and length will always be >0
#
# The ribbon and the bow on the present looks like this:
#
#
# FUNDAMENTALS
def wrap(h, w, l):
    l = [h, w, l]
    l.sort()
    return l[0] * 4 + l[1] * 2 + l[2] * 2 + 20

# 1759. Count Number of Homogenous Substrings
# Given a string s, return the number of homogenous substrings of s. Since the answer may be too large, return it modulo 109 + 7.
#
# A string is homogenous if all the characters of the string are the same.
#
# A substring is a contiguous sequence of characters within a string.
#
#
#
# Example 1:
#
# Input: s = "abbcccaa"
# Output: 13
# Explanation: The homogenous substrings are listed as below:
# "a"   appears 3 times.
# "aa"  appears 1 time.
# "b"   appears 2 times.
# "bb"  appears 1 time.
# "c"   appears 3 times.
# "cc"  appears 2 times.
# "ccc" appears 1 time.
# 3 + 1 + 2 + 1 + 3 + 2 + 1 = 13.
# Example 2:
#
# Input: s = "xy"
# Output: 2
# Explanation: The homogenous substrings are "x" and "y".
# Example 3:
#
# Input: s = "zzzzz"
# Output: 15
#
#
# Constraints:
#
# 1 <= s.length <= 105
# s consists of lowercase letters.
class Solution(object):
    def countHomogenous(self, s):
        count, top = 0, 1
        for i in range(len(s)):
            if i == len(s) - 1:
                count += (top * (top + 1) // 2) % (10 ** 9 + 7)
                break
            if s[i] == s[i + 1]:
                top += 1
            else:
                count += (top * (top + 1) // 2) % (10 ** 9 + 7)
                top = 1
        return count

# Thinkful - Object Drills: Vectors
# Create a Vector class with x and a y attributes that represent component magnitudes in the x and y directions.
#
# Your vectors should handle vector additon with an .add() method that takes a second vector as an argument and returns a new vector equal to the sum of the vector you call .add() on and the vector you pass in.
#
# For example:
#
# >>> a = Vector(3, 4)
# >>> a.x
# 3
# >>> a.y
# 4
# >>> b = Vector(1, 2)
# >>> c = a.add(b)
# >>> c.x
# 4
# >>> c.y
# 6
# Adding vectors when you have their components is easy: just add the two x components together and the two y components together to get the x and y components for the vector sum.
#
# FUNDAMENTALS
class Vector(object):
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def add(self, v):
        return Vector(self.x + v.x, self.y + v.y)

# 2614. Prime In Diagonal
# You are given a 0-indexed two-dimensional integer array nums.
#
# Return the largest prime number that lies on at least one of the diagonals of nums. In case, no prime is present on any of the diagonals, return 0.
#
# Note that:
#
# An integer is prime if it is greater than 1 and has no positive integer divisors other than 1 and itself.
# An integer val is on one of the diagonals of nums if there exists an integer i for which nums[i][i] = val or an i for which nums[i][nums.length - i - 1] = val.
#
#
# In the above diagram, one diagonal is [1,5,9] and another diagonal is [3,5,7].
#
#
#
# Example 1:
#
# Input: nums = [[1,2,3],[5,6,7],[9,10,11]]
# Output: 11
# Explanation: The numbers 1, 3, 6, 9, and 11 are the only numbers present on at least one of the diagonals. Since 11 is the largest prime, we return 11.
# Example 2:
#
# Input: nums = [[1,2,3],[5,17,7],[9,11,10]]
# Output: 17
# Explanation: The numbers 1, 3, 9, 10, and 17 are all present on at least one of the diagonals. 17 is the largest prime, so we return 17.
#
#
# Constraints:
#
# 1 <= nums.length <= 300
# nums.length == numsi.length
# 1 <= nums[i][j] <= 4*106
class Solution(object):
    def diagonalPrime(self, nums):
        def is_prime(N):
            if N < 2:
                return False
            count = 2
            while count ** 2 <= N:
                if N % count == 0:
                    return False
                count = count + 1
            return True
        top, n = 0, len(nums)
        for i in range(n):
            if is_prime(nums[i][i]):
                top = max(nums[i][i], top)
            if is_prime(nums[i][n -i - 1]):
                top = max(nums[i][n -i - 1], top)
        return top
    
# Simple Fun #40: Timed Reading
# Task
# Timed Reading is an educational tool used in many schools to improve and advance reading skills. A young elementary student has just finished his very first timed reading exercise. Unfortunately he's not a very good reader yet, so whenever he encountered a word longer than maxLength, he simply skipped it and read on.
#
# Help the teacher figure out how many words the boy has read by calculating the number of words in the text he has read, no longer than maxLength.
#
# Formally, a word is a substring consisting of English letters, such that characters to the left of the leftmost letter and to the right of the rightmost letter are not letters.
#
# Example
# For maxLength = 4 and text = "The Fox asked the stork, 'How is the soup?'", the output should be 7
#
# The boy has read the following words: "The", "Fox", "the", "How", "is", "the", "soup".
#
# Input/Output
# [input] integer maxLength
#
# A positive integer, the maximum length of the word the boy can read.
#
# Constraints: 1 ≤ maxLength ≤ 10.
#
# [input] string text
#
# A non-empty string of English letters and punctuation marks.
#
# [output] an integer
#
# The number of words the boy has read.
#
# PUZZLES
def timed_reading(max_length, text):
    l = []
    for i in text.split():
        while i and not i[-1].isalpha():
            i = i[:-1]
        if i:
            l.append(i)
    return sum(len(i) <= max_length for i in l)

# 1683. Invalid Tweets
# Table: Tweets
#
# +----------------+---------+
# | Column Name    | Type    |
# +----------------+---------+
# | tweet_id       | int     |
# | content        | varchar |
# +----------------+---------+
# tweet_id is the primary key (column with unique values) for this table.
# This table contains all the tweets in a social media app.
#
#
# Write a solution to find the IDs of the invalid tweets. The tweet is invalid if the number of characters used in the content of the tweet is strictly greater than 15.
#
# Return the result table in any order.
#
# The result format is in the following example.
#
#
#
# Example 1:
#
# Input:
# Tweets table:
# +----------+----------------------------------+
# | tweet_id | content                          |
# +----------+----------------------------------+
# | 1        | Vote for Biden                   |
# | 2        | Let us make America great again! |
# +----------+----------------------------------+
# Output:
# +----------+
# | tweet_id |
# +----------+
# | 2        |
# +----------+
# Explanation:
# Tweet 1 has length = 14. It is a valid tweet.
# Tweet 2 has length = 32. It is an invalid tweet.
# Solution PostrgreSQL
-- Write your PostgreSQL query statement below
SELECT tweet_id
FROM Tweets
WHERE LENGTH(content) > 15;
# Solution MySQL
# Write your MySQL query statement below
SELECT tweet_id
FROM Tweets
WHERE LENGTH(content) > 15;

# Complete The Pattern #5 - Even Ladder
# Task:
# You have to write a function pattern which creates the following pattern up to n/2 number of lines.
#
# If n <= 1 then it should return "" (i.e. empty string).
# If any odd number is passed as argument then the pattern should last up to the largest even number which is smaller than the passed odd number.
# Examples:
# pattern(8):
#
# 22
# 4444
# 666666
# 88888888
# pattern(5):
#
# 22
# 4444
# Note: There are no spaces in the pattern
#
# Hint: Use \n in string to jump to next line
#
# ASCII ARTFUNDAMENTALS
def pattern(n):
    if n <= 1:
        return ''
    top, x = [], 2
    while n % 2 != 0:
        n -= 1
    for i in range(2, n + 1, 2):
        top.append(str(i) * x)
        x += 2
    return '\n'.join(top)

# 2678. Number of Senior Citizens
# You are given a 0-indexed array of strings details. Each element of details provides information about a given passenger compressed into a string of length 15. The system is such that:
#
# The first ten characters consist of the phone number of passengers.
# The next character denotes the gender of the person.
# The following two characters are used to indicate the age of the person.
# The last two characters determine the seat allotted to that person.
# Return the number of passengers who are strictly more than 60 years old.
#
#
#
# Example 1:
#
# Input: details = ["7868190130M7522","5303914400F9211","9273338290F4010"]
# Output: 2
# Explanation: The passengers at indices 0, 1, and 2 have ages 75, 92, and 40. Thus, there are 2 people who are over 60 years old.
# Example 2:
#
# Input: details = ["1313579440F2036","2921522980M5644"]
# Output: 0
# Explanation: None of the passengers are older than 60.
#
#
# Constraints:
#
# 1 <= details.length <= 100
# details[i].length == 15
# details[i] consists of digits from '0' to '9'.
# details[i][10] is either 'M' or 'F' or 'O'.
# The phone numbers and seat numbers of the passengers are distinct.
class Solution(object):
    def countSeniors(self, details):
        return sum(i[-4:-2] > '60' for i in details)


# Multi-tap Keypad Text Entry on an Old Mobile Phone
# Prior to having fancy iPhones, teenagers would wear out their thumbs sending SMS messages on candybar-shaped feature phones with 3x4 numeric keypads.
#
# ------- ------- -------
# |     | | ABC | | DEF |
# |  1  | |  2  | |  3  |
# ------- ------- -------
# ------- ------- -------
# | GHI | | JKL | | MNO |
# |  4  | |  5  | |  6  |
# ------- ------- -------
# ------- ------- -------
# |PQRS | | TUV | | WXYZ|
# |  7  | |  8  | |  9  |
# ------- ------- -------
# ------- ------- -------
# |  *  | |space| |  #  |
# |     | |  0  | |     |
# ------- ------- -------
# Prior to the development of T9 systems (predictive text entry), the method to type words was called "multi-tap" and involved pressing a button repeatedly to cycle through all its possible values, in order. For example:
#
# Pressing the button 7 repeatedly will cycle through the letters P -> Q -> R -> S -> 7 -> P -> ....
# Pressing the button 0 is cycling through SPACE -> 0 -> SPACE -> 0 -> ....
# Buttons with a single symbol on it just type this symbol.
# A character is "locked in" and inserted into the message once the user presses a different key or pauses for a short period of time (thus, no extra button presses are required beyond what is needed for each letter individually). For example:
#
# To type a letter "R" you would press the 7 key three times (as the screen display for the current character cycles through P->Q->R->S->7).
# To type in a digit 3, you would press the button 3 four times.
# To type in the message "ABC", you would press the button 2 once, wait a second, then press the button 2 twice to enter the letter B, then pause for another second, and press the button 2 three times, to enter the letter C. You would have to press the button 2 six times in total.
# In order to send the message "WHERE DO U WANT 2 MEET L8R" a teen would have to actually do 47 button presses. No wonder they abbreviated...
#
# For this assignment, write code that can calculate the amount of button presses required for any phrase, with the following requirements:
#
# Punctuation can be ignored for this exercise.
# Likewise, the phone doesn't distinguish between upper and lowercase characters (but you should allow your module to accept input in either form, for convenience).
# Tested phrases contain letters (A-Z and a-z), digits (0-9), and special characters # and *.
# FUNDAMENTALS
def presses(phrase):
    l = ['1', 'ABC2', 'DEF3', 'GHI4', 'JKL5', 'MNO6', 'PQRS7',
        'TUV8', 'WXYZ9', '*', ' 0', '#']
    top = 0
    phrase = phrase.upper()
    for char in phrase:
        for but in l:
            if char in but:
                top += but.index(char) + 1
    return top

# 2785. Sort Vowels in a String
# Given a 0-indexed string s, permute s to get a new string t such that:
#
# All consonants remain in their original places. More formally, if there is an index i with 0 <= i < s.length such that s[i] is a consonant, then t[i] = s[i].
# The vowels must be sorted in the nondecreasing order of their ASCII values. More formally, for pairs of indices i, j with 0 <= i < j < s.length such that s[i] and s[j] are vowels, then t[i] must not have a higher ASCII value than t[j].
# Return the resulting string.
#
# The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in lowercase or uppercase. Consonants comprise all letters that are not vowels.
#
#
#
# Example 1:
#
# Input: s = "lEetcOde"
# Output: "lEOtcede"
# Explanation: 'E', 'O', and 'e' are the vowels in s; 'l', 't', 'c', and 'd' are all consonants. The vowels are sorted according to their ASCII values, and the consonants remain in the same places.
# Example 2:
#
# Input: s = "lYmpH"
# Output: "lYmpH"
# Explanation: There are no vowels in s (all characters in s are consonants), so we return "lYmpH".
#
#
# Constraints:
#
# 1 <= s.length <= 105
# s consists only of letters of the English alphabet in uppercase and lowercase.
class Solution(object):
    def sortVowels(self, s):
        word, l = '', []
        for i in s:
            if i.lower() in {'a', 'e', 'i', 'o', 'u'}:
                l.append(i)
        top = 0
        l.sort()
        for i in s:
            if i.lower() not in {'a', 'e', 'i', 'o', 'u'}:
                word += i
            else:
                word += l[top]
                top += 1
        return word

# Don't rely on luck.
# The test fixture I use for this kata is pre-populated.
#
# It will compare your guess to a random number generated using:
#
# randint(1,100)
# You can pass by relying on luck or skill but try not to rely on luck.
#
# "The power to define the situation is the ultimate power." - Jerry Rubin
#
# Good luck!
#
# GAMESPUZZLES
from random import randint,seed
seed(1)
guess = randint(1,100)
seed(1)

# 1652. Defuse the Bomb
# You have a bomb to defuse, and your time is running out! Your informer will provide you with a circular array code of length of n and a key k.
#
# To decrypt the code, you must replace every number. All the numbers are replaced simultaneously.
#
# If k > 0, replace the ith number with the sum of the next k numbers.
# If k < 0, replace the ith number with the sum of the previous k numbers.
# If k == 0, replace the ith number with 0.
# As code is circular, the next element of code[n-1] is code[0], and the previous element of code[0] is code[n-1].
#
# Given the circular array code and an integer key k, return the decrypted code to defuse the bomb!
#
#
#
# Example 1:
#
# Input: code = [5,7,1,4], k = 3
# Output: [12,10,16,13]
# Explanation: Each number is replaced by the sum of the next 3 numbers. The decrypted code is [7+1+4, 1+4+5, 4+5+7, 5+7+1]. Notice that the numbers wrap around.
# Example 2:
#
# Input: code = [1,2,3,4], k = 0
# Output: [0,0,0,0]
# Explanation: When k is zero, the numbers are replaced by 0.
# Example 3:
#
# Input: code = [2,4,9,3], k = -2
# Output: [12,5,6,13]
# Explanation: The decrypted code is [3+9, 2+3, 4+2, 9+4]. Notice that the numbers wrap around again. If k is negative, the sum is of the previous numbers.
#
#
# Constraints:
#
# n == code.length
# 1 <= n <= 100
# 1 <= code[i] <= 100
# -(n - 1) <= k <= n - 1
class Solution(object):
    def decrypt(self, code, k):
        if k == 0:
          return [0] * len(code)
        l, code = [], code * 2
        for i in range(len(code) // 2):
          if k > 0:
            l.append(sum(code[i + 1:i + k + 1]))
          else:
            x = i + len(code) // 2 - 1
            l.append(sum(code[x: x + k: -1]))
        return l
    
# Linked Lists - Length & Count
# Linked Lists - Length & Count
#
# Implement Length() to count the number of nodes in a linked list.
#
# length(null) => 0
# length(1 -> 2 -> 3 -> null) => 3
# Implement Count() to count the occurrences of an integer in a linked list.
#
# count(null, 1) => 0
# count(1 -> 2 -> 3 -> null, 1) => 1
# count(1 -> 1 -> 1 -> 2 -> 2 -> 2 -> 2 -> 3 -> 3 -> null, 2) => 4
# I've decided to bundle these two functions within the same Kata since they are both very similar.
#
# The push()/Push() and buildOneTwoThree()/BuildOneTwoThree() functions do not need to be redefined.
#
# Related Kata in order of expected completion (increasing difficulty):
# Linked Lists - Push & BuildOneTwoThree
# Linked Lists - Length & Count
# Linked Lists - Get Nth Node
# Linked Lists - Insert Nth Node
# Linked Lists - Sorted Insert
# Linked Lists - Insert Sort
# Linked Lists - Append
# Linked Lists - Remove Duplicates
# Linked Lists - Move Node
# Linked Lists - Move Node In-place
# Linked Lists - Alternating Split
# Linked Lists - Front Back Split
# Linked Lists - Shuffle Merge
# Linked Lists - Sorted Merge
# Linked Lists - Merge Sort
# Linked Lists - Sorted Intersect
# Linked Lists - Iterative Reverse
# Linked Lists - Recursive Reverse
#
# Inspired by Stanford Professor Nick Parlante's excellent Linked List teachings.
#
# LINKED LISTSDATA STRUCTURESFUNDAMENTALS
class Node(object):
    def __init__(self, data):
        self.data = data
        self.next = None


def length(node):
    count = 0
    while node:
        count += 1
        node = node.next
    return count


def count(node, data):
    count = 0
    while node:
        if node.data == data:
            count += 1
        node = node.next
    return count

# 1846. Maximum Element After Decreasing and Rearranging
# You are given an array of positive integers arr. Perform some operations (possibly none) on arr so that it satisfies these conditions:
#
# The value of the first element in arr must be 1.
# The absolute difference between any 2 adjacent elements must be less than or equal to 1. In other words, abs(arr[i] - arr[i - 1]) <= 1 for each i where 1 <= i < arr.length (0-indexed). abs(x) is the absolute value of x.
# There are 2 types of operations that you can perform any number of times:
#
# Decrease the value of any element of arr to a smaller positive integer.
# Rearrange the elements of arr to be in any order.
# Return the maximum possible value of an element in arr after performing the operations to satisfy the conditions.
#
#
#
# Example 1:
#
# Input: arr = [2,2,1,2,1]
# Output: 2
# Explanation:
# We can satisfy the conditions by rearranging arr so it becomes [1,2,2,2,1].
# The largest element in arr is 2.
# Example 2:
#
# Input: arr = [100,1,1000]
# Output: 3
# Explanation:
# One possible way to satisfy the conditions is by doing the following:
# 1. Rearrange arr so it becomes [1,100,1000].
# 2. Decrease the value of the second element to 2.
# 3. Decrease the value of the third element to 3.
# Now arr = [1,2,3], which satisfies the conditions.
# The largest element in arr is 3.
# Example 3:
#
# Input: arr = [1,2,3,4,5]
# Output: 5
# Explanation: The array already satisfies the conditions, and the largest element is 5.
#
#
# Constraints:
#
# 1 <= arr.length <= 105
# 1 <= arr[i] <= 109
class Solution(object):
    def maximumElementAfterDecrementingAndRearranging(self, arr):
        arr.sort()
        top = 0
        for i in arr:
            top = min(top + 1, i)
        return top

# What century is it?
# Return the century of the input year. The input will always be a 4 digit string, so there is no need for validation.
#
# Examples
# "1999" --> "20th"
# "2011" --> "21st"
# "2154" --> "22nd"
# "2259" --> "23rd"
# "1124" --> "12th"
# "2000" --> "20th"
# STRINGSALGORITHMSDATE TIME
def what_century(year):
    x = (int(year) - 1) // 100 + 1
    SUFFIXES = {1: 'st', 2: 'nd', 3: 'rd'}
    if 10 <= x % 100 <= 20:
        suffix = 'th'
    else:
        suffix = SUFFIXES.get(x % 10, 'th')
    return str(x) + suffix

# 1980. Find Unique Binary String
# Given an array of strings nums containing n unique binary strings each of length n, return a binary string of length n that does not appear in nums. If there are multiple answers, you may return any of them.
#
#
#
# Example 1:
#
# Input: nums = ["01","10"]
# Output: "11"
# Explanation: "11" does not appear in nums. "00" would also be correct.
# Example 2:
#
# Input: nums = ["00","01"]
# Output: "11"
# Explanation: "11" does not appear in nums. "10" would also be correct.
# Example 3:
#
# Input: nums = ["111","011","001"]
# Output: "101"
# Explanation: "101" does not appear in nums. "000", "010", "100", and "110" would also be correct.
#
#
# Constraints:
#
# n == nums.length
# 1 <= n <= 16
# nums[i].length == n
# nums[i] is either '0' or '1'.
# All the strings of nums are unique.
class Solution(object):
    def findDifferentBinaryString(self, nums):
        top = ''
        for i in range(len(nums)):
            top += '1' if nums[i][i] == '0' else '0'
        return top

# Ball Upwards
# You throw a ball vertically upwards with an initial speed v (in km per hour). The height h of the ball at each time t is given by h = v*t - 0.5*g*t*t where g is Earth's gravity (g ~ 9.81 m/s**2). A device is recording at every tenth of second the height of the ball. For example with v = 15 km/h the device gets something of the following form: (0, 0.0), (1, 0.367...), (2, 0.637...), (3, 0.808...), (4, 0.881..) ... where the first number is the time in tenth of second and the second number the height in meter.
#
# Task
# Write a function max_ball with parameter v (in km per hour) that returns the time in tenth of second of the maximum height recorded by the device.
#
# Examples:
# max_ball(15) should return 4
#
# max_ball(25) should return 7
#
# Notes
# Remember to convert the velocity from km/h to m/s or from m/s in km/h when necessary.
# The maximum height recorded by the device is not necessarily the maximum height reached by the ball.
# FUNDAMENTALS
def max_ball(v0):
    return round(10 * v0 / 9.81 / 3.6)

# 1877. Minimize Maximum Pair Sum in Array
# The pair sum of a pair (a,b) is equal to a + b. The maximum pair sum is the largest pair sum in a list of pairs.
#
# For example, if we have pairs (1,5), (2,3), and (4,4), the maximum pair sum would be max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8.
# Given an array nums of even length n, pair up the elements of nums into n / 2 pairs such that:
#
# Each element of nums is in exactly one pair, and
# The maximum pair sum is minimized.
# Return the minimized maximum pair sum after optimally pairing up the elements.
#
#
#
# Example 1:
#
# Input: nums = [3,5,2,3]
# Output: 7
# Explanation: The elements can be paired up into pairs (3,3) and (5,2).
# The maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.
# Example 2:
#
# Input: nums = [3,5,4,2,4,6]
# Output: 8
# Explanation: The elements can be paired up into pairs (3,5), (4,4), and (6,2).
# The maximum pair sum is max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8.
#
#
# Constraints:
#
# n == nums.length
# 2 <= n <= 105
# n is even.
# 1 <= nums[i] <= 105
# Solution 1 - Sort and Two Pointers
class Solution(object):
    def minPairSum(self, nums):
        nums.sort()
        x, y, top = 0, len(nums) - 1, 0
        while x < y:
            if nums[x] + nums[y] > top:
                top = nums[x] + nums[y]
            x += 1
            y -= 1
        return top
# Solution 2 - Sort and Two Pointers by One Pointer
class Solution(object):
    def minPairSum(self, nums):
        nums.sort()
        x, top = 0, 0
        while x < len(nums) / 2:
            top = max(top, nums[x] + nums[-x - 1])
            x += 1
        return top

# Coordinates Validator
# You need to create a function that will validate if given parameters are valid geographical coordinates.
#
# Valid coordinates look like the following: "23.32353342, -32.543534534". The return value should be either true or false.
#
# Latitude (which is first float) can be between 0 and 90, positive or negative. Longitude (which is second float) can be between 0 and 180, positive or negative.
#
# Coordinates can only contain digits, or one of the following symbols (including space after comma) __ -, . __
#
# There should be no space between the minus "-" sign and the digit after it.
#
# Here are some valid coordinates:
#
# -23, 25
# 24.53525235, 23.45235
# 04, -23.234235
# 43.91343345, 143
# 4, -3
# And some invalid ones:
#
# 23.234, - 23.4234
# 2342.43536, 34.324236
# N23.43345, E32.6457
# 99.234, 12.324
# 6.325624, 43.34345.345
# 0, 1,2
# 0.342q0832, 1.2324
# REGULAR EXPRESSIONSALGORITHMS
def is_valid_coordinates(coordinates):
    try:
        x, y = [abs(float(i)) for i in coordinates.split(',') if 'e' not in i]
    except:
        return False
    return x <= 90 and y <= 180

# 2932. Maximum Strong Pair XOR I
# You are given a 0-indexed integer array nums. A pair of integers x and y is called a strong pair if it satisfies the condition:
#
# |x - y| <= min(x, y)
# You need to select two integers from nums such that they form a strong pair and their bitwise XOR is the maximum among all strong pairs in the array.
#
# Return the maximum XOR value out of all possible strong pairs in the array nums.
#
# Note that you can pick the same integer twice to form a pair.
#
#
#
# Example 1:
#
# Input: nums = [1,2,3,4,5]
# Output: 7
# Explanation: There are 11 strong pairs in the array nums: (1, 1), (1, 2), (2, 2), (2, 3), (2, 4), (3, 3), (3, 4), (3, 5), (4, 4), (4, 5) and (5, 5).
# The maximum XOR possible from these pairs is 3 XOR 4 = 7.
# Example 2:
#
# Input: nums = [10,100]
# Output: 0
# Explanation: There are 2 strong pairs in the array nums: (10, 10) and (100, 100).
# The maximum XOR possible from these pairs is 10 XOR 10 = 0 since the pair (100, 100) also gives 100 XOR 100 = 0.
# Example 3:
#
# Input: nums = [5,6,25,30]
# Output: 7
# Explanation: There are 6 strong pairs in the array nums: (5, 5), (5, 6), (6, 6), (25, 25), (25, 30) and (30, 30).
# The maximum XOR possible from these pairs is 25 XOR 30 = 7 since the only other non-zero XOR value is 5 XOR 6 = 3.
#
#
# Constraints:
#
# 1 <= nums.length <= 50
# 1 <= nums[i] <= 100
class Solution(object):
    def maximumStrongPairXor(self, nums):
        top = 0
        for i in range(len(nums)):
            for j in range(i, len(nums)):
                if abs(nums[i] - nums[j]) <= min(nums[i], nums[j]):
                    top = max(top, nums[i] ^ nums[j])
        return top

# Can you get the loop ?
# You are given a node that is the beginning of a linked list. This list contains a dangling piece and a loop. Your objective is to determine the length of the loop.
#
# For example in the following picture the size of the dangling piece is 3 and the loop size is 12:
#
#
# # Use the `next' attribute to get the following node
# node.next
# Notes:
#
# do NOT mutate the nodes!
# in some cases there may be only a loop, with no dangling piece
# Thanks to shadchnev, I broke all of the methods from the Hash class.
#
# Don't miss dmitry's article in the discussion after you pass the Kata !!
#
# ALGORITHMSLINKED LISTSPERFORMANCE
# Solution 1 - Speed O(N) / Memory O(N)
def loop_size(node):
    d, top = {}, 0
    while node not in d:
        d[node] = top
        top += 1
        node = node.next
    return top - d[node]
# Solution 2 Speed O(N) / Memory O(1) FLoyd Algorithm
def loop_size(node):
    x, y = node.next, node.next.next
    while x != y:
        x, y = x.next, y.next.next
    count, y = 1, y.next
    while x != y:
        count += 1
        y = y.next
    return count

# 1887. Reduction Operations to Make the Array Elements Equal
# Given an integer array nums, your goal is to make all elements in nums equal. To complete one operation, follow these steps:
#
# Find the largest value in nums. Let its index be i (0-indexed) and its value be largest. If there are multiple elements with the largest value, pick the smallest i.
# Find the next largest value in nums strictly smaller than largest. Let its value be nextLargest.
# Reduce nums[i] to nextLargest.
# Return the number of operations to make all elements in nums equal.
#
#
#
# Example 1:
#
# Input: nums = [5,1,3]
# Output: 3
# Explanation: It takes 3 operations to make all elements in nums equal:
# 1. largest = 5 at index 0. nextLargest = 3. Reduce nums[0] to 3. nums = [3,1,3].
# 2. largest = 3 at index 0. nextLargest = 1. Reduce nums[0] to 1. nums = [1,1,3].
# 3. largest = 3 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [1,1,1].
# Example 2:
#
# Input: nums = [1,1,1]
# Output: 0
# Explanation: All elements in nums are already equal.
# Example 3:
#
# Input: nums = [1,1,2,2,3]
# Output: 4
# Explanation: It takes 4 operations to make all elements in nums equal:
# 1. largest = 3 at index 4. nextLargest = 2. Reduce nums[4] to 2. nums = [1,1,2,2,2].
# 2. largest = 2 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [1,1,1,2,2].
# 3. largest = 2 at index 3. nextLargest = 1. Reduce nums[3] to 1. nums = [1,1,1,1,2].
# 4. largest = 2 at index 4. nextLargest = 1. Reduce nums[4] to 1. nums = [1,1,1,1,1].
#
#
# Constraints:
#
# 1 <= nums.length <= 5 * 104
# 1 <= nums[i] <= 5 * 104
# Solution Speed - O(N log N) / Memory - O(1)
class Solution(object):
    def reductionOperations(self, nums):
        count, x = 0, 1
        nums.sort(reverse=True)
        while x < len(nums):
            if nums[x] != nums[x - 1]:
                count += x
            x += 1
        return count

# Closure Counter
# Closure Counter
# Define the function counter that returns a function that returns an increasing value.
# The first value should be 1.
# You're going to have to use closures.
# Example:
# const newCounter = counter();
# newCounter() // 1
# newCounter() // 2
# Closure:
# A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). In other words, a closure gives you access to an outer function’s scope from an inner function. In JavaScript, closures are created every time a function is created, at function creation time.
#
# https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures
#
# FUNDAMENTALS
def counter():
    i = 0
    def inscrease():
        nonlocal i
        i += 1
        return i
    return inscrease

# 2716. Minimize String Length
# Given a 0-indexed string s, repeatedly perform the following operation any number of times:
#
# Choose an index i in the string, and let c be the character in position i. Delete the closest occurrence of c to the left of i (if any) and the closest occurrence of c to the right of i (if any).
# Your task is to minimize the length of s by performing the above operation any number of times.
#
# Return an integer denoting the length of the minimized string.
#
#
#
# Example 1:
#
# Input: s = "aaabc"
# Output: 3
# Explanation: In this example, s is "aaabc". We can start by selecting the character 'a' at index 1. We then remove the closest 'a' to the left of index 1, which is at index 0, and the closest 'a' to the right of index 1, which is at index 2. After this operation, the string becomes "abc". Any further operation we perform on the string will leave it unchanged. Therefore, the length of the minimized string is 3.
# Example 2:
#
# Input: s = "cbbd"
# Output: 3
# Explanation: For this we can start with character 'b' at index 1. There is no occurrence of 'b' to the left of index 1, but there is one to the right at index 2, so we delete the 'b' at index 2. The string becomes "cbd" and further operations will leave it unchanged. Hence, the minimized length is 3.
# Example 3:
#
# Input: s = "dddaaa"
# Output: 2
# Explanation: For this, we can start with the character 'd' at index 1. The closest occurrence of a 'd' to its left is at index 0, and the closest occurrence of a 'd' to its right is at index 2. We delete both index 0 and 2, so the string becomes "daaa". In the new string, we can select the character 'a' at index 2. The closest occurrence of an 'a' to its left is at index 1, and the closest occurrence of an 'a' to its right is at index 3. We delete both of them, and the string becomes "da". We cannot minimize this further, so the minimized length is 2.
#
#
#
# Constraints:
#
# 1 <= s.length <= 100
# s contains only lowercase English letters
class Solution(object):
    def minimizedStringLength(self, s):
        return len(set(s))

# Make a square box!
# Easy; Make a box
# Given a number as a parameter (between 2 and 30), return an array containing strings which form a box.
# Like this:
#
# n = 5
#
# [
#   '-----',
#   '-   -',
#   '-   -',
#   '-   -',
#   '-----'
# ]
# n = 3
#
# [
#   '---',
#   '- -',
#   '---'
# ]
# STRINGSARRAYSASCII ARTALGORITHMS
def box(n):
    l = []
    for i in range(n):
        if i in {0, n -1}:
            l.append('-' * n)
        else:
            l.append('-' + ' ' * (n - 2) + '-')
    return l

# 1814. Count Nice Pairs in an Array
# You are given an array nums that consists of non-negative integers. Let us define rev(x) as the reverse of the non-negative integer x. For example, rev(123) = 321, and rev(120) = 21. A pair of indices (i, j) is nice if it satisfies all of the following conditions:
#
# 0 <= i < j < nums.length
# nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])
# Return the number of nice pairs of indices. Since that number can be too large, return it modulo 109 + 7.
#
#
#
# Example 1:
#
# Input: nums = [42,11,1,97]
# Output: 2
# Explanation: The two pairs are:
#  - (0,3) : 42 + rev(97) = 42 + 79 = 121, 97 + rev(42) = 97 + 24 = 121.
#  - (1,2) : 11 + rev(1) = 11 + 1 = 12, 1 + rev(11) = 1 + 11 = 12.
# Example 2:
#
# Input: nums = [13,10,35,24,76]
# Output: 4
#
#
# Constraints:
#
# 1 <= nums.length <= 105
# 0 <= nums[i] <= 109
class Solution(object):
    def countNicePairs(self, nums):
        d = {}
        for i in range(len(nums)):
            d[nums[i] - int(str(nums[i])[::-1])] = d.get(nums[i] - int(str(nums[i])[::-1]), 0) + 1
        return sum(val * (val - 1) // 2 for val in d.values()) % (10 ** 9 + 7)

# Spin Around, Touch the Ground
# Given a list of directions to spin, "left" or "right", return an integer of how many full 360° rotations were made. Note that each word in the array counts as a 90° rotation in that direction.
#
# Worked Example
# ["right", "right", "right", "right", "left", "right"] ➞ 1
# # You spun right 4 times (90 * 4 = 360)
# # You spun left once (360 - 90 = 270)
# # But you spun right once more to make a full rotation (270 + 90 = 360)
# Examples
# ["left", "right", "left", "right"] ➞ 0
#
# ["right", "right", "right", "right", "right", "right", "right", "right"] ➞ 2
#
# ["left", "left", "left", "left"] ➞ 1
# Notes
# Return a positive number.
# All tests will only include the words "right" and "left".
# ALGORITHMSARRAYS
def spin_around(lst):
    count = 0
    for i in lst:
        if i == 'left':
            count -= 1
        else:
            count += 1
    return abs(count) // 4

# 2169. Count Operations to Obtain Zero
# You are given two non-negative integers num1 and num2.
#
# In one operation, if num1 >= num2, you must subtract num2 from num1, otherwise subtract num1 from num2.
#
# For example, if num1 = 5 and num2 = 4, subtract num2 from num1, thus obtaining num1 = 1 and num2 = 4. However, if num1 = 4 and num2 = 5, after one operation, num1 = 4 and num2 = 1.
# Return the number of operations required to make either num1 = 0 or num2 = 0.
#
#
#
# Example 1:
#
# Input: num1 = 2, num2 = 3
# Output: 3
# Explanation:
# - Operation 1: num1 = 2, num2 = 3. Since num1 < num2, we subtract num1 from num2 and get num1 = 2, num2 = 3 - 2 = 1.
# - Operation 2: num1 = 2, num2 = 1. Since num1 > num2, we subtract num2 from num1.
# - Operation 3: num1 = 1, num2 = 1. Since num1 == num2, we subtract num2 from num1.
# Now num1 = 0 and num2 = 1. Since num1 == 0, we do not need to perform any further operations.
# So the total number of operations required is 3.
# Example 2:
#
# Input: num1 = 10, num2 = 10
# Output: 1
# Explanation:
# - Operation 1: num1 = 10, num2 = 10. Since num1 == num2, we subtract num2 from num1 and get num1 = 10 - 10 = 0.
# Now num1 = 0 and num2 = 10. Since num1 == 0, we are done.
# So the total number of operations required is 1.
#
#
# Constraints:
#
# 0 <= num1, num2 <= 105
# Solution 1 - Euclidean algorithm O(log min(num1, num2))
class Solution(object):
    def countOperations(self, num1, num2):
        return 0 if num1 * num2 == 0 else num1 // num2 + self.countOperations(num2, num1 % num2)
# Solution 2 O(max(num1, num2))
class Solution(object):
    def countOperations(self, num1, num2):
        count = 0
        while num1 != 0 and num2 != 0:
            if num1 >= num2:
                num1 = abs(num2 - num1)
            else:
                num2 = abs(num1 - num2)
            count += 1
        return count
    
# Doubleton number
# We will call a natural number a "doubleton number" if it contains exactly two distinct digits. For example, 23, 35, 100, 12121 are doubleton numbers, and 123 and 9980 are not.
#
# For a given natural number n (from 1 to 1 000 000), you need to find the next doubleton number. If n itself is a doubleton, return the next bigger than n.
#
# Examples:
# doubleton(120) == 121
# doubleton(1234) == 1311
# doubleton(10) == 12
# SETSFUNDAMENTALS
def doubleton(num):
    def check(n):
        d = {}
        for i in str(n):
            d[i] = d.get(i, 0) + 1
            if len(d) > 2:
                return False
        return len(d) in {2}
    num += 1
    while not check(num):
        num += 1
    return num

# 1018. Binary Prefix Divisible By 5
# You are given a binary array nums (0-indexed).
#
# We define xi as the number whose binary representation is the subarray nums[0..i] (from most-significant-bit to least-significant-bit).
#
# For example, if nums = [1,0,1], then x0 = 1, x1 = 2, and x2 = 5.
# Return an array of booleans answer where answer[i] is true if xi is divisible by 5.
#
#
#
# Example 1:
#
# Input: nums = [0,1,1]
# Output: [true,false,false]
# Explanation: The input numbers in binary are 0, 01, 011; which are 0, 1, and 3 in base-10.
# Only the first number is divisible by 5, so answer[0] is true.
# Example 2:
#
# Input: nums = [1,1,1]
# Output: [false,false,false]
#
#
# Constraints:
#
# 1 <= nums.length <= 105
# nums[i] is either 0 or 1.
class Solution(object):
    def prefixesDivBy5(self, nums):
        l, top = [True] * len(nums), 0
        for i in range(len(nums)):
            top = top * 2 + nums[i]
            l[i] = top % 5 == 0
        return l
    
# Uglify Word
# Summary
# In this kata, you have to make a function named uglify_word (uglifyWord in Java and Javascript). It accepts a string parameter.
# 
# What does the uglify_word do?
# It checks the char in the given string from the front with an iteration, in the iteration it does these steps:
# 
# There is a flag and it will be started from 1.
# Check the current char in the iteration index.
# If it is an alphabet character [a-zA-Z] and the flag value is equal to 1, then change this character to upper case.
# If it is an alphabet character [a-zA-Z] and the flag value is equal to 0, then change this character to lower case.
# Otherwise, if it is not an alphabet character, then set the flag value to 1.
# If the current char is an alphabet character, do a boolean not operation to the flag.
# After the iteration has done, return the fixed string that might have been changed in such iteration.
# 
# Examples
# uglify_word("aaa") === "AaA"
# uglify_word("AAA") === "AaA"
# uglify_word("BbB") === "BbB"
# uglify_word("aaa-bbb-ccc") === "AaA-BbB-CcC"
# uglify_word("AaA-BbB-CcC") === "AaA-BbB-CcC"
# uglify_word("eeee-ffff-gggg") === "EeEe-FfFf-GgGg"
# uglify_word("EeEe-FfFf-GgGg") === "EeEe-FfFf-GgGg"
# uglify_word("qwe123asdf456zxc") === "QwE123AsDf456ZxC"
# uglify_word("Hello World") === "HeLlO WoRlD"
# ALGORITHMS
def uglify_word(s):
    d = {0: lambda x: x.lower(), 1: lambda x: x.upper()}
    flag, word = 1, ''
    for i in s:
        if i.isalpha():
            word += d[flag](i)
            flag = not flag
        else:
            word += i
            flag = 1
    return word

# 728. Self Dividing Numbers
# A self-dividing number is a number that is divisible by every digit it contains.
#
# For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.
# A self-dividing number is not allowed to contain the digit zero.
#
# Given two integers left and right, return a list of all the self-dividing numbers in the range [left, right].
#
#
#
# Example 1:
#
# Input: left = 1, right = 22
# Output: [1,2,3,4,5,6,7,8,9,11,12,15,22]
# Example 2:
#
# Input: left = 47, right = 85
# Output: [48,55,66,77]
#
#
# Constraints:
#
# 1 <= left <= right <= 104
class Solution(object):
    def selfDividingNumbers(self, left, right):
        def check(n):
            x = str(n)
            if '0' in x:
                return False
            return all(n % int(i) == 0 for i in x)
        l = []
        for i in range(left, right + 1):
            if check(i):
                l.append(i)
        return l
    
# From A to Z
# Given a string indicating a range of letters, return a string which includes all the letters in that range, including the last letter. Note that if the range is given in capital letters, return the string in capitals also!
#
# Examples
# "a-z" ➞ "abcdefghijklmnopqrstuvwxyz"
# "h-o" ➞ "hijklmno"
# "Q-Z" ➞ "QRSTUVWXYZ"
# "J-J" ➞ "J"
# Notes
# A hyphen will separate the two letters in the string.
# You don't need to worry about error handling in this one (i.e. both letters will be the same case and the second letter will always be after the first alphabetically).
# ALGORITHMSSTRINGS
def gimme_the_letters(sp):
    al = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
    a, b = sp.split('-')
    return al[al.index(a): al.index(b) + 1]

# 1952. Three Divisors
# Given an integer n, return true if n has exactly three positive divisors. Otherwise, return false.
#
# An integer m is a divisor of n if there exists an integer k such that n = k * m.
#
#
#
# Example 1:
#
# Input: n = 2
# Output: false
# Explantion: 2 has only two divisors: 1 and 2.
# Example 2:
#
# Input: n = 4
# Output: true
# Explantion: 4 has three divisors: 1, 2, and 4.
#
#
# Constraints:
#
# 1 <= n <= 104
# Solution 1 Speed O(N // 2) Memory O(1)
class Solution(object):
    def isThree(self, n):
        count = 1
        for i in range(1, n // 2 + 1):
            top = 1
            while i * top < n:
                top += 1
            if top * i == n:
                count += 1
        return count == 3

# Solution 2 Speed O(log(N)) Memory O(1)
class Solution(object):
    def isThree(self, n):
        limit, count = n, 0
        for i in range(1, limit):
            if n % i == 0:
                limit = n / i
                if limit != i:
                    count += 1
                count += 1
        return count == 3

# Tube strike options calculator
# Tube strike options calculator
# The sweaty bus ride
# There is a tube strike today so instead of getting the London Underground home you have decided to take the bus. It's a hot day and you have been sitting on the bus for over an hour, but the bus is hardly moving. Your arm is sticking to the window and sweat drips off your nose as you try to read your neighbour's book when you say to yourself, "This is ridiculous. I could have walked faster than this!" Suddenly you have an idea for an app that helps people decide whether to walk or take the bus home when the London Underground is on strike.
# You rush home (relatively speaking) and begin to define the function that will underpin your app.
#
# Function specification
# You must create a function which takes three parameters; walking distance home, distance the bus must travel, and the combined distance of walking from the office to the bus stop and from the bus stop to your house. All distances are in kilometres.
# So for example, if your home is 5km away by foot, and the bus that takes you home travels 6km, but you have to walk 500 metres to the bus stop to catch it and 500 metres to your house once the bus arrives (i.e. 1km in total), which is faster, walking or taking the bus?
#
# Example - Which of these is faster?:
#
# Start---Walk 5km--->End
# Start---Walk 500m---Bus 6km---Walk 500m--->End
# Walking speed and bus driving speed have been given to you as two pre-loaded variables ($global_variables in Ruby).
#
# walk = 5 (km/hr) bus = 8 (km/hr)
#
# The function must return the fastest option, either "Walk" or "Bus". If the walk is going to be over 2 hours, the function should recommend that you take the bus. If the walk is going to be under 10 minutes, the function should recommend that you walk. If both options are going to take the same amount of time, the function should recommend that you walk
#
# FUNDAMENTALSALGORITHMS
def calculator(distance, bus_drive, bus_walk):
    by_walk = distance / walk
    by_bus = bus_walk / walk + bus_drive / bus
    if by_walk < 1/6:
        return 'Walk'
    elif by_walk <= 2:
        return 'Bus' if by_bus < by_walk else 'Walk'
    return 'Bus'

# 1037. Valid Boomerang
# Given an array points where points[i] = [xi, yi] represents a point on the X-Y plane, return true if these points are a boomerang.
#
# A boomerang is a set of three points that are all distinct and not in a straight line.
#
#
#
# Example 1:
#
# Input: points = [[1,1],[2,3],[3,2]]
# Output: true
# Example 2:
#
# Input: points = [[1,1],[2,2],[3,3]]
# Output: false
#
#
# Constraints:
#
# points.length == 3
# points[i].length == 2
# 0 <= xi, yi <= 100
# Solution Geometry Triangle Area Speed O(1), Memory O(1)
class Solution(object):
    def isBoomerang(self, p):
        x1, y1, x2, y2, x3, y3 = p[0][0], p[0][1], p[1][0], p[1][1], p[2][0], p[2][1]
        return x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0

# Alphabetical Grid
# Task:
# You need to write a function grid that returns an alphabetical grid of size NxN, where a = 0, b = 1, c = 2....
#
# Examples:
# grid(4)
#
# a b c d
# b c d e
# c d e f
# d e f g
# grid(10)
#
# a b c d e f g h i j
# b c d e f g h i j k
# c d e f g h i j k l
# d e f g h i j k l m
# e f g h i j k l m n
# f g h i j k l m n o
# g h i j k l m n o p
# h i j k l m n o p q
# i j k l m n o p q r
# j k l m n o p q r s
# Notes:
# After "z" comes "a"
# If function receive N < 0 should return:
# None
# FUNDAMENTALSALGORITHMS
def grid(N):
    if N < 0: return None
    if N == 0: return ''
    al, word = 'abcdefghijklmnopqrstuvwxyz' * N, []
    for i in range(N):
        top = [' '.join(al[i: i + N])]
        word.append(' '.join(top))
    return '\n'.join(word)

# 1556. Thousand Separator
# Given an integer n, add a dot (".") as the thousands separator and return it in string format.
#
#
#
# Example 1:
#
# Input: n = 987
# Output: "987"
# Example 2:
#
# Input: n = 1234
# Output: "1.234"
#
#
# Constraints:
#
# 0 <= n <= 231 - 1
class Solution(object):
    def thousandSeparator(self, n):
        if n == 0:
            return '0'
        top, count = '', 0
        while n:
            top = str(n % 10) + top
            count += 1
            n //= 10
            if n:
                if count == 3:
                    top = '.' + top
                    count = 0
        return top

# Day of the Year
# Work out what number day of the year it is.
#
# toDayOfYear([1, 1, 2000]) => 1
# The argument passed into the function is an array with the format [D, M, YYYY], e.g. [1, 2, 2000] for February 1st, 2000 or [22, 12, 1999] for December 22nd, 1999.
#
# Don't forget to check for whether it's a leap year! Three criteria must be taken into account to identify leap years:
#
# The year can be evenly divided by 4;
# If the year can be evenly divided by 100, it is NOT a leap year, unless;
# The year is also evenly divisible by 400. Then it is a leap year.
# FUNDAMENTALS
import calendar
def to_day_of_year(date):
    count = 0
    for i in range(1, date[1]):
        count += calendar.monthrange(date[-1], i)[1]
    count += date[0]
    return count

# 724. Find Pivot Index
# Given an array of integers nums, calculate the pivot index of this array.
#
# The pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index's right.
#
# If the index is on the left edge of the array, then the left sum is 0 because there are no elements to the left. This also applies to the right edge of the array.
#
# Return the leftmost pivot index. If no such index exists, return -1.
#
#
#
# Example 1:
#
# Input: nums = [1,7,3,6,5,6]
# Output: 3
# Explanation:
# The pivot index is 3.
# Left sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11
# Right sum = nums[4] + nums[5] = 5 + 6 = 11
# Example 2:
#
# Input: nums = [1,2,3]
# Output: -1
# Explanation:
# There is no index that satisfies the conditions in the problem statement.
# Example 3:
#
# Input: nums = [2,1,-1]
# Output: 0
# Explanation:
# The pivot index is 0.
# Left sum = 0 (no elements to the left of index 0)
# Right sum = nums[1] + nums[2] = 1 + -1 = 0
#
#
# Constraints:
#
# 1 <= nums.length <= 104
# -1000 <= nums[i] <= 1000
#
#
# Note: This question is the same as 1991: https://leetcode.com/problems/find-the-middle-index-in-array/
class Solution(object):
    def pivotIndex(self, nums):
        for i in range(len(nums)):
            if sum(nums[:i]) == sum(nums[i+1:]):
                return i
        return -1


# Game Hit the target
# Hit the target
# given a matrix n x n (2-7), determine if the arrow is directed to the target (x).
# There will be only 1 arrow '>' and 1 target 'x'
# An empty spot will be denoted by a space " ", the target with a cross "x", and the scope ">"
# Examples:
# given matrix 4x4:
# [
#
#   [' ', ' ', ' ', ' '],
#
#   [' ', ' ', ' ', ' '], --> return true
#
#   [' ', '>', ' ', 'x'],
#
#   [' ', ' ', ' ', ' ']
#
# ]
# given matrix 4x4:
# [
#
#   [' ', ' ', ' ', ' '],
#
#   [' ', '>', ' ', ' '], --> return false
#
#   [' ', ' ', ' ', 'x'],
#
#   [' ', ' ', ' ', ' ']
#
# ]
# given matrix 4x4:
# [
#
#   [' ', ' ', ' ', ' '],
#
#   [' ', 'x', '>', ' '], --> return false
#
#   [' ', '', ' ', ' '],
#
#   [' ', ' ', ' ', ' ']
#
# ]
#
# In this example, only a 4x4 matrix was used, the problem will have matrices of dimensions from 2 to 7
# Happy hacking as they say!
#
# GAMESMATRIXARRAYSSTRINGSFUNDAMENTALS
# Solution
def solution(mtrx):
    for i in mtrx:
        if '>' in i and 'x' in i:
            return i.index('>') < i.index('x')
    return False

# noobCode 03: CHECK THESE LETTERS... see if letters in "String 2" are present in "String 1"
# Write a function that checks if all the letters in the second string are present in the first one at least once, regardless of how many times they appear:
#
# ["ab", "aaa"]    =>  true
# ["trances", "nectar"]    =>  true
# ["compadres", "DRAPES"]  =>  true
# ["parses", "parsecs"]    =>  false
# Function should not be case sensitive, as indicated in example #2. Note: both strings are presented as a single argument in the form of an array.
#
# STRINGSALGORITHMS
 def letter_check(arr):
    return all(i.lower() in arr[0].lower() for i in arr[1])

# 191. Number of 1 Bits
# Write a function that takes the binary representation of an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight).
#
# Note:
#
# Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.
# In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 3, the input represents the signed integer. -3.
#
#
# Example 1:
#
# Input: n = 00000000000000000000000000001011
# Output: 3
# Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits.
# Example 2:
#
# Input: n = 00000000000000000000000010000000
# Output: 1
# Explanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit.
# Example 3:
#
# Input: n = 11111111111111111111111111111101
# Output: 31
# Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits.
#
#
# Constraints:
#
# The input must be a binary string of length 32.
#
#
# Follow up: If this function is called many times, how would you optimize it?
class Solution(object):
    def hammingWeight(self, n, count=0):
        return self.hammingWeight(n & n-1, count+1) if n!=0 else count

# 2869. Minimum Operations to Collect Elements
# You are given an array nums of positive integers and an integer k.
#
# In one operation, you can remove the last element of the array and add it to your collection.
#
# Return the minimum number of operations needed to collect elements 1, 2, ..., k.
#
#
#
# Example 1:
#
# Input: nums = [3,1,5,4,2], k = 2
# Output: 4
# Explanation: After 4 operations, we collect elements 2, 4, 5, and 1, in this order. Our collection contains elements 1 and 2. Hence, the answer is 4.
# Example 2:
#
# Input: nums = [3,1,5,4,2], k = 5
# Output: 5
# Explanation: After 5 operations, we collect elements 2, 4, 5, 1, and 3, in this order. Our collection contains elements 1 through 5. Hence, the answer is 5.
# Example 3:
#
# Input: nums = [3,2,5,3,1], k = 3
# Output: 4
# Explanation: After 4 operations, we collect elements 1, 3, 5, and 2, in this order. Our collection contains elements 1 through 3. Hence, the answer is 4.
#
#
# Constraints:
#
# 1 <= nums.length <= 50
# 1 <= nums[i] <= nums.length
# 1 <= k <= nums.length
# The input is generated such that you can collect elements 1, 2, ..., k.
class Solution(object):
    def minOperations(self, nums, k):
        d, count = {i: 1 for i in range(1, k +1)}, 0
        top = -1
        while d:
            if nums[top] in d:
                del d[nums[top]]
            top -= 1
        return abs(top) - 1


# Closest to Zero
# Simply find the closest value to zero from the list. Notice that there are negatives in the list.
#
# List is always not empty and contains only integers. Return None if it is not possible to define only one of such values. And of course, we are expecting 0 as closest value to zero.
#
# Examples:
#
# [2, 4, -1, -3]  => -1
# [5, 2, -2]      => None
# [5, 2, 2]       => 2
# [13, 0, -6]     => 0
# LISTSFUNDAMENTALS
def closest(lst):
    top = float('inf')
    for i in lst:
        if abs(i) < abs(top):
            top = i
    if lst.count(abs(top)) > 0 and lst.count(-top) > 0 and top != 0:
        return None
    return top

# 1662. Check If Two String Arrays are Equivalent
# Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.
#
# A string is represented by an array if the array elements concatenated in order forms the string.
#
#
#
# Example 1:
#
# Input: word1 = ["ab", "c"], word2 = ["a", "bc"]
# Output: true
# Explanation:
# word1 represents string "ab" + "c" -> "abc"
# word2 represents string "a" + "bc" -> "abc"
# The strings are the same, so return true.
# Example 2:
#
# Input: word1 = ["a", "cb"], word2 = ["ab", "c"]
# Output: false
# Example 3:
#
# Input: word1  = ["abc", "d", "defg"], word2 = ["abcddefg"]
# Output: true
#
#
# Constraints:
#
# 1 <= word1.length, word2.length <= 103
# 1 <= word1[i].length, word2[i].length <= 103
# 1 <= sum(word1[i].length), sum(word2[i].length) <= 103
# word1[i] and word2[i] consist of lowercase letters.
# Solution O(N) O(N)
class Solution(object):
    def arrayStringsAreEqual(self, word1, word2):
        return ''.join(word1) == ''.join(word2)

# Solution 2 - O(min(word1, word2)) Memory O(1)
class Solution(object):
    def arrayStringsAreEqual(self, word1, word2):
        for x, y in zip(self.generate(word1), self.generate(word2)):
            if x != y:
                return False
        return True

    def generate(self, n):
        for i in n:
            for j in i:
                yield j
        yield None
        
# Stacked Balls - 2D
# Background
# I have stacked some pool balls in a triangle.
#
# Like this,
#
# pool balls
# Kata Task
# Given the number of layers of my stack, what is the total height?
#
# Return the height as multiple of the ball diameter.
#
# Example
# The image above shows a stack of 5 layers.
#
# Notes
# layers >= 0
# approximate answers (within 0.001) are good enough
# See Also
#
# Stacked Balls - 2D
# Stacked Balls - 3D with square base
# Stacked Balls - 3D with triangle base
# FUNDAMENTALS
def stack_height_2d(layers):
    if layers in {0, 1}:
        return layers
    return 1 + (layers - 1) * 0.8660254

# 1160. Find Words That Can Be Formed by Characters
# You are given an array of strings words and a string chars.
#
# A string is good if it can be formed by characters from chars (each character can only be used once).
#
# Return the sum of lengths of all good strings in words.
#
#
#
# Example 1:
#
# Input: words = ["cat","bt","hat","tree"], chars = "atach"
# Output: 6
# Explanation: The strings that can be formed are "cat" and "hat" so the answer is 3 + 3 = 6.
# Example 2:
#
# Input: words = ["hello","world","leetcode"], chars = "welldonehoneyr"
# Output: 10
# Explanation: The strings that can be formed are "hello" and "world" so the answer is 5 + 5 = 10.
#
#
# Constraints:
#
# 1 <= words.length <= 1000
# 1 <= words[i].length, chars.length <= 100
# words[i] and chars consist of lowercase English letters.
# Solution
class Solution(object):
    def countCharacters(self, words, chars):
        d, count = {}, 0
        for i in chars:
            d[i] = d.get(i, 0) + 1
        for i in words:
            top, flag = {}, True
            for j in i:
                top[j] = top.get(j, 0) + 1
                if j not in d or top[j] > d[j]:
                    flag = False
                    break
            if flag:
                count += len(i)
        return count

# Supernatural
# This kata is a tribute/fanwork to the TV-show: Supernatural
#
# Balls!
#
# Those wayward Winchester boys are in trouble again, hunting something down in New Orleans. You are Bobby Singer, you know how "idjits" they can be, so you have to prepare. They will call you any minute with the race of the thing, and you want to answer as soon as possible. By answer, I mean: tell them how to kill, or fight it.
#
# You have something like a database (more like drunken doodling) to help them:
#
# werewolf : Silver knife or bullet to the heart
# vampire : Behead it with a machete
# wendigo : Burn it to death
# shapeshifter : Silver knife or bullet to the heart
# angel : Use the angelic blade
# demon : Use Ruby's knife, or some Jesus-juice
# ghost : Salt and iron, and don't forget to burn the corpse
# dragon : You have to find the excalibur for that
# djinn : Stab it with silver knife dipped in a lamb's blood
# pagan god : It depends on which one it is
# leviathan : Use some Borax, then kill Dick
# ghoul : Behead it
# jefferson starship : Behead it with a silver blade
# reaper : If it's nasty, you should gank who controls it
# rugaru : Burn it alive
# skinwalker : A silver bullet will do it
# phoenix : Use the colt
# witch : They are humans
# else : I have friggin no idea yet
# You can access the database as drunkenDoodling/drunken_doodling/DrunkenDoodling depending on your language.
#
# So a call would go down like this:
#
# The guys call you: bob('rugaru')
#
# ...and you reply (return) with the info, and your signature saying of yours! Burn it alive, idjits!
#
# GAMESFUNDAMENTALS
def bob(what):
    d = {'werewolf' : 'Silver knife or bullet to the heart', 'vampire' : 'Behead it with a machete',
        'wendigo' : 'Burn it to death', 'shapeshifter' : 'Silver knife or bullet to the heart',
        'angel' : 'Use the angelic blade', 'demon' : "Use Ruby's knife, or some Jesus-juice",
        'ghost' : "Salt and iron, and don't forget to burn the corpse", 'dragon' : 'You have to find the excalibur for that', 
         'djinn' : "Stab it with silver knife dipped in a lamb's blood",
        'pagan god' : 'It depends on which one it is', 'leviathan' : 'Use some Borax, then kill Dick',
        'ghoul' : 'Behead it', 'jefferson starship' : 'Behead it with a silver blade',
        'reaper' : "If it's nasty, you should gank who controls it", 'rugaru' : 'Burn it alive',
        'skinwalker' : 'A silver bullet will do it', 'phoenix' : 'Use the colt', 'witch' : 'They are humans'}
    word = ', idjits!'
    if what in d:
        return d[what] + word
    return 'I have friggin no idea yet' + word

# 1266. Minimum Time Visiting All Points
# On a 2D plane, there are n points with integer coordinates points[i] = [xi, yi]. Return the minimum time in seconds to visit all the points in the order given by points.
#
# You can move according to these rules:
#
# In 1 second, you can either:
# move vertically by one unit,
# move horizontally by one unit, or
# move diagonally sqrt(2) units (in other words, move one unit vertically then one unit horizontally in 1 second).
# You have to visit the points in the same order as they appear in the array.
# You are allowed to pass through points that appear later in the order, but these do not count as visits.
#
#
# Example 1:
#
#
# Input: points = [[1,1],[3,4],[-1,0]]
# Output: 7
# Explanation: One optimal path is [1,1] -> [2,2] -> [3,3] -> [3,4] -> [2,3] -> [1,2] -> [0,1] -> [-1,0]
# Time from [1,1] to [3,4] = 3 seconds
# Time from [3,4] to [-1,0] = 4 seconds
# Total time = 7 seconds
# Example 2:
#
# Input: points = [[3,2],[-2,2]]
# Output: 5
#
#
# Constraints:
#
# points.length == n
# 1 <= n <= 100
# points[i].length == 2
# -1000 <= points[i][0], points[i][1] <= 1000
# Solution O(N) O(1) Chebyshov Distance
class Solution(object):
    def minTimeToVisitAllPoints(self, points):
        count = 0
        for i in range(len(points) - 1):
            count += max(abs(points[i][0] - points[i + 1][0]), abs(points[i][1] - points[i + 1][1]))
        return count
    
# Cartesian coordinates from degree angle
# Write a simple function that takes polar coordinates (an angle in degrees and a radius) and returns the equivalent cartesian coordinates (rounded to 10 places).
#
# For example:
#
# coordinates(90,1)
# => (0.0, 1.0)
#
# coordinates(45, 1)
# => (0.7071067812, 0.7071067812)
# ALGORITHMSMATHEMATICSGEOMETRY
import math

def coordinates(degrees, radius):
    grad = degrees * (math.pi / 180)
    return (round(radius * math.cos(grad), 10), round(radius * math.sin(grad), 10))

# 2264. Largest 3-Same-Digit Number in String
# You are given a string num representing a large integer. An integer is good if it meets the following conditions:
#
# It is a substring of num with length 3.
# It consists of only one unique digit.
# Return the maximum good integer as a string or an empty string "" if no such integer exists.
#
# Note:
#
# A substring is a contiguous sequence of characters within a string.
# There may be leading zeroes in num or a good integer.
#
#
# Example 1:
#
# Input: num = "6777133339"
# Output: "777"
# Explanation: There are two distinct good integers: "777" and "333".
# "777" is the largest, so we return "777".
# Example 2:
#
# Input: num = "2300019"
# Output: "000"
# Explanation: "000" is the only good integer.
# Example 3:
#
# Input: num = "42352338"
# Output: ""
# Explanation: No substring of length 3 consists of only one unique digit. Therefore, there are no good integers.
#
#
# Constraints:
#
# 3 <= num.length <= 1000
# num only consists of digits.
# Solution 1 O(N) O(1)
class Solution(object):
    def largestGoodInteger(self, num):
        top, cop = '', num[0]
        for i in range(1, len(num)):
            if num[i] == cop[-1]:
                cop += num[i]
                if len(cop) == 3:
                    top = max(top, cop)
                    cop = cop[-1]
            else:
                cop = num[i]
        return top
# Solution 2 O(N) O(1)
class Solution(object):
    def largestGoodInteger(self, num):
        top = ''
        for i in range(2, len(num)):
            if num[i-2] == num[i-1] == num[i]:
                top = max(top, num[i-2:i+1])
        return top

# Find heavy ball - level: novice
# There are 8 balls numbered from 0 to 7. Seven of them have the same weight. One is heavier. Your task is to find its number.
#
# Your function findBall will receive single argument - scales object. The scales object contains an internally stored array of 8 elements (indexes 0-7), each having the same value except one, which is greater. It also has a public method named getWeight(left, right) which takes two arrays of indexes and returns -1, 0, or 1 based on the accumulation of the values found at the indexes passed are heavier, equal, or lighter.
#
# getWeight returns:
#
# -1 if left pan is heavier
#
# 1 if right pan is heavier
#
# 0 if both pans weight the same
#
# Examples of scales.getWeight() usage:
#
# scales.getWeight([3], [7]) returns -1 if ball 3 is heavier than ball 7, 1 if ball 7 is heavier, or 0 i these balls have the same weight.
#
# scales.getWeight([3, 4], [5, 2]) returns -1 if weight of balls 3 and 4 is heavier than weight of balls 5 and 2 etc.
#
# So where's the catch, you may ask. Well - the scales is very old. You can use it only 4 TIMES before the scale breaks.
#
# Note - Use scales.get_weight() in the Python, Crystal, Ruby And C versions.
#
# Too easy ? Try higher levels:
#
# conqueror
# master
# PUZZLESLOGICRIDDLES
def find_ball(scales):
    # call scales.get_weight() at most 4 TIMES
    # return indexOfHeavierBall
    for i in range(1, 8, 2):
        leftPan = [i-1]
        rightPan = [i]
        w = scales.get_weight(leftPan, rightPan)

        if w < 0:
            return leftPan[0]

        if w > 0:
            return rightPan[0]

# 1688. Count of Matches in Tournament
# You are given an integer n, the number of teams in a tournament that has strange rules:
#
# If the current number of teams is even, each team gets paired with another team. A total of n / 2 matches are played, and n / 2 teams advance to the next round.
# If the current number of teams is odd, one team randomly advances in the tournament, and the rest gets paired. A total of (n - 1) / 2 matches are played, and (n - 1) / 2 + 1 teams advance to the next round.
# Return the number of matches played in the tournament until a winner is decided.
#
#
#
# Example 1:
#
# Input: n = 7
# Output: 6
# Explanation: Details of the tournament:
# - 1st Round: Teams = 7, Matches = 3, and 4 teams advance.
# - 2nd Round: Teams = 4, Matches = 2, and 2 teams advance.
# - 3rd Round: Teams = 2, Matches = 1, and 1 team is declared the winner.
# Total number of matches = 3 + 2 + 1 = 6.
# Example 2:
#
# Input: n = 14
# Output: 13
# Explanation: Details of the tournament:
# - 1st Round: Teams = 14, Matches = 7, and 7 teams advance.
# - 2nd Round: Teams = 7, Matches = 3, and 4 teams advance.
# - 3rd Round: Teams = 4, Matches = 2, and 2 teams advance.
# - 4th Round: Teams = 2, Matches = 1, and 1 team is declared the winner.
# Total number of matches = 7 + 3 + 2 + 1 = 13.
#
#
# Constraints:
#
# 1 <= n <= 200
# Solution O(logN) O(1)
class Solution(object):
    def numberOfMatches(self, n):
        count = 0
        while n != 1:
            if n % 2 == 0:
                n = n / 2
                count += n
            else:
                count += (n - 1) / 2
                n = n // 2 + 1
        return count
# Solution O(1) O(1)
class Solution(object):
    def numberOfMatches(self, n):
        return n - 1

# Offload your work!
# You are the best freelancer in the city. Everybody knows you, but what they don't know, is that you are actually offloading your work to other freelancers and and you rarely need to do any work. You're living the life!
#
# To make this process easier you need to write a method called workNeeded to figure out how much time you need to contribute to a project.
#
# Giving the amount of time in minutes needed to complete the project and an array of pair values representing other freelancers' time in [Hours, Minutes] format ie. [[2, 33], [3, 44]] calculate how much time you will need to contribute to the project (if at all) and return a string depending on the case.
#
# If we need to contribute time to the project then return "I need to work x hour(s) and y minute(s)"
# If we don't have to contribute any time to the project then return "Easy Money!"
# FUNDAMENTALS
def work_needed(project_minutes, free_lancers):
    for i in free_lancers:
        if i[0] > 0:
            project_minutes -= i[0] * 60
        if i[1] > 0:
            project_minutes -= i[1]
    if project_minutes <= 0:
        return 'Easy Money!'
    return f'I need to work {project_minutes // 60} hour(s) and {project_minutes % 60} minute(s)'

# 1716. Calculate Money in Leetcode Bank
# Hercy wants to save money for his first car. He puts money in the Leetcode bank every day.
#
# He starts by putting in $1 on Monday, the first day. Every day from Tuesday to Sunday, he will put in $1 more than the day before. On every subsequent Monday, he will put in $1 more than the previous Monday.
# Given n, return the total amount of money he will have in the Leetcode bank at the end of the nth day.
#
#
#
# Example 1:
#
# Input: n = 4
# Output: 10
# Explanation: After the 4th day, the total is 1 + 2 + 3 + 4 = 10.
# Example 2:
#
# Input: n = 10
# Output: 37
# Explanation: After the 10th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37. Notice that on the 2nd Monday, Hercy only puts in $2.
# Example 3:
#
# Input: n = 20
# Output: 96
# Explanation: After the 20th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96.
#
#
# Constraints:
#
# 1 <= n <= 1000
class Solution(object):
    def totalMoney(self, n):
        if n % 7 == 0:
            return sum((1 + 7 + i * 2) * 7 / 2 for i in range(n // 7))
        x = sum((1 + 7 + i * 2) * 7 / 2 for i in range(n // 7))
        return x + sum(i + n // 7 for i in range(1, n % 7 + 1))

# Lottery machine
# Your task is to write an update for a lottery machine. Its current version produces a sequence of random letters and integers (passed as a string to the function). Your code must filter out all letters and return unique integers as a string, in their order of first appearance. If there are no integers in the string return "One more run!"
#
# Examples
# "hPrBKWDH8yc6Lt5NQZWQ"  -->  "865"
# "ynMAisVpHEqpqHBqTrwH"  -->  "One more run!"
# "555"                   -->  "5"
# STRINGSFUNDAMENTALS
def lottery(s):
    top = ''
    for i in s:
        if i.isdigit() and i not in top:
            top += i
    return top if top else 'One more run!'

# 1903. Largest Odd Number in String
# You are given a string num, representing a large integer. Return the largest-valued odd integer (as a string) that is a non-empty substring of num, or an empty string "" if no odd integer exists.
#
# A substring is a contiguous sequence of characters within a string.
#
#
#
# Example 1:
#
# Input: num = "52"
# Output: "5"
# Explanation: The only non-empty substrings are "5", "2", and "52". "5" is the only odd number.
# Example 2:
#
# Input: num = "4206"
# Output: ""
# Explanation: There are no odd numbers in "4206".
# Example 3:
#
# Input: num = "35427"
# Output: "35427"
# Explanation: "35427" is already an odd number.
#
#
# Constraints:
#
# 1 <= num.length <= 105
# num only consists of digits and does not contain any leading zeros.
class Solution(object):
    def largestOddNumber(self, num):
        while num[-1] not in {'1', '3', '5', '7', '9'}:
          num = num[:-1]
          if not num:
            return ''
        return num

# Mr Martingale
# You're in the casino, playing Roulette, going for the "1-18" bets only and desperate to beat the house and so you want to test how effective the Martingale strategy is.
#
# You will be given a starting cash balance and an array of binary digits to represent a win (1) or a loss (0). Return your balance after playing all rounds.
#
# The Martingale strategy
#
# You start with a stake of 100 dollars. If you lose a round, you lose the stake placed on that round and you double the stake for your next bet. When you win, you win 100% of the stake and revert back to staking 100 dollars on your next bet.
#
# Example
# martingale(1000, [1, 1, 0, 0, 1]) === 1300
# Explanation:
#
# you win your 1st round: gain $100, balance = 1100
# you win the 2nd round: gain $100, balance = 1200
# you lose the 3rd round: lose $100 dollars, balance = 1100
# double stake for 4th round and lose: staked $200, lose $200, balance = 900
# double stake for 5th round and win: staked $400, won $400, balance = 1300
# Note: Your balance is allowed to go below 0.
#
# GAMESPUZZLES
def martingale(bank, outcomes):
    top = 100
    for i in outcomes:
        if i == 1:
            bank += top
            top = 100
        else:
            bank -= top
            top *= 2
    return bank

# 606. Construct String from Binary Tree
# Given the root of a binary tree, construct a string consisting of parenthesis and integers from a binary tree with the preorder traversal way, and return it.
#
# Omit all the empty parenthesis pairs that do not affect the one-to-one mapping relationship between the string and the original binary tree.
#
#
#
# Example 1:
#
#
# Input: root = [1,2,3,4]
# Output: "1(2(4))(3)"
# Explanation: Originally, it needs to be "1(2(4)())(3()())", but you need to omit all the unnecessary empty parenthesis pairs. And it will be "1(2(4))(3)"
# Example 2:
#
#
# Input: root = [1,2,3,null,4]
# Output: "1(2()(4))(3)"
# Explanation: Almost the same as the first example, except we cannot omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output.
#
#
# Constraints:
#
# The number of nodes in the tree is in the range [1, 104].
# -1000 <= Node.val <= 1000
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def tree2str(self, root):
        if not root:
            return ''
        left = ('(' + str(self.tree2str(root.left)) + ')') if root.left or root.right else ''
        right = ('(' + str(self.tree2str(root.right)) + ')' ) if root.right else ''
        return str(root.val) + left + right

# Count up the points for the 7 Wonders board game! Easy version
# 7 Wonders
# 7 Wonders is a board game that consists of building your city, gathering resources and fighting your neighbors.
#
# One part of the game is also to research science in order to gain points at the end of the game. There are 3 types of science glyphs you can gather:
#
# Compasses
# Gears
# Tablets
# The way points are added up works as described here:
#
# Step 1
# Each distinct set of three different glyphs is worth 7 points:
#
# 1 Compass, 1 Gear and 1 Tablet    =  7 points
# 2 Compasses, 1 Gear and 1 Tablet  =  7 points (because it's just one disctinct set)
# Note that a distinct set of three different glyphs means 1 Compass, 1 Gear and 1 Tablet. No more, no less!
#
# Step 2
# The amount of each glyph you own is squared and then summed up:
#
# 1 Compass, 1 Gear and 1 Tablet    =  1*1 + 1*1 + 1*1  =  3 points
# 2 Compasses, 1 Gear and 1 Tablet  =  2*2 + 1*1 + 1*1  =  6 points
# Finally
# The total science points is equal to the sum of the two steps:
#
# 1 Compass, 1 Gear and 1 Tablet    =  7 + 3  =  10 points
# 2 Compasses, 1 Gear and 1 Tablet  =  7 + 6  =  13 points
# You will be given 3 inputs corresponding to the amount of each glyph you have acquired in the game. Your task is to output the final score. Take into account that you may have no glyphs at all!
#
# PUZZLES
def seven_wonders_science(compasses, gears, tablets):
    s1 = min(compasses, gears, tablets) * 7
    s2 = sum(i * i for i in (compasses, gears, tablets))
    return s1 + s2

# 94. Binary Tree Inorder Traversal
# Given the root of a binary tree, return the inorder traversal of its nodes' values.
#
#
#
# Example 1:
#
#
# Input: root = [1,null,2,3]
# Output: [1,3,2]
# Example 2:
#
# Input: root = []
# Output: []
# Example 3:
#
# Input: root = [1]
# Output: [1]
#
#
# Constraints:
#
# The number of nodes in the tree is in the range [0, 100].
# -100 <= Node.val <= 100
#
#
# Follow up: Recursive solution is trivial, could you do it iteratively?
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def inorderTraversal(self, root):
        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else []

# Most sales
# You work in the best consumer electronics corporation, and your boss wants to find out which three products generate the most revenue. Given 3 lists of the same length like these:
#
# products: ["Computer", "Cell Phones", "Vacuum Cleaner"]
# amounts: [3, 24, 8]
# prices: [199, 299, 399]
# return the three product names with the highest revenue (amount * price).
#
# Note: if multiple products have the same revenue, order them according to their original positions in the input list.
#
# FUNDAMENTALS
def top3(products, amounts, prices):
    d = {products[i]: amounts[i] * prices[i] for i in range(len(products))}
    l = sorted(d.items(), key=lambda x: x[1], reverse=True)
    return [i[0] for i in l][:3]

# 867. Transpose Matrix
# Given a 2D integer array matrix, return the transpose of matrix.
#
# The transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix's row and column indices.
#
#
#
#
#
# Example 1:
#
# Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
# Output: [[1,4,7],[2,5,8],[3,6,9]]
# Example 2:
#
# Input: matrix = [[1,2,3],[4,5,6]]
# Output: [[1,4],[2,5],[3,6]]
#
#
# Constraints:
#
# m == matrix.length
# n == matrix[i].length
# 1 <= m, n <= 1000
# 1 <= m * n <= 105
# -109 <= matrix[i][j] <= 109
class Solution(object):
    def transpose(self, matrix):
        m = [[0] * len(matrix) for j in range(len(matrix[0]))]
        for i in range(len(matrix[0])):
            for j in range(len(matrix)):
                m[i][j] = matrix[j][i]
        return m
    
# Thinking & Testing : How many "word"?
# No Story
#
# No Description
#
# Only by Thinking and Testing
#
# Look at result of testcase, guess the code!
#
# #Series:
# 01:A and B?
# 02:Incomplete string
# 03:True or False
# 04:Something capitalized
# 05:Uniq or not Uniq
# 06:Spatiotemporal index
# 07:Math of Primary School
# 08:Math of Middle school
# 09:From nothingness To nothingness
# 10:Not perfect? Throw away!
# 11:Welcome to take the bus
# 12:A happy day will come
# 13:Sum of 15(Hetu Luosliu)
# 14:Nebula or Vortex
# 15:Sport Star
# 16:Falsetto Rap Concert
# 17:Wind whispers
# 18:Mobile phone simulator
# 19:Join but not join
# 20:I hate big and small
# 21:I want to become diabetic ;-)
# 22:How many blocks?
# 23:Operator hidden in a string
# 24:Substring Magic
# 25:Report about something
# 26:Retention and discard I
# 27:Retention and discard II
# 28:How many "word"?
# 29:Hail and Waterfall
# 30:Love Forever
# 31:Digital swimming pool
# 32:Archery contest
# 33:The repair of parchment
# 34:Who are you?
# 35:Safe position
#
#
# #Special recommendation
# Another series, innovative and interesting, medium difficulty. People who like to challenge, can try these kata:
#
# <a href="http://www.codewars.com/kata/56c85eebfd8fc02551000281">Play Tetris : Shape anastomosis</a><br>
# Play FlappyBird : Advance Bravely
#
# PUZZLESGAMES
def testit(s):
    w, n, i = 'word', 0, 0
    for j in s.lower():
        if j == w[i]:
            n += j == w[-1]
            i = (i + 1) % len(w)
    return n

# 1287. Element Appearing More Than 25% In Sorted Array
# Given an integer array sorted in non-decreasing order, there is exactly one integer in the array that occurs more than 25% of the time, return that integer.
#
#
#
# Example 1:
#
# Input: arr = [1,2,2,6,6,6,6,7,10]
# Output: 6
# Example 2:
#
# Input: arr = [1,1]
# Output: 1
#
#
# Constraints:
#
# 1 <= arr.length <= 104
# 0 <= arr[i] <= 105
class Solution(object):
    def findSpecialInteger(self, arr):
        val, top, n = arr[0], 0, len(arr) // 4
        for i in range(len(arr)):
            if arr[i] == val:
                top += 1
                if top > n:
                    return  val
            else:
                val, top = arr[i], 1

# Noonerize Me
# Spoonerize... with numbers... numberize?... numboonerize?... noonerize? ...anyway! If you don't yet know what a spoonerism is and haven't yet tried my spoonerism kata, please do check it out first.
#
# You will create a function which takes an array of two positive integers, spoonerizes them, and returns the positive difference between them as a single number or 0 if the numbers are equal:
#
# [123, 456] = 423 - 156 = 267
# Your code must test that all array items are numbers and return "invalid array" if it finds that either item is not a number. The provided array will always contain 2 elements.
#
# When the inputs are valid, they will always be integers, no floats will be passed. However, you must take into account that the numbers will be of varying magnitude, between and within test cases.
#
# MATHEMATICSARRAYSALGORITHMS
def noonerize(numbers):
    if any(not isinstance(i, int) for i in numbers):
        return 'invalid array'
    return abs(int(str(numbers[1])[0] + str(numbers[0])[1:]) - int(str(numbers[0])[0] + str(numbers[1])[1:]))


# 1464. Maximum Product of Two Elements in an Array
# Given the array of integers nums, you will choose two different indices i and j of that array. Return the maximum value of (nums[i]-1)*(nums[j]-1).
#
#
# Example 1:
#
# Input: nums = [3,4,5,2]
# Output: 12
# Explanation: If you choose the indices i=1 and j=2 (indexed from 0), you will get the maximum value, that is, (nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12.
# Example 2:
#
# Input: nums = [1,5,4,5]
# Output: 16
# Explanation: Choosing the indices i=1 and j=3 (indexed from 0), you will get the maximum value of (5-1)*(5-1) = 16.
# Example 3:
#
# Input: nums = [3,7]
# Output: 12
#
#
# Constraints:
#
# 2 <= nums.length <= 500
# 1 <= nums[i] <= 10^3
class Solution(object):
    def maxProduct(self, nums):
        x, y = min(nums[0], nums[1]), max(nums[1], nums[0])
        for i in range(2, len(nums)):
            if nums[i] >= y:
                y, x = nums[i], y
            elif nums[i] > x:
                x = nums[i]
        return (x - 1) * (y - 1)


# 80's Kids #1: How Many Licks Does it Take?
# How many licks does it take to get to the tootsie roll center of a tootsie pop?
#
# A group of engineering students from Purdue University reported that its licking machine, modeled after a human tongue, took an average of 364 licks to get to the center of a Tootsie Pop. Twenty of the group's volunteers assumed the licking challenge-unassisted by machinery-and averaged 252 licks each to the center.
#
# Your task, if you choose to accept it, is to write a function that will return the number of licks it took to get to the tootsie roll center of a tootsie pop, given some environmental variables.
#
# Everyone knows it's harder to lick a tootsie pop in cold weather but it's easier if the sun is out. You will be given an object of environmental conditions for each trial paired with a value that will increase or decrease the number of licks. The environmental conditions all apply to the same trial.
#
# Assuming that it would normally take 252 licks to get to the tootsie roll center of a tootsie pop, return the new total of licks along with the condition that proved to be most challenging (causing the most added licks) in that trial.
#
# Example:
#
# totalLicks({ "freezing temps": 10, "clear skies": -2 });
# Should return:
#
# "It took 260 licks to get to the tootsie roll center of a tootsie pop. The toughest challenge was freezing temps."
# Other cases: If there are no challenges, the toughest challenge sentence should be omitted. If there are multiple challenges with the highest toughest amount, the first one presented will be the toughest. If an environment variable is present, it will be either a positive or negative integer. No need to validate.
#
# Check out my other 80's Kids Katas:
# 80's Kids #1: How Many Licks Does It Take
# 80's Kids #2: Help Alf Find His Spaceship
#
# 80's Kids #3: Punky Brewster's Socks
#
# 80's Kids #4: Legends of the Hidden Temple
#
# 80's Kids #5: You Can't Do That on Television
#
# 80's Kids #6: Rock 'Em, Sock 'Em Robots
#
# 80's Kids #7: She's a Small Wonder
#
# 80's Kids #8: The Secret World of Alex Mack
#
# 80's Kids #9: Down in Fraggle Rock
#
# 80's Kids #10: Captain Planet
#
# ALGORITHMS
def total_licks(env):
    if not env:
        return f'It took {252} licks to get to the tootsie roll center of a tootsie pop.'
    s = sum(v for k, v in env.items())
    w = f'It took {252 + s} licks to get to the tootsie roll center of a tootsie pop.'
    if s + 252 < 252:
        return w
    return w + f' The toughest challenge was {max(env, key=env.get)}.'

# 1582. Special Positions in a Binary Matrix
# Given an m x n binary matrix mat, return the number of special positions in mat.
#
# A position (i, j) is called special if mat[i][j] == 1 and all other elements in row i and column j are 0 (rows and columns are 0-indexed).
#
#
#
# Example 1:
#
#
# Input: mat = [[1,0,0],[0,0,1],[1,0,0]]
# Output: 1
# Explanation: (1, 2) is a special position because mat[1][2] == 1 and all other elements in row 1 and column 2 are 0.
# Example 2:
#
#
# Input: mat = [[1,0,0],[0,1,0],[0,0,1]]
# Output: 3
# Explanation: (0, 0), (1, 1) and (2, 2) are special positions.
#
#
# Constraints:
#
# m == mat.length
# n == mat[i].length
# 1 <= m, n <= 100
# mat[i][j] is either 0 or 1.
# Solution
class Solution(object):
    def numSpecial(self, mat):
        count = 0
        m, n = 0, 0
        while m < len(mat):
            for i in range(len(mat[m])):
                if mat[m][i] == 1:
                    top = 0
                    for k in range(len(mat[m])):
                        if mat[m][k] == 1:
                            top += 1
                            if top > 1:
                                break
                    if top == 1:
                        top = 0
                        for j in range(len(mat)):
                            if mat[j][i] == 1:
                                top += 1
                                if top > 1:
                                    break
                    if top == 1:
                        count += 1
            m += 1
        return count
# Solution 2 Python syntax sugar
class Solution(object):
    def numSpecial(self, mat):
        count = 0
        m = 0
        while m < len(mat):
            if mat[m].count(1) == 1:
                if sum(i[mat[m].index(1)] == 1 for i in mat) == 1:
                    count += 1
            m += 1
        return count
    
# Negative Connotation
# You will be given a string with sets of characters, (i.e. words), seperated by between one and four spaces (inclusive).
#
# Looking at the first letter of each word (case insensitive-"A" and "a" should be treated the same), you need to determine whether it falls into the positive/first half of the alphabet ("a"-"m") or the negative/second half ("n"-"z").
#
# Return True/true if there are more (or equal) positive words than negative words, False/false otherwise.
#
# "A big brown fox caught a bad rabbit" => True/true
# "Xylophones can obtain Xenon." => False/false
# FUNDAMENTALS
def connotation(strng):
    en_al_l = 'abcdefghijklmnopqrstuvwxyz'
    n = [1 if en_al_l.index(i[0].lower()) <= en_al_l.index('m') else 0 for i in strng.split()]
    return n.count(1) >= n.count(0)

# 2482. Difference Between Ones and Zeros in Row and Column
# You are given a 0-indexed m x n binary matrix grid.
#
# A 0-indexed m x n difference matrix diff is created with the following procedure:
#
# Let the number of ones in the ith row be onesRowi.
# Let the number of ones in the jth column be onesColj.
# Let the number of zeros in the ith row be zerosRowi.
# Let the number of zeros in the jth column be zerosColj.
# diff[i][j] = onesRowi + onesColj - zerosRowi - zerosColj
# Return the difference matrix diff.
#
#
#
# Example 1:
#
#
# Input: grid = [[0,1,1],[1,0,1],[0,0,1]]
# Output: [[0,0,4],[0,0,4],[-2,-2,2]]
# Explanation:
# - diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 2 + 1 - 1 - 2 = 0
# - diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 2 + 1 - 1 - 2 = 0
# - diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 2 + 3 - 1 - 0 = 4
# - diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 2 + 1 - 1 - 2 = 0
# - diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 2 + 1 - 1 - 2 = 0
# - diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 2 + 3 - 1 - 0 = 4
# - diff[2][0] = onesRow2 + onesCol0 - zerosRow2 - zerosCol0 = 1 + 1 - 2 - 2 = -2
# - diff[2][1] = onesRow2 + onesCol1 - zerosRow2 - zerosCol1 = 1 + 1 - 2 - 2 = -2
# - diff[2][2] = onesRow2 + onesCol2 - zerosRow2 - zerosCol2 = 1 + 3 - 2 - 0 = 2
# Example 2:
#
#
# Input: grid = [[1,1,1],[1,1,1]]
# Output: [[5,5,5],[5,5,5]]
# Explanation:
# - diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 3 + 2 - 0 - 0 = 5
# - diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 3 + 2 - 0 - 0 = 5
# - diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 3 + 2 - 0 - 0 = 5
# - diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 3 + 2 - 0 - 0 = 5
# - diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 3 + 2 - 0 - 0 = 5
# - diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 3 + 2 - 0 - 0 = 5
#
#
# Constraints:
#
# m == grid.length
# n == grid[i].length
# 1 <= m, n <= 105
# 1 <= m * n <= 105
# grid[i][j] is either 0 or 1.
class Solution(object):
    def onesMinusZeros(self, grid):
        n, m = len(grid), len(grid[0])
        r = [sum(grid[i]) for i in range(n)]
        c = [sum(grid[j][i] == 1 for j in range(n)) for i in range(m)]
        return [[r[i] + c[j] - (n - r[i] + m - c[j]) for j in range(m)] for i in range(n)]

# Differential Averaging
# Say you have a ratings system. People can rate a page, and the average is displayed on the page for everyone to see.
#
# One way of storing such a running average is to keep the the current average as well as the total rating that all users have submitted and with how many people rated it, so that the average can be calculated and updated when a new rating has been made.
#
# There are a couple of minor problems with this: first, you're keeping 3 columns instead of 1, which isn't ideal. Second is, if you're not careful, the number could get too large and get less and less accurate as the data format tries to keep up.
#
# So what you need to do is this: write a function that takes the current average, the current number of ratings (data points) made, and a new value to add to the average; then return the new value. That way, you only need 2 columns in your database, and the number will not get crazy large over time.
#
# To be clear:
#
# current = 0.5
# points = 2
# add = 1
#
# --> 0.6666666666666666666666666666666666 // (2/3)
# There are also plenty of examples in the example tests.
#
# MATHEMATICSALGEBRAALGORITHMS
def add_to_average(current, points, add):
    return (current * points + add) / (points + 1)

# 1436. Destination City
# You are given the array paths, where paths[i] = [cityAi, cityBi] means there exists a direct path going from cityAi to cityBi. Return the destination city, that is, the city without any path outgoing to another city.
#
# It is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city.
#
#
#
# Example 1:
#
# Input: paths = [["London","New York"],["New York","Lima"],["Lima","Sao Paulo"]]
# Output: "Sao Paulo"
# Explanation: Starting at "London" city you will reach "Sao Paulo" city which is the destination city. Your trip consist of: "London" -> "New York" -> "Lima" -> "Sao Paulo".
# Example 2:
#
# Input: paths = [["B","C"],["D","B"],["C","A"]]
# Output: "A"
# Explanation: All possible trips are:
# "D" -> "B" -> "C" -> "A".
# "B" -> "C" -> "A".
# "C" -> "A".
# "A".
# Clearly the destination city is "A".
# Example 3:
#
# Input: paths = [["A","Z"]]
# Output: "Z"
#
#
# Constraints:
#
# 1 <= paths.length <= 100
# paths[i].length == 2
# 1 <= cityAi.length, cityBi.length <= 10
# cityAi != cityBi
# All strings consist of lowercase and uppercase English letters and the space character.
# Solution O(N) O(N)
class Solution(object):
    def destCity(self, paths):
        city = set(path[0] for path in paths)
        for i in range(len(paths)):
            x = paths[i][1]
            if x not in city:
                return x

# An English Twist on a Japanese Classic
# Background:
# In Japan, a game called Shiritori is played. The rules are simple, a group of people take turns calling out a word whose beginning syllable is the same as the previous player's ending syllable. For example, the first person would say the word ねこ, and the second player must make a word that starts with こ, like　こむぎ. This repeats until a player can not think of a word fast enough or makes a word that ends in ん, because there are no words that begin with ん　in the Japanese language.
#
# English Shiritori has the same principle, with the first and last letters of words. That being said the lose condition is saying a word that doesn't start with the previous word's last letter or not saying a word quick enough.
#
# For example: apple -> eggs -> salmon -> nut -> turkey ...
#
# Your Task:
# You will be given a list of strings, a transcript of an English Shiritori match. Your task is to find out if the game ended early, and return a list that contains every valid string until the mistake. If a list is empty return an empty list. If one of the elements is an empty string, that is invalid and should be handled.
#
# Examples:
# All elements valid:
# The array {"dog","goose","elephant","tiger","rhino","orc","cat"}
#
# should return {"dog","goose","elephant","tiger","rhino","orc","cat"}
#
# An invalid element at index 2:
# The array {"dog","goose","tiger","cat", "elephant","rhino","orc"}
#
# should return ("dog","goose") since goose ends in 'e' and tiger starts with 't'
#
# An invalid empty string at index 2:
# The array {"ab","bc","","cd"}
#
# should return ("ab","bc")
#
# All invalid empty string at index 0:
# The array {"","bc","","cd"}
#
# should return An Empty List
#
# Resources:
# https://en.wikipedia.org/wiki/Shiritori
#
# Notes:
# 猫 = ねこ = neko = cat
#
# 小麦 = こむぎ = komugi = wheat
#
# FUNDAMENTALSALGORITHMSSTRINGS
def game(words):
    if not words or not words[0]:
        return []
    stack = [words[0]]
    for i in range(1, len(words)):
        if not words[i] or words[i][0] != stack[-1][-1]:
            break
        else:
            stack.append(words[i])
    return stack

# 2960. Count Tested Devices After Test Operations
# You are given a 0-indexed integer array batteryPercentages having length n, denoting the battery percentages of n 0-indexed devices.
#
# Your task is to test each device i in order from 0 to n - 1, by performing the following test operations:
#
# If batteryPercentages[i] is greater than 0:
# Increment the count of tested devices.
# Decrease the battery percentage of all devices with indices j in the range [i + 1, n - 1] by 1, ensuring their battery percentage never goes below 0, i.e, batteryPercentages[j] = max(0, batteryPercentages[j] - 1).
# Move to the next device.
# Otherwise, move to the next device without performing any test.
# Return an integer denoting the number of devices that will be tested after performing the test operations in order.
#
#
#
# Example 1:
#
# Input: batteryPercentages = [1,1,2,1,3]
# Output: 3
# Explanation: Performing the test operations in order starting from device 0:
# At device 0, batteryPercentages[0] > 0, so there is now 1 tested device, and batteryPercentages becomes [1,0,1,0,2].
# At device 1, batteryPercentages[1] == 0, so we move to the next device without testing.
# At device 2, batteryPercentages[2] > 0, so there are now 2 tested devices, and batteryPercentages becomes [1,0,1,0,1].
# At device 3, batteryPercentages[3] == 0, so we move to the next device without testing.
# At device 4, batteryPercentages[4] > 0, so there are now 3 tested devices, and batteryPercentages stays the same.
# So, the answer is 3.
# Example 2:
#
# Input: batteryPercentages = [0,1,2]
# Output: 2
# Explanation: Performing the test operations in order starting from device 0:
# At device 0, batteryPercentages[0] == 0, so we move to the next device without testing.
# At device 1, batteryPercentages[1] > 0, so there is now 1 tested device, and batteryPercentages becomes [0,1,1].
# At device 2, batteryPercentages[2] > 0, so there are now 2 tested devices, and batteryPercentages stays the same.
# So, the answer is 2.
#
#
# Constraints:
#
# 1 <= n == batteryPercentages.length <= 100
# 0 <= batteryPercentages[i] <= 100
# Solution 1 Similar bruteforce
# Complexity
# Time complexity: O(N**2 / 2)
#
# Space complexity: O(1)
#
# Code
class Solution(object):
    def countTestedDevices(self, batteryPercentages):
        count = 0
        for i in range(len(batteryPercentages)):
            if batteryPercentages[i] > 0:
                count += 1
                for j in range(i + 1, len(batteryPercentages)):
                    batteryPercentages[j] = max(0, batteryPercentages[j] - 1)
        return count
#
# Solution 2
# Complexity
# Time complexity: O(N)
#
# Space complexity: O(1)
#
class Solution(object):
    def countTestedDevices(self, batteryPercentages):
        count = 0
        for i in range(len(batteryPercentages)):
            count += batteryPercentages[i] > count
        return count

# 2961. Double Modular Exponentiation
# You are given a 0-indexed 2D array variables where variables[i] = [ai, bi, ci, mi], and an integer target.
#
# An index i is good if the following formula holds:
#
# 0 <= i < variables.length
# ((aibi % 10)ci) % mi == target
# Return an array consisting of good indices in any order.
#
#
#
# Example 1:
#
# Input: variables = [[2,3,3,10],[3,3,3,1],[6,1,1,4]], target = 2
# Output: [0,2]
# Explanation: For each index i in the variables array:
# 1) For the index 0, variables[0] = [2,3,3,10], (23 % 10)3 % 10 = 2.
# 2) For the index 1, variables[1] = [3,3,3,1], (33 % 10)3 % 1 = 0.
# 3) For the index 2, variables[2] = [6,1,1,4], (61 % 10)1 % 4 = 2.
# Therefore we return [0,2] as the answer.
# Example 2:
#
# Input: variables = [[39,3,1000,1000]], target = 17
# Output: []
# Explanation: For each index i in the variables array:
# 1) For the index 0, variables[0] = [39,3,1000,1000], (393 % 10)1000 % 1000 = 1.
# Therefore we return [] as the answer.
#
#
# Constraints:
#
# 1 <= variables.length <= 100
# variables[i] == [ai, bi, ci, mi]
# 1 <= ai, bi, ci, mi <= 103
# 0 <= target <= 103
# Solution O(N) O(N)
class Solution(object):
    def getGoodIndices(self, variables, target):
        out = set()
        for i in range(len(variables)):
            a, b, c, m = variables[i]
            if (a**b % 10)**c % m == target:
                out.add(i)
        return out

# 242. Valid Anagram
# Given two strings s and t, return true if t is an anagram of s, and false otherwise.
#
# An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.
#
#
#
# Example 1:
#
# Input: s = "anagram", t = "nagaram"
# Output: true
# Example 2:
#
# Input: s = "rat", t = "car"
# Output: false
#
#
# Constraints:
#
# 1 <= s.length, t.length <= 5 * 104
# s and t consist of lowercase English letters.
#
#
# Follow up: What if the inputs contain Unicode characters? How would you adapt your solution to such a case?
# Solution 1 - One HashTable O(N) O(N)
class Solution(object):
    def isAnagram(self, s, t):
        d = {}
        for i in s:
            d[i] = d.get(i, 0) + 1
        for i in t:
            d[i] = d.get(i, 0) - 1
        for i in d:
            if d[i] != 0:
                return False
        return True
# Solution 2 - Two HashTable O(N) O(N)
class Solution(object):
    def isAnagram(self, s, t):
        if len(s) != len(t):
            return False
        d1, d2 = {}, {}
        for i in s:
            if i  not in d1:
                d1[i] = 1
            else:
                d1[i] += 1
        for i in t:
            if i not in d2:
                d2[i] = 1
            else:
                d2[i] += 1
        return d1 == d2
 # Solution 3 - Similar Sorting O(N log(N)) O(N)
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        return sorted(s) == sorted(t)
# Solution 4 - One Liner O(N**2) O(N)
class Solution(object):
    def isAnagram(self, s, t):
        if len(s) != len(t):
            return False
        return all(s.count(i) == t.count(i) for i in t)
    
# Explosive Sum
# How many ways can you make the sum of a number?
# From wikipedia: https://en.wikipedia.org/wiki/Partition_(number_theory)
#
# In number theory and combinatorics, a partition of a positive integer n, also called an integer partition, is a way of writing n as a sum of positive integers. Two sums that differ only in the order of their summands are considered the same partition. If order matters, the sum becomes a composition. For example, 4 can be partitioned in five distinct ways:
#
# 4
# 3 + 1
# 2 + 2
# 2 + 1 + 1
# 1 + 1 + 1 + 1
# Examples
# Basic
# exp_sum(1) # 1
# exp_sum(2) # 2  -> 1+1 , 2
# exp_sum(3) # 3 -> 1+1+1, 1+2, 3
# exp_sum(4) # 5 -> 1+1+1+1, 1+1+2, 1+3, 2+2, 4
# exp_sum(5) # 7 -> 1+1+1+1+1, 1+1+1+2, 1+1+3, 1+2+2, 1+4, 5, 2+3
#
# exp_sum(10) # 42
# Explosive
# exp_sum(50) # 204226
# exp_sum(80) # 15796476
# exp_sum(100) # 190569292
# See here for more examples.
#
# ALGORITHMSMATHEMATICSFUNDAMENTALS
class PWithCache:
    def __init__(self):
        self.computed_pn = {0: 1}
    def __call__(self, n: int) -> int:
        if n in self.computed_pn:
            return self.computed_pn[n]
        total = 0
        for k in range(1, n+1):
            minus_one_term = n - k*(3*k-1)//2
            plus_one_term = n - k*(3*k+1)//2
            first_term = 0 if minus_one_term < 0 else self(minus_one_term)
            second_term = 0 if plus_one_term < 0 else self(plus_one_term)
            if k % 2:
                total += first_term + second_term
            else:
                total -= first_term + second_term
        self.computed_pn[n] = total
        return total

def exp_sum(n):
    P = PWithCache()
    return P(n)

# 2353. Design a Food Rating System
# Design a food rating system that can do the following:
#
# Modify the rating of a food item listed in the system.
# Return the highest-rated food item for a type of cuisine in the system.
# Implement the FoodRatings class:
#
# FoodRatings(String[] foods, String[] cuisines, int[] ratings) Initializes the system. The food items are described by foods, cuisines and ratings, all of which have a length of n.
# foods[i] is the name of the ith food,
# cuisines[i] is the type of cuisine of the ith food, and
# ratings[i] is the initial rating of the ith food.
# void changeRating(String food, int newRating) Changes the rating of the food item with the name food.
# String highestRated(String cuisine) Returns the name of the food item that has the highest rating for the given type of cuisine. If there is a tie, return the item with the lexicographically smaller name.
# Note that a string x is lexicographically smaller than string y if x comes before y in dictionary order, that is, either x is a prefix of y, or if i is the first position such that x[i] != y[i], then x[i] comes before y[i] in alphabetic order.
#
#
#
# Example 1:
#
# Input
# ["FoodRatings", "highestRated", "highestRated", "changeRating", "highestRated", "changeRating", "highestRated"]
# [[["kimchi", "miso", "sushi", "moussaka", "ramen", "bulgogi"], ["korean", "japanese", "japanese", "greek", "japanese", "korean"], [9, 12, 8, 15, 14, 7]], ["korean"], ["japanese"], ["sushi", 16], ["japanese"], ["ramen", 16], ["japanese"]]
# Output
# [null, "kimchi", "ramen", null, "sushi", null, "ramen"]
#
# Explanation
# FoodRatings foodRatings = new FoodRatings(["kimchi", "miso", "sushi", "moussaka", "ramen", "bulgogi"], ["korean", "japanese", "japanese", "greek", "japanese", "korean"], [9, 12, 8, 15, 14, 7]);
# foodRatings.highestRated("korean"); // return "kimchi"
#                                     // "kimchi" is the highest rated korean food with a rating of 9.
# foodRatings.highestRated("japanese"); // return "ramen"
#                                       // "ramen" is the highest rated japanese food with a rating of 14.
# foodRatings.changeRating("sushi", 16); // "sushi" now has a rating of 16.
# foodRatings.highestRated("japanese"); // return "sushi"
#                                       // "sushi" is the highest rated japanese food with a rating of 16.
# foodRatings.changeRating("ramen", 16); // "ramen" now has a rating of 16.
# foodRatings.highestRated("japanese"); // return "ramen"
#                                       // Both "sushi" and "ramen" have a rating of 16.
#                                       // However, "ramen" is lexicographically smaller than "sushi".
#
#
# Constraints:
#
# 1 <= n <= 2 * 104
# n == foods.length == cuisines.length == ratings.length
# 1 <= foods[i].length, cuisines[i].length <= 10
# foods[i], cuisines[i] consist of lowercase English letters.
# 1 <= ratings[i] <= 108
# All the strings in foods are distinct.
# food will be the name of a food item in the system across all calls to changeRating.
# cuisine will be a type of cuisine of at least one food item in the system across all calls to highestRated.
# At most 2 * 104 calls in total will be made to changeRating and highestRated.
from sortedcontainers import SortedList


class FoodRatings(object):
    def __init__(self, foods, cuisines, ratings):
        self.food_dct = {}
        self.csn_dct = defaultdict(SortedList)
        for food, cuisine, rating in zip(foods, cuisines, ratings):
            self.food_dct[food] = (cuisine, rating)
            self.csn_dct[cuisine].add((-rating, food))

    def changeRating(self, food, newRating):
        cuisine, rating = self.food_dct[food]
        self.food_dct[food] = cuisine, newRating
        self.csn_dct[cuisine].remove((-rating, food))
        self.csn_dct[cuisine].add((-newRating, food))

    def highestRated(self, cuisine):
        return self.csn_dct[cuisine][0][1]
    
# Common Denominators
# Common denominators
#
# You will have a list of rationals in the form
#
# { {numer_1, denom_1} , ... {numer_n, denom_n} }
# or
# [ [numer_1, denom_1] , ... [numer_n, denom_n] ]
# or
# [ (numer_1, denom_1) , ... (numer_n, denom_n) ]
# where all numbers are positive ints. You have to produce a result in the form:
#
# (N_1, D) ... (N_n, D)
# or
# [ [N_1, D] ... [N_n, D] ]
# or
# [ (N_1', D) , ... (N_n, D) ]
# or
# {{N_1, D} ... {N_n, D}}
# or
# "(N_1, D) ... (N_n, D)"
# depending on the language (See Example tests) in which D is as small as possible and
#
# N_1/D == numer_1/denom_1 ... N_n/D == numer_n,/denom_n.
# Example:
# convertFracs [(1, 2), (1, 3), (1, 4)] `shouldBe` [(6, 12), (4, 12), (3, 12)]
# Note:
# Due to the fact that the first translations were written long ago - more than 6 years - these first translations have only irreducible fractions.
#
# Newer translations have some reducible fractions. To be on the safe side it is better to do a bit more work by simplifying fractions even if they don't have to be.
#
# Note for Bash:
# input is a string, e.g "2,4,2,6,2,8" output is then "6 12 4 12 3 12"
#
# FUNDAMENTALSALGORITHMSMATHEMATICS
import math
def convertFracts(lst):
    D = 1
    for _, den in lst:
        D *= den // math.gcd(den, D)
    return [[D*n//d, D] for n, d in lst]

# 1913. Maximum Product Difference Between Two Pairs
# The product difference between two pairs (a, b) and (c, d) is defined as (a * b) - (c * d).
#
# For example, the product difference between (5, 6) and (2, 7) is (5 * 6) - (2 * 7) = 16.
# Given an integer array nums, choose four distinct indices w, x, y, and z such that the product difference between pairs (nums[w], nums[x]) and (nums[y], nums[z]) is maximized.
#
# Return the maximum such product difference.
#
#
#
# Example 1:
#
# Input: nums = [5,6,2,7,4]
# Output: 34
# Explanation: We can choose indices 1 and 3 for the first pair (6, 7) and indices 2 and 4 for the second pair (2, 4).
# The product difference is (6 * 7) - (2 * 4) = 34.
# Example 2:
#
# Input: nums = [4,2,5,9,7,4,8]
# Output: 64
# Explanation: We can choose indices 3 and 6 for the first pair (9, 8) and indices 1 and 5 for the second pair (2, 4).
# The product difference is (9 * 8) - (2 * 4) = 64.
#
#
# Constraints:
#
# 4 <= nums.length <= 104
# 1 <= nums[i] <= 104
class Solution(object):
    def maxProductDifference(self, nums):
        w, x = 0, 0,
        for i in range(len(nums)):
            if w <=  nums[i]:
                w, x, = nums[i], w
            elif x <= nums[i]:
                x = nums[i]
        y, z = float('inf'), float('inf')
        for i in range(len(nums)):
            if y >= nums[i]:
                y, z = nums[i], y
            elif z >= nums[i]:
                z = nums[i]
        return (w * x) - (y * z)
    
# Hamming Numbers
# A Hamming number is a positive integer of the form 2i3j5k, for some non-negative integers i, j, and k.
#
# Write a function that computes the nth smallest Hamming number.
#
# Specifically:
#
# The first smallest Hamming number is 1 = 203050
# The second smallest Hamming number is 2 = 213050
# The third smallest Hamming number is 3 = 203150
# The fourth smallest Hamming number is 4 = 223050
# The fifth smallest Hamming number is 5 = 203051
# The 20 smallest Hamming numbers are given in the Example test fixture.
#
# Your code should be able to compute the first 5 000 ( LC: 400, Clojure: 2 000, Haskell: 12 691, NASM, C, D, C++, Go and Rust: 13 282 ) Hamming numbers without timing out.
#
# NUMBER THEORYALGORITHMS
def hamming(n):
    l = [1]
    n2, n3, n5 = 0, 0, 0
    for i in range(1, n):
        mn = min(l[n2] * 2, l[n3] * 3, l[n5] * 5)
        if 2 * l[n2] == mn:
            n2 += 1
        if 3 * l[n3] == mn:
            n3 += 1
        if 5 * l[n5] == mn:
            n5 += 1
        l.append(mn)
    return l[-1]

# 661. Image Smoother
# An image smoother is a filter of the size 3 x 3 that can be applied to each cell of an image by rounding down the average of the cell and the eight surrounding cells (i.e., the average of the nine cells in the blue smoother). If one or more of the surrounding cells of a cell is not present, we do not consider it in the average (i.e., the average of the four cells in the red smoother).
#
#
# Given an m x n integer matrix img representing the grayscale of an image, return the image after applying the smoother on each cell of it.
#
#
#
# Example 1:
#
#
# Input: img = [[1,1,1],[1,0,1],[1,1,1]]
# Output: [[0,0,0],[0,0,0],[0,0,0]]
# Explanation:
# For the points (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0
# For the points (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0
# For the point (1,1): floor(8/9) = floor(0.88888889) = 0
# Example 2:
#
#
# Input: img = [[100,200,100],[200,50,200],[100,200,100]]
# Output: [[137,141,137],[141,138,141],[137,141,137]]
# Explanation:
# For the points (0,0), (0,2), (2,0), (2,2): floor((100+200+200+50)/4) = floor(137.5) = 137
# For the points (0,1), (1,0), (1,2), (2,1): floor((200+200+50+200+100+100)/6) = floor(141.666667) = 141
# For the point (1,1): floor((50+200+200+200+200+100+100+100+100)/9) = floor(138.888889) = 138
#
#
# Constraints:
#
# m == img.length
# n == img[i].length
# 1 <= m, n <= 200
# 0 <= img[i][j] <= 255
class Solution(object):
    def imageSmoother(self, img):
        """
        :type img: List[List[int]]
        :rtype: List[List[int]]
        """
        m, n = len(img), len(img[0])
        l = [[0 for i in range(n)] for j in range(m)]
        for i in range(m):
            for j in range(n):
                out = []
                out.append(img[i][j])
                if 0 <= i-1 < m:
                    out.append(img[i-1][j])
                    if 0 <= j-1 < n:
                        out.append(img[i-1][j-1])
                    if 0 <= j+1 < n:
                        out.append(img[i-1][j+1])
                if 0 <= j-1 < n:
                    out.append(img[i][j-1])
                if 0 <= j+1 < n:
                    out.append(img[i][j+1])
                if 0 <= i+1 < m:
                    out.append(img[i+1][j])
                    if 0 <= j-1 < n:
                        out.append(img[i+1][j-1])
                    if 0 <= j+1 < n:
                        out.append(img[i+1][j+1])
                l[i][j] = sum(out) // len(out)
        return l

# Validate Sudoku with size `NxN`
# Given a Sudoku data structure with size NxN, N > 0 and √N == integer, write a method to validate if it has been filled out correctly.
#
# The data structure is a multi-dimensional Array, i.e:
#
# [
#   [7,8,4,  1,5,9,  3,2,6],
#   [5,3,9,  6,7,2,  8,4,1],
#   [6,1,2,  4,3,8,  7,5,9],
#
#   [9,2,8,  7,1,5,  4,6,3],
#   [3,5,7,  8,4,6,  1,9,2],
#   [4,6,1,  9,2,3,  5,8,7],
#
#   [8,7,6,  3,9,4,  2,1,5],
#   [2,4,3,  5,6,1,  9,7,8],
#   [1,9,5,  2,8,7,  6,3,4]
# ]
# Rules for validation
#
# Data structure dimension: NxN where N > 0 and √N == integer
# Rows may only contain integers: 1..N (N included)
# Columns may only contain integers: 1..N (N included)
# 'Little squares' (3x3 in example above) may also only contain integers: 1..N (N included)
# ARRAYSPUZZLESALGORITHMS
class Sudoku(object):
    def __init__(self, data):
        self.data = data
    def is_valid(self):
        if any(len(i) != len(self.data) for i in self.data):
            return False
        for i in range(len(self.data)):
            s = set(range(1, len(self.data) + 1))
            for j in range(len(self.data)):
                if not isinstance(self.data[i][j], int) or type(self.data[i][j]) == bool:
                    return False
                if self.data[i][j] in s:
                    s.remove(self.data[i][j])
            if len(s) != 0:
                return False
        for i in range(len(self.data)):
            s = set(range(1, len(self.data) + 1))
            for j in range(len(self.data)):
                if self.data[j][i] in s:
                    s.remove(self.data[j][i])
            if len(s) != 0:
                return False
        step = 1
        while step ** 2 < len(self.data):
            step += 1
        pos = list(range(step))
        for i in range(0, len(self.data), step):
            for j in range(0, len(self.data), step):
                s = set(range(1, len(self.data) + 1))
                for k in pos:
                    for l in pos:
                        if self.data[i+k][j + l] not in s:
                            return False
                        else:
                            s.remove(self.data[i+k][j + l])
        return True

# 2706. Buy Two Chocolates
# You are given an integer array prices representing the prices of various chocolates in a store. You are also given a single integer money, which represents your initial amount of money.
#
# You must buy exactly two chocolates in such a way that you still have some non-negative leftover money. You would like to minimize the sum of the prices of the two chocolates you buy.
#
# Return the amount of money you will have leftover after buying the two chocolates. If there is no way for you to buy two chocolates without ending up in debt, return money. Note that the leftover must be non-negative.
#
#
#
# Example 1:
#
# Input: prices = [1,2,2], money = 3
# Output: 0
# Explanation: Purchase the chocolates priced at 1 and 2 units respectively. You will have 3 - 3 = 0 units of money afterwards. Thus, we return 0.
# Example 2:
#
# Input: prices = [3,2,3], money = 3
# Output: 3
# Explanation: You cannot buy 2 chocolates without going in debt, so we return 3.
#
#
# Constraints:
#
# 2 <= prices.length <= 50
# 1 <= prices[i] <= 100
# 1 <= money <= 100
# Solution O(N) O(1)
class Solution(object):
    def buyChoco(self, prices, money):
        ab_m, m = float('inf'), float('inf')
        for i in prices:
            if ab_m > i:
                ab_m, m = i, ab_m
            elif m > i:
                m = i
        return money - (ab_m + m) if ab_m + m <= money else money

# Vigenère Cipher Helper
# The Vigenère cipher is a classic cipher originally developed by Italian cryptographer Giovan Battista Bellaso and published in 1553. It is named after a later French cryptographer Blaise de Vigenère, who had developed a stronger autokey cipher (a cipher that incorporates the message of the text into the key).
#
# The cipher is easy to understand and implement, but survived three centuries of attempts to break it, earning it the nickname "le chiffre indéchiffrable" or "the indecipherable cipher."
#
# From Wikipedia:
#
# The Vigenère cipher is a method of encrypting alphabetic text by using a series of different Caesar ciphers based on the letters of a keyword. It is a simple form of polyalphabetic substitution.
#
# . . .
#
# In a Caesar cipher, each letter of the alphabet is shifted along some number of places; for example, in a Caesar cipher of shift 3, A would become D, B would become E, Y would become B and so on. The Vigenère cipher consists of several Caesar ciphers in sequence with different shift values.
#
# Assume the key is repeated for the length of the text, character by character. Note that some implementations repeat the key over characters only if they are part of the alphabet -- this is not the case here.
#
# The shift is derived by applying a Caesar shift to a character with the corresponding index of the key in the alphabet.
#
# Visual representation:
#
# "my secret code i want to secure"  // message
# "passwordpasswordpasswordpasswor"  // key
# Write a class that, when given a key and an alphabet, can be used to encode and decode from the cipher.
#
# Example
# var alphabet = 'abcdefghijklmnopqrstuvwxyz';
# var key = 'password';
#
# // creates a cipher helper with each letter substituted
# // by the corresponding character in the key
# var c = new VigenèreCipher(key, alphabet);
#
# c.encode('codewars'); // returns 'rovwsoiv'
# c.decode('laxxhsj');  // returns 'waffles'
# Any character not in the alphabet must be left as is. For example (following from above):
#
# c.encode('CODEWARS'); // returns 'CODEWARS'
# ALGORITHMSCIPHERSSECURITYOBJECT-ORIENTED PROGRAMMINGSTRINGS
class VigenereCipher(object):
    def __init__(self, key, alphabet):
        self.key = key * 10
        self.alphabet = alphabet * 2

    def encode(self, text):
        l = []
        for i in range(len(text)):
            if text[i].isalpha() and text[i] in self.alphabet:
                l.append(self.alphabet[self.alphabet.index(text[i]) + self.alphabet.index(self.key[i])])
            else:
                l.append(text[i])
        return ''.join(l)

    def decode(self, text):
        l = []
        for i in range(len(text)):
            if text[i].isalpha() and text[i] in self.alphabet:
                l.append(self.alphabet[
                             self.alphabet.index(text[i], len(self.alphabet) // 2) - self.alphabet.index(self.key[i])])
            else:
                l.append(text[i])
        return ''.join(l)

# 1637. Widest Vertical Area Between Two Points Containing No Points
# Given n points on a 2D plane where points[i] = [xi, yi], Return the widest vertical area between two points such that no points are inside the area.
#
# A vertical area is an area of fixed-width extending infinitely along the y-axis (i.e., infinite height). The widest vertical area is the one with the maximum width.
#
# Note that points on the edge of a vertical area are not considered included in the area.
#
#
#
# Example 1:
#
# ​
# Input: points = [[8,7],[9,9],[7,4],[9,7]]
# Output: 1
# Explanation: Both the red and the blue area are optimal.
# Example 2:
#
# Input: points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]]
# Output: 3
#
#
# Constraints:
#
# n == points.length
# 2 <= n <= 105
# points[i].length == 2
# 0 <= xi, yi <= 109
# Solution O(N log N) O(1)
class Solution:
    def maxWidthOfVerticalArea(self, points: List[List[int]]) -> int:
        points.sort()
        top, strt = 0, points[0][0]
        for i in range(1, len(points)):
            if points[i][0] != strt:
                top = max(top, points[i][0] - strt)
                strt = points[i][0]
        return top
# Solution 2 O(N log N) O(N)
class Solution:
    def maxWidthOfVerticalArea(self, points: List[List[int]]) -> int:
        l = sorted({x for x, y in points})
        return max([x2 - x1 for x1, x2 in zip(l, l[1:])] + [0])

# Financing Plan on Planet XY140Z-n
# I need to save some money to buy a gift. I think I can do something like that:
#
# First week (W0) I save nothing on Sunday, 1 on Monday, 2 on Tuesday... 6 on Saturday, second week (W1) 2 on Monday... 7 on Saturday and so on according to the table below where the days are numbered from 0 to 6.
#
# Can you tell me how much I will have for my gift on Saturday evening after I have saved 12? (Your function finance(6) should return 168 which is the sum of the savings in the table).
#
# Imagine now that we live on planet XY140Z-n where the days of the week are numbered from 0 to n (integer n > 0) and where I save from week number 0 to week number n included (in the table below n = 6).
#
# How much money would I have at the end of my financing plan on planet XY140Z-n?
#
# --	Su	Mo	Tu	We	Th	Fr	Sa
# W6							12
# W5						10	11
# W4					8	9	10
# W3				6	7	8	9
# W2			4	5	6	7	8
# W1		2	3	4	5	6	7
# W0	0	1	2	3	4	5	6
# Example:
# finance(5) --> 105
# finance(6) --> 168
# finance(7) --> 252
# finance(5000) --> 62537505000
# Note:
# your solution will be nicer without loops.
#
# MATHEMATICSALGORITHMS
# Solution 1
def finance(n):
    count = 3
    for i in range(2, n + 1):
        count += sum(range(i, i*2 + 1))
    return count
# Solution 2 Math solution
def finance(n):
    return n * (n + 1) * (n + 2) / 2

# 1422. Maximum Score After Splitting a String
# Given a string s of zeros and ones, return the maximum score after splitting the string into two non-empty substrings (i.e. left substring and right substring).
#
# The score after splitting a string is the number of zeros in the left substring plus the number of ones in the right substring.
#
#
#
# Example 1:
#
# Input: s = "011101"
# Output: 5
# Explanation:
# All possible ways of splitting s into two non-empty substrings are:
# left = "0" and right = "11101", score = 1 + 4 = 5
# left = "01" and right = "1101", score = 1 + 3 = 4
# left = "011" and right = "101", score = 1 + 2 = 3
# left = "0111" and right = "01", score = 1 + 1 = 2
# left = "01110" and right = "1", score = 2 + 1 = 3
# Example 2:
#
# Input: s = "00111"
# Output: 5
# Explanation: When left = "00" and right = "111", we get the maximum score = 2 + 3 = 5
# Example 3:
#
# Input: s = "1111"
# Output: 3
#
#
# Constraints:
#
# 2 <= s.length <= 500
# The string s consists of characters '0' and '1' only.
# Solution O(N) O(1)
class Solution:
    def maxScore(self, s: str) -> int:
        count_s = s.count('1', 1)
        if s[0] == '0':
            count_s += 1
        total = count_s
        for i in range(1, len(s) - 1):
            if s[i] == '0':
                count_s += 1
            else:
                count_s -= 1
            total = max(total, count_s)
        return total

# Least Common Multiple
# Write a function that calculates the least common multiple of its arguments; each argument is assumed to be a non-negative integer. In the case that there are no arguments (or the provided array in compiled languages is empty), return 1. If any argument is 0, return 0.
#
# MATHEMATICSALGORITHMS
def lcm(*args):
    if not args:
        return 1
    if 0 in args:
        return 0
    m = max(args)
    lcm = m
    while any(lcm % i != 0 for i in args):
        lcm += m
    return lcm

# 1496. Path Crossing
# Given a string path, where path[i] = 'N', 'S', 'E' or 'W', each representing moving one unit north, south, east, or west, respectively. You start at the origin (0, 0) on a 2D plane and walk on the path specified by path.
#
# Return true if the path crosses itself at any point, that is, if at any time you are on a location you have previously visited. Return false otherwise.
#
#
#
# Example 1:
#
#
# Input: path = "NES"
# Output: false
# Explanation: Notice that the path doesn't cross any point more than once.
# Example 2:
#
#
# Input: path = "NESWW"
# Output: true
# Explanation: Notice that the path visits the origin twice.
#
#
# Constraints:
#
# 1 <= path.length <= 104
# path[i] is either 'N', 'S', 'E', or 'W'.
# Solution O(N) O(N)
class Solution:
    def isPathCrossing(self, path: str) -> bool:
        x, y = 0, 0
        st = {(x, y)}
        for i in path:
            x += 1 if i == 'E' else (-1 if i == 'W' else 0)
            y += 1 if i == 'N' else (-1 if i == 'S' else 0)
            if (x, y) in st:
                return True
            st.add((x, y))
        return False

# flatten()
# For this exercise you will create a global flatten method. The method takes in any number of arguments and flattens them into a single array. If any of the arguments passed in are an array then the individual objects within the array will be flattened so that they exist at the same level as the other arguments. Any nested arrays, no matter how deep, should be flattened into the single array result.
#
# The following are examples of how this function would be used and what the expected results would be:
#
# flatten(1, [2, 3], 4, 5, [6, [7]]) # returns [1, 2, 3, 4, 5, 6, 7]
# flatten('a', ['b', 2], 3, None, [[4], ['c']]) # returns ['a', 'b', 2, 3, None, 4, 'c']
# ARRAYSALGORITHMS
def flatten(*args):
    if not args:
        return []
    l = []
    for i in args:
        if isinstance(i, list):
            l += flatten(*i)
        else:
            l += [i]
    return l

# 2966. Divide Array Into Arrays With Max Difference
# You are given an integer array nums of size n and a positive integer k.
#
# Divide the array into one or more arrays of size 3 satisfying the following conditions:
#
# Each element of nums should be in exactly one array.
# The difference between any two elements in one array is less than or equal to k.
# Return a 2D array containing all the arrays. If it is impossible to satisfy the conditions, return an empty array. And if there are multiple answers, return any of them.
#
#
#
# Example 1:
#
# Input: nums = [1,3,4,8,7,9,3,5,1], k = 2
# Output: [[1,1,3],[3,4,5],[7,8,9]]
# Explanation: We can divide the array into the following arrays: [1,1,3], [3,4,5] and [7,8,9].
# The difference between any two elements in each array is less than or equal to 2.
# Note that the order of elements is not important.
# Example 2:
#
# Input: nums = [1,3,3,2,7,3], k = 3
# Output: []
# Explanation: It is not possible to divide the array satisfying all the conditions.
#
#
# Constraints:
#
# n == nums.length
# 1 <= n <= 105
# n is a multiple of 3.
# 1 <= nums[i] <= 105
# 1 <= k <= 105
# Solution O(N log N) O(N)
class Solution(object):
    def divideArray(self, nums, k):
        if len(nums) < 3:
            return []
        nums.sort()
        l = []
        for i in range(0, len(nums), 3):
            if nums[i + 2] - nums[i] > k:
                return []
            else:
                l.append(nums[i:i+3])
        return l
    
# 2965. Find Missing and Repeated Values
# You are given a 0-indexed 2D integer matrix grid of size n * n with values in the range [1, n2]. Each integer appears exactly once except a which appears twice and b which is missing. The task is to find the repeating and missing numbers a and b.
#
# Return a 0-indexed integer array ans of size 2 where ans[0] equals to a and ans[1] equals to b.
#
#
#
# Example 1:
#
# Input: grid = [[1,3],[2,2]]
# Output: [2,4]
# Explanation: Number 2 is repeated and number 4 is missing so the answer is [2,4].
# Example 2:
#
# Input: grid = [[9,1,7],[8,9,2],[3,4,6]]
# Output: [9,5]
# Explanation: Number 9 is repeated and number 5 is missing so the answer is [9,5].
#
#
# Constraints:
#
# 2 <= n == grid.length == grid[i].length <= 50
# 1 <= grid[i][j] <= n * n
# For all x that 1 <= x <= n * n there is exactly one x that is not equal to any of the grid members.
# For all x that 1 <= x <= n * n there is exactly one x that is equal to exactly two of the grid members.
# For all x that 1 <= x <= n * n except two of them there is exatly one pair of i, j that 0 <= i, j <= n - 1 and grid[i][j] == x.
# Solution O(N) O(N) Math
class Solution(object):
    def findMissingAndRepeatedValues(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: List[int]
        """
        n = len(grid)
        sm, total, sn = n**2 * (n**2 + 1) // 2, 0, set()
        for i in range(n):
            for j in range(n):
                total += grid[i][j]
                if grid[i][j] in sn:
                    rep_num = grid[i][j]
                sn.add(grid[i][j])
        return [rep_num, (sm - total) + rep_num]

# 1758. Minimum Changes To Make Alternating Binary String
# You are given a string s consisting only of the characters '0' and '1'. In one operation, you can change any '0' to '1' or vice versa.
#
# The string is called alternating if no two adjacent characters are equal. For example, the string "010" is alternating, while the string "0100" is not.
#
# Return the minimum number of operations needed to make s alternating.
#
#
#
# Example 1:
#
# Input: s = "0100"
# Output: 1
# Explanation: If you change the last character to '1', s will be "0101", which is alternating.
# Example 2:
#
# Input: s = "10"
# Output: 0
# Explanation: s is already alternating.
# Example 3:
#
# Input: s = "1111"
# Output: 2
# Explanation: You need two operations to reach "0101" or "1010".
#
#
# Constraints:
#
# 1 <= s.length <= 104
# s[i] is either '0' or '1'.
# Solution 1 - O(N) O(1) HashSet
class Solution:
    def minOperations(self, s: str) -> int:
        d = {'0':'1', '1':'0'}
        top, count = 0, 0
        cur = '0'
        for i in range(len(s)):
            if cur == s[i]:
                count += 1
                cur = d[cur]
            else:
                cur = s[i]
        top = count
        count, cur = 0, '1'
        for i in range(len(s)):
            if cur == s[i]:
                count += 1
                cur = d[cur]
            else:
                cur = s[i]
        return min(top, count)
# Solution 2 OnePass O(N) O(N)
class Solution:
    def minOperations(self, s: str) -> int:
        count_one, count_zero = 0, 0
        cur_zero, cur_one = '0', '1'
        for i in range(len(s)):
            if s[i] == cur_zero:
                count_zero += 1
            else:
                count_one += 1
            cur_one, cur_zero = cur_zero, cur_one
        return min(count_zero, count_one)
    
# Sorting by bits
# In this kata you're expected to sort an array of 32-bit integers in ascending order of the number of on bits they have.
#
# E.g Given the array [7, 6, 15, 8]
#
# 7 has 3 on bits (000...0111)
# 6 has 2 on bits (000...0110)
# 15 has 4 on bits (000...1111)
# 8 has 1 on bit (000...1000)
# So the array in sorted order would be [8, 6, 7, 15].
#
# In cases where two numbers have the same number of bits, compare their real values instead.
#
# E.g between 10 (...1010) and 12 (...1100), they both have the same number of on bits '2' but the integer 10 is less than 12 so it comes first in sorted order.
#
# Your task is to write a function that takes an array of integers and sort them as described above.
#
# Note: your solution has to sort the array in place.
#
# Example:
#
# [3, 8, 3, 6, 5, 7, 9, 1]   =>    [1, 8, 3, 3, 5, 6, 9, 7]
# LOGICARRAYSALGORITHMSDATA STRUCTURESFUNDAMENTALSBITSBINARYSORTING
# Solution 1 - Using sort
def sort_by_bit(arr):
    arr.sort(key=lambda x: (bin(x).count('1'), x))
# Solution 2 -Bubble sort
def sort_by_bit(arr):
    for i in range(1, len(arr)):
        for j in range(len(arr) - i):
            top = bin(arr[j])[2:].count('1')
            x = bin(arr[j + 1])[2:].count('1')
            if top > x:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
            elif top == x:
                m = min(arr[j], arr[j + 1])
                m_ind = j if arr[j] == m else j + 1
                arr[j], arr[j + 1] = arr[m_ind], arr[j if j != m_ind else j + 1]

# 91. Decode Ways
# A message containing letters from A-Z can be encoded into numbers using the following mapping:
#
# 'A' -> "1"
# 'B' -> "2"
# ...
# 'Z' -> "26"
# To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, "11106" can be mapped into:
#
# "AAJF" with the grouping (1 1 10 6)
# "KJF" with the grouping (11 10 6)
# Note that the grouping (1 11 06) is invalid because "06" cannot be mapped into 'F' since "6" is different from "06".
#
# Given a string s containing only digits, return the number of ways to decode it.
#
# The test cases are generated so that the answer fits in a 32-bit integer.
#
#
#
# Example 1:
#
# Input: s = "12"
# Output: 2
# Explanation: "12" could be decoded as "AB" (1 2) or "L" (12).
# Example 2:
#
# Input: s = "226"
# Output: 3
# Explanation: "226" could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).
# Example 3:
#
# Input: s = "06"
# Output: 0
# Explanation: "06" cannot be mapped to "F" because of the leading zero ("6" is different from "06").
#
#
# Constraints:
#
# 1 <= s.length <= 100
# s contains only digits and may contain leading zero(s).
# Solution 1 - DP O(N) O(N)
class Solution:
    def numDecodings(self, s: str) -> int:
        count1, count2 = 1 if s[0] > '0' else 0, 0
        top = s[0]
        for i in s[1:]:
            prev = count1
            top += i
            if i > '0':
                count1 = count1 + count2
            else:
                count1 = 0
            if len(top) == 2:
                if '09' < top <= '26':
                    count2 = prev
                else:
                    count2 = 0
                top = top[-1]
        return count1 + count2
# Solution 2 DP O(N) O(N)
class Solution:
    def numDecodings(self, s: str) -> int:
        dp = [0 for i in range(len(s) + 1)]
        dp[0] = 1
        dp[1] = 0 if s[0] == '0' else 1
        for i in range(2, len(s) + 1):
            if 0 < int(s[i - 1]) <= 9:
                dp[i] += dp[i - 1]
            if 10 <= int(s[i - 2:i]) <= 26:
                dp[i] += dp[i - 2]
        return dp[len(s)]
    
# PatternCraft - Decorator
# The Decorator Design Pattern can be used, for example, in the StarCraft game to manage upgrades.
#
# The pattern consists in "incrementing" your base class with extra functionality.
#
# A decorator will receive an instance of the base class and use it to create a new instance with the new things you want "added on it".
#
# Your Task
# Complete the code so that when a Marine gets a WeaponUpgrade it increases the damage by 1, and if it is a ArmorUpgrade then increase the armor by 1.
#
# You have 3 classes:
#
# Marine: has a damage and an armor properties
# MarineWeaponUpgrade and MarineArmorUpgrade: upgrades to apply on marine. Accepts a Marine in the constructor and has the same properties as the Marine
# Resouces
# PatternCraft > Decorator
# SourceMaking > Decorator
# Wikipedia > Decorator
# PatternCraft series
# State Pattern
# Strategy Pattern
# Visitor Pattern
# Decorator Pattern
# Adapter Pattern
# Command Pattern
# The original PatternCraft series (by John Lindquist) is a collection of Youtube videos that explains some of the design patterns and how they are used (or could be) on StarCraft.
#
# DESIGN PATTERNSFUNDAMENTALS
class Marine:
    def __init__(self, damage, armor):
        self.damage = damage
        self.armor = armor
class Marine_weapon_upgrade:
    def __init__(self, marine):
        self.marine = marine
        self.damage = self.marine.damage + 1
        self.armor = self.marine.armor

class Marine_armor_upgrade:
    def __init__(self, marine):
        self.marine = marine
        self.armor = self.marine.armor + 1
        self.damage = self.marine.damage
        
# 2970. Count the Number of Incremovable Subarrays I
# You are given a 0-indexed array of positive integers nums.
#
# A subarray of nums is called incremovable if nums becomes strictly increasing on removing the subarray. For example, the subarray [3, 4] is an incremovable subarray of [5, 3, 4, 6, 7] because removing this subarray changes the array [5, 3, 4, 6, 7] to [5, 6, 7] which is strictly increasing.
#
# Return the total number of incremovable subarrays of nums.
#
# Note that an empty array is considered strictly increasing.
#
# A subarray is a contiguous non-empty sequence of elements within an array.
#
#
#
# Example 1:
#
# Input: nums = [1,2,3,4]
# Output: 10
# Explanation: The 10 incremovable subarrays are: [1], [2], [3], [4], [1,2], [2,3], [3,4], [1,2,3], [2,3,4], and [1,2,3,4], because on removing any one of these subarrays nums becomes strictly increasing. Note that you cannot select an empty subarray.
# Example 2:
#
# Input: nums = [6,5,7,8]
# Output: 7
# Explanation: The 7 incremovable subarrays are: [5], [6], [5,7], [6,5], [5,7,8], [6,5,7] and [6,5,7,8].
# It can be shown that there are only 7 incremovable subarrays in nums.
# Example 3:
#
# Input: nums = [8,7,6,6]
# Output: 3
# Explanation: The 3 incremovable subarrays are: [8,7,6], [7,6,6], and [8,7,6,6]. Note that [8,7] is not an incremovable subarray because after removing [8,7] nums becomes [6,6], which is sorted in ascending order but not strictly increasing.
#
#
# Constraints:
#
# 1 <= nums.length <= 50
# 1 <= nums[i] <= 50
# Solution O(N**3) O(1)
class Solution:
    def incremovableSubarrayCount(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return 1
        count = 0
        for i in range(len(nums)):
            for j in range(i, len(nums)):
                x = nums[:i] + nums[j+1:]
                if all(i < j for i, j in zip(x, x[1:])):
                    count += 1
        return count

# 2974. Minimum Number Game
# You are given a 0-indexed integer array nums of even length and there is also an empty array arr. Alice and Bob decided to play a game where in every round Alice and Bob will do one move. The rules of the game are as follows:
#
# Every round, first Alice will remove the minimum element from nums, and then Bob does the same.
# Now, first Bob will append the removed element in the array arr, and then Alice does the same.
# The game continues until nums becomes empty.
# Return the resulting array arr.
#
#
#
# Example 1:
#
# Input: nums = [5,4,2,3]
# Output: [3,2,5,4]
# Explanation: In round one, first Alice removes 2 and then Bob removes 3. Then in arr firstly Bob appends 3 and then Alice appends 2. So arr = [3,2].
# At the begining of round two, nums = [5,4]. Now, first Alice removes 4 and then Bob removes 5. Then both append in arr which becomes [3,2,5,4].
# Example 2:
#
# Input: nums = [2,5]
# Output: [5,2]
# Explanation: In round one, first Alice removes 2 and then Bob removes 5. Then in arr firstly Bob appends and then Alice appends. So arr = [5,2].
#
#
# Constraints:
#
# 1 <= nums.length <= 100
# 1 <= nums[i] <= 100
# nums.length % 2 == 0
# Solution 1
# Complexity
# Time complexity: O(N*N)
# Space complexity: O(N)
#
# Code
class Solution:
    def numberGame(self, nums: List[int]) -> List[int]:
        l  = []
        for j in range(len(nums) // 2):
            ab_top, top = float('inf'), float('inf')
            for i in nums:
                if ab_top > i:
                    ab_top, top = i, ab_top
                elif top > i:
                    top = i
            l += [top, ab_top]
            nums.remove(top)
            nums.remove(ab_top)
        return l

# Solution 2 - Sorting and Bubble Sort

# Complexity
# Time complexity: O(N log N)
# Space complexity: O(1)
# Code
class Solution:
    def numberGame(self, nums: List[int]) -> List[int]:
        nums.sort()
        for i in range(1, len(nums), 2):
            nums[i-1], nums[i] = nums[i], nums[i-1]
        return nums

# 2971. Find Polygon With the Largest Perimeter
# You are given an array of positive integers nums of length n.
#
# A polygon is a closed plane figure that has at least 3 sides. The longest side of a polygon is smaller than the sum of its other sides.
#
# Conversely, if you have k (k >= 3) positive real numbers a1, a2, a3, ..., ak where a1 <= a2 <= a3 <= ... <= ak and a1 + a2 + a3 + ... + ak-1 > ak, then there always exists a polygon with k sides whose lengths are a1, a2, a3, ..., ak.
#
# The perimeter of a polygon is the sum of lengths of its sides.
#
# Return the largest possible perimeter of a polygon whose sides can be formed from nums, or -1 if it is not possible to create a polygon.
#
#
#
# Example 1:
#
# Input: nums = [5,5,5]
# Output: 15
# Explanation: The only possible polygon that can be made from nums has 3 sides: 5, 5, and 5. The perimeter is 5 + 5 + 5 = 15.
# Example 2:
#
# Input: nums = [1,12,1,2,5,50,3]
# Output: 12
# Explanation: The polygon with the largest perimeter which can be made from nums has 5 sides: 1, 1, 2, 3, and 5. The perimeter is 1 + 1 + 2 + 3 + 5 = 12.
# We cannot have a polygon with either 12 or 50 as the longest side because it is not possible to include 2 or more smaller sides that have a greater sum than either of them.
# It can be shown that the largest possible perimeter is 12.
# Example 3:
#
# Input: nums = [5,5,50]
# Output: -1
# Explanation: There is no possible way to form a polygon from nums, as a polygon has at least 3 sides and 50 > 5 + 5.
#
#
# Constraints:
#
# 3 <= n <= 105
# 1 <= nums[i] <= 109
# Complexity
# Time complexity: O(N log N)
# Space complexity: O(1)
#
# Code
class Solution:
    def largestPerimeter(self, nums: List[int]) -> int:
        nums.sort()
        l: int = -1
        s: int = sum(nums[:2])
        for i in range(2, len(nums)):
            if nums[i] < s:
                l = nums[i] + s
            s += nums[i]
        return l
    
# 1155. Number of Dice Rolls With Target Sum
# You have n dice, and each die has k faces numbered from 1 to k.
#
# Given three integers n, k, and target, return the number of possible ways (out of the kn total ways) to roll the dice, so the sum of the face-up numbers equals target. Since the answer may be too large, return it modulo 109 + 7.
#
#
#
# Example 1:
#
# Input: n = 1, k = 6, target = 3
# Output: 1
# Explanation: You throw one die with 6 faces.
# There is only one way to get a sum of 3.
# Example 2:
#
# Input: n = 2, k = 6, target = 7
# Output: 6
# Explanation: You throw two dice, each with 6 faces.
# There are 6 ways to get a sum of 7: 1+6, 2+5, 3+4, 4+3, 5+2, 6+1.
# Example 3:
#
# Input: n = 30, k = 30, target = 500
# Output: 222616187
# Explanation: The answer must be returned modulo 109 + 7.
#
#
# Constraints:
#
# 1 <= n, k <= 30
# 1 <= target <= 1000
# Solution
class Solution:
    def numRollsToTarget(self, n: int, k: int, target: int) -> int:
        memorization: dict = {}
        def dp(n: int, target: int) -> int:
            if n == 0:
                return 0 if target > 0 else 1
            if (n, target) in memorization:
                return memorization[(n, target)]
            total: int = 0
            for f in range(max(0, target-k), target):
                total += dp(n-1, f)
            memorization[(n, target)] = total
            return total
        return dp(n, target) % (10**9 + 7)
    
# Vector class
# Create a Vector object that supports addition, subtraction, dot products, and norms. So, for example:
#
# a = Vector([1, 2, 3])
# b = Vector([3, 4, 5])
# c = Vector([5, 6, 7, 8])
#
# a.add(b)      # should return a new Vector([4, 6, 8])
# a.subtract(b) # should return a new Vector([-2, -2, -2])
# a.dot(b)      # should return 1*3 + 2*4 + 3*5 = 26
# a.norm()      # should return sqrt(1^2 + 2^2 + 3^2) = sqrt(14)
# a.add(c)      # raises an exception
# If you try to add, subtract, or dot two vectors with different lengths, you must throw an error!
#
# Also provide:
#
# a toString method, so that using the vectors from above, a.toString() === '(1,2,3)' (in Python, this is a __str__ method, so that str(a) == '(1,2,3)')
# an equals method, to check that two vectors that have the same components are equal
# Note: the test cases will utilize the user-provided equals method.
#
# OBJECT-ORIENTED PROGRAMMINGALGORITHMSLINEAR ALGEBRA
class Vector:
    def __init__(self, arr: list):
        self.vector = arr
    def add(self, new_vector):
        if len(new_vector.vector) != len(self.vector):
            raise Error
        return Vector([x + y for x, y in zip(self.vector, new_vector.vector)])
    def equals(self, new_vector):
        return all(i == j for i,j in zip(self.vector, new_vector.vector))
    def subtract(self, new_vector):
        return Vector([x - y for x, y in zip(self.vector, new_vector.vector)])
    def dot(self, new_vector):
        return sum(x * y for x, y in zip(self.vector, new_vector.vector))
    def norm(self):
        return sum(i**2 for i in self.vector) ** .5
    def __str__(self):
        return f"({','.join(str(i) for i in self.vector)})"
    
# 1578. Minimum Time to Make Rope Colorful
# Alice has n balloons arranged on a rope. You are given a 0-indexed string colors where colors[i] is the color of the ith balloon.
#
# Alice wants the rope to be colorful. She does not want two consecutive balloons to be of the same color, so she asks Bob for help. Bob can remove some balloons from the rope to make it colorful. You are given a 0-indexed integer array neededTime where neededTime[i] is the time (in seconds) that Bob needs to remove the ith balloon from the rope.
#
# Return the minimum time Bob needs to make the rope colorful.
#
#
#
# Example 1:
#
#
# Input: colors = "abaac", neededTime = [1,2,3,4,5]
# Output: 3
# Explanation: In the above image, 'a' is blue, 'b' is red, and 'c' is green.
# Bob can remove the blue balloon at index 2. This takes 3 seconds.
# There are no longer two consecutive balloons of the same color. Total time = 3.
# Example 2:
#
#
# Input: colors = "abc", neededTime = [1,2,3]
# Output: 0
# Explanation: The rope is already colorful. Bob does not need to remove any balloons from the rope.
# Example 3:
#
#
# Input: colors = "aabaa", neededTime = [1,2,3,4,1]
# Output: 2
# Explanation: Bob will remove the ballons at indices 0 and 4. Each ballon takes 1 second to remove.
# There are no longer two consecutive balloons of the same color. Total time = 1 + 1 = 2.
#
#
# Constraints:
#
# n == colors.length == neededTime.length
# 1 <= n <= 105
# 1 <= neededTime[i] <= 104
# colors contains only lowercase English letters.
# Solution 1 - O(N) O(1)
class Solution:
    def minCost(self, colors: str, neededTime: List[int]) -> int:
        if len(colors) == 1:
            return 0
        count, s, top = 0, 0, 0
        for i in range(1, len(colors)):
            s += neededTime[i-1]
            top = max(top, neededTime[i-1])
            if colors[i-1] != colors[i]:
                count += s - top
                s, top = 0, 0
        if colors[-2] == colors[-1]:
            s += neededTime[-1]
            top = max(top, neededTime[-1])
            count += s - top
        return count
# Solution 2 - O(N) O(1) But shorter than solution above
class Solution:
    def minCost(self, colors: str, neededTime: List[int]) -> int:
        sm, mx = 0, 0
        for i in range(len(colors)):
            if colors[i-1] != colors[i]:
                mx = 0
            sm += min(mx, neededTime[i])
            mx = max(mx, neededTime[i])
        return sm

# Custom FizzBuzz Array
# Write a function that returns a (custom) FizzBuzz sequence of the numbers 1 to 100.
#
# The function should be able to take up to 4 arguments:
#
# The 1st and 2nd arguments are strings, "Fizz" and "Buzz" by default;
# The 3rd and 4th arguments are integers, 3 and 5 by default.
# Thus, when the function is called without arguments, it will return the classic FizzBuzz sequence up to 100:
#
# [ 1, 2, "Fizz", 4, "Buzz", "Fizz", 7, ... 14, "FizzBuzz", 16, 17, ... 98, "Fizz", "Buzz" ]
# When the function is called with (up to 4) arguments, it should return a custom FizzBuzz sequence, for example:
#
# ('Hey', 'There')      -->  [ 1, 2, "Hey", 4, "There", "Hey", ... ]
# ('Foo', 'Bar', 2, 3)  -->  [ 1, "Foo", "Bar", "Foo", 5, "FooBar", 7, ... ]
# Examples
# fizz_buzz_custom()[15]                         # returns 16
# fizz_buzz_custom()[44]                         # returns "FizzBuzz" (45 is divisible by 3 and 5)
# fizz_buzz_custom('Hey', 'There')[25]         # returns 26
# fizz_buzz_custom('Hey', 'There')[11]         # returns "Hey" (12 is divisible by 3)
# fizz_buzz_custom("What's ", "up?", 3, 7)[80] # returns "What's " (81 is divisible by 3)
# The function must return the sequence as a list.
#
# ARRAYSLOGICFUNDAMENTALS
def fizz_buzz_custom(string_one='Fizz', string_two='Buzz', num_one=3, num_two=5):
    l: list = []
    for i in range(1, 101):
        if i % num_one == 0 and i % num_two == 0:
            l.append(string_one + string_two)
        elif i % num_one == 0:
            l.append(string_one)
        elif i % num_two == 0:
            l.append(string_two)
        else:
            l.append(i)
    return l

# 1531. String Compression II
# Run-length encoding is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string "aabccc" we replace "aa" by "a2" and replace "ccc" by "c3". Thus the compressed string becomes "a2bc3".
#
# Notice that in this problem, we are not adding '1' after single characters.
#
# Given a string s and an integer k. You need to delete at most k characters from s such that the run-length encoded version of s has minimum length.
#
# Find the minimum length of the run-length encoded version of s after deleting at most k characters.
#
#
#
# Example 1:
#
# Input: s = "aaabcccd", k = 2
# Output: 4
# Explanation: Compressing s without deleting anything will give us "a3bc3d" of length 6. Deleting any of the characters 'a' or 'c' would at most decrease the length of the compressed string to 5, for instance delete 2 'a' then we will have s = "abcccd" which compressed is abc3d. Therefore, the optimal way is to delete 'b' and 'd', then the compressed version of s will be "a3c3" of length 4.
# Example 2:
#
# Input: s = "aabbaa", k = 2
# Output: 2
# Explanation: If we delete both 'b' characters, the resulting compressed string would be "a4" of length 2.
# Example 3:
#
# Input: s = "aaaaaaaaaaa", k = 0
# Output: 3
# Explanation: Since k is zero, we cannot delete anything. The compressed string is "a11" of length 3.
#
#
# Constraints:
#
# 1 <= s.length <= 100
# 0 <= k <= s.length
# s contains only lowercase English letters.
class Solution:
    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:
        @lru_cache(None)
        def dp(i, prev, prev_cnt, k):
            if k < 0:
                return float('inf')
            if i >= len(s):
                return 0
            delete = dp(i + 1, prev, prev_cnt, k - 1)
            if s[i] == prev:
                keep = dp(i + 1, prev, prev_cnt + 1, k)
                if prev_cnt in {1, 9, 99}:
                    keep += 1
            else:
                keep = dp(i + 1, s[i], 1, k) + 1
            return min(delete, keep)
        return dp(0, '', 0, k)
    
# Square Matrix Multiplication
# Write a function that accepts two square (NxN) matrices (two dimensional arrays), and returns the product of the two. Only square matrices will be given.
#
# How to multiply two square matrices:
#
# We are given two matrices, A and B, of size 2x2 (note: tests are not limited to 2x2). Matrix C, the solution, will be equal to the product of A and B. To fill in cell [0][0] of matrix C, you need to compute: A[0][0] * B[0][0] + A[0][1] * B[1][0].
#
# More general: To fill in cell [n][m] of matrix C, you need to first multiply the elements in the nth row of matrix A by the elements in the mth column of matrix B, then take the sum of all those products. This will give you the value for cell [m][n] in matrix C.
#
# Example
#   A         B          C
# |1 2|  x  |3 2|  =  | 5 4|
# |3 2|     |1 1|     |11 8|
# Detailed calculation:
#
# C[0][0] = A[0][0] * B[0][0] + A[0][1] * B[1][0] = 1*3 + 2*1 =  5
# C[0][1] = A[0][0] * B[0][1] + A[0][1] * B[1][1] = 1*2 + 2*1 =  4
# C[1][0] = A[1][0] * B[0][0] + A[1][1] * B[1][0] = 3*3 + 2*1 = 11
# C[1][1] = A[1][0] * B[0][1] + A[1][1] * B[1][1] = 3*2 + 2*1 =  8
# Link to Wikipedia explaining matrix multiplication (look at the square matrix example): http://en.wikipedia.org/wiki/Matrix_multiplication
#
# A more visual explanation of matrix multiplication: http://matrixmultiplication.xyz
#
# MATRIXLINEAR ALGEBRAALGORITHMS
def matrix_mult(a, b):
    mt = []
    for n in range(len(a)):
        rows = []
        for m in range(len(a)):
            x = sum(a[n][k] * b[k][m] for k in range(len(a)))
            rows.append(x)
        mt.append(rows)
    return mt

# 2006. Count Number of Pairs With Absolute Difference K
# Given an integer array nums and an integer k, return the number of pairs (i, j) where i < j such that |nums[i] - nums[j]| == k.
# 
# The value of |x| is defined as:
# 
# x if x >= 0.
# -x if x < 0.
#  
# 
# Example 1:
# 
# Input: nums = [1,2,2,1], k = 1
# Output: 4
# Explanation: The pairs with an absolute difference of 1 are:
# - [1,2,2,1]
# - [1,2,2,1]
# - [1,2,2,1]
# - [1,2,2,1]
# Example 2:
# 
# Input: nums = [1,3], k = 3
# Output: 0
# Explanation: There are no pairs with an absolute difference of 3.
# Example 3:
# 
# Input: nums = [3,2,1,5,4], k = 2
# Output: 3
# Explanation: The pairs with an absolute difference of 2 are:
# - [3,2,1,5,4]
# - [3,2,1,5,4]
# - [3,2,1,5,4]
#  
# 
# Constraints:
# 
# 1 <= nums.length <= 200
# 1 <= nums[i] <= 100
# 1 <= k <= 99
# Solution 1 - Brute Force - Nested loops. Speed O(N**2) and Memory O(1)
# Note: if we should find a differences by absolute (abs) method, we can nof check i < j, but in the end, we have pairs*2
# variations of multiplicate numbers. And then we just should divide answer on 2
class Solution:
    def countKDifference(self, nums: List[int], k: int) -> int:
        count: int = 0
        for i in range(len(nums)):
            for j in range(len(nums)):
                if abs(nums[i] - nums[j]) == k:
                    count += 1
        return count // 2
# Solution 2 HashTable. Speed O(N) and Memory O(N)
class Solution:
    def countKDifference(self, nums: List[int], k: int) -> int:
        hm: dict = {}
        for i in nums:
            hm[i] = hm.get(i, 0) + 1
        count: int = 0
        for i in nums:
            if k + i in hm:
                count += hm[k + i]
        return count
    
# Longest Common Subsequence
# Write a function called LCS that accepts two sequences and returns the longest subsequence common to the passed in sequences.
#
# Subsequence
# A subsequence is different from a substring. The terms of a subsequence need not be consecutive terms of the original sequence.
#
# Example subsequence
# Subsequences of "abc" = "a", "b", "c", "ab", "ac", "bc" and "abc".
#
# LCS examples
# lcs( "abcdef" , "abc" ) => returns "abc"
# lcs( "abcdef" , "acf" ) => returns "acf"
# lcs( "132535365" , "123456789" ) => returns "12356"
# Notes
# Both arguments will be strings
# Return value must be a string
# Return an empty string if there exists no common subsequence
# Both arguments will have one or more characters (in JavaScript)
# All tests will only have a single longest common subsequence. Don't worry about cases such as LCS( "1234", "3412" ), which would have two possible longest common subsequences: "12" and "34".
# Note that the Haskell variant will use randomized testing, but any longest common subsequence will be valid.
#
# Note that the OCaml variant is using generic lists instead of strings, and will also have randomized tests (any longest common subsequence will be valid).
#
# Tips
# Wikipedia has an explanation of the two properties that can be used to solve the problem:
#
# First property
# Second property
# STRINGSALGORITHMS
def lcs(s1, s2):
    if not s1 or not s2:
        return ''
    matrix = [["" for x in range(len(s2))] for x in range(len(s1))]
    for i in range(len(s1)):
        for j in range(len(s2)):
            if s1[i] == s2[j]:
                if i == 0 or j == 0:
                    matrix[i][j] = s1[i]
                else:
                    matrix[i][j] = matrix[i-1][j-1] + s1[i]
            else:
                matrix[i][j] = max(matrix[i-1][j], matrix[i][j-1], key=len)
    return matrix[-1][-1]

# 1897. Redistribute Characters to Make All Strings Equal
# You are given an array of strings words (0-indexed).
#
# In one operation, pick two distinct indices i and j, where words[i] is a non-empty string, and move any character from words[i] to any position in words[j].
#
# Return true if you can make every string in words equal using any number of operations, and false otherwise.
#
#
#
# Example 1:
#
# Input: words = ["abc","aabc","bc"]
# Output: true
# Explanation: Move the first 'a' in words[1] to the front of words[2],
# to make words[1] = "abc" and words[2] = "abc".
# All the strings are now equal to "abc", so return true.
# Example 2:
#
# Input: words = ["ab","a"]
# Output: false
# Explanation: It is impossible to make all the strings equal using the operation.
#
#
# Constraints:
#
# 1 <= words.length <= 100
# 1 <= words[i].length <= 100
# words[i] consists of lowercase English letters.
# Solution O(N) O(N)
class Solution:
    def makeEqual(self, words: List[str]) -> bool:
        dt: dict = defaultdict(int)
        for i in words:
            for j in i:
                dt[j] += 1
        n: int = len(words)
        for i in dt:
            if dt[i] % n != 0:
                return False
        return True

# Ackermann Function
# The Ackermann function is a famous function that played a big role in computability theory as the first example of a total computable function that is not primitive recursive.
#
# Since then the function has been a bit simplified but is still of good use. Due to its definition in terms of extremely deep recursion it can be used as a benchmark of a compiler's ability to optimize recursion.
#
# The goal of this kata is to code a function which will be given two inputs, m and n, and will return the Ackermann number A(m,n) defined by:
#
# A(m,n) = n+1                          if m=0
# A(m,n) = A(m-1,1)                     if m>0 , n=0
# A(m,n) = A(m-1,A(m,n-1))              if m,n > 0
# m,n should be non-negative integers, the function should return null (Javascript), None (Python), or nil (Ruby) for other type, non-integer and negative numbers. In C, input is restricted to integer type.
#
# MATHEMATICSALGORITHMSRECURSION
def Ackermann(m, n):
    if type(m) != int or type(n) != int or m < 0 or n < 0:
        return
    if m == 0:
        return n + 1
    if m > 0 and n == 0:
        return Ackermann(m-1, 1)
    if m > 0 and n > 0:
        return Ackermann(m-1, Ackermann(m, n-1))

# 1624. Largest Substring Between Two Equal Characters
# Given a string s, return the length of the longest substring between two equal characters, excluding the two characters. If there is no such substring return -1.
#
# A substring is a contiguous sequence of characters within a string.
#
#
#
# Example 1:
#
# Input: s = "aa"
# Output: 0
# Explanation: The optimal substring here is an empty substring between the two 'a's.
# Example 2:
#
# Input: s = "abca"
# Output: 2
# Explanation: The optimal substring here is "bc".
# Example 3:
#
# Input: s = "cbzxy"
# Output: -1
# Explanation: There are no characters that appear twice in s.
#
#
# Constraints:
#
# 1 <= s.length <= 300
# s contains only lowercase English letters.
# Solution O(N**2) O(1)
class Solution:
    def maxLengthBetweenEqualCharacters(self, s: str) -> int:
        count: int = -1
        for i in range(len(s)):
            for j in range(i + 1, len(s)):
                if s[i] == s[j]:
                    count = max(count, j - i - 1)
        return count
# Solution 2 O(N) O(N)
class Solution:
    def maxLengthBetweenEqualCharacters(self, s: str) -> int:
        count: int = -1
        for i in range(len(s)):
            for j in range(i + 1, len(s)):
                if s[i] == s[j]:
                    count = max(count, j - i - 1)
        return count

# Angle Between Clock Hands
# Given a Date (in JS and Ruby) or hours and minutes (in C and Python), return the angle between the two hands of a 12-hour analog clock in radians.
#
# Notes:
# The minute hand always points to the exact minute (there is no seconds hand).
# The hour hand does not "snap" to the tick marks: e.g. at 6:30 the angle is not 0 because the hour hand is already half way between 6 and 7.
# Return the smaller of the angles ( <= π ).
# Return π if the hands are opposite.
# Examples
# at noon the angle is: 0
# at 3:00 the angle is: π/2 (90 degrees)
# at 6:00 the angle is: π (180 degrees)
# at 9:00 the angle is: π/2 (90 degrees)
# MATHEMATICSDATE TIMEALGORITHMS
from math import pi
def hand_angle(hours, minutes):
    h, m = .5 * (60 * hours + minutes), 6 * minutes
    angel = abs(h - m)
    x = min(angel, 360 - angel)
    return (pi / 180) * x

# 455. Assign Cookies
# Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.
#
# Each child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] >= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.
#
#
#
# Example 1:
#
# Input: g = [1,2,3], s = [1,1]
# Output: 1
# Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3.
# And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.
# You need to output 1.
# Example 2:
#
# Input: g = [1,2], s = [1,2,3]
# Output: 2
# Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2.
# You have 3 cookies and their sizes are big enough to gratify all of the children,
# You need to output 2.
#
#
# Constraints:
#
# 1 <= g.length <= 3 * 104
# 0 <= s.length <= 3 * 104
# 1 <= g[i], s[j] <= 231 - 1
# Solution O(N log(N) + min(len(s), len(g))) == O(Nlog(N)) \ Memory O(1)
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        count: int = 0
        top = g.pop(0)
        for i in s:
            if i >= top:
                count += 1
                if g:
                    top = g.pop(0)
                else:
                    break
        return count
# Solution O(Nlog(N)) Memory O(1)
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        x, y = 0, 0
        while x < len(g) and y < len(s):
            if s[y] >= g[x]:
                x = x + 1
            y += 1
        return x

# Play with two Strings
# Your task is to Combine two Strings. But consider the rule...
#
# By the way you don't have to check errors or incorrect input values, everything is ok without bad tricks, only two input strings and as result one output string;-)...
#
# And here's the rule:
# Input Strings a and b: For every character in string a swap the casing of every occurrence of the same character in string b. Then do the same casing swap with the inputs reversed. Return a single string consisting of the changed version of a followed by the changed version of b. A char of a is in b regardless if it's in upper or lower case - see the testcases too.
# I think that's all;-)...
#
# Some easy examples:
#
# Input: "abc" and "cde"      => Output: "abCCde"
# Input: "ab" and "aba"       => Output: "aBABA"
# Input: "abab" and "bababa"  => Output: "ABABbababa"
# Once again for the last example - description from KenKamau, see discourse;-):
#
# a) swap the case of characters in string b for every occurrence of that character in string a
# char 'a' occurs twice in string a, so we swap all 'a' in string b twice. This means we start with "bababa" then "bAbAbA" => "bababa"
# char 'b' occurs twice in string a and so string b moves as follows: start with "bababa" then "BaBaBa" => "bababa"
#
# b) then, swap the case of characters in string a for every occurrence in string b
# char 'a' occurs 3 times in string b. So string a swaps cases as follows: start with "abab" then => "AbAb" => "abab" => "AbAb"
# char 'b' occurs 3 times in string b. So string a swaps as follow: start with "AbAb" then => "ABAB" => "AbAb" => "ABAB".
#
# c) merge new strings a and b
# return "ABABbababa"
#
# There are some static tests at the beginning and many random tests if you submit your solution.
#
# Hope you have fun:-)!
# FUNDAMENTALSSTRINGSALGORITHMS
# Solution Speed O(len(a) + len(b)) Memory O(a2 + b2)
def work_on_strings(a,b):
    a1, b2 = {}, {}
    for i in a:
        x = i.lower()
        a1[x] = a1.get(x, 0) + 1
    for i in b:
        x = i.lower()
        b2[x] = b2.get(x, 0) + 1
    ansa, ansb = '', ''
    for i in a:
        x = i.lower()
        if x in b2:
            ansa += i.swapcase() if b2[x] % 2 != 0 else i
        else:
            ansa += i
    for i in b:
        x = i.lower()
        if x in a1:
            ansb += i.swapcase() if a1[x] % 2 != 0 else i
        else:
            ansb += i
    return ansa + ansb

# 2610. Convert an Array Into a 2D Array With Conditions
# You are given an integer array nums. You need to create a 2D array from nums satisfying the following conditions:
#
# The 2D array should contain only the elements of the array nums.
# Each row in the 2D array contains distinct integers.
# The number of rows in the 2D array should be minimal.
# Return the resulting array. If there are multiple answers, return any of them.
#
# Note that the 2D array can have a different number of elements on each row.
#
#
#
# Example 1:
#
# Input: nums = [1,3,4,1,2,3,1]
# Output: [[1,3,4,2],[1,3],[1]]
# Explanation: We can create a 2D array that contains the following rows:
# - 1,3,4,2
# - 1,3
# - 1
# All elements of nums were used, and each row of the 2D array contains distinct integers, so it is a valid answer.
# It can be shown that we cannot have less than 3 rows in a valid array.
# Example 2:
#
# Input: nums = [1,2,3,4]
# Output: [[4,3,2,1]]
# Explanation: All elements of the array are distinct, so we can keep all of them in the first row of the 2D array.
#
#
# Constraints:
#
# 1 <= nums.length <= 200
# 1 <= nums[i] <= nums.length
# Solution 1 - HashTable O(N**2) O(N)
class Solution:
    def findMatrix(self, nums: List[int]) -> List[List[int]]:
        d: dict = {}
        for i in nums:
            d[i] = d.get(i, 0) + 1
        ans: list = list()
        while d:
            top: list = []
            for i in d.copy():
                top.append(i)
                d[i] -= 1
                if d[i] == 0:
                    del d[i]
            ans.append(top)
        return ans
# Solution 2 - Flag O(N * len(ans)), O(N)
class Solution:
    def findMatrix(self, nums: List[int]) -> List[List[int]]:
        ans: list = [[]]
        for i in nums:
            flag: bool = False
            for l in ans:
                if i not in l:
                    l.append(i)
                    flag: bool = True
                    break
            if not flag:
                ans += [[i]]
        return  ans
# Solution 3 - HashTable O(N) O(N)
class Solution:
    def findMatrix(self, nums: List[int]) -> List[List[int]]:
        sq: list = [0] * (len(nums) + 1)
        ans: list = []
        for i in nums:
            if sq[i] >= len(ans):
                ans.append([])
            ans[sq[i]].append(i)
            sq[i] += 1
        return ans

# Convert all the cases!
# In this kata, you will make a function that converts between camelCase, snake_case, and kebab-case.
#
# You must write a function that changes to a given case. It must be able to handle all three case types:
#
# py> change_case("snakeCase", "snake")
# "snake_case"
# py> change_case("some-lisp-name", "camel")
# "someLispName"
# py> change_case("map_to_all", "kebab")
# "map-to-all"
# py> change_case("doHTMLRequest", "kebab")
# "do-h-t-m-l-request"
# py> change_case("invalid-inPut_bad", "kebab")
# None
# py> change_case("valid-input", "huh???")
# None
# py> change_case("", "camel")
# ""
# Your function must deal with invalid input as shown, though it will only be passed strings. Furthermore, all valid identifiers will be lowercase except when necessary, in other words on word boundaries in camelCase.
#
# (Any translations would be greatly appreciated!)
#
# STRINGSREGULAR EXPRESSIONSALGORITHMS
def change_case(id, target):
    if target not in {'kebab', 'camel', 'snake'}:
        return None
    if not id:
        return ''
    x = 0
    for i in id:
        if i.isupper():
            x += 1
    y, z = id.count('_'), id.count('-')
    if (x > 0 and (y > 0 or z > 0)) or (y > 0 and (x > 0 or z > 0)) or (z > 0 and (x > 0 or y > 0)):
        return None
    word: str = ''
    flag: bool = False
    for i in id:
        if not i.isupper() and i not in {'-', '_'}:
            if flag:
                word += i.upper()
                flag = not flag
            else:
                word += i
        elif i.isupper():
            if target == 'camel': word += i
            elif target == 'kebab': word += '-' + i.lower()
            elif target == 'snake': word += '_' + i.lower()
        elif i == '-':
            if target == 'snake': word += '_'
            elif target == 'kebab': word += i
            elif target == 'camel': flag = True
        elif i == '_':
            if target == 'kebab': word += '-'
            elif target == 'snake': word += i
            elif target == 'camel': flag = True
    return word

# Neutralisation
# Given two strings comprised of + and -, return a new string which shows how the two strings interact in the following way:
#
# When positives and positives interact, they remain positive.
# When negatives and negatives interact, they remain negative.
# But when negatives and positives interact, they become neutral, and are shown as the number 0.
# Worked Example
# ("+-+", "+--") ➞ "+-0"
# # Compare the first characters of each string, then the next in turn.
# # "+" against a "+" returns another "+".
# # "-" against a "-" returns another "-".
# # "+" against a "-" returns "0".
# # Return the string of characters.
# Examples
# ("--++--", "++--++") ➞ "000000"
#
# ("-+-+-+", "-+-+-+") ➞ "-+-+-+"
#
# ("-++-", "-+-+") ➞ "-+00"
# Notes
# The two strings will be the same length.
#
# ALGORITHMSSTRINGS
def neutralise(s1, s2):
    return ''.join('+' if x == y == '+' else '-' if x == y == '-' else '0' for x, y in zip(s1, s2))

# Pandas Series 101: Rename Columns
# Rename Columns
# Input parameters
# pandas.DataFrame object
# sequence
# Task
# Your function must return a new pandas.DataFrame object with same data than the original input but now its column names are the elements of the sequence. You must not modify the original input.
#
# The number of columns of the input will always be equal to the size of the sequence.
#
# Examples
#    0  1  2
# 0  1  2  3
# 1  4  5  6
#
# names = ['A', 'B', 'C']
#    A  B  C
# 0  1  2  3
# 1  4  5  6
# STRINGSDATA FRAMESFUNDAMENTALSDATA SCIENCE
import pandas as pd

def rename_columns(df, names):  
    df2 = df.copy()
    df2.columns = [i for i in names]
    return df2

# Genetic Algorithm Series - #2 Mutation
# Mutation is a genetic operator used to maintain genetic diversity from one generation of a population of genetic algorithm chromosomes to the next.
#
# Mutation
#
# A mutation here may happen on zero or more positions in a chromosome. It is going to check every position and by a given probability it will decide if a mutation will occur.
#
# A mutation is the change from 0 to 1 or from 1 to 0.
#
# Note: Some tests are random. If you think your algorithm is correct but the result fails, trying again should work.
#
# See other katas from this series
# Genetic Algorithm Series - #1 Generate
# Genetic Algorithm Series - #2 Mutation
# Genetic Algorithm Series - #3 Crossover
# Genetic Algorithm Series - #4 Get population and fitnesses
# Genetic Algorithm Series - #5 Roulette wheel selection
# ALGORITHMSGENETIC ALGORITHMSSTRINGS
from random import choices
def mutate(chromosome, p):
    return ''.join(choices([str(int(not bool(int(i)))), i], [p, 1 - p])[0] for i in chromosome)

# Quicksum
# A checksum is an algorithm that scans a packet of data and returns a single number. The idea is that if the packet is changed, the checksum will also change, so checksums are often used for detecting transmission errors, validating document contents, and in many other situations where it is necessary to detect undesirable changes in data.
#
# For this problem, you will implement a checksum algorithm called Quicksum. A Quicksum packet allows only uppercase letters and spaces. It always begins and ends with an uppercase letter.
#
# Otherwise, spaces and uppercase letters can occur in any combination, including consecutive spaces.
#
# A Quicksum is the sum of the products of each character’s position in the packet times the character’s value. A space has a value of zero, while letters have a value equal to their position in the alphabet.
#
# So, A = 1, B = 2, etc., through Z = 26. Here are example Quicksum calculations for the packets "ACM" and "A C M":
#
# ACM
# 1 × 1 + 2 × 3 + 3 × 13 = 46
#
# A C M
# 1 x 1 + 3 x 3 + 5 * 13 = 75
# When the packet doesn't have only uppercase letters and spaces or just spaces the result to quicksum have to be zero (0).
#
# AbqTH #5 = 0
# FUNDAMENTALS
def quicksum(packet):
    s: int = 0
    for i in range(len(packet)):
        if (not packet[i].isalpha() and packet[i] != ' ') or packet[i].islower():
            return 0
        if packet[i].isalpha():
            s += (ord(packet[i]) - 64) * (i + 1)
    return s

# Case-sensitive!
# Your task is very simple. Given an input string s, case_sensitive(s), check whether all letters are lowercase or not. Return True/False and a list of all the entries that are not lowercase in order of their appearance in s.
#
# For example, case_sensitive('codewars') returns [True, []], but case_sensitive('codeWaRs') returns [False, ['W', 'R']].
#
# Goodluck :)
#
# Have a look at my other katas!
#
# Alphabetically ordered
#
# Find Nearest square number
#
# Not prime numbers
#
# Find your caterer
#
# STRINGSFUNDAMENTALS
def case_sensitive(s):
    flag: bool = True
    ans: list = list()
    for i in s:
        if i.isupper():
            flag = not flag
            ans += i
    return [flag, ans]

# Acrostic reader
# An acrostic is a text in which the first letter of each line spells out a word. It is also a quick and cheap way of writing a poem for somebody, as exemplified below :
#
#
#
# Write a program that reads an acrostic to identify the "hidden" word. Specifically, your program will receive a list of words (reprensenting an acrostic) and will need to return a string corresponding to the word that is spelled out by taking the first letter of each word in the acrostic.
#
# STRINGSFUNDAMENTALS
def read_out(acrostic):
    return ''.join(i[0] for i in acrostic)

# Holiday II - Plane Seating
# Finding your seat on a plane is never fun, particularly for a long haul flight... You arrive, realise again just how little leg room you get, and sort of climb into the seat covered in a pile of your own stuff.
#
# To help confuse matters (although they claim in an effort to do the opposite) many airlines omit the letters 'I' and 'J' from their seat naming system.
#
# the naming system consists of a number (in this case between 1-60) that denotes the section of the plane where the seat is (1-20 = front, 21-40 = middle, 40+ = back). This number is followed by a letter, A-K with the exclusions mentioned above.
#
# Letters A-C denote seats on the left cluster, D-F the middle and G-K the right.
#
# Given a seat number, your task is to return the seat location in the following format:
#
# '2B' would return 'Front-Left'.
#
# If the number is over 60, or the letter is not valid, return 'No Seat!!'.
#
# FUNDAMENTALSSTRINGSARRAYS
def plane_seat(a):
    al: str = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    if int(a[:-1]) > 60 or a[-1] in {'I', 'J'} or al.index(a[-1]) > 10:
        return 'No Seat!!'
    x, y = '', ''
    n = al.index(a[-1])
    if 0 <= n <= al.index('C'):
        y = 'Left'
    elif al.index('C') < n <= al.index('F'):
        y = 'Middle'
    else:
        y = 'Right'
    n = int(a[:-1])
    if 1 <= n <= 20:
        x = 'Front'
    elif 21 <= n <= 40:
        x = 'Middle'
    else:
        x = 'Back'
    return f'{x}-{y}'

# Help Suzuki complete his chores!
# Suzuki has a long list of chores required to keep the monastery in good order. Each chore can be completed independently of the others and assigned to any student. Knowing there will always be an even number of chores and that the number of students isn't limited, Suzuki needs to assign two chores to each student in a way which minimizes the total duration of the day's work.
#
# For example, with the list of chores [1, 5, 2, 8, 4, 9, 6, 4, 2, 2, 2, 9], he'll need 6 students whose total workload will be: [7, 8, 8, 10, 10, 11] (as for [5+2, 4+4, 6+2, 8+2, 1+9, 9+2]). In this case, the maximal workload is minimized to 11 (=9+2. Keep in mind two chores must be assigned to each student involved).
#
# Input/output
# Input: 10 ≤ chores length ≤ 30, chores length is always even.
# Output: array of workloads, in ascending order.
# Please also try the other Kata in this series..
#
# Help Suzuki count his vegetables...
# Help Suzuki pack his coal basket!
# Help Suzuki purchase his Tofu!
# Help Suzuki rake his garden!
# Suzuki needs help lining up his students!
# How many stairs will Suzuki climb in 20 years?
# ALGORITHMS
def chore_assignment(chores):
    chores.sort()
    ans: list = []
    while chores:
        ans.append(chores[0] + chores[-1])
        chores.pop(0)
        chores.pop()
    ans.sort()
    return ans

# Chuck Norris II - One Punch
# Chuck Norris is the world's toughest man - he once kicked a horse in the chin. Its descendants today are known as giraffes.
#
# Like his punches, Chuck NEVER needs more than one line of code.
#
# Your task, to please Chuck, is to create a function that chains 4 methods on a SINGLE LINE! You can pass with multiple lines, but CHuck will pity you. Go big or go home. ONE LINE!!
#
# Chuck expects his list of favourite items to be split, sorted, joined AND have any occurrences of the letters 'e' and 'a' removed - why, you ask? Well Nunchuks hasn't got the letters 'a' or 'e' in it has it?? Chuck says shut your mouth... and don't forget the capitals.
#
# If anyone dares to provide Chuck with an empty string, an integer or an array, just return a description of their face once Chuck finds out: 'Broken!'
#
# Go, go go!!!
#
# FUNDAMENTALSREGULAR EXPRESSIONSALGORITHMS
def one_punch(item):
    return ' '.join(' '.join(''.join(i.replace('e', '').replace('a', '').replace('E', '').replace('A', '')) for i in sorted(item.split())).split(' ')) if (type(item) == str and item) else 'Broken!'

# Put a Letter in a Column
# Create a function that takes index [0, 8] and a character. It returns a string with columns. Put character in column marked with index.
#
# Ex.: index = 2, character = 'B'
#
# | | |B| | | | | | |
#  0 1 2 3 4 5 6 7 8
# Assume that argument index is integer [0, 8]. Assume that argument character is string with one character.
#
# FUNDAMENTALSSTRINGS
def build_row_text(index, character):
    s: str = ''
    for i in range(9):
        s += f'|{character if index == i else " "}'
    return s + '|'

# 2125. Number of Laser Beams in a Bank
# Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.
#
# There is one laser beam between any two security devices if both conditions are met:
#
# The two devices are located on two different rows: r1 and r2, where r1 < r2.
# For each row i where r1 < i < r2, there are no security devices in the ith row.
# Laser beams are independent, i.e., one beam does not interfere nor join with another.
#
# Return the total number of laser beams in the bank.
#
#
#
# Example 1:
#
#
# Input: bank = ["011001","000000","010100","001000"]
# Output: 8
# Explanation: Between each of the following device pairs, there is one beam. In total, there are 8 beams:
#  * bank[0][1] -- bank[2][1]
#  * bank[0][1] -- bank[2][3]
#  * bank[0][2] -- bank[2][1]
#  * bank[0][2] -- bank[2][3]
#  * bank[0][5] -- bank[2][1]
#  * bank[0][5] -- bank[2][3]
#  * bank[2][1] -- bank[3][2]
#  * bank[2][3] -- bank[3][2]
# Note that there is no beam between any device on the 0th row with any on the 3rd row.
# This is because the 2nd row contains security devices, which breaks the second condition.
# Example 2:
#
#
# Input: bank = ["000","111","000"]
# Output: 0
# Explanation: There does not exist two devices located on two different rows.
#
#
# Constraints:
#
# m == bank.length
# n == bank[i].length
# 1 <= m, n <= 500
# bank[i][j] is either '0' or '1'.
# Solution 1 - Math O(N * M) O(1)
class Solution:
    def numberOfBeams(self, bank: List[str]) -> int:
        count: int = 0
        flag: bool = False
        top: int = 0
        for i in bank:
            x = i.count('1')
            if x > 0:
                if not flag:
                    top = x
                    flag = True
                else:
                    count += top * x
                    top = x
        return count
# Solution 2 - Math O(N * M) O(1)
class Solution:
    def numberOfBeams(self, bank: List[str]) -> int:
        count: int = 0
        prev_top: int = 0
        for i in bank:
            top = i.count('1')
            if top > 0:
                count += prev_top * top
                prev_top = top
        return count
    
# Largest product in a series
# Complete the greatestProduct method so that it'll find the greatest product of five consecutive digits in the given string of digits.
#
# For example:
#
# greatestProduct("123834539327238239583") // should return 3240
# The input string always has more than five digits.
#
# Adapted from Project Euler.
#
# MATHEMATICSALGORITHMS
import math
def greatest_product(st):
    top: int = 0
    for i in range(len(st) - 4):
        s = math.prod(int(j) for j in st[i:i+5])
        if s > top:
            top = s
    return top

# 2367. Number of Arithmetic Triplets
# You are given a 0-indexed, strictly increasing integer array nums and a positive integer diff. A triplet (i, j, k) is an arithmetic triplet if the following conditions are met:
#
# i < j < k,
# nums[j] - nums[i] == diff, and
# nums[k] - nums[j] == diff.
# Return the number of unique arithmetic triplets.
#
#
#
# Example 1:
#
# Input: nums = [0,1,4,6,7,10], diff = 3
# Output: 2
# Explanation:
# (1, 2, 4) is an arithmetic triplet because both 7 - 4 == 3 and 4 - 1 == 3.
# (2, 4, 5) is an arithmetic triplet because both 10 - 7 == 3 and 7 - 4 == 3.
# Example 2:
#
# Input: nums = [4,5,6,7,8,9], diff = 2
# Output: 2
# Explanation:
# (0, 2, 4) is an arithmetic triplet because both 8 - 6 == 2 and 6 - 4 == 2.
# (1, 3, 5) is an arithmetic triplet because both 9 - 7 == 2 and 7 - 5 == 2.
#
#
# Constraints:
#
# 3 <= nums.length <= 200
# 0 <= nums[i] <= 200
# 1 <= diff <= 50
# nums is strictly increasing.
# Solution HashSet O(N) O(N)
class Solution:
    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:
        hs: set = set()
        count: int = 0
        for i in nums:
            if i - diff in hs and i - diff * 2 in hs:
                count += 1
            hs.add(i)
        return count
# Solution Combination with memorization O(N**3), O(1)
class Solution:
    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:
        count: int = 0
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                for k in range(j + 1, len(nums)):
                    if nums[j] - nums[i] == nums[k] - nums[j] == diff:
                        count += 1
        return count

# 1275. Find Winner on a Tic Tac Toe Game
# Tic-tac-toe is played by two players A and B on a 3 x 3 grid. The rules of Tic-Tac-Toe are:
#
# Players take turns placing characters into empty squares ' '.
# The first player A always places 'X' characters, while the second player B always places 'O' characters.
# 'X' and 'O' characters are always placed into empty squares, never on filled ones.
# The game ends when there are three of the same (non-empty) character filling any row, column, or diagonal.
# The game also ends if all squares are non-empty.
# No more moves can be played if the game is over.
# Given a 2D integer array moves where moves[i] = [rowi, coli] indicates that the ith move will be played on grid[rowi][coli]. return the winner of the game if it exists (A or B). In case the game ends in a draw return "Draw". If there are still movements to play return "Pending".
#
# You can assume that moves is valid (i.e., it follows the rules of Tic-Tac-Toe), the grid is initially empty, and A will play first.
#
#
#
# Example 1:
#
#
# Input: moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]
# Output: "A"
# Explanation: A wins, they always play first.
# Example 2:
#
#
# Input: moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]
# Output: "B"
# Explanation: B wins.
# Example 3:
#
#
# Input: moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]]
# Output: "Draw"
# Explanation: The game ends in a draw since there are no moves to make.
#
#
# Constraints:
#
# 1 <= moves.length <= 9
# moves[i].length == 2
# 0 <= rowi, coli <= 2
# There are no repeated elements on moves.
# moves follow the rules of tic tac toe.
# Solution O(R + C) O(R + C)
class Solution:
    def tictactoe(self, moves: List[List[int]]) -> str:
        m: list = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
        for i in range(len(moves)):
            m[moves[i][0]][moves[i][1]] = 'A' if i % 2 == 0 else 'B'
        for j in 'AB':
            if (
                (m[0][0] == m[1][1] == m[2][2] == j)
                or (m[0][2] == m[1][1] == m[2][0] == j)
                or (m[0][0] == m[1][0] == m[2][0] == j)
                or (m[0][1] == m[1][1] == m[2][1] == j)
                or (m[0][2] == m[1][2] == m[2][2] == j)
                or (m[0][0] == m[0][1] == m[0][2] == j)
                or (m[1][0] == m[1][1] == m[1][2] == j)
                or (m[2][0] == m[2][1] == m[2][2] == j)
            ):
                return j
        return 'Draw' if len(moves) == 9 else 'Pending'

# 2870. Minimum Number of Operations to Make Array Empty
# You are given a 0-indexed array nums consisting of positive integers.
#
# There are two types of operations that you can apply on the array any number of times:
#
# Choose two elements with equal values and delete them from the array.
# Choose three elements with equal values and delete them from the array.
# Return the minimum number of operations required to make the array empty, or -1 if it is not possible.
#
#
#
# Example 1:
#
# Input: nums = [2,3,3,2,2,4,2,3,4]
# Output: 4
# Explanation: We can apply the following operations to make the array empty:
# - Apply the first operation on the elements at indices 0 and 3. The resulting array is nums = [3,3,2,4,2,3,4].
# - Apply the first operation on the elements at indices 2 and 4. The resulting array is nums = [3,3,4,3,4].
# - Apply the second operation on the elements at indices 0, 1, and 3. The resulting array is nums = [4,4].
# - Apply the first operation on the elements at indices 0 and 1. The resulting array is nums = [].
# It can be shown that we cannot make the array empty in less than 4 operations.
# Example 2:
#
# Input: nums = [2,1,2,2,3,3]
# Output: -1
# Explanation: It is impossible to empty the array.
#
#
# Constraints:
#
# 2 <= nums.length <= 105
# 1 <= nums[i] <= 106
# Solution O(N) O(N)
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        count: int = 0
        d: dict = {}
        for i in nums:
            d[i] = d.get(i, 0) + 1
        for i in d:
            if d[i] == 1:
                return -1
            if d[i] % 3 == 0:
                count += d[i] // 3
            else:
                while d[i] - 3 >= 2:
                    d[i] -= 3
                    count += 1
                if d[i] % 2 == 0:
                    count += d[i] // 2
        return count

# Schrödinger's Boolean
# Can a value be both True and False?
#
# Define omnibool so that it returns True for the following:
#
# omnibool == True and omnibool == False
# If you enjoyed this kata, be sure to check out my other katas.
#
# LANGUAGE FEATURESMETAPROGRAMMINGPUZZLES
# Solution
class AlwaysTrue:
    def __eq__(self, other):
        return True

omnibool = AlwaysTrue()

# 976. Largest Perimeter Triangle
# Given an integer array nums, return the largest perimeter of a triangle with a non-zero area, formed from three of these lengths. If it is impossible to form any triangle of a non-zero area, return 0.
#
#
#
# Example 1:
#
# Input: nums = [2,1,2]
# Output: 5
# Explanation: You can form a triangle with three side lengths: 1, 2, and 2.
# Example 2:
#
# Input: nums = [1,2,1,10]
# Output: 0
# Explanation:
# You cannot use the side lengths 1, 1, and 2 to form a triangle.
# You cannot use the side lengths 1, 1, and 10 to form a triangle.
# You cannot use the side lengths 1, 2, and 10 to form a triangle.
# As we cannot use any three side lengths to form a triangle of non-zero area, we return 0.
#
#
# Constraints:
#
# 3 <= nums.length <= 104
# 1 <= nums[i] <= 106
# Solution O(NlogN) O(1)
class Solution:
    def largestPerimeter(self, nums: List[int]) -> int:
        nums.sort(reverse=True)
        for i in range(2, len(nums)):
            if nums[i] + nums[i-1] > nums[i-2]:
                return nums[i-2] + nums[i-1] + nums[i]
        return 0
    
# 43. Multiply Strings
# Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.
#
# Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.
#
#
#
# Example 1:
#
# Input: num1 = "2", num2 = "3"
# Output: "6"
# Example 2:
#
# Input: num1 = "123", num2 = "456"
# Output: "56088"
#
#
# Constraints:
#
# 1 <= num1.length, num2.length <= 200
# num1 and num2 consist of digits only.
# Both num1 and num2 do not contain any leading zero, except the number 0 itself.
class Solution:
    def multiply(self, num1: str, num2: str) -> str:
        if num1 == '0' or num2 == '0':
            return '0'
        d: dict = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4,
        '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}
        r_d: dict = {0: '0', 1: '1', 2: '2', 3: '3', 4: '4',
        5: '5', 6: '6', 7: '7', 8: '8', 9: '9'}
        x1, x2 = 0, 0
        for i in num1:
            x1 = x1 * 10 + d[i]
        for i in num2:
            x2 = x2 * 10 + d[i]
        x3 = x1 * x2
        ans: str = ''
        while x3:
            ans += r_d[x3 % 10]
            x3 //= 10
        return ans[::-1]

# 54. Spiral Matrix
# Given an m x n matrix, return all elements of the matrix in spiral order.
#
#
#
# Example 1:
#
#
# Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
# Output: [1,2,3,6,9,8,7,4,5]
# Example 2:
#
#
# Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
# Output: [1,2,3,4,8,12,11,10,9,5,6,7]
#
#
# Constraints:
#
# m == matrix.length
# n == matrix[i].length
# 1 <= m, n <= 10
# -100 <= matrix[i][j] <= 100
# Solution O(M * (M + N)) O(M + N)
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        l: list = []
        for k in range(len(matrix)):
            if matrix:
                for i in range(len(matrix[0]) - 1):
                    if matrix[0]:
                        l.append(matrix[0].pop(0))
            for i in range(len(matrix) - 1):
                if matrix[i]:
                    l.append(matrix[i].pop())
            if matrix:
                for i in range(len(matrix[-1]) - 1, 0, -1):
                    if matrix[-1]:
                        l.append(matrix[-1].pop(i))
            for i in range(len(matrix) - 1, 0, -1):
                if matrix[i]:
                    l.append(matrix[i].pop(0))
            for i in matrix:
                if not i:
                    matrix.remove(i)
        return l + matrix[0] if matrix else l

# 300. Longest Increasing Subsequence
# Given an integer array nums, return the length of the longest strictly increasing
# subsequence
# .
#
#
#
# Example 1:
#
# Input: nums = [10,9,2,5,3,7,101,18]
# Output: 4
# Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.
# Example 2:
#
# Input: nums = [0,1,0,3,2,3]
# Output: 4
# Example 3:
#
# Input: nums = [7,7,7,7,7,7,7]
# Output: 1
#
#
# Constraints:
#
# 1 <= nums.length <= 2500
# -104 <= nums[i] <= 104
#
#
# Follow up: Can you come up with an algorithm that runs in O(n log(n)) time complexity?
# Solution O(N**2) O(N)
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        n: int = len(nums)
        dp: list = [1] * n
        for i in range(1, n):
            for j in range(i):
                if nums[i] > nums[j] and dp[i] < dp[j] + 1:
                    dp[i] = dp[j] + 1
        return max(dp)
    
# Identify the array's ordering
# Write a function that takes a single array as an argument (containing multiple strings and/or positive numbers and/or arrays), and returns one of four possible string values, depending on the ordering of the lengths of the elements in the input array:
#
# Your function should return...
#
# “Increasing” - if the lengths of the elements increase from left to right (although it is possible that some neighbouring elements may also be equal in length)
# “Decreasing” - if the lengths of the elements decrease from left to right (although it is possible that some neighbouring elements may also be equal in length)
# “Unsorted” - if the lengths of the elements fluctuate from left to right
# “Constant” - if all element's lengths are the same.
# Numbers and Strings should be evaluated based on the number of characters or digits used to write them.
#
# Arrays should be evaluated based on the number of elements counted directly in the parent array (but not the number of elements contained in any sub-arrays).
#
# Happy coding! :)
#
# ARRAYSSTRINGSALGORITHMSFUNDAMENTALS
def order_type(arr):
    if not arr or len(arr) == 1:
        return 'Constant'
    l: list = []
    for i in arr:
        if type(i) in {str, list}:
            l.append(len(i))
        else:
            l.append(len(str(i)))
    if all(x == y for x, y in zip(l, l[1:])):
        return 'Constant'
    elif all(x <= y for x, y in zip(l, l[1:])):
        return 'Increasing'
    elif all(x >= y for x, y in zip(l, l[1:])):
        return 'Decreasing'
    return 'Unsorted'

# 1689. Partitioning Into Minimum Number Of Deci-Binary Numbers
# A decimal number is called deci-binary if each of its digits is either 0 or 1 without any leading zeros. For example, 101 and 1100 are deci-binary, while 112 and 3001 are not.
#
# Given a string n that represents a positive decimal integer, return the minimum number of positive deci-binary numbers needed so that they sum up to n.
#
#
#
# Example 1:
#
# Input: n = "32"
# Output: 3
# Explanation: 10 + 11 + 11 = 32
# Example 2:
#
# Input: n = "82734"
# Output: 8
# Example 3:
#
# Input: n = "27346209830709182346"
# Output: 9
#
#
# Constraints:
#
# 1 <= n.length <= 105
# n consists of only digits.
# n does not contain any leading zeros and represents a positive integer.
class Solution:
    def minPartitions(self, n: str) -> int:
        return int(max(n))
    
# Mix Fruit Juice
# Story
# Jumbo Juice makes a fresh juice out of fruits of your choice.Jumbo Juice charges $5 for regular fruits and $7 for special ones. Regular fruits are Banana, Orange, Apple, Lemon and Grapes. Special ones are Avocado, Strawberry and Mango. Others fruits that are not listed are also available upon request. Those extra special fruits cost $9 per each. There is no limit on how many fruits she/he picks.The price of a cup of juice is the mean of price of chosen fruits. In case of decimal number (ex. $5.99), output should be the nearest integer (use the standard rounding function of your language of choice).
#
# Input
# The function will receive an array of strings, each with the name of a fruit. The recognition of names should be case insensitive. There is no case of an empty array input.
#
# Example
# ['Mango', 'Banana', 'Avocado'] //the price of this juice bottle is (7+5+7)/3 = $6($6.333333...)
# FUNDAMENTALSARRAYS
def mix_fruit(arr):
    basic: set = {'banana', 'orange', 'apple', 'lemon', 'grapes'}
    special: set = {'avocado', 'strawberry', 'mango'}
    count: int = 0
    for i in arr:
        i = i.lower()
        if i in basic:
            count += 5
        elif i in special:
            count += 7
        else:
            count += 9
    return round(count / len(arr))

# 2942. Find Words Containing Character
# You are given a 0-indexed array of strings words and a character x.
#
# Return an array of indices representing the words that contain the character x.
#
# Note that the returned array may be in any order.
#
#
#
# Example 1:
#
# Input: words = ["leet","code"], x = "e"
# Output: [0,1]
# Explanation: "e" occurs in both words: "leet", and "code". Hence, we return indices 0 and 1.
# Example 2:
#
# Input: words = ["abc","bcd","aaaa","cbc"], x = "a"
# Output: [0,2]
# Explanation: "a" occurs in "abc", and "aaaa". Hence, we return indices 0 and 2.
# Example 3:
#
# Input: words = ["abc","bcd","aaaa","cbc"], x = "z"
# Output: []
# Explanation: "z" does not occur in any of the words. Hence, we return an empty array.
#
#
# Constraints:
#
# 1 <= words.length <= 50
# 1 <= words[i].length <= 50
# x is a lowercase English letter.
# words[i] consists only of lowercase English letters.
# Solution 1 - Simple checking O(N) O(N)
class Solution:
    def findWordsContaining(self, words: List[str], x: str) -> List[int]:
        ans: list = []
        for i in range(len(words)):
            if x in words[i]:
                ans.append(i)
        return ans
# Solution 2 - More Pythonic O(N) O(N)
class Solution:
    def findWordsContaining(self, words: List[str], x: str) -> List[int]:
        return [k for k, v in enumerate(words) if x in v]

# 2980. Check if Bitwise OR Has Trailing Zeros
# You are given an array of positive integers nums.
#
# You have to check if it is possible to select two or more elements in the array such that the bitwise OR of the selected elements has at least one trailing zero in its binary representation.
#
# For example, the binary representation of 5, which is "101", does not have any trailing zeros, whereas the binary representation of 4, which is "100", has two trailing zeros.
#
# Return true if it is possible to select two or more elements whose bitwise OR has trailing zeros, return false otherwise.
#
#
#
# Example 1:
#
# Input: nums = [1,2,3,4,5]
# Output: true
# Explanation: If we select the elements 2 and 4, their bitwise OR is 6, which has the binary representation "110" with one trailing zero.
# Example 2:
#
# Input: nums = [2,4,8,16]
# Output: true
# Explanation: If we select the elements 2 and 4, their bitwise OR is 6, which has the binary representation "110" with one trailing zero.
# Other possible ways to select elements to have trailing zeroes in the binary representation of their bitwise OR are: (2, 8), (2, 16), (4, 8), (4, 16), (8, 16), (2, 4, 8), (2, 4, 16), (2, 8, 16), (4, 8, 16), and (2, 4, 8, 16).
# Example 3:
#
# Input: nums = [1,3,5,7,9]
# Output: false
# Explanation: There is no possible way to select two or more elements to have trailing zeros in the binary representation of their bitwise OR.
#
#
# Constraints:
#
# 2 <= nums.length <= 100
# 1 <= nums[i] <= 100
# Solution Nested Loops O(N**2) O(1)
class Solution:
    def hasTrailingZeros(self, nums: List[int]) -> bool:
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                if bin(nums[i] | nums[j])[-1] == '0':
                    return True
        return False

# 2981. Find Longest Special Substring That Occurs Thrice I
# You are given a string s that consists of lowercase English letters.
#
# A string is called special if it is made up of only a single character. For example, the string "abc" is not special, whereas the strings "ddd", "zz", and "f" are special.
#
# Return the length of the longest special substring of s which occurs at least thrice, or -1 if no special substring occurs at least thrice.
#
# A substring is a contiguous non-empty sequence of characters within a string.
#
#
#
# Example 1:
#
# Input: s = "aaaa"
# Output: 2
# Explanation: The longest special substring which occurs thrice is "aa": substrings "aaaa", "aaaa", and "aaaa".
# It can be shown that the maximum length achievable is 2.
# Example 2:
#
# Input: s = "abcdef"
# Output: -1
# Explanation: There exists no special substring which occurs at least thrice. Hence return -1.
# Example 3:
#
# Input: s = "abcaba"
# Output: 1
# Explanation: The longest special substring which occurs thrice is "a": substrings "abcaba", "abcaba", and "abcaba".
# It can be shown that the maximum length achievable is 1.
#
#
# Constraints:
#
# 3 <= s.length <= 50
# s consists of only lowercase English letters.
# Solution O(N**3) O(1)
class Solution:
    def maximumLength(self, s: str) -> int:
        mx = -1
        top = s[0]
        for i in range(1, len(s)):
            count = 0
            for j in range(len(s)):
                if top == s[j:j+len(top)]:
                    count += 1
                if count > 2:
                    mx = max(mx, len(top))
                    break
            if s[i] == top[-1]:
                top += s[i]
                count = 0
                for j in range(len(s)):
                    if top == s[j:j+len(top)]:
                        count += 1
                    if count > 2:
                        mx = max(mx, len(top))
                        break
            else:
                top = s[i]
        return mx

# 10031. Smallest Missing Integer Greater Than Sequential Prefix Sum
# You are given a 0-indexed array of integers nums.
#
# A prefix nums[0..i] is sequential if, for all 1 <= j <= i, nums[j] = nums[j - 1] + 1. In particular, the prefix consisting only of nums[0] is sequential.
#
# Return the smallest integer x missing from nums such that x is greater than or equal to the sum of the longest sequential prefix.
#
#
#
# Example 1:
#
# Input: nums = [1,2,3,2,5]
# Output: 6
# Explanation: The longest sequential prefix of nums is [1,2,3] with a sum of 6. 6 is not in the array, therefore 6 is the smallest missing integer greater than or equal to the sum of the longest sequential prefix.
# Example 2:
#
# Input: nums = [3,4,5,1,12,14,13]
# Output: 15
# Explanation: The longest sequential prefix of nums is [3,4,5] with a sum of 12. 12, 13, and 14 belong to the array while 15 does not. Therefore 15 is the smallest missing integer greater than or equal to the sum of the longest sequential prefix.
#
#
# Constraints:
#
# 1 <= nums.length <= 50
# 1 <= nums[i] <= 50
class Solution:
    def missingInteger(self, nums: List[int]) -> int:
        s: int = nums[0]
        for i in range(1, len(nums)):
            if nums[i - 1] + 1 == nums[i]:
                s += nums[i]
            else:
                break
        while s in nums:
            s += 1
        return s

# 2894. Divisible and Non-divisible Sums Difference
# You are given positive integers n and m.
#
# Define two integers, num1 and num2, as follows:
#
# num1: The sum of all integers in the range [1, n] that are not divisible by m.
# num2: The sum of all integers in the range [1, n] that are divisible by m.
# Return the integer num1 - num2.
#
#
#
# Example 1:
#
# Input: n = 10, m = 3
# Output: 19
# Explanation: In the given example:
# - Integers in the range [1, 10] that are not divisible by 3 are [1,2,4,5,7,8,10], num1 is the sum of those integers = 37.
# - Integers in the range [1, 10] that are divisible by 3 are [3,6,9], num2 is the sum of those integers = 18.
# We return 37 - 18 = 19 as the answer.
# Example 2:
#
# Input: n = 5, m = 6
# Output: 15
# Explanation: In the given example:
# - Integers in the range [1, 5] that are not divisible by 6 are [1,2,3,4,5], num1 is the sum of those integers = 15.
# - Integers in the range [1, 5] that are divisible by 6 are [], num2 is the sum of those integers = 0.
# We return 15 - 0 = 15 as the answer.
# Example 3:
#
# Input: n = 5, m = 1
# Output: -15
# Explanation: In the given example:
# - Integers in the range [1, 5] that are not divisible by 1 are [], num1 is the sum of those integers = 0.
# - Integers in the range [1, 5] that are divisible by 1 are [1,2,3,4,5], num2 is the sum of those integers = 15.
# We return 0 - 15 = -15 as the answer.
#
#
# Constraints:
#
# 1 <= n, m <= 1000
# Solution 1 - Brute Force O(N) O(1)
class Solution:
    def differenceOfSums(self, n: int, m: int) -> int:
        count: int = 0
        for i in range(1, n + 1):
            if i % m != 0:
                count += i
            elif i % m == 0:
                count -= i
        return count
# Solution 2 Math O(1) O(1)
class Solution:
    def differenceOfSums(self, n: int, m: int) -> int:
        k = n // m
        return n * (n + 1) // 2 - (k + 1) * k * m
    
# Arrays and hex color codes
# Given an array with 3 subarrays, each containing hexadecimal color codes loosely defining red, green and blue colors based on their predominant byte value, return a string description of which of the three colors each array contains.
#
# Input is an array which contains 3 subarrays. These subarrays contain strings representing colors in RGB format, each string will contain one predominant color channel that is more saturated than the other two. Among all the strings in an subarray only 2 color channels will come up as predominant - the one that appears more often is "major" and the one that appears less often is "minor". Your task is to determine the major and minor colors inside each subarray and return them in the following format: {Major1}+{Minor1},{Major2}+{Minor2},{Major3}+{Minor3}.
#
# Example:
#
# input = [
#   ["FFA07A", "FA8072", "8DC4DE"],
#   ["7FFF00", "ADFF2F", "FF0000", "00FF7F", "00FF7F"],
#   ["ADD8E6", "6B8E23", "9ACD32", "32CD32", "00FF00"]
# ]
#
# result = "Red+Blue,Green+Red,Green+Blue"
# Explanation:
#
# first subarray's predominant colors: Red, Red, Blue (Red is major, Blue is minor)
# second subarray's predominant colors: Green, Green, Red, Green, Green (Green is major, Red is minor)
# third subarray's predominant colors: Blue, Green, Green, Green, Green (Green is major, Blue is minor)
# FUNDAMENTALSARRAYS
from PIL import ImageColor
def get_colors(col_arr):
    l: list = []
    for j in col_arr:
        d: dict = {}
        for k in j:
            r, g, b = ImageColor.getcolor('#' + k, "RGB")
            mx = max(r, g, b)
            if mx == r:
                d['Red'] = d.get('Red', 0) + 1
            elif mx == g:
                d['Green'] = d.get('Green', 0) + 1
            else:
                d['Blue'] = d.get('Blue', 0) + 1
        l.append(f"{max(d, key=d.get)}+{min(d, key=d.get)}")
    return ','.join(l)

# 2574. Left and Right Sum Differences
# Given a 0-indexed integer array nums, find a 0-indexed integer array answer where:
#
# answer.length == nums.length.
# answer[i] = |leftSum[i] - rightSum[i]|.
# Where:
#
# leftSum[i] is the sum of elements to the left of the index i in the array nums. If there is no such element, leftSum[i] = 0.
# rightSum[i] is the sum of elements to the right of the index i in the array nums. If there is no such element, rightSum[i] = 0.
# Return the array answer.
#
#
#
# Example 1:
#
# Input: nums = [10,4,8,3]
# Output: [15,1,11,22]
# Explanation: The array leftSum is [0,10,14,22] and the array rightSum is [15,11,3,0].
# The array answer is [|0 - 15|,|10 - 11|,|14 - 3|,|22 - 0|] = [15,1,11,22].
# Example 2:
#
# Input: nums = [1]
# Output: [0]
# Explanation: The array leftSum is [0] and the array rightSum is [0].
# The array answer is [|0 - 0|] = [0].
#
#
# Constraints:
#
# 1 <= nums.length <= 1000
# 1 <= nums[i] <= 105
# Solution O(N) O(1)
class Solution:
    def leftRightDifference(self, nums: List[int]) -> List[int]:
        left_sm, right_sm = 0, sum(nums)
        for i in range(len(nums)):
            x: int = nums[i]
            right_sm -= x
            nums[i] = abs(left_sm - right_sm)
            left_sm += x
        return nums

# Return substring instance count - 2
# Complete the solution so that it returns the number of times the search_text is found within the full_text.
#
# search_substr( full_text, search_text, allow_overlap = True )
# so that overlapping solutions are (not) counted. If the searchText is empty, it should return 0. Usage examples:
#
# search_substr('aa_bb_cc_dd_bb_e', 'bb') # should return 2 since bb shows up twice
# search_substr('aaabbbcccc', 'bbb') # should return 1
# search_substr( 'aaa', 'aa' ) # should return 2
# search_substr( 'aaa', '' ) # should return 0
# search_substr( 'aaa', 'aa', False ) # should return 1
# STRINGSREGULAR EXPRESSIONSALGORITHMS
# Solution
def search_substr(full_text, search_text, allow_overlap=True):
    if not full_text or not search_text:
        return 0
    if allow_overlap:
        count: int = 0
        for i in range(len(full_text)):
            if full_text[i: i + len(search_text)] == search_text:
                count += 1
        return count
    return full_text.count(search_text)

# 2176. Count Equal and Divisible Pairs in an Array
# Given a 0-indexed integer array nums of length n and an integer k, return the number of pairs (i, j) where 0 <= i < j < n, such that nums[i] == nums[j] and (i * j) is divisible by k.
#
#
# Example 1:
#
# Input: nums = [3,1,2,2,2,1,3], k = 2
# Output: 4
# Explanation:
# There are 4 pairs that meet all the requirements:
# - nums[0] == nums[6], and 0 * 6 == 0, which is divisible by 2.
# - nums[2] == nums[3], and 2 * 3 == 6, which is divisible by 2.
# - nums[2] == nums[4], and 2 * 4 == 8, which is divisible by 2.
# - nums[3] == nums[4], and 3 * 4 == 12, which is divisible by 2.
# Example 2:
#
# Input: nums = [1,2,3,4], k = 1
# Output: 0
# Explanation: Since no value in nums is repeated, there are no pairs (i,j) that meet all the requirements.
#
#
# Constraints:
#
# 1 <= nums.length <= 100
# 1 <= nums[i], k <= 100
# Solution O(N**2) O(1)
class Solution:
    def countPairs(self, nums: List[int], k: int) -> int:
        count: int = 0
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                if nums[i] == nums[j] and i * j % k == 0:
                    count += 1
        return count

# Ninja vs Samurai: Attack + Block
# Something is wrong with our Warrior class. All variables should initialize properly and the attack method is not working as expected.
#
# If properly set, it should correctly calculate the damage after an attack (if the attacker position is == to the block position of the defender: no damage; otherwise, the defender gets 10 damage if hit "high" or 5 damage if hit "low". If no block is set, the defender takes 5 extra damage.
#
# For some reason, the health value is not being properly set. The following shows an example of this code being used:
#
# ninja = Warrior('Hanzo Hattori')
# samurai = Warrior('Ryōma Sakamoto')
#
# samurai.block = 'l'
# ninja.attack(samurai, 'h')
# # samurai.health should be 90 now
# The warrios must be able to fight to the bitter end, and good luck to the most skilled!
#
# Notice that health can't be below 0: once hit to 0 health, a warrior attribute deceased becomes true; if hit again, the zombie attribute becomes true too!
#
# DEBUGGING
Position = {'high': 'h', 'low': 'l'}  # don't change this!


class Warrior():
    def __init__(self, name):
        # each warrior should be created with a name and 100 health points
        self.name = name
        self.health = 100
        # default guard is "", that is unguarded
        self.block = ""
        self.deceased = False
        self.zombie = False

    def attack(self, enemy, position):
        damage: int = 0
        # attacking high deals 10 damage, low 5
        # 0 damage if the enemy blocks in the same position
        if enemy.block != position: damage += 10 if position == Position['high'] else 5
        # and even more damage if the enemy is not blocking at all
        if enemy.block == "": damage += 5
        enemy.set_health(enemy.health - damage)

    def set_health(self, new_health):
        # health cannot have negative values
        self.health = max(0, new_health)
        # if a warrior is set to 0 health he is dead
        if self.health == 0:
            if self.deceased: self.zombie = True
            self.deceased = True


# 739. Daily Temperatures
# Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.
#
#
#
# Example 1:
#
# Input: temperatures = [73,74,75,71,69,72,76,73]
# Output: [1,1,4,2,1,1,0,0]
# Example 2:
#
# Input: temperatures = [30,40,50,60]
# Output: [1,1,1,0]
# Example 3:
#
# Input: temperatures = [30,60,90]
# Output: [1,1,0]
#
#
# Constraints:
#
# 1 <= temperatures.length <= 105
# 30 <= temperatures[i] <= 100
# Solution Stack O(N) O(N)
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        stack: list = [0]
        ans: list = [0] * len(temperatures)
        for i in range(1, len(temperatures)):
            while stack and temperatures[i] > temperatures[stack[-1]]:
                ans[stack[-1]] = i - stack[-1]
                stack.pop()
            stack.append(i)
        return ans

# 2231. Largest Number After Digit Swaps by Parity
# You are given a positive integer num. You may swap any two digits of num that have the same parity (i.e. both odd digits or both even digits).
#
# Return the largest possible value of num after any number of swaps.
#
#
#
# Example 1:
#
# Input: num = 1234
# Output: 3412
# Explanation: Swap the digit 3 with the digit 1, this results in the number 3214.
# Swap the digit 2 with the digit 4, this results in the number 3412.
# Note that there may be other sequences of swaps but it can be shown that 3412 is the largest possible number.
# Also note that we may not swap the digit 4 with the digit 1 since they are of different parities.
# Example 2:
#
# Input: num = 65875
# Output: 87655
# Explanation: Swap the digit 8 with the digit 6, this results in the number 85675.
# Swap the first digit 5 with the digit 7, this results in the number 87655.
# Note that there may be other sequences of swaps but it can be shown that 87655 is the largest possible number.
#
#
# Constraints:
#
# 1 <= num <= 109
class Solution:
    def largestInteger(self, num: int) -> int:
        odd, even = [], []
        ans: list = []
        while num:
            x = num % 10
            if x % 2 == 0:
                even.append(x)
                ans.append(True)
            else:
                odd.append(x)
                ans.append(False)
            num //= 10
        odd.sort()
        even.sort()
        i: int = 0
        ans = ans[::-1]
        while odd and even:
            if ans[i] == True:
                ans[i] = even.pop()
            else:
                ans[i] = odd.pop()
            i += 1
        while odd:
            ans[i] = odd.pop()
            i += 1
        while even:
            ans[i] = even.pop()
            i += 1
        top: int = 0
        while ans:
            top =  top * 10 + ans.pop(0)
        return top
    
# Get Password from grid
# In this kata you are expected to recover a scattered password in a (m x n) grid (you'll be given directions of all password pieces in the array)
#
# The array will contain pieces of the password to be recovered, you'll get directions on how to get all the the pieces, your initial position in the array will be the character "x".
#
# Heres what the array looks like
#
# [
#   ["p", "x", "m"],
#   ["a", "$", "$"],
#   ["k", "i", "t"]
# ]
# The given directions would consist of [left, right, up, down] and [leftT, rightT, upT, downT], the former would be used to move around the grid while the latter would be used when you have a password to that direction of you.( E.g if you are in a position and the move to make is leftT it means theres a password to the left of you, so take the value and move there)
#
# So in the 2d array example above, you will be given the directions ["lefT", "downT", "rightT", "rightT"], making for the word "pa$$".
#
# Remember you initial position is the character "x".
#
# So you write the function getPassword(grid, directions) that uses the directions to get a password in the grid.
#
# Another example.
#
# grid = [
#   ["a", "x", "c"],
#   ["g", "l", "t"],
#   ["o", "v", "e"]
# ];
#
# directions = ["downT", "down", "leftT", "rightT", "rightT", "upT"]
#
# getPassword(grid, directions) // => "lovet"
# Once again, Your initial position is the character "x", so from the position of "x" you follow the directions given and get all pieces in the grid.
#
# LOGICARRAYSALGORITHMSDATA STRUCTURES
def get_password(grid, directions):
    m, n = 0, 0
    for i in range(len(grid)):
        if 'x' in grid[i]:
            m, n = i, grid[i].index('x')
    word: str = ''
    for i in directions:
        if i[-1].isupper():
            if i[:-1] in {'down', 'up'}:
                m += 1 if i[:-1] == 'down' else -1
            else:
                n += -1 if i[:-1] == 'left' else 1
            word += grid[m][n]
        else:
            if i in {'down', 'up'}:
                m += 1 if i == 'down' else -1
            else:
                n += -1 if i == 'left' else 1
    return word

# 2190. Most Frequent Number Following Key In an Array
# You are given a 0-indexed integer array nums. You are also given an integer key, which is present in nums.
#
# For every unique integer target in nums, count the number of times target immediately follows an occurrence of key in nums. In other words, count the number of indices i such that:
#
# 0 <= i <= nums.length - 2,
# nums[i] == key and,
# nums[i + 1] == target.
# Return the target with the maximum count. The test cases will be generated such that the target with maximum count is unique.
#
#
#
# Example 1:
#
# Input: nums = [1,100,200,1,100], key = 1
# Output: 100
# Explanation: For target = 100, there are 2 occurrences at indices 1 and 4 which follow an occurrence of key.
# No other integers follow an occurrence of key, so we return 100.
# Example 2:
#
# Input: nums = [2,2,2,2,3], key = 2
# Output: 2
# Explanation: For target = 2, there are 3 occurrences at indices 1, 2, and 3 which follow an occurrence of key.
# For target = 3, there is only one occurrence at index 4 which follows an occurrence of key.
# target = 2 has the maximum number of occurrences following an occurrence of key, so we return 2.
#
#
# Constraints:
#
# 2 <= nums.length <= 1000
# 1 <= nums[i] <= 1000
# The test cases will be generated such that the answer is unique.
class Solution:
    def mostFrequent(self, nums: List[int], key: int) -> int:
        d: dict = {}
        for i in range(len(nums) - 1):
            if nums[i] == key:
                d[nums[i + 1]] = d.get(nums[i + 1], 0) + 1
        top: int = 0
        v_top: int = 0
        for i in d:
            if d[i] > top:
                v_top, top = i, d[i]
        return v_top
    
# Fixed xor
# Fixed xor
# Write a function that takes two hex strings as input and XORs them against each other. If the strings are different lengths the output should be the length of the shortest string.
#
# Hint: The strings would first need to be converted to binary to be XOR'd.
#
# Note:
# If the two strings are of different lengths, the output string should be the same length as the smallest string. This means that the longer string will be cut down to the same size as the smaller string, then xor'd
#
# Further help
# More information on the XOR operation can be found here https://www.khanacademy.org/computing/computer-science/cryptography/ciphers/a/xor-bitwise-operation
#
# More information of the binary and hex bases can be found here https://www.khanacademy.org/math/algebra-home/alg-intro-to-algebra/algebra-alternate-number-bases/v/number-systems-introduction
#
# Examples:
#
# fixed_xor("ab3f", "ac") == "07"
# fixed_xor("aadf", "bce2") == "163d"
# fixed_xor("1c0111001f010100061a024b53535009181c", "686974207468652062756c6c277320657965") == "746865206b696420646f6e277420706c6179"
# ALGORITHMSMATHEMATICSLOGICALGEBRABINARYCRYPTOGRAPHY
def fixed_xor(a, b):
    return ''.join(f'{int(x, 16) ^ int(y, 16):x}' for x, y in zip(a, b))

# 1704. Determine if String Halves Are Alike
# You are given a string s of even length. Split this string into two halves of equal lengths, and let a be the first half and b be the second half.
#
# Two strings are alike if they have the same number of vowels ('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'). Notice that s contains uppercase and lowercase letters.
#
# Return true if a and b are alike. Otherwise, return false.
#
#
#
# Example 1:
#
# Input: s = "book"
# Output: true
# Explanation: a = "bo" and b = "ok". a has 1 vowel and b has 1 vowel. Therefore, they are alike.
# Example 2:
#
# Input: s = "textbook"
# Output: false
# Explanation: a = "text" and b = "book". a has 1 vowel whereas b has 2. Therefore, they are not alike.
# Notice that the vowel o is counted twice.
#
#
# Constraints:
#
# 2 <= s.length <= 1000
# s.length is even.
# s consists of uppercase and lowercase letters.
# Solution O(N) O(1)
class Solution:
    def halvesAreAlike(self, s: str) -> bool:
        n: int = len(s) // 2
        count: int = 0
        vowels: set = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}
        for i in range(n):
            if s[i] in vowels:
                count += 1
            if s[i + n] in vowels:
                count -= 1
        return count == 0
    
# Are all elements equal? (Infinity version)
# Task
# Create a function eq_all that determines if all elements of any iterable are equal; the iterable may be infinite. Return value is a bool.
#
# Examples
# eq_all('aaa')   : True
# eq_all('abc')   : False
# eq_all('')      : True
#
# eq_all([0,0,0]) : True
# eq_all([0,1,2]) : False
# eq_all([])      : True
# Notes
# For the function result to be True, the iterable must be finite; False, however, can result from an element finitely far from the left end. There will be no tests with infinite series of equal elements.
# Elements will be primitive values.
#
# FUNDAMENTALS
# Solution
def eq_all(iterable):
    if not iterable:
        return True
    d: dict = {}
    for i in iterable:
        d[i] = d.get(i, 0) + 1
        if len(d) > 1:
            return False
    return True

# 1347. Minimum Number of Steps to Make Two Strings Anagram
# You are given two strings of the same length s and t. In one step you can choose any character of t and replace it with another character.
#
# Return the minimum number of steps to make t an anagram of s.
#
# An Anagram of a string is a string that contains the same characters with a different (or the same) ordering.
#
#
#
# Example 1:
#
# Input: s = "bab", t = "aba"
# Output: 1
# Explanation: Replace the first 'a' in t with b, t = "bba" which is anagram of s.
# Example 2:
#
# Input: s = "leetcode", t = "practice"
# Output: 5
# Explanation: Replace 'p', 'r', 'a', 'i' and 'c' from t with proper characters to make t anagram of s.
# Example 3:
#
# Input: s = "anagram", t = "mangaar"
# Output: 0
# Explanation: "anagram" and "mangaar" are anagrams.
#
#
# Constraints:
#
# 1 <= s.length <= 5 * 104
# s.length == t.length
# s and t consist of lowercase English letters only.
class Solution:
    def minSteps(self, s: str, t: str) -> int:
        hts, htt = {}, {}
        for i in s:
            hts[i] = hts.get(i, 0) + 1
        for i in t:
            htt[i] = htt.get(i, 0) + 1
        count: int = 0
        for i in hts:
            if i not in htt:
                count += hts[i]
            elif htt[i] < hts[i]:
                count += hts[i] - htt[i]
        return count
    
# Getting MAD
# Getting the Minimum Absolute Difference
# Task
# Given an array of integers with at least 2 elements: a1, a2, a3, a4, ... aN
#
# The absolute difference between two array elements ai and aj, where i != j, is the absolute value of ai - aj.
#
# Return the minimum absolute difference (MAD) between any two elements in the array.
#
# Example
# For [-10, 0, -3, 1]
#
# the MAD is 1.
#
# Explanation:
#
# | -10 -    0  | = 10
# | -10 -  (-3) | =  7
# | -10 -    1  | = 11
# |   0 - (-10) | = 10
# |   0 -  (-3) | =  3
# |   0 -    1  | =  1
# |  -3 - (-10) | =  7
# |  -3 -    0  | =  3
# |  -3 -    1  | =  4
# |   1 - (-10) | = 11
# |   1 -    0  | =  1
# |   1 -  (-3) | =  4
# The minimum value is 1 ( both | 0 - 1 | and | 1 - 0 | ).
#
# Note
# Note that the same value can appear more than once in the array. In that case, the MAD will be 0.
#
# FUNDAMENTALSARRAYSALGORITHMS
def getting_mad(arr):
    cop = list(set(arr))
    if len(cop) != len(arr):
        return 0
    ans: int = float('inf')
    for i in range(len(cop)):
        for j in range(i + 1, len(cop)):
            ans = min(ans, abs(cop[i] - cop[j]))
    return ans if ans < float('inf') else 0

# 1657. Determine if Two Strings Are Close
# Two strings are considered close if you can attain one from the other using the following operations:
#
# Operation 1: Swap any two existing characters.
# For example, abcde -> aecdb
# Operation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character.
# For example, aacabb -> bbcbaa (all a's turn into b's, and all b's turn into a's)
# You can use the operations on either string as many times as necessary.
#
# Given two strings, word1 and word2, return true if word1 and word2 are close, and false otherwise.
#
#
#
# Example 1:
#
# Input: word1 = "abc", word2 = "bca"
# Output: true
# Explanation: You can attain word2 from word1 in 2 operations.
# Apply Operation 1: "abc" -> "acb"
# Apply Operation 1: "acb" -> "bca"
# Example 2:
#
# Input: word1 = "a", word2 = "aa"
# Output: false
# Explanation: It is impossible to attain word2 from word1, or vice versa, in any number of operations.
# Example 3:
#
# Input: word1 = "cabbba", word2 = "abbccc"
# Output: true
# Explanation: You can attain word2 from word1 in 3 operations.
# Apply Operation 1: "cabbba" -> "caabbb"
# Apply Operation 2: "caabbb" -> "baaccc"
# Apply Operation 2: "baaccc" -> "abbccc"
#
#
# Constraints:
#
# 1 <= word1.length, word2.length <= 105
# word1 and word2 contain only lowercase English letters.
class Solution:
    def closeStrings(self, word1: str, word2: str) -> bool:
        if len(word1) != len(word2):
            return False
        htw1, htw2 = {}, {}
        for i in word1:
            htw1[i] = htw1.get(i, 0) + 1
        for i in word2:
            htw2[i] = htw2.get(i, 0) + 1
        for i in htw1:
            if i not in htw2:
                return False
        return sorted(htw1.values()) == sorted(htw2.values())

# 2996. Smallest Missing Integer Greater Than Sequential Prefix Sum
# You are given a 0-indexed array of integers nums.
#
# A prefix nums[0..i] is sequential if, for all 1 <= j <= i, nums[j] = nums[j - 1] + 1. In particular, the prefix consisting only of nums[0] is sequential.
#
# Return the smallest integer x missing from nums such that x is greater than or equal to the sum of the longest sequential prefix.
#
#
#
# Example 1:
#
# Input: nums = [1,2,3,2,5]
# Output: 6
# Explanation: The longest sequential prefix of nums is [1,2,3] with a sum of 6. 6 is not in the array, therefore 6 is the smallest missing integer greater than or equal to the sum of the longest sequential prefix.
# Example 2:
#
# Input: nums = [3,4,5,1,12,14,13]
# Output: 15
# Explanation: The longest sequential prefix of nums is [3,4,5] with a sum of 12. 12, 13, and 14 belong to the array while 15 does not. Therefore 15 is the smallest missing integer greater than or equal to the sum of the longest sequential prefix.
#
#
# Constraints:
#
# 1 <= nums.length <= 50
# 1 <= nums[i] <= 50
# Solution O(N) O(1)
class Solution:
    def missingInteger(self, nums: List[int]) -> int:
        s: int = nums[0]
        for i in range(1, len(nums)):
            if nums[i - 1] + 1 == nums[i]:
                s += nums[i]
            else:
                break
        while s in nums:
            s += 1
        return s
    
# 3000. Maximum Area of Longest Diagonal Rectangle
# You are given a 2D 0-indexed integer array dimensions.
#
# For all indices i, 0 <= i < dimensions.length, dimensions[i][0] represents the length and dimensions[i][1] represents the width of the rectangle i.
#
# Return the area of the rectangle having the longest diagonal. If there are multiple rectangles with the longest diagonal, return the area of the rectangle having the maximum area.
#
#
#
# Example 1:
#
# Input: dimensions = [[9,3],[8,6]]
# Output: 48
# Explanation:
# For index = 0, length = 9 and width = 3. Diagonal length = sqrt(9 * 9 + 3 * 3) = sqrt(90) ≈ 9.487.
# For index = 1, length = 8 and width = 6. Diagonal length = sqrt(8 * 8 + 6 * 6) = sqrt(100) = 10.
# So, the rectangle at index 1 has a greater diagonal length therefore we return area = 8 * 6 = 48.
# Example 2:
#
# Input: dimensions = [[3,4],[4,3]]
# Output: 12
# Explanation: Length of diagonal is the same for both which is 5, so maximum area = 12.
#
#
# Constraints:
#
# 1 <= dimensions.length <= 100
# dimensions[i].length == 2
# 1 <= dimensions[i][0], dimensions[i][1] <= 100
# Solution O(N) O(1)
class Solution:
    def areaOfMaxDiagonal(self, dimensions: List[List[int]]) -> int:
        mx = 0
        area = 0
        for i in dimensions:
            if (i[0]**2 + i[1]**2)**.5 > mx:
                mx = (i[0]**2 + i[1]**2)**.5
                area = i[0] * i[1]
            elif (i[0]**2 + i[1]**2)**.5 == mx:
                mx = (i[0]**2 + i[1]**2)**.5
                area = max(i[0] * i[1], area)
        return area

# Guess and convert
# In this kata, you have to define a function named func that will take a list as input.
#
# You must try and guess the pattern how we get the output number and return list - [output number,binary representation,octal representation,hexadecimal representation], but you must convert that specific number without built-in : bin,oct and hex functions.
#
# Examples :
#
# func([12,13,6,3,6,45,123]) returns - [29,'11101','35','1d']
#
# func([1,9,23,43,65,31,63,99]) returns - [41,'101001','51','29']
#
# func([2,4,6,8,10,12,14,16,18,19]) returns - [10,'1010','12','a']
# PUZZLES
def func(l):
    n: int = sum(l) // len(l)
    ans: list = [format(n, f) for f in ['b', 'o', 'x']]
    return [n] + ans

# 2225. Find Players With Zero or One Losses
# You are given an integer array matches where matches[i] = [winneri, loseri] indicates that the player winneri defeated player loseri in a match.
#
# Return a list answer of size 2 where:
#
# answer[0] is a list of all players that have not lost any matches.
# answer[1] is a list of all players that have lost exactly one match.
# The values in the two lists should be returned in increasing order.
#
# Note:
#
# You should only consider the players that have played at least one match.
# The testcases will be generated such that no two matches will have the same outcome.
#
#
# Example 1:
#
# Input: matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]
# Output: [[1,2,10],[4,5,7,8]]
# Explanation:
# Players 1, 2, and 10 have not lost any matches.
# Players 4, 5, 7, and 8 each have lost one match.
# Players 3, 6, and 9 each have lost two matches.
# Thus, answer[0] = [1,2,10] and answer[1] = [4,5,7,8].
# Example 2:
#
# Input: matches = [[2,3],[1,3],[5,4],[6,4]]
# Output: [[1,2,5,6],[]]
# Explanation:
# Players 1, 2, 5, and 6 have not lost any matches.
# Players 3 and 4 each have lost two matches.
# Thus, answer[0] = [1,2,5,6] and answer[1] = [].
#
#
# Constraints:
#
# 1 <= matches.length <= 105
# matches[i].length == 2
# 1 <= winneri, loseri <= 105
# winneri != loseri
# All matches[i] are unique.
# Solution HashTable O(NlogN) O(N)
class Solution:
    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:
        d: dict = {}
        ans: list = [[], []]
        for i in matches:
            w = d.get(i[0], [0, 0])
            d[i[0]] = [w[0] + 1, w[1] + 1]
            y = d.get(i[1], [0, 0])
            d[i[1]] = [y[0] + 0, y[1] + 1]
        for i in d:
            if d[i][1] > 0:
                if d[i][0] == d[i][1]:
                    ans[0].append(i)
                elif d[i][0] + 1 == d[i][1]:
                    ans[1].append(i)
        ans[0].sort()
        ans[1].sort()
        return ans

# Sorting Arrays by the Amount of Perfect Squares that Each Element May Generate
# You will be given an array of positive integers. The array should be sorted by the amount of distinct perfect squares and reversed, that can be generated from each number permuting its digits.
#
# E.g.: arr = [715, 112, 136, 169, 144]
#
# Number   Perfect Squares w/ its Digits   Amount
#  715                -                       0
#  112               121                      1
#  136               361                      1
#  169           169, 196, 961                3
#  144             144, 441                   2
# So the output will have the following order: [169, 144, 112, 136, 715]
#
# When we have two or more numbers with the same amount of perfect squares in their permutations, we sorted by their values.
#
# In the example given above, we can see that 112 and 136 both generate a perfect square. So 112 comes first.
#
# Examples for this kata:
#
# sort_by_perfsq([715, 112, 136, 169, 144]) == [169, 144, 112, 136, 715]
# # number of perfect squares:                   3    2    1    1    0
# We may have in the array numbers that belongs to the same set of permutations.
#
# sort_by_perfsq([234, 61, 16, 441, 144, 728]) == [144, 441, 16, 61, 234, 728]
# # number of perfect squares:                      2    2    1   0   0    0
# Features of the random tests:
#
# Number of tests: 80
# Arrays between 4 and 20 elements
# Integers having from 1 to 7 digits included
# Enjoy it!!
#
# ALGORITHMSMATHEMATICSNUMBER THEORYPERMUTATIONS
import math
import itertools
def sort_by_perfsq(arr):
    d: dict = {}
    for i in arr:
        count: int = 0
        for j in set(itertools.permutations(map(int, str(i)))):
            x: int = int(''.join(str(k) for k in j))
            count += math.sqrt(x).is_integer()
        d[i] = count
    ans: list = []
    while d:
        top: int = 0
        top_val: int = float('-inf')
        for i in d:
            if top_val < d[i]:
                top, top_val = i, d[i]
            elif top_val == d[i]:
                top = min(top, i)
        ans.append(top)
        del d[top]
    return ans

# 380. Insert Delete GetRandom O(1)
# Implement the RandomizedSet class:
#
# RandomizedSet() Initializes the RandomizedSet object.
# bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise.
# bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise.
# int getRandom() Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.
# You must implement the functions of the class such that each function works in average O(1) time complexity.
#
#
#
# Example 1:
#
# Input
# ["RandomizedSet", "insert", "remove", "insert", "getRandom", "remove", "insert", "getRandom"]
# [[], [1], [2], [2], [], [1], [2], []]
# Output
# [null, true, false, true, 2, true, false, 2]
#
# Explanation
# RandomizedSet randomizedSet = new RandomizedSet();
# randomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.
# randomizedSet.remove(2); // Returns false as 2 does not exist in the set.
# randomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].
# randomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.
# randomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].
# randomizedSet.insert(2); // 2 was already in the set, so return false.
# randomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.
#
#
# Constraints:
#
# -231 <= val <= 231 - 1
# At most 2 * 105 calls will be made to insert, remove, and getRandom.
# There will be at least one element in the data structure when getRandom is called.
import random
class RandomizedSet:
    def __init__(self):
        self.ht = {}
        self.data = []

    def insert(self, val: int) -> bool:
        if val not in self.ht:
            self.data.append(val)
            self.ht[val] = len(self.data) - 1
            return True
        return False

    def remove(self, val: int) -> bool:
        if val in self.ht:
            last_item, indx_val = self.data[-1], self.ht[val]
            self.data[indx_val], self.ht[last_item] = last_item, indx_val 
            self.data.pop()
            self.ht.pop(val)
            return True
        return False

    def getRandom(self) -> int:
        return random.choice(self.data)

# Your RandomizedSet object will be instantiated and called as such:
# obj = RandomizedSet()
# param_1 = obj.insert(val)
# param_2 = obj.remove(val)
# param_3 = obj.getRandom()

# Special Scores For Words
# We define a special score for a word (ssw) as follows. We multiply the corresponding 10 - base ascii code for each letter of the word by its respective frequency of this letter in the word, we collect these addens and we sum them up.
#
# For example for the word, investigation we have the respective ascci codes and frequencies for each letter:
#
# Letter    Ascii decimal code        Letter Frequency (in "investigation")
#  i             105                            3
#  n             110                            2
#  t             116                            2
#  a              97                            1
#  e             101                            1
#  g             103                            1
#  o             111                            1
#  s             115                            1
#  v             118                            1
# So the ssw for this word will be:
#
# ssw = 3 * 105 + 2 * 110 + 2 * 116 + 97 * 1 + 101 * 1 + 103 * 1 + 111 * 1 + 115 * 1 + 118 * 1 = 1412
# We need a function find_word() (Javascript: findWord()) that receives two arguments, number of letters, num_let (Javascript: numLet) and a maximum special scoremax_ssw (Javascript: maxSsw) for the word. The function will output a word from a data base of 2000 words that have the highest possible ssw of the given number of letters but smaller or equal than the given max_ssw. If we have more than one word with the same number of letters, num_let, and the same special score, ssw, it will be chosen the last word of the list of words sorted. You were provided with a list of 2000 words of the Oxford Dictionary Of English (U.K. English), named WORD_LIST for python, $word_list for ruby, wordList for javascript.
#
# Let's see some cases:
# num_let = 8
# max_ssw = 888
# find_word(num_let, max_ssw) == 'southern'
# /// There are three words with 8 letters and with ssw == 888
# 'question', 'security' and 'southern'
# The list of these words sorted withe its respespective ssw is [(888, 'question'),
# (888, 'security'), (888, 'southern')], 'southern' should be chosen
#
# num_let = 9
# max_ssw = 500
# find_word(num_let, max_ssw) == None # in Ruby nil, in Javascript null
# /// the word of 9 letters with minimum ssw is 'candidate' with ssw = 925
# There are no word of 9 letters less than 500
# We may have the case when the all the words of certain number of letters are bellow max_ssw
#
# num_let = 7
# max_ssw = 1412
# find_word(num_let, max_ssw) == 'support'
# ///'support' is the word of 7 letters with highest ssw (797)
# Enjoy it!
#
# FUNDAMENTALSDATA STRUCTURESALGORITHMSMEMOIZATION
TOM = {}

def summizing(word):
    ht: dict = {}
    for i in word:
        ht[i] = ht.get(i, 0) + 1
    return sum(ord(i) * ht[i] for i in ht)

def find_word(num_let, max_ssw):
    top_score, top_word = 0, ''
    for i in WORD_LIST:
        if len(i) == num_let:
            if i in TOM:
                if TOM[i] >= top_score and TOM[i] <= max_ssw:
                    top_score, top_word = TOM[i], i
                else:
                    continue
            else:
                x = summizing(i)
                if x >= top_score and x <= max_ssw:
                    top_score, top_word = x, i
                    TOM[i] = x
    return top_word if top_word else None

# 1207. Unique Number of Occurrences
# Given an array of integers arr, return true if the number of occurrences of each value in the array is unique or false otherwise.
#
#
#
# Example 1:
#
# Input: arr = [1,2,2,1,1,3]
# Output: true
# Explanation: The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences.
# Example 2:
#
# Input: arr = [1,2]
# Output: false
# Example 3:
#
# Input: arr = [-3,0,1,-3,1,1,1,-3,10,0]
# Output: true
#
#
# Constraints:
#
# 1 <= arr.length <= 1000
# -1000 <= arr[i] <= 1000
# Solution
class Solution(object):
    def uniqueOccurrences(self, arr):
        counter = Counter(arr).values()
        if(len(counter) == len(set(counter))): return True
        return False


# Solution 2 O(N) O(N) HashTable and HashSet
class Solution:
    def uniqueOccurrences(self, arr: List[int]) -> bool:
        ht: dict = {}
        for i in arr:
            ht[i] = ht.get(i, 0) + 1
        hs: set = set()
        for i in ht:
            if ht[i] in hs:
                return False
            else:
                hs.add(ht[i])
        return True
# Solution 3 O(N) O(N) HashTable
class Solution:
    def uniqueOccurrences(self, arr: List[int]) -> bool:
        ht: dict = {}
        for i in arr:
            ht[i] = ht.get(i, 0) + 1
        return len(ht.values()) == len(set(ht.values()))

# Remove a Specific Element of an Array
# You will be given a certain array of length n, such that n > 4, having positive and negative integers but there will be no zeroes and all the elements will occur once in it.
#
# We may obtain an amount of n sub-arrays of length n - 1, removing one element at a time (from left to right).
#
# For each subarray, let's calculate the product and sum of its elements with the corresponding absolute value of the quotient, q = SubProduct/SubSum (if it is possible, SubSum cannot be 0). Then we select the array with the lowest value of |q|(absolute value)
#
# e.g.: we have the array, arr = [1, 23, 2, -8, 5]
#
# Sub Arrays            SubSum    SubProduct         |q|
# [23, 2, -8, 5]         22         -1840         83.636363
# [1, 2, -8, 5]           0           -80          No value
# [1, 23, -8, 5]         21          -920         43.809524
# [1, 23, 2, 5]          31           230          7.419355  <--- selected array
# [1, 23, 2, -8]         18           368         20.444444
# Let's compare the given array with the selected subarray:
#
# [1, 23, 2, -8, 5]
# [1, 23, 2,     5]
# The difference between them is at the index 3 for the given array, with element -8, so we put both things for a result [3, -8].
#
# That means that to obtain the selected subarray we have to take out the value -8 at index 3. We need a function that receives an array as an argument and outputs the pair [index, arr[index]] that generates the subarray with the lowest value of |q|.
#
# select_subarray([1, 23, 2, -8, 5]) == [3, -8]
# Another case:
#
# select_subarray([1, 3, 23, 4, 2, -8, 5, 18]) == [2, 23]
# In Javascript the function will be selectSubarray().
#
# We may have some special arrays that may have more than one solution as the one that follows below.
#
# select_subarray([10, 20, -30, 100, 200]) == [[3, 100], [4, 200]]
# If there is more than one result the function should output a 2Darray sorted by the index of the element removed from the array.
#
# Thanks to Unnamed for detecting the special cases when we have multiple solutions.
#
# Features of the random tests:
#
# Number of tests = 200
# length of the array, l, such that 20 <= l <= 100
# Enjoy it!!
#
# FUNDAMENTALSDATA STRUCTURESALGORITHMSMATHEMATICSLOGIC
import math
def select_subarray(arr):
    cost_ans: list = [float('inf')]
    ans: list = [[-1, float('inf')]]
    total: int = sum(arr)
    for i in range(len(arr)):
        x: int = total - arr[i]
        if x != 0:
            y: int = math.prod(arr[:i] + arr[i+1:])
            q: int = (abs(y / x))
            if q < cost_ans[-1]:
                ans.clear(); ans.append([i, arr[i]])
                cost_ans.clear(); cost_ans.append(q)
            elif q == cost_ans[-1]:
                ans.append([i, arr[i]])
    return ans[0] if len(ans) == 1 else ans

# 75. Sort Colors
# Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.
#
# We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.
#
# You must solve this problem without using the library's sort function.
#
#
#
# Example 1:
#
# Input: nums = [2,0,2,1,1,0]
# Output: [0,0,1,1,2,2]
# Example 2:
#
# Input: nums = [2,0,1]
# Output: [0,1,2]
#
#
# Constraints:
#
# n == nums.length
# 1 <= n <= 300
# nums[i] is either 0, 1, or 2.
#
#
# Follow up: Could you come up with a one-pass algorithm using only constant extra space?
# Solution O(N) O(1) Two Pointers
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        left, right = 0, len(nums) - 1
        top: int = 0
        while top <= right:
            if nums[top] == 0:
                nums[top], nums[left] = nums[left], nums[top]
                left += 1
            if nums[top] == 2:
                nums[top], nums[right] = nums[right], nums[top]
                right -= 1
            else:
                top += 1
        return nums
    
# Most Consecutive Zeros of a Binary Number
# Given a string (str) containing a base-10 integer between 0 and 10000, convert the integer to its binary representation. At that point, obtain a count of the maximum amount of consecutive 0s. From there, return the count in written form with a capital letter.
#
# max_consec_zeros("9") => "Two"
# max_consec_zeros("13") => "One"
# max_consec_zeros("15") => "Zero"
# max_consec_zeros("42") => "One"
# max_consec_zeros("550") => "Three"
# In the very first example, we have an argument of "9" which is being passed to the method. The binary representation of 9 is 1001 which can be read as: one, zero, zero, one. There are, at most, two consecutive 0s, resulting in the integer 2 as the value of the count. The output in the block of code above reflects the final step of taking 2 from standard form to the written form "Two" as prompted.
#
# In the very last example, we have an argument of "550" which is being passed to the method. The binary representation of 550 is 1000100110 which can be read as: one, zero, zero, zero, one, zero, zero, one, one, zero. There are, at most, three consecutive 0s, resulting in the integer 3 as the value of the count. The output in the block of code above reflects the final step of taking 3 from standard form to the written form of "Three" as prompted.
#
# One way, among many, to visualize the end of each step might look like:
#
# max_consec_zeros("777")
# 1: "777"
# 2: 777
# 3: 1100001001
# 4: 4
# 5: "Four"
# max_consec_zeros("777") => "Four"
# Happy coding!
#
# FUNDAMENTALSMATHEMATICSSTRINGS
 def max_consec_zeros(s):
    words: dict = {0: "Zero", 1: "One", 2: "Two", 3: "Three",
                  4: 'Four', 5: 'Five', 6: 'Six', 7: 'Seven',
                  8: 'Eight', 9: 'Nine', 10: 'Ten', 11: 'Eleven',
                  12: 'Twelve', 13: 'Thirteen'}
    top: int = 0
    seq: int = 0
    for i in bin(int(s))[2:]:
        if i == '0':
            seq += 1
            top = max(top, seq)
        else:
            seq = 0
    return words[top]
 
# 7. Reverse Integer
# Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.
#
# Assume the environment does not allow you to store 64-bit integers (signed or unsigned).
#
#
#
# Example 1:
#
# Input: x = 123
# Output: 321
# Example 2:
#
# Input: x = -123
# Output: -321
# Example 3:
#
# Input: x = 120
# Output: 21
#
#
# Constraints:
#
# -231 <= x <= 231 - 1
class Solution:
    def reverse(self, x: int) -> int:
        flag: bool = x < 0
        if flag:
            x *= -1
        ans: int = 0
        while x:
            ans = ans * 10 + (x % 10)
            x //= 10
        if ans < -2**31 or ans > 2**31-1:
            return 0
        return -ans if flag else ans
    
# LOTTO 6 aus 49 - 6 of 49
# In Germany we have "LOTTO 6 aus 49". That means that 6 of 49 numbers are drawn as winning combination.
# There is also a "Superzahl", an additional number, which can increase your winning category.
#
# In this kata you have to write two methods.
#
# def number_generator():
#
# def check_for_winning_category(your_numbers, winning_numbers):
# The first method is for drawing the lottery numbers.
# You have to create an array with 7 random numbers. 6 from these are from 1 - 49.
# Of course every number may only occur once.
# And the 7th number is the "Superzahl". A number from 0 - 9. This number is independent from the first six numbers.
# The first 6 numbers have to be in ascending order.
#
# A result could be:
# 4, 9, 17, 22, 25, 35, 0
# Or:
# 4, 18, 22, 34, 41, 44, 4
#
# The second method should check a given number against the winning combination and have to return the winning category:
#
# 1  - 6 numbers and Superzahl match
# 2  - 6 numbers match
# 3  - 5 numbers and Superzahl match
# 4  - 5 numbers match
# 5  - 4 numbers and Superzahl match
# 6  - 4 numbers match
# 7  - 3 numbers and Superzahl match
# 8  - 3 numbers match
# 9  - 2 numbers and Superzahl match
# -1 - if the numbers do not match any of the rules above
#
#
# Have fun coding it and please don't forget to vote and rank this kata! :-)
#
# I have created other katas. Have a look if you like coding and challenges.
#
# MATHEMATICSALGORITHMS
import random
def number_generator():
    ans: list = [random.randint(1, 49) for i in range(6)]
    return sorted(ans) + [random.randint(0, 9)]

def check_for_winning_category(your_numbers, winning_numbers):
    count: int = sum(i in winning_numbers[:6] for i in your_numbers[:6])
    top: int = your_numbers[-1] == winning_numbers[-1]
    if count == 6: return 1 if top else 2
    elif count == 5: return 3 if top else 4
    elif count == 4: return 5 if top else 6
    elif count == 3: return 7 if top else 8
    elif count == 2: return 9 if top  else -1
    return -1

# 347. Top K Frequent Elements
# Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.
#
#
#
# Example 1:
#
# Input: nums = [1,1,1,2,2,3], k = 2
# Output: [1,2]
# Example 2:
#
# Input: nums = [1], k = 1
# Output: [1]
#
#
# Constraints:
#
# 1 <= nums.length <= 105
# -104 <= nums[i] <= 104
# k is in the range [1, the number of unique elements in the array].
# It is guaranteed that the answer is unique.
#
#
# Follow up: Your algorithm's time complexity must be better than O(n log n), where n is the array's size.
# Solution O(N) O(N) Bucket
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        ht: dict = {}
        for i in nums:
            ht[i] = ht.get(i, 0) + 1
        bucket: list = [None] * (len(nums) + 1)
        for i in ht:
            if not bucket[ht[i]]:
                bucket[ht[i]] = [i]
            else:
                bucket[ht[i]].extend([i])
        ans: list = []
        for i in range(len(bucket) - 1, -1, -1):
            if bucket[i]:
                ans.extend(bucket[i])
                if len(ans) >= k:
                    break
        return ans[:k]
# Solution HashTable O(NK) O(N + K)
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        ht: dict = {}
        for i in nums:
            ht[i] = ht.get(i, 0) + 1
        ans: list = []
        while k > 0:
            top: int = float('-inf')
            top_value: int = None
            for i in ht:
                if ht[i] > top:
                    top, top_value = ht[i], i
            ans.append(top_value)
            del ht[top_value]
            k -= 1
        return ans

# Cubic Tap Code
# Cubic Tap Code
# This works similarly to Tap Code except instead of being mapped onto a 5x5 square, letters are mapped onto a 3x3x3 cube, left to right, top to bottom, front to back with space being the 27th "letter". Letters are represented by a series of taps (represented as dots .) and pauses (represented by spaces  ), for example A is represented as . . . (first column, first row, first layer) and   is represented as ... ... ... (third column, third row, third layer).
#
# For reference the three layers of the cube are as follows (underscore represents space):
#
# 1  1  2  3
# 1  A  B  C
# 2  D  E  F
# 3  G  H  I
#
# 2  1  2  3
# 1  J  K  L
# 2  M  N  O
# 3  P  Q  R
#
# 3  1  2  3
# 1  S  T  U
# 2  V  W  X
# 3  Y  Z  _
# Your task (should you choose to accept it)
# Create two functions encode() and decode(), to encode and decode strings to and from cubic tap code.
#
# Input
# encode() takes a string of uppercase letters and spaces and outputs a string of dots and spaces. decode() takes a string of dots and spaces and outputs a string of uppercase letters and spaces. All inputs will be valid.
#
# Examples
# encode("N") => ".. .. .."
# encode("TEST") => ".. . ... .. .. . . . ... .. . ..."
# encode("HELLO WORLD") => ".. ... . .. .. . ... . .. ... . .. ... .. .. ... ... ... .. .. ... ... .. .. ... ... .. ... . .. . .. ."
#
# decode(".. .. ..") => "N"
# decode(".. . ... .. .. . . . ... .. . ...") => "TEST"
# decode(".. ... . .. .. . ... . .. ... . .. ... .. .. ... ... ... .. .. ... ... .. .. ... ... .. ... . .. . .. .") => "HELLO WORLD"
# CIPHERSALGORITHMSCRYPTOGRAPHY
# Solution
CHARS: list = [
    [['A',  'B',  'C'], ['D',  'E',  'F'], ['G',  'H',  'I']],
    [['J',  'K',  'L'], ['M',  'N',  'O'], ['P',  'Q',  'R',]],
    [['S',  'T',  'U'], ['V',  'W',  'X'], ['Y',  'Z',  ' ']]
]
LAYER: list = ['ABCDEFGHI', 'JKLMNOPQR', 'STUVWXYZ ']
def encode(string):
    ans: list = []
    for char in string:
        top: list = []
        for layer in range(3):
            if char in LAYER[layer]:
                top.append(layer)
        for rows in range(3):
            if char in CHARS[top[0]][rows]:
                top.append(rows)
                top.append(CHARS[top[0]][top[1]].index(char))
        x: str = ' '.join((i + 1) * '.' for i in top[::-1])
        ans.append(x)
    return ' '.join(ans)

def decode(string):
    word: str = []
    string = string.split()
    for i in range(0, len(string), 3):
        word.append(CHARS[len(string[i+2])-1][len(string[i+1])-1][len(string[i])-1])
    return ''.join(word)

# 2545. Sort the Students by Their Kth Score
# There is a class with m students and n exams. You are given a 0-indexed m x n integer matrix score, where each row represents one student and score[i][j] denotes the score the ith student got in the jth exam. The matrix score contains distinct integers only.
#
# You are also given an integer k. Sort the students (i.e., the rows of the matrix) by their scores in the kth (0-indexed) exam from the highest to the lowest.
#
# Return the matrix after sorting it.
#
#
#
# Example 1:
#
#
# Input: score = [[10,6,9,1],[7,5,11,2],[4,8,3,15]], k = 2
# Output: [[7,5,11,2],[10,6,9,1],[4,8,3,15]]
# Explanation: In the above diagram, S denotes the student, while E denotes the exam.
# - The student with index 1 scored 11 in exam 2, which is the highest score, so they got first place.
# - The student with index 0 scored 9 in exam 2, which is the second highest score, so they got second place.
# - The student with index 2 scored 3 in exam 2, which is the lowest score, so they got third place.
# Example 2:
#
#
# Input: score = [[3,4],[5,6]], k = 0
# Output: [[5,6],[3,4]]
# Explanation: In the above diagram, S denotes the student, while E denotes the exam.
# - The student with index 1 scored 5 in exam 0, which is the highest score, so they got first place.
# - The student with index 0 scored 3 in exam 0, which is the lowest score, so they got second place.
#
#
# Constraints:
#
# m == score.length
# n == score[i].length
# 1 <= m, n <= 250
# 1 <= score[i][j] <= 105
# score consists of distinct integers.
# 0 <= k < n
class Solution:
    def sortTheStudents(self, score: List[List[int]], k: int) -> List[List[int]]:
        for i in range(len(score)):
            for j in range(len(score) - i - 1):
                if score[j][k] < score[j + 1][k]:
                    score[j], score[j + 1] = score[j + 1], score[j]
        return score

# self_converge
# self_converge
# Goal: Given a number (with a minimum of 3 digits), return the number of iterations it takes to arrive at a derived number that converges on to itself, as per the following Kaprekar routine. As a learning exercise, come up with a solution that uses recursion. The following steps would be applicable to a number that originally had exactly 4 digits.
#
# Initialize a counter to count the number of iterations
# Take any four-digit number n, using at least two different digits.
# Arrange the digits in descending and then in ascending order to get two four-digit numbers, adding leading zeros if necessary.
# Add as many zeroes so that the width of the original number is maintained.
# Subtract the smaller number from the bigger number. Let us call this nseq.
# Check if nseq (the remainder) from Step 4 equals the previous value of n. If not, increment the iteration counter and go back to step 2 and perform it on the nseq.
# If the number of digits to start with was more than 4, convergence occurs on to a cycle of numbers. Therefore in Step 5, detect this cycle by comparing to not only the previous value, but to all previous values of n.
#
# If there is a match, then return the count of iterations
# If the sequence_number collapses to zero, then return -1
# Converge values
# While 3-digit numbers converge to the same unique number k which is also 3 digits long, all 4-digit numbers also converge to the same unique value k1 which is 4 digits long. However, 5 digit numbers converge to any one of the following values: 53955, 59994, 61974, 62964, 63954, 71973, 74943, 75933, 82962, 83952.
#
# Example
# 1234 -> 4
#
# 1. 4321 - 1234 =  3087 /
# 2. 8730 - 378  =  8352 /
# 3. 8532 - 2358 =  6174 /
# 4. 7641 - 1467 =  6174 // same as previous
# 414 -> 5
#
# 1. 441 - 144 =  297 /
# 2. 972 - 279 =  693 /
# 3. 963 - 369 =  594 /
# 4. 954 - 459 =  495 /
# 5. 954 - 459 =  495 // same as previous
# 50000 -> 4
#
# 1. 50000 - 5      =  49995 /
# 2. 99954 - 45999  =  53955 /  # first
# 3. 95553 - 35559  =  59994 /
# 4. 99954 - 45999  =  53955 /  # 2nd time
# RECURSIONALGORITHMS
def convert(n: int, flag: bool = False, zeroes: int = 0) -> int:
    l: list = []
    while n:
        l.append(n % 10)
        n //= 10
    l.sort(reverse=flag)
    ans: int = 0
    for i in l:
        ans = ans * 10 + i
    if flag:
        while ans < int(f'1{"0" * zeroes}'):
            ans *= 10
    return ans


def self_converge(n):
    hs: set = set()
    count: int = 1
    prev_x: int = -1
    zeroes: int = len(str(n)) - 1
    x: int = convert(n, flag=True, zeroes=zeroes) - convert(n)
    while x != prev_x:
        if x > 9999:
            if x in hs: return count
        count += 1
        prev_x = x
        hs.add(prev_x)
        x = convert(x, flag=True, zeroes=zeroes) - convert(x)

    return count

# 645. Set Mismatch
# You have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, due to some error, one of the numbers in s got duplicated to another number in the set, which results in repetition of one number and loss of another number.
#
# You are given an integer array nums representing the data status of this set after the error.
#
# Find the number that occurs twice and the number that is missing and return them in the form of an array.
#
#
#
# Example 1:
#
# Input: nums = [1,2,2,4]
# Output: [2,3]
# Example 2:
#
# Input: nums = [1,1]
# Output: [1,2]
#
#
# Constraints:
#
# 2 <= nums.length <= 104
# 1 <= nums[i] <= 104
# Solution
class Solution(object):
    def findErrorNums(self, nums):
        return [sum(nums) - sum(set(nums)), list(set(range(1, len(nums) + 1)) - set(nums))[0]]


# Solution 2 Math O(N) O(1)
class Solution:
    def findErrorNums(self, nums: List[int]) -> List[int]:
        l, x, y = len(nums), sum(nums), sum(set(nums))
        k = (l * (l + 1)) // 2
        return [x-y, k-y]
# Solution 3 HashTable O(N) O(N)
class Solution:
    def findErrorNums(self, nums: List[int]) -> List[int]:
        ht: dict = {}
        for i in range(1, len(nums) + 1):
            ht[i] = 0
        for i in nums:
            ht[i] += 1
        missing, dub = 0, 0
        for i in ht:
            if ht[i] == 0:
                missing = i
            elif ht[i] > 1:
                dub = i
        return [dub, missing]

# Range function
# Create range generator function that will take up to 3 parameters - start value, step and stop value. This function should return an iterable object with numbers. For simplicity, assume all parameters to be positive numbers.
#
# Examples:
#
# range(5) --> 1,2,3,4,5
# range(3, 7) --> 3,4,5,6,7
# range(2, 3, 15) --> 2,5,8,11,14
# FUNDAMENTALS
def range_function(*args):
    if len(args) == 1:
        return range(1, args[0] + 1)
    elif len(args) == 2:
        return range(args[0], args[1] + 1)
    return range(args[0], args[2] + 1, args[1])

# 594. Longest Harmonious Subsequence
# We define a harmonious array as an array where the difference between its maximum value and its minimum value is exactly 1.
#
# Given an integer array nums, return the length of its longest harmonious subsequence among all its possible subsequences.
#
# A subsequence of array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements.
#
#
#
# Example 1:
#
# Input: nums = [1,3,2,2,5,2,3,7]
# Output: 5
# Explanation: The longest harmonious subsequence is [3,2,2,2,3].
# Example 2:
#
# Input: nums = [1,2,3,4]
# Output: 2
# Example 3:
#
# Input: nums = [1,1,1,1]
# Output: 0
#
#
# Constraints:
#
# 1 <= nums.length <= 2 * 104
# -109 <= nums[i] <= 109
class Solution:
    def findLHS(self, nums: List[int]) -> int:
        ht: dict = {}
        for i in nums:
            ht[i] = ht.get(i, 0) + 1
        top: int = 0
        for i in ht:
            if i-1 in ht:
                top = max(top, ht[i] + ht[i-1])
        return top

# Catalog
# You are given a small extract of a catalog:
#
# s = "<prod><name>drill</name><prx>99</prx><qty>5</qty></prod>
#
# <prod><name>hammer</name><prx>10</prx><qty>50</qty></prod>
#
# <prod><name>screwdriver</name><prx>5</prx><qty>51</qty></prod>
#
# <prod><name>table saw</name><prx>1099.99</prx><qty>5</qty></prod>
#
# <prod><name>saw</name><prx>9</prx><qty>10</qty></prod>
#
# ...
# (prx stands for price, qty for quantity) and an article i.e "saw".
#
# The function catalog(s, "saw") returns the line(s) corresponding to the article with $ before the prices:
#
# "table saw > prx: $1099.99 qty: 5\nsaw > prx: $9 qty: 10\n..."
# If the article is not in the catalog return "Nothing".
#
# Notes
# There is a blank line between two lines of the catalog.
#
# The same article may appear more than once. If that happens return all the lines concerned by the article (in the same order as in the catalog; however see below a note for Prolog language).
#
# The line separator of results may depend on the language \nor \r\n. In Pascal \n is replaced by LineEnding.
#
# in Perl use "£" instead of "$" before the prices.
#
# You can see examples in the "Sample tests".
#
# Note for Prolog language
# If the article is not in the catalog then R equals "".
#
# R substrings (separated by "\n") must be in alphabetic order.
#
# FUNDAMENTALSSTRINGS
def catalog(s, article):
    s = s.split('\n')
    ans: list = []
    for i in s:
        if article in i:
            x = i.replace('<prod>', '').replace('</prod>', '').replace('<name>', '').replace('</name>', '')
            x = x.replace('<prx>', ' > prx: $').replace('</prx>', '').replace('<qty>', ' qty: ').replace('</qty>', '')
            ans.append(x)
    return '\r\n'.join(ans) if ans else 'Nothing'

# 1837. Sum of Digits in Base K
# Given an integer n (in base 10) and a base k, return the sum of the digits of n after converting n from base 10 to base k.
#
# After converting, each digit should be interpreted as a base 10 number, and the sum should be returned in base 10.
#
#
#
# Example 1:
#
# Input: n = 34, k = 6
# Output: 9
# Explanation: 34 (base 10) expressed in base 6 is 54. 5 + 4 = 9.
# Example 2:
#
# Input: n = 10, k = 10
# Output: 1
# Explanation: n is already in base 10. 1 + 0 = 1.
#
#
# Constraints:
#
# 1 <= n <= 100
# 2 <= k <= 10
class Solution:
    def sumBase(self, n: int, k: int) -> int:
        ans: int = 0
        while n:
            ans += n % k
            n //= k
        return ans

# telephone words
# Businesses use keypad letters in creative ways to spell out a phone number and make it more memorable. Example: http://en.wikipedia.org/wiki/File:Telephone-keypad2.svg
#
# Create a mapping for your dialer as given in the above link. Constraints:
#
# letters are all uppercase
# digits 0, 1 are mapped to 0, 1 respectively
# Write a function that takes four digits of a phone number, and returns a list of all of the words that can be written with that number. (You should return all permutations, not only English words.)
#
# STRINGSARRAYSALGORITHMS
def telephone_words(digit_string):
    letters: list = [['0'], ['1'], ['ABC'], ['DEF'], ['GHI'],
                    ['JKL'], ['MNO'], ['PQRS'], ['TUV'], ['WXYZ']]
    ans: list = []
    for first in letters[int(digit_string[0])][0]:
        for second in letters[int(digit_string[1])][0]:
            for third in letters[int(digit_string[2])][0]:
                for fourth in letters[int(digit_string[3])][0]:
                    ans.append(first + second + third + fourth)
    return ans

# 1143. Longest Common Subsequence
# Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.
#
# A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.
#
# For example, "ace" is a subsequence of "abcde".
# A common subsequence of two strings is a subsequence that is common to both strings.
#
#
#
# Example 1:
#
# Input: text1 = "abcde", text2 = "ace"
# Output: 3
# Explanation: The longest common subsequence is "ace" and its length is 3.
# Example 2:
#
# Input: text1 = "abc", text2 = "abc"
# Output: 3
# Explanation: The longest common subsequence is "abc" and its length is 3.
# Example 3:
#
# Input: text1 = "abc", text2 = "def"
# Output: 0
# Explanation: There is no such common subsequence, so the result is 0.
#
#
# Constraints:
#
# 1 <= text1.length, text2.length <= 1000
# text1 and text2 consist of only lowercase English characters.
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        F: list = [[0] * (len(text2) + 1) for i in range((len(text1) + 1))]
        for i in range(1, len(text1) + 1):
            for j in range(1, len(text2) + 1):
                if text1[i-1] == text2[j-1]:
                    F[i][j] = 1 + F[i-1][j-1]
                else:
                    F[i][j] = max(F[i-1][j], F[i][j-1])
        return F[-1][-1]

# Numbers so vain, they probably think this Kata is about them.
# Well, those numbers were right and we're going to feed their ego.
#
# Write a function, isNarcissistic, that takes in any amount of numbers and returns true if all the numbers are narcissistic. Return false for invalid arguments (numbers passed in as strings are ok).
#
# For more information about narcissistic numbers (and believe me, they love it when you read about them) follow this link: https://en.wikipedia.org/wiki/Narcissistic_number
#
# ALGORITHMSMATHEMATICS
def is_narcissistic(*args):
    for n in args:
        if not str(n).isdigit(): return False
        b: int = len(str(n))
        top: int = 0
        for i in str(n):
            top += int(i) ** b
        if top != int(n):
            return False
    return True

# 2160. Minimum Sum of Four Digit Number After Splitting Digits
# You are given a positive integer num consisting of exactly four digits. Split num into two new integers new1 and new2 by using the digits found in num. Leading zeros are allowed in new1 and new2, and all the digits found in num must be used.
#
# For example, given num = 2932, you have the following digits: two 2's, one 9 and one 3. Some of the possible pairs [new1, new2] are [22, 93], [23, 92], [223, 9] and [2, 329].
# Return the minimum possible sum of new1 and new2.
#
#
#
# Example 1:
#
# Input: num = 2932
# Output: 52
# Explanation: Some possible pairs [new1, new2] are [29, 23], [223, 9], etc.
# The minimum sum can be obtained by the pair [29, 23]: 29 + 23 = 52.
# Example 2:
#
# Input: num = 4009
# Output: 13
# Explanation: Some possible pairs [new1, new2] are [0, 49], [490, 0], etc.
# The minimum sum can be obtained by the pair [4, 9]: 4 + 9 = 13.
#
#
# Constraints:
#
# 1000 <= num <= 9999
class Solution:
    def minimumSum(self, num: int) -> int:
        lst: list = []
        while num:
            lst.append(num % 10)
            num //= 10
        lst.sort()
        x, y = 0, 0
        for i in range(len(lst)):
            if i % 2 == 0:
                x = x * 10 + lst[i]
            else:
                y = y * 10 + lst[i]
        return x + y

# Diamonds and Toads
# Base on the fairy tale Diamonds and Toads from Charles Perrault. In this kata you will have to complete a function that take 2 arguments:
#
# A string, that correspond to what the daugther says.
# A string, that tell you wich fairy the girl have met, this one can be good or evil.
# The function should return the following count as a hash:
#
# If the girl have met the good fairy:
# count 1 ruby everytime you see a r and 2 everytime you see a R
# count 1 crystal everytime you see a c and 2 everytime you see a C
# If the girl have met the evil fairy:
# count 1 python everytime you see a p and 2 everytime uou see a P
# count 1 squirrel everytime you see a s and 2 everytime you see a S
# Note: For this kata I decided to remplace the normal Diamonds and Toads by some programming languages. And just discover that Squirrel is a programming language.
#
# FUNDAMENTALSSTRINGS
def diamonds_and_toads(sentence, fairy):
    flag: bool = fairy == 'good'
    ht: dict = {}
    if flag:
        ht['ruby'] = 0
        ht['crystal'] = 0
    else:
        ht['python'] = 0
        ht['squirrel'] = 0
    for i in sentence:
        if flag:
            if i in 'rR':
                ht['ruby'] += (1 if i.islower() else 2)
            if i in 'cC':
                ht['crystal'] += (1 if i.islower() else 2)
        else:
            if i in 'pP':
                ht['python'] += (1 if i.islower() else 2)
            if i in 'sS':
                ht['squirrel'] += (1 if i.islower() else 2)
    return ht

# 2956. Find Common Elements Between Two Arrays
# You are given two 0-indexed integer arrays nums1 and nums2 of sizes n and m, respectively.
#
# Consider calculating the following values:
#
# The number of indices i such that 0 <= i < n and nums1[i] occurs at least once in nums2.
# The number of indices i such that 0 <= i < m and nums2[i] occurs at least once in nums1.
# Return an integer array answer of size 2 containing the two values in the above order.
#
#
#
# Example 1:
#
# Input: nums1 = [4,3,2,3,1], nums2 = [2,2,5,2,3,6]
# Output: [3,4]
# Explanation: We calculate the values as follows:
# - The elements at indices 1, 2, and 3 in nums1 occur at least once in nums2. So the first value is 3.
# - The elements at indices 0, 1, 3, and 4 in nums2 occur at least once in nums1. So the second value is 4.
# Example 2:
#
# Input: nums1 = [3,4,2,3], nums2 = [1,5]
# Output: [0,0]
# Explanation: There are no common elements between the two arrays, so the two values will be 0.
#
#
# Constraints:
#
# n == nums1.length
# m == nums2.length
# 1 <= n, m <= 100
# 1 <= nums1[i], nums2[i] <= 100
# Solution HashTable
# Complexity
# Time complexity: O(N)
#
# Space complexity: O(N)
class Solution:
    def findIntersectionValues(self, nums1: List[int], nums2: List[int]) -> List[int]:
        ht1, ht2 = dict(), dict()
        for i in range(len(nums2)):
            ht2[nums2[i]] = ht2.get(nums2[i], 0) + 1
        for i in range(len(nums1)):
            ht1[nums1[i]] = ht1.get(nums1[i], 0) + 1
        ans1, ans2 = 0, 0
        for i in ht1:
            if i in ht2:
                ans1 += ht1[i]
        for i in ht2:
            if i in ht1:
                ans2 += ht2[i]
        return [ans1, ans2]
# Solution 2 HashSet
# Complexity
# Time complexity: O(N)
#
# Space complexity: O(N)
class Solution:
    def findIntersectionValues(self, nums1: List[int], nums2: List[int]) -> List[int]:
        hs1, hs2 = set(nums1), set(nums2)
        ans1, ans2 = 0, 0
        for i in nums1:
            if i in hs2:
                ans1 += 1
        for i in nums2:
            if i in hs1:
                ans2 += 1
        return [ans1, ans2]
    
# Optimum coding school location
# Preface
# You are currently working together with a local community to build a school teaching children how to code. First plans have been made and the community wants to decide on the best location for the coding school. In order to make this decision data about the location of students and potential locations is collected.
#
# Problem
# In order to be able to attract and teach as many students as possible we want to minimize the total traveling distance for potential students. The streets system is organized in a traditional grid system and students can only travel horizontally or vertically (not diagonal).
#
# The locations of interested students is given as an array with the first value of each entry presenting the x coordinate and the second value presenting the y coordinate:
#
# students = [[3,7],[2,2],[14,1], ...];
# Potential locations are passed as an array of objects with an unique id, a x and y coordinate:
#
# locations = [{"id": 1, "x": 3, "y": 4}, {"id": 2, "x": 8, "y": 2}, ...];
# Your task is now to evaluate which of the school locations would be best to minimize the distance for all potential students to the school.
#
# The desired output should consist of a string indicating the ID of the best suitable location and the x and y coordinates in the following form:
#
# "The best location is number 1 with the coordinates x = 3 and y = 4"
# ALGORITHMS
def optimum_location(students, locations):
    total, total_value = float('inf'), None
    for start in locations:
        top: int = 0
        for stud in students:
            top += abs(stud[0] - start['x']) + abs(stud[1] - start['y'])
        if top < total:
            total, total_value = top, start
    return f'The best location is number {total_value["id"]} with the coordinates x = {total_value["x"]} and y = {total_value["y"]}'

# 3005. Count Elements With Maximum Frequency
# You are given an array nums consisting of positive integers.
#
# Return the total frequencies of elements in nums such that those elements all have the maximum frequency.
#
# The frequency of an element is the number of occurrences of that element in the array.
#
#
#
# Example 1:
#
# Input: nums = [1,2,2,3,1,4]
# Output: 4
# Explanation: The elements 1 and 2 have a frequency of 2 which is the maximum frequency in the array.
# So the number of elements in the array with maximum frequency is 4.
# Example 2:
#
# Input: nums = [1,2,3,4,5]
# Output: 5
# Explanation: All elements of the array have a frequency of 1 which is the maximum.
# So the number of elements in the array with maximum frequency is 5.
#
#
# Constraints:
#
# 1 <= nums.length <= 100
# 1 <= nums[i] <= 100
class Solution:
    def maxFrequencyElements(self, nums: List[int]) -> int:
        d: dict = {}
        for i in nums:
            d[i] = d.get(i, 0) + 1
        count, m = 0, max(d.values())
        for i in d:
            if d[i] == m:
                count += d[i]
        return count

# 3010. Divide an Array Into Subarrays With Minimum Cost I
# You are given an array of integers nums of length n.
#
# The cost of an array is the value of its first element. For example, the cost of [1,2,3] is 1 while the cost of [3,4,1] is 3.
#
# You need to divide nums into 3 disjoint contiguous
# subarrays
# .
#
# Return the minimum possible sum of the cost of these subarrays.
#
#
#
# Example 1:
#
# Input: nums = [1,2,3,12]
# Output: 6
# Explanation: The best possible way to form 3 subarrays is: [1], [2], and [3,12] at a total cost of 1 + 2 + 3 = 6.
# The other possible ways to form 3 subarrays are:
# - [1], [2,3], and [12] at a total cost of 1 + 2 + 12 = 15.
# - [1,2], [3], and [12] at a total cost of 1 + 3 + 12 = 16.
# Example 2:
#
# Input: nums = [5,4,3]
# Output: 12
# Explanation: The best possible way to form 3 subarrays is: [5], [4], and [3] at a total cost of 5 + 4 + 3 = 12.
# It can be shown that 12 is the minimum cost achievable.
# Example 3:
#
# Input: nums = [10,3,1,1]
# Output: 12
# Explanation: The best possible way to form 3 subarrays is: [10,3], [1], and [1] at a total cost of 10 + 1 + 1 = 12.
# It can be shown that 12 is the minimum cost achievable.
#
#
# Constraints:
#
# 3 <= n <= 50
# 1 <= nums[i] <= 50
class Solution:
    def minimumCost(self, nums: List[int]) -> int:
        y = z = float('inf')
        for i in range(1, len(nums)):
            if nums[i] <= y:
                y, z = nums[i], y
            elif nums[i] <= z:
                z = nums[i]
        return nums[0] + y + z

# 3011. Find if Array Can Be Sorted
# You are given a 0-indexed array of positive integers nums.
#
# In one operation, you can swap any two adjacent elements if they have the same number of
# set bits
# . You are allowed to do this operation any number of times (including zero).
#
# Return true if you can sort the array, else return false.
#
#
#
# Example 1:
#
# Input: nums = [8,4,2,30,15]
# Output: true
# Explanation: Let's look at the binary representation of every element. The numbers 2, 4, and 8 have one set bit each with binary representation "10", "100", and "1000" respectively. The numbers 15 and 30 have four set bits each with binary representation "1111" and "11110".
# We can sort the array using 4 operations:
# - Swap nums[0] with nums[1]. This operation is valid because 8 and 4 have one set bit each. The array becomes [4,8,2,30,15].
# - Swap nums[1] with nums[2]. This operation is valid because 8 and 2 have one set bit each. The array becomes [4,2,8,30,15].
# - Swap nums[0] with nums[1]. This operation is valid because 4 and 2 have one set bit each. The array becomes [2,4,8,30,15].
# - Swap nums[3] with nums[4]. This operation is valid because 30 and 15 have four set bits each. The array becomes [2,4,8,15,30].
# The array has become sorted, hence we return true.
# Note that there may be other sequences of operations which also sort the array.
# Example 2:
#
# Input: nums = [1,2,3,4,5]
# Output: true
# Explanation: The array is already sorted, hence we return true.
# Example 3:
#
# Input: nums = [3,16,8,4,2]
# Output: false
# Explanation: It can be shown that it is not possible to sort the input array using any number of operations.
#
#
# Constraints:
#
# 1 <= nums.length <= 100
# 1 <= nums[i] <= 28
class Solution:
    def canSortArray(self, nums: List[int]) -> bool:
        for i in range(1, len(nums)):
            for j in range(len(nums) - 1):
                if nums[j] > nums[j + 1]:
                    if nums[j].bit_count() == nums[j+1].bit_count():
                        nums[j], nums[j+1] = nums[j+1], nums[j]
        top: int = nums[0]
        for i in range(1, len(nums)):
            if top > nums[i]:
                return False
            else:
                top = nums[i]
        return True

# 3014. Minimum Number of Pushes to Type Word I
# You are given a string word containing distinct lowercase English letters.
#
# Telephone keypads have keys mapped with distinct collections of lowercase English letters, which can be used to form words by pushing them. For example, the key 2 is mapped with ["a","b","c"], we need to push the key one time to type "a", two times to type "b", and three times to type "c" .
#
# It is allowed to remap the keys numbered 2 to 9 to distinct collections of letters. The keys can be remapped to any amount of letters, but each letter must be mapped to exactly one key. You need to find the minimum number of times the keys will be pushed to type the string word.
#
# Return the minimum number of pushes needed to type word after remapping the keys.
#
# An example mapping of letters to keys on a telephone keypad is given below. Note that 1, *, #, and 0 do not map to any letters.
#
#
#
#
# Example 1:
#
#
# Input: word = "abcde"
# Output: 5
# Explanation: The remapped keypad given in the image provides the minimum cost.
# "a" -> one push on key 2
# "b" -> one push on key 3
# "c" -> one push on key 4
# "d" -> one push on key 5
# "e" -> one push on key 6
# Total cost is 1 + 1 + 1 + 1 + 1 = 5.
# It can be shown that no other mapping can provide a lower cost.
# Example 2:
#
#
# Input: word = "xycdefghij"
# Output: 12
# Explanation: The remapped keypad given in the image provides the minimum cost.
# "x" -> one push on key 2
# "y" -> two pushes on key 2
# "c" -> one push on key 3
# "d" -> two pushes on key 3
# "e" -> one push on key 4
# "f" -> one push on key 5
# "g" -> one push on key 6
# "h" -> one push on key 7
# "i" -> one push on key 8
# "j" -> one push on key 9
# Total cost is 1 + 2 + 1 + 2 + 1 + 1 + 1 + 1 + 1 + 1 = 12.
# It can be shown that no other mapping can provide a lower cost.
#
#
# Constraints:
#
# 1 <= word.length <= 26
# word consists of lowercase English letters.
# All letters in word are distinct.
class Solution:
    def minimumPushes(self, word: str) -> int:
        count: int = 0
        top: int = 1
        n: int = 0
        for i in range(len(word)):
            count += top
            n += 1
            if n == 8:
                n, top = 0, top + 1
        return count

# 3015. Count the Number of Houses at a Certain Distance I
# You are given three positive integers n, x, and y.
#
# In a city, there exist houses numbered 1 to n connected by n streets. There is a street connecting the house numbered i with the house numbered i + 1 for all 1 <= i <= n - 1 . An additional street connects the house numbered x with the house numbered y.
#
# For each k, such that 1 <= k <= n, you need to find the number of pairs of houses (house1, house2) such that the minimum number of streets that need to be traveled to reach house2 from house1 is k.
#
# Return a 1-indexed array result of length n where result[k] represents the total number of pairs of houses such that the minimum streets required to reach one house from the other is k.
#
# Note that x and y can be equal.
#
#
#
# Example 1:
#
#
# Input: n = 3, x = 1, y = 3
# Output: [6,0,0]
# Explanation: Let's look at each pair of houses:
# - For the pair (1, 2), we can go from house 1 to house 2 directly.
# - For the pair (2, 1), we can go from house 2 to house 1 directly.
# - For the pair (1, 3), we can go from house 1 to house 3 directly.
# - For the pair (3, 1), we can go from house 3 to house 1 directly.
# - For the pair (2, 3), we can go from house 2 to house 3 directly.
# - For the pair (3, 2), we can go from house 3 to house 2 directly.
# Example 2:
#
#
# Input: n = 5, x = 2, y = 4
# Output: [10,8,2,0,0]
# Explanation: For each distance k the pairs are:
# - For k == 1, the pairs are (1, 2), (2, 1), (2, 3), (3, 2), (2, 4), (4, 2), (3, 4), (4, 3), (4, 5), and (5, 4).
# - For k == 2, the pairs are (1, 3), (3, 1), (1, 4), (4, 1), (2, 5), (5, 2), (3, 5), and (5, 3).
# - For k == 3, the pairs are (1, 5), and (5, 1).
# - For k == 4 and k == 5, there are no pairs.
# Example 3:
#
#
# Input: n = 4, x = 1, y = 1
# Output: [6,4,2,0]
# Explanation: For each distance k the pairs are:
# - For k == 1, the pairs are (1, 2), (2, 1), (2, 3), (3, 2), (3, 4), and (4, 3).
# - For k == 2, the pairs are (1, 3), (3, 1), (2, 4), and (4, 2).
# - For k == 3, the pairs are (1, 4), and (4, 1).
# - For k == 4, there are no pairs.
#
#
# Constraints:
#
# 2 <= n <= 100
# 1 <= x, y <= n
class Solution:
    def countOfPairs(self, n: int, x: int, y: int) -> List[int]:
        l: list = [0] * n
        for i in range(1, n + 1):
            for j in range(i + 1, n + 1):
                top = min(j - i, abs(x - i) + abs(y - j) + 1, abs(y - i) + abs(x - j) + 1)
                l[top - 1] += 2
        return l

# 3016. Minimum Number of Pushes to Type Word II
# You are given a string word containing lowercase English letters.
#
# Telephone keypads have keys mapped with distinct collections of lowercase English letters, which can be used to form words by pushing them. For example, the key 2 is mapped with ["a","b","c"], we need to push the key one time to type "a", two times to type "b", and three times to type "c" .
#
# It is allowed to remap the keys numbered 2 to 9 to distinct collections of letters. The keys can be remapped to any amount of letters, but each letter must be mapped to exactly one key. You need to find the minimum number of times the keys will be pushed to type the string word.
#
# Return the minimum number of pushes needed to type word after remapping the keys.
#
# An example mapping of letters to keys on a telephone keypad is given below. Note that 1, *, #, and 0 do not map to any letters.
#
#
#
#
# Example 1:
#
#
# Input: word = "abcde"
# Output: 5
# Explanation: The remapped keypad given in the image provides the minimum cost.
# "a" -> one push on key 2
# "b" -> one push on key 3
# "c" -> one push on key 4
# "d" -> one push on key 5
# "e" -> one push on key 6
# Total cost is 1 + 1 + 1 + 1 + 1 = 5.
# It can be shown that no other mapping can provide a lower cost.
# Example 2:
#
#
# Input: word = "xyzxyzxyzxyz"
# Output: 12
# Explanation: The remapped keypad given in the image provides the minimum cost.
# "x" -> one push on key 2
# "y" -> one push on key 3
# "z" -> one push on key 4
# Total cost is 1 * 4 + 1 * 4 + 1 * 4 = 12
# It can be shown that no other mapping can provide a lower cost.
# Note that the key 9 is not mapped to any letter: it is not necessary to map letters to every key, but to map all the letters.
# Example 3:
#
#
# Input: word = "aabbccddeeffgghhiiiiii"
# Output: 24
# Explanation: The remapped keypad given in the image provides the minimum cost.
# "a" -> one push on key 2
# "b" -> one push on key 3
# "c" -> one push on key 4
# "d" -> one push on key 5
# "e" -> one push on key 6
# "f" -> one push on key 7
# "g" -> one push on key 8
# "h" -> two pushes on key 9
# "i" -> one push on key 9
# Total cost is 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 2 * 2 + 6 * 1 = 24.
# It can be shown that no other mapping can provide a lower cost.
#
#
# Constraints:
#
# 1 <= word.length <= 105
# word consists of lowercase English letters.
class Solution:
    def minimumPushes(self, word: str) -> int:
        ht: dict = {}
        for i in word:
            ht[i] = ht.get(i, 0) + 1
        ht = {k: v for k, v in sorted(ht.items(), reverse=True, key=lambda item: item[1])}
        count: int = 0
        top: int = 1
        n: int = 0
        for i in ht:
            count += top * ht[i]
            n += 1
            if n == 8:
                n, top = 0, top + 1
        return count

# 3019. Number of Changing Keys
# You are given a 0-indexed string s typed by a user. Changing a key is defined as using a key different from the last used key. For example, s = "ab" has a change of a key while s = "bBBb" does not have any.
#
# Return the number of times the user had to change the key.
#
# Note: Modifiers like shift or caps lock won't be counted in changing the key that is if a user typed the letter 'a' and then the letter 'A' then it will not be considered as a changing of key.
#
#
#
# Example 1:
#
# Input: s = "aAbBcC"
# Output: 2
# Explanation:
# From s[0] = 'a' to s[1] = 'A', there is no change of key as caps lock or shift is not counted.
# From s[1] = 'A' to s[2] = 'b', there is a change of key.
# From s[2] = 'b' to s[3] = 'B', there is no change of key as caps lock or shift is not counted.
# From s[3] = 'B' to s[4] = 'c', there is a change of key.
# From s[4] = 'c' to s[5] = 'C', there is no change of key as caps lock or shift is not counted.
#
# Example 2:
#
# Input: s = "AaAaAaaA"
# Output: 0
# Explanation: There is no change of key since only the letters 'a' and 'A' are pressed which does not require change of key.
#
#
# Constraints:
#
# 1 <= s.length <= 100
# s consists of only upper case and lower case English letters.
class Solution:
    def countKeyChanges(self, s: str) -> int:
        count: int = 0
        for i in range(1, len(s)):
            if s[i-1].lower() != s[i].lower():
                count += 1
        return count
    
# 2657. Find the Prefix Common Array of Two Arrays
# You are given two 0-indexed integer permutations A and B of length n.
#
# A prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.
#
# Return the prefix common array of A and B.
#
# A sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.
#
#
#
# Example 1:
#
# Input: A = [1,3,2,4], B = [3,1,2,4]
# Output: [0,2,3,4]
# Explanation: At i = 0: no number is common, so C[0] = 0.
# At i = 1: 1 and 3 are common in A and B, so C[1] = 2.
# At i = 2: 1, 2, and 3 are common in A and B, so C[2] = 3.
# At i = 3: 1, 2, 3, and 4 are common in A and B, so C[3] = 4.
# Example 2:
#
# Input: A = [2,3,1], B = [3,1,2]
# Output: [0,1,3]
# Explanation: At i = 0: no number is common, so C[0] = 0.
# At i = 1: only 3 is common in A and B, so C[1] = 1.
# At i = 2: 1, 2, and 3 are common in A and B, so C[2] = 3.
#
#
# Constraints:
#
# 1 <= A.length == B.length == n <= 50
# 1 <= A[i], B[i] <= n
# It is guaranteed that A and B are both a permutation of n integers.
class Solution:
    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:
        hsa: set = set()
        hsb: set = set()
        ans: list = []
        for i in range(len(A)):
            hsa.add(A[i])
            hsb.add(B[i])
            top: int = 0
            if A[i] != B[i]:
                if A[i] in hsb:
                    top += 1
                if B[i] in hsa:
                    top += 1
            else:
                top += 1
            if i > 0:
                top += ans[i-1]
            ans.append(top)
        return ans

# 3021. Alice and Bob Playing Flower Game
# Alice and Bob are playing a turn-based game on a circular field surrounded by flowers. The circle represents the field, and there are x flowers in the clockwise direction between Alice and Bob, and y flowers in the anti-clockwise direction between them.
#
# The game proceeds as follows:
#
# Alice takes the first turn.
# In each turn, a player must choose either the clockwise or anti-clockwise direction and pick one flower from that side.
# At the end of the turn, if there are no flowers left at all, the current player captures their opponent and wins the game.
# Given two integers, n and m, the task is to compute the number of possible pairs (x, y) that satisfy the conditions:
#
# Alice must win the game according to the described rules.
# The number of flowers x in the clockwise direction must be in the range [1,n].
# The number of flowers y in the anti-clockwise direction must be in the range [1,m].
# Return the number of possible pairs (x, y) that satisfy the conditions mentioned in the statement.
#
#
#
# Example 1:
#
# Input: n = 3, m = 2
# Output: 3
# Explanation: The following pairs satisfy conditions described in the statement: (1,2), (3,2), (2,1).
# Example 2:
#
# Input: n = 1, m = 1
# Output: 0
# Explanation: No pairs satisfy the conditions described in the statement.
#
#
# Constraints:
#
# 1 <= n, m <= 105
class Solution:
    def flowerGame(self, n: int, m: int) -> int:
        return n * m // 2
    
# Find X
# Part 2 version Find X Ⅱ
#
# We have a function that takes in an integer n, and returns a number x.
#
# Lets call this function findX(n)/find_x(n) (depending on your language):
#
# def find_x(n):
#     x = 0
#     for i in range(n):
#         for j in range(2*n):
#             x += j + i
#     return x
# The functions loops throught the number n and at every iteration, performs a nested loop on 2*n, at each iteration of this nested loop it increments x with the (nested loop index + parents loop index).
#
# This works well when the numbers are reasonably small.
#
# find_x(2) #=> 16
# find_x(3) #=> 63
# find_x(5) #=> 325
# But may be slow for numbers > 103
#
# So your task is to optimize the function findX/find_x, so it works well for large numbers.
#
# Input Range
# 1 <= n <= 106 (105 in JS)
#
# Note: This problem is more about logical reasoning than it is about finding a mathematicial formula, infact there are no complex math formula involved
#
# PUZZLES
def find_x(n):
    y = n * (2*n-1)
    return (n * (y + (n-1) * (2*n) + y)) // 2

# 232. Implement Queue using Stacks
# Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).
#
# Implement the MyQueue class:
#
# void push(int x) Pushes element x to the back of the queue.
# int pop() Removes the element from the front of the queue and returns it.
# int peek() Returns the element at the front of the queue.
# boolean empty() Returns true if the queue is empty, false otherwise.
# Notes:
#
# You must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid.
# Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations.
#
#
# Example 1:
#
# Input
# ["MyQueue", "push", "push", "peek", "pop", "empty"]
# [[], [1], [2], [], [], []]
# Output
# [null, null, null, 1, 1, false]
#
# Explanation
# MyQueue myQueue = new MyQueue();
# myQueue.push(1); // queue is: [1]
# myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
# myQueue.peek(); // return 1
# myQueue.pop(); // return 1, queue is [2]
# myQueue.empty(); // return false
#
#
# Constraints:
#
# 1 <= x <= 9
# At most 100 calls will be made to push, pop, peek, and empty.
# All the calls to pop and peek are valid.
#
#
# Follow-up: Can you implement the queue such that each operation is amortized O(1) time complexity?
# In other words, performing n operations will take overall O(n) time even if one of those operations may take longer.
class MyQueue:

    def __init__(self):
        self.l1 = []
        self.l2 = []

    def push(self, x: int) -> None:
        self.l1.append(x)

    def pop(self) -> int:
        if self.l2:
            return self.l2.pop()
        while self.l1:
            top = self.l1.pop()
            self.l2.append(top)
        return self.l2.pop()

    def peek(self) -> int:
        if self.l2:
            return self.l2[-1]
        return self.l1[0]

    def empty(self) -> bool:
        return not self.l1 and not self.l2


# Your MyQueue object will be instantiated and called as such:
# obj = MyQueue()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.peek()
# param_4 = obj.empty()

# First order Chebyshev polynomials
# First order Chebyshew polynomials are defined by:
#
# T{0}( v ) = 1
# T{1}( v ) = v
# T{n+1}( v ) = 2 * v * T{n}( v ) - T{n-1}( v )
# Calculate T{n}( v ) for given values of v and n.
#
# You don't have to round your results but you should expect large values.
#
# ALGORITHMS
from functools import lru_cache
@lru_cache(maxsize=None)
def chebyshev(n,v):
    if n == 0:
        return 1
    if n == 1:
        return v
    return 2 * v * chebyshev(n-1, v) - chebyshev(n-2, v)

# 150. Evaluate Reverse Polish Notation
# You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.
#
# Evaluate the expression. Return an integer that represents the value of the expression.
#
# Note that:
#
# The valid operators are '+', '-', '*', and '/'.
# Each operand may be an integer or another expression.
# The division between two integers always truncates toward zero.
# There will not be any division by zero.
# The input represents a valid arithmetic expression in a reverse polish notation.
# The answer and all the intermediate calculations can be represented in a 32-bit integer.
#
#
# Example 1:
#
# Input: tokens = ["2","1","+","3","*"]
# Output: 9
# Explanation: ((2 + 1) * 3) = 9
# Example 2:
#
# Input: tokens = ["4","13","5","/","+"]
# Output: 6
# Explanation: (4 + (13 / 5)) = 6
# Example 3:
#
# Input: tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
# Output: 22
# Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
# = ((10 * (6 / (12 * -11))) + 17) + 5
# = ((10 * (6 / -132)) + 17) + 5
# = ((10 * 0) + 17) + 5
# = (0 + 17) + 5
# = 17 + 5
# = 22
#
#
# Constraints:
#
# 1 <= tokens.length <= 104
# tokens[i] is either an operator: "+", "-", "*", or "/", or an integer in the range [-200, 200].
class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        stack: list = []
        operations: dict = {'+': lambda x, y: x + y, '-': lambda x, y: x - y,
        '*': lambda x, y: x * y, '/': lambda x, y: x / y}
        for i in tokens:
            if i in '+-*/':
                y, x = int(stack.pop()), int(stack.pop())
                stack.append(operations[i](x, y))
            else:
                stack.append(i)
        return int(stack[0])

# Casino chips
# You are given three piles of casino chips: white, green and black chips:
#
# the first pile contains only white chips
# the second pile contains only green chips
# the third pile contains only black chips
# Each day you take exactly two chips of different colors and head to the casino. You can choose any color, but you are not allowed to take two chips of the same color in a day.
#
# You will be given an array representing the number of chips of each color and your task is to return the maximum number of days you can pick the chips. Each day you need to take exactly two chips.
#
# Examples (input -> output)
# * [1,1,1] -> 1, because after you pick on day one, there will be only one chip left
# * [1,2,1] -> 2, you can pick twice; you pick two chips on day one then on day two
# * [4,1,1] -> 2
# More examples in the test cases. Good luck!
#
# Brute force is not the way to go here. Look for a simplifying mathematical approach.
#
# MATHEMATICSFUNDAMENTALS
def solve(arr):
    arr.sort()
    return min(arr[0] + arr[1], sum(arr) // 2)

# 739. Daily Temperatures
# Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.
#
#
#
# Example 1:
#
# Input: temperatures = [73,74,75,71,69,72,76,73]
# Output: [1,1,4,2,1,1,0,0]
# Example 2:
#
# Input: temperatures = [30,40,50,60]
# Output: [1,1,1,0]
# Example 3:
#
# Input: temperatures = [30,60,90]
# Output: [1,1,0]
#
#
# Constraints:
#
# 1 <= temperatures.length <= 105
# 30 <= temperatures[i] <= 100
# Solution O(N) O(N)
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        stack: list = [0]
        ans: list = [0] * len(temperatures)
        for i in range(1, len(temperatures)):
            while stack and temperatures[i] > temperatures[stack[-1]]:
                ans[stack[-1]] = i - stack[-1]
                stack.pop()
            stack.append(i)
        return ans

# Sort My Animals
# Consider the following class:
#
# class Animal:
#     def __init__(self, name, number_of_legs):
#         self.name = name
#         self.number_of_legs = number_of_legs
# Write a method that accepts a list of objects of type Animal, and returns a new list. The new list should be a copy of the original list, sorted first by the animal's number of legs, and then by its name.
#
# If an empty list is passed in, it should return an empty list back.
#
# LISTSSORTINGFUNDAMENTALS
def sort_animals(lst : list) -> list:
    return sorted(lst, key=lambda x: (x.number_of_legs, x.name))

# 2966. Divide Array Into Arrays With Max Difference
# You are given an integer array nums of size n and a positive integer k.
#
# Divide the array into one or more arrays of size 3 satisfying the following conditions:
#
# Each element of nums should be in exactly one array.
# The difference between any two elements in one array is less than or equal to k.
# Return a 2D array containing all the arrays. If it is impossible to satisfy the conditions, return an empty array. And if there are multiple answers, return any of them.
#
#
#
# Example 1:
#
# Input: nums = [1,3,4,8,7,9,3,5,1], k = 2
# Output: [[1,1,3],[3,4,5],[7,8,9]]
# Explanation: We can divide the array into the following arrays: [1,1,3], [3,4,5] and [7,8,9].
# The difference between any two elements in each array is less than or equal to 2.
# Note that the order of elements is not important.
# Example 2:
#
# Input: nums = [1,3,3,2,7,3], k = 3
# Output: []
# Explanation: It is not possible to divide the array satisfying all the conditions.
#
#
# Constraints:
#
# n == nums.length
# 1 <= n <= 105
# n is a multiple of 3.
# 1 <= nums[i] <= 105
# 1 <= k <= 105
# Solution (N logN) O(N)
class Solution:
    def divideArray(self, nums: List[int], k: int) -> List[List[int]]:
        nums.sort()
        ans: list = []
        for i in range(0, len(nums), 3):
            if nums[i+2] - nums[i] > k:
                return []
            ans.append(nums[i: i+3])
        return ans if len(nums) % 3 == 0 else []
    
# Largest Difference in Increasing Indexes
# Summary: Write a function which takes an array data of numbers and returns the largest difference in indexes j - i such that data[i] <= data[j]
#
# Long Description:
#
# The largestDifference takes an array of numbers. That array is not sorted. Do not sort it or change the order of the elements in any way, or their values.
#
# Consider all of the pairs of numbers in the array where the first one is less than or equal to the second one.
#
# From these, find a pair where their positions in the array are farthest apart.
#
# Return the difference between the indexes of the two array elements in this pair.
#
# Example:
#
# [ 1, 2, 3] returns 2 because here j = 2 and i = 0 and 2 - 0 = 2
# MATHEMATICSALGORITHMS
def largest_difference(data):
    top: int = 0
    for i in range(len(data)):
        for j in range(i + 1, len(data)):
            if data[i] <= data[j]:
                top = max(top, j - i)
    return top

# 1291. Sequential Digits
# An integer has sequential digits if and only if each digit in the number is one more than the previous digit.
#
# Return a sorted list of all the integers in the range [low, high] inclusive that have sequential digits.
#
#
#
# Example 1:
#
# Input: low = 100, high = 300
# Output: [123,234]
# Example 2:
#
# Input: low = 1000, high = 13000
# Output: [1234,2345,3456,4567,5678,6789,12345]
#
#
# Constraints:
#
# 10 <= low <= high <= 10^9
# Solution O(K * 9) where K is high // 10 Memory O(N)
class Solution:
    def sequentialDigits(self, low: int, high: int) -> List[int]:
        digits: str = '123456789'
        ans: list = []
        n1, n2 = len(str(low)), len(str(high))
        while n1 <= n2:
            for i in range(9 - (n1 - 1)):
                x: int = int(digits[i:i+n1])
                if x < low:
                    continue
                if x <= high:
                    ans.append(x)
                else:
                    break
            n1 += 1
        return ans

# Adding ordinal indicator suffixes to numbers
# Finish the function numberToOrdinal, which should take a number and return it as a string with the correct ordinal indicator suffix (in English). That is:
#
# numberToOrdinal(1) ==> '1st'
# numberToOrdinal(2) ==> '2nd'
# numberToOrdinal(3) ==> '3rd'
# numberToOrdinal(4) ==> '4th'
# ... and so on
# For the purposes of this kata, you may assume that the function will always be passed a non-negative integer. If the function is given 0 as an argument, it should return '0' (as a string).
#
# To help you get started, here is an excerpt from Wikipedia's page on Ordinal Indicators:
#
# st is used with numbers ending in 1 (e.g. 1st, pronounced first)
# nd is used with numbers ending in 2 (e.g. 92nd, pronounced ninety-second)
# rd is used with numbers ending in 3 (e.g. 33rd, pronounced thirty-third)
# As an exception to the above rules, all the "teen" numbers ending with 11, 12 or 13 use -th (e.g. 11th, pronounced eleventh, 112th, pronounced one hundred [and] twelfth)
# th is used for all other numbers (e.g. 9th, pronounced ninth).
# STRINGSALGORITHMS
def number_to_ordinal(n):
    if n == 0: return '0'
    last: list = [n // 10 % 10, n % 10]
    if last == [1, 1] or last == [1, 2] or last == [1, 3]: return f'{n}th'
    if last[1] == 1: return f'{n}st'
    if last[1] == 2: return f'{n}nd'
    if last[1] == 3: return f'{n}rd'
    return f'{n}th'

# 2828. Check if a String Is an Acronym of Words
# Given an array of strings words and a string s, determine if s is an acronym of words.
#
# The string s is considered an acronym of words if it can be formed by concatenating the first character of each string in words in order. For example, "ab" can be formed from ["apple", "banana"], but it can't be formed from ["bear", "aardvark"].
#
# Return true if s is an acronym of words, and false otherwise.
#
#
#
# Example 1:
#
# Input: words = ["alice","bob","charlie"], s = "abc"
# Output: true
# Explanation: The first character in the words "alice", "bob", and "charlie" are 'a', 'b', and 'c', respectively. Hence, s = "abc" is the acronym.
# Example 2:
#
# Input: words = ["an","apple"], s = "a"
# Output: false
# Explanation: The first character in the words "an" and "apple" are 'a' and 'a', respectively.
# The acronym formed by concatenating these characters is "aa".
# Hence, s = "a" is not the acronym.
# Example 3:
#
# Input: words = ["never","gonna","give","up","on","you"], s = "ngguoy"
# Output: true
# Explanation: By concatenating the first character of the words in the array, we get the string "ngguoy".
# Hence, s = "ngguoy" is the acronym.
#
#
# Constraints:
#
# 1 <= words.length <= 100
# 1 <= words[i].length <= 10
# 1 <= s.length <= 100
# words[i] and s consist of lowercase English letters.
# Solution O(N) O(1)
class Solution:
    def isAcronym(self, words: List[str], s: str) -> bool:
        x, y = len(words), len(s)
        if x != y:
            return False
        for i in range(x):
            if words[i][0] != s[i]:
                return False
        return True
    
# Valid string
# You are given a sequence of valid words and a string. Test if the string is made up by one or more words from the array.
#
# Task
# Test if the string can be entirely formed by consecutively concatenating words of the dictionary.
#
# For example:
#
# dictionary: ["code", "wars"]
#
# s1:         "codewars" =>  true  -> match 'code', 'wars'
# s2:         "codewar"  =>  false -> match 'code', unmatched 'war'
# One word from the dictionary can be used several times.
#
# STRINGSALGORITHMS
def valid_word(seq, word):
    matches: list = []
    for i in seq:
        if word.startswith(i):
            matches.append(i)
            if matches[-1] == word:
                return True
    count: int = 0
    while True:
        top: list = []
        flag: bool = False
        for char in matches:
            for wrd in seq:
                if word.startswith(char + wrd):
                    top.append(char + wrd)
                    flag = not flag
                    if top[-1] == word:
                        return True
        matches = top
        if not flag:
            count += 1
        else:
            count = 0
        if count == 10:
            return False

# 804. Unique Morse Code Words
# International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows:
#
# 'a' maps to ".-",
# 'b' maps to "-...",
# 'c' maps to "-.-.", and so on.
# For convenience, the full table for the 26 letters of the English alphabet is given below:
#
# [".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]
# Given an array of strings words where each word can be written as a concatenation of the Morse code of each letter.
#
# For example, "cab" can be written as "-.-..--...", which is the concatenation of "-.-.", ".-", and "-...". We will call such a concatenation the transformation of a word.
# Return the number of different transformations among all words we have.
#
#
#
# Example 1:
#
# Input: words = ["gin","zen","gig","msg"]
# Output: 2
# Explanation: The transformation of each word is:
# "gin" -> "--...-."
# "zen" -> "--...-."
# "gig" -> "--...--."
# "msg" -> "--...--."
# There are 2 different transformations: "--...-." and "--...--.".
# Example 2:
#
# Input: words = ["a"]
# Output: 1
#
#
# Constraints:
#
# 1 <= words.length <= 100
# 1 <= words[i].length <= 12
# words[i] consists of lowercase English letters.
class Solution:
    def uniqueMorseRepresentations(self, words: List[str]) -> int:
        morse: list = [".-","-...","-.-.","-..",".","..-.",
        "--.","....","..",".---","-.-",".-..",
        "--","-.","---",".--.","--.-",".-.","...",
        "-","..-","...-",".--","-..-","-.--","--.."]
        ht: dict = {}
        for i in words:
            top: str = ''
            for j in i:
                top += morse[ord(j) - 97]
            ht[top] = ht.get(top, 0) + 1
        return len(ht)
    
# Odd-heavy Array
# An array is defined to be odd-heavy if it contains at least one odd element and every element whose value is odd is greater than every even-valued element.
#
# eg.
#
# Array [11,4,9,2,8] is odd-heavy,
# because its odd elements [11,9] are greater than all the even elements [4,2,8]
#
# Array [11,4,9,2,3,10] is not odd-heavy,
# because one of its even elements (10 from [4,2,10]) is greater than two of
# its odd elements (9 and 3 from [11,9,3])
#
# Array [] is not odd-heavy,
# because it does not contain any odd numbers
#
# Array [3] is odd-heavy,
# because it does not contain any even numbers.
# write a function called isOddHeavy or is_odd_heavy that accepts an integer array and returns true if the array is odd-heavy else return false.
#
# ARRAYSFUNDAMENTALS
def is_odd_heavy(arr):
    arr.sort()
    x, y = float('inf'), float('-inf')
    for i in arr:
        if i % 2 != 0:
            x = i
            break
    for i in arr[::-1]:
        if i % 2 == 0:
            y = i
            break
    if x != float('inf'):
        return x > y
    return False

# 341. Flatten Nested List Iterator
# You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it.
#
# Implement the NestedIterator class:
#
# NestedIterator(List<NestedInteger> nestedList) Initializes the iterator with the nested list nestedList.
# int next() Returns the next integer in the nested list.
# boolean hasNext() Returns true if there are still some integers in the nested list and false otherwise.
# Your code will be tested with the following pseudocode:
#
# initialize iterator with nestedList
# res = []
# while iterator.hasNext()
#     append iterator.next() to the end of res
# return res
# If res matches the expected flattened list, then your code will be judged as correct.
#
#
#
# Example 1:
#
# Input: nestedList = [[1,1],2,[1,1]]
# Output: [1,1,2,1,1]
# Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].
# Example 2:
#
# Input: nestedList = [1,[4,[6]]]
# Output: [1,4,6]
# Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].
#
#
# Constraints:
#
# 1 <= nestedList.length <= 500
# The values of the integers in the nested list is in the range [-106, 106].
# """
# This is the interface that allows for creating nested lists.
# You should not implement it, or speculate about its implementation
# """
#class NestedInteger:
#    def isInteger(self) -> bool:
#        """
#        @return True if this NestedInteger holds a single integer, rather than a nested list.
#        """
#
#    def getInteger(self) -> int:
#        """
#        @return the single integer that this NestedInteger holds, if it holds a single integer
#        Return None if this NestedInteger holds a nested list
#        """
#
#    def getList(self) -> [NestedInteger]:
#        """
#        @return the nested list that this NestedInteger holds, if it holds a nested list
#        Return None if this NestedInteger holds a single integer
#        """

class NestedIterator:
    def __init__(self, nestedList: [NestedInteger]):
        self.stack = []
        self.flatten(nestedList)

    def flatten(self, nestedList):
        for i in reversed(nestedList):
            self.stack.append(i)

    def next(self) -> int:
        return self.stack.pop().getInteger()

    def hasNext(self) -> bool:
        while self.stack and not self.stack[-1].isInteger():
            self.flatten(self.stack.pop().getList())
        return bool(self.stack)


# Your NestedIterator object will be instantiated and called as such:
# i, v = NestedIterator(nestedList), []
# while i.hasNext(): v.append(i.next())

# By the Power Set of Castle Grayskull
# Write a function that returns all of the sublists of a list/array.
#
# Example:
#
# �
# �
# �
# �
# �
# (
# [
# 1
# ,
# 2
# ,
# 3
# ]
# )
# ;
# =
# >
# [
# [
# ]
# ,
# [
# 1
# ]
# ,
# [
# 2
# ]
# ,
# [
# 1
# ,
# 2
# ]
# ,
# [
# 3
# ]
# ,
# [
# 1
# ,
# 3
# ]
# ,
# [
# 2
# ,
# 3
# ]
# ,
# [
# 1
# ,
# 2
# ,
# 3
# ]
# ]
# power([1,2,3]);=>[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
# For more details regarding this, see the power set entry in wikipedia.
#
# MATHEMATICSALGORITHMS
def power(a):
    subsets: list = [[]]
    for i in a:
        for idx in range(len(subsets)):
            subsets.append(subsets[idx] + [i])
    return subsets

# 49. Group Anagrams
# Given an array of strings strs, group the anagrams together. You can return the answer in any order.
#
# An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.
#
#
#
# Example 1:
#
# Input: strs = ["eat","tea","tan","ate","nat","bat"]
# Output: [["bat"],["nat","tan"],["ate","eat","tea"]]
# Example 2:
#
# Input: strs = [""]
# Output: [[""]]
# Example 3:
#
# Input: strs = ["a"]
# Output: [["a"]]
#
#
# Constraints:
#
# 1 <= strs.length <= 104
# 0 <= strs[i].length <= 100
# strs[i] consists of lowercase English letters.
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        ht: dict = {}
        for i in range(len(strs)):
            x: str = ''.join(sorted(strs[i]))
            if x in ht:
                ht[x] += [i]
            else:
                ht[x] = [i]
        ans: list = []
        for i in ht:
            top: list = []
            for j in ht[i]:
                top.append(strs[j])
            ans.append(top)
        return ans

# Find Cracker.
# Someone was hacking the score. Each student's record is given as an array The objects in the array are given again as an array of scores for each name and total score. ex>
#
# array = [
#   ["name1", 445, ["B", "A", "A", "C", "A", "A"]],
#   ["name2", 110, ["B", "A", "A", "A"]],
#   ["name3", 200, ["B", "A", "A", "C"]],
#   ["name4", 200, ["A", "A", "A", "A", "A", "A", "A"]]
# ]
# The scores for each grade is:
#
# A: 30 points
# B: 20 points
# C: 10 points
# D: 5 points
# Everything else: 0 points
# If there are 5 or more courses and all courses has a grade of B or above, additional 20 points are awarded. After all the calculations, the total score should be capped at 200 points.
#
# Returns the name of the hacked name as an array when scoring with this rule.
#
# array = [
#   ["name1", 445, ["B", "A", "A", "C", "A", "A"]],     # name1 total point is over 200 => hacked
#   ["name2", 110, ["B", "A", "A", "A"]],               # name2 point is right
#   ["name3", 200, ["B", "A", "A", "C"]],               # name3 point is 200 but real point is 90 => hacked
#   ["name4", 200, ["A", "A", "A", "A", "A", "A", "A"]] # name4 point is right
# ];
#
# return ["name1", "name3"]
# FUNDAMENTALSARRAYS
def find_hack(arr):
    ht: dict = {'A': 30, 'B': 20, 'C': 10, 'D': 5}
    hackers: list = []
    for i in arr:
        name, points, scores = i
        top: int = 0
        flag: bool = True
        courses: int = 0
        for j in scores:
            courses += 1
            if j in ht:
                if j not in {'A', 'B'}:
                    flag = False
                top += ht[j]
            else:
                flag = False
        if flag and courses > 4:
            top += 20
        top = 200 if top >= 200 else top
        if top != points:
            hackers.append(name)
    return hackers

# 451. Sort Characters By Frequency
# Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string.
#
# Return the sorted string. If there are multiple answers, return any of them.
#
#
#
# Example 1:
#
# Input: s = "tree"
# Output: "eert"
# Explanation: 'e' appears twice while 'r' and 't' both appear once.
# So 'e' must appear before both 'r' and 't'. Therefore "eetr" is also a valid answer.
# Example 2:
#
# Input: s = "cccaaa"
# Output: "aaaccc"
# Explanation: Both 'c' and 'a' appear three times, so both "cccaaa" and "aaaccc" are valid answers.
# Note that "cacaca" is incorrect, as the same characters must be together.
# Example 3:
#
# Input: s = "Aabb"
# Output: "bbAa"
# Explanation: "bbaA" is also a valid answer, but "Aabb" is incorrect.
# Note that 'A' and 'a' are treated as two different characters.
#
#
# Constraints:
#
# 1 <= s.length <= 5 * 105
# s consists of uppercase and lowercase English letters and digits.
# Solution 1 HashTable in list comprehension O(NlogN) O(N)
class Solution:
    def frequencySort(self, s: str) -> str:
        ht: dict = {}
        for i in s:
            ht[i] = ht.get(i, 0) + 1
        return ''.join(i * ht[i] for i in sorted(ht, key=lambda x: ht[x], reverse=True))
# Solution 2 Bucket Sort O(N) O(N)
class Solution:
    def frequencySort(self, s: str) -> str:
        ht: dict = {}
        for i in s:
            ht[i] = ht.get(i, 0) + 1
        bucket: list = [[] for _ in range(max(ht.values()))]
        for i in ht:
            bucket[ht[i]-1] += [i * ht[i]]
        ans: list = []
        for i in range(len(bucket)-1, -1, -1):
            for j in bucket[i]:
                ans.append(j)
        return ''.join(ans)
    
# Easy Balance Checking
# You are given a (small) check book as a - sometimes - cluttered (by non-alphanumeric characters) string:
#
# "1000.00
# 125 Market 125.45
# 126 Hardware 34.95
# 127 Video 7.45
# 128 Book 14.32
# 129 Gasoline 16.10"
# The first line shows the original balance. Each other line (when not blank) gives information: check number, category, check amount. (Input form may change depending on the language).
#
# First you have to clean the lines keeping only letters, digits, dots and spaces.
#
# Then return a report as a string (underscores show spaces -- don't put them in your solution. They are there so you can see them and how many of them you need to have):
#
# "Original_Balance:_1000.00
# 125_Market_125.45_Balance_874.55
# 126_Hardware_34.95_Balance_839.60
# 127_Video_7.45_Balance_832.15
# 128_Book_14.32_Balance_817.83
# 129_Gasoline_16.10_Balance_801.73
# Total_expense__198.27
# Average_expense__39.65"
# On each line of the report you have to add the new balance and then in the last two lines the total expense and the average expense. So as not to have a too long result string we don't ask for a properly formatted result.
#
# Notes
# See input examples in Sample Tests.
# It may happen that one (or more) line(s) is (are) blank.
# Round to 2 decimals your calculated results (Elm: without traling 0)
# The line separator of results may depend on the language \n or \r\n. See examples in the "Sample tests".
# R language: Don't use R's base function "mean()" that could give results slightly different from expected ones.
# FUNDAMENTALSSTRINGS
import re
def balance(book):
    calc_lines = []
    total_expense =0
    book = re.sub("[^\w\d\.\s\n]", "", book)
    book = re.sub("\s{2,}", "\n", book)
    lines = book.splitlines()
    budget = float(lines.pop(0))
    remains = budget
    for line in lines:
        line = line.split()
        balance  = float(line[-1]) 
        total_expense += balance 
        remains -= balance 
        calc_lines.append(" ".join(
            line[:-1]) \
            + " {:.2f}".format(balance) \
            + " Balance {:.2f}".format(remains))
    return (
        "Original Balance: {:.2f}\r\n".format(budget)
        + '\r\n'.join(calc_lines)
        + "\r\n"
        + "Total expense  {:.2f}\r\n".format(total_expense)
        + "Average expense  {:.2f}".format(total_expense / len(lines)))

# 279. Perfect Squares
# Given an integer n, return the least number of perfect square numbers that sum to n.
#
# A perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.
#
#
#
# Example 1:
#
# Input: n = 12
# Output: 3
# Explanation: 12 = 4 + 4 + 4.
# Example 2:
#
# Input: n = 13
# Output: 2
# Explanation: 13 = 4 + 9.
#
#
# Constraints:
#
# 1 <= n <= 104
class Solution:
    def numSquares(self, n: int) -> int:
        if int(n**.5) == n**.5:
            return 1
        for i in range(1, int(n**.5) + 1):
            if int((n - i**2)**.5)**2 == n - i**2:
                    return 2
        while n %  4 == 0:
            n /= 4
        if n % 8 == 7:
            return 4
        return 3
    
# Element equals its index
# Given a sorted array of distinct integers, write a function index_equals_value that returns the lowest index for which array[index] == index.
# Return -1 if there is no such index.
#
# Your algorithm should be very performant.
#
# [input] array of integers ( with 0-based nonnegative indexing )
# [output] integer
#
# Examples:
# input: [-8,0,2,5]
# output: 2 # since array[2] == 2
#
# input: [-1,0,3,6]
# output: -1 # since no index in array satisfies array[index] == index
# Random Tests Constraints:
# Array length: 200 000
#
# Amount of tests: 1 000
#
# Time limit: 1.5 s
#
# If you liked this Kata check out my more complex creations:
#
# Find the neighbourhood in big dimensions. Neighbourhood collection
#
# The Rubik's cube
#
# ARRAYSALGORITHMS
def index_equals_value(arr):
    left, right = 0, len(arr) - 1
    ans: int = -1
    while left <= right:
        middle = (left + right) // 2
        if middle == arr[middle]:
            ans = middle
            right = middle - 1
        elif middle > arr[middle]:
            left = middle + 1
        else:
            right = middle - 1
    return ans

# 1021. Remove Outermost Parentheses
# A valid parentheses string is either empty "", "(" + A + ")", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.
#
# For example, "", "()", "(())()", and "(()(()))" are all valid parentheses strings.
# A valid parentheses string s is primitive if it is nonempty, and there does not exist a way to split it into s = A + B, with A and B nonempty valid parentheses strings.
#
# Given a valid parentheses string s, consider its primitive decomposition: s = P1 + P2 + ... + Pk, where Pi are primitive valid parentheses strings.
#
# Return s after removing the outermost parentheses of every primitive string in the primitive decomposition of s.
#
#
#
# Example 1:
#
# Input: s = "(()())(())"
# Output: "()()()"
# Explanation:
# The input string is "(()())(())", with primitive decomposition "(()())" + "(())".
# After removing outer parentheses of each part, this is "()()" + "()" = "()()()".
# Example 2:
#
# Input: s = "(()())(())(()(()))"
# Output: "()()()()(())"
# Explanation:
# The input string is "(()())(())(()(()))", with primitive decomposition "(()())" + "(())" + "(()(()))".
# After removing outer parentheses of each part, this is "()()" + "()" + "()(())" = "()()()()(())".
# Example 3:
#
# Input: s = "()()"
# Output: ""
# Explanation:
# The input string is "()()", with primitive decomposition "()" + "()".
# After removing outer parentheses of each part, this is "" + "" = "".
#
#
# Constraints:
#
# 1 <= s.length <= 105
# s[i] is either '(' or ')'.
# s is a valid parentheses string.
# Solution O(N) O(N)
class Solution:
    def removeOuterParentheses(self, s: str) -> str:
        ans: list = []
        count: int = 0
        for i in s:
            if i == '(' and count > 0:
                ans.append(i)
            elif i == ')' and count > 1:
                ans.append(i)
            count += 1 if i == '(' else -1
        return ''.join(ans)
# Solution O(N) O(N)
class Solution:
    def removeOuterParentheses(self, s: str) -> str:
        stack: list = []
        ans: str = ''
        part: list = []
        for i in s:
            if i == '(':
                stack.append(i)
                part.append(i)
            else:
                stack.pop()
                part.append(i)
                if not stack:
                    ans += ''.join(part[1:-1])
                    part = []
        return ans

# Exercise in Summing
# Your task is to finish two functions, minimumSum and maximumSum, that take 2 parameters:
#
# values: an array of integers with an arbitrary length; may be positive and negative
# n: how many integers should be summed; always 0 or bigger
# Example:
# values = [5, 4, 3, 2, 1];
# minimum_sum(values, 2) #should return 1 + 2 = 3
# maximum_sum(values, 3) #should return 3 + 4 + 5 = 12
# All values given to the functions will be integers. Also take care of the following special cases:
#
# if values is empty, both functions should return 0
# if n is 0, both functions should also return 0
# if n is larger than values's length, use the length instead.
# ARRAYSFUNDAMENTALS
def minimum_sum(values, n):
    if not values or not n:
        return 0
    values.sort()
    return sum(values[:n])

def maximum_sum(values, n):
    if not values or not n:
        return 0
    values.sort()
    return sum(values[-n:])

# 2095. Delete the Middle Node of a Linked List
# You are given the head of a linked list. Delete the middle node, and return the head of the modified linked list.
#
# The middle node of a linked list of size n is the ⌊n / 2⌋th node from the start using 0-based indexing, where ⌊x⌋ denotes the largest integer less than or equal to x.
#
# For n = 1, 2, 3, 4, and 5, the middle nodes are 0, 1, 1, 2, and 2, respectively.
#
#
# Example 1:
#
#
# Input: head = [1,3,4,7,1,2,6]
# Output: [1,3,4,1,2,6]
# Explanation:
# The above figure represents the given linked list. The indices of the nodes are written below.
# Since n = 7, node 3 with value 7 is the middle node, which is marked in red.
# We return the new list after removing this node.
# Example 2:
#
#
# Input: head = [1,2,3,4]
# Output: [1,2,4]
# Explanation:
# The above figure represents the given linked list.
# For n = 4, node 2 with value 3 is the middle node, which is marked in red.
# Example 3:
#
#
# Input: head = [2,1]
# Output: [2]
# Explanation:
# The above figure represents the given linked list.
# For n = 2, node 1 with value 1 is the middle node, which is marked in red.
# Node 0 with value 2 is the only node remaining after removing node 1.
#
#
# Constraints:
#
# The number of nodes in the list is in the range [1, 105].
# 1 <= Node.val <= 105
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        tmp = head
        if not tmp.next:
            head = None
            return head
        slow, speed = tmp, tmp
        while speed and speed.next:
            slow = slow.next
            speed = speed.next.next
        tmp = head
        while tmp.next != slow:
            tmp = tmp.next
        tmp.next = slow.next
        return head

# Linked Lists - Insert Nth Node
# Linked Lists - Insert Nth
#
# Implement an InsertNth() function (insert_nth() in PHP) which can insert a new node at any index within a list.
#
# InsertNth() is a more general version of the Push() function that we implemented in the first kata listed below. Given a list, an index 'n' in the range 0..length, and a data element, add a new node to the list so that it has the given index. InsertNth() should return the head of the list.
#
# insertNth(1 -> 2 -> 3 -> null, 0, 7) === 7 -> 1 -> 2 -> 3 -> null)
# insertNth(1 -> 2 -> 3 -> null, 1, 7) === 1 -> 7 -> 2 -> 3 -> null)
# insertNth(1 -> 2 -> 3 -> null, 3, 7) === 1 -> 2 -> 3 -> 7 -> null)
# You must throw/raise an exception (ArgumentOutOfRangeException in C#, InvalidArgumentException in PHP) if the index is too large.
#
# The push() and buildOneTwoThree() (build_one_two_three() in PHP) functions do not need to be redefined. The Node class is also preloaded for you in PHP.
#
# Related Kata in order of expected completion (increasing difficulty):
#  Linked Lists - Push & BuildOneTwoThree
#  Linked Lists - Length & Count
#  Linked Lists - Get Nth Node
# Linked Lists - Insert Nth Node
# Linked Lists - Sorted Insert
# Linked Lists - Insert Sort
# Linked Lists - Append
# Linked Lists - Remove Duplicates
# Linked Lists - Move Node
# Linked Lists - Move Node In-place
# Linked Lists - Alternating Split
# Linked Lists - Front Back Split
# Linked Lists - Shuffle Merge
# Linked Lists - Sorted Merge
# Linked Lists - Merge Sort
# Linked Lists - Sorted Intersect
# Linked Lists - Iterative Reverse
# Linked Lists - Recursive Reverse
#
# Inspired by Stanford Professor Nick Parlante's excellent Linked List teachings.
#
# LINKED LISTSDATA STRUCTURESFUNDAMENTALS
class Node(object):
    def __init__(self, data):
        self.data = data
        self.next = None


def insert_nth(head, index, data):
    tmp = head
    if not tmp:
        head = Node(data)
        return head
    if index == 0:
        nxt = tmp
        head = Node(data)
        head.next = nxt
        return head
    for i in range(index - 1):
        tmp = tmp.next
    nxt = tmp.next
    tmp.next = Node(data)
    tmp.next.next = nxt
    return head

# 238. Product of Array Except Self
# Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].
#
# The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.
#
# You must write an algorithm that runs in O(n) time and without using the division operation.
#
#
#
# Example 1:
#
# Input: nums = [1,2,3,4]
# Output: [24,12,8,6]
# Example 2:
#
# Input: nums = [-1,1,0,-3,3]
# Output: [0,0,9,0,0]
#
#
# Constraints:
#
# 2 <= nums.length <= 105
# -30 <= nums[i] <= 30
# The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.
#
#
# Follow up: Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space for space complexity analysis.)
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        output: list = list()
        prev, post = 1, 1
        for i in nums:
            output.append(prev)
            prev *= i
        for i in range(len(nums) - 1, -1, -1):
            output[i] *= post
            post *= nums[i]
        return output
    
# Rotate an array matrix
# Write a function that rotates a two-dimensional array (a matrix) either clockwise or anti-clockwise by 90 degrees, and returns the rotated array.
#
# The function accepts two parameters: a matrix, and a string specifying the direction or rotation. The direction will be either "clockwise" or "counter-clockwise".
#
# Examples
# For matrix:
#
# [
#   [1, 2, 3],
#   [4, 5, 6],
#   [7, 8, 9]
# ]
# Clockwise rotation:
#
# [
#   [7, 4, 1],
#   [8, 5, 2],
#   [9, 6, 3]
# ]
# Counter-clockwise rotation:
#
# [
#   [3, 6, 9],
#   [2, 5, 8],
#   [1, 4, 7]
# ]
# MATRIXARRAYSALGORITHMS
def rotate(matrix, direction):
    mtrx: list = []
    if direction == 'clockwise':
        for column in range(len(matrix[0])):
            top: list = []
            for row in range(len(matrix) - 1, -1, -1):
                top.append(matrix[row][column])
            mtrx.append(top)
        return mtrx
    else:
        for column in range(len(matrix[0]) - 1, -1, -1):
            top: list = []
            for row in range(len(matrix)):
                top.append(matrix[row][column])
            mtrx.append(top)
        return mtrx
    
# 128. Longest Consecutive Sequence
# Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.
#
# You must write an algorithm that runs in O(n) time.
#
#
#
# Example 1:
#
# Input: nums = [100,4,200,1,3,2]
# Output: 4
# Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
# Example 2:
#
# Input: nums = [0,3,7,2,5,8,4,6,0,1]
# Output: 9
#
#
# Constraints:
#
# 0 <= nums.length <= 105
# -109 <= nums[i] <= 109
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        hs: set = set(nums)
        ans: int = 0
        for i in hs:
            if i - 1 not in hs:
                top: int = 0
                while i + top in hs:
                    top += 1
                ans = max(ans, top)
        return ans

# 169. Majority Element
# Given an array nums of size n, return the majority element.
#
# The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.
#
#
#
# Example 1:
#
# Input: nums = [3,2,3]
# Output: 3
# Example 2:
#
# Input: nums = [2,2,1,1,1,2,2]
# Output: 2
#
#
# Constraints:
#
# n == nums.length
# 1 <= n <= 5 * 104
# -109 <= nums[i] <= 109
#
#
# Follow-up: Could you solve the problem in linear time and in O(1) space?
# Solution O(N) O(N)
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        ht: dict = dict()
        n: int = len(nums) // 2
        for i in nums:
            ht[i] = ht.get(i, 0) + 1
            if ht[i] > n:
                return i
# Solution O(N) O(1)
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        count: int = 0
        ans: int = 0
        for i in nums:
            if count == 0:
                ans = i
            if i == ans:
                count += 1
            else:
                count -= 1
        return ans

# Wave Sorting
# A list of integers is sorted in “Wave” order if alternate items are not less than their immediate neighbors (thus the other alternate items are not greater than their immediate neighbors).
#
# Thus, the array [4, 1, 7, 5, 6, 2, 3] is in Wave order because 4 >= 1, then 1 <= 7, then 7 >= 5, then 5 <= 6, then 6 >= 2, and finally 2 <= 3.
#
# The wave-sorted lists has to begin with an element not less than the next, so [1, 4, 5, 3] is not sorted in Wave because 1 < 4
#
# Your task is to implement a function that takes a list of integers and sorts it into wave order in place; your function shouldn't return anything.
#
# Note:
#
# The resulting array shouldn't necessarily match anyone in the tests, a function just checks if the array is now wave sorted.
# ALGORITHMSARRAYSLOGICSORTING
def wave_sort(a):
    a.sort(reverse=True)
    n: int = len(a)
    n = n // 2 + 1 if n % 2 != 0 else n // 2
    ans: list = []
    left, right = 0, n
    while right < len(a):
        ans.append(a[left])
        ans.append(a[right])
        left, right = left + 1, right + 1
    if left != n:
        ans.append(a[left])
    for i in range(len(a)):
        a[i] = ans[i]

# 2108. Find First Palindromic String in the Array
# Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string "".
#
# A string is palindromic if it reads the same forward and backward.
#
#
#
# Example 1:
#
# Input: words = ["abc","car","ada","racecar","cool"]
# Output: "ada"
# Explanation: The first string that is palindromic is "ada".
# Note that "racecar" is also palindromic, but it is not the first.
# Example 2:
#
# Input: words = ["notapalindrome","racecar"]
# Output: "racecar"
# Explanation: The first and only string that is palindromic is "racecar".
# Example 3:
#
# Input: words = ["def","ghi"]
# Output: ""
# Explanation: There are no palindromic strings, so the empty string is returned.
#
#
# Constraints:
#
# 1 <= words.length <= 100
# 1 <= words[i].length <= 100
# words[i] consists only of lowercase English letters.
# Solution Two Pointers O(N) O(1)
class Solution:
    def firstPalindrome(self, words: List[str]) -> str:
        for i in words:
            left, right = 0, len(i) - 1
            flag: bool = True
            while left <= right:
                if i[left] != i[right]:
                    flag = not flag
                    break
                left += 1
                right -= 1
            if flag:
                return i
        return ''
# Solution Two Pointers One Liner O(N) O(1)
class Solution:
    def firstPalindrome(self, words: List[str]) -> str:
        return next((i for i in words if all(i[j] == i[-(j+1)] for j in range(len(i)))), '')
    
# Interleaving Arrays
# Create a function, that accepts an arbitrary number of arrays and returns a single array generated by alternately appending elements from the passed in arguments. If one of them is shorter than the others, the result should be padded with empty elements.
#
# Examples:
#
# interleave([1, 2, 3], ["c", "d", "e"]) == [1, "c", 2, "d", 3, "e"]
# interleave([1, 2, 3], [4, 5]) == [1, 4, 2, 5, 3, None]
# interleave([1, 2, 3], [4, 5, 6], [7, 8, 9]) == [1, 4, 7, 2, 5, 8, 3, 6, 9]
# interleave([]) == []
# ALGORITHMSARRAYS
def interleave(*args):
    ans: list = []
    flag: bool = True
    while flag:
        flag = False
        for i in args:
            if i:
                flag = True
                ans.append(i.pop(0))
            else:
                ans.append(None)
    return ans[:-len(args)]

# 2149. Rearrange Array Elements by Sign
# You are given a 0-indexed integer array nums of even length consisting of an equal number of positive and negative integers.
#
# You should rearrange the elements of nums such that the modified array follows the given conditions:
#
# Every consecutive pair of integers have opposite signs.
# For all integers with the same sign, the order in which they were present in nums is preserved.
# The rearranged array begins with a positive integer.
# Return the modified array after rearranging the elements to satisfy the aforementioned conditions.
#
#
#
# Example 1:
#
# Input: nums = [3,1,-2,-5,2,-4]
# Output: [3,-2,1,-5,2,-4]
# Explanation:
# The positive integers in nums are [3,1,2]. The negative integers are [-2,-5,-4].
# The only possible way to rearrange them such that they satisfy all conditions is [3,-2,1,-5,2,-4].
# Other ways such as [1,-2,2,-5,3,-4], [3,1,2,-2,-5,-4], [-2,3,-5,1,-4,2] are incorrect because they do not satisfy one or more conditions.
# Example 2:
#
# Input: nums = [-1,1]
# Output: [1,-1]
# Explanation:
# 1 is the only positive integer and -1 the only negative integer in nums.
# So nums is rearranged to [1,-1].
#
#
# Constraints:
#
# 2 <= nums.length <= 2 * 105
# nums.length is even
# 1 <= |nums[i]| <= 105
# nums consists of equal number of positive and negative integers.
# Solution Two Pointers O(N) O(N)
class Solution:
    def rearrangeArray(self, nums: List[int]) -> List[int]:
        n: int = len(nums)
        arr_int: list = [0] * n
        left, right = 0, n // 2
        for i in range(n):
            if nums[i] > 0:
                arr_int[left] = nums[i]
                left += 1
            else:
                arr_int[right] = nums[i]
                right += 1
        left, right = 0, n // 2
        for i in range(0, n, 2):
            nums[i] = arr_int[left]
            nums[i+1] = arr_int[right]
            left, right = left + 1, right + 1
        return nums

# Basics 06: Reversing and Combining Text
# Your task is to Reverse and Combine Words. It's not too difficult, but there are some things you have to consider...
#
# So what to do?
# Input: String containing different "words" separated by spaces
#
# 1. More than one word? Reverse each word and combine first with second, third with fourth and so on...
#    (odd number of words => last one stays alone, but has to be reversed too)
# 2. Start it again until there's only one word without spaces
# 3. Return your result...
# Some easy examples:
# Input:  "abc def"
# Output: "cbafed"
#
# Input:  "abc def ghi 123"
# Output: "defabc123ghi"
#
# Input:  "abc def gh34 434ff 55_eri 123 343"
# Output: "43hgff434cbafed343ire_55321"
# I think it's clear?! First there are some static tests, later on random tests too...
#
# Hope you have fun! :-)
# STRINGSARRAYSFUNDAMENTALS
def reverse_and_combine_text(text):
    ans: list = text.split()
    while len(ans) > 1:
        top: list = []
        for i in range(1, len(ans), 2):
            top.append(ans[i-1][::-1] + ans[i][::-1])
        if len(ans) % 2 != 0:
            top.append(ans[-1][::-1])
        ans = top
    return ''.join(ans)

# 2971. Find Polygon With the Largest Perimeter
# You are given an array of positive integers nums of length n.
#
# A polygon is a closed plane figure that has at least 3 sides. The longest side of a polygon is smaller than the sum of its other sides.
#
# Conversely, if you have k (k >= 3) positive real numbers a1, a2, a3, ..., ak where a1 <= a2 <= a3 <= ... <= ak and a1 + a2 + a3 + ... + ak-1 > ak, then there always exists a polygon with k sides whose lengths are a1, a2, a3, ..., ak.
#
# The perimeter of a polygon is the sum of lengths of its sides.
#
# Return the largest possible perimeter of a polygon whose sides can be formed from nums, or -1 if it is not possible to create a polygon.
#
#
#
# Example 1:
#
# Input: nums = [5,5,5]
# Output: 15
# Explanation: The only possible polygon that can be made from nums has 3 sides: 5, 5, and 5. The perimeter is 5 + 5 + 5 = 15.
# Example 2:
#
# Input: nums = [1,12,1,2,5,50,3]
# Output: 12
# Explanation: The polygon with the largest perimeter which can be made from nums has 5 sides: 1, 1, 2, 3, and 5. The perimeter is 1 + 1 + 2 + 3 + 5 = 12.
# We cannot have a polygon with either 12 or 50 as the longest side because it is not possible to include 2 or more smaller sides that have a greater sum than either of them.
# It can be shown that the largest possible perimeter is 12.
# Example 3:
#
# Input: nums = [5,5,50]
# Output: -1
# Explanation: There is no possible way to form a polygon from nums, as a polygon has at least 3 sides and 50 > 5 + 5.
#
#
# Constraints:
#
# 3 <= n <= 105
# 1 <= nums[i] <= 109
# Solution Greedy O(NlogN) O(1)
class Solution:
    def largestPerimeter(self, nums: List[int]) -> int:
        nums.sort()
        total: int = nums[0] + nums[1]
        ans: int = -1
        for i in range(2, len(nums)):
            if total > nums[i]:
                ans = total + nums[i]
            total += nums[i]
        return ans

# Vowels Back
# You need to play around with the provided string (s).
#
# Move consonants forward 9 places through the alphabet. If they pass 'z', start again at 'a'.
#
# Move vowels back 5 places through the alphabet. If they pass 'a', start again at 'z'. For our Polish friends this kata does not count 'y' as a vowel.
#
# Exceptions:
#
# If the character is 'c' or 'o', move it back 1 place. For 'd' move it back 3, and for 'e', move it back 4.
#
# If a moved letter becomes 'c', 'o', 'd' or 'e', revert it back to it's original value.
#
# Provided string will always be lower case, won't be empty and will have no special characters.
#
# FUNDAMENTALSSTRINGSARRAYSALGORITHMS
def vowel_back(st):
    eng_al: str = 'abcdefghijklmnopqrstuvwxyz'
    ans: str = ''
    for i in st:
        prev_x: str = i
        x: str = i
        if i in 'aeoiu':
            if x == 'e':
                idx: int = eng_al.index(x) - 4
                x = eng_al[idx]
                if x in 'code':
                    ans += prev_x
                else:
                    ans += x
            elif x == 'o':
                idx: int = eng_al.index(x) - 1
                x = eng_al[idx]
                if x in 'code':
                    ans += prev_x
                else:
                    ans += x
            else:
                idx: int = eng_al.index(x) - 5
                x = eng_al[idx]
                if x in 'code':
                    ans += prev_x
                else:
                    ans += x
        else:
            if x == 'c':
                idx: int = eng_al.index(x) - 1
                x = eng_al[idx]
                if x in 'code':
                    ans += prev_x
                else:
                    ans += x
            elif x == 'd':
                idx: int = eng_al.index(x) - 3
                x = eng_al[idx]
                if x in 'code':
                    ans += prev_x
                else:
                    ans += x
            else:
                idx: int = eng_al.index(x) + 9
                if idx > 25:
                    idx %= 26
                x = eng_al[idx]
                if x in 'code':
                    ans += prev_x
                else:
                    ans += x
    return ans

# 1290. Convert Binary Number in a Linked List to Integer
# Given head which is a reference node to a singly-linked list. The value of each node in the linked list is either 0 or 1. The linked list holds the binary representation of a number.
#
# Return the decimal value of the number in the linked list.
#
# The most significant bit is at the head of the linked list.
#
#
#
# Example 1:
#
#
# Input: head = [1,0,1]
# Output: 5
# Explanation: (101) in base 2 = (5) in base 10
# Example 2:
#
# Input: head = [0]
# Output: 0
#
#
# Constraints:
#
# The Linked List is not empty.
# Number of nodes will not exceed 30.
# Each node's value is either 0 or 1.
# Solution O(N) O(N)
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def getDecimalValue(self, head: ListNode) -> int:
        ans: str = ''
        while head:
            ans += str(head.val)
            head = head.next
        return int(ans, 2)
# Same O(N) O(N), but more pythonic(without string permutation in loop)
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def getDecimalValue(self, head: ListNode) -> int:
        ans: list = list()
        while head:
            ans.append(str(head.val))
            head = head.next
        return int(''.join(ans), 2)
    
# 1481. Least Number of Unique Integers after K Removals
# Given an array of integers arr and an integer k. Find the least number of unique integers after removing exactly k elements.
#
#
#
# Example 1:
#
# Input: arr = [5,5,4], k = 1
# Output: 1
# Explanation: Remove the single 4, only 5 is left.
# Example 2:
# Input: arr = [4,3,1,1,3,3,2], k = 3
# Output: 2
# Explanation: Remove 4, 2 and either one of the two 1s or three 3s. 1 and 3 will be left.
#
#
# Constraints:
#
# 1 <= arr.length <= 10^5
# 1 <= arr[i] <= 10^9
# 0 <= k <= arr.length
class Solution:
    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:
        ht: dict = dict()
        for i in arr:
            ht[i] = ht.get(i, 0) + 1
        intgrs: list = sorted(ht.keys(), key=lambda x: ht[x])
        for i in intgrs:
            if k >= ht[i]:
                k -= ht[i]
                del ht[i]
            else:
                ht[i] -= k
                break
            if k == 0:
                break
        return len(ht)
    
# Versions manager
# In this kata we are going to mimic a software versioning system.
#
# You have to implement a VersionManager class.
#
# It should accept an optional parameter that represents the initial version. The input will be in one of the following formats: "{MAJOR}", "{MAJOR}.{MINOR}", or "{MAJOR}.{MINOR}.{PATCH}". More values may be provided after PATCH but they should be ignored. If these 3 parts are not decimal values, an exception with the message "Error occured while parsing version!" should be thrown. If the initial version is not provided or is an empty string, use "0.0.1" by default.
#
# This class should support the following methods, all of which should be chainable (except release):
#
# major() - increase MAJOR by 1, set MINOR and PATCH to 0
# minor() - increase MINOR by 1, set PATCH to 0
# patch() - increase PATCH by 1
# rollback() - return the MAJOR, MINOR, and PATCH to their values before the previous major/minor/patch call, or throw an exception with the message "Cannot rollback!" if there's no version to roll back to. Multiple calls to rollback() should be possible and restore the version history
# release() - return a string in the format "{MAJOR}.{MINOR}.{PATCH}"
# May the binary force be with you!
#
# ALGORITHMSARRAYSSTRINGSOBJECT-ORIENTED PROGRAMMING
BACKUP = []
class VersionManager:
    def __init__(self, version='0.0.1'):
        vers: list = version.split('.')
        if vers == ['']:
            vers = '0.0.1'.split('.')
        for words in vers[:3]:
            for char in words:
                if char not in '01234567893.':
                    raise ValueError('Error occured while parsing version!')
        self.major_ = int(vers[0] if len(vers) >= 1 else '0')
        self.minor_ = int(vers[1] if len(vers) >= 2 else '0')
        self.patch_ = int(vers[2] if len(vers) >= 3 else '0')
        BACKUP.clear()
    def major(self):
        BACKUP.append(f"{self.major_}.{self.minor_}.{self.patch_}")
        self.major_ += 1
        self.minor_, self.patch_ = 0, 0
        return self
    def minor(self):
        BACKUP.append(f"{self.major_}.{self.minor_}.{self.patch_}")
        self.minor_ += 1
        self.patch_ = 0
        return self
    def patch(self):
        BACKUP.append(f"{self.major_}.{self.minor_}.{self.patch_}")
        self.patch_ += 1
        return self
    def rollback(self):
        if not BACKUP:
            raise ValueError('Cannot rollback!')
        self.major_, self.minor_, self.patch_ = [int(i) for i in BACKUP.pop().split('.')]
        return self
    def release(self):
        return f"{self.major_}.{self.minor_}.{self.patch_}"

# 705. Design HashSet
# Design a HashSet without using any built-in hash table libraries.
#
# Implement MyHashSet class:
#
# void add(key) Inserts the value key into the HashSet.
# bool contains(key) Returns whether the value key exists in the HashSet or not.
# void remove(key) Removes the value key in the HashSet. If key does not exist in the HashSet, do nothing.
#
#
# Example 1:
#
# Input
# ["MyHashSet", "add", "add", "contains", "contains", "add", "contains", "remove", "contains"]
# [[], [1], [2], [1], [3], [2], [2], [2], [2]]
# Output
# [null, null, null, true, false, null, true, null, false]
#
# Explanation
# MyHashSet myHashSet = new MyHashSet();
# myHashSet.add(1);      // set = [1]
# myHashSet.add(2);      // set = [1, 2]
# myHashSet.contains(1); // return True
# myHashSet.contains(3); // return False, (not found)
# myHashSet.add(2);      // set = [1, 2]
# myHashSet.contains(2); // return True
# myHashSet.remove(2);   // set = [1]
# myHashSet.contains(2); // return False, (already removed)
#
#
# Constraints:
#
# 0 <= key <= 106
# At most 104 calls will be made to add, remove, and contains.
class Node:
    def __init__(self, val, next=None):
        self.val = val
        self.next = next


class MyHashSet:

    def __init__(self):
        self.head = None

    def add(self, key: int) -> None:
        if self.contains(key):
            return
        if not self.head:
            self.head = Node(val=key)
            return
        tmp = self.head
        while tmp.next:
            tmp = tmp.next
        tmp.next = Node(val=key)
        return

    def remove(self, key: int) -> None:
        if not self.contains(key):
            return
        if not self.head.next:
            self.head = None
            return
        if self.head.val == key:
            self.head = self.head.next
            return
        tmp = self.head
        while tmp.val != key:
            tmp = tmp.next
        prev_tmp = self.head
        while prev_tmp.next.val != tmp.val:
            prev_tmp = prev_tmp.next
        prev_tmp.next = tmp.next

    def contains(self, key: int) -> bool:
        tmp = self.head
        while tmp:
            if tmp.val == key:
                return True
            tmp = tmp.next
        return False


# Your MyHashSet object will be instantiated and called as such:
# obj = MyHashSet()
# obj.add(key)
# obj.remove(key)
# param_3 = obj.contains(key)

# 1642. Furthest Building You Can Reach
# You are given an integer array heights representing the heights of buildings, some bricks, and some ladders.
#
# You start your journey from building 0 and move to the next building by possibly using bricks or ladders.
#
# While moving from building i to building i+1 (0-indexed),
#
# If the current building's height is greater than or equal to the next building's height, you do not need a ladder or bricks.
# If the current building's height is less than the next building's height, you can either use one ladder or (h[i+1] - h[i]) bricks.
# Return the furthest building index (0-indexed) you can reach if you use the given ladders and bricks optimally.
#
#
#
# Example 1:
#
#
# Input: heights = [4,2,7,6,9,14,12], bricks = 5, ladders = 1
# Output: 4
# Explanation: Starting at building 0, you can follow these steps:
# - Go to building 1 without using ladders nor bricks since 4 >= 2.
# - Go to building 2 using 5 bricks. You must use either bricks or ladders because 2 < 7.
# - Go to building 3 without using ladders nor bricks since 7 >= 6.
# - Go to building 4 using your only ladder. You must use either bricks or ladders because 6 < 9.
# It is impossible to go beyond building 4 because you do not have any more bricks or ladders.
# Example 2:
#
# Input: heights = [4,12,2,7,3,18,20,3,19], bricks = 10, ladders = 2
# Output: 7
# Example 3:
#
# Input: heights = [14,3,19,3], bricks = 17, ladders = 0
# Output: 3
#
#
# Constraints:
#
# 1 <= heights.length <= 105
# 1 <= heights[i] <= 106
# 0 <= bricks <= 109
# 0 <= ladders <= heights.length
class Solution:
    def furthestBuilding(self, heights: List[int], bricks: int, ladders: int) -> int:
        heap: list = list()
        for i in range(1, len(heights)):
            diff: int = heights[i] - heights[i-1]
            if diff > 0:
                heapq.heappush(heap, diff)
            if len(heap) > ladders:
                bricks -= heapq.heappop(heap)
            if bricks < 0:
                return i - 1
        return len(heights) - 1

# Separate The Wheat From The Chaff
# Scenario
# With Cereal crops like wheat or rice, before we can eat the grain kernel, we need to remove that inedible hull, or to separate the wheat from the chaff.
#
# Task
# Given a sequence of n integers , separate the negative numbers (chaff) from positive ones (wheat).!alt
#
# Notes
# Sequence size is at least 3
# Return a new sequence, such that negative numbers (chaff) come first, then positive ones (wheat).
# In Java , you're not allowed to modify the input Array/list/Vector
# Have no fear , it is guaranteed that there will be no zeroes .!alt
# Repetition of numbers in the input sequence could occur , so duplications are included when separating.
# If a misplaced positive number is found in the front part of the sequence, replace it with the last misplaced negative number (the one found near the end of the input). The second misplaced positive number should be swapped with the second last misplaced negative number. Negative numbers found at the head (begining) of the sequence , should be kept in place .
# Input >> Output Examples:
# wheatFromChaff ({7, -8, 1 ,-2}) ==> return ({-2, -8, 1, 7})
# Explanation:
# Since 7  is a positive number , it should not be located at the beginnig so it needs to be swapped with the last negative number -2.
# wheatFromChaff ({-31, -5, 11 , -42, -22, -46, -4, -28 }) ==> return ({-31, -5,- 28, -42, -22, -46 , -4, 11})
# Explanation:
# Since, {-31, -5}  are negative numbers found at the head (begining) of the sequence , so we keep them in place .
# Since 11 is a positive number, it's replaced by the last negative which is -28 , and so on till sepration is complete.
# wheatFromChaff ({-25, -48, -29, -25, 1, 49, -32, -19, -46, 1}) ==> return ({-25, -48, -29, -25, -46, -19, -32, 49, 1, 1})
# Explanation:
# Since {-25, -48, -29, -25}  are negative numbers found at the head (begining) of the input , so we keep them in place .
#
# Since 1 is a positive number, it's replaced by the last negative which is -46 , and so on till sepration is complete.
#
# Remeber, duplications are included when separating , that's why the number 1 appeared twice at the end of the output.
#
# Tune Your Code , There are 250 Assertions , 100.000 element For Each .
# Only O(N) Complexity Solutions Will pass .
# Playing with Numbers Series
# Playing With Lists/Arrays Series
# Bizarre Sorting-katas
# For More Enjoyable Katas
# ALL translations are welcome
# Enjoy Learning !!
# Zizou
# FUNDAMENTALSARRAYSPERFORMANCE
def wheat_from_chaff(values):
    n: int = len(values)
    left, right = 0, n - 1
    while left < right:
        while left < n and values[left] < 0:
            left += 1
        while right >= 0 and values[right] >= 0:
            right -= 1
        if left < right:
            values[left], values[right] = values[right], values[left]
        left, right = left + 1, right - 1
    return values

# 3. Longest Substring Without Repeating Characters
# Given a string s, find the length of the longest
# substring
#  without repeating characters.
#
#
#
# Example 1:
#
# Input: s = "abcabcbb"
# Output: 3
# Explanation: The answer is "abc", with the length of 3.
# Example 2:
#
# Input: s = "bbbbb"
# Output: 1
# Explanation: The answer is "b", with the length of 1.
# Example 3:
#
# Input: s = "pwwkew"
# Output: 3
# Explanation: The answer is "wke", with the length of 3.
# Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.
#
#
# Constraints:
#
# 0 <= s.length <= 5 * 104
# s consists of English letters, digits, symbols and spaces.
# Solution Initial solution O(N**2) O(N)
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        count: int = 0
        ht: dict = dict()
        for i in range(len(s)):
            for j in range(i, len(s)):
                if s[j] not in ht:
                    ht[s[j]] = 1
                else:
                    count = max(count, len(ht))
                    ht.clear()
                    break
        return count if not ht else max(len(ht), count)
# Solution HashTable and Sliding Window O(N) O(M)
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        ht: dict = dict()
        ans: int = 0
        left: int = 0
        for right in range(len(s)):
            if s[right] not in ht or ht[s[right]] < left:
                ans = max(ans, right - left + 1)
            else:
                left = ht[s[right]] + 1
            ht[s[right]] = right
        return ans

# 3024. Type of Triangle
# You are given a 0-indexed integer array nums of size 3 which can form the sides of a triangle.
#
# A triangle is called equilateral if it has all sides of equal length.
# A triangle is called isosceles if it has exactly two sides of equal length.
# A triangle is called scalene if all its sides are of different lengths.
# Return a string representing the type of triangle that can be formed or "none" if it cannot form a triangle.
#
#
#
# Example 1:
#
# Input: nums = [3,3,3]
# Output: "equilateral"
# Explanation: Since all the sides are of equal length, therefore, it will form an equilateral triangle.
# Example 2:
#
# Input: nums = [3,4,5]
# Output: "scalene"
# Explanation:
# nums[0] + nums[1] = 3 + 4 = 7, which is greater than nums[2] = 5.
# nums[0] + nums[2] = 3 + 5 = 8, which is greater than nums[1] = 4.
# nums[1] + nums[2] = 4 + 5 = 9, which is greater than nums[0] = 3.
# Since the sum of the two sides is greater than the third side for all three cases, therefore, it can form a triangle.
# As all the sides are of different lengths, it will form a scalene triangle.
#
#
# Constraints:
#
# nums.length == 3
# 1 <= nums[i] <= 100
# Solution O(1) O(1)
class Solution:
    def triangleType(self, nums: List[int]) -> str:
        nums.sort()
        a, b, c = nums[0], nums[1], nums[2]
        if a + b > c:
            if a == b == c:
                return 'equilateral'
            if a != b and a != c and b != c:
                return 'scalene'
            else:
                return 'isosceles'
        return 'none'

# 3028. Ant on the Boundary
# An ant is on a boundary. It sometimes goes left and sometimes right.
#
# You are given an array of non-zero integers nums. The ant starts reading nums from the first element of it to its end. At each step, it moves according to the value of the current element:
#
# If nums[i] < 0, it moves left by -nums[i] units.
# If nums[i] > 0, it moves right by nums[i] units.
# Return the number of times the ant returns to the boundary.
#
# Notes:
#
# There is an infinite space on both sides of the boundary.
# We check whether the ant is on the boundary only after it has moved |nums[i]| units. In other words, if the ant crosses the boundary during its movement, it does not count.
#
#
# Example 1:
#
# Input: nums = [2,3,-5]
# Output: 1
# Explanation: After the first step, the ant is 2 steps to the right of the boundary.
# After the second step, the ant is 5 steps to the right of the boundary.
# After the third step, the ant is on the boundary.
# So the answer is 1.
# Example 2:
#
# Input: nums = [3,2,-3,-4]
# Output: 0
# Explanation: After the first step, the ant is 3 steps to the right of the boundary.
# After the second step, the ant is 5 steps to the right of the boundary.
# After the third step, the ant is 2 steps to the right of the boundary.
# After the fourth step, the ant is 2 steps to the left of the boundary.
# The ant never returned to the boundary, so the answer is 0.
#
#
# Constraints:
#
# 1 <= nums.length <= 100
# -10 <= nums[i] <= 10
# nums[i] != 0
# Solution O(N) O(1)
class Solution:
    def returnToBoundaryCount(self, nums: List[int]) -> int:
        steps: int = 0
        count: int = 0
        for i in range(len(nums)):
            steps += nums[i]
            if steps == 0:
                count += 1
        return count

# 3033. Modify the Matrix
# Given a 0-indexed m x n integer matrix matrix, create a new 0-indexed matrix called answer. Make answer equal to matrix, then replace each element with the value -1 with the maximum element in its respective column.
#
# Return the matrix answer.
#
#
#
# Example 1:
#
#
# Input: matrix = [[1,2,-1],[4,-1,6],[7,8,9]]
# Output: [[1,2,9],[4,8,6],[7,8,9]]
# Explanation: The diagram above shows the elements that are changed (in blue).
# - We replace the value in the cell [1][1] with the maximum value in the column 1, that is 8.
# - We replace the value in the cell [0][2] with the maximum value in the column 2, that is 9.
# Example 2:
#
#
# Input: matrix = [[3,-1],[5,2]]
# Output: [[3,2],[5,2]]
# Explanation: The diagram above shows the elements that are changed (in blue).
#
#
# Constraints:
#
# m == matrix.length
# n == matrix[i].length
# 2 <= m, n <= 50
# -1 <= matrix[i][j] <= 100
# The input is generated such that each column contains at least one non-negative integer.
# Solution O(NM) (1)
class Solution:
    def modifiedMatrix(self, matrix: List[List[int]]) -> List[List[int]]:
        for columns in range(len(matrix[0])):
            mx: int = -1
            for rows in range(len(matrix)):
                mx = max(mx, matrix[rows][columns])
            for rows in range(len(matrix)):
                if matrix[rows][columns] == -1:
                    matrix[rows][columns] = mx
        return matrix

# 3034. Number of Subarrays That Match a Pattern I
# You are given a 0-indexed integer array nums of size n, and a 0-indexed integer array pattern of size m consisting of integers -1, 0, and 1.
#
# A
# subarray
#  nums[i..j] of size m + 1 is said to match the pattern if the following conditions hold for each element pattern[k]:
#
# nums[i + k + 1] > nums[i + k] if pattern[k] == 1.
# nums[i + k + 1] == nums[i + k] if pattern[k] == 0.
# nums[i + k + 1] < nums[i + k] if pattern[k] == -1.
# Return the count of subarrays in nums that match the pattern.
#
#
#
# Example 1:
#
# Input: nums = [1,2,3,4,5,6], pattern = [1,1]
# Output: 4
# Explanation: The pattern [1,1] indicates that we are looking for strictly increasing subarrays of size 3. In the array nums, the subarrays [1,2,3], [2,3,4], [3,4,5], and [4,5,6] match this pattern.
# Hence, there are 4 subarrays in nums that match the pattern.
# Example 2:
#
# Input: nums = [1,4,4,1,3,5,5,3], pattern = [1,0,-1]
# Output: 2
# Explanation: Here, the pattern [1,0,-1] indicates that we are looking for a sequence where the first number is smaller than the second, the second is equal to the third, and the third is greater than the fourth. In the array nums, the subarrays [1,4,4,1], and [3,5,5,3] match this pattern.
# Hence, there are 2 subarrays in nums that match the pattern.
#
#
# Constraints:
#
# 2 <= n == nums.length <= 100
# 1 <= nums[i] <= 109
# 1 <= m == pattern.length < n
# -1 <= pattern[i] <= 1
# Solution O(NM) O(1)
class Solution:
    def countMatchingSubarrays(self, nums: List[int], pattern: List[int]) -> int:
        count: int = 0
        m: int = len(pattern) + 1
        for i in range(len(nums) - (m - 1)):
            flag: bool = True
            for k in range(len(pattern)):
                if pattern[k] == 1:
                    flag = nums[i + k + 1] > nums[i + k]
                elif pattern[k] == 0:
                    flag = nums[i+k+1] == nums[i+k]
                elif pattern[k] == -1:
                    flag = nums[i+k+1] < nums[i+k]
                if not flag:
                    break
            if flag:
                count += 1
        return count

# 3038. Maximum Number of Operations With the Same Score I
# Given an array of integers called nums, you can perform the following operation while nums contains at least 2 elements:
#
# Choose the first two elements of nums and delete them.
# The score of the operation is the sum of the deleted elements.
#
# Your task is to find the maximum number of operations that can be performed, such that all operations have the same score.
#
# Return the maximum number of operations possible that satisfy the condition mentioned above.
#
#
#
# Example 1:
#
# Input: nums = [3,2,1,4,5]
# Output: 2
# Explanation: We perform the following operations:
# - Delete the first two elements, with score 3 + 2 = 5, nums = [1,4,5].
# - Delete the first two elements, with score 1 + 4 = 5, nums = [5].
# We are unable to perform any more operations as nums contain only 1 element.
# Example 2:
#
# Input: nums = [3,2,6,1,4]
# Output: 1
# Explanation: We perform the following operations:
# - Delete the first two elements, with score 3 + 2 = 5, nums = [6,1,4].
# We are unable to perform any more operations as the score of the next operation isn't the same as the previous one.
#
#
# Constraints:
#
# 2 <= nums.length <= 100
# 1 <= nums[i] <= 1000
class Solution:
    def maxOperations(self, nums: List[int]) -> int:
        score: int = nums[0] + nums[1]
        n: int = len(nums)
        count: int = 1
        for i in range(2, n-1, 2):
            if nums[i] + nums[i+1] != score:
                return count
            count += 1
        return count

# 3039. Apply Operations to Make String Empty
# You are given a string s.
#
# Consider performing the following operation until s becomes empty:
#
# For every alphabet character from 'a' to 'z', remove the first occurrence of that character in s (if it exists).
# For example, let initially s = "aabcbbca". We do the following operations:
#
# Remove the underlined characters s = "aabcbbca". The resulting string is s = "abbca".
# Remove the underlined characters s = "abbca". The resulting string is s = "ba".
# Remove the underlined characters s = "ba". The resulting string is s = "".
# Return the value of the string s right before applying the last operation. In the example above, answer is "ba".
#
#
#
# Example 1:
#
# Input: s = "aabcbbca"
# Output: "ba"
# Explanation: Explained in the statement.
# Example 2:
#
# Input: s = "abcd"
# Output: "abcd"
# Explanation: We do the following operation:
# - Remove the underlined characters s = "abcd". The resulting string is s = "".
# The string just before the last operation is "abcd".
#
#
# Constraints:
#
# 1 <= s.length <= 5 * 105
# s consists only of lowercase English letters.
# Initial solution O(NlogN) O(N)
class Solution:
    def lastNonEmptyString(self, s: str) -> str:
        eng_al: str = 'abcdefghijklmnopqrstuvwxyz'
        ht: dict = dict()
        for i in range(len(s)):
            if s[i] in ht:
                ht[s[i]] = [ht[s[i]][0] + 1, i]
            else:
                ht[s[i]] = [1, i]
        mx = max(ht, key=lambda x: ht[x][0])
        score = ht[mx][0]
        ans: list = [[mx, ht[mx][0], ht[mx][1]]]
        del ht[mx]
        for i in ht:
            if ht[i][0] == score:
                ans.append([i, ht[i][0], ht[i][1]])
        ans.sort(key=lambda x: x[2])
        return ''.join(i[0] for i in ans)
# Solution HashTable O(N) O(N)
class Solution:
    def lastNonEmptyString(self, s: str) -> str:
        ht: dict = dict()
        for i in s:
            ht[i] = ht.get(i, 0) + 1
        mx: int = max(ht.values())
        ans: list = list()
        for i in range(len(s) - 1, -1, -1):
            if ht[s[i]] == mx:
                ans.append(s[i])
                ht[s[i]] = -1
        return ''.join(ans[::-1])

# 3042. Count Prefix and Suffix Pairs I
# You are given a 0-indexed string array words.
#
# Let's define a boolean function isPrefixAndSuffix that takes two strings, str1 and str2:
#
# isPrefixAndSuffix(str1, str2) returns true if str1 is both a
# prefix
#  and a
# suffix
#  of str2, and false otherwise.
# For example, isPrefixAndSuffix("aba", "ababa") is true because "aba" is a prefix of "ababa" and also a suffix, but isPrefixAndSuffix("abc", "abcd") is false.
#
# Return an integer denoting the number of index pairs (i, j) such that i < j, and isPrefixAndSuffix(words[i], words[j]) is true.
#
#
#
# Example 1:
#
# Input: words = ["a","aba","ababa","aa"]
# Output: 4
# Explanation: In this example, the counted index pairs are:
# i = 0 and j = 1 because isPrefixAndSuffix("a", "aba") is true.
# i = 0 and j = 2 because isPrefixAndSuffix("a", "ababa") is true.
# i = 0 and j = 3 because isPrefixAndSuffix("a", "aa") is true.
# i = 1 and j = 2 because isPrefixAndSuffix("aba", "ababa") is true.
# Therefore, the answer is 4.
# Example 2:
#
# Input: words = ["pa","papa","ma","mama"]
# Output: 2
# Explanation: In this example, the counted index pairs are:
# i = 0 and j = 1 because isPrefixAndSuffix("pa", "papa") is true.
# i = 2 and j = 3 because isPrefixAndSuffix("ma", "mama") is true.
# Therefore, the answer is 2.
# Example 3:
#
# Input: words = ["abab","ab"]
# Output: 0
# Explanation: In this example, the only valid index pair is i = 0 and j = 1, and isPrefixAndSuffix("abab", "ab") is false.
# Therefore, the answer is 0.
#
#
# Constraints:
#
# 1 <= words.length <= 50
# 1 <= words[i].length <= 10
# words[i] consists only of lowercase English letters.
# Solution O(N**2) O(1)
class Solution:
    def countPrefixSuffixPairs(self, words: List[str]) -> int:
        count: int = 0
        for i in range(len(words)):
            for j in range(i + 1, len(words)):
                if words[j].startswith(words[i]) and words[j].endswith(words[i]):
                    count += 1
        return count

# High score table
# You just got done writing a function that calculates the player's final score for your new game, "Flight of the cockatoo".
#
# Now all you need is a high score table that can be updated with the player's final scores. With such a feature, the player will be motivated to try to beat his previous scores, and hopefully, never stop playing your game.
#
# The high score table will start out empty. A limit to the size of the table will be specified upon creation of the table.
#
# Here's an example of the expected behavior of the high score table :
#
# highScoreTable = HighScoreTable(3)
# highScoreTable.scores == [] # evaluates to True
# highScoreTable.update(10)
# highScoreTable.scores == [10]
# highScoreTable.update(8)
# highScoreTable.update(12)
# highScoreTable.update(5)
# highScoreTable.update(10)
# highScoreTable.scores == [12, 10, 10]
# highScoreTable.reset()
# highScoreTable.scores == []
# # And so on...
# ALGORITHMSSORTINGSEARCHINGARRAYSOBJECT-ORIENTED PROGRAMMING
class HighScoreTable:

    def __init__(self, capacity):
        self.scores: list = list()
        self.capacity: int = capacity
        self.size: int = 0

    def update(self, val):
        if self.size > 0 and self.size == self.capacity:
            if min(self.scores) < val:
                self.scores.remove(min(self.scores))
                self.scores.append(val)
        if self.size < self.capacity:
            self.scores.append(val)
            self.size += 1
        self.scores.sort(reverse=True)

    def reset(self):
        self.scores.clear()
        self.size = 0

# 231. Power of Two
# Given an integer n, return true if it is a power of two. Otherwise, return false.
#
# An integer n is a power of two, if there exists an integer x such that n == 2x.
#
#
#
# Example 1:
#
# Input: n = 1
# Output: true
# Explanation: 20 = 1
# Example 2:
#
# Input: n = 16
# Output: true
# Explanation: 24 = 16
# Example 3:
#
# Input: n = 3
# Output: false
#
#
# Constraints:
#
# -231 <= n <= 231 - 1
#
#
# Follow up: Could you solve it without loops/recursion?
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return n & (n - 1) == 0 if n != 0 else False

# Perform operation to make string empty
# You are given a string "strng"
#
# Perform the following operation until "strng" becomes empty:
#
# For every alphabet character from 'a' to 'z', remove the first occurrence of that character in "strng" (if it exists).
# Example, let initially strng = "aabcbbca". We do the following operations:
#
# Remove the underlined characters strng = "(a)a(b)(c)bbca". The resulting string is strng = "abbca".
#
# Remove the underlined characters strng = "(a)(b)b(c)a". The resulting string is strng = "ba".
#
# Remove the underlined characters strng = "(b)(a)". The resulting string is strng = "".
#
# Return the value of the string strng right before applying the last operation. In the example above, answer is "ba".
# You can assume on next:
#
# strng will never be empty
#
# strng.length <= 5 * 10**5
#
# strng will contains only of lowercase English letters.
# ALGORITHMSLOGICPUZZLESFUNDAMENTALSSTRINGSPERFORMANCE
def last_non_empty_string(strng: str) -> str:
    ht: dict = dict()
    for i in strng:
        ht[i] = ht.get(i, 0) + 1
    mx: int = max(ht.values())
    ans: list = list()
    for i in range(len(strng) - 1, -1, -1):
        if ht[strng[i]] == mx:
            ans.append(strng[i])
            ht[strng[i]] = -1
    return ''.join(ans[::-1])
    
# Elimination Tournament
# In this Kata you will be given an array (or another language-appropriate collection) representing contestant ranks. You must eliminate contestant in series of rounds comparing consecutive pairs of ranks and store all initial and intermediate results in an array.
#
# During one round, the lowest rank of a pair is eliminated while the highest proceeds to the next round. This goes on until one contestant only is left. If the number of contestants is odd, the last one of the current array becomes the first of the next round.
#
# At the end of the competition, return the results of all the rounds in the form of array of arrays.
#
# Example:
# input = [9, 5, 4, 7, 6, 3, 8, 2];
#
# output = [
#   [9, 5, 4, 7, 6, 3, 8, 2],  // first round is initial input
#   [9, 7, 6, 8],              // results of 9 vs 5, 4 vs 7, 6 vs 3, and 8 vs 2
#   [9, 8],                    // results of 9 vs 7 and 6 vs 8
#   [9]                        // results of 9 vs 8
# ];
# Notes:
#
# Array length will alway be >= 2 and <= 100
# Elements of the array will always be >=1 and <= 100
# Input must not be altered.
# ARRAYSFUNDAMENTALSALGORITHMS
# Solution
def tourney(inp):
    ans: list = [inp]
    while len(inp) > 1:
        top: list = list()
        if len(inp) % 2 == 0:
            top = [max(inp[i], inp[i+1]) for i in range(0, len(inp), 2)]
        else:
            top = [inp[-1]] + [max(inp[i-1], inp[i]) for i in range(1, len(inp), 2)]
        ans.append(top)
        inp = top
    return ans

# 268. Missing Number
# Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.
#
#
#
# Example 1:
#
# Input: nums = [3,0,1]
# Output: 2
# Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.
# Example 2:
#
# Input: nums = [0,1]
# Output: 2
# Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.
# Example 3:
#
# Input: nums = [9,6,4,2,3,5,7,0,1]
# Output: 8
# Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.
#
#
# Constraints:
#
# n == nums.length
# 1 <= n <= 104
# 0 <= nums[i] <= n
# All the numbers of nums are unique.
#
#
# Follow up: Could you implement a solution using only O(1) extra space complexity and O(n) runtime complexity?
# Solution Math O(N) O(1)
class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        total: int = len(nums) * (len(nums) + 1) // 2
        for i in nums:
            total -= i
        return total
    
# X marks the spot!
# Write a function x(n) that takes in a number n and returns an nxn array with an X in the middle. The X will be represented by 1's and the rest will be 0's.
# E.g.
#
# x(5) ==  [[1, 0, 0, 0, 1],
#           [0, 1, 0, 1, 0],
#           [0, 0, 1, 0, 0],
#           [0, 1, 0, 1, 0],
#           [1, 0, 0, 0, 1]];
#
# x(6) ==  [[1, 0, 0, 0, 0, 1],
#           [0, 1, 0, 0, 1, 0],
#           [0, 0, 1, 1, 0, 0],
#           [0, 0, 1, 1, 0, 0],
#           [0, 1, 0, 0, 1, 0],
#           [1, 0, 0, 0, 0, 1]];
# ARRAYSALGORITHMS
def x(n):
    mtrx: list = [[0 for i in range(n)] for j in range(n)]
    for i in range(n):
        mtrx[i][i], mtrx[i][-i-1] = 1, 1
    return mtrx

# 201. Bitwise AND of Numbers Range
# Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.
#
#
#
# Example 1:
#
# Input: left = 5, right = 7
# Output: 4
# Example 2:
#
# Input: left = 0, right = 0
# Output: 0
# Example 3:
#
# Input: left = 1, right = 2147483647
# Output: 0
#
#
# Constraints:
#
# 0 <= left <= right <= 231 - 1
class Solution:
    def rangeBitwiseAnd(self, left: int, right: int) -> int:
        ans: int = 0
        while left != right:
            right >>= 1
            left >>= 1
            ans += 1
        return right << ans

# Points On A Line
# Given some points (cartesian coordinates), return true if all of them lie on a line. Treat both an empty set and a single point as a line.
#
# on_line(((1,2), (7,4), (22,9)) == True
# on_line(((1,2), (-3,-14), (22,9))) == False
# ARRAYSGEOMETRYFUNDAMENTALS
def on_line(p1):
    if len(p1) < 3:
        return True
    step = None
    for i in range(1, len(p1)):
        x: int = p1[i-1][0] - p1[i][0]
        y: int = p1[i-1][1] - p1[i][1]
        if y == 0:
            top: int = 0
        else:
            top: int = x / y
        if not step:
            step = top
        else:
            if top != step:
                return False
    return True

# 997. Find the Town Judge
# In a town, there are n people labeled from 1 to n. There is a rumor that one of these people is secretly the town judge.
#
# If the town judge exists, then:
#
# The town judge trusts nobody.
# Everybody (except for the town judge) trusts the town judge.
# There is exactly one person that satisfies properties 1 and 2.
# You are given an array trust where trust[i] = [ai, bi] representing that the person labeled ai trusts the person labeled bi. If a trust relationship does not exist in trust array, then such a trust relationship does not exist.
#
# Return the label of the town judge if the town judge exists and can be identified, or return -1 otherwise.
#
#
#
# Example 1:
#
# Input: n = 2, trust = [[1,2]]
# Output: 2
# Example 2:
#
# Input: n = 3, trust = [[1,3],[2,3]]
# Output: 3
# Example 3:
#
# Input: n = 3, trust = [[1,3],[2,3],[3,1]]
# Output: -1
#
#
# Constraints:
#
# 1 <= n <= 1000
# 0 <= trust.length <= 104
# trust[i].length == 2
# All the pairs of trust are unique.
# ai != bi
# 1 <= ai, bi <= n
class Solution:
    def findJudge(self, n: int, trust: List[List[int]]) -> int:
        lngth: int = n
        trusted, voted = [0 for i in range(lngth)], [0 for i in range(lngth)]
        for i in trust:
            trusted[i[1]-1] += 1
            voted[i[0]-1] += 1
        for i in range(lngth):
            if trusted[i] == lngth - 1 and voted[i] == 0:
                return i + 1
        return -1

# Will the present fit?
# Santa's elves are boxing presents, and they need your help! Write a function that takes two sequences of dimensions of the present and the box, respectively, and returns a Boolean based on whether or not the present will fit in the box provided. The box's walls are one unit thick, so be sure to take that in to account.
#
# Examples: Present and box respectively
#
# [10, 7, 16], [13, 32, 10] --> true, box is bigger than present
# [5, 7, 9], [9, 5, 7]      --> false, present and box are same size
# [17, 22, 10], [5, 5, 10]) --> false, box is too small
# ARRAYSALGORITHMS
def will_fit(present, box): 
    present = sorted(present)
    box = sorted(box)
    return all(x < y - 1 for x, y in zip(present, box))

# 2807. Insert Greatest Common Divisors in Linked List
# Given the head of a linked list head, in which each node contains an integer value.
#
# Between every pair of adjacent nodes, insert a new node with a value equal to the greatest common divisor of them.
#
# Return the linked list after insertion.
#
# The greatest common divisor of two numbers is the largest positive integer that evenly divides both numbers.
#
#
#
# Example 1:
#
#
# Input: head = [18,6,10,3]
# Output: [18,6,6,2,10,1,3]
# Explanation: The 1st diagram denotes the initial linked list and the 2nd diagram denotes the linked list after inserting the new nodes (nodes in blue are the inserted nodes).
# - We insert the greatest common divisor of 18 and 6 = 6 between the 1st and the 2nd nodes.
# - We insert the greatest common divisor of 6 and 10 = 2 between the 2nd and the 3rd nodes.
# - We insert the greatest common divisor of 10 and 3 = 1 between the 3rd and the 4th nodes.
# There are no more adjacent nodes, so we return the linked list.
# Example 2:
#
#
# Input: head = [7]
# Output: [7]
# Explanation: The 1st diagram denotes the initial linked list and the 2nd diagram denotes the linked list after inserting the new nodes.
# There are no pairs of adjacent nodes, so we return the initial linked list.
#
#
# Constraints:
#
# The number of nodes in the list is in the range [1, 5000].
# 1 <= Node.val <= 1000
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def insertGreatestCommonDivisors(self, head: Optional[ListNode]) -> Optional[ListNode]:
        def lcd(x: int, y: int) -> int:
            mul: int = 1
            x, y = max(x, y), min(x, y)
            while x * mul % y != 0:
                mul += 1
            return x * mul
        def gcd(x: int, y: int) -> int:
            return x * y // lcd(x, y)
        tmp = head
        while tmp.next:
            tmp.next = ListNode(val=gcd(tmp.val, tmp.next.val), next=tmp.next)
            tmp = tmp.next.next
        return head

# Which filetypes are you using the most?
# Description
# You've been working with a lot of different file types recently as your interests have broadened.
#
# But what file types are you using the most? With this question in mind we look at the following problem.
#
# Given a List/Array of Filenames (strings) files return a List/Array of string(s) containing the most common extension(s). If there is a tie, return a sorted list of all extensions.
#
# Important Info:
# Don't forget, you've been working with a lot of different file types, so expect some interesting extensions/file names/lengths in the random tests.
# Filenames and extensions will only contain letters (case sensitive), and numbers.
# If a file has multiple extensions (ie: mysong.mp3.als) only count the last extension (.als in this case)
# Examples
# files = ['Lakey - Better days.mp3',
#          'Wheathan - Superlove.wav',
#          'groovy jam.als',
#          '#4 final mixdown.als',
#          'album cover.ps',
#          'good nights.mp3']
# would return: ['.als', '.mp3'], as both of the extensions appear two times in files.
#
# files = ['Lakey - Better days.mp3',
#          'Fisher - Stop it.mp3',
#          'Fisher - Losing it.mp3',
#          '#4 final mixdown.als',
#          'album cover.ps',
#          'good nights.mp3']
# would return ['.mp3'], because it appears more times then any other extension, and no other extension has an equal amount of appearences.
#
# FUNDAMENTALSALGORITHMSSTRINGSARRAYS
def solve(files):
    ht: dict = dict()
    for i in files:
        indx: int = -1
        while i[indx] != '.':
            indx -= 1
        x: str = i[indx:]
        ht[x] = ht.get(x, 0) + 1
    mx = None
    for i in ht:
        if not mx:
            mx = i
        elif ht[i] > ht[mx]:
            mx = i
    ans: list = list()
    for i in ht:
        if ht[i] == ht[mx]:
            ans.append(i)
    ans.sort()
    return ans

# Update inventory in your smartphone store
# You will be given an array which lists the current inventory of stock in your store and another array which lists the new inventory being delivered to your store today.
#
# Your task is to write a function that returns the updated list of your current inventory in alphabetical order.
#
# Example
# cur_stock = [(25, 'HTC'), (1000, 'Nokia'), (50, 'Samsung'), (33, 'Sony'), (10, 'Apple')]
# new_stock = [(5, 'LG'), (10, 'Sony'), (4, 'Samsung'), (5, 'Apple')]
#
# update_inventory(cur_stock, new_stock)  ==>
# [(15, 'Apple'), (25, 'HTC'), (5, 'LG'), (1000, 'Nokia'), (54, 'Samsung'), (43, 'Sony')]
# Kata inspired by the FreeCodeCamp's 'Inventory Update' algorithm.
#
# ALGORITHMSDATA STRUCTURESARRAYS
def update_inventory(cur_stock, new_stock):
    ht: dict = dict()
    for i in cur_stock:
        ht[i[1]] = ht.get(i[1], 0) + i[0]
    for i in new_stock:
        ht[i[1]] = ht.get(i[1], 0) + i[0]
    ans: list = [(v, k)  for k, v in ht.items()]
    ans.sort(key=lambda x: x[1])
    return ans

# 2798. Number of Employees Who Met the Target
# There are n employees in a company, numbered from 0 to n - 1. Each employee i has worked for hours[i] hours in the company.
#
# The company requires each employee to work for at least target hours.
#
# You are given a 0-indexed array of non-negative integers hours of length n and a non-negative integer target.
#
# Return the integer denoting the number of employees who worked at least target hours.
#
#
#
# Example 1:
#
# Input: hours = [0,1,2,3,4], target = 2
# Output: 3
# Explanation: The company wants each employee to work for at least 2 hours.
# - Employee 0 worked for 0 hours and didn't meet the target.
# - Employee 1 worked for 1 hours and didn't meet the target.
# - Employee 2 worked for 2 hours and met the target.
# - Employee 3 worked for 3 hours and met the target.
# - Employee 4 worked for 4 hours and met the target.
# There are 3 employees who met the target.
# Example 2:
#
# Input: hours = [5,1,4,2,2], target = 6
# Output: 0
# Explanation: The company wants each employee to work for at least 6 hours.
# There are 0 employees who met the target.
#
#
# Constraints:
#
# 1 <= n == hours.length <= 50
# 0 <= hours[i], target <= 105
# Solution OnePass O(N) O(1)
class Solution:
    def numberOfEmployeesWhoMetTarget(self, hours: List[int], target: int) -> int:
        count: int = 0
        for i in range(len(hours)):
            if hours[i] >= target:
                count += 1
        return count
# Solution OnePass OneLiner O(N) O(1)
class Solution:
    def numberOfEmployeesWhoMetTarget(self, hours: List[int], target: int) -> int:
        return sum(i >= target for i in hours)

# Create Four Letter Birding Codes from Bird Names
# In the world of birding there are four-letter codes for the common names of birds. These codes are created by some simple rules:
#
# If the bird's name has only one word, the code takes the first four letters of that word.
# If the name is made up of two words, the code takes the first two letters of each word.
# If the name is made up of three words, the code is created by taking the first letter from the first two words and the first two letters from the third word.
# If the name is four words long, the code uses the first letter from all the words.
# (There are other ways that codes are created, but this Kata will only use the four rules listed above)
#
# Complete the function that takes an array of strings of common bird names from North America, and create the codes for those names based on the rules above. The function should return an array of the codes in the same order in which the input names were presented.
#
# Additional considertations:
#
# The four-letter codes in the returned array should be in UPPER CASE.
# If a common name has a hyphen/dash, it should be considered a space.
# Example
# If the input array is: ["Black-Capped Chickadee", "Common Tern"]
#
# The return array would be: ["BCCH", "COTE"]
#
# ARRAYSREGULAR EXPRESSIONSSTRINGSFUNDAMENTALS
def bird_code(arr):
    ans: list = list()
    for word in arr:
        names: list = list()
        top: str = ''
        for char in word:
            if not char.isalpha() and char not in "'":
                names.append(top)
                top = ''
            else:
                top += char
        if top:
            names.append(top)
        if len(names) == 1:
            ans.append(names[0][:4].upper())
        elif len(names) == 2:
            ans.append(names[0][:2].upper() + names[1][:2].upper())
        elif len(names) == 3:
            ans.append(names[0][0].upper() + names[1][0].upper() + names[2][:2].upper())
        else:
            ans.append(''.join(i[0].upper() for i in names))
    return ans

# 2396. Strictly Palindromic Number
# An integer n is strictly palindromic if, for every base b between 2 and n - 2 (inclusive), the string representation of the integer n in base b is palindromic.
#
# Given an integer n, return true if n is strictly palindromic and false otherwise.
#
# A string is palindromic if it reads the same forward and backward.
#
#
#
# Example 1:
#
# Input: n = 9
# Output: false
# Explanation: In base 2: 9 = 1001 (base 2), which is palindromic.
# In base 3: 9 = 100 (base 3), which is not palindromic.
# Therefore, 9 is not strictly palindromic so we return false.
# Note that in bases 4, 5, 6, and 7, n = 9 is also not palindromic.
# Example 2:
#
# Input: n = 4
# Output: false
# Explanation: We only consider base 2: 4 = 100 (base 2), which is not palindromic.
# Therefore, we return false.
#
#
#
# Constraints:
#
# 4 <= n <= 105
class Solution:
    def isStrictlyPalindromic(self, n: int) -> bool:
        def is_palindrome(arr: list) -> bool:
            left, right = 0, len(arr) - 1
            while left < right:
                if arr[left] != arr[right]:
                    return False
                left, right = left + 1, right - 1
            return True
        def num_to_base(num: int, base: int) -> list:
            if num == 0:
                return [0]
            ans: list = list()
            while num:
                ans.append(num % base)
                num //= base
            return ans[::-1]
        for base in range(2, n - 1):
            if not is_palindrome(num_to_base(n, base)):
                return False
        return True
    
# uniq -c (UNIX style)
# Implement a function which behaves like the 'uniq -c' command in UNIX.
#
# It takes as input a sequence and returns a sequence in which all duplicate elements following each other have been reduced to one instance together with the number of times a duplicate elements occurred in the original array.
#
# Example:
# ['a','a','b','b','c','a','b','c'] --> [('a',2),('b',2),('c',1),('a',1),('b',1),('c',1)]
# ARRAYSALGORITHMS
def uniq_c(seq):
    ans: list = list()
    count: int = 0
    start: bool = True
    object = None
    for i in seq:
        if start:
            start = False
            object = i
            count += 1
        elif i != object:
            ans.append((object, count))
            object, count = i, 1
        else:
            count += 1
    if not start:
        ans.append((object, count))
    return ans

# 155. Min Stack
# Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.
#
# Implement the MinStack class:
#
# MinStack() initializes the stack object.
# void push(int val) pushes the element val onto the stack.
# void pop() removes the element on the top of the stack.
# int top() gets the top element of the stack.
# int getMin() retrieves the minimum element in the stack.
# You must implement a solution with O(1) time complexity for each function.
#
#
#
# Example 1:
#
# Input
# ["MinStack","push","push","push","getMin","pop","top","getMin"]
# [[],[-2],[0],[-3],[],[],[],[]]
#
# Output
# [null,null,null,null,-3,null,0,-2]
#
# Explanation
# MinStack minStack = new MinStack();
# minStack.push(-2);
# minStack.push(0);
# minStack.push(-3);
# minStack.getMin(); // return -3
# minStack.pop();
# minStack.top();    // return 0
# minStack.getMin(); // return -2
#
#
# Constraints:
#
# -231 <= val <= 231 - 1
# Methods pop, top and getMin operations will always be called on non-empty stacks.
# At most 3 * 104 calls will be made to push, pop, top, and getMin.
# Complexity
# Time complexity: All opertaions is O(1), but technically .pop() can made up to O(N) when we delete min element in a stack
#
# Space complexity: O(N)
#
# Code
class MinStack:

    def __init__(self):
        self.stack: list = list()
        self.mn_val: int = float('inf')

    def push(self, val: int) -> None:
        self.stack.append(val)
        self.mn_val = min(val, self.mn_val)

    def pop(self) -> None:
        x: int = self.stack.pop()
        if x == self.mn_val:
            self.mn_val = float('inf')
            for i in self.stack:
                self.mn_val = min(self.mn_val, i)

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.mn_val


# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(val)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.getMin()
# Complexity
# Time complexity: All opertaions is O(1)
#
# Space complexity: O(N), but in solution above we use 2x small memory space
#
# Code
class MinStack:

    def __init__(self):
        self.stack: list = list()

    def push(self, val: int) -> None:
        if not self.stack:
            self.stack.append((val, val))
        else:
            self.stack.append((val, min(val, self.stack[-1][-1])))

    def pop(self) -> None:
        self.stack.pop()

    def top(self) -> int:
        return self.stack[-1][0]

    def getMin(self) -> int:
        return self.stack[-1][-1]

# 2824. Count Pairs Whose Sum is Less than Target
# Given a 0-indexed integer array nums of length n and an integer target, return the number of pairs (i, j) where 0 <= i < j < n and nums[i] + nums[j] < target.
#
#
# Example 1:
#
# Input: nums = [-1,1,2,3,1], target = 2
# Output: 3
# Explanation: There are 3 pairs of indices that satisfy the conditions in the statement:
# - (0, 1) since 0 < 1 and nums[0] + nums[1] = 0 < target
# - (0, 2) since 0 < 2 and nums[0] + nums[2] = 1 < target
# - (0, 4) since 0 < 4 and nums[0] + nums[4] = 0 < target
# Note that (0, 3) is not counted since nums[0] + nums[3] is not strictly less than the target.
# Example 2:
#
# Input: nums = [-6,2,5,-2,-7,-1,3], target = -2
# Output: 10
# Explanation: There are 10 pairs of indices that satisfy the conditions in the statement:
# - (0, 1) since 0 < 1 and nums[0] + nums[1] = -4 < target
# - (0, 3) since 0 < 3 and nums[0] + nums[3] = -8 < target
# - (0, 4) since 0 < 4 and nums[0] + nums[4] = -13 < target
# - (0, 5) since 0 < 5 and nums[0] + nums[5] = -7 < target
# - (0, 6) since 0 < 6 and nums[0] + nums[6] = -3 < target
# - (1, 4) since 1 < 4 and nums[1] + nums[4] = -5 < target
# - (3, 4) since 3 < 4 and nums[3] + nums[4] = -9 < target
# - (3, 5) since 3 < 5 and nums[3] + nums[5] = -3 < target
# - (4, 5) since 4 < 5 and nums[4] + nums[5] = -8 < target
# - (4, 6) since 4 < 6 and nums[4] + nums[6] = -4 < target
#
#
# Constraints:
#
# 1 <= nums.length == n <= 50
# -50 <= nums[i], target <= 50
# Solution BruteForce O(N**2) O(1)
class Solution:
    def countPairs(self, nums: List[int], target: int) -> int:
        count: int = 0
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                if nums[i] + nums[j] < target:
                    count += 1
        return count
# Solution Two Pointers O(NlogN) O(1)
class Solution:
    def countPairs(self, nums: List[int], target: int) -> int:
        nums.sort()
        count: int = 0
        left, right = 0, len(nums) - 1
        while left < right:
            if nums[left] + nums[right] < target:
                count += right - left
                left += 1
            else:
                right -= 1
        return count

# Millipede of words
# The set of words is given. Words are joined if the last letter of one word and the first letter of another word are the same. Return true if all words of the set can be combined into one word. Each word can and must be used only once. Otherwise return false.
#
# Input
# List of 3 to 7 words of random length. No capital letters.
#
# Example true
# Set: excavate, endure, desire, screen, theater, excess, night.
# Millipede: desirE EndurE ExcavatE ExcesS ScreeN NighT Theater.
#
# Example false
# Set: trade, pole, view, grave, ladder, mushroom, president.
# Millipede: presidenT Trade.
#
# ALGORITHMSARRAYSSTRINGS
from itertools import pairwise, permutations
def solution(arr):
    for i in permutations(arr, len(arr)):
        if all(x[-1] == y[0] for x, y in pairwise(i)):
            return True
    return False

# 2913. Subarrays Distinct Element Sum of Squares I
# You are given a 0-indexed integer array nums.
#
# The distinct count of a subarray of nums is defined as:
#
# Let nums[i..j] be a subarray of nums consisting of all the indices from i to j such that 0 <= i <= j < nums.length. Then the number of distinct values in nums[i..j] is called the distinct count of nums[i..j].
# Return the sum of the squares of distinct counts of all subarrays of nums.
#
# A subarray is a contiguous non-empty sequence of elements within an array.
#
#
#
# Example 1:
#
# Input: nums = [1,2,1]
# Output: 15
# Explanation: Six possible subarrays are:
# [1]: 1 distinct value
# [2]: 1 distinct value
# [1]: 1 distinct value
# [1,2]: 2 distinct values
# [2,1]: 2 distinct values
# [1,2,1]: 2 distinct values
# The sum of the squares of the distinct counts in all subarrays is equal to 12 + 12 + 12 + 22 + 22 + 22 = 15.
# Example 2:
#
# Input: nums = [1,1]
# Output: 3
# Explanation: Three possible subarrays are:
# [1]: 1 distinct value
# [1]: 1 distinct value
# [1,1]: 1 distinct value
# The sum of the squares of the distinct counts in all subarrays is equal to 12 + 12 + 12 = 3.
#
#
# Constraints:
#
# 1 <= nums.length <= 100
# 1 <= nums[i] <= 100
class Solution:
    def sumCounts(self, nums: List[int]) -> int:
        count: int = 0
        for i in range(len(nums)):
            for j in range(i, len(nums)):
                count += len(set(nums[i:j+1]))**2
        return count
    
# Name to Matrix
# Given a name, turn that name into a perfect square matrix (nested array with the amount of arrays equivalent to the length of each array).
#
# You will need to add periods (.) to the end of the name if necessary, to turn it into a matrix.
#
# If the name has a length of 0, return "name must be at least one letter"
#
# Examples
# "Bill" ==> [ ["B", "i"],
#              ["l", "l"] ]
#
# "Frank" ==> [ ["F", "r", "a"],
#               ["n", "k", "."],
#               [".", ".", "."] ]
# STRINGSARRAYSALGORITHMSMATRIX
def matrixfy(st):
    if not st:
        return 'name must be at least one letter'
    n: int = 1
    while n * n < len(st):
        n += 1
    ans: list = list()
    indx: int = 0
    for i in range(n):
        top: list = list()
        for j in range(n):
            if indx == len(st):
                top.append('.')
            else:
                top.append(st[indx])
                indx += 1
        ans.append(top)
    return ans

# 2315. Count Asterisks
# You are given a string s, where every two consecutive vertical bars '|' are grouped into a pair. In other words, the 1st and 2nd '|' make a pair, the 3rd and 4th '|' make a pair, and so forth.
#
# Return the number of '*' in s, excluding the '*' between each pair of '|'.
#
# Note that each '|' will belong to exactly one pair.
#
#
#
# Example 1:
#
# Input: s = "l|*e*et|c**o|*de|"
# Output: 2
# Explanation: The considered characters are underlined: "l|*e*et|c**o|*de|".
# The characters between the first and second '|' are excluded from the answer.
# Also, the characters between the third and fourth '|' are excluded from the answer.
# There are 2 asterisks considered. Therefore, we return 2.
# Example 2:
#
# Input: s = "iamprogrammer"
# Output: 0
# Explanation: In this example, there are no asterisks in s. Therefore, we return 0.
# Example 3:
#
# Input: s = "yo|uar|e**|b|e***au|tifu|l"
# Output: 5
# Explanation: The considered characters are underlined: "yo|uar|e**|b|e***au|tifu|l". There are 5 asterisks considered. Therefore, we return 5.
#
#
# Constraints:
#
# 1 <= s.length <= 1000
# s consists of lowercase English letters, vertical bars '|', and asterisks '*'.
# s contains an even number of vertical bars '|'.
# Solution One Liner O(N) O(N), but though iterator its O(1)
class Solution:
    def countAsterisks(self, s: str) -> int:
        return sum(i.count('*') for i in s.split('|')[::2])
# Solution OnePass O(N) O(1)
class Solution:
    def countAsterisks(self, s: str) -> int:
        count: int = 0
        boundary: int = 0
        for i in s:
            if i == '|':
                boundary += 1
            elif i == '*' and boundary % 2 == 0:
                count += 1
        return count
    
# Find the Word Pair!
# Given an array of words and a target compound word, your objective is to find the two words which combine into the target word, returning both words in the order they appear in the array, and their respective indices in the order they combine to form the target word. Words in the array you are given may repeat, but there will only be one unique pair that makes the target compound word. If there is no match found, return null/nil/None.
#
# Note: Some arrays will be very long and may include duplicates, so keep an eye on efficiency.
#
# Examples:
#
# fn(['super','bow','bowl','tar','get','book','let'], "superbowl")      =>   ['super','bowl',   [0,2]]
# fn(['bow','crystal','organic','ally','rain','line'], "crystalline")   =>   ['crystal','line', [1,5]]
# fn(['bow','crystal','organic','ally','rain','line'], "rainbow")       =>   ['bow','rain',     [4,0]]
# fn(['bow','crystal','organic','ally','rain','line'], "organically")   =>   ['organic','ally', [2,3]]
# fn(['top','main','tree','ally','fin','line'], "mainline")             =>   ['main','line',    [1,5]]
# fn(['top','main','tree','ally','fin','line'], "treetop")              =>   ['top','tree',     [2,0]]
# Have fun, and if you enjoyed it don't forget to rank & upvote! :)
#
# ARRAYSPERFORMANCEALGORITHMS
def compound_match(words, target):
    ht: dict = dict()
    for i in range(len(words)):
        if words[i] not in ht:
            ht[words[i]] = i
    for i in ht:
        if target.startswith(i):
            for j in ht:
                if i + j == target:
                    x, y = ht[i], ht[j]
                    return [i if x < y else j, i if x > y else j, [ht[i], ht[j]]]
    return

# 2037. Minimum Number of Moves to Seat Everyone
# There are n seats and n students in a room. You are given an array seats of length n, where seats[i] is the position of the ith seat. You are also given the array students of length n, where students[j] is the position of the jth student.
#
# You may perform the following move any number of times:
#
# Increase or decrease the position of the ith student by 1 (i.e., moving the ith student from position x to x + 1 or x - 1)
# Return the minimum number of moves required to move each student to a seat such that no two students are in the same seat.
#
# Note that there may be multiple seats or students in the same position at the beginning.
#
#
#
# Example 1:
#
# Input: seats = [3,1,5], students = [2,7,4]
# Output: 4
# Explanation: The students are moved as follows:
# - The first student is moved from from position 2 to position 1 using 1 move.
# - The second student is moved from from position 7 to position 5 using 2 moves.
# - The third student is moved from from position 4 to position 3 using 1 move.
# In total, 1 + 2 + 1 = 4 moves were used.
# Example 2:
#
# Input: seats = [4,1,5,9], students = [1,3,2,6]
# Output: 7
# Explanation: The students are moved as follows:
# - The first student is not moved.
# - The second student is moved from from position 3 to position 4 using 1 move.
# - The third student is moved from from position 2 to position 5 using 3 moves.
# - The fourth student is moved from from position 6 to position 9 using 3 moves.
# In total, 0 + 1 + 3 + 3 = 7 moves were used.
# Example 3:
#
# Input: seats = [2,2,6,6], students = [1,3,2,6]
# Output: 4
# Explanation: Note that there are two seats at position 2 and two seats at position 6.
# The students are moved as follows:
# - The first student is moved from from position 1 to position 2 using 1 move.
# - The second student is moved from from position 3 to position 6 using 3 moves.
# - The third student is not moved.
# - The fourth student is not moved.
# In total, 1 + 3 + 0 + 0 = 4 moves were used.
#
#
# Constraints:
#
# n == seats.length == students.length
# 1 <= n <= 100
# 1 <= seats[i], students[j] <= 100
# Solution Greedy O(NlogN) O(1)
class Solution:
    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:
        seats.sort()
        students.sort()
        count: int = 0
        for i in range(len(seats)):
            count += abs(seats[i] - students[i])
        return count
    
# All Star Code Challenge #19
# This Kata is intended as a small challenge for my students
#
# All Star Code Challenge #19
#
# You work for an ad agency and your boss, Bob, loves a catchy slogan. He's always jumbling together "buzz" words until he gets one he likes. You're looking to impress Boss Bob with a function that can do his job for him.
#
# Create a function called sloganMaker() that accepts an array of string "buzz" words. The function returns an array of all possible UNIQUE string permutations of the buzz words (concatonated and separated by spaces).
#
# Your boss is not very bright, so anticipate him using the same "buzz" word more than once, by accident. The function should ignore these duplicate string inputs.
#
# sloganMaker(["super", "hot", "guacamole"]);
# //[ 'super hot guacamole',
# //  'super guacamole hot',
# //  'hot super guacamole',
# //  'hot guacamole super',
# //  'guacamole super hot',
# //  'guacamole hot super' ]
#
# sloganMaker(["cool", "pizza", "cool"]); // => [ 'cool pizza', 'pizza cool' ]
# Note:
# There should be NO duplicate strings in the output array
#
# The input array MAY contain duplicate strings, which should STILL result in an output array with all unique strings
#
# An empty string is valid input
#
# The order of the output array must match those rules:
#
# Generate the permutations in lexicographic order of the original array.
# keep only the first occurence of a permutation, when duplicates are found.
# STRINGSCOMBINATORICSPERMUTATIONSARRAYSFUNDAMENTALS
import itertools
def slogan_maker(array):
    ht: dict = dict()
    for i in array:
        if i not in ht:
            ht[i] = 1
    ans: list = list()
    for i in itertools.permutations(ht.keys(), len(ht)):
        ans.append(' '.join(i))
    return ans

# 2864. Maximum Odd Binary Number
# You are given a binary string s that contains at least one '1'.
#
# You have to rearrange the bits in such a way that the resulting binary number is the maximum odd binary number that can be created from this combination.
#
# Return a string representing the maximum odd binary number that can be created from the given combination.
#
# Note that the resulting string can have leading zeros.
#
#
#
# Example 1:
#
# Input: s = "010"
# Output: "001"
# Explanation: Because there is just one '1', it must be in the last position. So the answer is "001".
# Example 2:
#
# Input: s = "0101"
# Output: "1001"
# Explanation: One of the '1's must be in the last position. The maximum number that can be made with the remaining digits is "100". So the answer is "1001".
#
#
# Constraints:
#
# 1 <= s.length <= 100
# s consists only of '0' and '1'.
# s contains at least one '1'.
# Solution HashTable O(N) O(N)
class Solution:
    def maximumOddBinaryNumber(self, s: str) -> str:
        ht: dict = dict()
        ans: list = list()
        for i in s:
            ht[i] = ht.get(i, 0) + 1
        while ht.get('1') > 1:
            ans.append('1')
            ht['1'] -= 1
        while ht.get('0'):
            ans.append('0')
            ht['0'] -= 1
        if ht.get('1'):
            ans.append('1')
        return ''.join(ans)
# Solution Counting Greedy O(N) O(N)
class Solution:
    def maximumOddBinaryNumber(self, s: str) -> str:
        count: int = 0
        ans: str = ''
        for i in s:
            if i == '1':
                count += 1
        for i in range(len(s) - 1):
            if count > 1:
                ans += '1'
                count -= 1
            else:
                ans += '0'
        ans += '1'
        return ans
        
# Split all even numbers to odd ones in different ways
# #Split all even numbers to odd ones in different ways
#
# Your task is to split all even numbers from an array to odd ones. So your method has to return a new array with only odd numbers.
#
# For "splitting" the numbers there are four ways.
#
# 0 -> Split into two odd numbers, that are closest to each other.
#      (e.g.: 8 -> 3,5)
# 1 -> Split into two odd numbers, that are most far from each other.
#      (e.g.: 8 -> 1,7)
# 2 -> All new odd numbers from the splitting should be equal and the maximum possible number.
#      (e.g.: 8 -> 1, 1, 1, 1, 1, 1, 1, 1)
# 3 -> Split into 1s.
#      (e.g.: 8 -> 1, 1, 1, 1, 1, 1, 1, 1)
# The new numbers (from the splitting) have always to be in ascending order.
# So in the array every even number is replaced by the new odd numbers from the splitting.
# Your method will get as parameters the input-array and the number of the way for splitting the even numbers.
#
# Some Examples
#
# [1,10,1,3],0 -> [1,5,5,1,3]
# [1,10,1,3],1 -> [1,1,9,1,3]
# [1,10,1,3],2 -> [1,5,5,1,3]
# [1,10,1,3],3 -> [1,1,1,1,1,1,1,1,1,1,1,1,3]
#
# [1,1,3,8],0 -> [1,1,3,3,5]
# [1,1,3,8],1 -> [1,1,3,1,7]
# [1,1,3,8],2 -> [1,1,3,1,1,1,1,1,1,1,1]
# [1,1,3,8],3 -> [1,1,3,1,1,1,1,1,1,1,1]
# The array will never be null and will always contain only integer numbers > 0. Also your result-array must contain only integer numbers > 0. The way-parameter will always be between inclusive 0 and inclusive 3 (0,1,2,3).
#
# You must not change the input-array!
#
#
#
#
# Have fun coding it and please don't forget to vote and rank this kata! :-)
#
# I have also created other katas. Take a look if you enjoyed this kata!
#
# ARRAYSLOGICALGORITHMS
def split_all_even_numbers(numbers, way):
    ans: list = list()
    if way == 0:
        for i in numbers:
            if i % 2 == 0:
                if i // 2 % 2 != 0:
                    ans.append(i//2)
                    ans.append(i//2)
                else:
                    ans.append(i // 2 - 1)
                    ans.append(i // 2 + 1)
            else:
                ans.append(i)
        return ans
    if way == 1:
        for i in numbers:
            if i % 2 == 0:
                ans.append(1)
                ans.append(i - 1)
            else:
                ans.append(i)
        return ans
    if way == 2:
        for i in numbers:
            if i % 2 == 0:
                for j in range(i // 2 + 1, 0, -1):
                    if j % 2 != 0 and j * (i // j) == i:
                        ans.extend([j] * (i // j))
                        break
            else:
                ans.append(i)
        return ans
    else:
        for i in numbers:
            if i % 2 == 0:
                ans.extend([1] * i)
            else:
                ans.append(i)
        return ans

# 977. Squares of a Sorted Array
# Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.
#
#
#
# Example 1:
#
# Input: nums = [-4,-1,0,3,10]
# Output: [0,1,9,16,100]
# Explanation: After squaring, the array becomes [16,1,0,9,100].
# After sorting, it becomes [0,1,9,16,100].
# Example 2:
#
# Input: nums = [-7,-3,2,3,11]
# Output: [4,9,9,49,121]
#
#
# Constraints:
#
# 1 <= nums.length <= 104
# -104 <= nums[i] <= 104
# nums is sorted in non-decreasing order.
#
#
# Follow up: Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach?
# Solution
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        n: int = len(nums)
        ans: list = [0] * n
        n -= 1
        left, right = 0, n
        while left <= right:
            if abs(nums[left]) >= abs(nums[right]):
                ans[n] = nums[left]**2
                left += 1
            else:
                ans[n] = nums[right]**2
                right -= 1
            n -= 1
        return ans

# What The Biggest Search Keys?
# You're a programmer in a SEO company. The SEO specialist of your company gets the list of all project keywords everyday, then he looks for the longest keys to analyze them.
#
# You will get the list with keywords and must write a simple function that returns the biggest search keywords and sorts them in lexicographical order.
#
# For instance you might get:
#
# 'key1', 'key2', 'key3', 'key n', 'bigkey2', 'bigkey1'
# And your function should return:
#
# "'bigkey1', 'bigkey2'"
# Don't forget to rate this kata! Thanks :)
#
# FUNDAMENTALSARRAYS
def the_biggest_search_keys(*args):
    ans: list = list()
    ln: int = -1
    for i in args:
        if len(i) > ln:
            ans.clear()
            ans.append(i)
            ln = len(i)
        elif len(i) == ln:
            ans.append(i)
    ans.sort()
    if not ans:
        return "''"
    return ', '.join(f"'{i}'" for i in ans)

# 19. Remove Nth Node From End of List
# Given the head of a linked list, remove the nth node from the end of the list and return its head.
#
#
#
# Example 1:
#
#
# Input: head = [1,2,3,4,5], n = 2
# Output: [1,2,3,5]
# Example 2:
#
# Input: head = [1], n = 1
# Output: []
# Example 3:
#
# Input: head = [1,2], n = 1
# Output: [1]
#
#
# Constraints:
#
# The number of nodes in the list is sz.
# 1 <= sz <= 30
# 0 <= Node.val <= 100
# 1 <= n <= sz
#
#
# Follow up: Could you do this in one pass?
# Solution O(N) O(1)
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        tmp = head
        ln: int = 0
        while tmp:
            ln += 1
            tmp = tmp.next
        if ln == 1 or ln - n == 0:
            head = head.next
            return head
        tmp = head
        for i in range(ln - n - 1):
            tmp = tmp.next
        tmp.next = tmp.next.next if tmp.next else tmp.next
        return head
# Solution Two Pointers O(N) O(1)
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        new_head = ListNode('new_head', head)
        fast, slow = new_head, new_head
        for i in range(n):
            fast = fast.next
        while fast.next:
            fast, slow = fast.next, slow.next
        slow.next = slow.next.next
        return new_head.next

# Base Conversion
# In this kata you have to implement a base converter, which converts positive integers between arbitrary bases / alphabets. Here are some pre-defined alphabets:
#
# bin      = '01'
# oct      = '01234567'
# dec      = '0123456789'
# hex      = '0123456789abcdef'
# allow    = 'abcdefghijklmnopqrstuvwxyz'
# allup    = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
# alpha    = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
# alphanum = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
# The function convert() should take an input (string), the source alphabet (string) and the target alphabet (string). You can assume that the input value always consists of characters from the source alphabet. You don't need to validate it.
#
# Examples
# convert("15", dec, bin)       ==>  "1111"
# convert("15", dec, oct)       ==>  "17"
# convert("1010", bin, dec)     ==>  "10"
# convert("1010", bin, hex)     ==>  "a"
# convert("0", dec, alpha)      ==>  "a"
# convert("27", dec, allow)     ==>  "bb"
# convert("hello", allow, hex)  ==>  "320048"
# Additional Notes:
#
# The maximum input value can always be encoded in a number without loss of precision in JavaScript. In Haskell, intermediate results will probably be too large for Int.
# The function must work for any arbitrary alphabets, not only the pre-defined ones
# You don't have to consider negative numbers
# STRINGSMATHEMATICSALGORITHMS
def convert(input, source, target):
    count: int = 0
    for i in input:
        count = count * len(source) + source.index(i)
    ans: list = list()
    while count:
        ans.append(target[count % len(target)])
        count //= len(target)
    return ''.join(ans[::-1]) if ans else target[0]

# 948. Bag of Tokens
# You start with an initial power of power, an initial score of 0, and a bag of tokens given as an integer array tokens, where each tokens[i] donates the value of tokeni.
#
# Your goal is to maximize the total score by strategically playing these tokens. In one move, you can play an unplayed token in one of the two ways (but not both for the same token):
#
# Face-up: If your current power is at least tokens[i], you may play tokeni, losing tokens[i] power and gaining 1 score.
# Face-down: If your current score is at least 1, you may play tokeni, gaining tokens[i] power and losing 1 score.
# Return the maximum possible score you can achieve after playing any number of tokens.
#
#
#
# Example 1:
#
# Input: tokens = [100], power = 50
#
# Output: 0
#
# Explanation: Since your score is 0 initially, you cannot play the token face-down. You also cannot play it face-up since your power (50) is less than tokens[0] (100).
#
# Example 2:
#
# Input: tokens = [200,100], power = 150
#
# Output: 1
#
# Explanation: Play token1 (100) face-up, reducing your power to 50 and increasing your score to 1.
#
# There is no need to play token0, since you cannot play it face-up to add to your score. The maximum score achievable is 1.
#
# Example 3:
#
# Input: tokens = [100,200,300,400], power = 200
#
# Output: 2
#
# Explanation: Play the tokens in this order to get a score of 2:
#
# Play token0 (100) face-up, reducing power to 100 and increasing score to 1.
# Play token3 (400) face-down, increasing power to 500 and reducing score to 0.
# Play token1 (200) face-up, reducing power to 300 and increasing score to 1.
# Play token2 (300) face-up, reducing power to 0 and increasing score to 2.
# The maximum score achievable is 2.
#
#
#
# Constraints:
#
# 0 <= tokens.length <= 1000
# 0 <= tokens[i], power < 104
class Solution:
    def bagOfTokensScore(self, tokens: List[int], power: int) -> int:
        tokens.sort()
        score: int = 0
        idx, n = 0, len(tokens) - 1
        ans: int = score
        while idx <= n:
            if power >= tokens[idx]:
                power -= tokens[idx]
                idx, score = idx + 1, score + 1
                ans = max(ans, score)
            elif score >= 1:
                score, n = score - 1, n - 1
                power += tokens.pop()
            else:
                break
        return ans
    
# Simple Fun #166: Best Match
# Task
# "AL-AHLY" and "Zamalek" are the best teams in Egypt, but "AL-AHLY" always wins the matches between them. "Zamalek" managers want to know what is the best match they've played so far.
#
# The best match is the match they lost with the minimum goal difference. If there is more than one match with the same difference, choose the one "Zamalek" scored more goals in.
#
# Given the information about all matches they played, return the index of the best match (0-based). If more than one valid result, return the smallest index.
#
# Example
# For ALAHLYGoals = [6,4] and zamalekGoals = [1,2], the output should be 1 (2 in COBOL).
#
# Because 4 - 2 is less than 6 - 1
#
# For ALAHLYGoals = [1,2,3,4,5] and zamalekGoals = [0,1,2,3,4], the output should be 4.
#
# The goal difference of all matches are 1, but at 4th match "Zamalek" scored more goals in. So the result is 4 (5 in COBOL).
#
# Input/Output
# [input] integer array ALAHLYGoals
# The number of goals "AL-AHLY" scored in each match.
#
# [input] integer array zamalekGoals
# The number of goals "Zamalek" scored in each match. It is guaranteed that zamalekGoals[i] < ALAHLYGoals[i] for each element.
#
# [output] an integer
# Index of the best match.
#
# FUNDAMENTALS
# Solution OnePass O(N) O(1)
def best_match(goals1, goals2):
    idx, val, gol = 0, goals1[0] - goals2[0], goals2[0]
    for i in range(1, len(goals1)):
        if goals1[i] - goals2[i] < val:
            idx, val, gol = i, goals1[i] - goals2[i], goals2[i]
        elif goals1[i] - goals2[i] == val:
            if gol >= goals2[i]:
                continue
            idx, val, gol = i, goals1[i] - goals2[i], goals2[i]
    return idx

# 1750. Minimum Length of String After Deleting Similar Ends
# Given a string s consisting only of characters 'a', 'b', and 'c'. You are asked to apply the following algorithm on the string any number of times:
#
# Pick a non-empty prefix from the string s where all the characters in the prefix are equal.
# Pick a non-empty suffix from the string s where all the characters in this suffix are equal.
# The prefix and the suffix should not intersect at any index.
# The characters from the prefix and suffix must be the same.
# Delete both the prefix and the suffix.
# Return the minimum length of s after performing the above operation any number of times (possibly zero times).
#
#
#
# Example 1:
#
# Input: s = "ca"
# Output: 2
# Explanation: You can't remove any characters, so the string stays as is.
# Example 2:
#
# Input: s = "cabaabac"
# Output: 0
# Explanation: An optimal sequence of operations is:
# - Take prefix = "c" and suffix = "c" and remove them, s = "abaaba".
# - Take prefix = "a" and suffix = "a" and remove them, s = "baab".
# - Take prefix = "b" and suffix = "b" and remove them, s = "aa".
# - Take prefix = "a" and suffix = "a" and remove them, s = "".
# Example 3:
#
# Input: s = "aabccabba"
# Output: 3
# Explanation: An optimal sequence of operations is:
# - Take prefix = "aa" and suffix = "a" and remove them, s = "bccabb".
# - Take prefix = "b" and suffix = "bb" and remove them, s = "cca".
#
#
# Constraints:
#
# 1 <= s.length <= 105
# s only consists of characters 'a', 'b', and 'c'.
class Solution:
    def minimumLength(self, s: str) -> int:
        left, right = 0, len(s) - 1
        while left < right and s[left] == s[right]:
            x: str = s[left]
            while left <= right and s[left] == x:
                left += 1
            while s[right] == x and right > left:
                right -= 1
        return right + 1 - left

# Calculate Variance
# Write a function which will accept a sequence of numbers and calculate the variance for the sequence.
#
# The variance for a set of numbers is found by subtracting the mean from every value, squaring the results, adding them all up and dividing by the number of elements.
#
# For example, in pseudo code, to calculate the variance for [1, 2, 2, 3].
#
# mean = (1 + 2 + 2 + 3) / 4
# => 2
#
# variance = ((1 - 2)^2 + (2 - 2)^2 + (2-2)^2 + (3 - 2)^2)  /  4
# => 0.5
# Results are tested to a relative error of 1e-4.
#
# STATISTICSMATHEMATICSALGORITHMS
def variance(numbers): 
    mean: int = sum(numbers) / len(numbers)
    return sum((i - mean)**2 for i in numbers) / len(numbers)

# 141. Linked List Cycle
# Given head, the head of a linked list, determine if the linked list has a cycle in it.
#
# There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.
#
# Return true if there is a cycle in the linked list. Otherwise, return false.
#
#
#
# Example 1:
#
#
# Input: head = [3,2,0,-4], pos = 1
# Output: true
# Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).
# Example 2:
#
#
# Input: head = [1,2], pos = 0
# Output: true
# Explanation: There is a cycle in the linked list, where the tail connects to the 0th node.
# Example 3:
#
#
# Input: head = [1], pos = -1
# Output: false
# Explanation: There is no cycle in the linked list.
#
#
# Constraints:
#
# The number of the nodes in the list is in the range [0, 104].
# -105 <= Node.val <= 105
# pos is -1 or a valid index in the linked-list.
#
#
# Follow up: Can you solve it using O(1) (i.e. constant) memory?
# Solution Two Pointers O(N) O(1)
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        slow = fast = head
        while slow and fast and fast.next:
            slow, fast = slow.next, fast.next.next
            if slow == fast:
                return True
        return False

# Lambdas as a mechanism for Open/Closed
# Open/Closed Principle
# The open/closed principle states that code should be closed for modification, yet open for extension. That means you should be able to add new functionality to an object or method without altering it.
#
# One way to achieve this is by using a lambda, which by nature is lazily bound to the lexical context. Until you call a lambda, it is just a piece of data you can pass around.
#
# Task at hand
# Implement 3 lambdas that alter a message based on emotion:
#
# spoken    = lambda greeting: ... # "hello WORLD" --> "Hello world."
# shouted   = lambda greeting: ... # "Hello world" --> "HELLO WORLD!"
# whispered = lambda greeting: ... # "HELLO WORLD" --> "hello world."
# Then create a fourth lambda, this one will take one of the above lambdas and a message, and the last lambda will delegate the emotion and the message up the chain.
#
# greet = lambda style, msg: ...
# Input
# Input message contains only ASCII alphabets and spaces.
#
# While here we only test for spoken, shouted, and whispered emotions, the open/closed principle allows us to add functionality to the greet function using other emotions/lambdas as well. For example, feeling like L33tsp34k1ng or sPoNgEbOb MeMe-ing today? No need to change the original greet function (closed for modification), you can just extend the greet function (open for extension) by passing a new lambda and message to the greet function. So, embrace the power of open/closed principle now and make your code more flexible and easier to extend!
#
# FUNDAMENTALS
spoken    = lambda greeting: greeting.title() + '.'
shouted   = lambda greeting: greeting.upper() + '!'
whispered = lambda greeting: greeting.lower() + '.'

greet = lambda style, msg: style(msg)

# 876. Middle of the Linked List
# Given the head of a singly linked list, return the middle node of the linked list.
#
# If there are two middle nodes, return the second middle node.
#
#
#
# Example 1:
#
#
# Input: head = [1,2,3,4,5]
# Output: [3,4,5]
# Explanation: The middle node of the list is node 3.
# Example 2:
#
#
# Input: head = [1,2,3,4,5,6]
# Output: [4,5,6]
# Explanation: Since the list has two middle nodes with values 3 and 4, we return the second one.
#
#
# Constraints:
#
# The number of nodes in the list is in the range [1, 100].
# 1 <= Node.val <= 100
# Solution
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:
        slow, fast = head, head
        while fast and fast.next:
            slow, fast = slow.next, fast.next.next
        return slow
    
# Look and say numbers
# There exists a sequence of numbers that follows the pattern
#
#           1
#          11
#          21
#         1211
#        111221
#        312211
#       13112221
#      1113213211
#           .
#           .
#           .
# Starting with "1" the following lines are produced by "saying what you see", so that line two is "one one", line three is "two one(s)", line four is "one two one one".
#
# Write a function that given a starting value as a string, returns the appropriate sequence as a list. The starting value can have any number of digits. The termination condition is a defined by the maximum number of iterations, also supplied as an argument.
#
# RECURSIONALGORITHMS
def look_and_say(data='1', maxlen=5):
    ans: list = list()
    for i in range(maxlen):
        top: str = ''
        prev: str = ans[-1][0]  if ans else data[0]
        count: int = 1
        for j in range(1, len(ans[-1]) if ans else len(data)):
            if prev != (ans[-1][j] if ans else data[j]):
                top += str(count) + prev
                count, prev = 1, ans[-1][j] if ans else data[j]
            else:
                count += 1
        if count > 0:
            top += str(count) + prev
        ans.append(top)
    return ans

# 3005. Count Elements With Maximum Frequency
# You are given an array nums consisting of positive integers.
#
# Return the total frequencies of elements in nums such that those elements all have the maximum frequency.
#
# The frequency of an element is the number of occurrences of that element in the array.
#
#
#
# Example 1:
#
# Input: nums = [1,2,2,3,1,4]
# Output: 4
# Explanation: The elements 1 and 2 have a frequency of 2 which is the maximum frequency in the array.
# So the number of elements in the array with maximum frequency is 4.
# Example 2:
#
# Input: nums = [1,2,3,4,5]
# Output: 5
# Explanation: All elements of the array have a frequency of 1 which is the maximum.
# So the number of elements in the array with maximum frequency is 5.
#
#
# Constraints:
#
# 1 <= nums.length <= 100
# 1 <= nums[i] <= 100
# Solution HashTable O(N) O(N)
class Solution:
    def maxFrequencyElements(self, nums: List[int]) -> int:
        ht: dict = dict()
        top, count = 0, 0
        for i in nums:
            ht[i] = ht.get(i, 0) + 1
            top = max(top, ht[i])
        for i in ht:
            count += ht[i] if ht[i] == top else 0
        return count

# Battle ships: Sunk damaged or not touched?
# Task
# Your task in the kata is to determine how many boats are sunk damaged and untouched from a set amount of attacks. You will need to create a function that takes two arguments, the playing board and the attacks.
#
# Example Game
# The board
#
# X
# Y
#
# 1
# 2
# 3
# 4
# 5
# 6
# 4
# 0
# 0
# 2
# 2
# 2
# 2
# 0
# 3
# 0
# 0
# 0
# 0
# 0
# 3
# 0
# 1
# 0
# 0
# 0
# 3
# 0
# 1
# 0
# 0
# 3
# 2
# 1
#
#
# Boats are placed either horizontally, vertically or diagonally on the board. 0 represents a space not occupied by a boat. Digits 1-3 represent boats which vary in length 1-4 spaces long. There will always be at least 1 boat up to a maximum of 3 in any one game. Boat sizes and board dimentions will vary from game to game.
#
# Attacks
# Attacks are calculated from the bottom left, first the X coordinate then the Y. There will be at least one attack per game, and the array will not contain duplicates.
#
# [[2, 1], [1, 3], [4, 2]]
# First attack      `[2, 1]` = `3`
# Second attack `[1, 3]` = `0`
# Third attack     `[4, 2]` = `1`
# Function Initialization
# board = [[0,0,0,2,2,0],
#          [0,3,0,0,0,0],
#          [0,3,0,1,0,0],
#          [0,3,0,1,0,0]]
# attacks = [[2, 1], [1, 3], [4, 2]]
# damaged_or_sunk(board, attacks)
# Scoring
# 1 point for every whole boat sank.
# 0.5 points for each boat hit at least once (not including boats that are sunk).
# -1 point for each whole boat that was not hit at least once.
# Sunk or Damaged
# `sunk` = all boats that are sunk
# `damaged` = all boats that have been hit at least once but not sunk
# `notTouched/not_touched` = all boats that have not been hit at least once
# Output
# You should return a hash with the following data
#
# `sunk`, `damaged`, `not_touched`, `points`
# Example Game Output
# In our above example..
#
# First attack: `boat 3` was damaged, which increases the `points` by `0.5`
# Second attack: miss nothing happens
# Third attack: `boat 1` was damaged, which increases the `points` by `0.5`
# `boat 2` was untouched so `points -1` and `notTouched +1` in Javascript/Java/C# and `not_touched +1` in Python/Ruby.
# No whole boats sank
# Return Hash
# { 'sunk': 0, 'damaged': 2 , 'not_touched': 1, 'points': 0 }
# ARRAYSFUNDAMENTALS
def damaged_or_sunk(board, attacks):
    ans: dict = {'sunk': 0, 'damaged': 0, 'not_touched': 0, 'points': 0}
    ht: dict = dict()
    for i in range(len(board)):
        for j in range(len(board[0])):
            if board[i][j] != 0:
                ht[board[i][j]] = ht.get(board[i][j], []) + [board[i][j]]
    ln: dict = {k: len(v) for k,v in ht.items()}
    for i in attacks:
        if board[-i[1]][i[0] - 1] != 0:
            ht[board[-i[1]][i[0] - 1]].pop()
    for i in ht:
        if ln[i] - len(ht[i]) == ln[i]:
            ans['sunk'] += 1
            ans['points'] += 1
        elif ln[i] - len(ht[i]) == 0:
            ans['not_touched'] += 1
            ans['points'] -= 1
        else:
            ans['damaged'] += 1
            ans['points'] += 0.5
    return ans

# 2540. Minimum Common Value
# Given two integer arrays nums1 and nums2, sorted in non-decreasing order, return the minimum integer common to both arrays. If there is no common integer amongst nums1 and nums2, return -1.
#
# Note that an integer is said to be common to nums1 and nums2 if both arrays have at least one occurrence of that integer.
#
#
#
# Example 1:
#
# Input: nums1 = [1,2,3], nums2 = [2,4]
# Output: 2
# Explanation: The smallest element common to both arrays is 2, so we return 2.
# Example 2:
#
# Input: nums1 = [1,2,3,6], nums2 = [2,3,4,5]
# Output: 2
# Explanation: There are two common elements in the array 2 and 3 out of which 2 is the smallest, so 2 is returned.
#
#
# Constraints:
#
# 1 <= nums1.length, nums2.length <= 105
# 1 <= nums1[i], nums2[j] <= 109
# Both nums1 and nums2 are sorted in non-decreasing order.
class Solution:
    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:
        left, right = 0, 0
        while left < len(nums1) and right < len(nums2):
            if nums1[left] == nums2[right]:
                return nums1[left]
            elif nums1[left] > nums2[right]:
                right += 1
            else:
                left += 1
        return -1
    
# Design a Simple Automaton (Finite State Machine)
# Create a finite automaton that has three states. Finite automatons are the same as finite state machines for our purposes.
#
# Our simple automaton, accepts the language of A, defined as {0, 1} and should have three states: q1, q2, and q3. Here is the description of the states:
#
# q1 is our start state, we begin reading commands from here
# q2 is our accept state, we return true if this is our last state
# And the transitions:
#
# q1 moves to q2 when given a 1, and stays at q1 when given a 0
# q2 moves to q3 when given a 0, and stays at q2 when given a 1
# q3 moves to q2 when given a 0 or 1
# The automaton should return whether we end in our accepted state (q2), or not (true/false).
#
# Your task
# You will have to design your state objects, and how your Automaton handles transitions. Also make sure you set up the three states, q1, q2, and q3 for the myAutomaton instance. The test fixtures will be calling against myAutomaton.
#
# As an aside, the automaton accepts an array of strings, rather than just numbers, or a number represented as a string, because the language an automaton can accept isn't confined to just numbers. An automaton should be able to accept any 'symbol.'
#
# Here are some resources on DFAs (the automaton this Kata asks you to create):
#
# http://en.wikipedia.org/wiki/Deterministic_finite_automaton
# http://www.cs.odu.edu/~toida/nerzic/390teched/regular/fa/dfa-definitions.html
# http://www.cse.chalmers.se/~coquand/AUTOMATA/o2.pdf
# Example
# a = Automaton()
# a.read_commands(["1", "0", "0", "1", "0"])  ==> False
# We make these transitions:
#
# input: ["1", "0", "0", "1", "0"]
#
# 1: q1 -> q2
# 0: q2 -> q3
# 0: q3 -> q2
# 1: q2 -> q2
# 0: q2 -> q3
# We end in q3 which is not our accept state, so we return false
#
# STATE MACHINESARTIFICIAL INTELLIGENCEALGORITHMSOBJECT-ORIENTED PROGRAMMING
class Automaton(object):

    def __init__(self):
        self.states = []

    def read_commands(self, commands):
        start = self.states[0]
        for i in commands:
            if start == self.states[0]:
                start = self.states[1] if i == '1' else self.states[0]
            elif start == self.states[1]:
                start = self.states[2] if i == '0' else self.states[1]
            else:
                start = self.states[1] if i in '01' else self.states[2]
        return start == 'q2'
my_automaton = Automaton()

# Do anything necessary to set up your automaton's states, q1, q2, and q3.
my_automaton.states.append('q1')
my_automaton.states.append('q2')
my_automaton.states.append('q3')

# 349. Intersection of Two Arrays
# Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.
#
#
#
# Example 1:
#
# Input: nums1 = [1,2,2,1], nums2 = [2,2]
# Output: [2]
# Example 2:
#
# Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
# Output: [9,4]
# Explanation: [4,9] is also accepted.
#
#
# Constraints:
#
# 1 <= nums1.length, nums2.length <= 1000
# 0 <= nums1[i], nums2[i] <= 1000
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        ht1, ht2 = dict(), dict()
        ans: list = list()
        for i in nums1:
            ht1[i] = ht1.get(i, 0) + 1
        for i in nums2:
            ht2[i] = ht2.get(i, 0) + 1
        for i in ht1:
            if i in ht2:
                ans.append(i)
        return ans

# 3046. Split the Array
# You are given an integer array nums of even length. You have to split the array into two parts nums1 and nums2 such that:
#
# nums1.length == nums2.length == nums.length / 2.
# nums1 should contain distinct elements.
# nums2 should also contain distinct elements.
# Return true if it is possible to split the array, and false otherwise.
#
#
#
# Example 1:
#
# Input: nums = [1,1,2,2,3,4]
# Output: true
# Explanation: One of the possible ways to split nums is nums1 = [1,2,3] and nums2 = [1,2,4].
# Example 2:
#
# Input: nums = [1,1,1,1]
# Output: false
# Explanation: The only possible way to split nums is nums1 = [1,1] and nums2 = [1,1]. Both nums1 and nums2 do not contain distinct elements. Therefore, we return false.
#
#
# Constraints:
#
# 1 <= nums.length <= 100
# nums.length % 2 == 0
# 1 <= nums[i] <= 100
class Solution:
    def isPossibleToSplit(self, nums: List[int]) -> bool:
        n: int = len(nums) // 2
        ht: dict = dict()
        for i in nums:
            ht[i] = ht.get(i, 0) + 1
            if ht[i] > 2:
                return False
        flag: bool = False
        sc1, sc2 = 0, 0
        for i in ht:
            if ht[i] == 2:
                sc1, sc2 = sc1 + 1, sc2 + 1
            else:
                if not flag:
                    sc1 += 1
                else:
                    sc2 += 1
                flag = not flag
        return sc1 == sc2 == n

# 3065. Minimum Operations to Exceed Threshold Value I
# You are given a 0-indexed integer array nums, and an integer k.
#
# In one operation, you can remove one occurrence of the smallest element of nums.
#
# Return the minimum number of operations needed so that all elements of the array are greater than or equal to k.
#
#
#
# Example 1:
#
# Input: nums = [2,11,10,1,3], k = 10
# Output: 3
# Explanation: After one operation, nums becomes equal to [2, 11, 10, 3].
# After two operations, nums becomes equal to [11, 10, 3].
# After three operations, nums becomes equal to [11, 10].
# At this stage, all the elements of nums are greater than or equal to 10 so we can stop.
# It can be shown that 3 is the minimum number of operations needed so that all elements of the array are greater than or equal to 10.
# Example 2:
#
# Input: nums = [1,1,2,4,9], k = 1
# Output: 0
# Explanation: All elements of the array are greater than or equal to 1 so we do not need to apply any operations on nums.
# Example 3:
#
# Input: nums = [1,1,2,4,9], k = 9
# Output: 4
# Explanation: only a single element of nums is greater than or equal to 9 so we need to apply the operations 4 times on nums.
#
#
# Constraints:
#
# 1 <= nums.length <= 50
# 1 <= nums[i] <= 109
# 1 <= k <= 109
# The input is generated such that there is at least one index i such that nums[i] >= k.
class Solution:
    def minOperations(self, nums: List[int], k: int) -> int:
        count: int = 0
        ht: dict = dict()
        for i in nums:
            ht[i] = ht.get(i, 0) + 1
        for i in ht:
            if i < k:
                count += ht[i]
        return count

# 3069. Distribute Elements Into Two Arrays I
# You are given a 1-indexed array of distinct integers nums of length n.
#
# You need to distribute all the elements of nums between two arrays arr1 and arr2 using n operations. In the first operation, append nums[1] to arr1. In the second operation, append nums[2] to arr2. Afterwards, in the ith operation:
#
# If the last element of arr1 is greater than the last element of arr2, append nums[i] to arr1. Otherwise, append nums[i] to arr2.
# The array result is formed by concatenating the arrays arr1 and arr2. For example, if arr1 == [1,2,3] and arr2 == [4,5,6], then result = [1,2,3,4,5,6].
#
# Return the array result.
#
#
#
# Example 1:
#
# Input: nums = [2,1,3]
# Output: [2,3,1]
# Explanation: After the first 2 operations, arr1 = [2] and arr2 = [1].
# In the 3rd operation, as the last element of arr1 is greater than the last element of arr2 (2 > 1), append nums[3] to arr1.
# After 3 operations, arr1 = [2,3] and arr2 = [1].
# Hence, the array result formed by concatenation is [2,3,1].
# Example 2:
#
# Input: nums = [5,4,3,8]
# Output: [5,3,4,8]
# Explanation: After the first 2 operations, arr1 = [5] and arr2 = [4].
# In the 3rd operation, as the last element of arr1 is greater than the last element of arr2 (5 > 4), append nums[3] to arr1, hence arr1 becomes [5,3].
# In the 4th operation, as the last element of arr2 is greater than the last element of arr1 (4 > 3), append nums[4] to arr2, hence arr2 becomes [4,8].
# After 4 operations, arr1 = [5,3] and arr2 = [4,8].
# Hence, the array result formed by concatenation is [5,3,4,8].
#
#
# Constraints:
#
# 3 <= n <= 50
# 1 <= nums[i] <= 100
# All elements in nums are distinct.
class Solution:
    def resultArray(self, nums: List[int]) -> List[int]:
        n: int = len(nums)
        ans1, ans2 = [nums[0]], [nums[1]]
        for i in range(2, n):
            if ans1[-1] > ans2[-1]:
                ans1.append(nums[i])
            else:
                ans2.append(nums[i])
        return ans1 + ans2
    
# Sort - one, three, two
# Hey You !
# Sort these integers for me ...
#
# By name ...
#
# Do it now !
#
# Input
# Range is 0-999
#
# There may be duplicates
#
# The array may be empty
#
# Example
# Input: 1, 2, 3, 4
# Equivalent names: "one", "two", "three", "four"
# Sorted by name: "four", "one", "three", "two"
# Output: 4, 1, 3, 2
# Notes
# Don't pack words together:
# e.g. 99 may be "ninety nine" or "ninety-nine"; but not "ninetynine"
# e.g 101 may be "one hundred one" or "one hundred and one"; but not "onehundredone"
# Don't fret about formatting rules, because if rules are consistently applied it has no effect anyway:
# e.g. "one hundred one", "one hundred two"; is same order as "one hundred and one", "one hundred and two"
# e.g. "ninety eight", "ninety nine"; is same order as "ninety-eight", "ninety-nine"
# SORTINGSTRINGSALGORITHMS
def convertation(dgt: int) -> str:
    digits: list = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine']
    ten: list = ['ten', 'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen', 'eighteen', 'nineteen']
    double: list = ['ten', 'twenty', 'thirty', 'forty', 'fifty', 'sixty', 'seventy', 'eighty', 'ninety']
    ans: list = list()
    while True:
        if dgt < 10:
            ans.append(digits[dgt])
            break
        elif dgt < 20:
            ans.append(ten[int(str(dgt)[1])])
            break
        elif dgt < 100:
            x, y = str(dgt)[:]
            if y == '0':
                ans.append(double[int(x) - 1])
                break
            else:
                ans.append(double[int(x) - 1] + ' ' + digits[int(y)])
                break
        else:
            if dgt % 100 == 0:
                ans.append(digits[int(str(dgt)[0])] + ' hundred')
                break
            ans.append(digits[int(str(dgt)[0])] + ' hundred')
            dgt %= 100
    return ' '.join(ans)


def sort_by_name(arr):
    ht: dict = {i:convertation(i) for i in arr}
    arr.sort(key=lambda x: ht[x])
    return arr

# 3074. Apple Redistribution into Boxes
# You are given an array apple of size n and an array capacity of size m.
#
# There are n packs where the ith pack contains apple[i] apples. There are m boxes as well, and the ith box has a capacity of capacity[i] apples.
#
# Return the minimum number of boxes you need to select to redistribute these n packs of apples into boxes.
#
# Note that, apples from the same pack can be distributed into different boxes.
#
#
#
# Example 1:
#
# Input: apple = [1,3,2], capacity = [4,3,1,5,2]
# Output: 2
# Explanation: We will use boxes with capacities 4 and 5.
# It is possible to distribute the apples as the total capacity is greater than or equal to the total number of apples.
# Example 2:
#
# Input: apple = [5,5,5], capacity = [2,4,2,7]
# Output: 4
# Explanation: We will need to use all the boxes.
#
#
# Constraints:
#
# 1 <= n == apple.length <= 50
# 1 <= m == capacity.length <= 50
# 1 <= apple[i], capacity[i] <= 50
# The input is generated such that it's possible to redistribute packs of apples into boxes.
class Solution:
    def minimumBoxes(self, apple: List[int], capacity: List[int]) -> int:
        total: int = sum(apple)
        capacity.sort(reverse=True)
        count: int = 0
        for i in capacity:
            count += 1
            total -= i
            if total <= 0:
                return count

# 3075. Maximize Happiness of Selected Children
# You are given an array happiness of length n, and a positive integer k.
#
# There are n children standing in a queue, where the ith child has happiness value happiness[i]. You want to select k children from these n children in k turns.
#
# In each turn, when you select a child, the happiness value of all the children that have not been selected till now decreases by 1. Note that the happiness value cannot become negative and gets decremented only if it is positive.
#
# Return the maximum sum of the happiness values of the selected children you can achieve by selecting k children.
#
#
#
# Example 1:
#
# Input: happiness = [1,2,3], k = 2
# Output: 4
# Explanation: We can pick 2 children in the following way:
# - Pick the child with the happiness value == 3. The happiness value of the remaining children becomes [0,1].
# - Pick the child with the happiness value == 1. The happiness value of the remaining child becomes [0]. Note that the happiness value cannot become less than 0.
# The sum of the happiness values of the selected children is 3 + 1 = 4.
# Example 2:
#
# Input: happiness = [1,1,1,1], k = 2
# Output: 1
# Explanation: We can pick 2 children in the following way:
# - Pick any child with the happiness value == 1. The happiness value of the remaining children becomes [0,0,0].
# - Pick the child with the happiness value == 0. The happiness value of the remaining child becomes [0,0].
# The sum of the happiness values of the selected children is 1 + 0 = 1.
# Example 3:
#
# Input: happiness = [2,3,4,5], k = 1
# Output: 5
# Explanation: We can pick 1 child in the following way:
# - Pick the child with the happiness value == 5. The happiness value of the remaining children becomes [1,2,3].
# The sum of the happiness values of the selected children is 5.
#
#
# Constraints:
#
# 1 <= n == happiness.length <= 2 * 105
# 1 <= happiness[i] <= 108
# 1 <= k <= n
class Solution:
    def maximumHappinessSum(self, happiness: List[int], k: int) -> int:
        count: int = 0
        happiness.sort(reverse=True)
        for i in range(k):
            count += max(0, happiness[i] - i)
        return count

# 3076. Shortest Uncommon Substring in an Array
# You are given an array arr of size n consisting of non-empty strings.
#
# Find a string array answer of size n such that:
#
# answer[i] is the shortest
# substring
#  of arr[i] that does not occur as a substring in any other string in arr. If multiple such substrings exist, answer[i] should be the
# lexicographically smallest
# . And if no such substring exists, answer[i] should be an empty string.
# Return the array answer.
#
#
#
# Example 1:
#
# Input: arr = ["cab","ad","bad","c"]
# Output: ["ab","","ba",""]
# Explanation: We have the following:
# - For the string "cab", the shortest substring that does not occur in any other string is either "ca" or "ab", we choose the lexicographically smaller substring, which is "ab".
# - For the string "ad", there is no substring that does not occur in any other string.
# - For the string "bad", the shortest substring that does not occur in any other string is "ba".
# - For the string "c", there is no substring that does not occur in any other string.
# Example 2:
#
# Input: arr = ["abc","bcd","abcd"]
# Output: ["","","abcd"]
# Explanation: We have the following:
# - For the string "abc", there is no substring that does not occur in any other string.
# - For the string "bcd", there is no substring that does not occur in any other string.
# - For the string "abcd", the shortest substring that does not occur in any other string is "abcd".
#
#
# Constraints:
#
# n == arr.length
# 2 <= n <= 100
# 1 <= arr[i].length <= 20
# arr[i] consists only of lowercase English letters.
class Solution:
    def shortestSubstrings(self, arr):
        def generate_substrings(s):
            substrings = []
            for i in range(len(s)):
                for j in range(i + 1, len(s) + 1):
                    substrings.append(s[i:j])
            return substrings

        ans: list = list()
        for i in range(len(arr)):
            top: list = generate_substrings(arr[i])
            top.sort(key=lambda x: (len(x), x))
            exists: bool = False
            for j in top:
                seen: bool = False
                for k in range(len(arr)):
                    if i == k:
                        continue
                    if j in arr[k]:
                        seen = True
                        break
                if not seen:
                    ans.append(j)
                    exists = True
                    break
            if not exists:
                ans.append('')
        return ans

# 791. Custom Sort String
# You are given two strings order and s. All the characters of order are unique and were sorted in some custom order previously.
#
# Permute the characters of s so that they match the order that order was sorted. More specifically, if a character x occurs before a character y in order, then x should occur before y in the permuted string.
#
# Return any permutation of s that satisfies this property.
#
#
#
# Example 1:
#
# Input:  order = "cba", s = "abcd"
#
# Output:  "cbad"
#
# Explanation: "a", "b", "c" appear in order, so the order of "a", "b", "c" should be "c", "b", and "a".
#
# Since "d" does not appear in order, it can be at any position in the returned string. "dcba", "cdba", "cbda" are also valid outputs.
#
# Example 2:
#
# Input:  order = "bcafg", s = "abcd"
#
# Output:  "bcad"
#
# Explanation: The characters "b", "c", and "a" from order dictate the order for the characters in s. The character "d" in s does not appear in order, so its position is flexible.
#
# Following the order of appearance in order, "b", "c", and "a" from s should be arranged as "b", "c", "a". "d" can be placed at any position since it's not in order. The output "bcad" correctly follows this rule. Other arrangements like "bacd" or "bcda" would also be valid, as long as "b", "c", "a" maintain their order.
#
#
#
# Constraints:
#
# 1 <= order.length <= 26
# 1 <= s.length <= 200
# order and s consist of lowercase English letters.
# All the characters of order are unique.
# Solution
class Solution:
    def customSortString(self, order: str, s: str) -> str:
        ht1, ht2 = dict(), dict()
        ans: list = [''] * len(order)
        for i in range(len(order)):
            ht1[order[i]] = i
        for i in s:
            ht2[i] = ht2.get(i, 0) + 1
        for i in ht2:
            if i not in ht1:
                ans.append(i * ht2[i])
            else:
                ans[ht1[i]] = i * ht2[i]
        return ''.join(ans)

# Count the days!
# Little Annie is very excited for upcoming events. She wants to know how many days she has to wait for a specific event.
#
# Your job is to help her out.
#
# Task: Write a function which returns the number of days from today till the given date. The function will take a Date object as parameter. You have to round the amount of days.
#
# If the event is in the past, return "The day is in the past!"
# If the event is today, return "Today is the day!"
# Else, return "x days"
#
# PS: This is my first kata. I hope you have fun^^
#
# This kata is part of the Collection "Date fundamentals":
#
# #1 Count the Days!
# #2 Minutes to Midnight
# #3 Can Santa save Christmas?
# #4 Christmas Present Calculator
# DATE TIMEFUNDAMENTALS
from datetime import datetime
def count_days(event_date):
    today = datetime.today()
    diff = event_date - today
    days = round(diff.total_seconds() / (24*60*60))
    if days < 0:
        return "The day is in the past!"
    elif days == 0:
        return "Today is the day!"
    return f"{days} days"

# 1863. Sum of All Subset XOR Totals
# The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.
#
# For example, the XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1.
# Given an array nums, return the sum of all XOR totals for every subset of nums.
#
# Note: Subsets with the same elements should be counted multiple times.
#
# An array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b.
#
#
#
# Example 1:
#
# Input: nums = [1,3]
# Output: 6
# Explanation: The 4 subsets of [1,3] are:
# - The empty subset has an XOR total of 0.
# - [1] has an XOR total of 1.
# - [3] has an XOR total of 3.
# - [1,3] has an XOR total of 1 XOR 3 = 2.
# 0 + 1 + 3 + 2 = 6
# Example 2:
#
# Input: nums = [5,1,6]
# Output: 28
# Explanation: The 8 subsets of [5,1,6] are:
# - The empty subset has an XOR total of 0.
# - [5] has an XOR total of 5.
# - [1] has an XOR total of 1.
# - [6] has an XOR total of 6.
# - [5,1] has an XOR total of 5 XOR 1 = 4.
# - [5,6] has an XOR total of 5 XOR 6 = 3.
# - [1,6] has an XOR total of 1 XOR 6 = 7.
# - [5,1,6] has an XOR total of 5 XOR 1 XOR 6 = 2.
# 0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28
# Example 3:
#
# Input: nums = [3,4,5,6,7,8]
# Output: 480
# Explanation: The sum of all XOR totals for every subset is 480.
#
#
# Constraints:
#
# 1 <= nums.length <= 12
# 1 <= nums[i] <= 20
class Solution:
    from itertools import combinations
    def subsetXORSum(self, nums: List[int]) -> int:
        total: int = 0
        for i in range(len(nums) + 1):
            for subset in combinations(nums, i):
                xor: int = 0
                for num in subset:
                    xor ^= num
                total += xor
        return total
    
# Simple Fun #180: Repeat Adjacent
# Task
# You are given a string s.
#
# Let us call a substring of s with 2 or more adjacent identical letters a group (such as "aa", "bbb", "cccc"...).
#
# Let us call a substring of s with 2 or more adjacent groups a big group (such as "aabb","bbccc"...).
#
# Your task is to count the number of big groups in the given string.
#
# Examples
# "ccccoodeffffiiighhhhhhhhhhttttttts" => 3
#
# The groups are "cccc", "oo", "ffff", "iii", "hhhhhhhhhh", "ttttttt".
#
# The big groups are "ccccoo", "ffffiii", "hhhhhhhhhhttttttt".
#
# "gztxxxxxggggggggggggsssssssbbbbbeeeeeeehhhmmmmmmmitttttttlllllhkppppp" => 2
#
# The big groups are :
#
# "xxxxxggggggggggggsssssssbbbbbeeeeeeehhhmmmmmmm" and "tttttttlllll"
#
# "soooooldieeeeeer" => 0
#
# There is no big group.
#
# Input/Output
# [input] string s
#
# A string of lowercase Latin letters.
#
# [output] an integer
#
# The number of big groups.
#
# ALGORITHMS
def repeat_adjacent(st):
    count: int = 0
    lst: list = list()
    el, count_el = None, 0
    for i in st:
        if el is None:
            el, count_el = i, 1
        elif el == i:
            count_el += 1
        else:
            if count_el == 1:
                if len(lst) > 1:
                    count += 1
                lst.clear()
            else:
                lst.append(count_el)
            el, count_el = i, 1
    if count_el > 1:
        lst.append(count_el)
    if len(lst) > 1:
        count += 1
    return count

# 2485. Find the Pivot Integer
# Given a positive integer n, find the pivot integer x such that:
#
# The sum of all elements between 1 and x inclusively equals the sum of all elements between x and n inclusively.
# Return the pivot integer x. If no such integer exists, return -1. It is guaranteed that there will be at most one pivot index for the given input.
#
#
#
# Example 1:
#
# Input: n = 8
# Output: 6
# Explanation: 6 is the pivot integer since: 1 + 2 + 3 + 4 + 5 + 6 = 6 + 7 + 8 = 21.
# Example 2:
#
# Input: n = 1
# Output: 1
# Explanation: 1 is the pivot integer since: 1 = 1.
# Example 3:
#
# Input: n = 4
# Output: -1
# Explanation: It can be proved that no such integer exist.
#
#
# Constraints:
#
# 1 <= n <= 1000
class Solution:
    def pivotInteger(self, n: int) -> int:
        tmp: int = (n**2 + n) // 2
        square: int = int(tmp**.5)
        return square if square**2 == tmp else -1
    
# Sort the number sequence
# When no more interesting kata can be resolved, I just choose to create the new kata, to solve their own, to enjoy the process --myjinxin2015 said
#
# Description
# You are given a number sequence (an array) that contains some positive integer and zero.
#
# [3,2,1,0,5,6,4,0,1,5,3,0,4,2,8,0]
# It can be split to some zero-terminated sub sequence, such as [3,2,1,0], [5,6,4,0] ..
#
# Your task is: First, sort each sub sequence according to the ascending order (don't sort the zero, it always at the end); Second, sort all sub sequence according to their sum value (ascending order too).
#
# Arguments:
#
# sequence: The number sequence.
# Results & Note:
#
# The result is the sorted number sequence.
# If some sub sequences have the same sum value, sort them according to their original order.
# Some Examples
# sortSequence([3,2,1,0,5,6,4,0,1,5,3,0,4,2,8,0]) should return
# [1,2,3,0,1,3,5,0,2,4,8,0,4,5,6,0]
#
# sortSequence([3,2,1,0,5,6,4,0,1,5,3,0,2,2,2,0]) should return
# [1,2,3,0,2,2,2,0,1,3,5,0,4,5,6,0]
#
# sortSequence([2,2,2,0,5,6,4,0,1,5,3,0,3,2,1,0]) should return
# [2,2,2,0,1,2,3,0,1,3,5,0,4,5,6,0]
# PUZZLESSORTINGALGORITHMS
def sort_sequence(sequence):
    lst: list = list()
    top: list = list()
    for i in sequence:
        if i == 0:
            if top:
                lst.append(sorted(top))
                top.clear()
        else:
            top.append(i)
    if top:
        lst.append(top)
    lst.sort(key=lambda x: sum(x))
    ans: list = list()
    for i in lst:
        i += [0]
        ans.extend(i)
    return ans

# 930. Binary Subarrays With Sum
# Given a binary array nums and an integer goal, return the number of non-empty subarrays with a sum goal.
#
# A subarray is a contiguous part of the array.
#
#
#
# Example 1:
#
# Input: nums = [1,0,1,0,1], goal = 2
# Output: 4
# Explanation: The 4 subarrays are bolded and underlined below:
# [1,0,1,0,1]
# [1,0,1,0,1]
# [1,0,1,0,1]
# [1,0,1,0,1]
# Example 2:
#
# Input: nums = [0,0,0,0,0], goal = 0
# Output: 15
#
#
# Constraints:
#
# 1 <= nums.length <= 3 * 104
# nums[i] is either 0 or 1.
# 0 <= goal <= nums.length
class Solution:
    def numSubarraysWithSum(self, nums: List[int], goal: int) -> int:
        count: int = 0
        prefix_sum: int = 0
        ht: dict = {0: 1}
        for i in nums:
            prefix_sum += i
            count += ht.get(prefix_sum - goal, 0)
            ht[prefix_sum] = ht.get(prefix_sum, 0) + 1
        return count
        
# packing rectangles
# Problem statement
# Packing multiple rectangles of varying widths and heights in an enclosing rectangle of minimum area. Given 3 rectangular boxes, find minimal area that they can be placed. Boxes can not overlap, these can only be placed on the floor.
#
# Input
# 3 pairs of numbers come to the input - the lengths(a1, b1, a2, b2, a3, b3) of the sides of the boxes. (1 ⩽ ai, bi ⩽ 10^4)
#
# Output
# Return a number equal to the minimum occupied area.
#
# Example
# Input example:
#
# packing_rectangles(4,10,5,11,12,3)
# Output example:
#
# 144
# ALGORITHMS
def packing_rectangles(a1, b1, a2, b2, a3, b3):
    def area(w, h):
        return w * h
    orientations = [
        (a1, b1, a2, b2, a3, b3),
        (a1, b1, b2, a2, a3, b3),
        (b1, a1, a2, b2, a3, b3),
        (b1, a1, b2, a2, a3, b3),
        (a1, b1, a2, b2, b3, a3),
        (a1, b1, b2, a2, b3, a3),
        (b1, a1, a2, b2, b3, a3),
        (b1, a1, b2, a2, b3, a3)
    ]
    min_area = float('inf')
    for orientation in orientations:
        w1, h1, w2, h2, w3, h3 = orientation
        min_area = min(min_area, area(w1 + w2 + w3, max(h1, h2, h3)))
        min_area = min(min_area, area(max(w1 + w2, w3), h1 + h2 + h3))
        min_area = min(min_area, area(max(w1 + w3, w2), h1 + h3 + h2))
        min_area = min(min_area, area(max(w2 + w3, w1), h2 + h3 + h1))
        min_area = min(min_area, area(w1 + max(w2, w3), max(h1, h2 + h3)))
        min_area = min(min_area, area(w2 + max(w1, w3), max(h2, h1 + h3)))
        min_area = min(min_area, area(w3 + max(w1, w2), max(h3, h1 + h2)))
        min_area = min(min_area, area(max(w1, w2, w3), h1 + h2 + h3))
    return min_area

# 238. Product of Array Except Self
# Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].
#
# The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.
#
# You must write an algorithm that runs in O(n) time and without using the division operation.
#
#
#
# Example 1:
#
# Input: nums = [1,2,3,4]
# Output: [24,12,8,6]
# Example 2:
#
# Input: nums = [-1,1,0,-3,3]
# Output: [0,0,9,0,0]
#
#
# Constraints:
#
# 2 <= nums.length <= 105
# -30 <= nums[i] <= 30
# The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.
#
#
# Follow up: Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space for space complexity analysis.)
# Soluition O(N) O(N) - but in the task its O(1)
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        output: list = list()
        prev, post = 1, 1
        for i in nums:
            output.append(prev)
            prev *= i
        for i in range(len(nums) - 1, -1, -1):
            output[i] *= post
            post *= nums[i]
        return output
    
# Simple Fun #268: Triangular Sum
# Task
# Triangular numbers are defined by the formula n * (n + 1) / 2 with n starting from 1. They count the number of objects that can form an equilateral triangle as shown in the picture below:
#
#
#
# So the sequence of triangular numbers begins as follows:
#
# 1, 3, 6, 10, 15, 21, 28, ....
#
# It is proven that the sum of squares of any two consecutive triangular numbers is equal to another triangular number.
#
# You're given a triangular number n. Return true if it can be represented as a sum of squares of two consecutive triangular numbers, or false otherwise.
#
# Input/Output
# [input] integer n
#
# A positive triangular number
#
# 3 ≤ n ≤ 10^9
#
# [output] a boolean value
#
# true if it is possible to represent n as the sum of squares of two consecutive triangular numbers, and false otherwise.
#
# Example
# For n = 6, the output should be false.
#
# No two squared consecutive triangular numbers add up to 6.
#
# For n = 45, the output should be true.
#
# 3 * 3 + 6 * 6 = 9 + 36 = 45
#
# PUZZLES
def triangular_sum(n):
    k = 1
    T_k = k * (k + 1) // 2
    while True:
        T_next = (k + 1) * (k + 2) // 2
        sum_of_squares = T_k**2 + T_next**2
        if sum_of_squares == n:
            return True
        if sum_of_squares > n:
            return False
        k += 1
        T_k = T_next
        
# 525. Contiguous Array
# Given a binary array nums, return the maximum length of a contiguous subarray with an equal number of 0 and 1.
#
#
#
# Example 1:
#
# Input: nums = [0,1]
# Output: 2
# Explanation: [0, 1] is the longest contiguous subarray with an equal number of 0 and 1.
# Example 2:
#
# Input: nums = [0,1,0]
# Output: 2
# Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.
#
#
# Constraints:
#
# 1 <= nums.length <= 105
# nums[i] is either 0 or 1.
class Solution:
    def findMaxLength(self, nums: List[int]) -> int:
        ht: dict = dict()
        count: int = 0
        ans: int = 0
        for i in range(len(nums)):
            count += 1 if nums[i] == 1 else -1
            if count == 0:
                ans = max(ans, i + 1)
            elif count in ht:
                ans = max(ans, i - ht[count])
            else:
                ht[count] = i
        return ans

# Simple Fun #155: Pac-Man
# Task
# Pac-Man got lucky today! Due to minor performance issue all his enemies have frozen. Too bad Pac-Man is not brave enough to face them right now, so he doesn't want any enemy to see him.
#
# Given a gamefield of size N x N, Pac-Man's position(PM) and his enemies' positions(enemies), your task is to count the number of coins he can collect without being seen.
#
# An enemy can see a Pac-Man if they are standing on the same row or column.
#
# It is guaranteed that no enemy can see Pac-Man on the starting position. There is a coin on each empty square (i.e. where there is no Pac-Man or enemy).
#
# Example
# For N = 4, PM = [3, 0], enemies = [[1, 2]], the result should be 3.
#
# Let O represent coins, P - Pac-Man and E - enemy.
# OOOO
# OOEO
# OOOO
# POOO
# Pac-Man cannot cross row 1 and column 2.
#
# He can only collect coins from points (2, 0), (2, 1) and (3, 1), like this:
#
# x is the points that Pac-Man can collect the coins.
# OOOO
# OOEO
# xxOO
# PxOO
# Input/Output
# [input] integer N
# The field size.
#
# [input] integer array PM
# Pac-Man's position (pair of integers)
#
# [input] 2D integer array enemies
# Enemies' positions (array of pairs)
#
# [output] an integer
# Number of coins Pac-Man can collect.
#
# More PacMan Katas
# Play PacMan: Devour all
#
# Play PacMan 2: The way home
#
# ALGORITHMSPUZZLES
def pac_man(n, pm, enemies):
    mtrx: list = [[True] * n for i in range(n)]
    ans: int = 0
    for i in enemies:
        for j in range(n):
            mtrx[i[0]][j] = False
            mtrx[j][i[1]] = False
            if pm[1] < i[1]:
                for rows in range(i[1], n):
                    print(j, rows)
                    mtrx[j][rows] = False
            else:
                for rows in range(i[1] + 1):
                    mtrx[j][rows] = False
    for i in enemies:
        if pm[0] > i[0]:
            for r in range(i[0] + 1):
                for c in range(n):
                    mtrx[r][c] = False
        else:
            for r in range(i[0], n):
                for c in range(n):
                    mtrx[r][c] = False
    for i in range(n):
        for j in range(n):
            ans += mtrx[i][j]
    return ans - 1

# 57. Insert Interval
# You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.
#
# Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).
#
# Return intervals after the insertion.
#
# Note that you don't need to modify intervals in-place. You can make a new array and return it.
#
#
#
# Example 1:
#
# Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
# Output: [[1,5],[6,9]]
# Example 2:
#
# Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
# Output: [[1,2],[3,10],[12,16]]
# Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].
#
#
# Constraints:
#
# 0 <= intervals.length <= 104
# intervals[i].length == 2
# 0 <= starti <= endi <= 105
# intervals is sorted by starti in ascending order.
# newInterval.length == 2
# 0 <= start <= end <= 105
class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        ans: list = list()
        x, y = newInterval[0], newInterval[1]
        seen: bool = False
        added: bool = False
        for i in intervals:
            if i[0] > newInterval[1]: # Current interval more than newInterval
                if seen: # if we making overlap
                    ans.append([x, y])
                    seen = False
                    ans.append(i)
                else:
                    if not added: # if we not added newInterval
                        ans.append(newInterval)
                    ans.append(i)
                added = True
            elif i[0] < newInterval[0] and i[1] < newInterval[0]: # current interval less than newInterval
                ans.append(i)
            elif not added: # Current interval can make overlap with newInterval
                seen = True
                x, y = min(x, i[0]), max(y, i[1])
        if seen: # if we making overlap and overlap interval not adding in answer
            ans.append([x, y])
        elif not added: # if we not adding newInterval in answer
            ans.append([x, y])
        return ans
    
# The latest clock
# Write a function which receives 4 digits and returns the latest time of day that can be built with those digits.
#
# The time should be in HH:MM format.
#
# Examples:
#
# digits: 1, 9, 8, 3 => result: "19:38"
# digits: 9, 1, 2, 5 => result: "21:59" (19:25 is also a valid time, but 21:59 is later)
# Notes
# Result should be a valid 24-hour time, between 00:00 and 23:59.
# Only inputs which have valid answers are tested.
# DATE TIMEFUNDAMENTALSALGORITHMS
def latest_clock(*args):
    stock: list = list(args)
    mx: int = float('-inf')
    for i in range(len(stock)):
        for j in range(len(stock)):
            if i == j: continue
            for k in range(len(stock)):
                if k == j or k == i: continue
                for l in range(len(stock)):
                    if l == i or l == j or l == k: continue
                    x: int = stock[i] * 1000 + stock[j] * 100 + stock[k] * 10 + stock[l]
                    if ((stock[i]  == 2 and stock[j] < 4) or (stock[i] < 2 and stock[j] < 10)) and stock[k] < 6:
                        mx = max(mx, x)
    if mx == 0:
        return '00:00'
    if mx < 1000:
        if mx % 1000 > 2:
            return '0' + str(mx)[:1] + ':' + str(mx)[1:]
    return str(mx)[:2] + ':' + str(mx)[2:]

# 3079. Find the Sum of Encrypted Integers
# You are given an integer array nums containing positive integers. We define a function encrypt such that encrypt(x) replaces every digit in x with the largest digit in x. For example, encrypt(523) = 555 and encrypt(213) = 333.
#
# Return the sum of encrypted elements.
#
#
#
# Example 1:
#
# Input: nums = [1,2,3]
#
# Output: 6
#
# Explanation: The encrypted elements are [1,2,3]. The sum of encrypted elements is 1 + 2 + 3 == 6.
#
# Example 2:
#
# Input: nums = [10,21,31]
#
# Output: 66
#
# Explanation: The encrypted elements are [11,22,33]. The sum of encrypted elements is 11 + 22 + 33 == 66.
#
#
#
# Constraints:
#
# 1 <= nums.length <= 50
# 1 <= nums[i] <= 1000
class Solution:
    def sumOfEncryptedInt(self, nums: List[int]) -> int:
        total: int = 0
        for i in nums:
            total += int(max(str(i)) * len(str(i)))
        return total

# 3083. Existence of a Substring in a String and Its Reverse
# Given a string s, find any
# substring
#  of length 2 which is also present in the reverse of s.
#
# Return true if such a substring exists, and false otherwise.
#
#
#
# Example 1:
#
# Input: s = "leetcode"
#
# Output: true
#
# Explanation: Substring "ee" is of length 2 which is also present in reverse(s) == "edocteel".
#
# Example 2:
#
# Input: s = "abcba"
#
# Output: true
#
# Explanation: All of the substrings of length 2 "ab", "bc", "cb", "ba" are also present in reverse(s) == "abcba".
#
# Example 3:
#
# Input: s = "abcd"
#
# Output: false
#
# Explanation: There is no substring of length 2 in s, which is also present in the reverse of s.
#
#
#
# Constraints:
#
# 1 <= s.length <= 100
# s consists only of lowercase English letters.
class Solution:
    def isSubstringPresent(self, s: str) -> bool:
        hs: set = set()
        rev: str = s[::-1]
        for i in range(len(s) - 1):
            hs.add(rev[i:i+2])
        for i in range(len(s) - 1):
            if s[i:i + 2] in hs:
                return True
        return False

# 3084. Count Substrings Starting and Ending with Given Character
# You are given a string s and a character c. Return the total number of
# substrings
#  of s that start and end with c.
#
#
#
# Example 1:
#
# Input: s = "abada", c = "a"
#
# Output: 6
#
# Explanation: Substrings starting and ending with "a" are: "abada", "abada", "abada", "abada", "abada", "abada".
#
# Example 2:
#
# Input: s = "zzz", c = "z"
#
# Output: 6
#
# Explanation: There are a total of 6 substrings in s and all start and end with "z".
#
#
#
# Constraints:
#
# 1 <= s.length <= 105
# s and c consist only of lowercase English letters.
class Solution:
    def countSubstrings(self, s: str, c: str) -> int:
        count: int = s.count(c)
        return count * (count + 1) // 2

# 452. Minimum Number of Arrows to Burst Balloons
# There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.
#
# Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart <= x <= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.
#
# Given the array points, return the minimum number of arrows that must be shot to burst all balloons.
#
#
#
# Example 1:
#
# Input: points = [[10,16],[2,8],[1,6],[7,12]]
# Output: 2
# Explanation: The balloons can be burst by 2 arrows:
# - Shoot an arrow at x = 6, bursting the balloons [2,8] and [1,6].
# - Shoot an arrow at x = 11, bursting the balloons [10,16] and [7,12].
# Example 2:
#
# Input: points = [[1,2],[3,4],[5,6],[7,8]]
# Output: 4
# Explanation: One arrow needs to be shot for each balloon for a total of 4 arrows.
# Example 3:
#
# Input: points = [[1,2],[2,3],[3,4],[4,5]]
# Output: 2
# Explanation: The balloons can be burst by 2 arrows:
# - Shoot an arrow at x = 2, bursting the balloons [1,2] and [2,3].
# - Shoot an arrow at x = 4, bursting the balloons [3,4] and [4,5].
#
#
# Constraints:
#
# 1 <= points.length <= 105
# points[i].length == 2
# -231 <= xstart < xend <= 231 - 1
class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        points.sort(key=lambda x: x[1])
        pos: int = float('-inf')
        ans: int = 0
        for i in points:
            if pos < i[0]:
                ans += 1
                pos = i[1]
        return ans
    
# Group Anagrams
# Your job is to group the words in anagrams.
#
# What is an anagram ?
# star and tsar are anagram of each other because you can rearrange the letters for star to obtain tsar.
#
# Example
# A typical test could be :
#
# // input
# ["tsar", "rat", "tar", "star", "tars", "cheese"]
#
# // output
# [
#   ["tsar", "star", "tars"],
#   ["rat", "tar"],
#   ["cheese"]
# ]
# Hvae unf !
#
# I'd advise you to find an efficient way for grouping the words in anagrams otherwise you'll probably won't pass the heavy superhero test cases
#
# ALGORITHMSDATA STRUCTURES
def group_anagrams(words):
    ht: dict = dict()
    for i in words:
        x: str = ''.join(sorted(i))
        ht[x] = ht.get(x, []) + [i]
    return ht.values()

# 1492. The kth Factor of n
# You are given two positive integers n and k. A factor of an integer n is defined as an integer i where n % i == 0.
#
# Consider a list of all factors of n sorted in ascending order, return the kth factor in this list or return -1 if n has less than k factors.
#
#
#
# Example 1:
#
# Input: n = 12, k = 3
# Output: 3
# Explanation: Factors list is [1, 2, 3, 4, 6, 12], the 3rd factor is 3.
# Example 2:
#
# Input: n = 7, k = 2
# Output: 7
# Explanation: Factors list is [1, 7], the 2nd factor is 7.
# Example 3:
#
# Input: n = 4, k = 4
# Output: -1
# Explanation: Factors list is [1, 2, 4], there is only 3 factors. We should return -1.
#
#
# Constraints:
#
# 1 <= k <= n <= 1000
#
#
# Follow up:
#
# Could you solve this problem in less than O(n) complexity?
class Solution:
    def kthFactor(self, n: int, k: int) -> int:
        count: int = 0
        for i in range(1, n + 1):
            if n % i == 0:
                count += 1
                if count == k:
                    return i
        return -1

# 1309. Decrypt String from Alphabet to Integer Mapping
# You are given a string s formed by digits and '#'. We want to map s to English lowercase characters as follows:
#
# Characters ('a' to 'i') are represented by ('1' to '9') respectively.
# Characters ('j' to 'z') are represented by ('10#' to '26#') respectively.
# Return the string formed after mapping.
#
# The test cases are generated so that a unique mapping will always exist.
#
#
#
# Example 1:
#
# Input: s = "10#11#12"
# Output: "jkab"
# Explanation: "j" -> "10#" , "k" -> "11#" , "a" -> "1" , "b" -> "2".
# Example 2:
#
# Input: s = "1326#"
# Output: "acz"
#
#
# Constraints:
#
# 1 <= s.length <= 1000
# s consists of digits and the '#' letter.
# s will be a valid string such that mapping is always possible.
# Solution O(N) O(N)
class Solution:
    def freqAlphabets(self, s: str) -> str:
        ans: list = list()
        for i in range(len(s)):
            if s[i] == '#':
                if ans:
                    ans.pop()
                    ans.pop()
                ans.append(chr(96 + int(s[i-2:i])))
            else:
                ans.append(chr(96 + int(s[i])))
        return ''.join(ans)

# Area and perimeter of the ellipse
# Task:
# Based on the received dimensions, a and b, of an ellipse, calculare its area and perimeter.
#
# Example:
# Input: ellipse(5,2)
#
# Output: "Area: 31.4, perimeter: 23.1"
# Note: The perimeter approximation formula you should use: π * (3/2(a+b) - sqrt(ab))
#
# Have fun :)
# FUNDAMENTALS
from math import pi
def ellipse(a, b):
    return f'Area: {round(pi * a * b, 1)}, perimeter: {round(pi * (3 / 2 * (a + b) - (a * b)**.5), 1)}'

# 1669. Merge In Between Linked Lists
# You are given two linked lists: list1 and list2 of sizes n and m respectively.
#
# Remove list1's nodes from the ath node to the bth node, and put list2 in their place.
#
# The blue edges and nodes in the following figure indicate the result:
#
#
# Build the result list and return its head.
#
#
#
# Example 1:
#
#
# Input: list1 = [10,1,13,6,9,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]
# Output: [10,1,13,1000000,1000001,1000002,5]
# Explanation: We remove the nodes 3 and 4 and put the entire list2 in their place. The blue edges and nodes in the above figure indicate the result.
# Example 2:
#
#
# Input: list1 = [0,1,2,3,4,5,6], a = 2, b = 5, list2 = [1000000,1000001,1000002,1000003,1000004]
# Output: [0,1,1000000,1000001,1000002,1000003,1000004,6]
# Explanation: The blue edges and nodes in the above figure indicate the result.
#
#
# Constraints:
#
# 3 <= list1.length <= 104
# 1 <= a <= b < list1.length - 1
# 1 <= list2.length <= 104
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:
        tmp = list1
        ans = ListNode()
        new_tmp = ans
        tail = list1
        step_for_tail = -1
        step_for_a = -1
        while step_for_tail != b:
            tail = tail.next
            step_for_tail += 1
        while step_for_a < a - 1:
            new_tmp.next = tmp
            new_tmp, tmp = new_tmp.next, tmp.next
            step_for_a += 1
        while list2:
            new_tmp.next = list2
            new_tmp, list2 = new_tmp.next, list2.next
        while tail:
            new_tmp.next = tail
            new_tmp, tail = new_tmp.next, tail.next
        return ans.next

# Sum of Intervals
# Write a function called sumIntervals/sum_intervals that accepts an array of intervals, and returns the sum of all the interval lengths. Overlapping intervals should only be counted once.
#
# Intervals
# Intervals are represented by a pair of integers in the form of an array. The first value of the interval will always be less than the second value. Interval example: [1, 5] is an interval from 1 to 5. The length of this interval is 4.
#
# Overlapping Intervals
# List containing overlapping intervals:
#
# [
#    [1, 4],
#    [7, 10],
#    [3, 5]
# ]
# The sum of the lengths of these intervals is 7. Since [1, 4] and [3, 5] overlap, we can treat the interval as [1, 5], which has a length of 4.
#
# Examples:
# sumIntervals( [
#    [1, 2],
#    [6, 10],
#    [11, 15]
# ] ) => 9
#
# sumIntervals( [
#    [1, 4],
#    [7, 10],
#    [3, 5]
# ] ) => 7
#
# sumIntervals( [
#    [1, 5],
#    [10, 20],
#    [1, 6],
#    [16, 19],
#    [5, 11]
# ] ) => 19
#
# sumIntervals( [
#    [0, 20],
#    [-100000000, 10],
#    [30, 40]
# ] ) => 100000030
# Tests with large intervals
# Your algorithm should be able to handle large intervals. All tested intervals are subsets of the range [-1000000000, 1000000000].
#
# ALGORITHMSPERFORMANCE
def sum_of_intervals(intervals):
    intervals.sort(key=lambda x: x[0])
    ans, x, y = 0, None, None
    for i in intervals:
        if x is None:
            x, y = i
        elif y >= i[0]:
            y = max(y, i[1])
        else:
            ans += y - x
            x, y = i
    ans += y - x
    return ans

# 206. Reverse Linked List
# Given the head of a singly linked list, reverse the list, and return the reversed list.
#
#
#
# Example 1:
#
#
# Input: head = [1,2,3,4,5]
# Output: [5,4,3,2,1]
# Example 2:
#
#
# Input: head = [1,2]
# Output: [2,1]
# Example 3:
#
# Input: head = []
# Output: []
#
#
# Constraints:
#
# The number of nodes in the list is the range [0, 5000].
# -5000 <= Node.val <= 5000
#
#
# Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both?
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head):
        if not head:
            return head
        prev = None
        current = head
        while current:
            nxt = current.next
            current.next = prev
            prev = current
            current = nxt
        head = prev
        return head
    
# Minutes to Midnight
# Teemo is not really excited about the new year's eve, but he has to celebrate it with his friends anyway.
#
# He has a really big passion about programming and he wants to be productive till midnight. He wants to know how many minutes he has left to work on his new project.
# He doesn't want to look on the clock all the time, so he thought about a function, which returns him the number of minutes.
#
# Can you write him a function, so he can stay productive?
#
# The function minutesToMidnight(d) will take a date object as parameter. Return the number of minutes in the following format:
#
# "x minute(s)"
#
# You will always get a date object with of today with a random timestamp.
# You have to round the number of minutes.
# Milliseconds doesn't matter!
#
#
# Some examples:
#
#
#
# 10.00 am => "840 minutes"
#
# 23.59 pm => "1 minute"
#
#
# This kata is part of the Collection "Date fundamentals":
# #1 Count the Days!
# #2 Minutes to Midnight
# #3 Can Santa save Christmas?
# #4 Christmas Present Calculator
# DATE TIMEFUNDAMENTALS
from datetime import datetime as dt
def minutes_to_midnight(d):
    x = dt(year=d.year, month=d.month, day=d.day + 1, hour=0, minute=0, second=0)
    s = round((x - d).total_seconds() / 60)
    return f'{s} {"minutes" if s > 1 else "minute"}'

# 234. Palindrome Linked List
# Given the head of a singly linked list, return true if it is a
# palindrome
#  or false otherwise.
#
#
#
# Example 1:
#
#
# Input: head = [1,2,2,1]
# Output: true
# Example 2:
#
#
# Input: head = [1,2]
# Output: false
#
#
# Constraints:
#
# The number of nodes in the list is in the range [1, 105].
# 0 <= Node.val <= 9
#
#
# Follow up: Could you do it in O(n) time and O(1) space?
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def isPalindrome(self, head: Optional[ListNode]) -> bool:
        stack: list = list()
        tmp, n = head, 0
        while tmp:
            stack.append(tmp.val)
            tmp, n = tmp.next, n+ 1
        left, right = 0, n - 1
        while left <= right:
            if stack[left] != stack[right]:
                return False
            left, right = left + 1, right - 1
        return True
    
# Collapse Left
# Task
# Write a function that takes an array containing numbers and functions. The output of the function should be an array of only numbers. So how are we to remove the functions from the array?
#
# All functions must be applied to the number before it prior to the function being discarded from the array. It is as if the functions are collapsing left in the array modifying the first number to the left of the function. The functions should apply in order of index in the array. After a function has been applied to the number before it, it should be "removed" from the array to allow any following functions to also modify that new number.
#
# Example
# [ 3, f(x) = x + 2, f(x) = x * 5, 4, f(x) = x - 1 ] => [ 25, 3 ]
# because
#
# [ (3 + 2) * 5, 4 - 1 ]
# Note how all functions collapsed into the closest number to the left; they did not produce new numbers into the array, but modified existing ones.
#
# Notes
# If a function comes first in the array, it should behave as if it were passed in 0:
# [ f(x) = x + 2, 4 ] => [0 + 2, 4]
# An empty array passed in must return an empty array.
# Functions will always take exactly one, number, parameter.
# If an array only contains numbers, the array should be returned without any modifications.
# ARRAYS
# Suggest kata description edits
def operationArguments(arr):
    ans: list = list()
    for i in range(len(arr)):
        if not isinstance(arr[i], int):
            if i == 0:
                ans.append(arr[i](0))
            else:
                ans.append(arr[i](ans.pop()))
        else:
            ans.append(arr[i])
    return ans

# 143. Reorder List
# You are given the head of a singly linked-list. The list can be represented as:
#
# L0 → L1 → … → Ln - 1 → Ln
# Reorder the list to be on the following form:
#
# L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
# You may not modify the values in the list's nodes. Only nodes themselves may be changed.
#
#
#
# Example 1:
#
#
# Input: head = [1,2,3,4]
# Output: [1,4,2,3]
# Example 2:
#
#
# Input: head = [1,2,3,4,5]
# Output: [1,5,2,4,3]
#
#
# Constraints:
#
# The number of nodes in the list is in the range [1, 5 * 104].
# 1 <= Node.val <= 1000
class Solution:
    def reorderList(self, head):
        # Floyd Algorithm
        if not head: return []
        slow, fast = head, head
        while fast.next and fast.next.next:
            slow = slow.next
            fast = fast.next.next
        # Reversing right half of linked list
        prev, curr = None, slow.next
        while curr:
            nextt = curr.next
            curr.next = prev
            prev = curr
            curr = nextt
        slow.next = None
        # Merging two halfs by Two Pointers Approach
        left, right = head, prev
        while right:
            nextt = left.next
            left.next = right
            left = right
            right = nextt
            
# Rotten Oranges
# Wait long enough and a single rotten orange can turn a whole box of oranges to trash.
#
# You will be given a box of oranges. Find out how long it takes until all oranges are rotten.
#
# a rotten orange will rot every neighboring orange (use Von Neumann neighborhood)
# a box of oranges will be given to you as an int[][] orangeBox (or a list of lists orange_box in Python)
# all inner lists have an equal length
# rotten oranges are represented by 2
# fresh oranges are represented by 1
# empty spaces are represented by 0
# return an int value noting the time needed to fully rot the box
# return -1 in case the box will never completely rot
# Example:
# orangeBox:
#
# 2 1 1
# 1 1 1
# orangeBox after 1 time unit:
#
# 2 2 1
# 2 1 1
# orangeBox after 2 time units:
#
# 2 2 2
# 2 2 1
# orangeBox after 3 time units:
#
# 2 2 2
# 2 2 2
# The box is now fully rotten. Result: 3.
#
# FUNDAMENTALS
def calc_rot_time(box):
    mtrx: list[int] = [[-1]  + i + [-1] for i in box]
    mtrx.insert(0, [-1] * (len(box[0]) + 2))
    mtrx.append([-1] * (len(box[0]) + 2))
    new_mtrx: list[int] = list()
    mtrx_moves: list[int] = [[-1, 0], [1, 0], [0, -1], [0, 1]]
    hazard: bool = True
    count: int = 0
    while hazard:
        hazard = False
        rows: list[int] = list()
        for i in range(len(mtrx)):
            for j in range(len(mtrx[0])):
                if mtrx[i][j] == 1:
                    for position in mtrx_moves:
                        if mtrx[i + position[0]][j + position[1]] == 2:
                            hazard = True
                            rows.append(2)
                            break
                    else:
                        rows.append(1)
                else:
                    rows.append(mtrx[i][j])
            new_mtrx.append(rows)
            rows = []
        if hazard:
            mtrx = new_mtrx
            new_mtrx = []
            count += 1
    if all(mtrx[i][j] in {0, 2} for j in range(1, len(mtrx[0]) - 1) for i in range(1, len(mtrx) - 1)):
        return count
    return -1

# 287. Find the Duplicate Number
# Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.
#
# There is only one repeated number in nums, return this repeated number.
#
# You must solve the problem without modifying the array nums and uses only constant extra space.
#
#
#
# Example 1:
#
# Input: nums = [1,3,4,2,2]
# Output: 2
# Example 2:
#
# Input: nums = [3,1,3,4,2]
# Output: 3
# Example 3:
#
# Input: nums = [3,3,3,3,3]
# Output: 3
#
#
# Constraints:
#
# 1 <= n <= 105
# nums.length == n + 1
# 1 <= nums[i] <= n
# All the integers in nums appear only once except for precisely one integer which appears two or more times.
#
#
# Follow up:
#
# How can we prove that at least one duplicate number must exist in nums?
# Can you solve the problem in linear runtime complexity?
# Solution Array Stack O(N) O(N)
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        array: list[bool] = [True] * len(nums)
        for i in nums:
            if array[i-1]:
                array[i-1] = False
            else:
                return i
# Solution Slow and Fast Pointers O(N) O(1)
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        slow, fast = nums[0], nums[0]
        while True:
            slow = nums[slow]
            fast = nums[nums[fast]]
            if slow == fast:
                break
        slow = nums[0]
        while slow != fast:
            slow, fast = nums[slow], nums[fast]
        return slow
    
# Simple Events
# Your goal is to write an Event constructor function, which can be used to make event objects.
#
# An event object should work like this:
#
# it has a .subscribe() method, which takes a function and stores it as its handler
# it has an .unsubscribe() method, which takes a function and removes it from its handlers
# it has an .emit() method, which takes an arbitrary number of arguments and calls all the stored functions with these arguments
# As this is an elementary example of events, there are some simplifications:
#
# all functions are called with correct arguments (e.g. only functions will be passed to unsubscribe)
# you should not worry about the order of handlers' execution
# the handlers will not attempt to modify an event object (e.g. add or remove handlers)
# the context of handlers' execution is not important
# each handler will be subscribed at most once at any given moment of time. It can still be unsubscribed and then subscribed again
# Also see an example test fixture for suggested usage
#
# DESIGN PATTERNSEVENT HANDLINGFUNDAMENTALS
class Event():
    def __init__(self):
        self.stack: list = list()
    def subscribe(self, func):
        self.stack.append(func)
    def unsubscribe(self, func):
        self.stack.remove(func)
    def emit(self, *args):
        for f in self.stack:
            f(*args)
            
# 442. Find All Duplicates in an Array
# Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears once or twice, return an array of all the integers that appears twice.
#
# You must write an algorithm that runs in O(n) time and uses only constant extra space.
#
#
#
# Example 1:
#
# Input: nums = [4,3,2,7,8,2,3,1]
# Output: [2,3]
# Example 2:
#
# Input: nums = [1,1,2]
# Output: [1]
# Example 3:
#
# Input: nums = [1]
# Output: []
#
#
# Constraints:
#
# n == nums.length
# 1 <= n <= 105
# 1 <= nums[i] <= n
# Each element in nums appears once or twice.
# Solution HashTable O(N) O(N)
class Solution:
    def findDuplicates(self, nums: List[int]) -> List[int]:
        ht: dict = dict()
        for i in nums:
            ht[i] = ht.get(i, 0) + 1
        return [i for i in ht if ht[i] > 1]
# Solution OnePass O(N) O(1)
class Solution:
    def findDuplicates(self, nums: List[int]) -> List[int]:
        ans: list = list()
        for i in nums:
            if nums[abs(i) - 1] < 0:
                ans.append(abs(i))
            else:
                nums[abs(i) - 1] *= -1
        return ans
    
# Land perimeter
# Given an array arr of strings, complete the function by calculating the total perimeter of all the islands. Each piece of land will be marked with 'X' while the water fields are represented as 'O'. Consider each tile being a perfect 1 x 1 piece of land. Some examples for better visualization:
#
# ['XOOXO',
#  'XOOXO',
#  'OOOXO',
#  'XXOXO',
#  'OXOOO']
# which represents:
#
# should return: "Total land perimeter: 24".
#
# Following input:
#
# ['XOOO',
#  'XOXO',
#  'XOXO',
#  'OOXX',
#  'OOOO']
# which represents:
#
# should return: "Total land perimeter: 18"
#
# FUNDAMENTALS
def land_perimeter(arr):
    count: int = 0
    moves: list[list[int, int]] = [[-1, 0], [1, 0], [0, -1], [0, 1]]
    arr = ['s' + i + 's' for i in arr]
    arr.append('s' * (len(arr[0])))
    arr.insert(0, 's' * (len(arr[0])))
    for rows in range(len(arr)):
        for column in range(len(arr[0])):
            if arr[rows][column] == 'X':
                for move in moves:
                    if arr[rows + move[0]][column + move[1]] != 'X':
                        count += 1
    return f'Total land perimeter: {count}'

# 1313. Decompress Run-Length Encoded List
# We are given a list nums of integers representing a list compressed with run-length encoding.
#
# Consider each adjacent pair of elements [freq, val] = [nums[2*i], nums[2*i+1]] (with i >= 0).  For each such pair, there are freq elements with value val concatenated in a sublist. Concatenate all the sublists from left to right to generate the decompressed list.
#
# Return the decompressed list.
#
#
#
# Example 1:
#
# Input: nums = [1,2,3,4]
# Output: [2,4,4,4]
# Explanation: The first pair [1,2] means we have freq = 1 and val = 2 so we generate the array [2].
# The second pair [3,4] means we have freq = 3 and val = 4 so we generate [4,4,4].
# At the end the concatenation [2] + [4,4,4] is [2,4,4,4].
# Example 2:
#
# Input: nums = [1,1,2,3]
# Output: [1,3,3]
#
#
# Constraints:
#
# 2 <= nums.length <= 100
# nums.length % 2 == 0
# 1 <= nums[i] <= 100
class Solution:
    def decompressRLElist(self, nums: List[int]) -> List[int]:
        ans: list[int] = list()
        for i in range(0, len(nums), 2):
            ans.extend([nums[i + 1]] * nums[i])
        return ans

# Pick peaks
# In this kata, you will write a function that returns the positions and the values of the "peaks" (or local maxima) of a numeric array.
#
# For example, the array arr = [0, 1, 2, 5, 1, 0] has a peak at position 3 with a value of 5 (since arr[3] equals 5).
#
# The output will be returned as an object with two properties: pos and peaks. Both of these properties should be arrays. If there is no peak in the given array, then the output should be {pos: [], peaks: []}.
#
# Example: pickPeaks([3, 2, 3, 6, 4, 1, 2, 3, 2, 1, 2, 3]) should return {pos: [3, 7], peaks: [6, 3]} (or equivalent in other languages)
#
# All input arrays will be valid integer arrays (although it could still be empty), so you won't need to validate the input.
#
# The first and last elements of the array will not be considered as peaks (in the context of a mathematical function, we don't know what is after and before and therefore, we don't know if it is a peak or not).
#
# Also, beware of plateaus !!! [1, 2, 2, 2, 1] has a peak while [1, 2, 2, 2, 3] and [1, 2, 2, 2, 2] do not. In case of a plateau-peak, please only return the position and value of the beginning of the plateau. For example: pickPeaks([1, 2, 2, 2, 1]) returns {pos: [1], peaks: [2]} (or equivalent in other languages)
#
# Have fun!
#
# ARRAYSALGORITHMS
def pick_peaks(arr):
    ans: dict = {'pos': list(), 'peaks': list()}
    stack: list[int] = list()
    if not arr or len(arr) < 3:
        return ans
    for i in range(1, len(arr) - 1):
        if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]:
            if stack:
                stack = []
            ans['pos'] = ans.get('pos', []) + [i]
            ans['peaks'] = ans.get('peaks', []) + [arr[i]]
        elif (not stack and arr[i] > arr[i - 1] and arr[i] >= arr[i + 1]) or (stack and arr[i] >= arr[i + 1] and arr[i] >= arr[i - 1]):
            if stack and arr[i] > arr[i + 1]:
                ans['pos'] = ans.get('pos', []) + [stack[0]]
                ans['peaks'] = ans.get('peaks', []) + [arr[stack[0]]]
                print(stack)
                stack = []
            else:
                stack.append(i)
        elif stack:
            stack = []
    if stack and arr[stack[0] - 1] == arr[-1] and arr[stack[0]] > arr[-1]:
        ans['pos'] = ans.get('pos', []) + [stack[0]]
        ans['peaks'] = ans.get('peaks', []) + [arr[stack[0]]]
    return ans

# 713. Subarray Product Less Than K
# Given an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k.
#
#
#
# Example 1:
#
# Input: nums = [10,5,2,6], k = 100
# Output: 8
# Explanation: The 8 subarrays that have product less than 100 are:
# [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]
# Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.
# Example 2:
#
# Input: nums = [1,2,3], k = 0
# Output: 0
#
#
# Constraints:
#
# 1 <= nums.length <= 3 * 104
# 1 <= nums[i] <= 1000
# 0 <= k <= 106
class Solution:
    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        ans: int = 0
        total: int = 1
        left, right = 0, 0
        while left < len(nums) and right < len(nums):
            total *= nums[right]
            while right >= left and total >= k:
                total /= nums[left]
                left += 1
            ans += right + 1 - left
            right += 1
        return ans

# PatternCraft - Strategy
# The Strategy Design Pattern can be used, for example, to determine how a unit moves in the StarCraft game.
#
# The pattern consists in having a different strategy to one functionality. A unit, for example, could move by walking or flying.
#
# Your Task
# Complete the code so that when a Viking is flying its position increases by 10 each time it moves. If it is walking then the position is increased by 1.
#
# In this Kata, Viking starts as a ground unit when it is created.
#
# You have 3 classes:
#
# Viking: has a position, moveBehavior and move method.
# Fly and Walk: the move behaviors with the move(unit) method. Fly has to move 10 positions at a time and Walk has to move 1.
# Resouces
# PatternCraft > Strategy
# SourceMaking > Strategy
# Wikipedia > Strategy
# PatternCraft series
# State Pattern
# Strategy Pattern
# Visitor Pattern
# Decorator Pattern
# Adapter Pattern
# Command Pattern
# The original PatternCraft series (by John Lindquist) is a collection of Youtube videos that explains some of the design patterns and how they are used (or could be) on StarCraft.
#
# DESIGN PATTERNSFUNDAMENTALS
class Fly():
    def move(self, unit):
        return 10


class Walk():
    def move(self, unit):
        return 1


class Viking():
    def __init__(self):
        self.position = 0
        self.move_behavior = Walk()

    def move(self):
        self.position += self.move_behavior.move(self)
        
# 2958. Length of Longest Subarray With at Most K Frequency
# You are given an integer array nums and an integer k.
#
# The frequency of an element x is the number of times it occurs in an array.
#
# An array is called good if the frequency of each element in this array is less than or equal to k.
#
# Return the length of the longest good subarray of nums.
#
# A subarray is a contiguous non-empty sequence of elements within an array.
#
#
#
# Example 1:
#
# Input: nums = [1,2,3,1,2,3,1,2], k = 2
# Output: 6
# Explanation: The longest possible good subarray is [1,2,3,1,2,3] since the values 1, 2, and 3 occur at most twice in this subarray. Note that the subarrays [2,3,1,2,3,1] and [3,1,2,3,1,2] are also good.
# It can be shown that there are no good subarrays with length more than 6.
# Example 2:
#
# Input: nums = [1,2,1,2,1,2,1,2], k = 1
# Output: 2
# Explanation: The longest possible good subarray is [1,2] since the values 1 and 2 occur at most once in this subarray. Note that the subarray [2,1] is also good.
# It can be shown that there are no good subarrays with length more than 2.
# Example 3:
#
# Input: nums = [5,5,5,5,5,5,5], k = 4
# Output: 4
# Explanation: The longest possible good subarray is [5,5,5,5] since the value 5 occurs 4 times in this subarray.
# It can be shown that there are no good subarrays with length more than 4.
#
#
# Constraints:
#
# 1 <= nums.length <= 105
# 1 <= nums[i] <= 109
# 1 <= k <= nums.length
class Solution:
    def maxSubarrayLength(self, nums: List[int], k: int) -> int:
        ans: int = 0
        ht: dict = dict()
        left: int = 0
        for right in range(len(nums)):
            ht[nums[right]] = ht.get(nums[right], 0) + 1
            while ht[nums[right]] > k:
                ht[nums[left]] -= 1
                left += 1
            ans = max(ans, right + 1 - left)
        return ans

# Sort sentence pseudo-alphabetically
# Given a standard english sentence passed in as a string, write a method that will return a sentence made up of the same words, but sorted by their first letter. However, the method of sorting has a twist to it:
#
# All words that begin with a lower case letter should be at the beginning of the sorted sentence, and sorted in ascending order.
# All words that begin with an upper case letter should come after that, and should be sorted in descending order.
# If a word appears multiple times in the sentence, it should be returned multiple times in the sorted sentence. Any punctuation must be discarded.
#
# Example
# For example, given the input string "Land of the Old Thirteen! Massachusetts land! land of Vermont and Connecticut!", your method should return "and land land of of the Vermont Thirteen Old Massachusetts Land Connecticut". Lower case letters are sorted a -> l -> l -> o -> o -> t and upper case letters are sorted V -> T -> O -> M -> L -> C.
#
# SORTINGSTRINGSALGORITHMS
def pseudo_sort(st):
    l, u = list(), list()
    for i in st.split():
        x = i
        while x and not x[-1].isalpha():
            x = x[:-1]
        if x and x[0].isupper():
            u.append(x)
        elif x:
            l.append(x)
    l.sort()
    u.sort(reverse=True)
    ans = l + u
    return ' '.join(ans)

# 2962. Count Subarrays Where Max Element Appears at Least K Times
# You are given an integer array nums and a positive integer k.
#
# Return the number of subarrays where the maximum element of nums appears at least k times in that subarray.
#
# A subarray is a contiguous sequence of elements within an array.
#
#
#
# Example 1:
#
# Input: nums = [1,3,2,3,3], k = 2
# Output: 6
# Explanation: The subarrays that contain the element 3 at least 2 times are: [1,3,2,3], [1,3,2,3,3], [3,2,3], [3,2,3,3], [2,3,3] and [3,3].
# Example 2:
#
# Input: nums = [1,4,2,1], k = 3
# Output: 0
# Explanation: No subarray contains the element 4 at least 3 times.
#
#
# Constraints:
#
# 1 <= nums.length <= 105
# 1 <= nums[i] <= 106
# 1 <= k <= 105
class Solution:
    def countSubarrays(self, nums: List[int], k: int) -> int:
        ans: int = 0
        count_sub: int = 0
        left, mx = 0, max(nums)
        for right in range(len(nums)):
            count_sub += nums[right] == mx
            while count_sub >= k:
                count_sub -= nums[left] == mx
                left += 1
            ans += left
        return ans
    
# Simple Fun #58: Volleyball Positions
# Task
# You are watching a volleyball tournament, but you missed the beginning of the very first game of your favorite team. Now you're curious about how the coach arranged the players on the field at the start of the game.
#
# The team you favor plays in the following formation:
#
# 0 3 0
# 4 0 2
# 0 6 0
# 5 0 1
# where positive numbers represent positions occupied by players. After the team gains the serve, its members rotate one position in a clockwise direction, so the player in position 2 moves to position 1, the player in position 3 moves to position 2, and so on, with the player in position 1 moving to position 6.
#
# Here's how the players change their positions:
#
#
#
# Given the current formation of the team and the number of times k it gained the serve, find the initial position of each player in it.
#
# Example
# For
#
# formation = [["empty",   "Player5", "empty"],
#              ["Player4", "empty",   "Player2"],
#              ["empty",   "Player3", "empty"],
#              ["Player6", "empty",   "Player1"]]
# and k = 2
# the output should be
#
# [
#     ["empty",   "Player1", "empty"],
#     ["Player2", "empty",   "Player3"],
#     ["empty",   "Player4", "empty"],
#     ["Player5", "empty",   "Player6"]
# ]
# For
#
# formation = [["empty", "Alice", "empty"],
#              ["Bob",   "empty", "Charlie"],
#              ["empty", "Dave",  "empty"],
#              ["Eve",   "empty", "Frank"]]
# and k = 6
# the output should be
#
#   [
#     ["empty", "Alice", "empty"],
#     ["Bob",   "empty", "Charlie"],
#     ["empty", "Dave",  "empty"],
#     ["Eve",   "empty", "Frank"]
# ]
# Input
# 2D string array formation
#
# A 4 × 3 array of strings representing names of the players in the positions corresponding to those in the schema above.
#
# It is guaranteed that for each empty position the corresponding element of formation is "empty".
#
# It is also guaranteed that there is no player called "empty" in the team.
#
# Integer k
#
# The number of times the team gained the serve.
#
# Constraints: 0 ≤ k ≤ 1000000000.
#
# Output
# 2D string array
#
# Team arrangement at the start of the game.
#
# PUZZLES
def volleyball_positions(formation, k):
    steps: int = k % 6
    mtrx_moves: list = [[3, 2], [2, 1], [3, 0], [1, 0], [0, 1], [1, 2]]
    new_mtrx: list = list()
    for rows in range(4):
        top: list = list()
        for columns in range(3):
            if formation[rows][columns] != 'empty':
                idx: int = (mtrx_moves.index([rows, columns]) + steps)
                if idx > 5:
                    idx %= 6
                top.append(formation[mtrx_moves[idx][0]][mtrx_moves[idx][1]])
            else:
                top.append(formation[rows][columns])
        new_mtrx.append(top)
    return new_mtrx

# 1534. Count Good Triplets
# Given an array of integers arr, and three integers a, b and c. You need to find the number of good triplets.
#
# A triplet (arr[i], arr[j], arr[k]) is good if the following conditions are true:
#
# 0 <= i < j < k < arr.length
# |arr[i] - arr[j]| <= a
# |arr[j] - arr[k]| <= b
# |arr[i] - arr[k]| <= c
# Where |x| denotes the absolute value of x.
#
# Return the number of good triplets.
#
#
#
# Example 1:
#
# Input: arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3
# Output: 4
# Explanation: There are 4 good triplets: [(3,0,1), (3,0,1), (3,1,1), (0,1,1)].
# Example 2:
#
# Input: arr = [1,1,2,2,3], a = 0, b = 0, c = 1
# Output: 0
# Explanation: No triplet satisfies all conditions.
#
#
# Constraints:
#
# 3 <= arr.length <= 100
# 0 <= arr[i] <= 1000
# 0 <= a, b, c <= 1000
class Solution:
    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:
        ans: int = 0
        for i in range(len(arr)):
            for j in range(i + 1, len(arr)):
                if abs(arr[i] - arr[j]) > a:
                    continue
                for k in range(j + 1, len(arr)):
                    if abs(arr[j] - arr[k]) > b:
                        continue
                    elif abs(arr[i]  - arr[k]) <= c:
                        ans += 1
        return ans

# Simple Fun #72: Absolute Values Sum Minimization
# Task
# Given a sorted array of integers A, find such an integer x that the value of abs(A[0] - x) + abs(A[1] - x) + ... + abs(A[A.length - 1] - x) is the smallest possible (here abs denotes the absolute value).
#
# If there are several possible answers, output the smallest one.
#
# Example
# For A = [2, 4, 7], the output should be 4.
#
# Input/Output
# [input] integer array A
#
# A non-empty array of integers, sorted in ascending order.
#
# Constraints:
#
# 1 ≤ A.length ≤ 200,
#
# -1000000 ≤ A[i] ≤ 1000000.
#
# [output] an integer
#
# PUZZLES
def absolute_values_sum_minimization(lst):
    sm: int = float('inf')
    ans: int = -1
    for i in lst:
        x: int = sum(abs(j - i) for j in lst)
        if x < sm:
            sm, ans = x, i
    return ans

# 38. Count and Say
# The count-and-say sequence is a sequence of digit strings defined by the recursive formula:
#
# countAndSay(1) = "1"
# countAndSay(n) is the way you would "say" the digit string from countAndSay(n-1), which is then converted into a different digit string.
# To determine how you "say" a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.
#
# For example, the saying and conversion for digit string "3322251":
#
#
# Given a positive integer n, return the nth term of the count-and-say sequence.
#
#
#
# Example 1:
#
# Input: n = 1
# Output: "1"
# Explanation: This is the base case.
# Example 2:
#
# Input: n = 4
# Output: "1211"
# Explanation:
# countAndSay(1) = "1"
# countAndSay(2) = say "1" = one 1 = "11"
# countAndSay(3) = say "11" = two 1's = "21"
# countAndSay(4) = say "21" = one 2 + one 1 = "12" + "11" = "1211"
#
#
# Constraints:
#
# 1 <= n <= 30
class Solution:
    def countAndSay(self, n: int) -> str:
        permut: str = '1'
        for rep in range(n - 1):
            new_permut: list = list()
            count: int = 0
            prev_digit: str = None
            for digit in permut:
                if prev_digit is None:
                    prev_digit, count = digit, 1
                elif digit != prev_digit:
                    new_permut.append(str(count) + prev_digit)
                    prev_digit, count = digit, 1
                else:
                    count += 1
            if count > 0:
                new_permut.append(str(count) + prev_digit)
            permut = ''.join(new_permut)
        return permut

# 3090. Maximum Length Substring With Two Occurrences
# Given a string s, return the maximum length of a
# substring
#  such that it contains at most two occurrences of each character.
#
#
# Example 1:
#
# Input: s = "bcbbbcba"
#
# Output: 4
#
# Explanation:
#
# The following substring has a length of 4 and contains at most two occurrences of each character: "bcbbbcba".
# Example 2:
#
# Input: s = "aaaa"
#
# Output: 2
#
# Explanation:
#
# The following substring has a length of 2 and contains at most two occurrences of each character: "aaaa".
#
#
# Constraints:
#
# 2 <= s.length <= 100
# s consists only of lowercase English letters.
class Solution:
    def maximumLengthSubstring(self, s: str) -> int:
        ans: int = 0
        ht: dict = dict()
        left: int = 0
        for right in range(len(s)):
            ht[s[right]] = ht.get(s[right], 0) + 1
            while ht[s[right]] > 2:
                ht[s[left]] -= 1
                left += 1
            ans = max(ans, right + 1 - left)
        return ans

# 3091. Apply Operations to Make Sum of Array Greater Than or Equal to k
# You are given a positive integer k. Initially, you have an array nums = [1].
#
# You can perform any of the following operations on the array any number of times (possibly zero):
#
# Choose any element in the array and increase its value by 1.
# Duplicate any element in the array and add it to the end of the array.
# Return the minimum number of operations required to make the sum of elements of the final array greater than or equal to k.
#
#
#
# Example 1:
#
# Input: k = 11
#
# Output: 5
#
# Explanation:
#
# We can do the following operations on the array nums = [1]:
#
# Increase the element by 1 three times. The resulting array is nums = [4].
# Duplicate the element two times. The resulting array is nums = [4,4,4].
# The sum of the final array is 4 + 4 + 4 = 12 which is greater than or equal to k = 11.
# The total number of operations performed is 3 + 2 = 5.
#
# Example 2:
#
# Input: k = 1
#
# Output: 0
#
# Explanation:
#
# The sum of the original array is already greater than or equal to 1, so no operations are needed.
#
#
#
# Constraints:
#
# 1 <= k <= 105
class Solution:
    def minOperations(self, k: int) -> int:
        if k == 1:
            return 0
        ans: int = float('inf')
        for i in range(1, k+1):
            count = i - 1
            sm = i
            while sm < k:
                count += 1
                sm += i
            ans = min(ans, count)
        return ans

# 3095. Shortest Subarray With OR at Least K I
# You are given an array nums of non-negative integers and an integer k.
#
# An array is called special if the bitwise OR of all of its elements is at least k.
#
# Return the length of the shortest special non-empty
# subarray
#  of nums, or return -1 if no special subarray exists.
#
#
#
# Example 1:
#
# Input: nums = [1,2,3], k = 2
#
# Output: 1
#
# Explanation:
#
# The subarray [3] has OR value of 3. Hence, we return 1.
#
# Example 2:
#
# Input: nums = [2,1,8], k = 10
#
# Output: 3
#
# Explanation:
#
# The subarray [2,1,8] has OR value of 11. Hence, we return 3.
#
# Example 3:
#
# Input: nums = [1,2], k = 0
#
# Output: 1
#
# Explanation:
#
# The subarray [1] has OR value of 1. Hence, we return 1.
#
#
#
# Constraints:
#
# 1 <= nums.length <= 50
# 0 <= nums[i] <= 50
# 0 <= k < 64
class Solution:
    def minimumSubarrayLength(self, nums: List[int], k: int) -> int:
        ans = float('inf')
        for i in range(len(nums)):
            top_or: int = 0
            for j in range(i, len(nums)):
                top_or |= nums[j]
                if top_or >= k:
                    ans = min(ans, j - i + 1)
                    break
        return ans if ans != float('inf') else -1


# 3096. Minimum Levels to Gain More Points
# You are given a binary array possible of length n.
#
# Danielchandg and Bob are playing a game that consists of n levels. Some of the levels in the game are impossible to clear while others can always be cleared. In particular, if possible[i] == 0, then the ith level is impossible to clear for both the players. A player gains 1 point on clearing a level and loses 1 point if the player fails to clear it.
#
# At the start of the game, Danielchandg will play some levels in the given order starting from the 0th level, after which Bob will play for the rest of the levels.
#
# Danielchandg wants to know the minimum number of levels he should play to gain more points than Bob, if both players play optimally to maximize their points.
#
# Return the minimum number of levels danielchandg should play to gain more points. If this is not possible, return -1.
#
# Note that each player must play at least 1 level.
#
#
#
# Example 1:
#
# Input: possible = [1,0,1,0]
#
# Output: 1
#
# Explanation:
#
# Let's look at all the levels that Danielchandg can play up to:
#
# If Danielchandg plays only level 0 and Bob plays the rest of the levels, Danielchandg has 1 point, while Bob has -1 + 1 - 1 = -1 point.
# If Danielchandg plays till level 1 and Bob plays the rest of the levels, Danielchandg has 1 - 1 = 0 points, while Bob has 1 - 1 = 0 points.
# If Danielchandg plays till level 2 and Bob plays the rest of the levels, Danielchandg has 1 - 1 + 1 = 1 point, while Bob has -1 point.
# Danielchandg must play a minimum of 1 level to gain more points.
#
# Example 2:
#
# Input: possible = [1,1,1,1,1]
#
# Output: 3
#
# Explanation:
#
# Let's look at all the levels that Danielchandg can play up to:
#
# If Danielchandg plays only level 0 and Bob plays the rest of the levels, Danielchandg has 1 point, while Bob has 4 points.
# If Danielchandg plays till level 1 and Bob plays the rest of the levels, Danielchandg has 2 points, while Bob has 3 points.
# If Danielchandg plays till level 2 and Bob plays the rest of the levels, Danielchandg has 3 points, while Bob has 2 points.
# If Danielchandg plays till level 3 and Bob plays the rest of the levels, Danielchandg has 4 points, while Bob has 1 point.
# Danielchandg must play a minimum of 3 levels to gain more points.
#
# Example 3:
#
# Input: possible = [0,0]
#
# Output: -1
#
# Explanation:
#
# The only possible way is for both players to play 1 level each. Danielchandg plays level 0 and loses 1 point. Bob plays level 1 and loses 1 point. As both players have equal points, Danielchandg can't gain more points than Bob.
#
#
#
# Constraints:
#
# 2 <= n == possible.length <= 105
# possible[i] is either 0 or 1.
class Solution:
    def minimumLevels(self, possible: List[int]) -> int:
        all_ones: int = sum(possible)
        all_zeros: int = sum(i == 0 for i in possible)
        total: int = 0
        for i in range(len(possible) - 1):
            if possible[i] == 1:
                all_ones, total = all_ones - 1, total + 1
            else:
                total, all_zeros = total - 1, all_zeros - 1
            if total > all_ones - all_zeros:
                return i + 1
        return -1

# Simple fraction to mixed number converter
    # Task
# Given a string representing a simple fraction x/y, your function must return a string representing the corresponding mixed fraction in the following format:
#
# [sign]a b/c
#
# where a is integer part and b/c is irreducible proper fraction. There must be exactly one space between a and b/c. Provide [sign] only if negative (and non zero) and only at the beginning of the number (both integer part and fractional part must be provided absolute).
#
# If the x/y equals the integer part, return integer part only. If integer part is zero, return the irreducible proper fraction only. In both of these cases, the resulting string must not contain any spaces.
#
# Division by zero should raise an error (preferably, the standard zero division error of your language).
#
# Value ranges
# -10 000 000 < x < 10 000 000
# -10 000 000 < y < 10 000 000
# Examples
# Input: 42/9, expected result: 4 2/3.
# Input: 6/3, expedted result: 2.
# Input: 4/6, expected result: 2/3.
# Input: 0/18891, expected result: 0.
# Input: -10/7, expected result: -1 3/7.
# Inputs 0/0 or 3/0 must raise a zero division error.
# Note
# Make sure not to modify the input of your function in-place, it is a bad practice.
#
# FUNDAMENTALS
    def comprare(x: int, y: int, positive: bool) -> str:
        gcd: int = 1
        for i in range(2, x + 1):
            if x % i == 0 and y % i == 0:
                gcd = i
        return f'{(x // gcd) if positive else (x // gcd * -1)}/{y // gcd}'


def mixed_fraction(s):
    x, y = map(int, s.split('/'))
    if y == 0:
        raise DivisionByZero
    if x == 0:
        return '0'
    positive: bool = x > 0 and y > 0 or (x < 0 and y < 0)
    x, y = abs(x), abs(y)
    if x == y:
        return '1' if positive else '-1'
    if abs(x) > y:
        if x % y == 0:
            return str(x // y) if positive else '-' + str(x // y)
        full: int = x // y
        x = x - y * full
        if not positive:
            full = abs(full) * -1
        return f'{full} {comprare(x, y, True)}'
    return comprare(x, y, positive)

# 3099. Harshad Number
# An integer divisible by the sum of its digits is said to be a Harshad number. You are given an integer x. Return the sum of the digits of x if x is a Harshad number, otherwise, return -1.
#
#
#
# Example 1:
#
# Input: x = 18
#
# Output: 9
#
# Explanation:
#
# The sum of digits of x is 9. 18 is divisible by 9. So 18 is a Harshad number and the answer is 9.
#
# Example 2:
#
# Input: x = 23
#
# Output: -1
#
# Explanation:
#
# The sum of digits of x is 5. 23 is not divisible by 5. So 23 is not a Harshad number and the answer is -1.
#
#
#
# Constraints:
#
# 1 <= x <= 100
class Solution:
    def sumOfTheDigitsOfHarshadNumber(self, x: int) -> int:
        sm: int = sum(int(i) for i in str(x))
        return sm if x % sm == 0 else -1
        
# 3100. Water Bottles II
# You are given two integers numBottles and numExchange.
#
# numBottles represents the number of full water bottles that you initially have. In one operation, you can perform one of the following operations:
#
# Drink any number of full water bottles turning them into empty bottles.
# Exchange numExchange empty bottles with one full water bottle. Then, increase numExchange by one.
# Note that you cannot exchange multiple batches of empty bottles for the same value of numExchange. For example, if numBottles == 3 and numExchange == 1, you cannot exchange 3 empty water bottles for 3 full bottles.
#
# Return the maximum number of water bottles you can drink.
#
#
#
# Example 1:
#
#
# Input: numBottles = 13, numExchange = 6
# Output: 15
# Explanation: The table above shows the number of full water bottles, empty water bottles, the value of numExchange, and the number of bottles drunk.
# Example 2:
#
#
# Input: numBottles = 10, numExchange = 3
# Output: 13
# Explanation: The table above shows the number of full water bottles, empty water bottles, the value of numExchange, and the number of bottles drunk.
#
#
# Constraints:
#
# 1 <= numBottles <= 100
# 1 <= numExchange <= 100
class Solution:
    def maxBottlesDrunk(self, numBottles: int, numExchange: int) -> int:
        ans: int = 0
        empty_bottles: int = 0
        while True:
            if numBottles > 0:
                ans += numBottles
                empty_bottles += numBottles
                numBottles = 0
            while empty_bottles >= numExchange:
                numBottles += 1
                empty_bottles -= numExchange
                numExchange += 1
            if numBottles == 0:
                return ans

# 3101. Count Alternating Subarrays
# You are given a
# binary array
#  nums.
#
# We call a
# subarray
#  alternating if no two adjacent elements in the subarray have the same value.
#
# Return the number of alternating subarrays in nums.
#
#
#
# Example 1:
#
# Input: nums = [0,1,1,1]
#
# Output: 5
#
# Explanation:
#
# The following subarrays are alternating: [0], [1], [1], [1], and [0,1].
#
# Example 2:
#
# Input: nums = [1,0,1,0]
#
# Output: 10
#
# Explanation:
#
# Every subarray of the array is alternating. There are 10 possible subarrays that we can choose.
#
#
#
# Constraints:
#
# 1 <= nums.length <= 105
# nums[i] is either 0 or 1.
class Solution:
    def countAlternatingSubarrays(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return 1
        ans: int = 0
        ln: int = 0
        for i in range(len(nums) - 1):
            ln += 1
            if nums[i] == nums[i + 1]:
                ans += ln * (ln + 1) // 2
                ln = 0
        if len(nums) > 1:
            if nums[-1] != nums[-2]:
                ln += 1
            else:
                ln = 1
            ans += ln * (ln + 1) // 2
        return ans

# 58. Length of Last Word
# Given a string s consisting of words and spaces, return the length of the last word in the string.
#
# A word is a maximal
# substring
#  consisting of non-space characters only.
#
#
#
# Example 1:
#
# Input: s = "Hello World"
# Output: 5
# Explanation: The last word is "World" with length 5.
# Example 2:
#
# Input: s = "   fly me   to   the moon  "
# Output: 4
# Explanation: The last word is "moon" with length 4.
# Example 3:
#
# Input: s = "luffy is still joyboy"
# Output: 6
# Explanation: The last word is "joyboy" with length 6.
#
#
# Constraints:
#
# 1 <= s.length <= 104
# s consists of only English letters and spaces ' '.
# There will be at least one word in s.
class Solution:
    def lengthOfLastWord(self, s: str) -> int:
        left = right = len(s) - 1
        while right > 0 and s[right] == ' ':
            right -= 1
        left = right
        while left >= 0 and s[left] != ' ':
            left -= 1
        return right - left

# PatternCraft - State
# The State Design Pattern can be used, for example, to manage the state of a tank in the StarCraft game.
#
# The pattern consists in isolating the state logic in different classes rather than having multiple ifs to determine what should happen.
#
# Your Task
# Complete the code so that when a Tank goes into SiegeMode it cannot move and its damage goes to 20. When it goes to TankMode it should be able to move and the damage should be set to 5.
#
# You have 3 classes:
#
# Tank: has a state, canMove and damage properties
# SiegeState and TankState: has canMove and damage properties
# Note: The tank initial state should be TankState.
#
# Resources
# PatternCraft > State
# SourceMaking > State
# Wikipedia > State
# PatternCraft series
# State Pattern
# Strategy Pattern
# Visitor Pattern
# Decorator Pattern
# Adapter Pattern
# Command Pattern
# The original PatternCraft series (by John Lindquist) is a collection of Youtube videos that explains some of the design patterns and how they are used (or could be) on StarCraft.
#
# DESIGN PATTERNSFUNDAMENTALS
class SiegeState:
    def can_move(self):
        return False
    def damage(self):
        return 20

class TankState:
    def can_move(self):
        return True
    def damage(self):
        return 5
class Tank:
    def __init__(self, state=None):
        self.state = state if state is not None else TankState()
    def can_move(self):
        return self.state.can_move()
    def damage(self):
        return self.state.damage()

# 205. Isomorphic Strings
# Given two strings s and t, determine if they are isomorphic.
#
# Two strings s and t are isomorphic if the characters in s can be replaced to get t.
#
# All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.
#
#
#
# Example 1:
#
# Input: s = "egg", t = "add"
# Output: true
# Example 2:
#
# Input: s = "foo", t = "bar"
# Output: false
# Example 3:
#
# Input: s = "paper", t = "title"
# Output: true
#
#
# Constraints:
#
# 1 <= s.length <= 5 * 104
# t.length == s.length
# s and t consist of any valid ascii character.
class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        ht1, ht2 = dict(), dict()
        for i in range(len(s)):
            if ht1.get(s[i], 0) != ht2.get(t[i], 0):
                return False
            if (s[i] == s[max(i - 1, 0)] and t[i] != t[max(i - 1, 0)]) or (s[i] != s[max(i - 1, 0)] and t[i] == t[max(i - 1, 0)]):
                return False
            ht1[s[i]] = i
            ht2[t[i]] = i
        return ht1.get(s[-1], 0) == ht2.get(t[-1], 0)

# Christmas Present Calculator
# Christmas Present Calculator
# After we find out if Santa can save Christmas there is another task to face.
#
# Santa's little helper aren't sick anymore. They are ready to give away presents again. But some of them are still weak.
# This leads to more productive elves than others.
#
# How many presents can Santa distribute this christmas?
#
# Your Task:
# You will get two inputs.
# One dictionary with the producitivity of each elf like the following:
#
# {"Santa": 1, "elf_1": 1, "elf_2": 1, "elf_3": 2, "elf_4": 3}
#
# and a string array with the time needed for each present like the following:
#
# "hh:mm:ss"
#
# The productivity describes the workload an elf can do each day:
#
# //productivity 1 = 24 hours each day
# //productivity 2 = 48 hours each day
# ...
#
# Return the number of present they can distribute at maximum.
#
# Note that:
#
# They have only 24 hours
# They try to give out as much as presents as possible (the ones with less time first)
# All the elves can work on multiple tasks. You can count it as one work capacity
#
#
# This kata is part of the Collection "Date fundamentals":
# #1 Count the Days!
# #2 Minutes to Midnight
# #3 Can Santa save Christmas?
# #4 How Many Presents?
# DATE TIMEFUNDAMENTALS
from datetime import timedelta as td


def convert(arr: list[str]) -> list[int]:
    ans: list[int] = list()
    for time in arr:
        hours, minutes, seconds = map(int, time.split(':'))
        if hours >= 24:
            total_seconds: int = int(hours * 3600 + minutes * 60 + seconds)
        else:
            total_seconds: int = int(td(hours=hours, minutes=minutes, seconds=seconds).total_seconds())
        ans.append(total_seconds)
    return ans


def count_presents(prod: dict, pres: list[str]) -> int:
    times: list[int] = sorted(convert(pres))
    count: int = 0
    powers: int = sum(time * 24 * 3600 for time in prod.values())
    for gift in times:
        if powers >= gift:
            count += 1
            powers -= gift
        else:
            break
    return count

# 1725. Number Of Rectangles That Can Form The Largest Square
# You are given an array rectangles where rectangles[i] = [li, wi] represents the ith rectangle of length li and width wi.
#
# You can cut the ith rectangle to form a square with a side length of k if both k <= li and k <= wi. For example, if you have a rectangle [4,6], you can cut it to get a square with a side length of at most 4.
#
# Let maxLen be the side length of the largest square you can obtain from any of the given rectangles.
#
# Return the number of rectangles that can make a square with a side length of maxLen.
#
#
#
# Example 1:
#
# Input: rectangles = [[5,8],[3,9],[5,12],[16,5]]
# Output: 3
# Explanation: The largest squares you can get from each rectangle are of lengths [5,3,5,5].
# The largest possible square is of length 5, and you can get it out of 3 rectangles.
# Example 2:
#
# Input: rectangles = [[2,3],[3,7],[4,3],[3,7]]
# Output: 3
#
#
# Constraints:
#
# 1 <= rectangles.length <= 1000
# rectangles[i].length == 2
# 1 <= li, wi <= 109
# li != wi
class Solution:
    def countGoodRectangles(self, rectangles: List[List[int]]) -> int:
        mx, count = 0, 0
        for i in rectangles:
            if mx == min(i):
                count += 1
            elif mx < min(i):
                mx, count = min(i), 1
        return count
    
# Game Hit the target - 2nd part
# This is the second part of the kata :3 🎈🎆🎇🎆🎈
# given a matrix n x n (2-7), determine if the arrow is directed to the target (x).
# Now there are one of 4 types of arrows ( '^', '>', 'v', '<' ) and only one target (x)
# An empty spot will be denoted by a space " ", the target with a cross "x", and the scope ">"
# Examples:
# given matrix 4x4:
# [
#
#   [' ', 'x', ' ', ' '],
#
#   [' ', ' ', ' ', ' '], --> return true
#
#   [' ', '^', ' ', ' '],
#
#   [' ', ' ', ' ', ' ']
#
# ]
# given matrix 4x4:
# [
#
#   [' ', ' ', ' ', ' '],
#
#   [' ', 'v', ' ', ' '], --> return false
#
#   [' ', ' ', ' ', 'x'],
#
#   [' ', ' ', ' ', ' ']
#
# ]
# given matrix 4x4:
# [
#
#   [' ', ' ', ' ', ' '],
#
#   ['>', ' ', ' ', 'x'], --> return true
#
#   [' ', '', ' ', ' '],
#
#   [' ', ' ', ' ', ' ']
#
# ]
#
# In this example, only a 4x4 matrix was used, the problem will have matrices of dimensions from 2 to 7
# And here is the first part of this kata - click me ●v●
# Happy hacking as they say! 💻
#
# MATRIXARRAYSSTRINGSFUNDAMENTALS
def solution(mtrx):
    for rows in range(len(mtrx)):
        for columns in range(len(mtrx[0])):
            if mtrx[rows][columns] == '^':
                x: int = rows
                while x > 0:
                    x -= 1
                    if mtrx[x][columns] == 'x':
                        return True
                return False
            elif mtrx[rows][columns] == 'v':
                x: int = rows
                while x < len(mtrx) - 1:
                    x += 1
                    if mtrx[x][columns] == 'x':
                        return True
                return False
            elif mtrx[rows][columns] == '>':
                x: int = columns
                while x < len(mtrx[0]) - 1:
                    x += 1
                    if mtrx[rows][x] == 'x':
                        return True
                return False
            elif mtrx[rows][columns] == '<':
                x: int = columns
                while x > 0:
                    x -= 1
                    if mtrx[rows][x] == 'x':
                        return True
                return False
    return False


# 1614. Maximum Nesting Depth of the Parentheses
# A string is a valid parentheses string (denoted VPS) if it meets one of the following:
#
# It is an empty string "", or a single character not equal to "(" or ")",
# It can be written as AB (A concatenated with B), where A and B are VPS's, or
# It can be written as (A), where A is a VPS.
# We can similarly define the nesting depth depth(S) of any VPS S as follows:
#
# depth("") = 0
# depth(C) = 0, where C is a string with a single character not equal to "(" or ")".
# depth(A + B) = max(depth(A), depth(B)), where A and B are VPS's.
# depth("(" + A + ")") = 1 + depth(A), where A is a VPS.
# For example, "", "()()", and "()(()())" are VPS's (with nesting depths 0, 1, and 2), and ")(" and "(()" are not VPS's.
#
# Given a VPS represented as string s, return the nesting depth of s.
#
#
#
# Example 1:
#
# Input: s = "(1+(2*3)+((8)/4))+1"
# Output: 3
# Explanation: Digit 8 is inside of 3 nested parentheses in the string.
# Example 2:
#
# Input: s = "(1)+((2))+(((3)))"
# Output: 3
#
#
# Constraints:
#
# 1 <= s.length <= 100
# s consists of digits 0-9 and characters '+', '-', '*', '/', '(', and ')'.
# It is guaranteed that parentheses expression s is a VPS.
# Solution One Pass Stack O(N) O(N)
class Solution:
    def maxDepth(self, s: str) -> int:
        stack: list[str] = list()
        depth: int = 0
        ans: int = 0
        for i in s:
            if i == '(':
                depth += 1
                stack.append(i)
            elif i == ')':
                ans, depth = max(ans, depth), depth - 1
                if not stack: # if stack is empty and we meet )
                    continue
                stack.pop()
        return ans
    
# Statistics for an Athletic Association
# You are the "computer expert" of a local Athletic Association (C.A.A.). Many teams of runners come to compete. Each time you get a string of all race results of every team who has run. For example here is a string showing the individual results of a team of 5 runners:
#
# "01|15|59, 1|47|6, 01|17|20, 1|32|34, 2|3|17"
#
# Each part of the string is of the form: h|m|s where h, m, s (h for hour, m for minutes, s for seconds) are positive or null integer (represented as strings) with one or two digits. Substrings in the input string are separated by ,  or ,.
#
# To compare the results of the teams you are asked for giving three statistics; range, average and median.
#
# Range : difference between the lowest and highest values. In {4, 6, 9, 3, 7} the lowest value is 3, and the highest is 9, so the range is 9 − 3 = 6.
#
# Mean or Average : To calculate mean, add together all of the numbers and then divide the sum by the total count of numbers.
#
# Median : In statistics, the median is the number separating the higher half of a data sample from the lower half. The median of a finite list of numbers can be found by arranging all the observations from lowest value to highest value and picking the middle one (e.g., the median of {3, 3, 5, 9, 11} is 5) when there is an odd number of observations. If there is an even number of observations, then there is no single middle value; the median is then defined to be the mean of the two middle values (the median of {3, 5, 6, 9} is (5 + 6) / 2 = 5.5).
#
# Your task is to return a string giving these 3 values. For the example given above, the string result will be
#
# "Range: 00|47|18 Average: 01|35|15 Median: 01|32|34"
#
# of the form: "Range: hh|mm|ss Average: hh|mm|ss Median: hh|mm|ss"`
#
# where hh, mm, ss are integers (represented by strings) with each 2 digits.
#
# Remarks:
# if a result in seconds is ab.xy... it will be given truncated as ab.
# if the given string is "" you will return ""
# FUNDAMENTALSSTRINGSSTATISTICSMATHEMATICSDATA SCIENCE
def stat(strg):
    if not strg:
        return ''
    stack: list[int] = list()
    for part in strg.split(', '):
        top: list[str] = part.split('|')
        ans: int = 0
        for i in range(len(top)):
            if i == 0:
                ans += int(top[i]) * 3600
            elif i == 1:
                ans += int(top[i]) * 60
            else:
                ans += int(top[i])
        stack.append(ans)
    diff: int = max(stack) - min(stack)
    diff: str = f'Range: {diff // 3600:02d}|{diff % 3600 // 60:02d}|{diff % 3600 % 60:02d}'
    average: int = sum(stack) // len(stack)
    average: str = f'Average: {average // 3600:02d}|{average % 3600 // 60:02d}|{average % 3600 % 60:02d}'
    stack.sort()
    median: int = stack[len(stack) // 2] if len(stack) % 2 != 0 else (stack[len(stack) // 2] + stack[len(stack) // 2 - 1]) // 2
    median: str = f'Median: {median // 3600:02d}|{median % 3600 // 60:02d}|{median % 3600 % 60:02d}'
    return f'{diff} {average} {median}'

# 1544. Make The String Great
# Given a string s of lower and upper case English letters.
#
# A good string is a string which doesn't have two adjacent characters s[i] and s[i + 1] where:
#
# 0 <= i <= s.length - 2
# s[i] is a lower-case letter and s[i + 1] is the same letter but in upper-case or vice-versa.
# To make the string good, you can choose two adjacent characters that make the string bad and remove them. You can keep doing this until the string becomes good.
#
# Return the string after making it good. The answer is guaranteed to be unique under the given constraints.
#
# Notice that an empty string is also good.
#
#
#
# Example 1:
#
# Input: s = "leEeetcode"
# Output: "leetcode"
# Explanation: In the first step, either you choose i = 1 or i = 2, both will result "leEeetcode" to be reduced to "leetcode".
# Example 2:
#
# Input: s = "abBAcC"
# Output: ""
# Explanation: We have many possible scenarios, and all lead to the same answer. For example:
# "abBAcC" --> "aAcC" --> "cC" --> ""
# "abBAcC" --> "abBA" --> "aA" --> ""
# Example 3:
#
# Input: s = "s"
# Output: "s"
#
#
# Constraints:
#
# 1 <= s.length <= 100
# s contains only lower and upper case English letters.
class Solution:
    def makeGood(self, s: str) -> str:
        stack: list[str] = list()
        for i in s:
            if not stack:
                stack.append(i)
            elif abs(ord(i) - ord(stack[-1])) == 32:
                stack.pop()
            else:
                stack.append(i)
        return ''.join(stack)

# Spin the sentence
# In this kata you will have to modify a sentence so it meets the following rules:
#
# convert every word backwards that is:
#
# longer than 6 characters
# OR
#
# has 2 or more 'T' or 't' in it
# convert every word uppercase that is:
#
# exactly 2 characters long
# OR
#
# before a comma
# convert every word to a "0" that is:
#
# exactly one character long
# NOTES:
#
#   Punctuation must not be touched. if a word is 6 characters long, and a "." is behind it,
#   it counts as 6 characters so it must not be flipped, but if a word is 7 characters long,
#   it must be flipped but the "." must stay at the end of the word.
#   -----------------------------------------------------------------------------------------
#   Only the first transformation applies to a given word, for example 'companions,'
#   will be 'snoinapmoc,' and not 'SNOINAPMOC,'.
#   -----------------------------------------------------------------------------------------
#   As for special characters like apostrophes or dashes, they count as normal characters,
#   so e.g 'sand-colored' must be transformed to 'deroloc-dnas'.
# STRINGSFUNDAMENTALS
def spin_solve(sentence):
    ans: list[str] = list()
    for word in sentence.split():
        x: str = word[:]
        end: bool = False
        while not x[-1].isalnum():
            x, end = x[:-1], True
        if len(x) > 6 or x.count('T') > 1 or x.count('t') > 1:
            ans.append(x[::-1] + (word[-1] if end else ''))
        elif len(x) == 2 or (end and word[-1] == ','):
            ans.append(x.upper() + (word[-1] if end else ''))
        elif len(x) == 1:
            ans.append('0')
        else:
            ans.append(x + (word[-1] if end else ''))
    return ' '.join(ans)

# 1249. Minimum Remove to Make Valid Parentheses
# Given a string s of '(' , ')' and lowercase English characters.
#
# Your task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string.
#
# Formally, a parentheses string is valid if and only if:
#
# It is the empty string, contains only lowercase characters, or
# It can be written as AB (A concatenated with B), where A and B are valid strings, or
# It can be written as (A), where A is a valid string.
#
#
# Example 1:
#
# Input: s = "lee(t(c)o)de)"
# Output: "lee(t(c)o)de"
# Explanation: "lee(t(co)de)" , "lee(t(c)ode)" would also be accepted.
# Example 2:
#
# Input: s = "a)b(c)d"
# Output: "ab(c)d"
# Example 3:
#
# Input: s = "))(("
# Output: ""
# Explanation: An empty string is also valid.
#
#
# Constraints:
#
# 1 <= s.length <= 105
# s[i] is either'(' , ')', or lowercase English letter.
class Solution:
    def minRemoveToMakeValid(self, s: str) -> str:
        stack: list[int] = list()
        for i in range(len(s)):
            if s[i] == '(':
                stack.append(i)
            elif s[i] == ')':
                if stack and s[stack[-1]] == '(':
                    stack.pop()
                else:
                    stack.append(i)
        ans: list[str] = list()
        for i in range(len(s)):
            if stack and i != stack[0]:
                ans.append(s[i])
            elif stack:
                stack.pop(0)
            else:
                ans.append(s[i])
        return ''.join(ans)

# Address Book by State
# Given a string with friends to visit in different states:
#
# ad3="John Daggett, 341 King Road, Plymouth MA
# Alice Ford, 22 East Broadway, Richmond VA
# Sal Carpenter, 73 6th Street, Boston MA"
# we want to produce a result that sorts the names by state and lists the name of the state followed by the name of each person residing in that state (people's names sorted). When the result is printed we get:
#
# Massachusetts
# .....^John Daggett 341 King Road Plymouth Massachusetts
# .....^Sal Carpenter 73 6th Street Boston Massachusetts
# ^Virginia
# .....^Alice Ford 22 East Broadway Richmond Virginia
# Spaces not being always well seen, in the above result ^ means a white space.
#
# The resulting string (when not printed) will be:
#
# "Massachusetts\n..... John Daggett 341 King Road Plymouth Massachusetts\n..... Sal Carpenter 73 6th Street Boston Massachusetts\n Virginia\n..... Alice Ford 22 East Broadway Richmond Virginia"
# or (the separator is \n or \r\n depending on the language)
#
# "Massachusetts\r\n..... John Daggett 341 King Road Plymouth Massachusetts\r\n..... Sal Carpenter 73 6th Street Boston Massachusetts\r\n Virginia\r\n..... Alice Ford 22 East Broadway Richmond Virginia"
# Notes
# There can be a blank last line in the given string of addresses.
# The tests only contains CA, MA, OK, PA, VA, AZ, ID, IN for states.
# You can see another example in the "Sample tests".
# States
# For the lazy ones:
#
# 'AZ': 'Arizona',
# 'CA': 'California',
# 'ID': 'Idaho',
# 'IN': 'Indiana',
# 'MA': 'Massachusetts',
# 'OK': 'Oklahoma',
# 'PA': 'Pennsylvania',
# 'VA': 'Virginia'
# FUNDAMENTALSSTRINGS
def by_state(st):
    ht: dict[str, list[str]] = dict()
    acronym: dict[str, str] = {
        'AZ': 'Arizona','CA': 'California',
        'ID': 'Idaho','IN': 'Indiana',
        'MA': 'Massachusetts','OK': 'Oklahoma',
        'PA': 'Pennsylvania','VA': 'Virginia'
    }
    for people in st.split('\n'):
        if people[-2:]:
            ht[people[-2:]] = ht.get(people[-2:], []) + [people]
    states: list[str] = sorted(ht.keys())
    ans: list[str] = list()
    for state in states:
        top: list[str] = [acronym.get(state)] + [people[:-2].replace(',', '') + acronym.get(state) for people in sorted(ht.get(state))]
        ans.append('\r\n..... '.join(top))
    return '\r\n '.join(ans)

# 678. Valid Parenthesis String
# Given a string s containing only three types of characters: '(', ')' and '*', return true if s is valid.
#
# The following rules define a valid string:
#
# Any left parenthesis '(' must have a corresponding right parenthesis ')'.
# Any right parenthesis ')' must have a corresponding left parenthesis '('.
# Left parenthesis '(' must go before the corresponding right parenthesis ')'.
# '*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string "".
#
#
# Example 1:
#
# Input: s = "()"
# Output: true
# Example 2:
#
# Input: s = "(*)"
# Output: true
# Example 3:
#
# Input: s = "(*))"
# Output: true
#
#
# Constraints:
#
# 1 <= s.length <= 100
# s[i] is '(', ')' or '*'.
class Solution:
    def checkValidString(self, s: str) -> bool:
        mn, mx = 0, 0
        for i in s:
            if i == '(':
                mn, mx = mn + 1, mx + 1
            elif i == ')':
                mn, mx = max(mn - 1, 0), mx - 1
            else:
                mn, mx = max(mn - 1, 0), mx + 1
            if mx < 0:
                return False
        return mn == 0

# Baby Magpies
# Magpies are my favourite birds
# Baby ones even more so...
#
#
# It is a little known fact^ that the black & white colours of baby magpies differ by at least one place and at most two places from the colours of the mother magpie.
#
# So now you can work out if any two magpies may be related.
#
# ...and Quardle oodle ardle wardle doodle the magpies said
#
# Kata Task
# Given the colours of two magpies, determine if one is a possible child or grand-child of the other.
#
# Notes
# Each pair of birds being compared will have same number of colour areas
# B = Black
# W = White
# Example
# Given these three magpies
#
# Magpie 1  BWBWBW
# Magpie 2  BWBWBB
# Magpie 3  WWWWBB
# You can see:
#
# Magpie 2 may be a child of Magpie 1 because there is only one difference
# Magpie 3 may be child of Magpie 2 because there are two differences
# So Magpie 3 may be a grand-child of Magpie 1
# On the other hand, Magpie 3 cannot be a child of Magpie 1 because there are three differences
# DM :-)
#
# ^ This fact is little known because I just made it up
#
# ALGORITHMS
def child(bird1, bird2):
    return 1 <= sum(x != y for x, y in zip(bird1, bird2)) <= 2

def grandchild(bird1, bird2):
    return 0 <= sum(x != y for x, y in zip(bird1, bird2)) <= [4, 0][len(bird1) == 1]

# 3105. Longest Strictly Increasing or Strictly Decreasing Subarray
# You are given an array of integers nums. Return the length of the longest
# subarray
#  of nums which is either
# strictly increasing
#  or
# strictly decreasing
# .
#
#
#
# Example 1:
#
# Input: nums = [1,4,3,3,2]
#
# Output: 2
#
# Explanation:
#
# The strictly increasing subarrays of nums are [1], [2], [3], [3], [4], and [1,4].
#
# The strictly decreasing subarrays of nums are [1], [2], [3], [3], [4], [3,2], and [4,3].
#
# Hence, we return 2.
#
# Example 2:
#
# Input: nums = [3,3,3,3]
#
# Output: 1
#
# Explanation:
#
# The strictly increasing subarrays of nums are [3], [3], [3], and [3].
#
# The strictly decreasing subarrays of nums are [3], [3], [3], and [3].
#
# Hence, we return 1.
#
# Example 3:
#
# Input: nums = [3,2,1]
#
# Output: 3
#
# Explanation:
#
# The strictly increasing subarrays of nums are [3], [2], and [1].
#
# The strictly decreasing subarrays of nums are [3], [2], [1], [3,2], [2,1], and [3,2,1].
#
# Hence, we return 3.
#
#
#
# Constraints:
#
# 1 <= nums.length <= 50
# 1 <= nums[i] <= 50
class Solution:
    def longestMonotonicSubarray(self, nums: List[int]) -> int:
        ans, top = 1, 0
        prev = 0
        for i in range(1, len(nums)):
            if nums[i] < nums[prev]:
                prev = i
                continue
            else:
                ans = max(ans, i - top)
                top, prev = i, i
        ans = max(ans, len(nums) - top)
        top, prev = 0, 0
        for i in range(1, len(nums)):
            if nums[i] > nums[prev]:
                prev = i
            else:
                ans = max(ans, i - top)
                top, prev = i, i
        ans = max(ans, len(nums) - top)
        return ans

# 3106. Lexicographically Smallest String After Operations With Constraint
# You are given a string s and an integer k.
#
# Define a function distance(s1, s2) between two strings s1 and s2 of the same length n as:
#
# The sum of the minimum distance between s1[i] and s2[i] when the characters from 'a' to 'z' are placed in a cyclic order, for all i in the range [0, n - 1].
# For example, distance("ab", "cd") == 4, and distance("a", "z") == 1.
#
# You can change any letter of s to any other lowercase English letter, any number of times.
#
# Return a string denoting the
# lexicographically smallest
#  string t you can get after some changes, such that distance(s, t) <= k.
#
#
#
# Example 1:
#
# Input: s = "zbbz", k = 3
#
# Output: "aaaz"
#
# Explanation:
#
# Change s to "aaaz". The distance between "zbbz" and "aaaz" is equal to k = 3.
#
# Example 2:
#
# Input: s = "xaxcd", k = 4
#
# Output: "aawcd"
#
# Explanation:
#
# The distance between "xaxcd" and "aawcd" is equal to k = 4.
#
# Example 3:
#
# Input: s = "lol", k = 0
#
# Output: "lol"
#
# Explanation:
#
# It's impossible to change any character as k = 0.
#
#
#
# Constraints:
#
# 1 <= s.length <= 100
# 0 <= k <= 2000
# s consists only of lowercase English letters.
class Solution:
    def getSmallestString(self, s: str, k: int) -> str:
        if k == 0:
            return s
        ans: list[str] = ['a' for i in range(len(s))]
        count: int = sum(min(abs(ord(s[i]) - ord(ans[i])), abs(ord(s[i]) - (ord(ans[i]) + 26))) for i in range(len(s)))
        idx: int = len(ans) - 1
        while count > k:
            count -= min(abs(ord(s[idx]) - ord(ans[idx])), abs(ord(s[idx]) - (ord(ans[idx]) + 26)))
            flag = False
            for i in range(ord(s[idx]) - k, ord(s[idx]) + 1):
                if count + (ord(s[idx]) - i) <= k:
                    ans[idx] = chr(i)
                    flag = True
                    return ''.join(ans)
            if not flag:
                ans[idx] = s[idx]
                idx -= 1
        return ''.join(ans)
    
# 3107. Minimum Operations to Make Median of Array Equal to K
# You are given an integer array nums and a non-negative integer k. In one operation, you can increase or decrease any element by 1.
#
# Return the minimum number of operations needed to make the
# median
#  of nums equal to k.
#
#
#
# Example 1:
#
# Input: nums = [2,5,6,8,5], k = 4
#
# Output: 2
#
# Explanation:
#
# We can subtract one from nums[1] and nums[4] to obtain [2, 4, 6, 8, 4]. The median of the resulting array is equal to k.
#
# Example 2:
#
# Input: nums = [2,5,6,8,5], k = 7
#
# Output: 3
#
# Explanation:
#
# We can add one to nums[1] twice and add one to nums[2] once to obtain [2, 7, 7, 8, 5].
#
# Example 3:
#
# Input: nums = [1,2,3,4,5,6], k = 4
#
# Output: 0
#
# Explanation:
#
# The median of the array is already equal to k.
#
#
#
# Constraints:
#
# 1 <= nums.length <= 2 * 105
# 1 <= nums[i] <= 109
# 1 <= k <= 109
class Solution:
    def minOperationsToMakeMedianK(self, nums: List[int], k: int) -> int:
        nums.sort()
        start: int = len(nums) // 2
        ans: int = 0
        if nums[start] < k:
            for i in range(start, len(nums)):
                if k <= nums[i]:
                    return ans
                ans += k - nums[i]
            return ans
        else:
            for i in range(start, -1, -1):
                if k >= nums[i]:
                    return ans
                ans += nums[i] - k
            return ans
        
# 1700. Number of Students Unable to Eat Lunch
# The school cafeteria offers circular and square sandwiches at lunch break, referred to by numbers 0 and 1 respectively. All students stand in a queue. Each student either prefers square or circular sandwiches.
#
# The number of sandwiches in the cafeteria is equal to the number of students. The sandwiches are placed in a stack. At each step:
#
# If the student at the front of the queue prefers the sandwich on the top of the stack, they will take it and leave the queue.
# Otherwise, they will leave it and go to the queue's end.
# This continues until none of the queue students want to take the top sandwich and are thus unable to eat.
#
# You are given two integer arrays students and sandwiches where sandwiches[i] is the type of the i​​​​​​th sandwich in the stack (i = 0 is the top of the stack) and students[j] is the preference of the j​​​​​​th student in the initial queue (j = 0 is the front of the queue). Return the number of students that are unable to eat.
#
#
#
# Example 1:
#
# Input: students = [1,1,0,0], sandwiches = [0,1,0,1]
# Output: 0
# Explanation:
# - Front student leaves the top sandwich and returns to the end of the line making students = [1,0,0,1].
# - Front student leaves the top sandwich and returns to the end of the line making students = [0,0,1,1].
# - Front student takes the top sandwich and leaves the line making students = [0,1,1] and sandwiches = [1,0,1].
# - Front student leaves the top sandwich and returns to the end of the line making students = [1,1,0].
# - Front student takes the top sandwich and leaves the line making students = [1,0] and sandwiches = [0,1].
# - Front student leaves the top sandwich and returns to the end of the line making students = [0,1].
# - Front student takes the top sandwich and leaves the line making students = [1] and sandwiches = [1].
# - Front student takes the top sandwich and leaves the line making students = [] and sandwiches = [].
# Hence all students are able to eat.
# Example 2:
#
# Input: students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1]
# Output: 3
#
#
# Constraints:
#
# 1 <= students.length, sandwiches.length <= 100
# students.length == sandwiches.length
# sandwiches[i] is 0 or 1.
# students[i] is 0 or 1.
class Solution:
    def countStudents(self, students: List[int], sandwiches: List[int]) -> int:
        n: int = len(students)
        count: int = 0
        eat: bool = True
        while students and eat:
            eat = False
            for i in range(len(students)):
                if students[i] == sandwiches[0]:
                    count += 1
                    eat = True
                    students.pop(i)
                    sandwiches.pop(0)
                    break
        return n - count
# Solution Counting O(N) O(1)
class Solution:
    def countStudents(self, students: List[int], sandwiches: List[int]) -> int:
        zeros, ones = 0, 0
        for i in students:
            if i == 1:
                ones += 1
            else:
                zeros += 1
        for i in sandwiches:
            if i == 1:
                if ones == 0:
                    return zeros
                ones -= 1
            else:
                if zeros == 0:
                    return ones
                zeros -= 1
        return 0
    
# Esthetic Numbers
# A number is Esthetic if, in any base from base2 up to base10, the absolute difference between every pair of its adjacent digits is constantly equal to 1.
#
# num = 441 (base10)
# // Adjacent pairs of digits:
# // |4, 4|, |4, 1|
# // The absolute difference is not constant
# // 441 is not Esthetic in base10
#
# 441 in base4 = 12321
# // Adjacent pairs of digits:
# // |1, 2|, |2, 3|, |3, 2|, |2, 1|
# // The absolute difference is constant and is equal to 1
# // 441 is Esthetic in base4
# Given a positive integer num, implement a function that returns an array containing the bases (as integers from 2 up to 10) in which num results to be Esthetic, or an empty array [] if no base makes num Esthetic.
#
# Examples
# 10 ➞ [2, 3, 8, 10]
# // 10 in base2 = 1010
# // 10 in base3 = 101
# // 10 in base8 = 12
# // 10 in base10 = 10
#
# 23 ➞ [3, 5, 7, 10]
# // 23 in base3 = 212
# // 23 in base5 = 43
# // 23 in base7 = 32
# // 23 in base10 = 23
#
# 666 ➞ [8]
# // 666 in base8 = 1232
# Suggest kata description edits
def esthetic(num):
    ans: list[int] = list()
    for i in range(2, 11):
        top: list[int] = list()
        x: int = num
        while x:
            top.append(x % i)
            x //= i
        if all(abs(x - y) == 1 for x, y in zip(top, top[1:])):
            ans.append(i)
    return ans

# 2073. Time Needed to Buy Tickets
# There are n people in a line queuing to buy tickets, where the 0th person is at the front of the line and the (n - 1)th person is at the back of the line.
#
# You are given a 0-indexed integer array tickets of length n where the number of tickets that the ith person would like to buy is tickets[i].
#
# Each person takes exactly 1 second to buy a ticket. A person can only buy 1 ticket at a time and has to go back to the end of the line (which happens instantaneously) in order to buy more tickets. If a person does not have any tickets left to buy, the person will leave the line.
#
# Return the time taken for the person at position k (0-indexed) to finish buying tickets.
#
#
#
# Example 1:
#
# Input: tickets = [2,3,2], k = 2
# Output: 6
# Explanation:
# - In the first pass, everyone in the line buys a ticket and the line becomes [1, 2, 1].
# - In the second pass, everyone in the line buys a ticket and the line becomes [0, 1, 0].
# The person at position 2 has successfully bought 2 tickets and it took 3 + 3 = 6 seconds.
# Example 2:
#
# Input: tickets = [5,1,1,1], k = 0
# Output: 8
# Explanation:
# - In the first pass, everyone in the line buys a ticket and the line becomes [4, 0, 0, 0].
# - In the next 4 passes, only the person in position 0 is buying tickets.
# The person at position 0 has successfully bought 5 tickets and it took 4 + 1 + 1 + 1 + 1 = 8 seconds.
#
#
# Constraints:
#
# n == tickets.length
# 1 <= n <= 100
# 1 <= tickets[i] <= 100
# 0 <= k < n
# Solution Simulation O(N**K) O(1)
class Solution:
    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:
        ans: int = 0
        for i in range(tickets[k]):
            for person in range(len(tickets)):
                if tickets[person] > 0:
                    ans += 1
                    tickets[person] -= 1
                    if tickets[k] == 0:
                        return ans

# Solution Counting OnePass O(N) O(1)
class Solution:
    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:
        ans: int = 0
        for i in range(len(tickets)):
            ans += min(tickets[i], tickets[k] if i <= k else tickets[k] - 1)
        return ans

    
# Is it a letter?
# Write a function, isItLetter or is_it_letter or IsItLetter, which tells us if a given character is a letter or not.
def is_it_letter(s):
    return s.isalpha()

# 950. Reveal Cards In Increasing Order
# You are given an integer array deck. There is a deck of cards where every card has a unique integer. The integer on the ith card is deck[i].
#
# You can order the deck in any order you want. Initially, all the cards start face down (unrevealed) in one deck.
#
# You will do the following steps repeatedly until all cards are revealed:
#
# Take the top card of the deck, reveal it, and take it out of the deck.
# If there are still cards in the deck then put the next top card of the deck at the bottom of the deck.
# If there are still unrevealed cards, go back to step 1. Otherwise, stop.
# Return an ordering of the deck that would reveal the cards in increasing order.
#
# Note that the first entry in the answer is considered to be the top of the deck.
#
#
#
# Example 1:
#
# Input: deck = [17,13,11,2,3,5,7]
# Output: [2,13,3,11,5,17,7]
# Explanation:
# We get the deck in the order [17,13,11,2,3,5,7] (this order does not matter), and reorder it.
# After reordering, the deck starts as [2,13,3,11,5,17,7], where 2 is the top of the deck.
# We reveal 2, and move 13 to the bottom.  The deck is now [3,11,5,17,7,13].
# We reveal 3, and move 11 to the bottom.  The deck is now [5,17,7,13,11].
# We reveal 5, and move 17 to the bottom.  The deck is now [7,13,11,17].
# We reveal 7, and move 13 to the bottom.  The deck is now [11,17,13].
# We reveal 11, and move 17 to the bottom.  The deck is now [13,17].
# We reveal 13, and move 17 to the bottom.  The deck is now [17].
# We reveal 17.
# Since all the cards revealed are in increasing order, the answer is correct.
# Example 2:
#
# Input: deck = [1,1000]
# Output: [1,1000]
#
#
# Constraints:
#
# 1 <= deck.length <= 1000
# 1 <= deck[i] <= 106
# All the values of deck are unique.
class Solution:
    def deckRevealedIncreasing(self, deck):
        deq = collections.deque()
        for el in sorted(deck, reverse=True):
            deq.rotate()
            deq.appendleft(el)
        return list(deq)

# Continued Fraction
# In this kata, you will have to return the continued fractionwiki of a fraction.
#
# For example, if the numerator is 311 and the denominator is 144, then you would have to return [2, 6, 3, 1, 5], because:
#
# 311
# /
# 144
# =
# 2
# +
# 1
# 6
# +
# 1
# 3
# +
# 1
# 1
# +
# 1
# 5
# 311/144=2+
# 6+
# 3+
# 1+
# 5
# 1
# ​
#
# 1
# ​
#
# 1
# ​
#
# 1
# ​
#
# If the numerator is 0, you should return [].
def continued_fraction(nu: int, de:int) -> list[int]:
    ans: list[int] = list()
    while nu != 0 and de != 0:
        n: int = nu // de
        ans.append(n)
        x: int = max(nu - (de * n), de)
        y: int = min(nu - (de * n), de)
        nu, de = x, y
    return ans

# 402. Remove K Digits
# Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.
#
#
#
# Example 1:
#
# Input: num = "1432219", k = 3
# Output: "1219"
# Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.
# Example 2:
#
# Input: num = "10200", k = 1
# Output: "200"
# Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.
# Example 3:
#
# Input: num = "10", k = 2
# Output: "0"
# Explanation: Remove all the digits from the number and it is left with nothing which is 0.
#
#
# Constraints:
#
# 1 <= k <= num.length <= 105
# num consists of only digits.
# num does not have any leading zeros except for the zero itself.
class Solution:
    def removeKdigits(self, num: str, k: int) -> str:
        stack: list[str] = list()
        for i in num:
            while k > 0 and stack and stack[-1] > i:
                k -= 1
                stack.pop()
            stack.append(i)
        if k > 0:
            stack = stack[:-k]
        if not stack:
            return '0'
        idx: int = 0
        while idx < len(stack) and stack[idx] == '0':
            idx += 1
        ans: str = ''.join(stack[idx:])
        return ans if ans else '0'

# Simple Fun #373: The Possible Scores
# Problem
# John and Tom are students of Myjinxin.
#
# In the classroom, Myjinxin often gives 10 judgment questions, let the students write the answer. o represents right and x represents wrong. i.e. If the students think that the 10 judgments are all right, his answer will be "oooooooooo".
#
# Tom always answers questions earlier than John. Then, the teacher gives Tom a score, each subject worth 10 points. i.e. If Tom's answer is "oooooooooo" and the correct answer is "ooxxxxxxxx", Tom got 20 points.
#
# John didn't know what the correct answer was. He has his own answer.
#
# John looked at Tom's answer and Tom's score, and he wanted to know what the minimum possible score and the maximum possible score he could get..
#
# Task
# You are given three arguments:
#
# answerOfTom: Tom's answer. It's a string of length 10, contains only o or x.
#
# scoreOfTom: Tom's score. an integer that can be 0,10,20,...,100.
#
# answerOfJohn: John's answer. It's a string of length 10, contains only o or x.
#
# Your result should be a 2-elements integer array/tuple: <minimum possible score of John>, <maximum possible score of John>
#
# Still not understand the task? Look at the following example ;-)
#
# Examples
# For answerOfTom="oooooooooo", scoreOfTom=20, answerOfJohn="oooooooooo" the output should be 20,20
#
# In this case, John's answer is same as Tom's, so his scores can only be 20.
#
# For answerOfTom="oooooooooo", scoreOfTom=20, answerOfJohn="xxxxxxxxxx" the output should be 80,80
#
# In this case, John's answer is just the opposite of Tom's, so his scores can only be 80.
#
# For answerOfTom="oooooooooo", scoreOfTom=20, answerOfJohn="oooooxxxxx" the output should be 30,70
#
# In this case, Tom's score is 20. It means two questions Tom answered correctly.
#
# Let's think about some situations:
#
# If the first question and second question Tom answered correctly, the whole correct answer may be "ooxxxxxxxx", John will get 70 points;
#
# If the last question and second last question Tom answered correctly, the whole correct answer may be "xxxxxxxxoo", John will get 30 points;
#
# If the 5th question and 6th question Tom answered correctly, the whole correct answer may be "xxxxooxxxx", John will get 50 points;
#
# ...and other situations...
#
# So, John can get at least 30 points, at most 70 points.
#
# Note
# Happy Coding ^_^
# FUNDAMENTALS
def possible_scores(answer_of_tom, score_of_tom, answer_of_john):
    x: int = sum(i != j for i, j in zip(answer_of_tom, answer_of_john))
    ans: int = None
    n: int = score_of_tom // 10
    if x == 0:
        ans = n
    elif x == 10:
        ans = x - n
    else:
        ans = min(10 - x + (10 - n), x + n)
    return (abs(x - n) * 10, ans * 10)

# 42. Trapping Rain Water
# Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.
#
#
#
# Example 1:
#
#
# Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
# Output: 6
# Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.
# Example 2:
#
# Input: height = [4,2,0,3,2,5]
# Output: 9
#
#
# Constraints:
#
# n == height.length
# 1 <= n <= 2 * 104
# 0 <= height[i] <= 105
# Solution Two Pointers O(N) O(1)
class Solution:
    def trap(self, height: List[int]) -> int:
        ans: int = 0
        idx_mx: int = 0
        for i in range(len(height)):
            if height[i] > height[idx_mx]:
                idx_mx = i
        left, right = 0, idx_mx
        left_boundary, right_boundary = 0, height[idx_mx]
        while left <= right:
            if left_boundary < height[left]:
                left_boundary = height[left]
            ans += min(left_boundary, right_boundary) - height[left]
            left += 1
        right = len(height) - 1
        right_boundary = height[right]
        while right >= left:
            if right_boundary < height[right]:
                right_boundary = height[right]
            ans += min(left_boundary, right_boundary) - height[right]
            right += -1
        return ans


# Permutations Of An Array And Associated Values
# The special score(ssc) of an array of integers will be the sum of each integer multiplied by its corresponding index plus one in the array.
#
# E.g.: with the array [6, 12, -1]
#
# arr =   [6,      12,       -1 ]
# ssc =   1*6  +  2*12  +  3*(-1) = 6 + 24 - 3 = 27
# The array given in the example has six(6) permutations and are with the corresponding ssc:
#
# Permutations      Special Score (ssc)
# [6, 12, -1]       1*6 + 2*12 + 3*(-1) = 27
# [6, -1, 12]       1*6 + 2*(-1) + 3*12 = 40
# [-1, 6, 12]       1*(-1) + 2*6 + 3*12 = 47
# [-1, 12, 6]       1*(-1) + 2*12 + 3*6 = 41
# [12, -1, 6]       1*12 + 2*(-1) + 3*6 = 28
# [12, 6, -1]       1*12 + 2*6 + 3*(-1) = 21
# The total sum of the ssc's of all the possible permutations is: 27 + 40 + 47 + 41 + 28 + 21 = 204
#
# The maximum value for the ssc is 47.
#
# The minimum value for the ssc is 21.
#
# We need a special function ssc_forperm() that receives an array of uncertain number of elements (the elements may occur more than once) and may output a list of dictionaries with the following data:
#
# [{"total perm":__}, {"total ssc": ___}, {"max ssc": __}, {"min ssc": __}]
# For the example we have above will be:
#
# ssc_forperm([6, 12, -1]) = [{"total perm":6}, {"total ssc:204}, {"max ssc":47}, {"min ssc":21}]
# You may assume that you will never receive an empty array.
#
# Also you will never receive an array with the same element in all the positions like [1, 1, 1, 1 ,1], but you may have elements occuring twice or more like [1, 1, 1, 2, 3]
#
# Enjoy it!!
#
# FUNDAMENTALSMATHEMATICSDATA STRUCTURESPERMUTATIONSALGORITHMS
import itertools
def ssc_forperm(arr):
    mx, mn = float('-inf'), float('inf')
    total = 0
    stack: list[list] = list(set(itertools.permutations(arr)))
    for lst in stack:
        x: int = sum((i + 1) * lst[i] for i in range(len(lst)))
        total += x
        mx = max(mx, x)
        mn = min(mn, x)
    return [{"total perm": len(stack)}, {"total ssc": total}, {"max ssc": mx}, {"min ssc": mn}]

# 84. Largest Rectangle in Histogram
# Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.
#
#
#
# Example 1:
#
#
# Input: heights = [2,1,5,6,2,3]
# Output: 10
# Explanation: The above is a histogram where width of each bar is 1.
# The largest rectangle is shown in the red area, which has an area = 10 units.
# Example 2:
#
#
# Input: heights = [2,4]
# Output: 4
#
#
# Constraints:
#
# 1 <= heights.length <= 105
# 0 <= heights[i] <= 104
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        heights.append(0)
        stack: list[int] = list()
        ans: int = 0
        for idx in range(len(heights)):
            while stack and heights[stack[-1]] >= heights[idx]:
                h: int = heights[stack.pop()]
                w: int = idx if not stack else idx - stack[-1] - 1
                ans = max(ans, h * w)
            stack.append(idx)
        return ans

# 85. Maximal Rectangle
# Given a rows x cols binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.
#
#
#
# Example 1:
#
#
# Input: matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
# Output: 6
# Explanation: The maximal rectangle is shown in the above picture.
# Example 2:
#
# Input: matrix = [["0"]]
# Output: 0
# Example 3:
#
# Input: matrix = [["1"]]
# Output: 1
#
#
# Constraints:
#
# rows == matrix.length
# cols == matrix[i].length
# 1 <= row, cols <= 200
# matrix[i][j] is '0' or '1'.
class Solution:
    def maximalRectangleInHistogram(self, arr: list[int]) -> int:
        arr.append(0)
        stack: list[int] = list()
        ans: int = 0
        for idx in range(len(arr)):
            while stack and arr[stack[-1]] >= arr[idx]:
                h: int = arr[stack.pop()]
                w: int = idx if not stack else idx - stack[-1] - 1
                ans = max(ans, h * w)
            stack.append(idx)
        return ans

    def maximalRectangle(self, matrix: List[List[str]]) -> int:
        stack: list[int] = [0] * len(matrix[0])
        ans: int = 0
        for rows in matrix:
            for cols in range(len(rows)):
                stack[cols] = 0 if rows[cols] == '0' else stack[cols] + int(rows[cols])
            ans = max(ans, self.maximalRectangleInHistogram(stack))
        return ans

# Histogram - H2
# This Kata is a variation of Histogram - H1
#
# Kata in this series
#
# Histogram - H1
# Histogram - H2
# Histogram - V1
# Histogram - V2
# Background
# A 6-sided die is rolled a number of times and the results are plotted as percentages of the total in a character-based horizontal histogram.
#
# Example:
#
# 6|██ 5%
# 5|
# 4|███████ 15%
# 3|███████████████████████████████████ 70%
# 2|█ 3%
# 1|███ 7%
# Task
# You will be passed the dice value frequencies, and your task is to write the code to return a string representing a histogram, so that when it is printed it has the same format as the example.
#
# Notes
# There are no trailing spaces on the lines
# All lines (including the last) end with a newline \n
# The percentage is displayed beside each bar except where it is 0%
# The total number of rolls varies, but won't exceed 10,000
# The bar lengths are scaled so that 100% = 50 x bar characters
# The bar character is █, which is the Unicode U+2588 char
# When calculating percentages and bar lengths always floor/truncate to the nearest integer
# FUNDAMENTALS
def histogram(results):
    bar_char = "█"
    n: int = sum(results)
    for i in range(len(results)):
        x: int = (results[i] * 100 // n) if n else 0
        results[i] = f'{i + 1}|{bar_char * (x // 2)}' + (f' {x}%' if x else '')
    return '\n'.join(results[::-1]) + '\n'

# 1551. Minimum Operations to Make Array Equal
# You have an array arr of length n where arr[i] = (2 * i) + 1 for all valid values of i (i.e., 0 <= i < n).
#
# In one operation, you can select two indices x and y where 0 <= x, y < n and subtract 1 from arr[x] and add 1 to arr[y] (i.e., perform arr[x] -=1 and arr[y] += 1). The goal is to make all the elements of the array equal. It is guaranteed that all the elements of the array can be made equal using some operations.
#
# Given an integer n, the length of the array, return the minimum number of operations needed to make all the elements of arr equal.
#
#
#
# Example 1:
#
# Input: n = 3
# Output: 2
# Explanation: arr = [1, 3, 5]
# First operation choose x = 2 and y = 0, this leads arr to be [2, 3, 4]
# In the second operation choose x = 2 and y = 0 again, thus arr = [3, 3, 3].
# Example 2:
#
# Input: n = 6
# Output: 9
#
#
# Constraints:
#
# 1 <= n <= 104
class Solution:
    def minOperations(self, n: int) -> int:
        if n % 2 != 0:
            n = (n - 1) // 2
            return n * (n + 1)
        n = n // 2
        return n**2

# Sum it continuously
# Make a function "add" that will be able to sum elements of list continuously and return a new list of sums.
#
# For example:
#
# add [1,2,3,4,5] == [1, 3, 6, 10, 15], because it's calculated like
# this : [1, 1 + 2, 1 + 2 + 3, 1 + 2 + 3 + 4, 1 + 2 + 3 + 4 + 5]
# If you want to learn more see https://en.wikipedia.org/wiki/Prefix_sum
#
# FUNDAMENTALSLISTS
def add(lst):
    for i in range(len(lst)):
        lst[i] += lst[i - 1] if i > 0 else 0
    return lst
    
# 189. Rotate Array
# Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.
#
#
#
# Example 1:
#
# Input: nums = [1,2,3,4,5,6,7], k = 3
# Output: [5,6,7,1,2,3,4]
# Explanation:
# rotate 1 steps to the right: [7,1,2,3,4,5,6]
# rotate 2 steps to the right: [6,7,1,2,3,4,5]
# rotate 3 steps to the right: [5,6,7,1,2,3,4]
# Example 2:
#
# Input: nums = [-1,-100,3,99], k = 2
# Output: [3,99,-1,-100]
# Explanation:
# rotate 1 steps to the right: [99,-1,-100,3]
# rotate 2 steps to the right: [3,99,-1,-100]
#
#
# Constraints:
#
# 1 <= nums.length <= 105
# -231 <= nums[i] <= 231 - 1
# 0 <= k <= 105
#
#
# Follow up:
#
# Try to come up with as many solutions as you can. There are at least three different ways to solve this problem.
# Could you do it in-place with O(1) extra space?
class Solution:
    def vice_versa(self, arr, left, right):
        while left < right:
            arr[left], arr[right] = arr[right], arr[left]
            left, right = left + 1, right - 1
        return arr
    def rotate(self, nums: List[int], k: int) -> None:
        n: int = len(nums)
        k %= n
        self.vice_versa(nums, 0, n - 1)
        self.vice_versa(nums, 0, k - 1)
        self.vice_versa(nums, k, n - 1)
        
# Clock Patience
# In this Kata you will be playing Clock Patience which is a single-player card game of chance requiring zero skill.
#
# Input
# cards a shuffled deck of 52 playing cards represented as a string array
# card values are A,2,3,4,5,6,7,8,9,10,J,Q,K (suits are not relevant)
# Process
# Within the Kata method you will need to:
#
# "Deal" the cards face down one at a time into clock positions
#
# First card at 1 o'clock position, 2nd at 2 o'clock... 12th at 12 o'clock, 13th card in the centre
#
# Repeat 4 times.
#
# When all cards are dealt there will be 13 piles of 4 cards each
#
# See here for the general idea (but use this Kata's dealing rules)
#
# "Play" the game according to these RULES
#
# Start by turning over the top card in the clock centre
#
# Place that card face up at the clock position associated with its card-value:
#
# A at 1 o'clock
# 2 at 2 o'clock
# 3 at 3 o'clock
# ...
# Q at 12 o'clock
# K in the centre
# Next turn over the top card of the pile at this new clock position
#
# REPEAT until no more moves are possible
#
# This happens only when the 4th King (K) is revealed
# See here for clarification of these rules
#
# Kata Task
# Return the number of cards still remaining face down when the game ends (a winning game would return 0)
#
# ALGORITHMS
def patience(cards: list[str]) -> int:
    if not cards:
        return 0
    pos: dict[str, int] = {
        '1': 1, '2': 2, '3': 3, '4': 4,
        '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10,
        'J': 11, 'Q': 12, 'K': 13, 'A': 1
    }
    stack: list[list[str]] = [[] for _ in range(14)]
    for rep in range(4):
        for i in range(1, 14):
            stack[i].append(cards.pop(0))
    current: str = stack[13].pop()
    while stack[13]:
        current = stack[pos[current]].pop()
    return sum(len(chunck) for chunck in stack)

# 164. Maximum Gap
# Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.
#
# You must write an algorithm that runs in linear time and uses linear extra space.
#
#
#
# Example 1:
#
# Input: nums = [3,6,9,1]
# Output: 3
# Explanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.
# Example 2:
#
# Input: nums = [10]
# Output: 0
# Explanation: The array contains less than 2 elements, therefore return 0.
#
#
# Constraints:
#
# 1 <= nums.length <= 105
# 0 <= nums[i] <= 109
class Solution:
    from math import ceil
    def maximumGap(self, nums: List[int]) -> int:
        mn, mx = min(nums), max(nums)
        if len(nums) < 2 or mn == mx:
            return 0
        n: int = ceil((mx - mn) / (len(nums) - 1))
        bucket: list[list[int, int]] = [[None, None] for _ in range((mx - mn) // n + 1)]
        for elmnt in nums:
            current_chunck: list[int, int] = bucket[(elmnt - mn) // n]
            current_chunck[0] = elmnt if current_chunck[0] is None else min(elmnt, current_chunck[0])
            current_chunck[1] = elmnt if current_chunck[1] is None else max(elmnt, current_chunck[1])
        bucket = [chunck for chunck in bucket if chunck[0] if not None]
        return max(bucket[i][0] - bucket[i - 1][1] for i in range(1, len(bucket)))

# Find the integer Partition of k-Length With Maximum or Minimum Value For Its Product Value
# Given a certain integer n, n > 0and a number of partitions, k, k > 0; we want to know the partition which has the maximum or minimum product of its terms.
#
# The function find_spec_partition() , will receive three arguments, n, k, and a command: 'max' or 'min'
#
# The function should output the partition that has maximum or minimum value product (it depends on the given command) as an array with its terms in decreasing order.
#
# Let's see some cases (Python and Ruby)
#
# find_spec_partition(10, 4, 'max') == [3, 3, 2, 2]
# find_spec_partition(10, 4, 'min') == [7, 1, 1, 1]
# and Javascript:
#
# findSpecPartition(10, 4, 'max') == [3, 3, 2, 2]
# findSpecPartition(10, 4, 'min') == [7, 1, 1, 1]
# The partitions of 10 with 4 terms with their products are:
#
# (4, 3, 2, 1): 24
# (4, 2, 2, 2): 32
# (6, 2, 1, 1): 12
# (3, 3, 3, 1): 27
# (4, 4, 1, 1): 16
# (5, 2, 2, 1): 20
# (7, 1, 1, 1): 7   <------- min. productvalue
# (3, 3, 2, 2): 36  <------- max.product value
# (5, 3, 1, 1): 15
# Enjoy it!
#
# FUNDAMENTALSDATA STRUCTURESALGORITHMSMATHEMATICSLOGICSTRINGS
def find_spec_partition(n, k, com):
    if com == 'min':
        return [n - (k - 1)] + [1 for i in range(k - 1)]
    stack: list[int] = [0] * k
    count: int = 0
    idx: int = 0
    while count < n:
        count += 1
        stack[idx % k] += 1
        idx += 1
    return stack

# 2670. Find the Distinct Difference Array
# You are given a 0-indexed array nums of length n.
#
# The distinct difference array of nums is an array diff of length n such that diff[i] is equal to the number of distinct elements in the suffix nums[i + 1, ..., n - 1] subtracted from the number of distinct elements in the prefix nums[0, ..., i].
#
# Return the distinct difference array of nums.
#
# Note that nums[i, ..., j] denotes the subarray of nums starting at index i and ending at index j inclusive. Particularly, if i > j then nums[i, ..., j] denotes an empty subarray.
#
#
#
# Example 1:
#
# Input: nums = [1,2,3,4,5]
# Output: [-3,-1,1,3,5]
# Explanation: For index i = 0, there is 1 element in the prefix and 4 distinct elements in the suffix. Thus, diff[0] = 1 - 4 = -3.
# For index i = 1, there are 2 distinct elements in the prefix and 3 distinct elements in the suffix. Thus, diff[1] = 2 - 3 = -1.
# For index i = 2, there are 3 distinct elements in the prefix and 2 distinct elements in the suffix. Thus, diff[2] = 3 - 2 = 1.
# For index i = 3, there are 4 distinct elements in the prefix and 1 distinct element in the suffix. Thus, diff[3] = 4 - 1 = 3.
# For index i = 4, there are 5 distinct elements in the prefix and no elements in the suffix. Thus, diff[4] = 5 - 0 = 5.
# Example 2:
#
# Input: nums = [3,2,3,4,2]
# Output: [-2,-1,0,2,3]
# Explanation: For index i = 0, there is 1 element in the prefix and 3 distinct elements in the suffix. Thus, diff[0] = 1 - 3 = -2.
# For index i = 1, there are 2 distinct elements in the prefix and 3 distinct elements in the suffix. Thus, diff[1] = 2 - 3 = -1.
# For index i = 2, there are 2 distinct elements in the prefix and 2 distinct elements in the suffix. Thus, diff[2] = 2 - 2 = 0.
# For index i = 3, there are 3 distinct elements in the prefix and 1 distinct element in the suffix. Thus, diff[3] = 3 - 1 = 2.
# For index i = 4, there are 3 distinct elements in the prefix and no elements in the suffix. Thus, diff[4] = 3 - 0 = 3.
#
#
# Constraints:
#
# 1 <= n == nums.length <= 50
# 1 <= nums[i] <= 50
class Solution:
    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:
        prev_ht: dict[int, int] = dict()
        post_ht: dict[int, int] = dict()
        ln_post: int = 0
        ln_pref: int = 0
        ans: list[int] = list()
        for i in nums:
            if i not in post_ht:
                ln_post += 1
                post_ht[i] = 0
            post_ht[i] += 1
        for i in nums:
            if i not in prev_ht:
                ln_pref += 1
                prev_ht[i] = 1
            post_ht[i] -= 1
            if post_ht[i] == 0:
                ln_post -= 1
            ans.append(ln_pref - ln_post)
        return ans

# Number encrypting: cypher
# Number encrypting: cypher
# Part I of Number encrypting Katas
# Introduction
# Back then when the internet was coming up, most search functionalities simply looked for keywords in text to show relevant documents. Hackers weren't very keen on having their information displayed on websites, bulletin boards, newsgroups or any other place, so they started to replace certain letters in words. It started out with simple vowel substitutions like a 4 instead of an A, or a 3 instead of an E. This meant that topics like cracking or hacking remained undetected.
#
# Here we will use a reduced version of the Leet Speak alphabet, but you can find more information here or at Wikipedia.
#
# Task
# You will receive a string composed by English words, string. You will have to return a cyphered version of that string.
#
# The numbers corresponding to each letter are represented at the table below. Notice that different letters can share the same number. In those cases, one letter will be upper case and the other one lower case.
#
# 1	2	3	4	5	6	7	8	9	0
# Upper case	I	R	E	A	S	G	T	B		O
# Lower case	l	z	e	a	s	b	t		g	o
#
# Any character that is not at the table, does not change when cyphered.
#
# Examples
# Input: "Hello World". Output: "H3110 W0r1d"
# Input: "I am your father". Output: "1 4m y0ur f47h3r"
# Input: "I do not know what else I can test. Be cool. Good luck". Output: "1 d0 n07 kn0w wh47 3153 1 c4n 7357. 83 c001. 600d 1uck"
# Part II
# If you liked this Kata, you can find the part II: Number encrypting: decypher, where your goal is to decypher the strings.
#
# FUNDAMENTALSSTRINGSCIPHERSCRYPTOGRAPHY
def cypher(s):
    return s.translate(str.maketrans('IREASGTBOlzeasbtgo', '123456780123456790'))

# 463. Island Perimeter
# You are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water.
#
# Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).
#
# The island doesn't have "lakes", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.
#
#
#
# Example 1:
#
#
# Input: grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]
# Output: 16
# Explanation: The perimeter is the 16 yellow stripes in the image above.
# Example 2:
#
# Input: grid = [[1]]
# Output: 4
# Example 3:
#
# Input: grid = [[1,0]]
# Output: 4
#
#
# Constraints:
#
# row == grid.length
# col == grid[i].length
# 1 <= row, col <= 100
# grid[i][j] is 0 or 1.
# There is exactly one island in grid.
class Solution:
    def islandPerimeter(self, grid: List[List[int]]) -> int:
        ans: int = 0
        moves: list[list[int, int]] = [[0, -1], [-1, 0], [0, 1], [1, 0]]
        n, m = len(grid), len(grid[0])
        for rows in range(n):
            for cols in range(m):
                if grid[rows][cols] == 1:
                    for mov in moves:
                        x, y = mov
                        if (rows + x < 0 or rows + x == n) or (cols + y < 0 or cols + y == m):
                            ans += 1
                            continue
                        ans += grid[rows + x][cols + y] == 0
        return ans
    
# Cantor's Diagonals
# Given a list of lists containing only 1s and 0s, return a new list that differs from list 1 in its first element, list 2 in its second element, list 3 in its 3rd element, and so on.
#
# cantor([[0,0,0],
#         [1,1,1],
#         [0,1,0]]) = [1,0,1]
#
# cantor([[1,0,0],
#         [0,1,0],
#         [0,0,1]]) = [0,0,0]
# The nested list will always be perfectly square. Your solution should be a list containing only 1s and 0s.
#
# See Wikipedia for background (if you're interested; it won't help you solve the kata). Obviously this kata is not the same because the lists are not infinite so it doesn't really prove anything -- consider it a tribute...
#
# FUNDAMENTALS
def cantor(nested_list):
    return [int(not bool(nested_list[i][i])) for i in range(len(nested_list))]

# 961. N-Repeated Element in Size 2N Array
# You are given an integer array nums with the following properties:
#
# nums.length == 2 * n.
# nums contains n + 1 unique elements.
# Exactly one element of nums is repeated n times.
# Return the element that is repeated n times.
#
#
#
# Example 1:
#
# Input: nums = [1,2,3,3]
# Output: 3
# Example 2:
#
# Input: nums = [2,1,2,5,3,2]
# Output: 2
# Example 3:
#
# Input: nums = [5,1,5,2,5,3,5,4]
# Output: 5
#
#
# Constraints:
#
# 2 <= n <= 5000
# nums.length == 2 * n
# 0 <= nums[i] <= 104
# nums contains n + 1 unique elements and one of them is repeated exactly n times.
class Solution:
    def repeatedNTimes(self, nums: List[int]) -> int:
        for i in range(2, len(nums)):
            if nums[i] == nums[i - 1] or nums[i] == nums[i - 2]:
                return nums[i]
        return nums[0]
    
# All or Nothing
# Suppose a student can earn 100% on an exam by getting the answers all correct or all incorrect. Given a potentially incomplete answer key and the student's answers, write a function that determines whether or not a student can still score 100%. Incomplete questions are marked with an underscore, "_".
#
# ["A", "_", "C", "_", "B"]   # answer key
# ["A", "D", "C", "E", "B"]   # student's solution
#
# ➞ True
#
# # Possible for student to get all questions correct.
#
# ["B", "_", "B"]   # answer key
# ["B", "D", "C"]   # student's solution
#
# ➞ False
#
# # First question is correct but third is wrong, so not possible to score 100%.
#
# ["T", "_", "F", "F", "F"]   # answer key
# ["F", "F", "T", "T", "T"]   # student's solution
#
# ➞ True
#
# # Possible for student to get all questions incorrect.
# Examples
#
# (["B", "A", "_", "_"], ["B", "A", "C", "C"]) ➞ True
#
# (["A", "B", "A", "_"], ["B", "A", "C", "C"]) ➞ True
#
# (["A", "B", "C", "_"], ["B", "A", "C", "C"]) ➞ False
#
# (["B", "_"], ["C", "A"]) ➞ True
#
# (["B", "A"], ["C", "A"]) ➞ False
#
# (["B"], ["B"]) ➞ True
#
# (["_"], ["B"]) ➞ True
# Notes
#
# Test has at least one question.
# len(key) == len(answers)
# ALGORITHMSARRAYS
 def possibly_perfect(key, answers):
    for i in range(len(key) - 1, -1, -1):
        if key[i] == '_':
            answers.pop(i)
            key.pop(i)
    flag_true: bool = all(key[i] == answers[i] for i in range(len(key)))
    flag_false: bool = all(key[i] != answers[i] for i in range(len(key)))
    return flag_true or flag_false

# 807. Max Increase to Keep City Skyline
# There is a city composed of n x n blocks, where each block contains a single building shaped like a vertical square prism. You are given a 0-indexed n x n integer matrix grid where grid[r][c] represents the height of the building located in the block at row r and column c.
#
# A city's skyline is the outer contour formed by all the building when viewing the side of the city from a distance. The skyline from each cardinal direction north, east, south, and west may be different.
#
# We are allowed to increase the height of any number of buildings by any amount (the amount can be different per building). The height of a 0-height building can also be increased. However, increasing the height of a building should not affect the city's skyline from any cardinal direction.
#
# Return the maximum total sum that the height of the buildings can be increased by without changing the city's skyline from any cardinal direction.
#
#
#
# Example 1:
#
#
# Input: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]
# Output: 35
# Explanation: The building heights are shown in the center of the above image.
# The skylines when viewed from each cardinal direction are drawn in red.
# The grid after increasing the height of buildings without affecting skylines is:
# gridNew = [ [8, 4, 8, 7],
#             [7, 4, 7, 7],
#             [9, 4, 8, 7],
#             [3, 3, 3, 3] ]
# Example 2:
#
# Input: grid = [[0,0,0],[0,0,0],[0,0,0]]
# Output: 0
# Explanation: Increasing the height of any building will result in the skyline changing.
#
#
# Constraints:
#
# n == grid.length
# n == grid[r].length
# 2 <= n <= 50
# 0 <= grid[r][c] <= 100
class Solution:
    def maxIncreaseKeepingSkyline(self, grid: List[List[int]]) -> int:
        rows: list[int] = [max(row) for row in grid]
        cols: list[int] = [max(grid[row][col] for row in range(len(grid))) for col in range(len(grid[0]))]
        ans: int = 0
        for row in range(len(grid)):
            for col in range(len(grid[0])):
                ans += min(rows[row], cols[col]) - grid[row][col]
        return ans
    
# DNA Sequence Tester
# DNA is a biomolecule that carries genetic information. It is composed of four different building blocks, called nucleotides: adenine (A), thymine (T), cytosine (C) and guanine (G). Two DNA strands join to form a double helix, whereby the nucleotides of one strand bond to the nucleotides of the other strand at the corresponding positions. The bonding is only possible if the nucleotides are complementary: A always pairs with T, and C always pairs with G.
#
# Due to the asymmetry of the DNA, every DNA strand has a direction associated with it. The two strands of the double helix run in opposite directions to each other, which we refer to as the 'up-down' and the 'down-up' directions.
#
# Write a function checkDNA that takes in two DNA sequences as strings, and checks if they are fit to form a fully complementary DNA double helix. The function should return a Boolean true if they are complementary, and false if there is a sequence mismatch (Example 1 below).
#
# Note:
#
# All sequences will be of non-zero length, and consisting only of A, T, C and G characters.
# All sequences will be given in the up-down direction.
# The two sequences to be compared can be of different length. If this is the case and one strand is entirely bonded by the other, and there is no sequence mismatch between the two (Example 2 below), your function should still return true.
# If both strands are only partially bonded (Example 3 below), the function should return false.
# Example 1:
#
# seq1 = 'GTCTTAGTGTAGCTATGCATGC';  // NB up-down
# seq2 = 'GCATGCATAGCTACACTACGAC';  // NB up-down
#
# checkDNA (seq1, seq2);
# // --> false
#
# // Because there is a sequence mismatch at position 4:
# // (seq1)    up-GTCTTAGTGTAGCTATGCATGC-down
# //              ||| ||||||||||||||||||
# // (seq2)  down-CAGCATCACATCGATACGTACG-up
# Example 2:
#
# seq1 = 'GCGCTGCTAGCTGATCGA';             // NB up-down
# seq2 = 'ACGTACGATCGATCAGCTAGCAGCGCTAC';  // NB up-down
#
# checkDNA (seq1, seq2);
# // --> true
#
# // Because one strand is entirely bonded by the other:
# // (seq1)       up-GCGCTGCTAGCTGATCGA-down
# //                 ||||||||||||||||||
# // (seq2)  down-CATCGCGACGATCGACTAGCTAGCATGCA-up
# Example 3:
#
# seq1 = 'CGATACGAACCCATAATCG';  // NB up-down
# seq2 = 'CTACACCGGCCGATTATGG';  // NB up-down
#
# checkDNA (seq1, seq2);
# // --> false
#
# // Because both strands are only partially bonded:
# // (seq1)  up-CGATACGAACCCATAATCG-down
# //                      |||||||||
# // (seq2)          down-GGTATTAGCCGGCCACATC-up
# If you enjoyed this kata, check out also my other DNA kata: Longest Repeated DNA Motif
# FUNDAMENTALSSTRINGS
def checking(first: str, second: str) -> bool:
    return first.translate(str.maketrans('ATGC', 'TACG')) in second
def check_DNA(seq1, seq2):
    seq2 = seq2[::-1]
    if len(seq1) <= len(seq2):
        return checking(seq1, seq2)
    return checking(seq2, seq1)

# 1828. Queries on Number of Points Inside a Circle
# You are given an array points where points[i] = [xi, yi] is the coordinates of the ith point on a 2D plane. Multiple points can have the same coordinates.
#
# You are also given an array queries where queries[j] = [xj, yj, rj] describes a circle centered at (xj, yj) with a radius of rj.
#
# For each query queries[j], compute the number of points inside the jth circle. Points on the border of the circle are considered inside.
#
# Return an array answer, where answer[j] is the answer to the jth query.
#
#
#
# Example 1:
#
#
# Input: points = [[1,3],[3,3],[5,3],[2,2]], queries = [[2,3,1],[4,3,1],[1,1,2]]
# Output: [3,2,2]
# Explanation: The points and circles are shown above.
# queries[0] is the green circle, queries[1] is the red circle, and queries[2] is the blue circle.
# Example 2:
#
#
# Input: points = [[1,1],[2,2],[3,3],[4,4],[5,5]], queries = [[1,2,2],[2,2,2],[4,3,2],[4,3,3]]
# Output: [2,3,2,4]
# Explanation: The points and circles are shown above.
# queries[0] is green, queries[1] is red, queries[2] is blue, and queries[3] is purple.
#
#
# Constraints:
#
# 1 <= points.length <= 500
# points[i].length == 2
# 0 <= x​​​​​​i, y​​​​​​i <= 500
# 1 <= queries.length <= 500
# queries[j].length == 3
# 0 <= xj, yj <= 500
# 1 <= rj <= 500
# All coordinates are integers.
#
#
# Follow up: Could you find the answer for each query in better complexity than O(n)?
class Solution:
    def countPoints(self, points: List[List[int]], queries: List[List[int]]) -> List[int]:
        ans: list[int] = [0] * len(queries)
        for i in range(len(queries)):
            top: int = 0
            for pair in points:
                euclide: float = ((queries[i][0] - pair[0])**2 + (queries[i][1] - pair[1])**2)**.5
                if queries[i][2] >= euclide:
                    top += 1
            ans[i] = top
        return ans

# Sequence convergence
# Consider the following series:
#
# 1, 2, 4, 8, 16, 22, 26, 38, 62, 74, 102, 104, 108, 116, 122
#
# It is generated as follows:
#
# For single digit integers, add the number to itself to get the next element.
# For other integers, multiply all the non-zero digits and add the result to the original number to get the next element.
# For example: 16 + (6 * 1) = 22 and 104 + (4 * 1) = 108.
#
# Let's begin the same series with a seed value of 3 instead of 1:
#
# 3, 6, 12, 14, 18, 26, 38, 62, 74, 102, 104, 108, 116, 122
#
# Notice that the two sequences converge at 26 and are identical therefter. We will call the series seeded by a value of 1 the "base series" and the other series the "test series".
#
# Let's look another test series that starts with 15
#
# 15, 20, 22, 26, 38, 62, 74, 102, 104, 108, 116, 122
#
# The sequences converge at 22 if the test series starts with 15
#
# You will be given a seed value for the test series and your task will be to return the number of integers that have to be generated in the test series before it converges to the base series. In the case above:
#
# convergence(3) = 5, the length of [3, 6, 12, 14, 18].
# convergence(15) = 2, the length of [15, 20].
# Good luck!
#
# If you like this Kata, please try:
#
# Simple Prime Streaming
#
# Unique digit sequence
#
# Divisor harmony
#
# ALGORITHMS
from math import prod
def generate(x: int) -> int:
    if x < 10:
        return x * 2
    return x + prod(i for i in map(int, str(x)) if i > 0)
def convergence(n):
    base: int = 1
    ans_ln: int = 0
    while base != n:
        while base < n:
            base = generate(base)
        while n < base:
            ans_ln += 1
            n = generate(n)
    return ans_ln

# 1051. Height Checker
# A school is trying to take an annual photo of all the students. The students are asked to stand in a single file line in non-decreasing order by height. Let this ordering be represented by the integer array expected where expected[i] is the expected height of the ith student in line.
#
# You are given an integer array heights representing the current order that the students are standing in. Each heights[i] is the height of the ith student in line (0-indexed).
#
# Return the number of indices where heights[i] != expected[i].
#
#
#
# Example 1:
#
# Input: heights = [1,1,4,2,1,3]
# Output: 3
# Explanation:
# heights:  [1,1,4,2,1,3]
# expected: [1,1,1,2,3,4]
# Indices 2, 4, and 5 do not match.
# Example 2:
#
# Input: heights = [5,1,2,3,4]
# Output: 5
# Explanation:
# heights:  [5,1,2,3,4]
# expected: [1,2,3,4,5]
# All indices do not match.
# Example 3:
#
# Input: heights = [1,2,3,4,5]
# Output: 0
# Explanation:
# heights:  [1,2,3,4,5]
# expected: [1,2,3,4,5]
# All indices match.
#
#
# Constraints:
#
# 1 <= heights.length <= 100
# 1 <= heights[i] <= 100
class Solution:
    def heightChecker(self, heights: List[int]) -> int:
        arr: list[int] = [0] * 101
        ans: int = 0
        idx: int = 0
        for i in heights:
            arr[i] += 1
        for i in heights:
            while not arr[idx]:
                idx += 1
            if idx != i:
                ans += 1
            arr[idx] -= 1
        return ans

# Memesorting
# Roma is programmer and he likes memes about IT,
# Maxim is chemist and he likes memes about chemistry,
# Danik is designer and he likes memes about design,
# and Vlad likes all other memes.
#
# You will be given a meme (string), and your task is to identify its category, and send it to the right receiver: IT - 'Roma', chemistry - 'Maxim', design - 'Danik', or other - 'Vlad'.
#
# IT meme has letters b, u, g.
# Chemistry meme has letters b, o, o, m.
# Design meme has letters e, d, i, t, s.
# If there is more than 1 possible answer, the earliest match should be chosen.
#
# Note: letters are case-insensetive and should come in the order specified above.
#
# Examples:
# (Matching letters are surrounded by curly braces for readability.)
#
# this is programmer meme {b}ecause it has b{ug}
# this is also program{bu}r meme {g}ecause it has needed key word
# this is {ed}s{i}gner meme cause i{t} ha{s} key word
#
# this could {b}e chemistry meme b{u}t our{g}Gey word 'boom' is too late
#     instead of
# this could {b}e chemistry meme but {o}ur gey w{o}rd 'boo{m}' is too late
# STRINGSREGULAR EXPRESSIONSFUNDAMENTALSSORTING
def memesorting(meme):
    it: list[str] = ['b', 'u', 'g']
    x, y, z = 0, 0, 0
    ht: dict[int, str] = {'Roma': x, 'Maxim': y, 'Danik': z}
    chemistry: list[str] = ['b', 'o', 'o', 'm']
    design: list[str] = ['e', 'd', 'i', 't', 's']
    for i in range(len(meme)):
        if meme[i].lower() == it[0]:
            it.pop(0)
            x += 1
        if meme[i].lower() == chemistry[0]:
            chemistry.pop(0)
            y += i
        if meme[i].lower() == design[0]:
            design.pop(0)
            z += i
        ht = {'Roma': x, 'Maxim': y, 'Danik': z}
        stack: list[int] = [[x, y, z][i] for i in range(3) if not [it, chemistry, design][i]]
        if stack:
            return [k for k, v in ht.items() if v == min(stack)][0]
    return 'Vlad'

# 2373. Largest Local Values in a Matrix
# You are given an n x n integer matrix grid.
#
# Generate an integer matrix maxLocal of size (n - 2) x (n - 2) such that:
#
# maxLocal[i][j] is equal to the largest value of the 3 x 3 matrix in grid centered around row i + 1 and column j + 1.
# In other words, we want to find the largest value in every contiguous 3 x 3 matrix in grid.
#
# Return the generated matrix.
#
#
#
# Example 1:
#
#
# Input: grid = [[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]]
# Output: [[9,9],[8,6]]
# Explanation: The diagram above shows the original matrix and the generated matrix.
# Notice that each value in the generated matrix corresponds to the largest value of a contiguous 3 x 3 matrix in grid.
# Example 2:
#
#
# Input: grid = [[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]]
# Output: [[2,2,2],[2,2,2],[2,2,2]]
# Explanation: Notice that the 2 is contained within every contiguous 3 x 3 matrix in grid.
#
#
# Constraints:
#
# n == grid.length == grid[i].length
# 3 <= n <= 100
# 1 <= grid[i][j] <= 100
class Solution:
    def largestLocal(self, grid: List[List[int]]) -> List[List[int]]:
        n: int = len(grid)
        ans: list[int] = [[0] * (n - 2) for i in range(n - 2)]
        for i in range(n - 2):
            for j in range(n - 2):
                ans[i][j] = max(grid[row][col] for row in range(i, i + 3) for col in range(j, j + 3))
        return ans
    
# Matrix Rotation
# Given a matrix represented as a list of string, such as
#
# ###.....
# ..###...
# ....###.
# .....###
# .....###
# ....###.
# ..###...
# ###.....
# write a function
#
# rotate_clockwise(matrix)
#
# that return its 90° clockwise rotation, for our example:
#
# #......#
# #......#
# ##....##
# .#....#.
# .##..##.
# ..####..
# ..####..
# ...##...
#  /!\ You must return a rotated copy of matrix! (matrix must be the same before and after calling your function)
# Note that the matrix isn't necessarily a square, though it's always a rectangle!
# Please also note that the equality m == rotateClockwise(rotateClockwise(rotateClockwise(rotateClockwise(m)))); (360° clockwise rotation), is not always true because rotateClockwise(['']) => [] and rotateClockwise(['','','']) => [] (empty lines information is lost)
#
# MATRIXFUNDAMENTALS
 def rotate_clockwise(matrix):
    ans: list = list()
    if not matrix:
        return ans
    for col in range(len(matrix[0])):
        top: list = list()
        for row in range(len(matrix)):
            top.append(matrix[row][col])
        ans.append(''.join(top)[::-1])
    return ans

# 1769. Minimum Number of Operations to Move All Balls to Each Box
# You have n boxes. You are given a binary string boxes of length n, where boxes[i] is '0' if the ith box is empty, and '1' if it contains one ball.
#
# In one operation, you can move one ball from a box to an adjacent box. Box i is adjacent to box j if abs(i - j) == 1. Note that after doing so, there may be more than one ball in some boxes.
#
# Return an array answer of size n, where answer[i] is the minimum number of operations needed to move all the balls to the ith box.
#
# Each answer[i] is calculated considering the initial state of the boxes.
#
#
#
# Example 1:
#
# Input: boxes = "110"
# Output: [1,1,3]
# Explanation: The answer for each box is as follows:
# 1) First box: you will have to move one ball from the second box to the first box in one operation.
# 2) Second box: you will have to move one ball from the first box to the second box in one operation.
# 3) Third box: you will have to move one ball from the first box to the third box in two operations, and move one ball from the second box to the third box in one operation.
# Example 2:
#
# Input: boxes = "001011"
# Output: [11,8,5,4,3,4]
#
#
# Constraints:
#
# n == boxes.length
# 1 <= n <= 2000
# boxes[i] is either '0' or '1'.
class Solution:
    def minOperations(self, boxes: str) -> List[int]:
        n: int = len(boxes)
        ans: list[int] = [0] * n
        left_frq_ones, left_sm_ones = 0, 0
        for i in range(1, n):
            if boxes[i - 1] == '1':
                left_frq_ones += 1
            left_sm_ones += left_frq_ones
            ans[i] += left_sm_ones
        right_frq_ones, right_sm_ones = 0, 0
        for i in range(n - 2, -1, -1):
            if boxes[i + 1] == '1':
                right_frq_ones += 1
            right_sm_ones += right_frq_ones
            ans[i] += right_sm_ones
        return ans

# 1137. N-th Tribonacci Number
# The Tribonacci sequence Tn is defined as follows:
#
# T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.
#
# Given n, return the value of Tn.
#
#
#
# Example 1:
#
# Input: n = 4
# Output: 4
# Explanation:
# T_3 = 0 + 1 + 1 = 2
# T_4 = 1 + 1 + 2 = 4
# Example 2:
#
# Input: n = 25
# Output: 1389537
#
#
# Constraints:
#
# 0 <= n <= 37
# The answer is guaranteed to fit within a 32-bit integer, ie. answer <= 2^31 - 1.
class Solution:
    def tribonacci(self, n: int, a: int = 0, b: int = 0, c: int = 1) -> int:
        if n == 0:
            return b
        return self.tribonacci(n - 1, b, c, a + b + c)
    
# A Man and his Umbrellas
# A Man and his Umbrellas
# Each morning a man walks to work, and each afternoon he walks back home.
#
# If it is raining in the morning and he has an umbrella at home, he takes an umbrella for the journey so he doesn't get wet, and stores it at work. Likewise, if it is raining in the afternoon and he has an umbrella at work, he takes an umbrella for the journey home.
#
# Given an array of the weather conditions, your task is to work out the minimum number of umbrellas he needs to start with in order that he never gets wet. He can start with some umbrellas at home and some at work, but the output is a single integer, the minimum total number.
#
# The input is an array/list of consecutive half-day weather forecasts. So, e.g. the first value is the 1st day's morning weather and the second value is the 1st day's afternoon weather. The options are:
#
# Without umbrella:
#
# "clear",
# "sunny",
# "cloudy",
# "overcast",
# "windy".
# With umbrella:
#
# "rainy",
# "thunderstorms".
# e.g. for three days, 6 values:
#
# weather = ["rainy", "cloudy", "sunny", "sunny", "cloudy", "thunderstorms"]
# N.B. He never takes an umbrella if it is not raining.
#
# Examples:
# minUmbrellas(["rainy", "clear", "rainy", "cloudy"])
# should return 2
#
# Because on the first morning, he needs an umbrella to take, and he leaves it at work. So on the second morning, he needs a second umbrella.
#
# minUmbrellas(["sunny", "windy", "sunny", "clear"])
# should return 0
#
# Because it doesn't rain at all
#
# minUmbrellas(["rainy", "rainy", "rainy", "rainy", "thunderstorms", "rainy"])
# should return 1
#
# Because he only needs 1 umbrella which he takes on every journey.
#
# LOGICARRAYSFUNDAMENTALS
def min_umbrellas(weather):
    home: int = 0
    work: int = 0
    umbrella: int = 0
    for i in range(len(weather)):
        if weather[i] in {'rainy', 'thunderstorms'}:
            if i % 2 == 0:
                if home > 0:
                    home -= 1
                else:
                    umbrella += 1
                work += 1
            else:
                if work > 0:
                    work -= 1
                else:
                    umbrella += 1
                home += 1
    return umbrella

# 11. Container With Most Water
# You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).
#
# Find two lines that together with the x-axis form a container, such that the container contains the most water.
#
# Return the maximum amount of water a container can store.
#
# Notice that you may not slant the container.
#
#
#
# Example 1:
#
#
# Input: height = [1,8,6,2,5,4,8,3,7]
# Output: 49
# Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.
# Example 2:
#
# Input: height = [1,1]
# Output: 1
#
#
# Constraints:
#
# n == height.length
# 2 <= n <= 105
# 0 <= height[i] <= 104
class Solution:
    def maxArea(self, height: List[int]) -> int:
        ans: int = 0
        left, right = 0, len(height) - 1
        while left < right:
            ans = max(ans, min(height[left], height[right]) * (right - left))
            if height[left] <= height[right]:
                left += 1
            else:
                right -= 1
        return ans

# Number Shortening Filter
# Here is a new kata that Codewars asked me to do related to interviewing and working in a production setting.
#
# You might be familar with and have used Angular.js. Among other things, it lets you create your own filters that work as functions. You can then put these in a page to perform specific data changes, such as shortening a number to display a more concise notation.
#
# In this kata, we will create a function which returns another function (or process, in Ruby) that shortens very long numbers. Given an initial array of values replace the Xth power of a given base. If the input of the returned function is not a numerical string, it should return the input itself as a string.
#
# Here's an example, which is worth a thousand words:
#
# filter1 = shorten_number(['','k','m'],1000)
# filter1('234324') == '234k'
# filter1('98234324') == '98m'
# filter1([1,2,3]) == '[1,2,3]'
# filter2 = shorten_number(['B','KB','MB','GB'],1024)
# filter2('32') == '32B'
# filter2('2100') == '2KB';
# filter2('pippi') == 'pippi'
# If you like to test yourself on kata related to actual work and interviews, consider trying this kata where you will build a breadcrumb generator
#
# ANGULARALGORITHMS
def shorten_number(suffixes, base):
    suffixes: list[str] = list(suffixes)
    base: int = base
    def inner(n):
        nonlocal base
        nonlocal suffixes
        if not isinstance(n, str) or not n.isdigit():
            return str(n)
        n = int(n)
        idx: int = 0
        while n >= base and idx < len(suffixes) - 1:
            idx += 1
            n //= base
        return f'{n}{suffixes[idx]}'
    return inner

# 134. Gas Station
# There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i].
#
# You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations.
#
# Given two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique
#
#
#
# Example 1:
#
# Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
# Output: 3
# Explanation:
# Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
# Travel to station 4. Your tank = 4 - 1 + 5 = 8
# Travel to station 0. Your tank = 8 - 2 + 1 = 7
# Travel to station 1. Your tank = 7 - 3 + 2 = 6
# Travel to station 2. Your tank = 6 - 4 + 3 = 5
# Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.
# Therefore, return 3 as the starting index.
# Example 2:
#
# Input: gas = [2,3,4], cost = [3,4,3]
# Output: -1
# Explanation:
# You can't start at station 0 or 1, as there is not enough gas to travel to the next station.
# Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
# Travel to station 0. Your tank = 4 - 3 + 2 = 3
# Travel to station 1. Your tank = 3 - 3 + 3 = 3
# You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.
# Therefore, you can't travel around the circuit once no matter where you start.
#
#
# Constraints:
#
# n == gas.length == cost.length
# 1 <= n <= 105
# 0 <= gas[i], cost[i] <= 104
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        if sum(i for i in gas) < sum(i for i in cost):
            return -1
        start: int = 0
        total: int = 0
        for i in range(len(gas)):
            total += gas[i] - cost[i]
            if total < 0:
                start = i + 1
                total = 0
        return start

# PatternCraft - Adapter
# The Adapter Design Pattern can be used, for example in the StarCraft game, to insert an external character in the game.
#
# The pattern consists in having a wrapper class that will adapt the code from the external source.
#
# Your Task
# The adapter receives an instance of the object that it is going to adapt and handles it in a way that works with our application.
#
# In this example we have the pre-loaded classes:
#
# class Target:
#     def __init__(self, health):
#         self.health = health
#
# class Marine:
#     @staticmethod
#     def attack(target):
#         target.health -= 6
#
# class Zealot:
#     @staticmethod
#     def attack(target):
#         target.health -= 8
#
# class Zergling:
#     @staticmethod
#     def attack(target):
#         target.health -= 5
#
# class Mario:
#     @staticmethod
#     def jump_attack():
#         print('Mamamia!')
#         return 3
# Complete the code so that we can create a MarioAdapter that can attack as other units do.
#
# Note to calculate how much damage mario is going to do you have to call the jumpAttack method (jump_attack in Python).
#
# Resources
# PatternCraft > Adapter
# SourceMaking > Adapter
# Wikipedia > Adapter
# PatternCraft series
# State Pattern
# Strategy Pattern
# Visitor Pattern
# Decorator Pattern
# Adapter Pattern
# Command Pattern
# The original PatternCraft series (by John Lindquist) is a collection of Youtube videos that explains some of the design patterns and how they are used (or could be) on StarCraft.
#
# DESIGN PATTERNSFUNDAMENTALS
class MarioAdapter:
    def __init__(self, mario=None):
        if mario is None:
            raise TypeError("MarioAdapter.__init__() missing 1 required positional argument: 'mario'")
        self.mario = mario

    def attack(self, target):
        target.health -= self.mario.jump_attack()
        
# 1381. Design a Stack With Increment Operation
# Design a stack that supports increment operations on its elements.
#
# Implement the CustomStack class:
#
# CustomStack(int maxSize) Initializes the object with maxSize which is the maximum number of elements in the stack.
# void push(int x) Adds x to the top of the stack if the stack has not reached the maxSize.
# int pop() Pops and returns the top of the stack or -1 if the stack is empty.
# void inc(int k, int val) Increments the bottom k elements of the stack by val. If there are less than k elements in the stack, increment all the elements in the stack.
#
#
# Example 1:
#
# Input
# ["CustomStack","push","push","pop","push","push","push","increment","increment","pop","pop","pop","pop"]
# [[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]
# Output
# [null,null,null,2,null,null,null,null,null,103,202,201,-1]
# Explanation
# CustomStack stk = new CustomStack(3); // Stack is Empty []
# stk.push(1);                          // stack becomes [1]
# stk.push(2);                          // stack becomes [1, 2]
# stk.pop();                            // return 2 --> Return top of the stack 2, stack becomes [1]
# stk.push(2);                          // stack becomes [1, 2]
# stk.push(3);                          // stack becomes [1, 2, 3]
# stk.push(4);                          // stack still [1, 2, 3], Do not add another elements as size is 4
# stk.increment(5, 100);                // stack becomes [101, 102, 103]
# stk.increment(2, 100);                // stack becomes [201, 202, 103]
# stk.pop();                            // return 103 --> Return top of the stack 103, stack becomes [201, 202]
# stk.pop();                            // return 202 --> Return top of the stack 202, stack becomes [201]
# stk.pop();                            // return 201 --> Return top of the stack 201, stack becomes []
# stk.pop();                            // return -1 --> Stack is empty return -1.
#
#
# Constraints:
#
# 1 <= maxSize, x, k <= 1000
# 0 <= val <= 100
# At most 1000 calls will be made to each method of increment, push and pop each separately.
class CustomStack:

    def __init__(self, maxSize: int):
        self.max_size: int = maxSize
        self.capacity: int = 0
        self.stack: list[int] = [0] * self.max_size

    def push(self, x: int) -> None:
        if self.capacity < self.max_size:
            self.stack[self.capacity] = x
            self.capacity += 1

    def pop(self) -> int:
        if self.capacity > 0:
            self.capacity -= 1
            x: int = self.stack[self.capacity]
            self.stack[self.capacity] = 0
            return x
        return -1

    def increment(self, k: int, val: int) -> None:
        for i in range(min(self.capacity, k)):
            self.stack[i] += val
            
# Emojicode
# In this challenge, you have to create two functions to convert an emoji string to the "emojicode" format, and back.
#
# Emoji strings consist solely of Unicode emojis, and each of the emojis can be represented with a single Unicode code point. There is no combining characters, variant selectors, joiners, direction modifiers, color modifiers, groups of people, or any other emojis which consist of more than a single code point.
#
# Emojicode string is a string of space separated code points of Unicode emojis. Every code point is formatted as its decimal value, stringified into a sequence of Unicode emoji keycap digits.
#
# Examples
# The emoji "SMILING FACE WITH SMILING EYES" 😊 is encoded as U+1F60A. The decimal value of its code point is 128522. After converting the value to a string and using emoji keycaps for digits, the emojicode is "1️⃣2️⃣8️⃣5️⃣2️⃣2️⃣".
#
# The three emojis SEE-/HEAR-/SPEAK-NO-EVIL MONKEY are represented by code points U+1F648, U+1F649, and U+1F64A, which are decimal 128584, 128585 and 128586, respectively. Therefore, the string "🙈🙉🙊" after conversion to emojicode results in "1️⃣2️⃣8️⃣5️⃣8️⃣4️⃣ 1️⃣2️⃣8️⃣5️⃣8️⃣5️⃣ 1️⃣2️⃣8️⃣5️⃣8️⃣6️⃣".
#
# Tests size
# At the moment of the writing, Unicode Emoji Standard includes ~1380 emojis which can be represented with a single Unicode code point (see References below). Each of these emojis is tested at least once for conversion in both directions, with fixed tests. Additionally, small random tests check 50 strings of 1-5 emojis and 200 strings of 20-50 emojis, for conversion in both directions.
#
# References
# List of Unicode emojis
#
# STRINGSUNICODE
def to_emojicode(emojis):
    numbers: str = ['0️⃣', '1️⃣', '2️⃣', '3️⃣', '4️⃣', '5️⃣', '6️⃣', '7️⃣', '8️⃣', '9️⃣']
    ans: list[str] = list()
    for i in emojis:
        top: list[str] = list()
        for j in str(ord(i)):
            top.append(numbers[int(j)])
        ans.append(''.join(top))
    return ' '.join(ans)
def to_emojis(emojicode):
    ans: list[str] = list()
    top: list[str] = list()
    stack: int = 0
    for i in emojicode:
        if i.isdigit():
            top.append(i)
            stack = 0
        else:
            stack += 1
            if stack == 3:
                ans.append(chr(int(''.join(top))))
                top = []
                stack = 0
    ans.append(chr(int(''.join(top))))
    return ''.join(ans)

# 2356. Number of Unique Subjects Taught by Each Teacher
# Table: Teacher
#
# +-------------+------+
# | Column Name | Type |
# +-------------+------+
# | teacher_id  | int  |
# | subject_id  | int  |
# | dept_id     | int  |
# +-------------+------+
# (subject_id, dept_id) is the primary key (combinations of columns with unique values) of this table.
# Each row in this table indicates that the teacher with teacher_id teaches the subject subject_id in the department dept_id.
#
#
# Write a solution to calculate the number of unique subjects each teacher teaches in the university.
#
# Return the result table in any order.
#
# The result format is shown in the following example.
#
#
#
# Example 1:
#
# Input:
# Teacher table:
# +------------+------------+---------+
# | teacher_id | subject_id | dept_id |
# +------------+------------+---------+
# | 1          | 2          | 3       |
# | 1          | 2          | 4       |
# | 1          | 3          | 3       |
# | 2          | 1          | 1       |
# | 2          | 2          | 1       |
# | 2          | 3          | 1       |
# | 2          | 4          | 1       |
# +------------+------------+---------+
# Output:
# +------------+-----+
# | teacher_id | cnt |
# +------------+-----+
# | 1          | 2   |
# | 2          | 4   |
# +------------+-----+
# Explanation:
# Teacher 1:
#   - They teach subject 2 in departments 3 and 4.
#   - They teach subject 3 in department 3.
# Teacher 2:
#   - They teach subject 1 in department 1.
#   - They teach subject 2 in department 1.
#   - They teach subject 3 in department 1.
#   - They teach subject 4 in department 1.
SELECT teacher_id, COUNT(DISTINCT subject_id) AS cnt
FROM Teacher
GROUP BY teacher_id

# 1741. Find Total Time Spent by Each Employee
# Table: Employees
#
# +-------------+------+
# | Column Name | Type |
# +-------------+------+
# | emp_id      | int  |
# | event_day   | date |
# | in_time     | int  |
# | out_time    | int  |
# +-------------+------+
# (emp_id, event_day, in_time) is the primary key (combinations of columns with unique values) of this table.
# The table shows the employees' entries and exits in an office.
# event_day is the day at which this event happened, in_time is the minute at which the employee entered the office, and out_time is the minute at which they left the office.
# in_time and out_time are between 1 and 1440.
# It is guaranteed that no two events on the same day intersect in time, and in_time < out_time.
#
#
# Write a solution to calculate the total time in minutes spent by each employee on each day at the office. Note that within one day, an employee can enter and leave more than once. The time spent in the office for a single entry is out_time - in_time.
#
# Return the result table in any order.
#
# The result format is in the following example.
#
#
#
# Example 1:
#
# Input:
# Employees table:
# +--------+------------+---------+----------+
# | emp_id | event_day  | in_time | out_time |
# +--------+------------+---------+----------+
# | 1      | 2020-11-28 | 4       | 32       |
# | 1      | 2020-11-28 | 55      | 200      |
# | 1      | 2020-12-03 | 1       | 42       |
# | 2      | 2020-11-28 | 3       | 33       |
# | 2      | 2020-12-09 | 47      | 74       |
# +--------+------------+---------+----------+
# Output:
# +------------+--------+------------+
# | day        | emp_id | total_time |
# +------------+--------+------------+
# | 2020-11-28 | 1      | 173        |
# | 2020-11-28 | 2      | 30         |
# | 2020-12-03 | 1      | 41         |
# | 2020-12-09 | 2      | 27         |
# +------------+--------+------------+
# Explanation:
# Employee 1 has three events: two on day 2020-11-28 with a total of (32 - 4) + (200 - 55) = 173, and one on day 2020-12-03 with a total of (42 - 1) = 41.
# Employee 2 has two events: one on day 2020-11-28 with a total of (33 - 3) = 30, and one on day 2020-12-09 with a total of (74 - 47) = 27.
SELECT event_day AS day, emp_id, SUM(out_time - in_time) AS total_time
FROM Employees
GROUP BY day, emp_id

# 1974. Minimum Time to Type Word Using Special Typewriter
# There is a special typewriter with lowercase English letters 'a' to 'z' arranged in a circle with a pointer. A character can only be typed if the pointer is pointing to that character. The pointer is initially pointing to the character 'a'.
#
#
# Each second, you may perform one of the following operations:
#
# Move the pointer one character counterclockwise or clockwise.
# Type the character the pointer is currently on.
# Given a string word, return the minimum number of seconds to type out the characters in word.
#
#
#
# Example 1:
#
# Input: word = "abc"
# Output: 5
# Explanation:
# The characters are printed as follows:
# - Type the character 'a' in 1 second since the pointer is initially on 'a'.
# - Move the pointer clockwise to 'b' in 1 second.
# - Type the character 'b' in 1 second.
# - Move the pointer clockwise to 'c' in 1 second.
# - Type the character 'c' in 1 second.
# Example 2:
#
# Input: word = "bza"
# Output: 7
# Explanation:
# The characters are printed as follows:
# - Move the pointer clockwise to 'b' in 1 second.
# - Type the character 'b' in 1 second.
# - Move the pointer counterclockwise to 'z' in 2 seconds.
# - Type the character 'z' in 1 second.
# - Move the pointer clockwise to 'a' in 1 second.
# - Type the character 'a' in 1 second.
# Example 3:
#
# Input: word = "zjpc"
# Output: 34
# Explanation:
# The characters are printed as follows:
# - Move the pointer counterclockwise to 'z' in 1 second.
# - Type the character 'z' in 1 second.
# - Move the pointer clockwise to 'j' in 10 seconds.
# - Type the character 'j' in 1 second.
# - Move the pointer clockwise to 'p' in 6 seconds.
# - Type the character 'p' in 1 second.
# - Move the pointer counterclockwise to 'c' in 13 seconds.
# - Type the character 'c' in 1 second.
#
#
# Constraints:
#
# 1 <= word.length <= 100
# word consists of lowercase English letters.
# Solution 1 Greedy O(N) O(1)
# Mind set
# if character more than half of alphabet size check path to conterwise otherwise to clockwise
class Solution:
    def minTimeToType(self, word: str) -> int:
        ans: int = len(word)
        current: int = ord('a')
        for i in word:
            ans += min(abs(current - ord(i)), abs(current - (ord(i) - (26 if ord(i) > 110 else -26))))
            current = ord(i)
        return ans
# Solution 2 Greedy O(N) O(1)
class Solution:
    def minTimeToType(self, word: str) -> int:
        ans: int = len(word)
        current: int = ord('a')
        for i in word:
            x: int = (ord(i) - current) % 26
            ans += min(x, 26 - x)
            current = ord(i)
        return ans

# 3132. Find the Integer Added to Array II
# You are given two integer arrays nums1 and nums2.
#
# From nums1 two elements have been removed, and all other elements have been increased (or decreased in the case of negative) by an integer, represented by the variable x.
#
# As a result, nums1 becomes equal to nums2. Two arrays are considered equal when they contain the same integers with the same frequencies.
#
# Return the minimum possible integer x that achieves this equivalence.
#
#
#
# Example 1:
#
# Input: nums1 = [4,20,16,12,8], nums2 = [14,18,10]
#
# Output: -2
#
# Explanation:
#
# After removing elements at indices [0,4] and adding -2, nums1 becomes [18,14,10].
#
# Example 2:
#
# Input: nums1 = [3,5,5,3], nums2 = [7,7]
#
# Output: 2
#
# Explanation:
#
# After removing elements at indices [0,3] and adding 2, nums1 becomes [7,7].
#
#
#
# Constraints:
#
# 3 <= nums1.length <= 200
# nums2.length == nums1.length - 2
# 0 <= nums1[i], nums2[i] <= 1000
# The test cases are generated in a way that there is an integer x such that nums1 can become equal to nums2 by removing two elements and adding x to each element of nums1.
class Solution:
    def minimumAddedInteger(self, nums1: List[int], nums2: List[int]) -> int:
        ans: int = float('inf')
        nums1.sort()
        nums2.sort()
        for i in range(len(nums1)):
            for j in range(i + 1, len(nums1)):
                x: list[int] = [nums1[k] for k in range(len(nums1)) if k not in {i, j}]
                union_lst: list[int] = [-x[k] + nums2[k] for k in range(len(nums2))]
                if len(set(union_lst)) == 1 and union_lst[0] < ans:
                    ans = union_lst[0]
        return ans

# 3111. Minimum Rectangles to Cover Points
# You are given a 2D integer array points, where points[i] = [xi, yi]. You are also given an integer w. Your task is to cover all the given points with rectangles.
#
# Each rectangle has its lower end at some point (x1, 0) and its upper end at some point (x2, y2), where x1 <= x2, y2 >= 0, and the condition x2 - x1 <= w must be satisfied for each rectangle.
#
# A point is considered covered by a rectangle if it lies within or on the boundary of the rectangle.
#
# Return an integer denoting the minimum number of rectangles needed so that each point is covered by at least one rectangle.
#
# Note: A point may be covered by more than one rectangle.
#
#
#
# Example 1:
#
#
#
# Input: points = [[2,1],[1,0],[1,4],[1,8],[3,5],[4,6]], w = 1
#
# Output: 2
#
# Explanation:
#
# The image above shows one possible placement of rectangles to cover the points:
#
# A rectangle with a lower end at (1, 0) and its upper end at (2, 8)
# A rectangle with a lower end at (3, 0) and its upper end at (4, 8)
# Example 2:
#
#
#
# Input: points = [[0,0],[1,1],[2,2],[3,3],[4,4],[5,5],[6,6]], w = 2
#
# Output: 3
#
# Explanation:
#
# The image above shows one possible placement of rectangles to cover the points:
#
# A rectangle with a lower end at (0, 0) and its upper end at (2, 2)
# A rectangle with a lower end at (3, 0) and its upper end at (5, 5)
# A rectangle with a lower end at (6, 0) and its upper end at (6, 6)
# Example 3:
#
#
#
# Input: points = [[2,3],[1,2]], w = 0
#
# Output: 2
#
# Explanation:
#
# The image above shows one possible placement of rectangles to cover the points:
#
# A rectangle with a lower end at (1, 0) and its upper end at (1, 2)
# A rectangle with a lower end at (2, 0) and its upper end at (2, 3)
#
#
# Constraints:
#
# 1 <= points.length <= 105
# points[i].length == 2
# 0 <= xi == points[i][0] <= 109
# 0 <= yi == points[i][1] <= 109
# 0 <= w <= 109
# All pairs (xi, yi) are distinct.
class Solution:
    def minRectanglesToCoverPoints(self, points: List[List[int]], w: int) -> int:
        points.sort(key=lambda x: x[0])
        ans: int = 1
        start: int = points[0][0]
        for i in points:
            if i[0] - start > w:
                start = i[0]
                ans += 1
        return ans

# 3115. Maximum Prime Difference
# You are given an integer array nums.
#
# Return an integer that is the maximum distance between the indices of two (not necessarily different) prime numbers in nums.
#
#
#
# Example 1:
#
# Input: nums = [4,2,9,5,3]
#
# Output: 3
#
# Explanation: nums[1], nums[3], and nums[4] are prime. So the answer is |4 - 1| = 3.
#
# Example 2:
#
# Input: nums = [4,8,2,8]
#
# Output: 0
#
# Explanation: nums[2] is prime. Because there is just one prime number, the answer is |2 - 2| = 0.
#
#
#
# Constraints:
#
# 1 <= nums.length <= 3 * 105
# 1 <= nums[i] <= 100
# The input is generated such that the number of prime numbers in the nums is at least one.
class Solution:
    from math import sqrt
    def isPrime(self, n: int) -> bool:
        prime_flag = 0
        if (n > 1):
            for i in range(2, int(sqrt(n)) + 1):
                if (n % i == 0):
                    prime_flag = 1
                    break
            if (prime_flag == 0):
                return True
            else:
                return False
        return False

    def maximumPrimeDifference(self, nums: List[int]) -> int:
        x, y = None, None
        for i in range(len(nums)):
            if self.isPrime(nums[i]):
                if x is None:
                    x = i
                else:
                    y = i
        return 0 if y is None else y - x

# 3121. Count the Number of Special Characters II
# You are given a string word. A letter c is called special if it appears both in lowercase and uppercase in word, and every lowercase occurrence of c appears before the first uppercase occurrence of c.
#
# Return the number of special letters in word.
#
#
#
# Example 1:
#
# Input: word = "aaAbcBC"
#
# Output: 3
#
# Explanation:
#
# The special characters are 'a', 'b', and 'c'.
#
# Example 2:
#
# Input: word = "abc"
#
# Output: 0
#
# Explanation:
#
# There are no special characters in word.
#
# Example 3:
#
# Input: word = "AbBCab"
#
# Output: 0
#
# Explanation:
#
# There are no special characters in word.
#
#
#
# Constraints:
#
# 1 <= word.length <= 2 * 105
# word consists of only lowercase and uppercase English letters.
class Solution:
    def numberOfSpecialChars(self, word: str) -> int:
        ht: dict[str, int] = dict()
        for i in range(len(word)):
            if word[i] not in ht:
                ht[word[i]] = i
            elif word[i].islower():
                ht[word[i]] = i
        ans: int = 0
        for i in ht:
            if (i.lower() in ht and i.upper() in ht) and ht[i.lower()] < ht[i.upper()]:
                ans += 1
        return ans // 2

# 3128. Right Triangles
# You are given a 2D boolean matrix grid.
#
# Return an integer that is the number of right triangles that can be made with the 3 elements of grid such that all of them have a value of 1.
#
# Note:
#
# A collection of 3 elements of grid is a right triangle if one of its elements is in the same row with another element and in the same column with the third element. The 3 elements do not have to be next to each other.
#
#
# Example 1:
#
# 0	1	0
# 0	1	1
# 0	1	0
# 0	1	0
# 0	1	1
# 0	1	0
# Input: grid = [[0,1,0],[0,1,1],[0,1,0]]
#
# Output: 2
#
# Explanation:
#
# There are two right triangles.
#
# Example 2:
#
# 1	0	0	0
# 0	1	0	1
# 1	0	0	0
# Input: grid = [[1,0,0,0],[0,1,0,1],[1,0,0,0]]
#
# Output: 0
#
# Explanation:
#
# There are no right triangles.
#
# Example 3:
#
# 1	0	1
# 1	0	0
# 1	0	0
# 1	0	1
# 1	0	0
# 1	0	0
# Input: grid = [[1,0,1],[1,0,0],[1,0,0]]
#
# Output: 2
#
# Explanation:
#
# There are two right triangles.
#
#
#
# Constraints:
#
# 1 <= grid.length <= 1000
# 1 <= grid[i].length <= 1000
# 0 <= grid[i][j] <= 1
class Solution:
    def numberOfRightTriangles(self, grid: List[List[int]]) -> int:
        ans: int = 0
        rows: list[list[int]] = [sum(grid[rows][cols] for rows in range(len(grid))) for cols in range(len(grid[0]))]
        for row in range(len(grid)):
            n: int = grid[row].count(1)
            if n > 1:
                for col in range(len(grid[0])):
                    if grid[row][col]:
                        ans += (n - 1) * (max(rows[col] - 1, 0))
        return ans
    
# 2D Cellular Neighbourhood
# This kata is the first part of a series: Neighbourhood kata collection. If this one is too easy you can try out the harder katas. ;)
#
# The neighbourhood of a cell (in a matrix) are cells that are near to it. There are two popular types:
#
# The Moore neighborhood are eight cells which surround a given cell
# The Von Neumann neighborhood are four cells which share a border with the given cell
# Task
# Given a neighbourhood type ("moore" or "von_neumann"), a 2D matrix (a list of lists) and a pair of coordinates, return the list of neighbours of the given cell.
#
# Notes:
#
# The order of the elements in the output list is not important
# If the input indexes are outside the matrix, return an empty list
# If the the matrix is empty, return an empty list
# Order of the indices: the first index should be applied for the outer/first matrix layer and the last index for the most inner/last layer. coordinates = (m, n) should be applied like mat[m][n]
# Examples
# \ n   0    1    2    3    4
# m  --------------------------
# 0  |  0 |  1 |  2 |  3 |  4 |
# 1  |  5 |  6 |  7 |  8 |  9 |
# 2  | 10 | 11 | 12 | 13 | 14 |
# 3  | 15 | 16 | 17 | 18 | 19 |
# 4  | 20 | 21 | 22 | 23 | 24 |
#    --------------------------
#
# get_neighborhood("moore", mat, (1,1)) == [0, 1, 2, 5, 7, 10, 11, 12]
# get_neighborhood("moore", mat, (0,0)) == [1, 6, 5]
# get_neighborhood("moore", mat, (4,2)) == [21, 16, 17, 18, 23]
# get_neighborhood("von_neumann", mat, (1,1)) == [1, 5, 7, 11]
# get_neighborhood("von_neumann", mat, (0,0)) == [1, 5]
# get_neighborhood("von_neumann", mat, (4,2)) == [21, 17, 23]
# Translations are appreciated
#
# If you like chess take a look at Chess Aesthetics
# If you like puzzles take a look at Rubik's cube
# ALGORITHMSDATA STRUCTURESARRAYSMATRIX
def get_neighbourhood(n_type, mat, cor):
    if not mat: return []
    if (cor[0] >= len(mat) or cor[0] < 0) or (cor[1] >= len(mat[0]) or cor[1] < 0):
        return []
    ht: dict[str, list[list[int]]] = {
        'moore': [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]],
        'von_neumann': [[-1, 0], [0, -1], [0, 1], [1, 0]]
    }
    ans: list[int] = list()
    for mov in ht[n_type]:
        if cor[0] + mov[0] >= len(mat) or cor[0] + mov[0] < 0: continue
        if cor[1] + mov[1] >= len(mat[0]) or cor[1] + mov[1] < 0: continue
        ans.append(mat[cor[0] + mov[0]][cor[1] + mov[1]])
    return ans

# 2997. Minimum Number of Operations to Make Array XOR Equal to K
# You are given a 0-indexed integer array nums and a positive integer k.
#
# You can apply the following operation on the array any number of times:
#
# Choose any element of the array and flip a bit in its binary representation. Flipping a bit means changing a 0 to 1 or vice versa.
# Return the minimum number of operations required to make the bitwise XOR of all elements of the final array equal to k.
#
# Note that you can flip leading zero bits in the binary representation of elements. For example, for the number (101)2 you can flip the fourth bit and obtain (1101)2.
#
#
#
# Example 1:
#
# Input: nums = [2,1,3,4], k = 1
# Output: 2
# Explanation: We can do the following operations:
# - Choose element 2 which is 3 == (011)2, we flip the first bit and we obtain (010)2 == 2. nums becomes [2,1,2,4].
# - Choose element 0 which is 2 == (010)2, we flip the third bit and we obtain (110)2 = 6. nums becomes [6,1,2,4].
# The XOR of elements of the final array is (6 XOR 1 XOR 2 XOR 4) == 1 == k.
# It can be shown that we cannot make the XOR equal to k in less than 2 operations.
# Example 2:
#
# Input: nums = [2,0,2,0], k = 0
# Output: 0
# Explanation: The XOR of elements of the array is (2 XOR 0 XOR 2 XOR 0) == 0 == k. So no operation is needed.
#
#
# Constraints:
#
# 1 <= nums.length <= 105
# 0 <= nums[i] <= 106
# 0 <= k <= 106
class Solution:
    def minOperations(self, nums: List[int], k: int) -> int:
        y: int = 0
        for i in range(len(nums)):
            y ^= nums[i]
        return bin(y ^ k).count('1')

# 2D Cellular Neighbourhood - Part 2
# This kata is the second part of a series: Neighbourhood kata collection. You may want to do the first one before trying this version.
#
# Now we will implement the distance
# The distance extends the reach of the neighbourhood - instead of returning only the closest neighbours, you'll be searching for all neighbours in a given maximum distance.
#
# There are two popular types of cellular neighbourhoods:
#
# Moore neighborhood - the eight cells that surround the given cell
# Von Neumann neighborhood - the four cells that share a border with the given cell
# Task
# Given a neighbourhood type ("moore" or "von_neumann"), a 2D matrix (a list of lists), a pair of coordinates and the distance, return the list of neighbours of the given cell.
#
# Order of the indices: The first index should be applied for the outer/first matrix layer. The last index for the most inner/last layer. coordinates = (m, n) should be applied like mat[m][n]
#
# Note: you should return an empty array if any of these conditions are true:
#
# Matrix is empty
# Coordinates are outside the matrix
# Distance is equal to 0
# Example:
# \ n  0    1    2    3    4
# m  --------------------------
# 0  | 0  | 1  | 2  | 3  | 4  |
# 1  | 5  | 6  | 7  | 8  | 9  |
# 2  | 10 | 11 | 12 | 13 | 14 |
# 3  | 15 | 16 | 17 | 18 | 19 |
# 4  | 20 | 21 | 22 | 23 | 24 |
#    --------------------------
#
# get_neighborhood("moore", arr, (2,2), 1) == [6,7,8,11,13,16,17,18]
# get_neighborhood("moore", arr, (2,2), 2) == [0,1,2,3,4,5,6,7,8,9,10,11,13,14,15,16,17,18,19,20,21,22,23,24]
#
# get_neighborhood("von_neumann", arr, (2,2), 1) == [7,11,13,17]
# get_neighborhood("von_neumann", arr, (2,2), 2) == [2,6,7,8,10,11,13,14,16,17,18,22]
# Translations are appreciated ^^
#
# If you like chess take a look at Chess Aesthetics
#
# If you like puzzles take a look at Rubik's cube
#
# ALGORITHMSDATA STRUCTURESARRAYSMATRIX
def get_neighbourhood(n_type, mat, cor, distance=1):
    if not mat: return []
    if (cor[0] >= len(mat) or cor[0] < 0) or (cor[1] >= len(mat[0]) or cor[1] < 0):
        return []

    ans: set[tuple[int, int]] = set()
    if n_type == 'moore':
        for rows in range(max(0, cor[0] - distance), min(len(mat), cor[0] + distance + 1)):
            for cols in range(max(0, cor[1] - distance), min(len(mat[0]), cor[1] + distance + 1)):
                if (rows, cols) == cor: continue
                if 0 <= rows < len(mat) and 0 <= cols < len(mat[0]):
                    ans.add((rows, cols))
        return [mat[x][y] for x, y in ans]

    idx: int = 1
    for rows in range(cor[0] - 1, max(0, cor[0] - distance) - 1, -1):
        for cols in range(max(0, (cor[1] - distance) + idx), min(len(mat[0]), (cor[1] + distance) - idx + 1)):
            if (rows, cols) == cor: continue
            if 0 <= rows < len(mat) and 0 <= cols < len(mat[0]):
                ans.add((rows, cols))
        idx += 1

    idx: int = -1
    for rows in range(cor[0], min(len(mat), cor[0] + distance + 1)):
        if rows >= cor[0]:
            idx += 1
        for cols in range(max(0, (cor[1] - distance) + idx), min(len(mat[0]), (cor[1] + distance) - idx + 1)):
            if (rows, cols) == cor: continue
            if 0 <= rows < len(mat) and 0 <= cols < len(mat[0]):
                ans.add((rows, cols))
    return [mat[x][y] for x, y in ans]

# 1561. Maximum Number of Coins You Can Get
# There are 3n piles of coins of varying size, you and your friends will take piles of coins as follows:
#
# In each step, you will choose any 3 piles of coins (not necessarily consecutive).
# Of your choice, Alice will pick the pile with the maximum number of coins.
# You will pick the next pile with the maximum number of coins.
# Your friend Bob will pick the last pile.
# Repeat until there are no more piles of coins.
# Given an array of integers piles where piles[i] is the number of coins in the ith pile.
#
# Return the maximum number of coins that you can have.
#
#
#
# Example 1:
#
# Input: piles = [2,4,1,2,7,8]
# Output: 9
# Explanation: Choose the triplet (2, 7, 8), Alice Pick the pile with 8 coins, you the pile with 7 coins and Bob the last one.
# Choose the triplet (1, 2, 4), Alice Pick the pile with 4 coins, you the pile with 2 coins and Bob the last one.
# The maximum number of coins which you can have are: 7 + 2 = 9.
# On the other hand if we choose this arrangement (1, 2, 8), (2, 4, 7) you only get 2 + 4 = 6 coins which is not optimal.
# Example 2:
#
# Input: piles = [2,4,5]
# Output: 4
# Example 3:
#
# Input: piles = [9,8,7,6,5,1,2,3,4]
# Output: 18
#
#
# Constraints:
#
# 3 <= piles.length <= 105
# piles.length % 3 == 0
# 1 <= piles[i] <= 104
class Solution:
    def maxCoins(self, piles: List[int]) -> int:
        piles.sort(reverse=True)
        n: int = len(piles) // 3
        return sum(i for i in piles[1:len(piles) - n:2])

# Square string tops
# Task
# Write a function that accepts msg string and returns local tops of string from the highest to the lowest.
# The string's tops are from displaying the string in the below way:
#
#
#                                          7891012
#                              TUWvXY      6     3
#                    ABCDE     S    Z      5
#            lmno    z   F     R    1      4
#      abc   k  p    v   G     Q    2      3
# .34..9 d...j  q....x   H.....P    3......2
# 125678 efghi  rstuwy   IJKLMNO    45678901
# The next top is always 1 character higher than the previous one. For the above example, the solution for the 123456789abcdefghijklmnopqrstuwyxvzABCDEFGHIJKLMNOPQRSTUWvXYZ123456789012345678910123 input string is 7891012TUWvXYABCDElmnoabc34.
#
# When the msg string is empty, return an empty string.
# The input strings may be very long. Make sure your solution has good performance.
# The (.)dots on the sample dispaly of string are only there to help you to understand the pattern
# Check the test cases for more samples.
#
# Series
# String tops
# Square string tops
# FUNDAMENTALSSTRINGS
def tops(msg):
    if not msg: return ''
    ans: list[str] = list()
    top: int = 2
    step: int = 5
    start: int = 2
    n: int = len(msg)
    while start < n:
        ans.append(msg[start:start + top])
        start += top
        top += 1
        start += step
        step += 3
    return ''.join(ans[::-1])

# 2000. Reverse Prefix of Word
# Given a 0-indexed string word and a character ch, reverse the segment of word that starts at index 0 and ends at the index of the first occurrence of ch (inclusive). If the character ch does not exist in word, do nothing.
#
# For example, if word = "abcdefd" and ch = "d", then you should reverse the segment that starts at 0 and ends at 3 (inclusive). The resulting string will be "dcbaefd".
# Return the resulting string.
#
#
#
# Example 1:
#
# Input: word = "abcdefd", ch = "d"
# Output: "dcbaefd"
# Explanation: The first occurrence of "d" is at index 3.
# Reverse the part of word from 0 to 3 (inclusive), the resulting string is "dcbaefd".
# Example 2:
#
# Input: word = "xyxzxe", ch = "z"
# Output: "zxyxxe"
# Explanation: The first and only occurrence of "z" is at index 3.
# Reverse the part of word from 0 to 3 (inclusive), the resulting string is "zxyxxe".
# Example 3:
#
# Input: word = "abcd", ch = "z"
# Output: "abcd"
# Explanation: "z" does not exist in word.
# You should not do any reverse operation, the resulting string is "abcd".
#
#
# Constraints:
#
# 1 <= word.length <= 250
# word consists of lowercase English letters.
# ch is a lowercase English letter.
# Solution O(N) O(1)
class Solution:
    def reversePrefix(self, word: str, ch: str) -> str:
        for i in range(len(word)):
            if word[i] == ch:
                return ''.join(word[i::-1] + word[i + 1:])
        return word
# Solution in Pythonic Style O(N) O(N)
class Solution:
    def reversePrefix(self, word: str, ch: str) -> str:
        ans: list[str] = list(word)
        for i in range(len(ans)):
            if ans[i] == ch:
                print(ans[i:-1:-1])
                return ''.join(ans[i::-1] + ans[i + 1:])
        return word

# Grill it!
# Introduction
# A grille cipher was a technique for encrypting a plaintext by writing it onto a sheet of paper through a pierced sheet (of paper or cardboard or similar). The earliest known description is due to the polymath Girolamo Cardano in 1550. His proposal was for a rectangular stencil allowing single letters, syllables, or words to be written, then later read, through its various apertures. The written fragments of the plaintext could be further disguised by filling the gaps between the fragments with anodyne words or letters. This variant is also an example of steganography, as are many of the grille ciphers. Wikipedia Link
#
# Tangiers1Tangiers2
#
# Task
# Write a function that accepts two inputs: message and code and returns hidden message decrypted from message using the code.
# The code is a nonnegative integer and it decrypts in binary the message.
#
# Grille("abcdef", 5)  => "df"
#
# message : abcdef
# code    : 000101
# ----------------
# result  : df
# STRINGSBINARYFUNDAMENTALS
def grille(message, code):
    if not message: return ''
    code: str = bin(code)[2:]
    if len(code) < len(message):
        code = '0' * (len(message) - len(code)) + code
    while len(code) > len(message):
        code = code[1:]
    return ''.join(message[i] for i in range(min(len(code), len(message))) if code[i] == '1')

# Linux history and `!` command. Series#2 The `!n` command
# All Unix user know the command line history. This one comes with a set of useful commands know as the bang command.
#
# For more information about the history command line you can take a look at:
#
# The man page -> simply type man history in your terminal.
# The online man page here.
# And for more information about the bang command you can read this article
# For this second kata we will explore the !n command, according to the man page this one refer to command line n.
#
# In this kata you should complete a function that take in an integer that correspond to n, and an history with the following format:
#
#   1  cd /pub
#   2  more beer
#   3  lost
#   4  ls
#   5  touch me
#   6  chmod 000 me
#   7  more me
#   8  history
# and that should return the nth executed command line, for example with n=4 and the above history it should return ls. If user ask for a n without any know entry for example n=12 here, the function should return !12: event not found. Note: For this kata we will assume that n >= 1.
#
# Note: Lot of the command line comes form some geeky t-shirt and form this excellent page.
#
# STRINGSPARSINGREGULAR EXPRESSIONSALGORITHMS
 def bang_n(n, history):
    history = [i.lstrip().rstrip() for i in history.split('\n ')]
    if n - 1 >= len(history): return f'!{n}: event not found'
    return ' '.join(history[n - 1].split()[1:])

# 2441. Largest Positive Integer That Exists With Its Negative
# Given an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array.
#
# Return the positive integer k. If there is no such integer, return -1.
#
#
#
# Example 1:
#
# Input: nums = [-1,2,-3,3]
# Output: 3
# Explanation: 3 is the only valid k we can find in the array.
# Example 2:
#
# Input: nums = [-1,10,6,7,-7,1]
# Output: 7
# Explanation: Both 1 and 7 have their corresponding negative values in the array. 7 has a larger value.
# Example 3:
#
# Input: nums = [-10,8,6,7,-2,-3]
# Output: -1
# Explanation: There is no a single valid k, we return -1.
#
#
# Constraints:
#
# 1 <= nums.length <= 1000
# -1000 <= nums[i] <= 1000
# nums[i] != 0
# Solution HashSet O(N) O(N)
class Solution:
    def findMaxK(self, nums: List[int]) -> int:
        ans: int = -1
        hs: set[int] = set()
        for i in nums:
            if i < 0 and abs(i) in hs:
                ans = max(ans, abs(i))
            elif i > 0 and -i in hs:
                ans = max(ans, i)
            hs.add(i)
        return ans
    
# 165. Compare Version Numbers
# Given two version numbers, version1 and version2, compare them.
#
# Version numbers consist of one or more revisions joined by a dot '.'. Each revision consists of digits and may contain leading zeros. Every revision contains at least one character. Revisions are 0-indexed from left to right, with the leftmost revision being revision 0, the next revision being revision 1, and so on. For example 2.5.33 and 0.1 are valid version numbers.
#
# To compare version numbers, compare their revisions in left-to-right order. Revisions are compared using their integer value ignoring any leading zeros. This means that revisions 1 and 001 are considered equal. If a version number does not specify a revision at an index, then treat the revision as 0. For example, version 1.0 is less than version 1.1 because their revision 0s are the same, but their revision 1s are 0 and 1 respectively, and 0 < 1.
#
# Return the following:
#
# If version1 < version2, return -1.
# If version1 > version2, return 1.
# Otherwise, return 0.
#
#
# Example 1:
#
# Input: version1 = "1.01", version2 = "1.001"
# Output: 0
# Explanation: Ignoring leading zeroes, both "01" and "001" represent the same integer "1".
# Example 2:
#
# Input: version1 = "1.0", version2 = "1.0.0"
# Output: 0
# Explanation: version1 does not specify revision 2, which means it is treated as "0".
# Example 3:
#
# Input: version1 = "0.1", version2 = "1.1"
# Output: -1
# Explanation: version1's revision 0 is "0", while version2's revision 0 is "1". 0 < 1, so version1 < version2.
#
#
# Constraints:
#
# 1 <= version1.length, version2.length <= 500
# version1 and version2 only contain digits and '.'.
# version1 and version2 are valid version numbers.
# All the given revisions in version1 and version2 can be stored in a 32-bit integer.
class Solution:
    def compareVersion(self, version1: str, version2: str) -> int:
        version1 = [int(i) for i in version1.split('.')]
        version2 = [int(i) for i in version2.split('.')]
        v1, v2 = len(version1), len(version2)
        for i in range(min(v1, v2)):
            if version1[i] < version2[i]:
                return -1
            elif version1[i] > version2[i]:
                return 1
        if v1 == v2:
            return 0
        elif v1 > v2:
            return [1, 0][all(version1[i] == 0 for i in range(v2, v1))]
        return [-1, 0][all(version2[i] == 0 for i in range(v1, v2))]

# City Swim - 2D (TowerFlood And PlainFlood)
# Given an array representing the height of towers on a 2d plane, with each tower being of width 1, Whats's the maximum amount of units of water that can be captured between the towers when it rains?
#
# Each tower is immediately next to the tower next to it in the array, except in instances where a height of 0 is shown, then no tower would be present.
#
# A single unit can be thought of as a 2d square with a width 1.
#
# Examples
#           [5,2,10] should return 3
#   [1,0,5,2,6,3,10] should return 7
# [15,0,6,10,11,2,5] should return 20
#            [1,5,1] should return 0
#              [6,5] should return 0
#                 [] should return 0
# Performances:
# Watch out for performances: you'll need a solution linear with the number of towers.
#
# PUZZLESMATHEMATICSALGORITHMS
def rain_volume(towers):
    if not towers:
        return 0
    left, left_boundary = 0, 0
    mx_idx: int = 0
    ans: int = 0
    for i in range(len(towers)):
        mx_idx = i if towers[i] > towers[mx_idx] else mx_idx
    while left < mx_idx:
        if towers[left] > left_boundary:
            left_boundary = towers[left]
        ans += left_boundary - towers[left]
        left += 1
    right_boundary = towers[-1]
    for i in range(len(towers) - 1, left, -1):
        if towers[i] > right_boundary:
            right_boundary = towers[i]
        ans += right_boundary - towers[i]
    return ans

# 881. Boats to Save People
# You are given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weight of limit. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit.
#
# Return the minimum number of boats to carry every given person.
#
#
#
# Example 1:
#
# Input: people = [1,2], limit = 3
# Output: 1
# Explanation: 1 boat (1, 2)
# Example 2:
#
# Input: people = [3,2,2,1], limit = 3
# Output: 3
# Explanation: 3 boats (1, 2), (2) and (3)
# Example 3:
#
# Input: people = [3,5,3,4], limit = 5
# Output: 4
# Explanation: 4 boats (3), (3), (4), (5)
#
#
# Constraints:
#
# 1 <= people.length <= 5 * 104
# 1 <= people[i] <= limit <= 3 * 104
class Solution:
    def numRescueBoats(self, people: List[int], limit: int) -> int:
        people.sort()
        ans: int = 0
        n: int = len(people)
        left, right = 0, n - 1

        while left <= right:
            if left < right and people[right] + people[left] <= limit:
                left += 1
            right -= 1
            ans += 1

        return ans

# Keyword Cipher Helper
# A keyword cipher is a monoalphabetic cipher which uses a "keyword" to provide encryption. It is somewhat similar to a Caesar cipher.
#
# In a keyword cipher, repeats of letters in the keyword are removed and the alphabet is reordered such that the letters in the keyword appear first, followed by the rest of the letters in the alphabet in their otherwise usual order.
#
# E.g. for an uppercase latin alphabet with keyword of "KEYWORD":
#
# A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z
#
# becomes:
#
# K|E|Y|W|O|R|D|A|B|C|F|G|H|I|J|L|M|N|P|Q|S|T|U|V|X|Z
#
# such that:
#
# cipher.encode('ABCHIJ') == 'KEYABC'
# cipher.decode('KEYABC') == 'ABCHIJ'
# All letters in the keyword will also be in the alphabet. For the purpose of this kata, only the first occurence of a letter in a keyword should be used. Any characters not provided in the alphabet should be left in situ when encoding or decoding.
#
# CRYPTOGRAPHYCIPHERSSECURITYOBJECT-ORIENTED PROGRAMMINGSTRINGSA keyword cipher is a monoalphabetic cipher which uses a "keyword" to provide encryption. It is somewhat similar to a Caesar cipher.
#
# In a keyword cipher, repeats of letters in the keyword are removed and the alphabet is reordered such that the letters in the keyword appear first, followed by the rest of the letters in the alphabet in their otherwise usual order.
#
# E.g. for an uppercase latin alphabet with keyword of "KEYWORD":
#
# A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z
#
# becomes:
#
# K|E|Y|W|O|R|D|A|B|C|F|G|H|I|J|L|M|N|P|Q|S|T|U|V|X|Z
#
# such that:
#
# cipher.encode('ABCHIJ') == 'KEYABC'
# cipher.decode('KEYABC') == 'ABCHIJ'
# All letters in the keyword will also be in the alphabet. For the purpose of this kata, only the first occurence of a letter in a keyword should be used. Any characters not provided in the alphabet should be left in situ when encoding or decoding.
#
# CRYPTOGRAPHYCIPHERSSECURITYOBJECT-ORIENTED PROGRAMMINGSTRINGS
class keyword_cipher(object):

    def __init__(self, abc, keyword):
        self.abc: str = abc
        self.al = dict()
        for i in keyword:
            if i not in self.al:
                self.al[i] = 1
        self.al = ''.join(self.al.keys())
        self.al += ''.join(i for i in self.abc if i not in self.al)

    def encode(self, plain):
        return plain.translate(str.maketrans(self.abc, self.al))

    def decode(self, ciphered):
        return ciphered.translate(str.maketrans(self.al, self.abc))

# D&D: Non-Euclidian Movement
# Context
# In Dungeons and Dragons, a tabletop roleplaying game, movement is limited in combat. Characters can only move a set amount of distance per turn, meaning the distance you travel is very important.
#
# In the 5th edition of the rulebook, the board is commonly organized into a grid, but for ease of counting, movement is non-euclidian. Each square is 5 ft, and moving diagonally counts the same as moving in a cardinal direction.
#
# +------------------------+
# | 10 | 10 | 10 | 10 | 10 |
# +------------------------+
# | 10 |  5 |  5 |  5 | 10 |
# +------------------------+
# | 10 |  5 | :) |  5 | 10 |
# +------------------------+
# | 10 |  5 |  5 |  5 | 10 |
# +------------------------+
# | 10 | 10 | 10 | 10 | 10 |
# +------------------------+
# Distance of each grid cell from the player, in feet
# Your task
# Create an algorithm to calculate the distance of a movement path. You will be provided with the path as a series of absolute grid points (x, y, z). Take in to account both horizontal (x, y) as well as vertical (z) movement. Vertical movement is governed by the same rules, for the sake of simplicity.
#
# ALGORITHMSDATA STRUCTURES
def calc_distance(path):
    ans: int = 0
    start = path[0]
    for i in path[1:]:
        ans += max(abs(x - y) for x, y in zip(start, i)) * 5
        start = i
    return ans

# 237. Delete Node in a Linked List
# There is a singly-linked list head and we want to delete a node node in it.
#
# You are given the node to be deleted node. You will not be given access to the first node of head.
#
# All the values of the linked list are unique, and it is guaranteed that the given node node is not the last node in the linked list.
#
# Delete the given node. Note that by deleting the node, we do not mean removing it from memory. We mean:
#
# The value of the given node should not exist in the linked list.
# The number of nodes in the linked list should decrease by one.
# All the values before node should be in the same order.
# All the values after node should be in the same order.
# Custom testing:
#
# For the input, you should provide the entire linked list head and the node to be given node. node should not be the last node of the list and should be an actual node in the list.
# We will build the linked list and pass the node to your function.
# The output will be the entire list after calling your function.
#
#
# Example 1:
#
#
# Input: head = [4,5,1,9], node = 5
# Output: [4,1,9]
# Explanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.
# Example 2:
#
#
# Input: head = [4,5,1,9], node = 1
# Output: [4,5,9]
# Explanation: You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function.
#
#
# Constraints:
#
# The number of the nodes in the given list is in the range [2, 1000].
# -1000 <= Node.val <= 1000
# The value of each node in the list is unique.
# The node to be deleted is in the list and is not a tail node.
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def deleteNode(self, node):
        """
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        """
        tmp = node
        while tmp:
            if tmp is node:
                tmp.val = tmp.next.val
                tmp.next = tmp.next.next
                return
            tmp = tmp.next

# 3136. Valid Word
# A word is considered valid if:
#
# It contains a minimum of 3 characters.
# It consists of the digits 0-9, and the uppercase and lowercase English letters. (Not necessary to have all of them.)
# It includes at least one vowel.
# It includes at least one consonant.
# You are given a string word.
#
# Return true if word is valid, otherwise, return false.
#
# Notes:
#
# 'a', 'e', 'i', 'o', 'u', and their uppercases are vowels.
# A consonant is an English letter that is not a vowel.
#
#
# Example 1:
#
# Input: word = "234Adas"
#
# Output: true
#
# Explanation:
#
# This word satisfies the conditions.
#
# Example 2:
#
# Input: word = "b3"
#
# Output: false
#
# Explanation:
#
# The length of this word is fewer than 3, and does not have a vowel.
#
# Example 3:
#
# Input: word = "a3$e"
#
# Output: false
#
# Explanation:
#
# This word contains a '$' character and does not have a consonant.
#
#
#
# Constraints:
#
# 1 <= word.length <= 20
# word consists of English uppercase and lowercase letters, digits, '@', '#', and '$'.
class Solution:
    def isValid(self, word: str) -> bool:
        al = 'abcdefghijklmnopqrstuvwxyz'
        ln = len(word)
        l, u = False, False
        c, v = False, False
        d = False
        for i in word:
            if i.isupper():
                if i.lower() in 'aeiou':
                    v = True
                elif i.lower() in al:
                    c = True
                u = True
            elif i.islower():
                if i in 'aeiou':
                    v = True
                elif i in al:
                    c = True
                l = True
            elif i.isdigit():
                d = True
            else:
                return False
        an = int(u) + int(l) + int(d)
        return len(word) >= 3 and an > 0 and c and v

# 3137. Minimum Number of Operations to Make Word K-Periodic
# You are given a string word of size n, and an integer k such that k divides n.
#
# In one operation, you can pick any two indices i and j, that are divisible by k, then replace the
# substring
#  of length k starting at i with the substring of length k starting at j. That is, replace the substring word[i..i + k - 1] with the substring word[j..j + k - 1].
#
# Return the minimum number of operations required to make word k-periodic.
#
# We say that word is k-periodic if there is some string s of length k such that word can be obtained by concatenating s an arbitrary number of times. For example, if word == “ababab”, then word is 2-periodic for s = "ab".
#
#
#
# Example 1:
#
# Input: word = "leetcodeleet", k = 4
#
# Output: 1
#
# Explanation:
#
# We can obtain a 4-periodic string by picking i = 4 and j = 0. After this operation, word becomes equal to "leetleetleet".
#
# Example 2:
#
# Input: word = "leetcoleet", k = 2
#
# Output: 3
#
# Explanation:
#
# We can obtain a 2-periodic string by applying the operations in the table below.
#
# i	j	word
# 0	2	etetcoleet
# 4	0	etetetleet
# 6	0	etetetetet
#
#
#
# Constraints:
#
# 1 <= n == word.length <= 105
# 1 <= k <= word.length
# k divides word.length.
# word consists only of lowercase English letters.
class Solution:
    def minimumOperationsToMakeKPeriodic(self, word: str, k: int) -> int:
        ht: dict[str, int] = dict()
        for i in range(0, len(word), k):
            x: str = word[i:i+k]
            if len(x) == k:
                ht[x] = ht.get(x, 0) + 1
        return len(word) // k - max(ht.values())

# 3138. Minimum Length of Anagram Concatenation
# You are given a string s, which is known to be a concatenation of anagrams of some string t.
#
# Return the minimum possible length of the string t.
#
# An anagram is a word or phrase formed by rearranging the letters of a word or phrase, typically using all the original letters exactly once.
#
#
#
# Example 1:
#
# Input: s = "abba"
#
# Output: 2
#
# Explanation:
#
# One possible string t could be "ba".
#
# Example 2:
#
# Input: s = "cdef"
#
# Output: 4
#
# Explanation:
#
# One possible string t could be "cdef", notice that t can be equal to s.
#
#
#
# Constraints:
#
# 1 <= s.length <= 105
# s consist only of lowercase English letters.
class Solution:
    def minAnagramLength(self, s: str) -> int:
        n: int = len(s)
        ht = dict()
        for i in s:
            ht[i] = ht.get(i, 0) + 1
        if len(ht) == 1:
            return 1
        for i in range(n, 0, -1):
            if n % i == 0:
                if all(v % i == 0 for v in ht.values()):
                    return sum(v // i for v in ht.values())

# 3110. Score of a String
# You are given a string s. The score of a string is defined as the sum of the absolute difference between the ASCII values of adjacent characters.
#
# Return the score of s.
#
#
#
# Example 1:
#
# Input: s = "hello"
#
# Output: 13
#
# Explanation:
#
# The ASCII values of the characters in s are: 'h' = 104, 'e' = 101, 'l' = 108, 'o' = 111. So, the score of s would be |104 - 101| + |101 - 108| + |108 - 108| + |108 - 111| = 3 + 7 + 0 + 3 = 13.
#
# Example 2:
#
# Input: s = "zaz"
#
# Output: 50
#
# Explanation:
#
# The ASCII values of the characters in s are: 'z' = 122, 'a' = 97. So, the score of s would be |122 - 97| + |97 - 122| = 25 + 25 = 50.
#
#
#
# Constraints:
#
# 2 <= s.length <= 100
# s consists only of lowercase English letters.
class Solution:
    def scoreOfString(self, s: str) -> int:
        return sum(abs(ord(i) - ord(j)) for i, j in zip(s, s[1:]))

# 3114. Latest Time You Can Obtain After Replacing Characters
# You are given a string s representing a 12-hour format time where some of the digits (possibly none) are replaced with a "?".
#
# 12-hour times are formatted as "HH:MM", where HH is between 00 and 11, and MM is between 00 and 59. The earliest 12-hour time is 00:00, and the latest is 11:59.
#
# You have to replace all the "?" characters in s with digits such that the time we obtain by the resulting string is a valid 12-hour format time and is the latest possible.
#
# Return the resulting string.
#
#
#
# Example 1:
#
# Input: s = "1?:?4"
#
# Output: "11:54"
#
# Explanation: The latest 12-hour format time we can achieve by replacing "?" characters is "11:54".
#
# Example 2:
#
# Input: s = "0?:5?"
#
# Output: "09:59"
#
# Explanation: The latest 12-hour format time we can achieve by replacing "?" characters is "09:59".
#
#
#
# Constraints:
#
# s.length == 5
# s[2] is equal to the character ":".
# All characters except s[2] are digits or "?" characters.
# The input is generated such that there is at least one time between "00:00" and "11:59" that you can obtain after replacing the "?" characters.
class Solution:
    def findLatestTime(self, s: str) -> str:
        s = list(s)
        zero: bool = False
        if s[0] == '0':
            zero = True
        elif s[0] == '1':
            zero = False
        else:
            s[0] = '1' if (s[1] == '?' or (int(s[1] != '?' and s[1]) < 2)) else '0' 
            zero = s[0] == '0'
        if s[1] == '?':
            s[1] = '1' if not zero else '9'
        if s[3] == '?':
            s[3] = '5'
        if s[4] == '?':
            s[4] = '9'
        return ''.join(s)

# 3120. Count the Number of Special Characters I
# You are given a string word. A letter is called special if it appears both in lowercase and uppercase in word.
#
# Return the number of special letters in word.
#
#
#
# Example 1:
#
# Input: word = "aaAbcBC"
#
# Output: 3
#
# Explanation:
#
# The special characters in word are 'a', 'b', and 'c'.
#
# Example 2:
#
# Input: word = "abc"
#
# Output: 0
#
# Explanation:
#
# No character in word appears in uppercase.
#
# Example 3:
#
# Input: word = "abBCab"
#
# Output: 1
#
# Explanation:
#
# The only special character in word is 'b'.
#
#
#
# Constraints:
#
# 1 <= word.length <= 50
# word consists of only lowercase and uppercase English letters.
class Solution:
    def numberOfSpecialChars(self, word: str) -> int:
        ht: dict[str, int] = dict()
        for i in word:
            ht[i] = ht.get(i, 0) + 1
        ans: int = 0
        for i in ht:
            if i.lower() in ht and i.upper() in ht:
                ans += 1
        return ans // 2

# 3127. Make a Square with the Same Color
# You are given a 2D matrix grid of size 3 x 3 consisting only of characters 'B' and 'W'. Character 'W' represents the white color, and character 'B' represents the black color.
#
# Your task is to change the color of at most one cell so that the matrix has a 2 x 2 square where all cells are of the same color.
#
# Return true if it is possible to create a 2 x 2 square of the same color, otherwise, return false.
#
#
#
# Example 1:
#
#
#
#
#
#
#
#
#
#
# Input: grid = [["B","W","B"],["B","W","W"],["B","W","B"]]
#
# Output: true
#
# Explanation:
#
# It can be done by changing the color of the grid[0][2].
#
# Example 2:
#
#
#
#
#
#
#
#
#
#
# Input: grid = [["B","W","B"],["W","B","W"],["B","W","B"]]
#
# Output: false
#
# Explanation:
#
# It cannot be done by changing at most one cell.
#
# Example 3:
#
#
#
#
#
#
#
#
#
#
# Input: grid = [["B","W","B"],["B","W","W"],["B","W","W"]]
#
# Output: true
#
# Explanation:
#
# The grid already contains a 2 x 2 square of the same color.
#
#
#
# Constraints:
#
# grid.length == 3
# grid[i].length == 3
# grid[i][j] is either 'W' or 'B'.
class Solution:
    def canMakeSquare(self, grid: List[List[str]]) -> bool:
        moves: list[list[int, int]] = [[0, 1], [1, 0], [1, 1]]
        for i in range(2):
            for j in range(2):
                x: int = sum(grid[i][j] != grid[i + x][j + y] for x, y in moves)
                if x <= 1 or x >= 3:
                    return True
        return False
    
# 3131. Find the Integer Added to Array I
# You are given two arrays of equal length, nums1 and nums2.
#
# Each element in nums1 has been increased (or decreased in the case of negative) by an integer, represented by the variable x.
#
# As a result, nums1 becomes equal to nums2. Two arrays are considered equal when they contain the same integers with the same frequencies.
#
# Return the integer x.
#
#
#
# Example 1:
#
# Input: nums1 = [2,6,4], nums2 = [9,7,5]
#
# Output: 3
#
# Explanation:
#
# The integer added to each element of nums1 is 3.
#
# Example 2:
#
# Input: nums1 = [10], nums2 = [5]
#
# Output: -5
#
# Explanation:
#
# The integer added to each element of nums1 is -5.
#
# Example 3:
#
# Input: nums1 = [1,1,1,1], nums2 = [1,1,1,1]
#
# Output: 0
#
# Explanation:
#
# The integer added to each element of nums1 is 0.
#
#
#
# Constraints:
#
# 1 <= nums1.length == nums2.length <= 100
# 0 <= nums1[i], nums2[i] <= 1000
# The test cases are generated in a way that there is an integer x such that nums1 can become equal to nums2 by adding x to each element of nums1.
class Solution:
    def addedInteger(self, nums1: List[int], nums2: List[int]) -> int:
        return (sum(nums2) - sum(nums1)) // len(nums1)

# 2487. Remove Nodes From Linked List
# You are given the head of a linked list.
#
# Remove every node which has a node with a greater value anywhere to the right side of it.
#
# Return the head of the modified linked list.
#
#
#
# Example 1:
#
#
# Input: head = [5,2,13,3,8]
# Output: [13,8]
# Explanation: The nodes that should be removed are 5, 2 and 3.
# - Node 13 is to the right of node 5.
# - Node 13 is to the right of node 2.
# - Node 8 is to the right of node 3.
# Example 2:
#
# Input: head = [1,1,1,1]
# Output: [1,1,1,1]
# Explanation: Every node has value 1, so no nodes are removed.
#
#
# Constraints:
#
# The number of the nodes in the given list is in the range [1, 105].
# 1 <= Node.val <= 105
# Solution O(N) O(1)
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # Reverse O(N) O(1)
        prev = None
        current = head
        while current:
            nxt = current.next
            current.next = prev
            prev = current
            current = nxt
        head = prev
        # Removing O(N) O(1)
        tmp = head
        check: int = tmp.val
        while tmp:
            if tmp.next and tmp.next.val < check:
                tmp.next = tmp.next.next if tmp.next.next else None
            elif tmp.next and tmp.next.val > check:
                check = tmp.next.val
            else:
                tmp = tmp.next
        # Vice versa reversing O(N) O(1)
        prev = None
        current = head
        while current:
            nxt = current.next
            current.next = prev
            prev = current
            current = nxt
        head = prev
        return head

# Down Arrow With Numbers
# Given a number n, make a down arrow shaped pattern.
#
# For example, when n = 5, the output would be:
#
# 123454321
#  1234321
#   12321
#    121
#     1
# and for n = 11, it would be:
#
# 123456789010987654321
#  1234567890987654321
#   12345678987654321
#    123456787654321
#     1234567654321
#      12345654321
#       123454321
#        1234321
#         12321
#          121
#           1
#
# An important thing to note in the above example is that the numbers greater than 9 still stay single digit, like after 9 it would be 0 - 9 again instead of 10 - 19.
#
# Note:
#
# There are spaces for the indentation on the left of each line and no spaces on the right.
# Return "" if given n<1.
# Have fun!
#
# ALGORITHMS
def get_a_down_arrow_of(n):
    if n < 1:
        return ''
    ans: list[str] = list()
    for i in range(n, 0, -1):
        x: str = ' '* (n - i)
        x += ''.join(str(j)[-1] for j in range(1, i + 1))
        x += ''.join(str(j)[-1] for j in range(i - 1, 0, -1))
        ans.append(x)
    return '\n'.join(ans)

# 2816. Double a Number Represented as a Linked List
# You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.
#
# Return the head of the linked list after doubling it.
#
#
#
# Example 1:
#
#
# Input: head = [1,8,9]
# Output: [3,7,8]
# Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.
# Example 2:
#
#
# Input: head = [9,9,9]
# Output: [1,9,9,8]
# Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.
#
#
# Constraints:
#
# The number of nodes in the list is in the range [1, 104]
# 0 <= Node.val <= 9
# The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # Parse n
        n: int = 0
        tmp = head
        count: int = 0
        while tmp:
            count += 1
            n = n * 10 + tmp.val
            tmp = tmp.next
        n *= 2
        # Insert n in linked list
        out = head
        while n:
            out.val = n % 10
            n //= 10
            if out.next:
                out = out.next
            else:
                out.next = ListNode() if n else None
                out = out.next
        # Reverse list
        prev = None
        current = head
        while current:
            nxt = current.next
            current.next = prev
            prev = current
            current = nxt
        head = prev
        return head

# Simple reversal game
# Jack and Jill are playing a game. They have balls numbered from 0 to n - 1. Jack looks the other way and asks Jill to reverse the position of the balls, for instance, to change the order from say, 0,1,2,3 to 3,2,1,0. He further asks Jill to reverse the position of the balls n times, each time starting from one position further to the right, till she reaches the last ball. So, Jill has to reverse the positions of the ball starting from position 0, then from position 1, then from position 2 and so on. At the end of the game, Jill will ask Jack to guess the final position of any ball numbered k.
#
# You will be given 2 integers, the first will be n(balls numbered from 0 to n-1) and the second will be k. You will return the position of the ball numbered k after the rearrangement.
#
# solve(4,1) = 3. The reversals are [0,1,2,3] -> [3,2,1,0] -> [3,0,1,2] -> [3,0,2,1]. => 1 is in position 3.
# More examples in the test cases. Good luck!
#
# PUZZLESMATHEMATICS
def solve(n,k):
    stack: list[int] = [i for i in range(n)]
    for i in range(n):
        stack = stack[:i] + stack[i:][::-1]
    return stack.index(k)

# 506. Relative Ranks
# You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.
#
# The athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:
#
# The 1st place athlete's rank is "Gold Medal".
# The 2nd place athlete's rank is "Silver Medal".
# The 3rd place athlete's rank is "Bronze Medal".
# For the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is "x").
# Return an array answer of size n where answer[i] is the rank of the ith athlete.
#
#
#
# Example 1:
#
# Input: score = [5,4,3,2,1]
# Output: ["Gold Medal","Silver Medal","Bronze Medal","4","5"]
# Explanation: The placements are [1st, 2nd, 3rd, 4th, 5th].
# Example 2:
#
# Input: score = [10,3,8,9,4]
# Output: ["Gold Medal","5","Bronze Medal","Silver Medal","4"]
# Explanation: The placements are [1st, 5th, 3rd, 2nd, 4th].
#
#
#
# Constraints:
#
# n == score.length
# 1 <= n <= 104
# 0 <= score[i] <= 106
# All the values in score are unique.
# Solution
class Solution:
    def findRelativeRanks(self, score: List[int]) -> List[str]:
        n: int = len(score)
        pairs: list[tuple(int, int)] = [(score[i], i) for i in range(n)]
        pairs.sort(key=lambda x: x[0], reverse=True)
        idx: int = 0
        while idx < n:
            if idx == 0:
                score[pairs[idx][1]] = 'Gold Medal'
            elif idx == 1:
                score[pairs[idx][1]] = 'Silver Medal'
            elif idx == 2:
                score[pairs[idx][1]] = 'Bronze Medal'
            else:
                score[pairs[idx][1]] = str(idx + 1)
            idx += 1
        return score

# Simple Fun #179: Fraction
# Task
# Given two integers a and b, return the sum of the numerator and the denominator of the reduced fraction a/b.
#
# Example
# For a = 2, b = 4, the result should be 3
#
# Since 2/4 = 1/2 => 1 + 2 = 3.
#
# For a = 10, b = 100, the result should be 11
#
# Since 10/100 = 1/10 => 1 + 10 = 11.
#
# For a = 5, b = 5, the result should be 2
#
# Since 5/5 = 1/1 => 1 + 1 = 2.
#
# Input/Output
# [input] integer a
# The numerator, 1 ≤ a ≤ 2000.
#
# [input] integer b
# The denominator, 1 ≤ b ≤ 2000.
#
# [output] an integer
# The sum of the numerator and the denominator of the reduces fraction.
#
# FUNDAMENTALS
# Solution
def euclide_gcd(a, b):
    if b % a == 0:
        return a
    return euclide_gcd(b, a % b)
def fraction(a, b):
    x: int = euclide_gcd(a, b)
    return a // x + b // x

# 1757. Recyclable and Low Fat Products
# Table: Products
#
# +-------------+---------+
# | Column Name | Type    |
# +-------------+---------+
# | product_id  | int     |
# | low_fats    | enum    |
# | recyclable  | enum    |
# +-------------+---------+
# product_id is the primary key (column with unique values) for this table.
# low_fats is an ENUM (category) of type ('Y', 'N') where 'Y' means this product is low fat and 'N' means it is not.
# recyclable is an ENUM (category) of types ('Y', 'N') where 'Y' means this product is recyclable and 'N' means it is not.
#
#
# Write a solution to find the ids of products that are both low fat and recyclable.
#
# Return the result table in any order.
#
# The result format is in the following example.
#
#
#
# Example 1:
#
# Input:
# Products table:
# +-------------+----------+------------+
# | product_id  | low_fats | recyclable |
# +-------------+----------+------------+
# | 0           | Y        | N          |
# | 1           | Y        | Y          |
# | 2           | N        | Y          |
# | 3           | Y        | Y          |
# | 4           | N        | N          |
# +-------------+----------+------------+
# Output:
# +-------------+
# | product_id  |
# +-------------+
# | 1           |
# | 3           |
# +-------------+
# Explanation: Only products 1 and 3 are both low fat and recyclable.
SELECT product_id
FROM Products
WHERE low_fats = 'Y' AND recyclable = 'Y'

# Nesting Structure Comparison
# Complete the function/method (depending on the language) to return true/True when its argument is an array that has the same nesting structures and same corresponding length of nested arrays as the first array.
#
# For example:
#
# # should return True
# same_structure_as([ 1, 1, 1 ], [ 2, 2, 2 ] )
# same_structure_as([ 1, [ 1, 1 ] ], [ 2, [ 2, 2 ] ] )
#
# # should return False
# same_structure_as([ 1, [ 1, 1 ] ], [ [ 2, 2 ], 2 ] )
# same_structure_as([ 1, [ 1, 1 ] ], [ [ 2 ], 2 ] )
#
# # should return True
# same_structure_as([ [ [ ], [ ] ] ], [ [ [ ], [ ] ] ] )
#
# # should return False
# same_structure_as([ [ [ ], [ ] ] ], [ [ 1, 1 ] ] )
# ARRAYSALGORITHMS
def same_structure_as(original,other):
    if isinstance(original, list) or isinstance(other, list):
        if type(original) != type(other):
                return False
        if len(original) != len(other):
            return False
    for i in range(len(original)):
        if isinstance(original[i], list) or isinstance(other[i], list):
            if type(original[i]) != type(other[i]):
                return False
            return same_structure_as(original[i], other[i])
    return True

# 786. K-th Smallest Prime Fraction
# You are given a sorted integer array arr containing 1 and prime numbers, where all the integers of arr are unique. You are also given an integer k.
#
# For every i and j where 0 <= i < j < arr.length, we consider the fraction arr[i] / arr[j].
#
# Return the kth smallest fraction considered. Return your answer as an array of integers of size 2, where answer[0] == arr[i] and answer[1] == arr[j].
#
#
#
# Example 1:
#
# Input: arr = [1,2,3,5], k = 3
# Output: [2,5]
# Explanation: The fractions to be considered in sorted order are:
# 1/5, 1/3, 2/5, 1/2, 3/5, and 2/3.
# The third fraction is 2/5.
# Example 2:
#
# Input: arr = [1,7], k = 1
# Output: [1,7]
#
#
# Constraints:
#
# 2 <= arr.length <= 1000
# 1 <= arr[i] <= 3 * 104
# arr[0] == 1
# arr[i] is a prime number for i > 0.
# All the numbers of arr are unique and sorted in strictly increasing order.
# 1 <= k <= arr.length * (arr.length - 1) / 2
#
#
# Follow up: Can you solve the problem with better than O(n2) complexity?
# Solution Brute Force O(N**2) O(N)
class Solution:
    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:
        stack: list[int] = list()
        for i in range(len(arr)):
            for j in range(i + 1, len(arr)):
                stack.append((arr[i] / arr[j], [i, j]))
        stack.sort(key=lambda x: x[0])
        x, y = stack[k - 1][1]
        return [arr[x], arr[y]]
# Solution Binary Search Two Pointers O(NlogN) O(1)
class Solution:
    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:
        left, right = 0, 1
        n: int = len(arr)
        while left <= right:
            middle: float = (left + right) / 2
            j, top, num, den = 1, 0, 0, 0
            mxfrq: float = 0.0
            for i in range(n):
                while j < n and arr[i] >= arr[j] * middle:
                    j += 1
                top += n - j
                if j < n and mxfrq < arr[i] / arr[j]:
                    mxfrq = arr[i] / arr[j]
                    num, den = i, j
            if top == k:
                return [arr[num], arr[den]]
            elif top > k:
                right = middle
            else:
                left = middle
        return [arr[num], arr[den]]

# Matrix Determinant
# Write a function that accepts a square matrix (N x N 2D array) and returns the determinant of the matrix.
#
# How to take the determinant of a matrix -- it is simplest to start with the smallest cases:
#
# A 1x1 matrix |a| has determinant a.
#
# A 2x2 matrix [ [a, b], [c, d] ] or
#
# |a  b|
# |c  d|
# has determinant: a*d - b*c.
#
# The determinant of an n x n sized matrix is calculated by reducing the problem to the calculation of the determinants of n matrices ofn-1 x n-1 size.
#
# For the 3x3 case, [ [a, b, c], [d, e, f], [g, h, i] ] or
#
# |a b c|
# |d e f|
# |g h i|
# the determinant is: a * det(a_minor) - b * det(b_minor) + c * det(c_minor) where det(a_minor) refers to taking the determinant of the 2x2 matrix created by crossing out the row and column in which the element a occurs:
#
# |- - -|
# |- e f|
# |- h i|
# Note the alternation of signs.
#
# The determinant of larger matrices are calculated analogously, e.g. if M is a 4x4 matrix with first row [a, b, c, d], then:
#
# det(M) = a * det(a_minor) - b * det(b_minor) + c * det(c_minor) - d * det(d_minor)
#
# MATRIXLINEAR ALGEBRAMATHEMATICSRECURSIONALGORITHMS
# Solution
def construct(mtrx, r, c):
    output: list = list()
    for n in range(len(mtrx)):
        top: list = list()
        if n == r: continue
        for m in range(len(mtrx[0])):
            if m == c: continue
            top.append(mtrx[n][m])
        output.append(top)
    return output
def determinant(matrix):
    ans = 0
    if len(matrix) == 1:
        return matrix[0][0]
    for i in range(len(matrix[0])):
        x = (matrix[0][i] * determinant(construct(matrix, 0, i)))
        ans = ans + (-x if i % 2 != 0 else x)
    return ans

# 1693. Daily Leads and Partners
# Table: DailySales
#
# +-------------+---------+
# | Column Name | Type    |
# +-------------+---------+
# | date_id     | date    |
# | make_name   | varchar |
# | lead_id     | int     |
# | partner_id  | int     |
# +-------------+---------+
# There is no primary key (column with unique values) for this table. It may contain duplicates.
# This table contains the date and the name of the product sold and the IDs of the lead and partner it was sold to.
# The name consists of only lowercase English letters.
#
#
# For each date_id and make_name, find the number of distinct lead_id's and distinct partner_id's.
#
# Return the result table in any order.
#
# The result format is in the following example.
#
#
#
# Example 1:
#
# Input:
# DailySales table:
# +-----------+-----------+---------+------------+
# | date_id   | make_name | lead_id | partner_id |
# +-----------+-----------+---------+------------+
# | 2020-12-8 | toyota    | 0       | 1          |
# | 2020-12-8 | toyota    | 1       | 0          |
# | 2020-12-8 | toyota    | 1       | 2          |
# | 2020-12-7 | toyota    | 0       | 2          |
# | 2020-12-7 | toyota    | 0       | 1          |
# | 2020-12-8 | honda     | 1       | 2          |
# | 2020-12-8 | honda     | 2       | 1          |
# | 2020-12-7 | honda     | 0       | 1          |
# | 2020-12-7 | honda     | 1       | 2          |
# | 2020-12-7 | honda     | 2       | 1          |
# +-----------+-----------+---------+------------+
# Output:
# +-----------+-----------+--------------+-----------------+
# | date_id   | make_name | unique_leads | unique_partners |
# +-----------+-----------+--------------+-----------------+
# | 2020-12-8 | toyota    | 2            | 3               |
# | 2020-12-7 | toyota    | 1            | 2               |
# | 2020-12-8 | honda     | 2            | 2               |
# | 2020-12-7 | honda     | 3            | 2               |
# +-----------+-----------+--------------+-----------------+
# Explanation:
# For 2020-12-8, toyota gets leads = [0, 1] and partners = [0, 1, 2] while honda gets leads = [1, 2] and partners = [1, 2].
# For 2020-12-7, toyota gets leads = [0] and partners = [1, 2] while honda gets leads = [0, 1, 2] and partners = [1, 2].
SELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners
FROM DailySales
GROUP BY date_id, make_name

# Codewars style ranking system
# Write a class called User that is used to calculate the amount that a user will progress through a ranking system similar to the one Codewars uses.
#
# Business Rules:
# A user starts at rank -8 and can progress all the way to 8.
# There is no 0 (zero) rank. The next rank after -1 is 1.
# Users will complete activities. These activities also have ranks.
# Each time the user completes a ranked activity the users rank progress is updated based off of the activity's rank
# The progress earned from the completed activity is relative to what the user's current rank is compared to the rank of the activity
# A user's rank progress starts off at zero, each time the progress reaches 100 the user's rank is upgraded to the next level
# Any remaining progress earned while in the previous rank will be applied towards the next rank's progress (we don't throw any progress away). The exception is if there is no other rank left to progress towards (Once you reach rank 8 there is no more progression).
# A user cannot progress beyond rank 8.
# The only acceptable range of rank values is -8,-7,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,7,8. Any other value should raise an error.
# The progress is scored like so:
#
# Completing an activity that is ranked the same as that of the user's will be worth 3 points
# Completing an activity that is ranked one ranking lower than the user's will be worth 1 point
# Any activities completed that are ranking 2 levels or more lower than the user's ranking will be ignored
# Completing an activity ranked higher than the current user's rank will accelerate the rank progression. The greater the difference between rankings the more the progression will be increased. The formula is 10 * d * d where d equals the difference in ranking between the activity and the user.
# Logic Examples:
# If a user ranked -8 completes an activity ranked -7 they will receive 10 progress
# If a user ranked -8 completes an activity ranked -6 they will receive 40 progress
# If a user ranked -8 completes an activity ranked -5 they will receive 90 progress
# If a user ranked -8 completes an activity ranked -4 they will receive 160 progress, resulting in the user being upgraded to rank -7 and having earned 60 progress towards their next rank
# If a user ranked -1 completes an activity ranked 1 they will receive 10 progress (remember, zero rank is ignored)
# Code Usage Examples:
# user = User()
# user.rank # => -8
# user.progress # => 0
# user.inc_progress(-7)
# user.progress # => 10
# user.inc_progress(-5) # will add 90 progress
# user.progress # => 0 # progress is now zero
# user.rank # => -7 # rank was upgraded to -7
# Note: Codewars no longer uses this algorithm for its own ranking system. It uses a pure Math based solution that gives consistent results no matter what order a set of ranked activities are completed at.
#
# ALGORITHMSOBJECT-ORIENTED PROGRAMMING
class User:
    def __init__(self):
        self.rank: int = -8
        self.progress: int = 0

    def inc_progress(self, rank: int) -> None:
        if rank == 0 or not -8 <= rank <= 8:
            raise ValueError
        if self.rank == 8: return
        negative_rank: bool = self.rank < 0
        negative_rank_completed: bool = rank < 0
        if self.rank == rank:
            self.progress += 3

        elif negative_rank == negative_rank_completed == True:
            if self.rank > rank:
                if abs(rank) - abs(self.rank) == 1:
                    self.progress += 1
            else:
                d: int = abs(self.rank) - abs(rank)
                self.progress += 10 * d * d

        elif negative_rank == negative_rank_completed == False:
            if self.rank < rank:
                d: int = rank - self.rank
                self.progress += 10 * d * d
            elif self.rank - rank == 1:
                self.progress += 1

        elif negative_rank and not negative_rank_completed:
            x: int = abs(self.rank) - 1
            d: int = rank + x
            self.progress += 10 * d * d

        elif not negative_rank and negative_rank_completed:
            if self.rank == 1 and rank == -1:
                self.progress += 1

        if self.progress >= 100 and self.rank < 8:
            update: int = self.progress // 100
            if self.rank < 0 and self.rank + update >= 0:
                update += 1
            self.rank += update
            self.rank = min(self.rank, 8)
            if self.rank == 0:
                self.rank += 1
            if self.rank == 8:
                self.progress = 0
            else:
                self.progress %= 100
                
# 1795. Rearrange Products Table
# Table: Products
#
# +-------------+---------+
# | Column Name | Type    |
# +-------------+---------+
# | product_id  | int     |
# | store1      | int     |
# | store2      | int     |
# | store3      | int     |
# +-------------+---------+
# product_id is the primary key (column with unique values) for this table.
# Each row in this table indicates the product's price in 3 different stores: store1, store2, and store3.
# If the product is not available in a store, the price will be null in that store's column.
#
#
# Write a solution to rearrange the Products table so that each row has (product_id, store, price). If a product is not available in a store, do not include a row with that product_id and store combination in the result table.
#
# Return the result table in any order.
#
# The result format is in the following example.
#
#
#
# Example 1:
#
# Input:
# Products table:
# +------------+--------+--------+--------+
# | product_id | store1 | store2 | store3 |
# +------------+--------+--------+--------+
# | 0          | 95     | 100    | 105    |
# | 1          | 70     | null   | 80     |
# +------------+--------+--------+--------+
# Output:
# +------------+--------+-------+
# | product_id | store  | price |
# +------------+--------+-------+
# | 0          | store1 | 95    |
# | 0          | store2 | 100   |
# | 0          | store3 | 105   |
# | 1          | store1 | 70    |
# | 1          | store3 | 80    |
# +------------+--------+-------+
# Explanation:
# Product 0 is available in all three stores with prices 95, 100, and 105 respectively.
# Product 1 is available in store1 with price 70 and store3 with price 80. The product is not available in store2.
SELECT product_id, 'store1' AS store, store1 AS price
FROM Products
WHERE store1 IS NOT NULL
UNION
SELECT product_id, 'store2' AS store, store2 AS price
FROM Products
WHERE store2 IS NOT NULL
UNION
SELECT product_id, 'store3' as store, store3 AS price
FROM Products
WHERE store3 IS NOT NULL

# The Millionth Fibonacci Kata
# The year is 1214. One night, Pope Innocent III awakens to find the the archangel Gabriel floating before him. Gabriel thunders to the pope:
#
# Gather all of the learned men in Pisa, especially Leonardo Fibonacci. In order for the crusades in the holy lands to be successful, these men must calculate the millionth number in Fibonacci's recurrence. Fail to do this, and your armies will never reclaim the holy land. It is His will.
#
# The angel then vanishes in an explosion of white light.
#
# Pope Innocent III sits in his bed in awe. How much is a million? he thinks to himself. He never was very good at math.
#
# He tries writing the number down, but because everyone in Europe is still using Roman numerals at this moment in history, he cannot represent this number. If he only knew about the invention of zero, it might make this sort of thing easier.
#
# He decides to go back to bed. He consoles himself, The Lord would never challenge me thus; this must have been some deceit by the devil. A pretty horrendous nightmare, to be sure.
#
# Pope Innocent III's armies would go on to conquer Constantinople (now Istanbul), but they would never reclaim the holy land as he desired.
#
# In this kata you will have to calculate fib(n) where:
#
# fib(0) := 0
# fib(1) := 1
# fib(n + 2) := fib(n + 1) + fib(n)
# Write an algorithm that can handle n up to 2000000.
#
# Your algorithm must output the exact integer answer, to full precision. Also, it must correctly handle negative numbers as input.
#
# HINT I: Can you rearrange the equation fib(n + 2) = fib(n + 1) + fib(n) to find fib(n) if you already know fib(n + 1) and fib(n + 2)? Use this to reason what value fib has to have for negative values.
#
# HINT II: See https://web.archive.org/web/20220614001843/https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2.4
#
# MATHEMATICSALGORITHMS
import numpy as np

def fib(n):
    matrix = np.matrix([[1, 1], [1, 0]], dtype=object) ** abs(n)
    if n%2 == 0 and n < 0:
        return -matrix[0,1]
    return matrix[0, 1]

# 3146. Permutation Difference between Two Strings
# You are given two strings s and t such that every character occurs at most once in s and t is a permutation of s.
#
# The permutation difference between s and t is defined as the sum of the absolute difference between the index of the occurrence of each character in s and the index of the occurrence of the same character in t.
#
# Return the permutation difference between s and t.
#
#
#
# Example 1:
#
# Input: s = "abc", t = "bac"
#
# Output: 2
#
# Explanation:
#
# For s = "abc" and t = "bac", the permutation difference of s and t is equal to the sum of:
#
# The absolute difference between the index of the occurrence of "a" in s and the index of the occurrence of "a" in t.
# The absolute difference between the index of the occurrence of "b" in s and the index of the occurrence of "b" in t.
# The absolute difference between the index of the occurrence of "c" in s and the index of the occurrence of "c" in t.
# That is, the permutation difference between s and t is equal to |0 - 1| + |2 - 2| + |1 - 0| = 2.
#
# Example 2:
#
# Input: s = "abcde", t = "edbac"
#
# Output: 12
#
# Explanation: The permutation difference between s and t is equal to |0 - 3| + |1 - 2| + |2 - 4| + |3 - 1| + |4 - 0| = 12.
#
#
#
# Constraints:
#
# 1 <= s.length <= 26
# Each character occurs at most once in s.
# t is a permutation of s.
# s consists only of lowercase English letters.
class Solution:
    def findPermutationDifference(self, s: str, t: str) -> int:
        ht: dict[str, int] = dict()
        for i in range(len(s)):
            if s[i] in ht:
                ht[s[i]] = abs(ht[s[i]] - i)
            else:
                ht[s[i]] = i
            if t[i] in ht:
                ht[t[i]] = abs(ht[t[i]] - i)
            else:
                ht[t[i]] = i
        return sum(ht.values())

# 3142. Check if Grid Satisfies Conditions
# You are given a 2D matrix grid of size m x n. You need to check if each cell grid[i][j] is:
#
# Equal to the cell below it, i.e. grid[i][j] == grid[i + 1][j] (if it exists).
# Different from the cell to its right, i.e. grid[i][j] != grid[i][j + 1] (if it exists).
# Return true if all the cells satisfy these conditions, otherwise, return false.
#
#
#
# Example 1:
#
# Input: grid = [[1,0,2],[1,0,2]]
#
# Output: true
#
# Explanation:
#
#
#
# All the cells in the grid satisfy the conditions.
#
# Example 2:
#
# Input: grid = [[1,1,1],[0,0,0]]
#
# Output: false
#
# Explanation:
#
#
#
# All cells in the first row are equal.
#
# Example 3:
#
# Input: grid = [[1],[2],[3]]
#
# Output: false
#
# Explanation:
#
#
#
# Cells in the first column have different values.
#
#
#
# Constraints:
#
# 1 <= n, m <= 10
# 0 <= grid[i][j] <= 9
class Solution:
    def satisfiesConditions(self, grid: List[List[int]]) -> bool:
        n, m = len(grid), len(grid[0])
        for row in range(n):
            for col in range(m):
                if col + 1 < m:
                    if grid[row][col] == grid[row][col + 1]:
                        return False
                if row + 1 < n:
                    if grid[row][col] != grid[row + 1][col]:
                        return False
        return True

# 861. Score After Flipping Matrix
# You are given an m x n binary matrix grid.
#
# A move consists of choosing any row or column and toggling each value in that row or column (i.e., changing all 0's to 1's, and all 1's to 0's).
#
# Every row of the matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers.
#
# Return the highest possible score after making any number of moves (including zero moves).
#
#
#
# Example 1:
#
#
# Input: grid = [[0,0,1,1],[1,0,1,0],[1,1,0,0]]
# Output: 39
# Explanation: 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39
# Example 2:
#
# Input: grid = [[0]]
# Output: 1
#
#
# Constraints:
#
# m == grid.length
# n == grid[i].length
# 1 <= m, n <= 20
# grid[i][j] is either 0 or 1.
class Solution:
    def matrixScore(self, grid: List[List[int]]) -> int:
        n, m = len(grid), len(grid[0])
        for row in range(n):
            if grid[row][0] == 0:
                for col in range(m):
                    grid[row][col] ^= 1
        for col in range(m):
            count: int = sum(grid[row][col] for row in range(n))
            if count < n - count:
                for row in range(n):
                    grid[row][col] ^= 1
        return sum(int(''.join(str(i) for i in grid[row]), 2) for row in range(n))
    
# Make Me Slow
# Make me slow! Calling makeMeSlow() should take at least 7 seconds.
#
# FUNDAMENTALS
import time
def make_me_slow():
    time.sleep(7)
    for i in range(1000000):
        pass

# 2181. Merge Nodes in Between Zeros
# You are given the head of a linked list, which contains a series of integers separated by 0's. The beginning and end of the linked list will have Node.val == 0.
#
# For every two consecutive 0's, merge all the nodes lying in between them into a single node whose value is the sum of all the merged nodes. The modified list should not contain any 0's.
#
# Return the head of the modified linked list.
#
#
#
# Example 1:
#
#
# Input: head = [0,3,1,0,4,5,2,0]
# Output: [4,11]
# Explanation:
# The above figure represents the given linked list. The modified list contains
# - The sum of the nodes marked in green: 3 + 1 = 4.
# - The sum of the nodes marked in red: 4 + 5 + 2 = 11.
# Example 2:
#
#
# Input: head = [0,1,0,3,0,2,2,0]
# Output: [1,3,4]
# Explanation:
# The above figure represents the given linked list. The modified list contains
# - The sum of the nodes marked in green: 1 = 1.
# - The sum of the nodes marked in red: 3 = 3.
# - The sum of the nodes marked in yellow: 2 + 2 = 4.
#
#
# Constraints:
#
# The number of nodes in the list is in the range [3, 2 * 105].
# 0 <= Node.val <= 1000
# There are no two consecutive nodes with Node.val == 0.
# The beginning and end of the linked list have Node.val == 0.
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:
        tmp = head
        inner_tmp = head
        top: int = 0
        while tmp.next:
            if tmp.val == 0 and tmp is not head:
                inner_tmp.val = top
                inner_tmp = inner_tmp.next
                top = 0
            top += tmp.val
            tmp = tmp.next
        inner_tmp.val = top
        inner_tmp.next = None
        return head

# Twice linear
# Consider a sequence u where u is defined as follows:
#
# The number u(0) = 1 is the first one in u.
# For each x in u, then y = 2 * x + 1 and z = 3 * x + 1 must be in u too.
# There are no other numbers in u.
# Ex: u = [1, 3, 4, 7, 9, 10, 13, 15, 19, 21, 22, 27, ...]
#
# 1 gives 3 and 4, then 3 gives 7 and 10, 4 gives 9 and 13, then 7 gives 15 and 22 and so on...
#
# Task:
# Given parameter n the function dbl_linear (or dblLinear...) returns the element u(n) of the ordered (with <) sequence u (so, there are no duplicates).
#
# Example:
# dbl_linear(10) should return 22
#
# Note:
# Focus attention on efficiency
#
# MATHEMATICSALGORITHMS
import heapq
def dbl_linear(n):
    u_set = {1}
    u_heap = [1]
    for _ in range(n):
        smallest = heapq.heappop(u_heap)
        y = 2 * smallest + 1
        z = 3 * smallest + 1
        if y not in u_set:
            u_set.add(y)
            heapq.heappush(u_heap, y)
        if z not in u_set:
            u_set.add(z)
            heapq.heappush(u_heap, z)
    return heapq.heappop(u_heap)

# 495. Teemo Attacking
# Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets poisoned for a exactly duration seconds. More formally, an attack at second t will mean Ashe is poisoned during the inclusive time interval [t, t + duration - 1]. If Teemo attacks again before the poison effect ends, the timer for it is reset, and the poison effect will end duration seconds after the new attack.
#
# You are given a non-decreasing integer array timeSeries, where timeSeries[i] denotes that Teemo attacks Ashe at second timeSeries[i], and an integer duration.
#
# Return the total number of seconds that Ashe is poisoned.
#
#
#
# Example 1:
#
# Input: timeSeries = [1,4], duration = 2
# Output: 4
# Explanation: Teemo's attacks on Ashe go as follows:
# - At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.
# - At second 4, Teemo attacks, and Ashe is poisoned for seconds 4 and 5.
# Ashe is poisoned for seconds 1, 2, 4, and 5, which is 4 seconds in total.
# Example 2:
#
# Input: timeSeries = [1,2], duration = 2
# Output: 3
# Explanation: Teemo's attacks on Ashe go as follows:
# - At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.
# - At second 2 however, Teemo attacks again and resets the poison timer. Ashe is poisoned for seconds 2 and 3.
# Ashe is poisoned for seconds 1, 2, and 3, which is 3 seconds in total.
#
#
# Constraints:
#
# 1 <= timeSeries.length <= 104
# 0 <= timeSeries[i], duration <= 107
# timeSeries is sorted in non-decreasing order.
class Solution:
    def findPoisonedDuration(self, timeSeries: List[int], duration: int) -> int:
        output: int = 0
        for i in range(1, len(timeSeries)):
            time_window: int = (timeSeries[i] - timeSeries[i - 1])
            output += duration if time_window >= duration else time_window
        return output + duration

# 628. Maximum Product of Three Numbers
# Given an integer array nums, find three numbers whose product is maximum and return the maximum product.
#
#
#
# Example 1:
#
# Input: nums = [1,2,3]
# Output: 6
# Example 2:
#
# Input: nums = [1,2,3,4]
# Output: 24
# Example 3:
#
# Input: nums = [-1,-2,-3]
# Output: -6
#
#
# Constraints:
#
# 3 <= nums.length <= 104
# -1000 <= nums[i] <= 1000
class Solution:
    def maximumProduct(self, nums: List[int]) -> int:
        first_max = second_max = third_max = float('-inf')
        first_min = second_min = float('inf')
        for i in nums:
            if i > first_max:
                first_max, second_max, third_max = i, first_max, second_max
            elif i > second_max:
                second_max, third_max = i, second_max
            elif i > third_max:
                third_max = i
            if i < first_min:
                first_min, second_min = i, first_min
            elif i < second_min:
                second_min = i
        if second_min != float('inf'):
            return max(first_min * second_min * first_max, first_max * second_max * third_max)
        return first_max * second_max * third_max

# 2094. Finding 3-Digit Even Numbers
# You are given an integer array digits, where each element is a digit. The array may contain duplicates.
#
# You need to find all the unique integers that follow the given requirements:
#
# The integer consists of the concatenation of three elements from digits in any arbitrary order.
# The integer does not have leading zeros.
# The integer is even.
# For example, if the given digits were [1, 2, 3], integers 132 and 312 follow the requirements.
#
# Return a sorted array of the unique integers.
#
#
#
# Example 1:
#
# Input: digits = [2,1,3,0]
# Output: [102,120,130,132,210,230,302,310,312,320]
# Explanation: All the possible integers that follow the requirements are in the output array.
# Notice that there are no odd integers or integers with leading zeros.
# Example 2:
#
# Input: digits = [2,2,8,8,2]
# Output: [222,228,282,288,822,828,882]
# Explanation: The same digit can be used as many times as it appears in digits.
# In this example, the digit 8 is used twice each time in 288, 828, and 882.
# Example 3:
#
# Input: digits = [3,7,5]
# Output: []
# Explanation: No even integers can be formed using the given digits.
#
#
# Constraints:
#
# 3 <= digits.length <= 100
# 0 <= digits[i] <= 9
class Solution:
    def findEvenNumbers(self, digits: List[int]) -> List[int]:
        output: list[int] = list()
        digits_count: list[int] = [0] * 10
        for digit in digits:
            digits_count[digit] += 1
        even_digits: list[int] = [i for i in range(0, 10, 2) if digits_count[i] > 0]
        if len(even_digits) == 0: return output
        for first_digit in range(10):
            if first_digit != 0 and digits_count[first_digit] > 0:
                digits_count[first_digit] -= 1
                for second_digit in range(10):
                    if digits_count[second_digit] > 0:
                        digits_count[second_digit] -= 1
                        for third_digit in even_digits:
                            if digits_count[third_digit] > 0:
                                digit: int = first_digit * 100 + second_digit * 10 + third_digit
                                output.append(digit)
                        digits_count[second_digit] += 1
                digits_count[first_digit] += 1
        return output

# 2433. Find The Original Array of Prefix Xor
# You are given an integer array pref of size n. Find and return the array arr of size n that satisfies:
#
# pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i].
# Note that ^ denotes the bitwise-xor operation.
#
# It can be proven that the answer is unique.
#
#
#
# Example 1:
#
# Input: pref = [5,2,0,3,1]
# Output: [5,7,2,3,2]
# Explanation: From the array [5,7,2,3,2] we have the following:
# - pref[0] = 5.
# - pref[1] = 5 ^ 7 = 2.
# - pref[2] = 5 ^ 7 ^ 2 = 0.
# - pref[3] = 5 ^ 7 ^ 2 ^ 3 = 3.
# - pref[4] = 5 ^ 7 ^ 2 ^ 3 ^ 2 = 1.
# Example 2:
#
# Input: pref = [13]
# Output: [13]
# Explanation: We have pref[0] = arr[0] = 13.
#
#
# Constraints:
#
# 1 <= pref.length <= 105
# 0 <= pref[i] <= 106
class Solution:
    def findArray(self, pref: List[int]) -> List[int]:
        for i in range(len(pref) - 1, 0, -1):
            pref[i] ^= pref[i - 1]
        return pref

# parseInt() reloaded
# In this kata we want to convert a string into an integer. The strings simply represent the numbers in words.
#
# Examples:
#
# "one" => 1
# "twenty" => 20
# "two hundred forty-six" => 246
# "seven hundred eighty-three thousand nine hundred and nineteen" => 783919
# Additional Notes:
#
# The minimum number is "zero" (inclusively)
# The maximum number, which must be supported is 1 million (inclusively)
# The "and" in e.g. "one hundred and twenty-four" is optional, in some cases it's present and in others it's not
# All tested numbers are valid, you don't need to validate them
# PARSINGSTRINGSALGORITHMS
def parse_int(string):
    digits: dict[str, int] = {
        'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4,
        'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9
    }
    teens: dict[str, int] = {
        'eleven': 11, 'twelve': 12, 'thirteen': 13, 'fourteen': 14, 'fifteen': 15,
        'sixteen': 16, 'seventeen': 17, 'eighteen': 18, 'nineteen': 19
    }
    tens: dict[str, int] = {
        'ten': 10, 'twenty': 20, 'thirty': 30, 'forty': 40, 'fifty': 50,
        'sixty': 60, 'seventy': 70, 'eighty': 80, 'ninety': 90
    }
    ordinal: dict[str, int] = {
        'hundred': 100, 'thousand': 1000, 'million': 1_000_000
    }
    string = string.replace('-', ' ')
    number: int = 0
    string = string.split()
    if string[0] in teens: return teens.get(string[0])
    n: int = len(string)
    idx: int = 0
    inner_num: int = 0
    while idx < n:
        char: str = string[idx]
        if char in teens:
            number += inner_num + teens.get(char)
            inner_num = 0
        elif char in digits:
            x: int = digits.get(char)
            inner_num += x
        elif char in tens:
            x: int = tens.get(char)
            inner_num += x
            if (idx + 1 < n and string[idx + 1] != 'and' and not ordinal.get(string[idx + 1]) and not digits.get(string[idx + 1])):
                number += inner_num
                inner_num = 0
        elif char in ordinal:
            while idx < n and ordinal.get(string[idx]):
                inner_num *= ordinal.get(string[idx])
                idx += 1
            if idx < n and string[idx] != 'and':
                if digits.get(string[idx]) and (idx + 2 == n and string[-1] == 'thousand'):
                    inner_num += digits.get(string[idx])
                    idx += 1
                elif tens.get(string[idx]) and (idx + 1 < n and not ordinal.get(string[idx + 1])):
                    inner_num += tens.get(string[idx])
                    idx += 1
                else:
                    number += inner_num
                    inner_num = 0
            continue
        idx += 1
    number += inner_num
    return number

# 1068. Product Sales Analysis I
# Table: Sales
#
# +-------------+-------+
# | Column Name | Type  |
# +-------------+-------+
# | sale_id     | int   |
# | product_id  | int   |
# | year        | int   |
# | quantity    | int   |
# | price       | int   |
# +-------------+-------+
# (sale_id, year) is the primary key (combination of columns with unique values) of this table.
# product_id is a foreign key (reference column) to Product table.
# Each row of this table shows a sale on the product product_id in a certain year.
# Note that the price is per unit.
#
#
# Table: Product
#
# +--------------+---------+
# | Column Name  | Type    |
# +--------------+---------+
# | product_id   | int     |
# | product_name | varchar |
# +--------------+---------+
# product_id is the primary key (column with unique values) of this table.
# Each row of this table indicates the product name of each product.
#
#
# Write a solution to report the product_name, year, and price for each sale_id in the Sales table.
#
# Return the resulting table in any order.
#
# The result format is in the following example.
#
#
#
# Example 1:
#
# Input:
# Sales table:
# +---------+------------+------+----------+-------+
# | sale_id | product_id | year | quantity | price |
# +---------+------------+------+----------+-------+
# | 1       | 100        | 2008 | 10       | 5000  |
# | 2       | 100        | 2009 | 12       | 5000  |
# | 7       | 200        | 2011 | 15       | 9000  |
# +---------+------------+------+----------+-------+
# Product table:
# +------------+--------------+
# | product_id | product_name |
# +------------+--------------+
# | 100        | Nokia        |
# | 200        | Apple        |
# | 300        | Samsung      |
# +------------+--------------+
# Output:
# +--------------+-------+-------+
# | product_name | year  | price |
# +--------------+-------+-------+
# | Nokia        | 2008  | 5000  |
# | Nokia        | 2009  | 5000  |
# | Apple        | 2011  | 9000  |
# +--------------+-------+-------+
# Explanation:
# From sale_id = 1, we can conclude that Nokia was sold for 5000 in the year 2008.
# From sale_id = 2, we can conclude that Nokia was sold for 5000 in the year 2009.
# From sale_id = 7, we can conclude that Apple was sold for 9000 in the year 2011.
SELECT product_name, year, price
FROM Sales
JOIN Product ON Sales.product_id = Product.product_id

# Make a spiral
# Your task, is to create a NxN spiral with a given size.
#
# For example, spiral with size 5 should look like this:
#
# 00000
# ....0
# 000.0
# 0...0
# 00000
# and with the size 10:
#
# 0000000000
# .........0
# 00000000.0
# 0......0.0
# 0.0000.0.0
# 0.0..0.0.0
# 0.0....0.0
# 0.000000.0
# 0........0
# 0000000000
# Return value should contain array of arrays, of 0 and 1, with the first row being composed of 1s. For example for given size 5 result should be:
#
# [[1,1,1,1,1],[0,0,0,0,1],[1,1,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]
# Because of the edge-cases for tiny spirals, the size will be at least 5.
#
# General rule-of-a-thumb is, that the snake made with '1' cannot touch to itself.
#
# ALGORITHMSARRAYSLOGIC
def check_right(output, up, right, n):
    moves = [[-1, 1], [1, 1]]
    for m in moves:
        x, y = m
        if (not 0 <= up + x <= n - 1) or (not 0 <= right + y <= n - 1):
            continue
        if output[up + x][right + y] == 1:
            return False
    return True

def check_left(output, up, right, n):
    moves = [[1, -1], [-1, -1]]
    for m in moves:
        x, y = m
        if (not 0 <= up + x <= n - 1) or (not 0 <= right + y <= n - 1):
            continue
        if output[up + x][right + y] == 1:
            return False
    return True

def spiralize(size):
    right, up = 0, 0    
    output: list[list[int]] = [[0 for _ in range(size)] for _ in range(size)]
    n: int = size
    for rep in range(n):

        for i in range(size - 1):
            if not check_right(output, up, right, n):
                break
            if output[up][min(right + 1, n - 1)] == 1:
                break
            output[up][right] = 1
            if output[up][min(right + 2, n - 1)] == 1:
                break
            right += 1

        for i in range(size - 1):
            if output[min(up + 1, n - 1)][right] == 1:
                break
            output[up][right] = 1
            if output[min(up + 2, n - 1)][right] == 1:
                break
            up += 1

        for i in range(size - 1):
            if not check_left(output, up, right, n):
                break
            if output[up][max(0, right - 1)] == 1:
                break
            output[up][right] = 1
            if output[up][max(0, right - 2)] == 1:
                break
            right -= 1
            move_left = True
        size -= 2

        for i in range(size - 1):
            if output[max(0, up - 1)][right] == 1:
                break
            output[up][right] = 1
            if output[max(0, up - 2)][right] == 1:
                break
            up -= 1
        if size <= 0: break
    return output

# 1587. Bank Account Summary II
# Table: Users
#
# +--------------+---------+
# | Column Name  | Type    |
# +--------------+---------+
# | account      | int     |
# | name         | varchar |
# +--------------+---------+
# account is the primary key (column with unique values) for this table.
# Each row of this table contains the account number of each user in the bank.
# There will be no two users having the same name in the table.
#
#
# Table: Transactions
#
# +---------------+---------+
# | Column Name   | Type    |
# +---------------+---------+
# | trans_id      | int     |
# | account       | int     |
# | amount        | int     |
# | transacted_on | date    |
# +---------------+---------+
# trans_id is the primary key (column with unique values) for this table.
# Each row of this table contains all changes made to all accounts.
# amount is positive if the user received money and negative if they transferred money.
# All accounts start with a balance of 0.
#
#
# Write a solution to report the name and balance of users with a balance higher than 10000. The balance of an account is equal to the sum of the amounts of all transactions involving that account.
#
# Return the result table in any order.
#
# The result format is in the following example.
#
#
#
# Example 1:
#
# Input:
# Users table:
# +------------+--------------+
# | account    | name         |
# +------------+--------------+
# | 900001     | Alice        |
# | 900002     | Bob          |
# | 900003     | Charlie      |
# +------------+--------------+
# Transactions table:
# +------------+------------+------------+---------------+
# | trans_id   | account    | amount     | transacted_on |
# +------------+------------+------------+---------------+
# | 1          | 900001     | 7000       |  2020-08-01   |
# | 2          | 900001     | 7000       |  2020-09-01   |
# | 3          | 900001     | -3000      |  2020-09-02   |
# | 4          | 900002     | 1000       |  2020-09-12   |
# | 5          | 900003     | 6000       |  2020-08-07   |
# | 6          | 900003     | 6000       |  2020-09-07   |
# | 7          | 900003     | -4000      |  2020-09-11   |
# +------------+------------+------------+---------------+
# Output:
# +------------+------------+
# | name       | balance    |
# +------------+------------+
# | Alice      | 11000      |
# +------------+------------+
# Explanation:
# Alice's balance is (7000 + 7000 - 3000) = 11000.
# Bob's balance is 1000.
# Charlie's balance is (6000 + 6000 - 4000) = 8000.
SELECT Users.name, SUM(amount) AS balance
FROM Users
JOIN Transactions ON Users.account = Transactions.account
GROUP BY Users.name
HAVING SUM(Transactions.amount) > 10000

# Sortable Shapes
# Although shapes can be very different by nature, they can be sorted by the size of their area.
# 
# Task:
# 
# Create different shapes that can be part of a sortable list. The sort order is based on the size of their respective areas:
# The area of a Square is the square of its side
# The area of a Rectangle is width multiplied by height
# The area of a Triangle is base multiplied by height divided by 2
# The area of a Circle is the square of its radius multiplied by π
# The area of a CustomShape is given
# 
# The default sort order of a list of shapes is ascending on area size:
# side = 1.1234
# radius = 1.1234
# base = 5
# height = 2
# 
# # All classes must be subclasses of the Shape class
# 
# shapes: List[Shape] = [Square(side), Circle(radius), Triangle(base, height)]
# shapes.sort()
# Use the correct π constant for your circle area calculations:
# math.pi
# 
# SORTINGFUNDAMENTALSMATHEMATICSDESIGN PATTERNSARRAYSGEOMETRY
from math import pi


class Shape:
    def __init__(self):
        self.area: float = 0.0

    def __lt__(self, x) -> bool:
        return self.area < x.area

    def __gt__(self, x) -> bool:
        return self.area > x.area

    def __eq__(self, x) -> bool:
        return self.area == x.area

    def __le__(self, x) -> bool:
        return self.area <= x.area

    def __ge__(self, x) -> bool:
        return self.area >= x.area

    def __ne__(self, x) -> bool:
        return self.area != x.area


class Square(Shape):
    def __init__(self, side: int):
        super().__init__()
        self.area = side ** 2


class Rectangle(Shape):
    def __init__(self, width: int, height: int):
        super().__init__()
        self.area = width * height


class Triangle(Shape):
    def __init__(self, base: int, height: int):
        super().__init__()
        self.area = (base * height) / 2


class Circle(Shape):
    def __init__(self, radius: float):
        super().__init__()
        self.area = radius ** 2 * pi


class CustomShape(Shape):
    def __init__(self, area: float):
        super().__init__()
        self.area = area
        
# 1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree
# Given two binary trees original and cloned and given a reference to a node target in the original tree.
#
# The cloned tree is a copy of the original tree.
#
# Return a reference to the same node in the cloned tree.
#
# Note that you are not allowed to change any of the two trees or the target node and the answer must be a reference to a node in the cloned tree.
#
#
#
# Example 1:
#
#
# Input: tree = [7,4,3,null,null,6,19], target = 3
# Output: 3
# Explanation: In all examples the original and cloned trees are shown. The target node is a green node from the original tree. The answer is the yellow node from the cloned tree.
# Example 2:
#
#
# Input: tree = [7], target =  7
# Output: 7
# Example 3:
#
#
# Input: tree = [8,null,6,null,5,null,4,null,3,null,2,null,1], target = 4
# Output: 4
#
#
# Constraints:
#
# The number of nodes in the tree is in the range [1, 104].
# The values of the nodes of the tree are unique.
# target node is a node from the original tree and is not null.
#
#
# Follow up: Could you solve the problem if repeated values on the tree are allowed?
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:
        next_nodes: list = list()
        current_nodes: list = [cloned]
        while current_nodes:
            for node in current_nodes:
                if node.val == target.val:
                    return node
                if node and node.left:
                    next_nodes.append(node.left)
                if node and node.right:
                    next_nodes.append(node.right)
            current_nodes = next_nodes
            next_nodes = []

# Fun with trees: max sum
# You are given a binary tree. Implement a function that returns the maximum sum of a route from root to leaf.
#
# For example, given the following tree:
#
#     17
#    /  \
#   3   -10
#  /    /  \
# 2    16   1
#          /
#         13
# The function should return 23, since 17 -> -10 -> 16 is the route from root to leaf with the maximum sum.
#
# Return 0 if the tree is empty.
#
# Please note that you are not to find the best possible route in the tree, but the best possible route from root to leaf, e.g. for the following tree, you cannot skip the leaves and return 5 + 10 = 15: the expected answer is 5 + 4 + -60 = -51
#
#         5
#       /   \
#     4      10
#    / \     /
# -80 -60 -90
# A tree node type is preloaded for you:
#
# class TreeNode:
#     def __init__(self, value, left=None, right=None):
#         self.value = value
#         self.left = left
#         self.right = right
# This kata is part of fun with trees series:
#
# Fun with trees: max sum
# Fun with trees: array to tree
# Fun with trees: is perfect
# TREESRECURSIONBINARY TREESBINARY SEARCH TREESDATA STRUCTURESALGORITHMS
from preloaded import TreeNode

def max_sum(root: TreeNode) -> int:
    ans: int = float('-inf')
    def dfs(root, top: int = 0):
        if not root:
            return
        if not root.left and not root.right:
            nonlocal ans
            ans = max(ans, top + root.value)
        if root.left:
            dfs(root.left, top + root.value)
        if root.right:
            dfs(root.right, top + root.value)
    dfs(root)
    return ans if root else 0

# 3151. Special Array I
# An array is considered special if every pair of its adjacent elements contains two numbers with different parity.
#
# You are given an array of integers nums. Return true if nums is a special array, otherwise, return false.
#
#
#
# Example 1:
#
# Input: nums = [1]
#
# Output: true
#
# Explanation:
#
# There is only one element. So the answer is true.
#
# Example 2:
#
# Input: nums = [2,1,4]
#
# Output: true
#
# Explanation:
#
# There is only two pairs: (2,1) and (1,4), and both of them contain numbers with different parity. So the answer is true.
#
# Example 3:
#
# Input: nums = [4,3,1,6]
#
# Output: false
#
# Explanation:
#
# nums[1] and nums[2] are both odd. So the answer is false.
#
#
#
# Constraints:
#
# 1 <= nums.length <= 100
# 1 <= nums[i] <= 100
class Solution:
    def isArraySpecial(self, nums: List[int]) -> bool:
        return all(x % 2 != y % 2 for x, y in zip(nums, nums[1:]))

# 3152. Special Array II
# An array is considered special if every pair of its adjacent elements contains two numbers with different parity.
#
# You are given an array of integer nums and a 2D integer matrix queries, where for queries[i] = [fromi, toi] your task is to check that
# subarray
#  nums[fromi..toi] is special or not.
#
# Return an array of booleans answer such that answer[i] is true if nums[fromi..toi] is special.
#
#
#
# Example 1:
#
# Input: nums = [3,4,1,2,6], queries = [[0,4]]
#
# Output: [false]
#
# Explanation:
#
# The subarray is [3,4,1,2,6]. 2 and 6 are both even.
#
# Example 2:
#
# Input: nums = [4,3,1,6], queries = [[0,2],[2,3]]
#
# Output: [false,true]
#
# Explanation:
#
# The subarray is [4,3,1]. 3 and 1 are both odd. So the answer to this query is false.
# The subarray is [1,6]. There is only one pair: (1,6) and it contains numbers with different parity. So the answer to this query is true.
#
#
# Constraints:
#
# 1 <= nums.length <= 105
# 1 <= nums[i] <= 105
# 1 <= queries.length <= 105
# queries[i].length == 2
# 0 <= queries[i][0] <= queries[i][1] <= nums.length - 1
# Solution Sorting O(NlogN) O(N)
class Solution:
    def isArraySpecial(self, nums: List[int], queries: List[List[int]]) -> List[bool]:
        n: int = len(queries)
        output: list[bool] = [True] * n
        for i in range(n):
            queries[i].append(i)
        queries.sort(key=lambda x: (x[0], -x[1]))
        idx: int = 0
        for i in range(1, len(nums)):
            if nums[i - 1] % 2 == nums[i] % 2:
                while idx < n:
                    if i - 1 < queries[idx][0]:
                        break
                    if i <= queries[idx][1]:
                        output[queries[idx][-1]] = False
                        idx += 1
                    else:
                        idx += 1
        return output
# Solution Prefix Sum O(N) O(N)
class Solution:
    def isArraySpecial(self, nums: List[int], queries: List[List[int]]) -> List[bool]:
        n: int = len(queries)
        output: list[int] = [1]
        for item in range(1, len(nums)):
            x: int = output[-1]
            output.append(x if nums[item - 1] % 2 == nums[item] % 2 else x + 1)
        for i in range(n):
            x, y = queries[i]
            queries[i] = output[y] - output[x] == y - x
        return queries

# 2236. Root Equals Sum of Children
# You are given the root of a binary tree that consists of exactly 3 nodes: the root, its left child, and its right child.
#
# Return true if the value of the root is equal to the sum of the values of its two children, or false otherwise.
#
#
#
# Example 1:
#
#
# Input: root = [10,4,6]
# Output: true
# Explanation: The values of the root, its left child, and its right child are 10, 4, and 6, respectively.
# 10 is equal to 4 + 6, so we return true.
# Example 2:
#
#
# Input: root = [5,3,1]
# Output: false
# Explanation: The values of the root, its left child, and its right child are 5, 3, and 1, respectively.
# 5 is not equal to 3 + 1, so we return false.
#
#
# Constraints:
#
# The tree consists only of the root, its left child, and its right child.
# -100 <= Node.val <= 100
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def checkTree(self, root: Optional[TreeNode]) -> bool:
        return root.val == root.left.val + root.right.val

# Binary Tree Compare
# Given the node object:
#
# Node:
#   val: <int>,
#   left: <Node> or null,
#   right: <Node> or null
# write a function compare(a, b) which compares the two trees defined by Nodes a and b and returns true if they are equal in structure and in value and false otherwise.
#
# Examples:
#
# 1       1
# | \     | \
# 2  3    2  3
# => true
#
# 1       1
# | \     | \
# 3  3    2  3
# => false (values not the same 2 != 3)
#
# 1       1
# | \     |
# 2  3    2
#         |
#         3
# => false (structure not the same)
# BINARY TREESALGORITHMS
def compare(a, b):
    if (a and not b) or (not a and b): return False
    a_current_nodes: list = [a]
    b_current_nodes: list = [b]
    a_next_nodes: list = []
    b_next_nodes: list = []
    while a_current_nodes or b_current_nodes:
        for x, y in zip(a_current_nodes, b_current_nodes):
            if x and y:
                if x.val != y.val: return False
                if not (bool(x.right) == bool(y.right) and bool(x.left) == bool(y.left)): return False
                if x.left: a_next_nodes.append(x.left)
                if x.right: a_next_nodes.append(x.right)
                if y.left: b_next_nodes.append(y.left)
                if y.right: b_next_nodes.append(y.right)
        if (x and not y) or (not x and y): return False
        if len(a_next_nodes) != len(b_next_nodes): return False
        a_current_nodes, b_current_nodes = a_next_nodes, b_next_nodes
        a_next_nodes, b_next_nodes = [], []
    return True

# 2220. Minimum Bit Flips to Convert Number
# A bit flip of a number x is choosing a bit in the binary representation of x and flipping it from either 0 to 1 or 1 to 0.
#
# For example, for x = 7, the binary representation is 111 and we may choose any bit (including any leading zeros not shown) and flip it. We can flip the first bit from the right to get 110, flip the second bit from the right to get 101, flip the fifth bit from the right (a leading zero) to get 10111, etc.
# Given two integers start and goal, return the minimum number of bit flips to convert start to goal.
#
#
#
# Example 1:
#
# Input: start = 10, goal = 7
# Output: 3
# Explanation: The binary representation of 10 and 7 are 1010 and 0111 respectively. We can convert 10 to 7 in 3 steps:
# - Flip the first bit from the right: 1010 -> 1011.
# - Flip the third bit from the right: 1011 -> 1111.
# - Flip the fourth bit from the right: 1111 -> 0111.
# It can be shown we cannot convert 10 to 7 in less than 3 steps. Hence, we return 3.
# Example 2:
#
# Input: start = 3, goal = 4
# Output: 3
# Explanation: The binary representation of 3 and 4 are 011 and 100 respectively. We can convert 3 to 4 in 3 steps:
# - Flip the first bit from the right: 011 -> 010.
# - Flip the second bit from the right: 010 -> 000.
# - Flip the third bit from the right: 000 -> 100.
# It can be shown we cannot convert 3 to 4 in less than 3 steps. Hence, we return 3.
#
#
# Constraints:
#
# 0 <= start, goal <= 109
class Solution:
    def minBitFlips(self, start: int, goal: int) -> int:
        return bin(start ^ goal).count('1')

# Hofstadter Q
# Hofstadter sequences are a family of related integer sequences, among which the first ones were described by an American professor Douglas Hofstadter in his book Gödel, Escher, Bach.
#
# Task
# Today we will be implementing the rather chaotic recursive sequence of integers called Hofstadter Q.
#
# The Hofstadter Q is defined as:
#
#
# As the author states in the aforementioned book:
#
#
# It is reminiscent of the Fibonacci definition in that each new value is a sum of two previous values-but not of the immediately previous two values. Instead, the two immediately previous values tell how far to count back to obtain the numbers to be added to make the new value.
# The function produces the starting sequence:
# 1, 1, 2, 3, 3, 4, 5, 5, 6 . . .
# Test info: 100 random tests, n is always positive
#
# Good luck!
# RECURSIONALGORITHMS
def hofstadter_q(n):
    if n < 3:
        return 1
    q_values = [1, 1] + [0] * (n - 2)
    for i in range(2, n):
        q_values[i] = q_values[i - q_values[i - 1]] + q_values[i - q_values[i - 2]]
    return q_values[n - 1]

# 938. Range Sum of BST
# Given the root node of a binary search tree and two integers low and high, return the sum of values of all nodes with a value in the inclusive range [low, high].
#
#
#
# Example 1:
#
#
# Input: root = [10,5,15,3,7,null,18], low = 7, high = 15
# Output: 32
# Explanation: Nodes 7, 10, and 15 are in the range [7, 15]. 7 + 10 + 15 = 32.
# Example 2:
#
#
# Input: root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10
# Output: 23
# Explanation: Nodes 6, 7, and 10 are in the range [6, 10]. 6 + 7 + 10 = 23.
#
#
# Constraints:
#
# The number of nodes in the tree is in the range [1, 2 * 104].
# 1 <= Node.val <= 105
# 1 <= low <= high <= 105
# All Node.val are unique.
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:
        total: int = 0
        current_nodes: list = [root]
        next_nodes: list = list()
        while current_nodes:
            for node in current_nodes:
                if low <= node.val <= high: total += node.val
                if node.right: next_nodes.append(node.right)
                if node.left: next_nodes.append(node.left)
            current_nodes = next_nodes
            next_nodes = []
        return total

# 71A
# A. Слишком длинные слова
# ограничение по времени на тест1 second
# ограничение по памяти на тест256 megabytes
# вводстандартный ввод
# выводстандартный вывод
# Иногда некоторые слова вроде «localization» или «internationalization» настолько длинны, что их весьма утомительно писать много раз в каком либо тексте.
#
# Будем считать слово слишком длинным, если его длина строго больше 10 символов. Все слишком длинные слова можно заменить специальной аббревиатурой.
#
# Эта аббревиатура строится следующим образом: записывается первая и последняя буква слова, а между ними — количество букв между первой и последней буквой (в десятичной системе счисления и без ведущих нулей).
#
# Таком образом, «localization» запишется как «l10n», а «internationalization» как «i18n».
#
# Вам предлагается автоматизировать процесс замены слов на аббревиатуры. При этом все слишком длинные слова должны быть заменены аббревиатурой, а слова, не являющиеся слишком длинными, должны остаться без изменений.
#
# Входные данные
# В первой строке содержится целое число n (1 ≤ n ≤ 100). В каждой из последующих n строк содержится по одному слову. Все слова состоят из малых латинских букв и имеют длину от 1 до 100 символов.
#
# Выходные данные
# Выведите n строк. В i строке должен находиться результат замены i-го слова из входных данных.
#
# Примеры
# входные данныеСкопировать
# 4
# word
# localization
# internationalization
# pneumonoultramicroscopicsilicovolcanoconiosis
# выходные данныеСкопировать
# word
# l10n
# i18n
# p43s
import sys
n: int = int(sys.stdin.readline().rstrip())
initial: list = [0] * n
for idx in range(n):
    initial[idx] = sys.stdin.readline().rstrip()
for word in range(n):
    x: str = initial[word]
    if len(x) > 10:
        initial[word] = x[0] + str(len(x) - 2) + x[-1]
print('\n'.join(initial))

# A. Watermelon
# A. Watermelon
# time limit per test1 second
# memory limit per test64 megabytes
# inputstandard input
# outputstandard output
# One hot summer day Pete and his friend Billy decided to buy a watermelon. They chose the biggest and the ripest one, in their opinion. After that the watermelon was weighed, and the scales showed w kilos. They rushed home, dying of thirst, and decided to divide the berry, however they faced a hard problem.
#
# Pete and Billy are great fans of even numbers, that's why they want to divide the watermelon in such a way that each of the two parts weighs even number of kilos, at the same time it is not obligatory that the parts are equal. The boys are extremely tired and want to start their meal as soon as possible, that's why you should help them and find out, if they can divide the watermelon in the way they want. For sure, each of them should get a part of positive weight.
#
# Input
# The first (and the only) input line contains integer number w (1 ≤ w ≤ 100) — the weight of the watermelon bought by the boys.
#
# Output
# Print YES, if the boys can divide the watermelon into two parts, each of them weighing even number of kilos; and NO in the opposite case.
#
# Examples
# inputCopy
# 8
# outputCopy
# YES
# Note
# For example, the boys can divide the watermelon into two parts of 2 and 6 kilos respectively (another variant — two parts of 4 and 4 kilos).
x = int(input())
print(['NO', 'YES'][x % 2 == 0 and x > 2])

# Binary Tree Traversal
# Given the root node of a binary tree (but not necessarily a binary search tree,) write three functions that will print the tree in pre-order, in-order, and post-order.
#
# A Node has the following properties:
#
# data    # A number or a string
# left    # A Node, which is None if there is no left child.
# right   # A Node, which is None if there is no right child.
# Pre-order means that we
# 1.) Visit the root.
# 2.) Traverse the left subtree (left node.)
# 3.) Traverse the right subtree (right node.)
#
# In-order means that we
# 1.) Traverse the left subtree (left node.)
# 2.) Visit the root.
# 3.) Traverse the right subtree (right node.)
#
# Post-order means that we
# 1.) Traverse the left subtree (left node.)
# 2.) Traverse the right subtree (right node.)
# 3.) Visit the root.
#
# Let's say we have three nodes.
#
# a = Node("A")
# b = Node("B")
# c = Node("C")
#
# a.left = b
# a.right = c
# Then, preOrder(a) should return ["A", "B", C"]
# inOrder(a) should return ["B", "A", "C"]
# postOrder(a) should return ["B", "C", A"]
#
# What would happen if we did this?
#
# d = Node("D")
# c.left = d
# preOrder(a) should return ["A", "B", "C", "D"]
# inOrder(a) should return ["B", "A", "D", "C"]
# postOrder(a) should return ["B", "D", "C", "A"]
#
# BINARY TREESTREESRECURSIONDATA STRUCTURESALGORITHMS
# Pre-order traversal
def pre_order(node):
    output: list = []
    if not node: return output
    output.append(node.data)
    if node.left:
        output += pre_order(node.left)
    if node.right:
        output += pre_order(node.right)
    return output

# In-order traversal
def in_order(node):
    output: list = []
    if not node: return output
    if node.left:
        output += in_order(node.left)
    output.append(node.data)
    if node.right:
        output += in_order(node.right)
    return output

# Post-order traversal
def post_order(node):
    output: list = []
    if not node: return output
    if node.left:
        output += post_order(node.left)
    if node.right:
        output += post_order(node.right)
    output.append(node.data)
    return output

# 1844. Replace All Digits with Characters
# You are given a 0-indexed string s that has lowercase English letters in its even indices and digits in its odd indices.
#
# There is a function shift(c, x), where c is a character and x is a digit, that returns the xth character after c.
#
# For example, shift('a', 5) = 'f' and shift('x', 0) = 'x'.
# For every odd index i, you want to replace the digit s[i] with shift(s[i-1], s[i]).
#
# Return s after replacing all digits. It is guaranteed that shift(s[i-1], s[i]) will never exceed 'z'.
#
#
#
# Example 1:
#
# Input: s = "a1c1e1"
# Output: "abcdef"
# Explanation: The digits are replaced as follows:
# - s[1] -> shift('a',1) = 'b'
# - s[3] -> shift('c',1) = 'd'
# - s[5] -> shift('e',1) = 'f'
# Example 2:
#
# Input: s = "a1b2c3d4e"
# Output: "abbdcfdhe"
# Explanation: The digits are replaced as follows:
# - s[1] -> shift('a',1) = 'b'
# - s[3] -> shift('b',2) = 'd'
# - s[5] -> shift('c',3) = 'f'
# - s[7] -> shift('d',4) = 'h'
#
#
# Constraints:
#
# 1 <= s.length <= 100
# s consists only of lowercase English letters and digits.
# shift(s[i-1], s[i]) <= 'z' for all odd indices i.
# Solution 1 - Using builtin function
# Complexity
# Time complexity: O(N)
# Space complexity: O(N)
# Code
class Solution:
    def replaceDigits(self, s: str) -> str:
        letters: list[str] = list(s)
        for i in range(len(letters)):
            if i % 2 != 0:
                letters[i] = chr(ord(letters[i - 1]) + int(letters[i]))
        return ''.join(letters)
# Solution 2 - Implementing shift function
# Complexity
# Time complexity: O(N)
# Space complexity: O(N)
# Code
from string import ascii_lowercase
class Solution:
    def shift(self, char, step):
        return ascii_lowercase[ascii_lowercase.index(char) + step]
    def replaceDigits(self, s: str) -> str:
        letters: list[str] = list(s)
        for i in range(len(letters)):
            if i % 2 != 0:
                letters[i] = self.shift(letters[i - 1], int(letters[i]))
        return ''.join(letters)

# A. Team
# A. Team
# time limit per test2 seconds
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# One day three best friends Petya, Vasya and Tonya decided to form a team and take part in programming contests. Participants are usually offered several problems during programming contests. Long before the start the friends decided that they will implement a problem if at least two of them are sure about the solution. Otherwise, the friends won't write the problem's solution.
#
# This contest offers n problems to the participants. For each problem we know, which friend is sure about the solution. Help the friends find the number of problems for which they will write a solution.
#
# Input
# The first input line contains a single integer n (1 ≤ n ≤ 1000) — the number of problems in the contest. Then n lines contain three integers each, each integer is either 0 or 1. If the first number in the line equals 1, then Petya is sure about the problem's solution, otherwise he isn't sure. The second number shows Vasya's view on the solution, the third number shows Tonya's view. The numbers on the lines are separated by spaces.
#
# Output
# Print a single integer — the number of problems the friends will implement on the contest.
#
# Examples
# inputCopy
# 3
# 1 1 0
# 1 1 1
# 1 0 0
# outputCopy
# 2
# inputCopy
# 2
# 1 0 0
# 0 1 1
# outputCopy
# 1
# Note
# In the first sample Petya and Vasya are sure that they know how to solve the first problem and all three of them know how to solve the second problem. That means that they will write solutions for these problems. Only Petya is sure about the solution for the third problem, but that isn't enough, so the friends won't take it.
#
# In the second sample the friends will only implement the second problem, as Vasya and Tonya are sure about the solution.
import sys
n: int = int(sys.stdin.readline().rstrip())
initial: list = [0] * n
for idx in range(n):
    initial[idx] = sum(map(int, sys.stdin.readline().rstrip().split()))
answer: int = sum(1 for item in initial if item > 1)
sys.stdout.write(str(answer))

# Find Max Tree Node
# You are given a binary tree. Implement the method findMax which returns the maximal node value in the tree.
#
# For example, maximum in the following Tree is 11.
#
#               7
#             /   \
#            /     \
#           5       2
#            \       \
#            6        11
#            /\      /
#           1  9   4
# Note:
#
# Tree node values any integer value.
# Tree can unbalanced and unsorted.
# The root argument is never an empty tree.
# You are given a tree node class as follows:
#
# class TreeNode:
#     def __init__(self, value, left = None, right = None):
#         self.left = left
#         self.right = right
#         self.value = value
# ALGORITHMSRECURSIONBINARY SEARCH TREESBINARY
def find_max(root):
    ans: int = root.value
    if root.left:
        ans = max(ans, find_max(root.left))
    if root.right:
        ans = max(ans, find_max(root.right))
    return ans

# 1967. Number of Strings That Appear as Substrings in Word
# Given an array of strings patterns and a string word, return the number of strings in patterns that exist as a substring in word.
#
# A substring is a contiguous sequence of characters within a string.
#
#
#
# Example 1:
#
# Input: patterns = ["a","abc","bc","d"], word = "abc"
# Output: 3
# Explanation:
# - "a" appears as a substring in "abc".
# - "abc" appears as a substring in "abc".
# - "bc" appears as a substring in "abc".
# - "d" does not appear as a substring in "abc".
# 3 of the strings in patterns appear as a substring in word.
# Example 2:
#
# Input: patterns = ["a","b","c"], word = "aaaaabbbbb"
# Output: 2
# Explanation:
# - "a" appears as a substring in "aaaaabbbbb".
# - "b" appears as a substring in "aaaaabbbbb".
# - "c" does not appear as a substring in "aaaaabbbbb".
# 2 of the strings in patterns appear as a substring in word.
# Example 3:
#
# Input: patterns = ["a","a","a"], word = "ab"
# Output: 3
# Explanation: Each of the patterns appears as a substring in word "ab".
#
#
# Constraints:
#
# 1 <= patterns.length <= 100
# 1 <= patterns[i].length <= 100
# 1 <= word.length <= 100
# patterns[i] and word consist of lowercase English letters.
# Complexity
# Time complexity: O(KN) where K is the length of patterns and N is lenght of word
#
# Space complexity: O(1)
#
# Code
class Solution:
    def numOfStrings(self, patterns: List[str], word: str) -> int:
        return sum(item in word for item in patterns)

# A. Theatre Square
# A. Theatre Square
# time limit per test1 second
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# Theatre Square in the capital city of Berland has a rectangular shape with the size n × m meters. On the occasion of the city's anniversary, a decision was taken to pave the Square with square granite flagstones. Each flagstone is of the size a × a.
#
# What is the least number of flagstones needed to pave the Square? It's allowed to cover the surface larger than the Theatre Square, but the Square has to be covered. It's not allowed to break the flagstones. The sides of flagstones should be parallel to the sides of the Square.
#
# Input
# The input contains three positive integer numbers in the first line: n,  m and a (1 ≤  n, m, a ≤ 109).
#
# Output
# Write the needed number of flagstones.
#
# Examples
# inputCopy
# 6 6 4
# outputCopy
# 4
import sys
n, m, a = map(int, sys.stdin.readline().rstrip().split())
m_box: int = (n + a - 1) // a
n_box: int = (m + a - 1) // a
sys.stdout.write(str(n_box * m_box))

# Binary Tree Search (not BST)
# Given a number and a binary tree ( not a Binary Search Tree! ):
#
# return True/true if the given number is in the tree
# return False/false if it isn't
# BINARY TREESFUNDAMENTALS
from __future__ import annotations
from typing import Optional


class Node:
    def __init__(self, value: int, left: Optional[Node] = None, right: Optional[Node] = None):
        self.value = value
        self.left = left
        self.right = right


def search(n: int, root: Optional[Node]) -> bool:
    """ Determines if a value is in a binary tree (NOT bst) """
    return root.value == n or search(n, root.left) or search(n, root.right) if root else False

# 2130. Maximum Twin Sum of a Linked List
# In a linked list of size n, where n is even, the ith node (0-indexed) of the linked list is known as the twin of the (n-1-i)th node, if 0 <= i <= (n / 2) - 1.
#
# For example, if n = 4, then node 0 is the twin of node 3, and node 1 is the twin of node 2. These are the only nodes with twins for n = 4.
# The twin sum is defined as the sum of a node and its twin.
#
# Given the head of a linked list with even length, return the maximum twin sum of the linked list.
#
#
#
# Example 1:
#
#
# Input: head = [5,4,2,1]
# Output: 6
# Explanation:
# Nodes 0 and 1 are the twins of nodes 3 and 2, respectively. All have twin sum = 6.
# There are no other nodes with twins in the linked list.
# Thus, the maximum twin sum of the linked list is 6.
# Example 2:
#
#
# Input: head = [4,2,2,3]
# Output: 7
# Explanation:
# The nodes with twins present in this linked list are:
# - Node 0 is the twin of node 3 having a twin sum of 4 + 3 = 7.
# - Node 1 is the twin of node 2 having a twin sum of 2 + 2 = 4.
# Thus, the maximum twin sum of the linked list is max(7, 4) = 7.
# Example 3:
#
#
# Input: head = [1,100000]
# Output: 100001
# Explanation:
# There is only one node with a twin in the linked list having twin sum of 1 + 100000 = 100001.
#
#
# Constraints:
#
# The number of nodes in the list is an even integer in the range [2, 105].
# 1 <= Node.val <= 105
# Solution 1 - Tortoise and Hare
# Complexity
# Time complexity: O(N)
# Space complexity: O(1)
# Code
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def pairSum(self, head: Optional[ListNode]) -> int:
        ans: int = float('-inf')
        slow, fast = head, head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
        prev = None
        while slow:
            nxt = slow.next
            slow.next = prev
            prev = slow
            slow = nxt
        left, right = head, prev
        while right:
            ans = max(ans, left.val + right.val)
            left, right = left.next, right.next
        return ans

# Solution 2 - List storing aka Stack
# Complexity
# Time complexity: O(N)
# Space complexity: O(N)
# Code
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def pairSum(self, head: Optional[ListNode]) -> int:
        nodes: list = list()
        n: int = 0
        tmp = head
        while tmp:
            nodes.append(tmp.val)
            tmp, n = tmp.next, n + 1
        ans: int = float('-inf')
        for i in range(n):
            ans = max(ans, nodes[i] + nodes[n - i - 1])
        return ans

# A. Bit++
# A. Bit++
# time limit per test1 second
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# The classic programming language of Bitland is Bit++. This language is so peculiar and complicated.
#
# The language is that peculiar as it has exactly one variable, called x. Also, there are two operations:
#
# Operation ++ increases the value of variable x by 1.
# Operation -- decreases the value of variable x by 1.
# A statement in language Bit++ is a sequence, consisting of exactly one operation and one variable x. The statement is written without spaces, that is, it can only contain characters "+", "-", "X". Executing a statement means applying the operation it contains.
#
# A programme in Bit++ is a sequence of statements, each of them needs to be executed. Executing a programme means executing all the statements it contains.
#
# You're given a programme in language Bit++. The initial value of x is 0. Execute the programme and find its final value (the value of the variable when this programme is executed).
#
# Input
# The first line contains a single integer n (1 ≤ n ≤ 150) — the number of statements in the programme.
#
# Next n lines contain a statement each. Each statement contains exactly one operation (++ or --) and exactly one variable x (denoted as letter «X»). Thus, there are no empty statements. The operation and the variable can be written in any order.
#
# Output
# Print a single integer — the final value of x.
#
# Examples
# inputCopy
# 1
# ++X
# outputCopy
# 1
# inputCopy
# 2
# X++
# --X
# outputCopy
# 0

import sys
n: int = int(sys.stdin.readline().rstrip())
ans: int = 0
for _ in range(n):
    x: str = sys.stdin.readline().rstrip()
    if x in {'X++', '++X'}: ans += 1
    else: ans -= 1
sys.stdout.write(str(ans))

# Text align justify
# Your task in this Kata is to emulate text justification in monospace font. You will be given a single-lined text and the expected justification width. The longest word will never be greater than this width.
# 
# Here are the rules:
# 
# Use spaces to fill in the gaps between words.
# Each line should contain as many words as possible.
# Use '\n' to separate lines.
# Last line should not terminate in '\n'
# '\n' is not included in the length of a line.
# Gaps between words can't differ by more than one space.
# Lines should end with a word not a space.
# Large gaps go first, then smaller ones ('Lorem--ipsum--dolor--sit-amet,' (2, 2, 2, 1 spaces)).
# Last line should not be justified, use only one space between words.
# Lines with one word do not need gaps ('somelongword\n').
# Example with width=30:
# 
# Lorem  ipsum  dolor  sit amet,
# consectetur  adipiscing  elit.
# Vestibulum    sagittis   dolor
# mauris,  at  elementum  ligula
# tempor  eget.  In quis rhoncus
# nunc,  at  aliquet orci. Fusce
# at   dolor   sit   amet  felis
# suscipit   tristique.   Nam  a
# imperdiet   tellus.  Nulla  eu
# vestibulum    urna.    Vivamus
# tincidunt  suscipit  enim, nec
# ultrices   nisi  volutpat  ac.
# Maecenas   sit   amet  lacinia
# arcu,  non dictum justo. Donec
# sed  quam  vel  risus faucibus
# euismod.  Suspendisse  rhoncus
# rhoncus  felis  at  fermentum.
# Donec lorem magna, ultricies a
# nunc    sit    amet,   blandit
# fringilla  nunc. In vestibulum
# velit    ac    felis   rhoncus
# pellentesque. Mauris at tellus
# enim.  Aliquam eleifend tempus
# dapibus. Pellentesque commodo,
# nisi    sit   amet   hendrerit
# fringilla,   ante  odio  porta
# lacus,   ut   elementum  justo
# nulla et dolor.
# Also you can always take a look at how justification works in your text editor or directly in HTML (css: text-align: justify).
# 
# Have fun :)
# 
# STRINGSALGORITHMS
def calc_whitespaces(count_spaces: int, needed_spaces: int) -> list[int]:
    if needed_spaces == 0: return count_spaces
    if count_spaces % needed_spaces == 0:
        return [count_spaces // needed_spaces for _ in range(needed_spaces)]
    space_size: int = 1
    while needed_spaces * space_size < count_spaces:
        space_size += 1
    output: list[int] = [space_size for _ in range(needed_spaces)]
    for idx in range(-1, -(space_size * needed_spaces - count_spaces) - 1, -1):
        output[idx] -= 1
    return output


def create_sentence(whitespaces: list[int], words: list[str]) -> str:
    if len(words) == 1: return words[0]
    output: list[str] = list()
    for _ in range(len(whitespaces)):
        if not output:
            output.append(words.pop(0))
        output.append(' ' * whitespaces.pop(0))
        output.append(words.pop(0))
    return ''.join(output)


def justify(text, width):
    if not text: return ''
    output: list[str] = list()
    top: list[str] = list()
    top_len: int = 0
    space_len: int = 0
    for word in text.split(' '):
        if top_len + len(word) + (space_len if (top and len(top) < 1) else space_len + 1) <= width:
            top_len += len(word)
            top.append(word)
            space_len = len(top) - 1
        else:
            space_len += width - (top_len + space_len)
            whitespaces: list[int] = calc_whitespaces(space_len, len(top) - 1)
            sentence: str = create_sentence(whitespaces, top)
            output.append(sentence)

            space_len = 0
            top_len = len(word)
            top = [word]

    whitespaces: list[int] = calc_whitespaces(space_len, len(top) - 1)
    sentence: str = create_sentence(whitespaces, top)
    output.append(sentence)
    return '\n'.join(output)

# 535. Encode and Decode TinyURL
# Note: This is a companion problem to the System Design problem: Design TinyURL.
# TinyURL is a URL shortening service where you enter a URL such as https://leetcode.com/problems/design-tinyurl and it returns a short URL such as http://tinyurl.com/4e9iAk. Design a class to encode a URL and decode a tiny URL.
#
# There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.
#
# Implement the Solution class:
#
# Solution() Initializes the object of the system.
# String encode(String longUrl) Returns a tiny URL for the given longUrl.
# String decode(String shortUrl) Returns the original long URL for the given shortUrl. It is guaranteed that the given shortUrl was encoded by the same object.
#
#
# Example 1:
#
# Input: url = "https://leetcode.com/problems/design-tinyurl"
# Output: "https://leetcode.com/problems/design-tinyurl"
#
# Explanation:
# Solution obj = new Solution();
# string tiny = obj.encode(url); // returns the encoded tiny url.
# string ans = obj.decode(tiny); // returns the original url after decoding it.
#
#
# Constraints:
#
# 1 <= url.length <= 104
# url is guranteed to be a valid URL.
class Codec:
    def __init__(self):
        self.storage_encoded: dict[str, str] = dict()
        self.storage_decoded: dict[str, str] = dict()

    def encode(self, longUrl: str) -> str:
        """Encodes a URL to a shortened URL.
        """
        if longUrl in self.storage_encoded:
            return self.storage_encoded.get(longURL)
        decoded_url: str = 'https://' + str(abs(hash(longUrl)))
        while decoded_url in self.storage_decoded:
            decoded_url = 'https://' + str(abs(hash(longUrl)))
        self.storage_encoded[longUrl] = decoded_url
        self.storage_decoded[decoded_url] = longUrl
        return decoded_url

    def decode(self, shortUrl: str) -> str:
        """Decodes a shortened URL to its original URL.
        """
        return self.storage_decoded.get(shortUrl)

# Your Codec object will be instantiated and called as such:
# codec = Codec()
# codec.decode(codec.encode(url))

# A. Next Round
# A. Next Round
# time limit per test3 seconds
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# "Contestant who earns a score equal to or greater than the k-th place finisher's score will advance to the next round, as long as the contestant earns a positive score..." — an excerpt from contest rules.
#
# A total of n participants took part in the contest (n ≥ k), and you already know their scores. Calculate how many participants will advance to the next round.
#
# Input
# The first line of the input contains two integers n and k (1 ≤ k ≤ n ≤ 50) separated by a single space.
#
# The second line contains n space-separated integers a1, a2, ..., an (0 ≤ ai ≤ 100), where ai is the score earned by the participant who got the i-th place. The given sequence is non-increasing (that is, for all i from 1 to n - 1 the following condition is fulfilled: ai ≥ ai + 1).
#
# Output
# Output the number of participants who advance to the next round.
#
# Examples
# inputCopy
# 8 5
# 10 9 8 7 7 7 5 5
# outputCopy
# 6
# inputCopy
# 4 2
# 0 0 0 0
# outputCopy
# 0
# Note
# In the first example the participant on the 5th place earned 7 points. As the participant on the 6th place also earned 7 points, there are 6 advancers.
#
# In the second example nobody got a positive score.
import sys
n, k = map(int, sys.stdin.readline().rstrip().split())
answer: int = 0
partipicants: list = list(map(int, sys.stdin.readline().rstrip().split()))
if not partipicants: sys.stdout.write(str(0))
else:
    score: int = partipicants[k - 1]
    for user in partipicants:
        if user > 0 and user >= score:
            answer += 1
        else:
            break
    sys.stdout.write(str(answer))

# Four Letter Words ~ Mutations
# Our Setup
# Alice and Bob work in an office. When the workload is light and the boss isn't looking, they play simple word games for fun. This is one of those days!
#
# Today's Game
# Alice and Bob are playing what they like to call Mutations, where they take turns trying to "think up" a new four-letter word (made up of four unique letters) that is identical to the prior word except for only one letter. They just keep on going until their memories fail out.
#
# Their Words
# Alice and Bob have memories of the same size, each able to recall 10 to 2000 different four-letter words. Memory words and initial game word are randomly taken from the same list of 4000 (unique, four-letter, lowercased) words, any of which may appear in both memories.
#
# The expression to "think up" a new word means that for their turn, the player must submit as their response word the first valid, unused word that appears in their memory (by lowest array index), as their memories are ordered from the most "memorable" words to the least.
#
# The Rules
# a valid response word must contain four unique letters
# 1 letter is replaced while the other 3 stay in position
# it must be the lowest indexed valid word in that memory
# this word cannot have already been used during the game
# the final player to provide a valid word will win the game
# if 1st player fails 1st turn, 2nd can win with one word
# when both players fail the initial word, there is no winner
# Your Task
# To determine the winner!
#
# Some Examples
# alice = plat,rend,bear,soar,mare,pare,flap,neat,clan,pore
#
# bob   = boar,clap,farm,lend,near,peat,pure,more,plan,soap
#
# In the case of word = "send" and first = 0:
# Alice responds to send with rend
# Bob responds to rend with lend
# Alice has no valid response to lend
# Bob wins the game.
# In the case of word = "flip" and first = 1:
# Bob has no valid response to flip
# Alice responds to flip with flap
# Alice wins the game.
# In the case of word = "calm" and first = 1:
# Bob has no valid response to calm
# Alice has no valid response to calm
# Neither wins the game.
# In the case of word = "more" and first = 1:
# Bob has no valid response to more **
# Alice responds to more with mare
# Alice wins the game.
# In the case of word = "maze" and first = 0:
# Alice responds to maze with mare
# Bob responds to mare with more **
# Alice responds to more with pore
# Bob responds to pore with pure
# Alice responds to pure with pare
# Bob has no valid response to pare
# Alice wins the game.
# ** Note that in these last two cases, Bob cannot use mere because it has two e's.
#
# Input
# alice  #  list of words in Alice's memory (10 <= n <= 2000)
# bob    #  list of words in Bob's memory (same size as alice)
# word   #  string of the initial challenge word of the game
# first  #  integer of whom begins: 0 for Alice, 1 for Bob
# Output
# return  0  #  if Alice wins
# return  1  #  if Bob wins
# return -1  #  if both fail
# Enjoy!
# You may consider one of the following kata to solve next:
#
# Playing With Toy Blocks ~ Can you build a 4x4 square?
# Crossword Puzzle! (2x2)
# Interlocking Binary Pairs
# Is Sator Square?
# STRINGSARRAYSGAMESPARSINGALGORITHMS
def delete_unsupported(arr: list[str], target: str) -> None:
    for i in range(len(arr) - 1, -1, -1):
        if len(set(arr[i])) != 4 or arr[i] == target: arr.pop(i)


def find_word(words: list[str], target: str) -> tuple[bool, str]:
    word: str = ''
    for i in range(len(words)):
        if sum(x != y for x, y in zip(words[i], target)) <= 1:
            word = words[i]
            words.pop(i)
            return True, word
    return False, word


def mutations(alice, bob, word, first):
    alice_, bob_ = alice[::], bob[::]
    delete_unsupported(alice_, word)
    delete_unsupported(bob_, word)
    users: dict[int, str] = {0: 'Alice', 1: 'Bob'}
    user_words: dict[str, list[str]] = {'Alice': alice_, 'Bob': bob_}
    user: int = first
    idx: int = 0
    stack: list[tuple[int, bool]] = list()
    prev_winner: int = 0
    while True:
        step = find_word(user_words.get(users[user]), word)
        stack.append((user, step[0]))
        if step[0]:
            prev_winner = user
            delete_unsupported(alice_, step[1])
            delete_unsupported(bob_, step[1])
        word = step[1] if step[0] else word
        user = int(not bool(user))

        step = find_word(user_words.get(users[user]), word)
        stack.append((user, step[0]))
        if step[0]:
            prev_winner = user
            delete_unsupported(alice_, step[1])
            delete_unsupported(bob_, step[1])

        word = step[1] if step[0] else word

        if stack[0][1] == stack[1][1] == False and idx == 0:
            return -1
        elif stack[0][1] == stack[1][1] == False:
            return prev_winner
        elif stack[0][1] == True and stack[1][1] == False:
            return stack[0][0]
        elif stack[0][1] == False and stack[1][1] == True:
            return stack[1][0]
        user = int(not bool(user))
        stack = []
        idx += 1
    return -1

# 3158. Find the XOR of Numbers Which Appear Twice
# You are given an array nums, where each number in the array appears either once or twice.
#
# Return the bitwise XOR of all the numbers that appear twice in the array, or 0 if no number appears twice.
#
#
#
# Example 1:
#
# Input: nums = [1,2,1,3]
#
# Output: 1
#
# Explanation:
#
# The only number that appears twice in nums is 1.
#
# Example 2:
#
# Input: nums = [1,2,3]
#
# Output: 0
#
# Explanation:
#
# No number appears twice in nums.
#
# Example 3:
#
# Input: nums = [1,2,2,1]
#
# Output: 3
#
# Explanation:
#
# Numbers 1 and 2 appeared twice. 1 XOR 2 == 3.
#
#
#
# Constraints:
#
# 1 <= nums.length <= 50
# 1 <= nums[i] <= 50
# Each number in nums appears either once or twice.
class Solution:
    def duplicateNumbersXOR(self, nums: List[int]) -> int:
        duplicate: list[int] = list()
        seen: set[int] = set()
        for i in nums:
            if i in seen: duplicate.append(i)
            seen.add(i)
        ans: int = 0
        for i in duplicate:
            ans ^= i
        return ans

# 3159. Find Occurrences of an Element in an Array
# You are given an integer array nums, an integer array queries, and an integer x.
#
# For each queries[i], you need to find the index of the queries[i]th occurrence of x in the nums array. If there are fewer than queries[i] occurrences of x, the answer should be -1 for that query.
#
# Return an integer array answer containing the answers to all queries.
#
#
#
# Example 1:
#
# Input: nums = [1,3,1,7], queries = [1,3,2,4], x = 1
#
# Output: [0,-1,2,-1]
#
# Explanation:
#
# For the 1st query, the first occurrence of 1 is at index 0.
# For the 2nd query, there are only two occurrences of 1 in nums, so the answer is -1.
# For the 3rd query, the second occurrence of 1 is at index 2.
# For the 4th query, there are only two occurrences of 1 in nums, so the answer is -1.
# Example 2:
#
# Input: nums = [1,2,3], queries = [10], x = 5
#
# Output: [-1]
#
# Explanation:
#
# For the 1st query, 5 doesn't exist in nums, so the answer is -1.
#
#
# Constraints:
#
# 1 <= nums.length, queries.length <= 105
# 1 <= queries[i] <= 105
# 1 <= nums[i], x <= 104
class Solution:
    def occurrencesOfElement(self, nums: List[int], queries: List[int], x: int) -> List[int]:
        occurences: list[int] = [idx for idx in range(len(nums)) if nums[idx] == x]
        output: list[int] = list()
        n: int = len(occurences)
        for i in queries:
            if n <= i - 1:
                output.append(-1)
            else:
                output.append(occurences[i - 1])
        return output

# 3160. Find the Number of Distinct Colors Among the Balls
# You are given an integer limit and a 2D array queries of size n x 2.
#
# There are limit + 1 balls with distinct labels in the range [0, limit]. Initially, all balls are uncolored. For every query in queries that is of the form [x, y], you mark ball x with the color y. After each query, you need to find the number of distinct colors among the balls.
#
# Return an array result of length n, where result[i] denotes the number of distinct colors after ith query.
#
# Note that when answering a query, lack of a color will not be considered as a color.
#
#
#
# Example 1:
#
# Input: limit = 4, queries = [[1,4],[2,5],[1,3],[3,4]]
#
# Output: [1,2,2,3]
#
# Explanation:
#
#
#
# After query 0, ball 1 has color 4.
# After query 1, ball 1 has color 4, and ball 2 has color 5.
# After query 2, ball 1 has color 3, and ball 2 has color 5.
# After query 3, ball 1 has color 3, ball 2 has color 5, and ball 3 has color 4.
# Example 2:
#
# Input: limit = 4, queries = [[0,1],[1,2],[2,2],[3,4],[4,5]]
#
# Output: [1,2,2,3,4]
#
# Explanation:
#
#
#
# After query 0, ball 0 has color 1.
# After query 1, ball 0 has color 1, and ball 1 has color 2.
# After query 2, ball 0 has color 1, and balls 1 and 2 have color 2.
# After query 3, ball 0 has color 1, balls 1 and 2 have color 2, and ball 3 has color 4.
# After query 4, ball 0 has color 1, balls 1 and 2 have color 2, ball 3 has color 4, and ball 4 has color 5.
#
#
# Constraints:
#
# 1 <= limit <= 109
# 1 <= n == queries.length <= 105
# queries[i].length == 2
# 0 <= queries[i][0] <= limit
# 1 <= queries[i][1] <= 109
class Solution:
    def queryResults(self, limit: int, queries: List[List[int]]) -> List[int]:
        balls: dict[int, int] = dict() # HashBalls from description
        colors: dict[int, int] = dict() # HashColors from description
        output: list[int] = list() # our list of answers
        count: int = 0 # total count of unique colors
        for i in queries: # iterate from queries and get each query
            x, y = i # x - representing ball, y - representing color
            if x in balls: # if x already exist(first condition)
                if colors[balls[x]] == 1: count -= 1 # if existing ball have unique color
                colors[balls[x]] = max(0, colors[balls[x]] - 1) # delete old color from HashColors
                balls[x] = y # Set new color to existing ball
                colors[y] = colors.get(y, 0) + 1 # increment frequences of given color
                if colors[y] == 1: count += 1 # if value is 1(it means that we got uniuqe color)
            else: # If we got new ball(second condition)
                balls[x] = y # Set new ball in HashBalls
                colors[y] = colors.get(y, 0) + 1 # Increment frequences of given color
                if colors[y] == 1: count += 1 # if value is 1(it means that we got unique color) so just increment count
            output.append(count) # append to the answer list given count of unique colors
        return output

# 3162. Find the Number of Good Pairs I
# You are given 2 integer arrays nums1 and nums2 of lengths n and m respectively. You are also given a positive integer k.
#
# A pair (i, j) is called good if nums1[i] is divisible by nums2[j] * k (0 <= i <= n - 1, 0 <= j <= m - 1).
#
# Return the total number of good pairs.
#
#
#
# Example 1:
#
# Input: nums1 = [1,3,4], nums2 = [1,3,4], k = 1
#
# Output: 5
#
# Explanation:
#
# The 5 good pairs are (0, 0), (1, 0), (1, 1), (2, 0), and (2, 2).
# Example 2:
#
# Input: nums1 = [1,2,4,12], nums2 = [2,4], k = 3
#
# Output: 2
#
# Explanation:
#
# The 2 good pairs are (3, 0) and (3, 1).
#
#
#
# Constraints:
#
# 1 <= n, m <= 50
# 1 <= nums1[i], nums2[j] <= 50
# 1 <= k <= 50
class Solution:
    def numberOfPairs(self, nums1: List[int], nums2: List[int], k: int) -> int:
        answer: int = 0
        for i in range(len(nums1)):
            for j in range(len(nums2)):
                if nums1[i] % (nums2[j] * k) == 0: answer += 1
        return answer

# 3163. String Compression III
# Given a string word, compress it using the following algorithm:
#
# Begin with an empty string comp. While word is not empty, use the following operation:
# Remove a maximum length prefix of word made of a single character c repeating at most 9 times.
# Append the length of the prefix followed by c to comp.
# Return the string comp.
#
#
#
#
#
# Example 1:
#
# Input: word = "abcde"
#
# Output: "1a1b1c1d1e"
#
# Explanation:
#
# Initially, comp = "". Apply the operation 5 times, choosing "a", "b", "c", "d", and "e" as the prefix in each operation.
#
# For each prefix, append "1" followed by the character to comp.
#
# Example 2:
#
# Input: word = "aaaaaaaaaaaaaabb"
#
# Output: "9a5a2b"
#
# Explanation:
#
# Initially, comp = "". Apply the operation 3 times, choosing "aaaaaaaaa", "aaaaa", and "bb" as the prefix in each operation.
#
# For prefix "aaaaaaaaa", append "9" followed by "a" to comp.
# For prefix "aaaaa", append "5" followed by "a" to comp.
# For prefix "bb", append "2" followed by "b" to comp.
#
#
# Constraints:
#
# 1 <= word.length <= 2 * 105
# word consists only of lowercase English letters.
class Solution:
    def compressedString(self, word: str) -> str:
        comp: str = ''
        count: int = 1
        seq: list[str] = [word[0]]
        for i in range(1, len(word)):
            if word[i] != seq[-1]:
                comp += str(count) + seq[-1]
                count, seq = 1, word[i]
            elif word[i] == seq[-1]:
                if count + 1 > 9:
                    comp += str(count) + seq[-1]
                    count = 1
                else:
                    count += 1
        comp += str(count) + seq[-1]
        return comp

# 1393. Capital Gain/Loss
# Table: Stocks
#
# +---------------+---------+
# | Column Name   | Type    |
# +---------------+---------+
# | stock_name    | varchar |
# | operation     | enum    |
# | operation_day | int     |
# | price         | int     |
# +---------------+---------+
# (stock_name, operation_day) is the primary key (combination of columns with unique values) for this table.
# The operation column is an ENUM (category) of type ('Sell', 'Buy')
# Each row of this table indicates that the stock which has stock_name had an operation on the day operation_day with the price.
# It is guaranteed that each 'Sell' operation for a stock has a corresponding 'Buy' operation in a previous day. It is also guaranteed that each 'Buy' operation for a stock has a corresponding 'Sell' operation in an upcoming day.
#
#
# Write a solution to report the Capital gain/loss for each stock.
#
# The Capital gain/loss of a stock is the total gain or loss after buying and selling the stock one or many times.
#
# Return the result table in any order.
#
# The result format is in the following example.
#
#
#
# Example 1:
#
# Input:
# Stocks table:
# +---------------+-----------+---------------+--------+
# | stock_name    | operation | operation_day | price  |
# +---------------+-----------+---------------+--------+
# | Leetcode      | Buy       | 1             | 1000   |
# | Corona Masks  | Buy       | 2             | 10     |
# | Leetcode      | Sell      | 5             | 9000   |
# | Handbags      | Buy       | 17            | 30000  |
# | Corona Masks  | Sell      | 3             | 1010   |
# | Corona Masks  | Buy       | 4             | 1000   |
# | Corona Masks  | Sell      | 5             | 500    |
# | Corona Masks  | Buy       | 6             | 1000   |
# | Handbags      | Sell      | 29            | 7000   |
# | Corona Masks  | Sell      | 10            | 10000  |
# +---------------+-----------+---------------+--------+
# Output:
# +---------------+-------------------+
# | stock_name    | capital_gain_loss |
# +---------------+-------------------+
# | Corona Masks  | 9500              |
# | Leetcode      | 8000              |
# | Handbags      | -23000            |
# +---------------+-------------------+
# Explanation:
# Leetcode stock was bought at day 1 for 1000$ and was sold at day 5 for 9000$. Capital gain = 9000 - 1000 = 8000$.
# Handbags stock was bought at day 17 for 30000$ and was sold at day 29 for 7000$. Capital loss = 7000 - 30000 = -23000$.
# Corona Masks stock was bought at day 1 for 10$ and was sold at day 3 for 1010$. It was bought again at day 4 for 1000$ and was sold at day 5 for 500$. At last, it was bought at day 6 for 1000$ and was sold at day 10 for 10000$. Capital gain/loss is the sum of capital gains/losses for each ('Buy' --> 'Sell') operation = (1010 - 10) + (500 - 1000) + (10000 - 1000) = 1000 - 500 + 9000 = 9500$.
SELECT stock_name,
SUM(CASE 
    WHEN operation = 'Buy' THEN -price
    WHEN operation = 'Sell' THEN price
    END
) AS capital_gain_loss
FROM Stocks
GROUP BY stock_name

# A. Domino piling
# A. Domino piling
# time limit per test2 seconds
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# You are given a rectangular board of M × N squares. Also you are given an unlimited number of standard domino pieces of 2 × 1 squares. You are allowed to rotate the pieces. You are asked to place as many dominoes as possible on the board so as to meet the following conditions:
#
# 1. Each domino completely covers two squares.
#
# 2. No two dominoes overlap.
#
# 3. Each domino lies entirely inside the board. It is allowed to touch the edges of the board.
#
# Find the maximum number of dominoes, which can be placed under these restrictions.
#
# Input
# In a single line you are given two integers M and N — board sizes in squares (1 ≤ M ≤ N ≤ 16).
#
# Output
# Output one number — the maximal number of dominoes, which can be placed.
#
# Examples
# inputCopy
# 2 4
# outputCopy
# 4
# inputCopy
# 3 3
# outputCopy
# 4
import sys
n, m = map(int, sys.stdin.readline().rstrip().split())
high = n
width = m // 2
vertical = 0
if m % 2 != 0:
    vertical += n // 2
sys.stdout.write(str(high * width + vertical))

# Bug Fix - Quick Sort
# There is an implementation of quicksort algorithm. Your task is to fix it. All inputs are correct.
#
# See also: https://en.wikipedia.org/wiki/Quicksort
#
# SORTINGALGORITHMSFUNDAMENTALSDEBUGGING
def quicksort(arr):
    if len(arr) < 1: return arr
    p = arr[0]
    less = [i for i in arr[1:] if i < p]
    greater = [i for i in arr[1:] if i >= p]
    return quicksort(less) + [p] + quicksort(greater)

# 1608. Special Array With X Elements Greater Than or Equal X
# You are given an array nums of non-negative integers. nums is considered special if there exists a number x such that there are exactly x numbers in nums that are greater than or equal to x.
#
# Notice that x does not have to be an element in nums.
#
# Return x if the array is special, otherwise, return -1. It can be proven that if nums is special, the value for x is unique.
#
#
#
# Example 1:
#
# Input: nums = [3,5]
# Output: 2
# Explanation: There are 2 values (3 and 5) that are greater than or equal to 2.
# Example 2:
#
# Input: nums = [0,0]
# Output: -1
# Explanation: No numbers fit the criteria for x.
# If x = 0, there should be 0 numbers >= x, but there are 2.
# If x = 1, there should be 1 number >= x, but there are 0.
# If x = 2, there should be 2 numbers >= x, but there are 0.
# x cannot be greater since there are only 2 numbers in nums.
# Example 3:
#
# Input: nums = [0,4,3,0,4]
# Output: 3
# Explanation: There are 3 values that are greater than or equal to 3.
#
#
# Constraints:
#
# 1 <= nums.length <= 100
# 0 <= nums[i] <= 1000
class Solution:
    def bucket_sort(self, arr):
        bucket = [0 for _ in range(max(arr) + 1)]
        for i in arr:
            bucket[i] += 1
        idx: int = 0
        for chunk in range(len(bucket)):
            if bucket[chunk] > 0:
                for _ in range(bucket[chunk]):
                    arr[idx] = chunk
                    idx += 1

    def leftmost_binary_search(self, arr, target, n):
        left, right = 0, n - 1
        while left <= right:
            middle = (left + right) >> 1
            if arr[middle] >= target:
                right = middle - 1
            else:
                left = middle + 1
        return right + 1

    def specialArray(self, nums: List[int]) -> int:
        self.bucket_sort(nums)
        n: int = len(nums)
        left, right = 0, n
        while left <= right:
            middle = (left + right) >> 1
            idx = self.leftmost_binary_search(nums, middle, n)
            items_ge = n - idx
            if items_ge == middle: return middle
            elif items_ge > middle: left = middle + 1
            else: right = middle - 1
        return -1

# 263A. Beautiful Matrix
# A. Beautiful Matrix
# time limit per test2 seconds
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# You've got a 5 × 5 matrix, consisting of 24 zeroes and a single number one. Let's index the matrix rows by numbers from 1 to 5 from top to bottom, let's index the matrix columns by numbers from 1 to 5 from left to right. In one move, you are allowed to apply one of the two following transformations to the matrix:
#
# Swap two neighboring matrix rows, that is, rows with indexes i and i + 1 for some integer i (1 ≤ i < 5).
# Swap two neighboring matrix columns, that is, columns with indexes j and j + 1 for some integer j (1 ≤ j < 5).
# You think that a matrix looks beautiful, if the single number one of the matrix is located in its middle (in the cell that is on the intersection of the third row and the third column). Count the minimum number of moves needed to make the matrix beautiful.
#
# Input
# The input consists of five lines, each line contains five integers: the j-th integer in the i-th line of the input represents the element of the matrix that is located on the intersection of the i-th row and the j-th column. It is guaranteed that the matrix consists of 24 zeroes and a single number one.
#
# Output
# Print a single integer — the minimum number of moves needed to make the matrix beautiful.
#
# Examples
# inputCopy
# 0 0 0 0 0
# 0 0 0 0 1
# 0 0 0 0 0
# 0 0 0 0 0
# 0 0 0 0 0
# outputCopy
# 3
# inputCopy
# 0 0 0 0 0
# 0 0 0 0 0
# 0 1 0 0 0
# 0 0 0 0 0
# 0 0 0 0 0
# outputCopy
# 1
import sys
lst: list = []
for _ in range(5):
    lst.append(list(map(int, sys.stdin.readline().rstrip().split())))
for r in range(5):
    for c in range(5):
        if lst[r][c] == 1:
            sys.stdout.write(str(abs(2 - r) + abs(2 - c)))

# Allocating Hotel Rooms
# Task
# Allocate customers to hotel rooms based on their arrival and departure days. Each customer wants their own room, so two customers can stay in the same room only if the departure day of the first customer is earlier than the arrival day of the second customer. The number of rooms used should be minimized.
#
# Input
# A list or array of n customers, 1 ≤ n ≤ 1000. Each customer is represented by (arrival_day, departure_day), which are positive integers satisfying arrival_day ≤ departure_day.
#
# Output
# A list or array of size n, where element i indicates the room that customer i was allocated. Rooms are numbered 1,2, ..., k for some 1 ≤ k ≤ n. Any allocation that minimizes the number of rooms k is a valid solution.
#
# Example:
# Suppose customers is [(1,5), (2,4), (6,8), (7,7)].
# Clearly customers 1 and 2 cannot get the same room. Customer 3 can use the same room as either of them, because they both leave before customer 3 arrives. Then customer 4 can be given the other room.
# So any of [1,2,1,2], [1,2,2,1], [2,1,2,1], [2,1,1,2] is a valid solution.
#
# NOTE: The list of customers is not necessarily ordered by arrival_time.
#
# Source: CSES
# Related kata:
# Minimum number of taxis is a harder version, because the lists are bigger.
#
# The Hotel with Infinite Rooms
# Is room reserved?
#
# SORTINGARRAYS
import heapq

def allocate_rooms(customers):
    customers = sorted(enumerate(customers), key=lambda x: (x[1][0], x[1][1]))
    heap = []
    room_assignment = {}
    room_count = 0
    for original_index, (arrival, departure) in customers:
        if heap and heap[0][0] < arrival:
            earliest_departure, assigned_room = heapq.heappop(heap)
            heapq.heappush(heap, (departure, assigned_room))
        else:
            room_count += 1
            assigned_room = room_count
            heapq.heappush(heap, (departure, assigned_room))
        room_assignment[original_index] = assigned_room
    result = [room_assignment[i] for i in range(len(customers))]
    return result

# Minimum number of taxis
# You work at a taxi central.
# People contact you to order a taxi. They inform you of the time they want to be picked up and dropped off.
#
# A taxi is available to handle a new customer 1 time unit after it has dropped off a previous customer.
#
# What is the minimum number of taxis you need to service all requests?
#
# Constraints:
# Let N be the number of customer requests:
# N is an integer in the range [1, 100k]
# All times will be integers in range [1, 10k]
# Let PU be the time of pickup and DO be the time of dropoff
# Then for each request: PU < DO
# The input list is NOT sorted.
# Examples:
# # Two customers, overlapping schedule. Two taxis needed.
# # First customer wants to be picked up 1 and dropped off 4.
# # Second customer wants to be picked up 2 and dropped off 6.
# requests = [(1, 4), (2, 6)]
# min_num_taxis(requests) # => 2
#
# # Two customers, no overlap in schedule. Only one taxi needed.
# # First customer wants to be picked up 1 and dropped off 4.
# # Second customer wants to be picked up 5 and dropped off 9.
# requests = [(1, 4), (5, 9)]
# min_num_taxis(requests) # => 1
# DATA STRUCTURESALGORITHMSPRIORITY QUEUESSCHEDULING
import heapq

def min_num_taxis(requests):
    requests = sorted(enumerate(requests), key=lambda x: (x[1][0], x[1][1]))
    heap = []
    room_count = 0
    for original_index, (arrival, departure) in requests:
        if heap and heap[0][0] < arrival:
            earliest_departure, assigned_room = heapq.heappop(heap)
            heapq.heappush(heap, (departure, assigned_room))
        else:
            room_count += 1
            assigned_room = room_count
            heapq.heappush(heap, (departure, assigned_room))
    return room_count

# How much hex is the fish
# How much is the fish! (- Scooter )
# The ocean is full of colorful fishes. We as programmers want to know the hexadecimal value of these fishes.
#
# Task
# Take all hexadecimal valid characters (a,b,c,d,e,f) of the given name and XOR them. Return the result as an integer.
#
# Input
# The input is always a string, which can contain spaces, upper and lower case letters but no digits.
#
# Example
# fisHex("redlionfish") -> e,d,f -> XOR -> 12
#
# STRINGSFUNDAMENTALS
def fish_hex(name):
    output: int = 0
    for i in name:
        if i.lower() in 'abcdef': output ^= int(i.upper(), 16)
    return output
    
# A. Petya and Strings
# A. Petya and Strings
# time limit per test2 seconds
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# Little Petya loves presents. His mum bought him two strings of the same size for his birthday. The strings consist of uppercase and lowercase Latin letters. Now Petya wants to compare those two strings lexicographically. The letters' case does not matter, that is an uppercase letter is considered equivalent to the corresponding lowercase letter. Help Petya perform the comparison.
#
# Input
# Each of the first two lines contains a bought string. The strings' lengths range from 1 to 100 inclusive. It is guaranteed that the strings are of the same length and also consist of uppercase and lowercase Latin letters.
#
# Output
# If the first string is less than the second one, print "-1". If the second string is less than the first one, print "1". If the strings are equal, print "0". Note that the letters' case is not taken into consideration when the strings are compared.
#
# Examples
# inputCopy
# aaaa
# aaaA
# outputCopy
# 0
# inputCopy
# abs
# Abz
# outputCopy
# -1
# inputCopy
# abcdefg
# AbCdEfF
# outputCopy
# 1
# Note
# If you want more formal information about the lexicographical order (also known as the "dictionary order" or "alphabetical order"), you can visit the following site:
#
# http://en.wikipedia.org/wiki/Lexicographical_order
import sys
first: str = sys.stdin.readline().rstrip().lower()
second: str = sys.stdin.readline().rstrip().lower()
if first == second:
    sys.stdout.write(str(0))
else:
    sys.stdout.write(str([-1, 1][first > second]))
    
# 1208. Get Equal Substrings Within Budget
# You are given two strings s and t of the same length and an integer maxCost.
#
# You want to change s to t. Changing the ith character of s to ith character of t costs |s[i] - t[i]| (i.e., the absolute difference between the ASCII values of the characters).
#
# Return the maximum length of a substring of s that can be changed to be the same as the corresponding substring of t with a cost less than or equal to maxCost. If there is no substring from s that can be changed to its corresponding substring from t, return 0.
#
#
#
# Example 1:
#
# Input: s = "abcd", t = "bcdf", maxCost = 3
# Output: 3
# Explanation: "abc" of s can change to "bcd".
# That costs 3, so the maximum length is 3.
# Example 2:
#
# Input: s = "abcd", t = "cdef", maxCost = 3
# Output: 1
# Explanation: Each character in s costs 2 to change to character in t,  so the maximum length is 1.
# Example 3:
#
# Input: s = "abcd", t = "acde", maxCost = 0
# Output: 1
# Explanation: You cannot make any change, so the maximum length is 1.
#
#
# Constraints:
#
# 1 <= s.length <= 105
# t.length == s.length
# 0 <= maxCost <= 106
# s and t consist of only lowercase English letters.
class Solution:
    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:
        total_cost: int = 0
        substring: int = 0
        left: int = 0
        for right in range(len(t)):
            cost: int = abs(ord(s[right]) - ord(t[right]))
            total_cost += cost
            while total_cost > maxCost:
                total_cost -= abs(ord(s[left]) - ord(t[left]))
                left += 1
            substring = max(substring, right - left + 1)
        return substring

# 1404. Number of Steps to Reduce a Number in Binary Representation to One
# Given the binary representation of an integer as a string s, return the number of steps to reduce it to 1 under the following rules:
#
# If the current number is even, you have to divide it by 2.
#
# If the current number is odd, you have to add 1 to it.
#
# It is guaranteed that you can always reach one for all test cases.
#
#
#
# Example 1:
#
# Input: s = "1101"
# Output: 6
# Explanation: "1101" corressponds to number 13 in their decimal representation.
# Step 1) 13 is odd, add 1 and obtain 14.
# Step 2) 14 is even, divide by 2 and obtain 7.
# Step 3) 7 is odd, add 1 and obtain 8.
# Step 4) 8 is even, divide by 2 and obtain 4.
# Step 5) 4 is even, divide by 2 and obtain 2.
# Step 6) 2 is even, divide by 2 and obtain 1.
# Example 2:
#
# Input: s = "10"
# Output: 1
# Explanation: "10" corressponds to number 2 in their decimal representation.
# Step 1) 2 is even, divide by 2 and obtain 1.
# Example 3:
#
# Input: s = "1"
# Output: 0
#
#
# Constraints:
#
# 1 <= s.length <= 500
# s consists of characters '0' or '1'
# s[0] == '1'
class Solution:
    def numSteps(self, s: str) -> int:
        x: int = int(s, 2)
        step: int = 0
        while x > 1:
            x = [x >> 1, x + 1][x & 1]
            step += 1
        return step


# A. Helpful Maths
# A. Helpful Maths
# time limit per test2 seconds
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# Xenia the beginner mathematician is a third year student at elementary school. She is now learning the addition operation.
#
# The teacher has written down the sum of multiple numbers. Pupils should calculate the sum. To make the calculation easier, the sum only contains numbers 1, 2 and 3. Still, that isn't enough for Xenia. She is only beginning to count, so she can calculate a sum only if the summands follow in non-decreasing order. For example, she can't calculate sum 1+3+2+1 but she can calculate sums 1+1+2 and 3+3.
#
# You've got the sum that was written on the board. Rearrange the summans and print the sum in such a way that Xenia can calculate the sum.
#
# Input
# The first line contains a non-empty string s — the sum Xenia needs to count. String s contains no spaces. It only contains digits and characters "+". Besides, string s is a correct sum of numbers 1, 2 and 3. String s is at most 100 characters long.
#
# Output
# Print the new sum that Xenia can count.
#
# Examples
# inputCopy
# 3+2+1
# outputCopy
# 1+2+3
# inputCopy
# 1+1+3+1+3
# outputCopy
# 1+1+1+3+3
# inputCopy
# 2
# outputCopy
# 2

import sys
storage: list = [0] * 4
digits: list = list(map(int, sys.stdin.readline().rstrip().split('+')))
output: list = []
for i in digits:
    storage[i] += 1
for i in range(4):
    if storage[i] > 0:
        for _ in range(storage[i]):
            output.append(str(i))
print('+'.join(output))

# Thinking & Testing #38: What's the "?"
# No Story
#
# No Description
#
# Only by Thinking and Testing
#
# Look at result of testcase, guess the code!
#
# #Series:
# 01:A and B?
# 02:Incomplete string
# 03:True or False
# 04:Something capitalized
# 05:Uniq or not Uniq
# 06:Spatiotemporal index
# 07:Math of Primary School
# 08:Math of Middle school
# 09:From nothingness To nothingness
# 10:Not perfect? Throw away!
# 11:Welcome to take the bus
# 12:A happy day will come
# 13:Sum of 15(Hetu Luosliu)
# 14:Nebula or Vortex
# 15:Sport Star
# 16:Falsetto Rap Concert
# 17:Wind whispers
# 18:Mobile phone simulator
# 19:Join but not join
# 20:I hate big and small
# 21:I want to become diabetic ;-)
# 22:How many blocks?
# 23:Operator hidden in a string
# 24:Substring Magic
# 25:Report about something
# 26:Retention and discard I
# 27:Retention and discard II
# 28:How many "word"?
# 29:Hail and Waterfall
# 30:Love Forever
# 31:Digital swimming pool
# 32:Archery contest
# 33:The repair of parchment
# 34:Who are you?
# 35:Safe position
# 36:Sort in order
# 37:Convert number
# 38:What's the "?"
#
# PUZZLESGAMES
def test_it(arr):
    colors: dict[str, int] = dict()
    shapes: dict[str, int] = dict()
    for item in arr:
        if item == '?': continue
        color, shape = item.split()
        colors[color] = colors.get(color, 0) + 1
        shapes[shape] = shapes.get(shape, 0) + 1
    color, color_time = None, float('inf')
    shape, shape_time = None, float('inf')
    for name, time in colors.items():
        if color_time > time:
            color, color_time = name, time
    for name, time in shapes.items():
        if shape_time > time:
            shape, shape_time = name, time
    return color + ' ' + shape

# 1442. Count Triplets That Can Form Two Arrays of Equal XOR
# Given an array of integers arr.
#
# We want to select three indices i, j and k where (0 <= i < j <= k < arr.length).
#
# Let's define a and b as follows:
#
# a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]
# b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]
# Note that ^ denotes the bitwise-xor operation.
#
# Return the number of triplets (i, j and k) Where a == b.
#
#
#
# Example 1:
#
# Input: arr = [2,3,1,6,7]
# Output: 4
# Explanation: The triplets are (0,1,2), (0,2,2), (2,3,4) and (2,4,4)
# Example 2:
#
# Input: arr = [1,1,1,1,1]
# Output: 10
#
#
# Constraints:
#
# 1 <= arr.length <= 300
# 1 <= arr[i] <= 108
class Solution:
    def countTriplets(self, arr: List[int]) -> int:
        output: int = 0
        n: int = len(arr)
        for start in range(n):
            outer_xor: int = arr[start]
            for end in range(start + 1, n):
                outer_xor ^= arr[end]
                if outer_xor == 0: output += end - start
        return output
    
# Simple Fun #147: Find The Missing Tree
# Task
# After a long night (work, play, study) you find yourself sleeping on a bench in a park. As you wake up and try to figure out what happened you start counting trees.
#
# You notice there are different tree sizes but there's always one size which is unbalanced. For example there are 2 size 2, 2 size 1 and 1 size 3. (then the size 3 is unbalanced)
#
# Given an array representing different tree sizes. Which one is the unbalanced size.
#
# Notes
# There can be any number of sizes but one is always unbalanced
# The unbalanced size is always one less than the other sizes
# The array is not ordered (nor the trees)
# Examples
# For trees = [1,1,2,2,3], the result should be 3.
#
# For trees = [2,2,2,56,56,56,8,8], the result should be 8.
#
# For trees = [34,76,12,99,64,99,76,12,34], the result should be 64.
#
# Input/Output
# [input] integer array trees
#
# Array representing different tree sizes
#
# [output] an integer
#
# The size of the missing tree.
#
# ALGORITHMS
# Solution
def find_the_missing_tree(trees):
    hashtable: dict[int, int] = dict()
    for i in trees:
        hashtable[i] = hashtable.get(i, 0) + 1
    v = min(hashtable.values())
    for k in hashtable:
        if hashtable[k] == v:
            return k

# A. Word Capitalization
# A. Word Capitalization
# time limit per test2 seconds
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# Capitalization is writing a word with its first letter as a capital letter. Your task is to capitalize the given word.
#
# Note, that during capitalization all the letters except the first one remains unchanged.
#
# Input
# A single line contains a non-empty word. This word consists of lowercase and uppercase English letters. The length of the word will not exceed 103.
#
# Output
# Output the given word after capitalization.
#
# Examples
# inputCopy
# ApPLe
# outputCopy
# ApPLe
# inputCopy
# konjac
# outputCopy
# Konjac
import sys
sentence = sys.stdin.readline().rstrip()
answer = sentence[0].upper() + sentence[1:]
sys.stdout.write(answer)

# A. Verify Password
# A. Verify Password
# time limit per test2 seconds
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# Monocarp is working on his new site, and the current challenge is to make the users pick strong passwords.
#
# Monocarp decided that strong passwords should satisfy the following conditions:
#
# password should consist only of lowercase Latin letters and digits;
# there should be no digit that comes after a letter (so, after each letter, there is either another letter or the string ends);
# all digits should be sorted in the non-decreasing order;
# all letters should be sorted in the non-decreasing order.
# Note that it's allowed for the password to have only letters or only digits.
#
# Monocarp managed to implement the first condition, but he struggles with the remaining ones. Can you help him to verify the passwords?
#
# Input
# The first line contains a single integer t
#  (1≤t≤1000
# ) — the number of testcases.
#
# The first line of each testcase contains a single integer n
#  (1≤n≤20
# ) — the length of the password.
#
# The second line contains a string, consisting of exactly n
#  characters. Each character is either a lowercase Latin letter or a digit.
#
# Output
# For each testcase, print "YES" if the given password is strong and "NO" otherwise.
#
# Example
# inputCopy
# 5
# 4
# 12ac
# 5
# 123wa
# 9
# allllmost
# 5
# ac123
# 6
# 011679
# outputCopy
# YES
# NO
# YES
# NO
# YES
# Note
# In the second testcase, the letters are not sorted in the non-decreasing order.
#
# In the fourth testcase, there is a digit that comes after a letter — digit '1' after a letter 'c'.
# Solution Sorting O(NlogN) O(N)
import sys
from string import ascii_lowercase
t: int = int(sys.stdin.readline().rstrip())
for _ in range(t):
    n: int = int(sys.stdin.readline().rstrip())
    seen: bool = False
    password: str = sys.stdin.readline().rstrip()
    correct: bool = True
    letters: list = []
    digits: list = []
    for i in password:
        if i in ascii_lowercase:
            seen = True
            letters.append(i)
        elif i in '0123456789':
            if seen:
                correct = False
                break
            digits.append(i)
        else:
            correct = False
            break
    print(['NO', 'YES'][correct and (sorted(letters) == letters) and (sorted(digits) == digits)])
    
# How long should you cook this for?
# You've purchased a ready-meal from the supermarket.
#
# The packaging says that you should microwave it for 4 minutes and 20 seconds, based on a 600W microwave.
#
# Oh no, your microwave is 800W! How long should you cook this for?!
#
# Input
# You'll be given 4 arguments:
#
# 1. needed power
# The power of the needed microwave.
# Example: "600W"
#
# 2. minutes
# The number of minutes shown on the package.
# Example: 4
#
# 3. seconds
# The number of seconds shown on the package.
# Example: 20
#
# 4. power
# The power of your microwave.
# Example: "800W"
#
# Output
# The amount of time you should cook the meal for formatted as a string.
# Example: "3 minutes 15 seconds"
#
# Note: the result should be rounded up.
#
# 59.2 sec  -->  60 sec  -->  return "1 minutes 0 seconds"
# All comments/feedback/translations appreciated.
# FUNDAMENTALS
def cooking_time(needed_power, minutes, seconds, power):
    x, x_sec = int(needed_power[:-1]), minutes * 60 + seconds
    y = int(power[:-1])
    y_sec = x * x_sec / y
    y_sec = int(y_sec) + 1 if int(y_sec) < y_sec else int(y_sec)
    return f'{y_sec // 60} minutes {y_sec % 60} seconds'
    
# A. Boy or Girl
# A. Boy or Girl
# time limit per test1 second
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# Those days, many boys use beautiful girls' photos as avatars in forums. So it is pretty hard to tell the gender of a user at the first glance. Last year, our hero went to a forum and had a nice chat with a beauty (he thought so). After that they talked very often and eventually they became a couple in the network.
#
# But yesterday, he came to see "her" in the real world and found out "she" is actually a very strong man! Our hero is very sad and he is too tired to love again now. So he came up with a way to recognize users' genders by their user names.
#
# This is his method: if the number of distinct characters in one's user name is odd, then he is a male, otherwise she is a female. You are given the string that denotes the user name, please help our hero to determine the gender of this user by his method.
#
# Input
# The first line contains a non-empty string, that contains only lowercase English letters — the user name. This string contains at most 100 letters.
#
# Output
# If it is a female by our hero's method, print "CHAT WITH HER!" (without the quotes), otherwise, print "IGNORE HIM!" (without the quotes).
#
# Examples
# inputCopy
# wjmzbmr
# outputCopy
# CHAT WITH HER!
# inputCopy
# xiaodao
# outputCopy
# IGNORE HIM!
# inputCopy
# sevenkplus
# outputCopy
# CHAT WITH HER!
# Note
# For the first example. There are 6 distinct characters in "wjmzbmr". These characters are: "w", "j", "m", "z", "b", "r". So wjmzbmr is a female and you should print "CHAT WITH HER!".
import sys
username: str = sys.stdin.readline().rstrip()
sys.stdout.write(['CHAT WITH HER!', 'IGNORE HIM!'][len(set(username)) % 2 != 0])

# 260. Single Number III
# Given an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order.
#
# You must write an algorithm that runs in linear runtime complexity and uses only constant extra space.
#
#
#
# Example 1:
#
# Input: nums = [1,2,1,3,2,5]
# Output: [3,5]
# Explanation:  [5, 3] is also a valid answer.
# Example 2:
#
# Input: nums = [-1,0]
# Output: [-1,0]
# Example 3:
#
# Input: nums = [0,1]
# Output: [1,0]
#
#
# Constraints:
#
# 2 <= nums.length <= 3 * 104
# -231 <= nums[i] <= 231 - 1
# Each integer in nums will appear twice, only two integers will appear once.
class Solution:
    def singleNumber(self, nums: List[int]) -> List[int]:
        diff: int = 0
        for item in nums: diff ^= item
        bit_position: int = 0
        while not diff & (1 << bit_position): bit_position += 1
        first: int = 0
        for item in nums:
            if item & (1 << bit_position):
                first ^= item
        return [first, first ^ diff]
    
# A. String Task
# A. String Task
# time limit per test2 seconds
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# Petya started to attend programming lessons. On the first lesson his task was to write a simple program. The program was supposed to do the following: in the given string, consisting if uppercase and lowercase Latin letters, it:
#
# deletes all the vowels,
# inserts a character "." before each consonant,
# replaces all uppercase consonants with corresponding lowercase ones.
# Vowels are letters "A", "O", "Y", "E", "U", "I", and the rest are consonants. The program's input is exactly one string, it should return the output as a single string, resulting after the program's processing the initial string.
#
# Help Petya cope with this easy task.
#
# Input
# The first line represents input string of Petya's program. This string only consists of uppercase and lowercase Latin letters and its length is from 1 to 100, inclusive.
#
# Output
# Print the resulting string. It is guaranteed that this string is not empty.
#
# Examples
# inputCopy
# tour
# outputCopy
# .t.r
# inputCopy
# Codeforces
# outputCopy
# .c.d.f.r.c.s
# inputCopy
# aBAcAba
# outputCopy
# .b.c.b
import sys
sentence: list = list(sys.stdin.readline().rstrip())
for i in range(len(sentence) - 1, -1, -1):
    if sentence[i].lower() in 'aeoiuy':
        sentence.pop(i)
    else:
        sentence[i] = sentence[i].lower()
print(''.join('.' + i for i in sentence))

# 17. Letter Combinations of a Phone Number
# Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.
#
# A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.
#
#
#
#
# Example 1:
#
# Input: digits = "23"
# Output: ["ad","ae","af","bd","be","bf","cd","ce","cf"]
# Example 2:
#
# Input: digits = ""
# Output: []
# Example 3:
#
# Input: digits = "2"
# Output: ["a","b","c"]
#
#
# Constraints:
#
# 0 <= digits.length <= 4
# digits[i] is a digit in the range ['2', '9'].
# Brute Force
# Complexity
# Time complexity: O(N**K)
# Space complexity: O(N**K)
# Where N is length of letters in digits and K is length of digits

# Code
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits: return []
        digits_store: dict[str, str] = {
            '2': 'abc', '3': 'def', '4': 'ghi',
            '5': 'jkl', '6': 'mno', '7': 'pqrs',
            '8': 'tuv', '9': 'wxyz'
        }
        output: list[str] = list()
        if len(digits) == 1:
            return list(digits_store.get(digits))
        elif len(digits) == 2:
            for i in digits_store.get(digits[0]):
                for j in digits_store.get(digits[1]):
                    output.append(i + j)
        elif len(digits) == 3:
            for i in digits_store.get(digits[0]):
                for j in digits_store.get(digits[1]):
                    for k in digits_store.get(digits[2]):
                        output.append(i + j + k)
        elif len(digits) == 4:
            for i in digits_store.get(digits[0]):
                for j in digits_store.get(digits[1]):
                    for k in digits_store.get(digits[2]):
                        for l  in digits_store.get(digits[3]):
                            output.append(i + j + k + l)
        return output

# Backtracking
# Complexity
# Time complexity: O(N**K)
# Space complexity: O(N**K)
# Where N is length of letters in digits and K is length of digits

# Code
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        def backtracking(idx: int, current_string: str) -> None:
            if len(current_string) == len(digits):
                output.append(current_string)
                return
            for letter in digits_store.get(digits[idx]):
                backtracking(idx + 1, current_string + letter)
        digits_store: dict[str, str] = {
            '2': 'abc', '3': 'def', '4': 'ghi',
            '5': 'jkl', '6': 'mno', '7': 'pqrs',
            '8': 'tuv', '9': 'wxyz'
        }
        output: list[str] = list()
        if digits: backtracking(0, '')
        return output
    
# PRNG: Linear Congruential Generator
# The Linear Congruential Generator (LCG) is one of the oldest pseudo random number generator functions.
#
# The algorithm is as follows:
#
# Xn+1=(aXn + c) mod m
# where:
#
# a/A is the multiplier (we'll be using 2)
# c/C is the increment (we'll be using 3)
# m/M is the modulus (we'll be using 10)
# X0 is the seed.
#
# Your task
# Define a method random/Random in the class LCG that provides the next random number based on a seed. You never return the initial seed value.
#
# Similar to random return the result as a floating point number in the range [0.0, 1.0)
#
# Example
# # initialize the generator with seed = 5
# LCG(5)
#
# # first random number (seed = 5)
# LCG.random() = 0.3      # (2 * 5 + 3) mod 10 = 3 --> return 0.3
#
# # next random number (seed = 3)
# LCG.random() = 0.9      # (2 * 3 + 3) mod 10 = 9 --> return 0.9
#
# # next random number (seed = 9)
# LCG.random() = 0.1
#
# # next random number (seed = 1)
# LCG.random() = 0.5
# ALGORITHMS
class LCG(object):
    a = 2
    c = 3
    m = 10

    def __init__(self, seed):
        self.seed = seed

    def random(self):
        x: int = (self.a * self.seed + self.c) % self.m
        self.seed = x
        return x / 10

# 344. Reverse String
# Write a function that reverses a string. The input string is given as an array of characters s.
#
# You must do this by modifying the input array in-place with O(1) extra memory.
#
#
#
# Example 1:
#
# Input: s = ["h","e","l","l","o"]
# Output: ["o","l","l","e","h"]
# Example 2:
#
# Input: s = ["H","a","n","n","a","h"]
# Output: ["h","a","n","n","a","H"]
#
#
# Constraints:
#
# 1 <= s.length <= 105
# s[i] is a printable ascii character.
class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        left, right = 0, len(s) - 1
        while left < right:
            s[left], s[right] = s[right], s[left]
            left, right = left + 1, right - 1

# Thinking & Testing : Spatiotemporal index
# No Story
#
# No Description
#
# Only by Thinking and Testing
#
# Look at the results of the testcases, and guess the code!
#
# Series:
# A and B?
# Incomplete string
# True or False
# Something capitalized
# Uniq or not Uniq
# Spatiotemporal index
# Math of Primary School
# Math of Middle school
# From nothingness To nothingness
# Not perfect? Throw away!
# Welcome to take the bus
# A happy day will come
# Sum of 15(Hetu Luosliu)
# Nebula or Vortex
# Sport Star
# Falsetto Rap Concert
# Wind whispers
# Mobile phone simulator
# Join but not join
# I hate big and small
# I want to become diabetic ;-)
# How many blocks?
# Operator hidden in a string
# Substring Magic
# Report about something
# Retention and discard I
# Retention and discard II
# How many "word"?
# Hail and Waterfall
# Love Forever
# Digital swimming pool
# Archery contest
# The repair of parchment
# Who are you?
# Safe position
# Special recommendation
# Another series, innovative and interesting, medium difficulty. People who like challenges, can try these kata:
#
# Play Tetris : Shape anastomosis
# Play FlappyBird : Advance Bravely
# PUZZLESARRAYS
distance: dict[str, int] = {'mm': 1, 'cm': 10, 'dm': 100, 'm': 1_000, 'km': 1_000_000}
time: dict[str, int] = {'ms': 1, 's': 1_000, 'm': 60_000, 'h': 3_600_000 , 'd': 86_400_000}

def check(sentence: list[str]) -> tuple[bool, str]:
    units: list[str] = list()
    for i in sentence:
        units.append(i[get_metric(i):])
    if all(i in distance for i in units): return True, 'distance'
    elif all(i in time for i in units): return True, 'time'
    return False, None

def get_metric(unit):
    idx: int = 0
    while unit[idx] in '0123456789':
        idx += 1
    return idx

def testit(a):
    metrics: bool = check(a)
    if metrics[0] is False: return metrics[1]
    elif metrics[1] == 'distance':
        a.sort(key=lambda x: int(x[:get_metric(x)]) * distance.get(x[get_metric(x):]))
        return a
    else:
        a.sort(key=lambda x: int(x[:get_metric(x)]) * time.get(x[get_metric(x):]))
        return a
        
# A. Bear and Big Brother
# A. Bear and Big Brother
# time limit per test1 second
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# Bear Limak wants to become the largest of bears, or at least to become larger than his brother Bob.
# 
# Right now, Limak and Bob weigh a and b respectively. It's guaranteed that Limak's weight is smaller than or equal to his brother's weight.
# 
# Limak eats a lot and his weight is tripled after every year, while Bob's weight is doubled after every year.
# 
# After how many full years will Limak become strictly larger (strictly heavier) than Bob?
# 
# Input
# The only line of the input contains two integers a and b (1 ≤ a ≤ b ≤ 10) — the weight of Limak and the weight of Bob respectively.
# 
# Output
# Print one integer, denoting the integer number of years after which Limak will become strictly larger than Bob.
# 
# Examples
# inputCopy
# 4 7
# outputCopy
# 2
# inputCopy
# 4 9
# outputCopy
# 3
# inputCopy
# 1 1
# outputCopy
# 1
# Note
# In the first sample, Limak weighs 4 and Bob weighs 7 initially. After one year their weights are 4·3 = 12 and 7·2 = 14 respectively (one weight is tripled while the other one is doubled). Limak isn't larger than Bob yet. After the second year weights are 36 and 28, so the first weight is greater than the second one. Limak became larger than Bob after two years so you should print 2.
# 
# In the second sample, Limak's and Bob's weights in next years are: 12 and 18, then 36 and 36, and finally 108 and 72 (after three years). The answer is 3. Remember that Limak wants to be larger than Bob and he won't be satisfied with equal weights.
# 
# In the third sample, Limak becomes larger than Bob after the first year. Their weights will be 3 and 2 then.
import sys
limak, bob = map(int, sys.stdin.readline().rstrip().split())
answer: int = 0
while limak <= bob:
    answer += 1
    limak, bob = limak * 3, bob * 2
sys.stdout.write(str(answer))

# 3168. Minimum Number of Chairs in a Waiting Room
# You are given a string s. Simulate events at each second i:
# 
# If s[i] == 'E', a person enters the waiting room and takes one of the chairs in it.
# If s[i] == 'L', a person leaves the waiting room, freeing up a chair.
# Return the minimum number of chairs needed so that a chair is available for every person who enters the waiting room given that it is initially empty.
# 
#  
# 
# Example 1:
# 
# Input: s = "EEEEEEE"
# 
# Output: 7
# 
# Explanation:
# 
# After each second, a person enters the waiting room and no person leaves it. Therefore, a minimum of 7 chairs is needed.
# 
# Example 2:
# 
# Input: s = "ELELEEL"
# 
# Output: 2
# 
# Explanation:
# 
# Let's consider that there are 2 chairs in the waiting room. The table below shows the state of the waiting room at each second.
# 
# Second	Event	People in the Waiting Room	Available Chairs
# 0	Enter	1	1
# 1	Leave	0	2
# 2	Enter	1	1
# 3	Leave	0	2
# 4	Enter	1	1
# 5	Enter	2	0
# 6	Leave	1	1
# Example 3:
# 
# Input: s = "ELEELEELLL"
# 
# Output: 3
# 
# Explanation:
# 
# Let's consider that there are 3 chairs in the waiting room. The table below shows the state of the waiting room at each second.
# 
# Second	Event	People in the Waiting Room	Available Chairs
# 0	Enter	1	2
# 1	Leave	0	3
# 2	Enter	1	2
# 3	Enter	2	1
# 4	Leave	1	2
# 5	Enter	2	1
# 6	Enter	3	0
# 7	Leave	2	1
# 8	Leave	1	2
# 9	Leave	0	3
#  
# 
# Constraints:
# 
# 1 <= s.length <= 50
# s consists only of the letters 'E' and 'L'.
# s represents a valid sequence of entries and exits.
class Solution:
    def minimumChairs(self, s: str) -> int:
        total: int = float('-inf')
        current: int = 0
        for i in s:
            if i == 'E':
                current += 1
            else:
                current -= 1
            total = max(total, current)
        return total

# 3169. Count Days Without Meetings
# You are given a positive integer days representing the total number of days an employee is available for work (starting from day 1). You are also given a 2D array meetings of size n where, meetings[i] = [start_i, end_i] represents the starting and ending days of meeting i (inclusive).
#
# Return the count of days when the employee is available for work but no meetings are scheduled.
#
# Note: The meetings may overlap.
#
#
#
# Example 1:
#
# Input: days = 10, meetings = [[5,7],[1,3],[9,10]]
#
# Output: 2
#
# Explanation:
#
# There is no meeting scheduled on the 4th and 8th days.
#
# Example 2:
#
# Input: days = 5, meetings = [[2,4],[1,3]]
#
# Output: 1
#
# Explanation:
#
# There is no meeting scheduled on the 5th day.
#
# Example 3:
#
# Input: days = 6, meetings = [[1,6]]
#
# Output: 0
#
# Explanation:
#
# Meetings are scheduled for all working days.
#
#
#
# Constraints:
#
# 1 <= days <= 109
# 1 <= meetings.length <= 105
# meetings[i].length == 2
# 1 <= meetings[i][0] <= meetings[i][1] <= days
class Solution:
    def countDays(self, days: int, meetings: List[List[int]]) -> int:
        meetings.sort(key=lambda x: (x[0], -x[1]))
        start, end = meetings[0]
        for i in range(1, len(meetings)):
            if meetings[i][0] <= end:
                end = max(end, meetings[i][1])
            else:
                days -= end - start + 1
                start, end = meetings[i]
        days -= end - start + 1
        return days
    
# 3170. Lexicographically Minimum String After Removing Stars
# You are given a string s. It may contain any number of '*' characters. Your task is to remove all '*' characters.
#
# While there is a '*', do the following operation:
#
# Delete the leftmost '*' and the smallest non-'*' character to its left. If there are several smallest characters, you can delete any of them.
# Return the
# lexicographically smallest
#  resulting string after removing all '*' characters.
#
#
#
# Example 1:
#
# Input: s = "aaba*"
#
# Output: "aab"
#
# Explanation:
#
# We should delete one of the 'a' characters with '*'. If we choose s[3], s becomes the lexicographically smallest.
#
# Example 2:
#
# Input: s = "abc"
#
# Output: "abc"
#
# Explanation:
#
# There is no '*' in the string.
#
#
#
# Constraints:
#
# 1 <= s.length <= 105
# s consists only of lowercase English letters and '*'.
# The input is generated such that it is possible to delete all '*' characters.
import heapq
class Solution:
    def clearStars(self, s: str) -> str:
        heap = list()
        for i in range(len(s)):
            if s[i] == '*':
                 heapq.heappop(heap)
            else:
                heapq.heappush(heap, (s[i], -i))
        heap.sort(key=lambda x: -x[1])
        return ''.join(i[0] for i in heap)

# A. Stones on the Table
# A. Stones on the Table
# time limit per test2 seconds
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# There are n stones on the table in a row, each of them can be red, green or blue. Count the minimum number of stones to take from the table so that any two neighboring stones had different colors. Stones in a row are considered neighboring if there are no other stones between them.
# 
# Input
# The first line contains integer n (1 ≤ n ≤ 50) — the number of stones on the table.
# 
# The next line contains string s, which represents the colors of the stones. We'll consider the stones in the row numbered from 1 to n from left to right. Then the i-th character s equals "R", if the i-th stone is red, "G", if it's green and "B", if it's blue.
# 
# Output
# Print a single integer — the answer to the problem.
# 
# Examples
# inputCopy
# 3
# RRG
# outputCopy
# 1
# inputCopy
# 5
# RRRRR
# outputCopy
# 4
# inputCopy
# 4
# BRBG
# outputCopy
# 0
import sys
n: int = int(sys.stdin.readline().rstrip())
stones: str = sys.stdin.readline().rstrip()
current_index: int = 0
swaped: int = 0
for idx in range(1, n):
    if stones[current_index] == stones[idx]:
        swaped += 1
    else:
        current_index = idx
sys.stdout.write(str(swaped))

# 2486. Append Characters to String to Make Subsequence
# You are given two strings s and t consisting of only lowercase English letters.
#
# Return the minimum number of characters that need to be appended to the end of s so that t becomes a subsequence of s.
#
# A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.
#
#
#
# Example 1:
#
# Input: s = "coaching", t = "coding"
# Output: 4
# Explanation: Append the characters "ding" to the end of s so that s = "coachingding".
# Now, t is a subsequence of s ("coachingding").
# It can be shown that appending any 3 characters to the end of s will never make t a subsequence.
# Example 2:
#
# Input: s = "abcde", t = "a"
# Output: 0
# Explanation: t is already a subsequence of s ("abcde").
# Example 3:
#
# Input: s = "z", t = "abcde"
# Output: 5
# Explanation: Append the characters "abcde" to the end of s so that s = "zabcde".
# Now, t is a subsequence of s ("zabcde").
# It can be shown that appending any 4 characters to the end of s will never make t a subsequence.
#
#
# Constraints:
#
# 1 <= s.length, t.length <= 105
# s and t consist only of lowercase English letters.
class Solution:
    def appendCharacters(self, s: str, t: str) -> int:
        left, right = 0, 0
        left_len, right_len = len(s), len(t)
        total: int = right_len
        while left < left_len and right < right_len:
            if s[left] == t[right]:
                total -= 1
                right += 1
            left += 1
        return total
        
# Is Sator Square?
# A Discovery
# One fine day while tenaciously turning the soil of his fields, Farmer Arepo found a square stone tablet with letters carved into it... he knew such artifacts may 'show a message in four directions', so he wisely kept it. As he continued to toil in his work with his favourite rotary plough, he found more such tablets, but with so many crops to sow he had no time to decipher them all.
#
# Your Task
# Please help Farmer Arepo by inspecting each tablet to see if it forms a valid Sator Square!
#
# sator square
# The Square
# is a two-dimentional palindrome, made from words of equal length that can be read in these four ways:
#
#     1)    left-to-right    (across)
#     2)    top-to-bottom    (down)
#     3)    bottom-to-top    (up)
#     4)    right-to-left    (reverse)
# An Example
# Considering this square:
#
#     B A T S
#     A B U T
#     T U B A
#     S T A B
# Here are the four ways a word (in this case "TUBA") can be read:
#
#                          down
#                           ↓
#            B A T S    B A T S    B A T S    B A T S
#            A B U T    A B U T    A B U T    A B U T ← reverse
#   across → T U B A    T U B A    T U B A    T U B A
#            S T A B    S T A B    S T A B    S T A B
#                                    ↑
#                                    up
# IMPORTANT:
#
# In a true Sator Square, ALL of its words can be read in ALL four of these ways.
# If there is any deviation, it would be false to consider it a Sator Square.
# Some Details
# tablet (square) dimensions range from 2x2 to 33x33 inclusive
# all characters used will be upper-case alphabet letters
# there is no need to validate any input
# Input
# an N x N (square) two-dimentional matrix of uppercase letters
# Output
# boolean true or false whether or not the tablet is a Sator Square
# Enjoy!
# You may consider one of the following kata to solve next:
#
# Playing With Toy Blocks ~ Can you build a 4x4 square?
# Four Letter Words ~ Mutations
# Setting Places for the Dead
# Crossword Puzzle! (2x2)
# Interlocking Binary Pairs
# ARRAYSDATA STRUCTURESALGORITHMS
# Solution
from collections import defaultdict
def is_sator_square(tablet):
    ht: dict[str, int] = defaultdict(int)
    for r in range(len(tablet)):
        word = ''.join(tablet[r])
        ht[word] += 1
        ht[word[::-1]] += 1
    for c in range(len(tablet[0])):
        word = ''.join(tablet[r][c] for r in range(len(tablet)))
        ht[word] += 1
        ht[word[::-1]] += 1
    for k in ht:
        if ht[k] < 4: return False
    return True

# 409. Longest Palindrome
# Given a string s which consists of lowercase or uppercase letters, return the length of the longest
# palindrome
#  that can be built with those letters.
#
# Letters are case sensitive, for example, "Aa" is not considered a palindrome.
#
#
#
# Example 1:
#
# Input: s = "abccccdd"
# Output: 7
# Explanation: One longest palindrome that can be built is "dccaccd", whose length is 7.
# Example 2:
#
# Input: s = "a"
# Output: 1
# Explanation: The longest palindrome that can be built is "a", whose length is 1.
#
#
# Constraints:
#
# 1 <= s.length <= 2000
# s consists of lowercase and/or uppercase English letters only.
from collections import defaultdict
class Solution:
    def longestPalindrome(self, s: str) -> int:
        ht: dict[str, int] = defaultdict(int)
        for i in s: ht[i] += 1
        answer: int = 0
        mx_odd: str = None
        for i in ht:
            if ht[i] % 2 == 0: answer += ht[i]
            elif not mx_odd or ht[i] > ht[mx_odd]:
                answer += (ht[mx_odd] - 1) if mx_odd else 0
                mx_odd = i
            else: answer += ht[i] - 1
        return answer + ht[mx_odd]
        
# A. Elephant
# A. Elephant
# time limit per test1 second
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# An elephant decided to visit his friend. It turned out that the elephant's house is located at point 0 and his friend's house is located at point x(x > 0) of the coordinate line. In one step the elephant can move 1, 2, 3, 4 or 5 positions forward. Determine, what is the minimum number of steps he need to make in order to get to his friend's house.
#
# Input
# The first line of the input contains an integer x (1 ≤ x ≤ 1 000 000) — The coordinate of the friend's house.
#
# Output
# Print the minimum number of steps that elephant needs to make to get from point 0 to point x.
#
# Examples
# inputCopy
# 5
# outputCopy
# 1
# inputCopy
# 12
# outputCopy
# 3
# Note
# In the first sample the elephant needs to make one step of length 5 to reach the point x.
#
# In the second sample the elephant can get to point x if he moves by 3, 5 and 4. There are other ways to get the optimal answer but the elephant cannot reach x in less than three moves.
import sys
n: int = int(sys.stdin.readline().rstrip())
answer: int = 0
divider: int = 5
while n > 0:
    answer += n // divider
    n %= divider
    divider -= 1
sys.stdout.write(str(answer))

# Tree to list
# Given the root of a tree with an arbitrary number of child nodes, return a list containing the nodes' data in breadth-first order (left to right, top to bottom).
#
# Child nodes are stored in a list. An empty tree is represented by an empty list.
#
# Example:
#
#            1
#           / \
#          2   3  -> [1,2,3,4,5,6,7]
#         /|\   \
#        4 5 6   7
# TREESFUNDAMENTALS
class Node:
    def __init__(self, data, child_nodes=None):
        self.data = data
        self.child_nodes = [] if child_nodes is None else child_nodes

def tree_to_list(tree_root):
    current: list = [tree_root]
    nxt: list = list()
    answer: list = list()
    while current:
        for node in current:
            if not node: continue
            answer.append(node.data)
            nxt.extend(node.child_nodes)
        current = nxt
        nxt = []
    return answer

# 1002. Find Common Characters
# Given a string array words, return an array of all characters that show up in all strings within the words (including duplicates). You may return the answer in any order.
#
#
#
# Example 1:
#
# Input: words = ["bella","label","roller"]
# Output: ["e","l","l"]
# Example 2:
#
# Input: words = ["cool","lock","cook"]
# Output: ["c","o"]
#
#
# Constraints:
#
# 1 <= words.length <= 100
# 1 <= words[i].length <= 100
# words[i] consists of lowercase English letters.
class Solution:
    def commonChars(self, words: List[str]) -> List[str]:
        letter_storage: list[list[int]] = [[] for _ in range(27)] # total storage
        n: int = 0 # length of words
        for word in words:
            n += 1
            # local storage to each word
            local_letter_storage: list[int] = [0 for _ in range(27)]
            for letter in word: # count all frequences of each charackter in one word
                local_letter_storage[ord(letter) - 96] += 1
            for char in range(27): # Adding result of local storage to total storage
                letter_storage[char] += [local_letter_storage[char]]
        common_characters: list[int] = [] # Answer array
        for char in range(27):
            if len(letter_storage[char]) == n: # if character contained in all words
                common_characters.extend([chr(char + 96)] * min(letter_storage[char])) # addind minimum frequence
        return common_characters

# A. Soldier and Bananas
# A. Soldier and Bananas
# time limit per test1 second
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# A soldier wants to buy w bananas in the shop. He has to pay k dollars for the first banana, 2k dollars for the second one and so on (in other words, he has to pay i·k dollars for the i-th banana).
# 
# He has n dollars. How many dollars does he have to borrow from his friend soldier to buy w bananas?
# 
# Input
# The first line contains three positive integers k, n, w (1  ≤  k, w  ≤  1000, 0 ≤ n ≤ 109), the cost of the first banana, initial number of dollars the soldier has and number of bananas he wants.
# 
# Output
# Output one integer — the amount of dollars that the soldier must borrow from his friend. If he doesn't have to borrow money, output 0.
# 
# Examples
# inputCopy
# 3 17 4
# outputCopy
# 13
import sys
k, n, w = map(int, sys.stdin.readline().rstrip().split())
total: int = 0
for i in range(1, w + 1):
    total += i * k
sys.stdout.write(str(max(0, total - n)))

# Simple Fun #150: Robot Transfer
# Task
# We have a N×N matrix (N<10) and a robot.
#
# We wrote in each point of matrix x and y coordinates of a point of matrix.
#
# When robot goes to a point of matrix, reads x and y and transfer to point with x and y coordinates.
#
# For each point in the matrix we want to know if robot returns back to it after EXACTLY k moves. So your task is to count points to which Robot returns in EXACTLY k moves.
#
# You should stop counting moves as soon as the robot returns to the starting point. That is, if the robot returns to the starting point in fewer than k moves, that point should not count as a valid point.
#
# example
# For:
#
# matrix=[
# ["0,1","0,0","1,2"],
# ["1,1","1,0","0,2"],
# ["2,1","2,0","0,0"]]
# k= 2
# The result should be 8
#
# Robot start at (0,0) --> (0,1) --> (0,0), total 2 moves
# Robot start at (0,1) --> (0,0) --> (0,1), total 2 moves
# Robot start at (0,2) --> (1,2) --> (0,2), total 2 moves
# Robot start at (1,2) --> (0,2) --> (1,2), total 2 moves
# Robot start at (1,0) --> (1,1) --> (1,0), total 2 moves
# Robot start at (1,1) --> (1,0) --> (1,1), total 2 moves
# Robot start at (2,0) --> (2,1) --> (2,0), total 2 moves
# Robot start at (2,1) --> (2,0) --> (2,1), total 2 moves
# Robot start at (2,2) --> (0,0) --> (0,1) --> (0,0) --> (0,1) ....
# (Robot can not transfer back to 2,2)
# So the result is 8.
#
# Input/Output
# [input] 2D integer array matrix
# n x n matrix. 3 <= n <=9
#
# [input] integer k
# 2 <= k <= 5
#
# [output] an integer
# PUZZLES
def robot_transfer(matrix, k):
    correct_cells: int = 0
    for row in range(len(matrix)):
        for col in range(len(matrix[0])):
            moving_point = row, col
            for _ in range(k):
                moving_point = tuple(map(int, matrix[moving_point[0]][moving_point[1]].split(',')))
                if moving_point == (row, col):
                    if _ + 1 == k: correct_cells += 1
                    break
    return correct_cells

# A. Word
# A. Word
# time limit per test2 seconds
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# Vasya is very upset that many people on the Net mix uppercase and lowercase letters in one word. That's why he decided to invent an extension for his favorite browser that would change the letters' register in every word so that it either only consisted of lowercase letters or, vice versa, only of uppercase ones. At that as little as possible letters should be changed in the word. For example, the word HoUse must be replaced with house, and the word ViP — with VIP. If a word contains an equal number of uppercase and lowercase letters, you should replace all the letters with lowercase ones. For example, maTRIx should be replaced by matrix. Your task is to use the given method on one given word.
#
# Input
# The first line contains a word s — it consists of uppercase and lowercase Latin letters and possesses the length from 1 to 100.
#
# Output
# Print the corrected word s. If the given word s has strictly more uppercase letters, make the word written in the uppercase register, otherwise - in the lowercase one.
#
# Examples
# inputCopy
# HoUse
# outputCopy
# house
# inputCopy
# ViP
# outputCopy
# VIP
# inputCopy
# maTRIx
# outputCopy
# matrix
import sys
n: str = sys.stdin.readline().rstrip()
low_case = upp_case = 0
for i in n:
    if i.islower(): low_case += 1
    else: upp_case += 1
sys.stdout.write(n.lower() if low_case >= upp_case else n.upper())

# 846. Hand of Straights
# Alice has some number of cards and she wants to rearrange the cards into groups so that each group is of size groupSize, and consists of groupSize consecutive cards.
#
# Given an integer array hand where hand[i] is the value written on the ith card and an integer groupSize, return true if she can rearrange the cards, or false otherwise.
#
#
#
# Example 1:
#
# Input: hand = [1,2,3,6,2,3,4,7,8], groupSize = 3
# Output: true
# Explanation: Alice's hand can be rearranged as [1,2,3],[2,3,4],[6,7,8]
# Example 2:
#
# Input: hand = [1,2,3,4,5], groupSize = 4
# Output: false
# Explanation: Alice's hand can not be rearranged into groups of 4.
#
#
#
# Constraints:
#
# 1 <= hand.length <= 104
# 0 <= hand[i] <= 109
# 1 <= groupSize <= hand.length
#
#
# Note: This question is the same as 1296: https://leetcode.com/problems/divide-array-in-sets-of-k-consecutive-numbers/
 from collections import defaultdict
class Solution:
    def isNStraightHand(self, hand: List[int], groupSize: int) -> bool:
        if len(hand) % groupSize != 0: return False
        ht: dict[int, int] = defaultdict(int)
        for i in hand: ht[i] += 1
        for i in sorted(ht.keys()):
            if ht[i] > 0:
                needed: int = ht[i]
                for number in range(i, i + groupSize):
                    if ht[number] < needed: return False
                    ht[number] -= needed
        return True

# 1296. Divide Array in Sets of K Consecutive Numbers
# Given an array of integers nums and a positive integer k, check whether it is possible to divide this array into sets of k consecutive numbers.
#
# Return true if it is possible. Otherwise, return false.
#
#
#
# Example 1:
#
# Input: nums = [1,2,3,3,4,4,5,6], k = 4
# Output: true
# Explanation: Array can be divided into [1,2,3,4] and [3,4,5,6].
# Example 2:
#
# Input: nums = [3,2,1,2,3,4,3,4,5,9,10,11], k = 3
# Output: true
# Explanation: Array can be divided into [1,2,3] , [2,3,4] , [3,4,5] and [9,10,11].
# Example 3:
#
# Input: nums = [1,2,3,4], k = 3
# Output: false
# Explanation: Each array should be divided in subarrays of size 3.
#
#
# Constraints:
#
# 1 <= k <= nums.length <= 105
# 1 <= nums[i] <= 109
#
#
# Note: This question is the same as 846: https://leetcode.com/problems/hand-of-straights/
from collections import defaultdict
class Solution:
    def isPossibleDivide(self, nums: List[int], k: int) -> bool:
        if len(nums) % k != 0: return False
        ht: dict[int, int] = defaultdict(int)
        for number in nums: ht[number] += 1
        for current_number in sorted(ht.keys()):
            if ht[current_number] > 0:
                needed_amount: int = ht[current_number]
                for number in range(current_number, current_number + k):
                    if number not in ht: return False
                    elif ht[number] < needed_amount: return False
                    ht[number] -= needed_amount
        return True
        
# Even or Odd Accessor
# Create a function that takes an integer as an argument and returns "Even" for even numbers or "Odd" for odd numbers. The function should also return "Even" or "Odd" when accessing a value at an integer index.
#
# For example:
#
# evenOrOdd(2); //'Even'
# evenOrOdd[2]; //'Even'
# evenOrOdd(7); //'Odd'
# evenOrOdd[7]; //'Odd'
# MATHEMATICSFUNDAMENTALS
class EvenOrOdd:
    def __call__(self, number):
        return "Even" if number % 2 == 0 else "Odd"

    def __getitem__(self, number):
        return self(number)
even_or_odd = EvenOrOdd()

# A. Wrong Subtraction
# A. Wrong Subtraction
# time limit per test1 second
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# Little girl Tanya is learning how to decrease a number by one, but she does it wrong with a number consisting of two or more digits. Tanya subtracts one from a number by the following algorithm:
#
# if the last digit of the number is non-zero, she decreases the number by one;
# if the last digit of the number is zero, she divides the number by 10 (i.e. removes the last digit).
# You are given an integer number n
# . Tanya will subtract one from it k
#  times. Your task is to print the result after all k
#  subtractions.
#
# It is guaranteed that the result will be positive integer number.
#
# Input
# The first line of the input contains two integer numbers n
#  and k
#  (2≤n≤109
# , 1≤k≤50
# ) — the number from which Tanya will subtract and the number of subtractions correspondingly.
#
# Output
# Print one integer number — the result of the decreasing n
#  by one k
#  times.
#
# It is guaranteed that the result will be positive integer number.
#
# Examples
# inputCopy
# 512 4
# outputCopy
# 50
# inputCopy
# 1000000000 9
# outputCopy
# 1
# Note
# The first example corresponds to the following sequence: 512→511→510→51→50
# .
import sys
n, k = map(int, sys.stdin.readline().rstrip().split())
for _ in range(k):
    last = n % 10
    if last == 0: n //= 10
    else: n -= 1
sys.stdout.write(str(n))

# 648. Replace Words
# In English, we have a concept called root, which can be followed by some other word to form another longer word - let's call this word derivative. For example, when the root "help" is followed by the word "ful", we can form a derivative "helpful".
# 
# Given a dictionary consisting of many roots and a sentence consisting of words separated by spaces, replace all the derivatives in the sentence with the root forming it. If a derivative can be replaced by more than one root, replace it with the root that has the shortest length.
# 
# Return the sentence after the replacement.
# 
#  
# 
# Example 1:
# 
# Input: dictionary = ["cat","bat","rat"], sentence = "the cattle was rattled by the battery"
# Output: "the cat was rat by the bat"
# Example 2:
# 
# Input: dictionary = ["a","b","c"], sentence = "aadsfasf absbs bbab cadsfafs"
# Output: "a a b c"
#  
# 
# Constraints:
# 
# 1 <= dictionary.length <= 1000
# 1 <= dictionary[i].length <= 100
# dictionary[i] consists of only lower-case letters.
# 1 <= sentence.length <= 106
# sentence consists of only lower-case letters and spaces.
# The number of words in sentence is in the range [1, 1000]
# The length of each word in sentence is in the range [1, 1000]
# Every two consecutive words in sentence will be separated by exactly one space.
# sentence does not have leading or trailing spaces.
class Solution:
    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        hs: set[str] = set()
        len_max_word: int = 0
        for word in dictionary:
            len_max_word = max(len_max_word, len(word))
            hs.add(word)
        output: list[str] = []
        for word in sentence.split():
            idx: int = 0
            matched: bool = False
            while idx < len_max_word:
                if word[:idx + 1] in hs:
                    matched = True
                    output.append(word[:idx + 1])
                    break
                idx += 1
            if not matched: output.append(word)
        return ' '.join(output)
    
# Thinking & Testing : Sport Star
# No Story
#
# No Description
#
# Only by Thinking and Testing
#
# Look at result of testcase, guess the code!
#
# Series:
# A and B?
# Incomplete string
# True or False
# Something capitalized
# Uniq or not Uniq
# Spatiotemporal index
# Math of Primary School
# Math of Middle school
# From nothingness To nothingness
# Not perfect? Throw away!
# Welcome to take the bus
# A happy day will come
# Sum of 15(Hetu Luosliu)
# Nebula or Vortex
# Sport Star
# Falsetto Rap Concert
# Wind whispers
# Mobile phone simulator
# Join but not join
# I hate big and small
# I want to become diabetic ;-)
# How many blocks?
# Operator hidden in a string
# Substring Magic
# Report about something
# Retention and discard I
# Retention and discard II
# How many "word"?
# Hail and Waterfall
# Love Forever
# Digital swimming pool
# Archery contest
# The repair of parchment
# Who are you?
# Safe position
# Special recommendation
# Another series, innovative and interesting, medium difficulty. People who like challenges, can try these kata:
#
# Play Tetris : Shape anastomosis
# Play FlappyBird : Advance Bravely
# PUZZLESGAMES
def testit(act, s):
    return ''.join('x' if (s[i] == '_' and act[i] != 'run') else '/' if (s[i] == '|' and act[i] != 'jump') else s[i] for i in range(len(s)))

# 523. Continuous Subarray Sum
# Given an integer array nums and an integer k, return true if nums has a good subarray or false otherwise.
#
# A good subarray is a subarray where:
#
# its length is at least two, and
# the sum of the elements of the subarray is a multiple of k.
# Note that:
#
# A subarray is a contiguous part of the array.
# An integer x is a multiple of k if there exists an integer n such that x = n * k. 0 is always a multiple of k.
#
#
# Example 1:
#
# Input: nums = [23,2,4,6,7], k = 6
# Output: true
# Explanation: [2, 4] is a continuous subarray of size 2 whose elements sum up to 6.
# Example 2:
#
# Input: nums = [23,2,6,4,7], k = 6
# Output: true
# Explanation: [23, 2, 6, 4, 7] is an continuous subarray of size 5 whose elements sum up to 42.
# 42 is a multiple of 6 because 42 = 7 * 6 and 7 is an integer.
# Example 3:
#
# Input: nums = [23,2,6,4,7], k = 13
# Output: false
#
#
# Constraints:
#
# 1 <= nums.length <= 105
# 0 <= nums[i] <= 109
# 0 <= sum(nums[i]) <= 231 - 1
# 1 <= k <= 231 - 1
class Solution:
    def checkSubarraySum(self, nums: List[int], k: int) -> bool:
        hs: set[int] = set()
        previous_remainder: int = 0
        total_sum: int = 0
        for number in nums:
            total_sum += number
            remainder: int = total_sum % k
            if remainder in hs: return True
            hs.add(previous_remainder)
            previous_remainder = remainder
        return False

# A. Young Physicist
# A. Young Physicist
# time limit per test2 seconds
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# A guy named Vasya attends the final grade of a high school. One day Vasya decided to watch a match of his favorite hockey team. And, as the boy loves hockey very much, even more than physics, he forgot to do the homework. Specifically, he forgot to complete his physics tasks. Next day the teacher got very angry at Vasya and decided to teach him a lesson. He gave the lazy student a seemingly easy task: You are given an idle body in space and the forces that affect it. The body can be considered as a material point with coordinates (0; 0; 0). Vasya had only to answer whether it is in equilibrium. "Piece of cake" — thought Vasya, we need only to check if the sum of all vectors is equal to 0. So, Vasya began to solve the problem. But later it turned out that there can be lots and lots of these forces, and Vasya can not cope without your help. Help him. Write a program that determines whether a body is idle or is moving by the given vectors of forces.
#
# Input
# The first line contains a positive integer n (1 ≤ n ≤ 100), then follow n lines containing three integers each: the xi coordinate, the yi coordinate and the zi coordinate of the force vector, applied to the body ( - 100 ≤ xi, yi, zi ≤ 100).
#
# Output
# Print the word "YES" if the body is in equilibrium, or the word "NO" if it is not.
#
# Examples
# inputCopy
# 3
# 4 1 7
# -2 4 -1
# 1 -5 -3
# outputCopy
# NO
# inputCopy
# 3
# 3 -1 7
# -5 2 -4
# 2 -1 -3
# outputCopy
# YES
import sys
n: int = int(sys.stdin.readline().rstrip())
s_x = s_y = s_z = 0
for _ in range(n):
    x, y, z = map(int, sys.stdin.readline().rstrip().split())
    s_x += x
    s_y += y
    s_z += z
sys.stdout.write(['NO', 'YES'][s_x == s_y == s_x == 0])

# British vs Slovakian postcodes
# Task
# Write a function called which_postcode/whichPostcode that takes a string, and determines whether it represents a British or Slovakian postcode. If the string is a valid British postcode, return "GB". If it's a valid Slovakian postcode, return "SK". If the input is neither a valid British nor a valid Slovakian postcode, return "Not valid".
#
# Leading and trailing spaces should be ignored, but if there are spaces in wrong place in the middle of the postcode, then it is invalid.
#
# The input will always be a valid British postcode, a valid Slovakian postcode or an invalid postcode.
#
# British Postcodes
# To be considered valid, a British postcode must follow the rules below:
#
# Consists a mix of letters and numbers, seperated to two segments by a single space.
# First segment must start with either 1 or 2 letters, followed by 1 or 2 numbers. Example: G4, G40, DN4 or DN11
# Second segment must start with a digit, followed by 2 letters. Example: 1AB
# British postcodes are not case-sensitive, so Se21 7aA is a valid postcode.
#
# Slovakian Postcodes
# Consists of 5 numbers, where the first 3 are seperated by a space from the last 2 numbers. Example: 123 45.
# Examples
# Valid British postcodes:
#   G4 7AH
# G12 8NU
# Dn1 1aA
# SE21 7AA
# Valid Slovakian postcodes:
#  040 01
# 810 08
# 984 59
# Invalid postcodes:
# 0765 820 - Should only have 3 numbers in the first segment, 2 numbers in the second segment
# SE 21 7AA - Should only contain 2 segments
# 070  08 - Should have single space separating the two segments, not double space
# REGULAR EXPRESSIONSSTRINGS
from string import digits, ascii_lowercase, ascii_uppercase
STRING = ascii_lowercase + ascii_uppercase
def check_british_postcode(postcode):
    if postcode.count(' ') != 1: return False
    first, second = postcode.split()
    letters = dgts = ''
    while first and first[0] in STRING:
        letters += first[0]
        first = first[1:]
    while first and first[0] in digits:
        dgts += first[0]
        first = first[1:]
    if first: return False
    if any(len(i) not in {1, 2} for i in [letters, dgts]): return False
    if len(second) != 3: return False
    if second[0] not in digits: return False
    if not all(i in STRING for i in second[1:]): return False
    return True

def check_slovakian_postcode(postcode):
    if len(postcode) != 6: return False
    if postcode.count(' ') != 1: return False
    first, second = postcode.split()
    if len(first) != 3: return False
    return all(i in digits for i in first + second)

def which_postcode(postcode):
    postcode = postcode.strip()
    if check_british_postcode(postcode): return 'GB'
    elif check_slovakian_postcode(postcode): return 'SK'
    return 'Not valid'

# 3174. Clear Digits
# You are given a string s.
#
# Your task is to remove all digits by doing this operation repeatedly:
#
# Delete the first digit and the closest non-digit character to its left.
# Return the resulting string after removing all digits.
#
#
#
# Example 1:
#
# Input: s = "abc"
#
# Output: "abc"
#
# Explanation:
#
# There is no digit in the string.
#
# Example 2:
#
# Input: s = "cb34"
#
# Output: ""
#
# Explanation:
#
# First, we apply the operation on s[2], and s becomes "c4".
#
# Then we apply the operation on s[1], and s becomes "".
#
#
#
# Constraints:
#
# 1 <= s.length <= 100
# s consists only of lowercase English letters and digits.
# The input is generated such that it is possible to delete all digits.
class Solution:
    def clearDigits(self, s: str) -> str:
        stack: list[str] = []
        for i in s:
            if i.isdigit():
                stack.pop()
            else:
                stack += i
        return ''.join(stack)

# 3175. Find The First Player to win K Games in a Row
# A competition consists of n players numbered from 0 to n - 1.
#
# You are given an integer array skills of size n and a positive integer k, where skills[i] is the skill level of player i. All integers in skills are unique.
#
# All players are standing in a queue in order from player 0 to player n - 1.
#
# The competition process is as follows:
#
# The first two players in the queue play a game, and the player with the higher skill level wins.
# After the game, the winner stays at the beginning of the queue, and the loser goes to the end of it.
# The winner of the competition is the first player who wins k games in a row.
#
# Return the initial index of the winning player.
#
#
#
# Example 1:
#
# Input: skills = [4,2,6,3,9], k = 2
#
# Output: 2
#
# Explanation:
#
# Initially, the queue of players is [0,1,2,3,4]. The following process happens:
#
# Players 0 and 1 play a game, since the skill of player 0 is higher than that of player 1, player 0 wins. The resulting queue is [0,2,3,4,1].
# Players 0 and 2 play a game, since the skill of player 2 is higher than that of player 0, player 2 wins. The resulting queue is [2,3,4,1,0].
# Players 2 and 3 play a game, since the skill of player 2 is higher than that of player 3, player 2 wins. The resulting queue is [2,4,1,0,3].
# Player 2 won k = 2 games in a row, so the winner is player 2.
#
# Example 2:
#
# Input: skills = [2,5,4], k = 3
#
# Output: 1
#
# Explanation:
#
# Initially, the queue of players is [0,1,2]. The following process happens:
#
# Players 0 and 1 play a game, since the skill of player 1 is higher than that of player 0, player 1 wins. The resulting queue is [1,2,0].
# Players 1 and 2 play a game, since the skill of player 1 is higher than that of player 2, player 1 wins. The resulting queue is [1,0,2].
# Players 1 and 0 play a game, since the skill of player 1 is higher than that of player 0, player 1 wins. The resulting queue is [1,2,0].
# Player 1 won k = 3 games in a row, so the winner is player 1.
#
#
#
# Constraints:
#
# n == skills.length
# 2 <= n <= 105
# 1 <= k <= 109
# 1 <= skills[i] <= 106
# All integers in skills are unique.
# One Pass
# Complexity
# Time complexity: O(N)
# Space complexity: O(1)
# Code
class Solution:
    def findWinningPlayer(self, skills: List[int], k: int) -> int:
        winner: int = skills[0]
        in_a_row: int = 0
        for player in skills[1:]:
            in_a_row = in_a_row + 1 if winner > player else 1
            winner = max(winner, player)
            if in_a_row == k: break
        return skills.index(winner)

# Simulation
# Complexity
# Time complexity: O(10**5) == O(N)
# Space complexity: O(N)
# Code
from collections import deque, defaultdict
class Solution:
    def findWinningPlayer(self, skills: List[int], k: int) -> int:
        queue = deque(range(len(skills)))
        queue_score = deque(skills)
        ht = defaultdict(int)
        idx = 0
        while idx < 10**5:
            idx += 1
            first, second = queue.popleft(), queue.popleft()
            first_score, second_score = queue_score.popleft(), queue_score.popleft()
            if first_score > second_score:
                ht[first] +=1
                if ht[first] >= k: return first
                ht[second] = 0
                queue.appendleft(first)
                queue_score.appendleft(first_score)
                queue.append(second)
                queue_score.append(second_score)
            else:
                ht[second] += 1
                if ht[second] >= k: return second
                ht[first] = 0
                queue.appendleft(second)
                queue_score.appendleft(second_score)
                queue.append(first)
                queue_score.append(first_score)
        return queue.popleft()

# 974. Subarray Sums Divisible by K
# Given an integer array nums and an integer k, return the number of non-empty subarrays that have a sum divisible by k.
# 
# A subarray is a contiguous part of an array.
# 
#  
# 
# Example 1:
# 
# Input: nums = [4,5,0,-2,-3,1], k = 5
# Output: 7
# Explanation: There are 7 subarrays with a sum divisible by k = 5:
# [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]
# Example 2:
# 
# Input: nums = [5], k = 9
# Output: 0
#  
# 
# Constraints:
# 
# 1 <= nums.length <= 3 * 104
# -104 <= nums[i] <= 104
# 2 <= k <= 104
from collections import defaultdict
class Solution:
    def subarraysDivByK(self, nums: List[int], k: int) -> int:
        prefix_sum: int = 0
        ht: dict[int] = defaultdict(int)
        ht[0] = 1
        count: int = 0
        for number in nums:
            prefix_sum += number
            remainder = prefix_sum % k
            if remainder in ht:
                count += ht[remainder]
            ht[remainder] += 1
        return count

# A. Football
# A. Football
# time limit per test2 seconds
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# Petya loves football very much. One day, as he was watching a football match, he was writing the players' current positions on a piece of paper. To simplify the situation he depicted it as a string consisting of zeroes and ones. A zero corresponds to players of one team; a one corresponds to players of another team. If there are at least 7 players of some team standing one after another, then the situation is considered dangerous. For example, the situation 00100110111111101 is dangerous and 11110111011101 is not. You are given the current situation. Determine whether it is dangerous or not.
#
# Input
# The first input line contains a non-empty string consisting of characters "0" and "1", which represents players. The length of the string does not exceed 100 characters. There's at least one player from each team present on the field.
#
# Output
# Print "YES" if the situation is dangerous. Otherwise, print "NO".
#
# Examples
# inputCopy
# 001001
# outputCopy
# NO
# inputCopy
# 1000000001
# outputCopy
# YES
# O(N) O(1)
import sys
n: str = sys.stdin.readline().rstrip()
row: int = 1
row_val: str = n[0]
dangerous: bool = False
for i in n[1:]:
    if i == row_val:
        row += 1
        if row == 7: dangerous = True
    else:
        row, row_val = 1, i
sys.stdout.write(['NO', 'YES'][dangerous])
# Builtin functions O(N) O(1)
import sys
n: str = sys.stdin.readline().rstrip()
sys.stdout.write(['NO', 'YES']['1111111' in n or '0000000' in n])

# 3178. Find the Child Who Has the Ball After K Seconds
# You are given two positive integers n and k. There are n children numbered from 0 to n - 1 standing in a queue in order from left to right.
#
# Initially, child 0 holds a ball and the direction of passing the ball is towards the right direction. After each second, the child holding the ball passes it to the child next to them. Once the ball reaches either end of the line, i.e. child 0 or child n - 1, the direction of passing is reversed.
#
# Return the number of the child who receives the ball after k seconds.
#
#
#
# Example 1:
#
# Input: n = 3, k = 5
#
# Output: 1
#
# Explanation:
#
# Time elapsed	Children
# 0	[0, 1, 2]
# 1	[0, 1, 2]
# 2	[0, 1, 2]
# 3	[0, 1, 2]
# 4	[0, 1, 2]
# 5	[0, 1, 2]
# Example 2:
#
# Input: n = 5, k = 6
#
# Output: 2
#
# Explanation:
#
# Time elapsed	Children
# 0	[0, 1, 2, 3, 4]
# 1	[0, 1, 2, 3, 4]
# 2	[0, 1, 2, 3, 4]
# 3	[0, 1, 2, 3, 4]
# 4	[0, 1, 2, 3, 4]
# 5	[0, 1, 2, 3, 4]
# 6	[0, 1, 2, 3, 4]
# Example 3:
#
# Input: n = 4, k = 2
#
# Output: 2
#
# Explanation:
#
# Time elapsed	Children
# 0	[0, 1, 2, 3]
# 1	[0, 1, 2, 3]
# 2	[0, 1, 2, 3]
#
#
# Constraints:
#
# 2 <= n <= 50
# 1 <= k <= 50
class Solution:
    def numberOfChild(self, n: int, k: int) -> int:
        reverse: bool = False
        cur: int = 0
        for _ in range(k):
            cur += 1 if not reverse else -1
            if cur == n - 1:
                reverse = True
            elif cur == 0:
                reverse = False
        return cur

# 3179. Find the N-th Value After K Seconds
# You are given two integers n and k.
#
# Initially, you start with an array a of n integers where a[i] = 1 for all 0 <= i <= n - 1. After each second, you simultaneously update each element to be the sum of all its preceding elements plus the element itself. For example, after one second, a[0] remains the same, a[1] becomes a[0] + a[1], a[2] becomes a[0] + a[1] + a[2], and so on.
#
# Return the value of a[n - 1] after k seconds.
#
# Since the answer may be very large, return it modulo 109 + 7.
#
#
#
# Example 1:
#
# Input: n = 4, k = 5
#
# Output: 56
#
# Explanation:
#
# Second	State After
# 0	[1,1,1,1]
# 1	[1,2,3,4]
# 2	[1,3,6,10]
# 3	[1,4,10,20]
# 4	[1,5,15,35]
# 5	[1,6,21,56]
# Example 2:
#
# Input: n = 5, k = 3
#
# Output: 35
#
# Explanation:
#
# Second	State After
# 0	[1,1,1,1,1]
# 1	[1,2,3,4,5]
# 2	[1,3,6,10,15]
# 3	[1,4,10,20,35]
#
#
# Constraints:
#
# 1 <= n, k <= 1000
class Solution:
    def fill_array(self, arr: list[int]) -> None:
        for i in range(len(arr)):
            arr[i] = arr[i] + (arr[i - 1] if i - 1 >= 0 else 0)
    def valueAfterKSeconds(self, n: int, k: int) -> int:
        prefix_sum: list[int] = [1 for _ in range(n)]
        for _ in range(k):
            self.fill_array(prefix_sum)
        return prefix_sum[-1] % (10**9+7)

# [Code Golf] Gobang Weight Table
# Gobang Weight Table
# You will generate a weight table of gobang game in less than 100 characters. The outermost layer of the table is 0, and the number is incremented by one for each layer inside.
#
# Your task is to define a function, which returns weight table in different sizes(N) as the examples below.
#
# Examples:
# Input: 3
# Output:
# [[0, 0, 0],
#  [0, 1, 0],
#  [0, 0, 0]]
# Input: 5
# Output:
# [[0, 0, 0, 0, 0],
#  [0, 1, 1, 1, 0],
#  [0, 1, 2, 1, 0],
#  [0, 1, 1, 1, 0],
#  [0, 0, 0, 0, 0]]
# Input: 9
# Output:
# [[0, 0, 0, 0, 0, 0, 0, 0, 0],
#  [0, 1, 1, 1, 1, 1, 1, 1, 0],
#  [0, 1, 2, 2, 2, 2, 2, 1, 0],
#  [0, 1, 2, 3, 3, 3, 2, 1, 0],
#  [0, 1, 2, 3, 4, 3, 2, 1, 0],
#  [0, 1, 2, 3, 3, 3, 2, 1, 0],
#  [0, 1, 2, 2, 2, 2, 2, 1, 0],
#  [0, 1, 1, 1, 1, 1, 1, 1, 0],
#  [0, 0, 0, 0, 0, 0, 0, 0, 0]]
# Notes
# 3 <= N <= 99, N will ONLY be odd number.
# Your code cannot be longer than 100 characters.
# RESTRICTEDPUZZLES
def weight_table(n):return[[min(i,n-1-i,j,n-1-j)for j in range(n)]for i in range(n)]

# 1051. Height Checker
# A school is trying to take an annual photo of all the students. The students are asked to stand in a single file line in non-decreasing order by height. Let this ordering be represented by the integer array expected where expected[i] is the expected height of the ith student in line.
#
# You are given an integer array heights representing the current order that the students are standing in. Each heights[i] is the height of the ith student in line (0-indexed).
#
# Return the number of indices where heights[i] != expected[i].
#
#
#
# Example 1:
#
# Input: heights = [1,1,4,2,1,3]
# Output: 3
# Explanation:
# heights:  [1,1,4,2,1,3]
# expected: [1,1,1,2,3,4]
# Indices 2, 4, and 5 do not match.
# Example 2:
#
# Input: heights = [5,1,2,3,4]
# Output: 5
# Explanation:
# heights:  [5,1,2,3,4]
# expected: [1,2,3,4,5]
# All indices do not match.
# Example 3:
#
# Input: heights = [1,2,3,4,5]
# Output: 0
# Explanation:
# heights:  [1,2,3,4,5]
# expected: [1,2,3,4,5]
# All indices match.
#
#
# Constraints:
#
# 1 <= heights.length <= 100
# 1 <= heights[i] <= 100
class Solution:
    def heightChecker(self, heights: List[int]) -> int:
        correct_height: list[int] = []
        total_students: list[int] = [0 for _ in range(max(heights) + 1)]
        for student in heights:
            total_students[student] += 1
        for student in range(len(total_students)):
            if total_students[student] > 0:
                correct_height += [student] * total_students[student]
        return sum(correct_height[idx] != heights[idx] for idx in range(len(heights)))

# A. Nearly Lucky NumberA. Nearly Lucky Number
# time limit per test2 seconds
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# Petya loves lucky numbers. We all know that lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.
#
# Unfortunately, not all numbers are lucky. Petya calls a number nearly lucky if the number of lucky digits in it is a lucky number. He wonders whether number n is a nearly lucky number.
#
# Input
# The only line contains an integer n (1 ≤ n ≤ 1018).
#
# Please do not use the %lld specificator to read or write 64-bit numbers in С++. It is preferred to use the cin, cout streams or the %I64d specificator.
#
# Output
# Print on the single line "YES" if n is a nearly lucky number. Otherwise, print "NO" (without the quotes).
#
# Examples
# inputCopy
# 40047
# outputCopy
# NO
# inputCopy
# 7747774
# outputCopy
# YES
# inputCopy
# 1000000000000000000
# outputCopy
# NO
# Note
# In the first sample there are 3 lucky digits (first one and last two), so the answer is "NO".
#
# In the second sample there are 7 lucky digits, 7 is lucky number, so the answer is "YES".
#
# In the third sample there are no lucky digits, so the answer is "NO".
import sys
n: str = sys.stdin.readline().rstrip()
count: int = 0
for i in n:
    if i in {'4', '7'}:
        count += 1
sys.stdout.write(['NO', 'YES'][count in {4, 7}])

# Basic Bounding Box
# You are given an image represented as a binary array. Your task is to predict the bounding box that encloses all the 1s within the image. The bounding box should be a hollow rectangle, where only the edges of the bounding box are 1s, and the interior is filled with 0s returned in an array of the same size as the original input.
#
# You can make the following assumptions:
#
# An image will only ever be comprised of 0s or 1s.
# An image will always have a consistent m x n shape.
# Important things to remember:
#
# If an empty image is passed, then an empty array should also be returned.
# If there are no 1s present then no bounding box should be drawn.
# Example
# Input:
# [[0,0,0,0,0,0,0,0,0,0],
#  [0,0,0,0,0,0,0,0,0,0],
#  [0,0,0,0,0,0,0,0,0,0],
#  [0,0,0,0,0,0,0,0,0,0],
#  [0,0,0,0,0,0,0,0,0,0],
#  [0,0,0,0,1,1,0,0,0,0],
#  [0,0,0,1,1,1,1,0,0,0],
#  [0,0,1,1,1,1,1,1,0,0],
#  [0,1,1,1,1,1,0,0,0,0],
#  [0,0,0,0,0,0,0,0,0,0]]
# Output:
#
# [[0,0,0,0,0,0,0,0,0,0],
#  [0,0,0,0,0,0,0,0,0,0],
#  [0,0,0,0,0,0,0,0,0,0],
#  [0,0,0,0,0,0,0,0,0,0],
#  [0,0,0,0,0,0,0,0,0,0],
#  [0,1,1,1,1,1,1,1,0,0],
#  [0,1,0,0,0,0,0,1,0,0],
#  [0,1,0,0,0,0,0,1,0,0],
#  [0,1,1,1,1,1,1,1,0,0],
#  [0,0,0,0,0,0,0,0,0,0]]
# ARRAYS
def bounding_box(image_array):
    if not image_array: return []
    most_left = most_up = float('inf')
    most_right = most_down = float('-inf')
    for row in range(len(image_array)):
        for col in range(len(image_array[0])):
            if image_array[row][col] == 1:
                most_left, most_right = min(most_left, col), max(most_right, col)
                most_up, most_down = min(most_up, row), max(most_down, row)
    for row in range(len(image_array)):
        for col in range(len(image_array[0])):
            if (row >= most_up and row <= most_down):
                if (row == most_up or row == most_down) and col >= most_left and col <= most_right:
                    image_array[row][col] = 1
                elif col == most_left or col == most_right:
                    image_array[row][col] = 1
                else: image_array[row][col] = 0
            else: image_array[row][col] = 0
    return image_array


# A. Anton and Danik
# A. Anton and Danik
# time limit per test1 second
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# Anton likes to play chess, and so does his friend Danik.
#
# Once they have played n games in a row. For each game it's known who was the winner — Anton or Danik. None of the games ended with a tie.
#
# Now Anton wonders, who won more games, he or Danik? Help him determine this.
#
# Input
# The first line of the input contains a single integer n (1 ≤ n ≤ 100 000) — the number of games played.
#
# The second line contains a string s, consisting of n uppercase English letters 'A' and 'D' — the outcome of each of the games. The i-th character of the string is equal to 'A' if the Anton won the i-th game and 'D' if Danik won the i-th game.
#
# Output
# If Anton won more games than Danik, print "Anton" (without quotes) in the only line of the output.
#
# If Danik won more games than Anton, print "Danik" (without quotes) in the only line of the output.
#
# If Anton and Danik won the same number of games, print "Friendship" (without quotes).
#
# Examples
# inputCopy
# 6
# ADAAAA
# outputCopy
# Anton
# inputCopy
# 7
# DDDAADA
# outputCopy
# Danik
# inputCopy
# 6
# DADADA
# outputCopy
# Friendship
# Note
# In the first sample, Anton won 6 games, while Danik — only 1. Hence, the answer is "Anton".
#
# In the second sample, Anton won 3 games and Danik won 4 games, so the answer is "Danik".
#
# In the third sample, both Anton and Danik won 3 games and the answer is "Friendship".
import sys
n: str = sys.stdin.readline().rstrip()
games: str = sys.stdin.readline().rstrip()
a, d = games.count('A'), games.count('D')
if a == d:
    sys.stdout.write('Friendship')
else:
    sys.stdout.write(['Danik', 'Anton'][a > d])
    
# 1122. Relative Sort Array
# Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr2 are also in arr1.
#
# Sort the elements of arr1 such that the relative ordering of items in arr1 are the same as in arr2. Elements that do not appear in arr2 should be placed at the end of arr1 in ascending order.
#
#
#
# Example 1:
#
# Input: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]
# Output: [2,2,2,1,4,3,3,9,6,7,19]
# Example 2:
#
# Input: arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6]
# Output: [22,28,8,6,17,44]
#
#
# Constraints:
#
# 1 <= arr1.length, arr2.length <= 1000
# 0 <= arr1[i], arr2[i] <= 1000
# All the elements of arr2 are distinct.
# Each arr2[i] is in arr1.
class Solution:
    def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]:
        bucket: list[int] = [0 for _ in range(max(arr1) + 1)]
        for number in arr1:
            bucket[number] += 1
        idx: int = 0
        for number in arr2:
            for _ in range(bucket[number]):
                arr1[idx] = number
                idx += 1
            bucket[number] = 0
        for number in range(len(bucket)):
            if bucket[number] > 0:
                for _ in range(bucket[number]):
                    arr1[idx] = number
                    idx += 1
        return arr1

# Simple Fun #341: Minimum Bonus
# Task
# International hackers group organized a programming competition, in which n teams participated.
#
# They were assigned to separate rooms for competitions, and the rooms were lined up in a straight line.
#
# The game was over and each team scored points. It's time to pay bonuses. The rule is:
#
# - The bonus unit is 1K($1000), and each team gets at least 1k.
# - The bonus payment process is not public.
# - A team can know the bonus amount of its adjacent team, if the
#   score of the adjacent team is lower than itself.
# - If a team finds that its bonus is no higher than the adjacent team whose
#   score is lower than itself, the team will not be satisfied
# Given an integer array scores represents the score of all teams. Your task is to calculate how much bonuses international hackers group need to pay to keep all teams satisfied.
#
# Note, the unit of bonus is 1K. All teams are in a straight line, and their order is the same as that of the array elements.
#
# Example
# For scores = [10,20,30], the output should be 6.
#
# team1's score = 10
# team2's score = 20
# team3's score = 30
#
# team1 can get 1K, The team was satisfied
# because it knew nothing about the other teams.
#
# team2 can know team1's bonus amount,
# So team2 at least get 2K to be satisfied
#
# team3 can know team2's bonus amount,
# So team3 at least get 3K to be satisfied
#
# 1 + 2 + 3 = 6
# For scores = [10,20,20,30], the output should be 6.
#
# The possible bonus amount of each team can be:[1,2,1,2]
#
# For scores = [20,30,10,30,40,10,20,30,40,30], the output should be 20.
#
# The possible bonus amount of each team can be:[1,2,1,2,3,1,2,3,4,1]
#
# ALGORITHMS
from collections import defaultdict
def minimum_bonus(scores):
    ht: dict[int, int] = defaultdict(int)
    for team in range(len(scores)):
        ht[team] += 1
    while True:
        swaped: bool = False
        for team in range(len(scores)):
            if team + 1 < len(scores) and scores[team] > scores[team + 1] and ht[team] <= ht[team + 1]:
                ht[team] = ht[team + 1] + 1
                swaped = True
            if team - 1 >= 0 and scores[team] > scores[team - 1] and ht[team] <= ht[team - 1]:
                ht[team] = ht[team - 1] + 1
                swaped = True
        if not swaped:
            return sum(ht.values())

# 63. Unique Paths II
# You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.
#
# An obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.
#
# Return the number of possible unique paths that the robot can take to reach the bottom-right corner.
#
# The testcases are generated so that the answer will be less than or equal to 2 * 109.
#
#
#
# Example 1:
#
#
# Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
# Output: 2
# Explanation: There is one obstacle in the middle of the 3x3 grid above.
# There are two ways to reach the bottom-right corner:
# 1. Right -> Right -> Down -> Down
# 2. Down -> Down -> Right -> Right
# Example 2:
#
#
# Input: obstacleGrid = [[0,1],[0,0]]
# Output: 1
#
#
# Constraints:
#
# m == obstacleGrid.length
# n == obstacleGrid[i].length
# 1 <= m, n <= 100
# obstacleGrid[i][j] is 0 or 1.
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        m, n = len(obstacleGrid), len(obstacleGrid[0])
        if obstacleGrid[m - 1][n - 1] == 1: return 0
        prev_row = [0] * n
        prev_row[n - 1] = 1
        for row in range(m - 1, -1, -1):
            current_row = [0] * n
            current_row[n - 1] = 0 if obstacleGrid[row][n - 1] == 1 else prev_row[n - 1]
            for col in range(n - 2, -1, -1):
                if obstacleGrid[row][col] == 1: continue
                current_row[col] = current_row[col + 1] + prev_row[col]
            prev_row = current_row
        return prev_row[0]

# 198. House Robber
# You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.
#
# Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.
#
#
#
# Example 1:
#
# Input: nums = [1,2,3,1]
# Output: 4
# Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
# Total amount you can rob = 1 + 3 = 4.
# Example 2:
#
# Input: nums = [2,7,9,3,1]
# Output: 12
# Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
# Total amount you can rob = 2 + 9 + 1 = 12.
#
#
# Constraints:
#
# 1 <= nums.length <= 100
# 0 <= nums[i] <= 400
# HashMap
# Complexity
# Time complexity: O(N)
# Space complexity: O(N)
# Code
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return nums[0]
        cache: dict[int, int] = {0: nums[0], 1: nums[1]}
        for idx in range(2, len(nums)):
            cache[idx] = max(cache.get(idx - 2), cache.get(idx - 3, 0)) + nums[idx]
        return max(cache.values())

# Constant Memory Complexity
# Complexity
# Time complexity: O(N)
# Space complexity: O(1)
# Code
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 1: return nums[0]
        nums[1] = max(nums[0], nums[1])
        for idx in range(2, len(nums)):
            nums[idx] = max(nums[idx - 1], nums[idx] + nums[idx - 2])
        return nums[-1]

# 75. Sort Colors
# Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.
#
# We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.
#
# You must solve this problem without using the library's sort function.
#
#
#
# Example 1:
#
# Input: nums = [2,0,2,1,1,0]
# Output: [0,0,1,1,2,2]
# Example 2:
#
# Input: nums = [2,0,1]
# Output: [0,1,2]
#
#
# Constraints:
#
# n == nums.length
# 1 <= n <= 300
# nums[i] is either 0, 1, or 2.
#
#
# Follow up: Could you come up with a one-pass algorithm using only constant extra space?
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        n: int = len(nums)
        zeros, twos = 0, n - 1
        current_idx: int = 0
        while current_idx <= twos:
            while current_idx <= twos and nums[current_idx] == 0:
                if current_idx <= zeros:
                    current_idx += 1
                else:
                    nums[zeros], nums[current_idx] = nums[current_idx], nums[zeros]
                    zeros += 1
            while current_idx <= twos and nums[current_idx] == 2:
                nums[twos], nums[current_idx] = nums[current_idx], nums[twos]
                twos -= 1
            if current_idx < n and nums[current_idx] == 1:
                current_idx += 1
                
# A. Translation
# A. Translation
# time limit per test2 seconds
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# The translation from the Berland language into the Birland language is not an easy task. Those languages are very similar: a berlandish word differs from a birlandish word with the same meaning a little: it is spelled (and pronounced) reversely. For example, a Berlandish word code corresponds to a Birlandish word edoc. However, it's easy to make a mistake during the «translation». Vasya translated word s from Berlandish into Birlandish as t. Help him: find out if he translated the word correctly.
#
# Input
# The first line contains word s, the second line contains word t. The words consist of lowercase Latin letters. The input data do not consist unnecessary spaces. The words are not empty and their lengths do not exceed 100 symbols.
#
# Output
# If the word t is a word s, written reversely, print YES, otherwise print NO.
#
# Examples
# inputCopy
# code
# edoc
# outputCopy
# YES
# inputCopy
# abb
# aba
# outputCopy
# NO
# inputCopy
# code
# code
# outputCopy
# NO
import sys

def solution(t, s):
    len_t, len_s = len(t), len(s)
    if len_t != len_s:
        return 'NO'
    for idx in range(len_t):
        if t[idx] != s[-idx - 1]:
            return 'NO'
    return 'YES'

if __name__ == '__main__':
    t = sys.stdin.readline().rstrip()
    s = sys.stdin.readline().rstrip()
    answer = solution(t, s)
    sys.stdout.write(answer)

# Pyramid Slide Down
# Lyrics...
# Pyramids are amazing! Both in architectural and mathematical sense. If you have a computer, you can mess with pyramids even if you are not in Egypt at the time. For example, let's consider the following problem. Imagine that you have a pyramid built of numbers, like this one here:
#
#    /3/
#   \7\ 4
#  2 \4\ 6
# 8 5 \9\ 3
# Here comes the task...
# Let's say that the 'slide down' is the maximum sum of consecutive numbers from the top to the bottom of the pyramid. As you can see, the longest 'slide down' is 3 + 7 + 4 + 9 = 23
#
# Your task is to write a function that takes a pyramid representation as an argument and returns its largest 'slide down'. For example:
#
# * With the input `[[3], [7, 4], [2, 4, 6], [8, 5, 9, 3]]`
# * Your function should return `23`.
# By the way...
# My tests include some extraordinarily high pyramids so as you can guess, brute-force method is a bad idea unless you have a few centuries to waste. You must come up with something more clever than that.
#
# (c) This task is a lyrical version of Problem 18 and/or Problem 67 on ProjectEuler.
#
# ALGORITHMSDYNAMIC PROGRAMMING
def longest_slide_down(pyramid):
    prev_row = pyramid[-1]
    for row in range(len(pyramid) - 2, -1, -1):
        current_row = pyramid[row]
        for col in range(len(pyramid[row])):
            current_row[col] = max(
                prev_row[col], prev_row[col + 1]
            ) + current_row[col]
        prev_row = current_row
    return prev_row[0]

# A. Tram
# A. Tram
# time limit per test2 seconds
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# Linear Kingdom has exactly one tram line. It has n stops, numbered from 1 to n in the order of tram's movement. At the i-th stop ai passengers exit the tram, while bi passengers enter it. The tram is empty before it arrives at the first stop. Also, when the tram arrives at the last stop, all passengers exit so that it becomes empty.
#
# Your task is to calculate the tram's minimum capacity such that the number of people inside the tram at any time never exceeds this capacity. Note that at each stop all exiting passengers exit before any entering passenger enters the tram.
#
# Input
# The first line contains a single number n (2 ≤ n ≤ 1000) — the number of the tram's stops.
#
# Then n lines follow, each contains two integers ai and bi (0 ≤ ai, bi ≤ 1000) — the number of passengers that exits the tram at the i-th stop, and the number of passengers that enter the tram at the i-th stop. The stops are given from the first to the last stop in the order of tram's movement.
#
# The number of people who exit at a given stop does not exceed the total number of people in the tram immediately before it arrives at the stop. More formally, . This particularly means that a1 = 0.
# At the last stop, all the passengers exit the tram and it becomes empty. More formally, .
# No passenger will enter the train at the last stop. That is, bn = 0.
# Output
# Print a single integer denoting the minimum possible capacity of the tram (0 is allowed).
#
# Examples
# inputCopy
# 4
# 0 3
# 2 5
# 4 2
# 4 0
# outputCopy
# 6
# Note
# For the first example, a capacity of 6 is sufficient:
#
# At the first stop, the number of passengers inside the tram before arriving is 0. Then, 3 passengers enter the tram, and the number of passengers inside the tram becomes 3.
# At the second stop, 2 passengers exit the tram (1 passenger remains inside). Then, 5 passengers enter the tram. There are 6 passengers inside the tram now.
# At the third stop, 4 passengers exit the tram (2 passengers remain inside). Then, 2 passengers enter the tram. There are 4 passengers inside the tram now.
# Finally, all the remaining passengers inside the tram exit the tram at the last stop. There are no passenger inside the tram now, which is in line with the constraints.
# Since the number of passengers inside the tram never exceeds 6, a capacity of 6 is sufficient. Furthermore it is not possible for the tram to have a capacity less than 6. Hence, 6 is the correct answer.
import sys
n: int = int(sys.stdin.readline().rstrip())
max_people: int = -1
total: int = 0
for _ in range(n):
    a, b = map(int, sys.stdin.readline().rstrip().split())
    total += b - a
    max_people = max(max_people, total)
sys.stdout.write(str(max_people))

# Path Finder #1: can you reach the exit?
# Task
# You are at position [0, 0] in maze NxN and you can only move in one of the four cardinal directions (i.e. North, East, South, West). Return true if you can reach position [N-1, N-1] or false otherwise.
#
# Empty positions are marked ..
# Walls are marked W.
# Start and exit positions are empty in all test cases.
# Path Finder Series:
# #1: can you reach the exit?
# #2: shortest path
# #3: the Alpinist
# #4: where are you?
# #5: there's someone here
# ALGORITHMS
def path_finder(maze):
    maze = maze.split('\n')
    n = len(maze)
    queue = dict()
    queue[(n - 1, n - 1)] = 0
    cache = set()
    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    while queue:
        k, v = queue.popitem()
        current_row, current_col = k
        if current_row == current_col ==  0:
            return True
        cache.add((current_row, current_col))
        for move in moves:
            nxt_row, nxt_col = current_row + move[0], current_col + move[1]
            if (nxt_row, nxt_col) in cache:
                continue
            elif not (0 <= nxt_row < n) or not (0 <= nxt_col < n):
                continue
            elif maze[nxt_row][nxt_col] == 'W':
                continue
            queue[(nxt_row, nxt_col)] = 0
    return False

# A. Vanya and Fence
# A. Vanya and Fence
# time limit per test1 second
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# Vanya and his friends are walking along the fence of height h and they do not want the guard to notice them. In order to achieve this the height of each of the friends should not exceed h. If the height of some person is greater than h he can bend down and then he surely won't be noticed by the guard. The height of the i-th person is equal to ai.
#
# Consider the width of the person walking as usual to be equal to 1, while the width of the bent person is equal to 2. Friends want to talk to each other while walking, so they would like to walk in a single row. What is the minimum width of the road, such that friends can walk in a row and remain unattended by the guard?
#
# Input
# The first line of the input contains two integers n and h (1 ≤ n ≤ 1000, 1 ≤ h ≤ 1000) — the number of friends and the height of the fence, respectively.
#
# The second line contains n integers ai (1 ≤ ai ≤ 2h), the i-th of them is equal to the height of the i-th person.
#
# Output
# Print a single integer — the minimum possible valid width of the road.
#
# Examples
# inputCopy
# 3 7
# 4 5 14
# outputCopy
# 4
# inputCopy
# 6 1
# 1 1 1 1 1 1
# outputCopy
# 6
# inputCopy
# 6 5
# 7 6 8 9 10 5
# outputCopy
# 11
# Note
# In the first sample, only person number 3 must bend down, so the required width is equal to 1 + 1 + 2 = 4.
#
# In the second sample, all friends are short enough and no one has to bend, so the width 1 + 1 + 1 + 1 + 1 + 1 = 6 is enough.
#
# In the third sample, all the persons have to bend, except the last one. The required minimum width of the road is equal to 2 + 2 + 2 + 2 + 2 + 1 = 11.
import sys
n, h = map(int, sys.stdin.readline().rstrip().split())
friends = list(map(int, sys.stdin.readline().rstrip().split()))
total = 0
for fr in friends:
    if fr > h:
        total += 2
    else:
        total += 1
sys.stdout.write(str(total))

# Path Finder #2: shortest path
# Task
# You are at position [0, 0] in maze NxN and you can only move in one of the four cardinal directions (i.e. North, East, South, West). Return the minimal number of steps to exit position [N-1, N-1] if it is possible to reach the exit from the starting position. Otherwise, return false.
#
# Empty positions are marked .. Walls are marked W. Start and exit positions are guaranteed to be empty in all test cases.
#
# Path Finder Series:
# #1: can you reach the exit?
# #2: shortest path
# #3: the Alpinist
# #4: where are you?
# #5: there's someone here
# ALGORITHMS
from collections import deque
def path_finder(maze):
    maze = maze.split('\n')
    queue = deque()
    seen = set()
    queue.append((0, 0))
    seen.add((0, 0))
    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    length = 0
    n = len(maze)
    while queue:
        for _ in range(len(queue)):
            cur_r, cur_c = queue.popleft()
            if cur_r == cur_c == n - 1:
                return length
            for move in moves:
                nxt_r, nxt_c = cur_r + move[0], cur_c + move[1]
                if min(nxt_r, nxt_c) < 0 or max(nxt_r, nxt_c) >= n or maze[nxt_r][nxt_c] == 'W' or (nxt_r, nxt_c) in seen:
                    continue
                queue.append((nxt_r, nxt_c))
                seen.add((nxt_r, nxt_c))
        length += 1
    return False
    
# 1827. Minimum Operations to Make the Array Increasing
# You are given an integer array nums (0-indexed). In one operation, you can choose an element of the array and increment it by 1.
# 
# For example, if nums = [1,2,3], you can choose to increment nums[1] to make nums = [1,3,3].
# Return the minimum number of operations needed to make nums strictly increasing.
# 
# An array nums is strictly increasing if nums[i] < nums[i+1] for all 0 <= i < nums.length - 1. An array of length 1 is trivially strictly increasing.
# 
#  
# 
# Example 1:
# 
# Input: nums = [1,1,1]
# Output: 3
# Explanation: You can do the following operations:
# 1) Increment nums[2], so nums becomes [1,1,2].
# 2) Increment nums[1], so nums becomes [1,2,2].
# 3) Increment nums[2], so nums becomes [1,2,3].
# Example 2:
# 
# Input: nums = [1,5,2,4,1]
# Output: 14
# Example 3:
# 
# Input: nums = [8]
# Output: 0
#  
# 
# Constraints:
# 
# 1 <= nums.length <= 5000
# 1 <= nums[i] <= 104
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        total: int = 0
        for idx in range(1, len(nums)):
            if nums[idx] <= nums[idx - 1]:
                x: int = nums[idx - 1] + 1
                total += x - nums[idx]
                nums[idx] = x
        return total
        
# 945. Minimum Increment to Make Array Unique
# You are given an integer array nums. In one move, you can pick an index i where 0 <= i < nums.length and increment nums[i] by 1.
# 
# Return the minimum number of moves to make every value in nums unique.
# 
# The test cases are generated so that the answer fits in a 32-bit integer.
# 
#  
# 
# Example 1:
# 
# Input: nums = [1,2,2]
# Output: 1
# Explanation: After 1 move, the array could be [1, 2, 3].
# Example 2:
# 
# Input: nums = [3,2,1,2,1,7]
# Output: 6
# Explanation: After 6 moves, the array could be [3, 4, 1, 2, 5, 7].
# It can be shown with 5 or less moves that it is impossible for the array to have all unique values.
#  
# 
# Constraints:
# 
# 1 <= nums.length <= 105
# 0 <= nums[i] <= 105
class Solution:
    def minIncrementForUnique(self, nums: List[int]) -> int:
        nums.sort()
        total: int = 0
        for idx in range(1, len(nums)):
            if nums[idx] <= nums[idx - 1]:
                nxt_uniq_number: int = nums[idx - 1] + 1
                total += nxt_uniq_number - nums[idx]
                nums[idx] = nxt_uniq_number
        return total

# 502. IPO
# Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects.
# 
# You are given n projects where the ith project has a pure profit profits[i] and a minimum capital of capital[i] is needed to start it.
# 
# Initially, you have w capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.
# 
# Pick a list of at most k distinct projects from given projects to maximize your final capital, and return the final maximized capital.
# 
# The answer is guaranteed to fit in a 32-bit signed integer.
# 
#  
# 
# Example 1:
# 
# Input: k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]
# Output: 4
# Explanation: Since your initial capital is 0, you can only start the project indexed 0.
# After finishing it you will obtain profit 1 and your capital becomes 1.
# With capital 1, you can either start the project indexed 1 or the project indexed 2.
# Since you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.
# Therefore, output the final maximized capital, which is 0 + 1 + 3 = 4.
# Example 2:
# 
# Input: k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]
# Output: 6
#  
# 
# Constraints:
# 
# 1 <= k <= 105
# 0 <= w <= 109
# n == profits.length
# n == capital.length
# 1 <= n <= 105
# 0 <= profits[i] <= 104
# 0 <= capital[i] <= 109
# Initial Solution O(KNlogN) O(N)
import heapq
class Solution:
    def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -> int:
        h = []
        for idx in range(len(profits)):
            heapq.heappush(h, (-profits[idx], capital[idx], idx))
        while k > 0:
            future = set()
            while h and h[0][1] > w:
                future.add(heapq.heappop(h))
            if not h:
                return w
            w += profits[heapq.heappop(h)[2]]
            k -= 1
            while future:
                heapq.heappush(h, future.pop())
        return w
# Solution after code review
# General idea
# Firstly we create a array(let's call him "profit_capital") contains other arrays(int, int) in each array,
# respectively meaning pair profit that give project and capital thats needed to use this project.
# Then we sort "profit_capital" in ascending order(i0 <= i1 <= ... <= in-1 <= in) by captial value.
# After sorting we creat an loop that will iterate while k(maximum count of used projects)
# will be more than 0(when its 0, it means that we alreade use maximum project before IPO).
# In each iteration we will create inner while loop, by next condition: while we don't got
# out of upper boundary(index out of range) our "capital_profit" array
# AND value of needed capital of current object less or equal than our current capital,
# we will push to minimum heap(use negative value of profit(for minimum heap approach)) current project profit.
# After ending while loop we have 2 cases:
# We iterate from all projects and our heap of chosen projects is empty.
# So it mean that we don't have opportunity to use any
# of projects(our capital is less than minimum capital of all possible project).
# In this case, we should just break outer while loop(while k > 0)
# We have non empty heap contains chosen projects.
# In this case we should just pop from the top of minimum heap.
# Because by definition of minimum heap, smallest value will be always
# on the top of heap(we use negative "-" mark for create negative value of profit).
# Add value from the top of heap to current capital
# like that: "w += -value"(use "negative mark" for creating positve value).
# After incrementing current capital, we should descrease "k"(maximum count of used projects)
# At the end, we need jsut return current_capital
# Complexity
# Time complexity: O(NlogN)
# Space complexity: O(N)
# Code
import heapq
class Solution:
    def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -> int:
        profit_capital: list[list[int, int]] = [[profits[idx], capital[idx]] for idx in range(len(profits))]
        profit_capital.sort(key=lambda x: x[1])
        current_index: int = 0
        max_profit_projects: list[int] = []
        count_projects: int = len(profit_capital)
        while k > 0:
            while current_index < count_projects and profit_capital[current_index][1] <= w:
                heapq.heappush(max_profit_projects, -profit_capital[current_index][0])
                current_index += 1
            if not max_profit_projects:
                break
            w += -heapq.heappop(max_profit_projects)
            k -= 1
        return w

# A. Beautiful Year
# A. Beautiful Year
# time limit per test2 seconds
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# It seems like the year of 2013 came only yesterday. Do you know a curious fact? The year of 2013 is the first year after the old 1987 with only distinct digits.
#
# Now you are suggested to solve the following problem: given a year number, find the minimum year number which is strictly larger than the given one and has only distinct digits.
#
# Input
# The single line contains integer y (1000 ≤ y ≤ 9000) — the year number.
#
# Output
# Print a single integer — the minimum year number that is strictly larger than y and all it's digits are distinct. It is guaranteed that the answer exists.
#
# Examples
# inputCopy
# 1987
# outputCopy
# 2013
# inputCopy
# 2013
# outputCopy
# 2014
import sys

def check(year: int) -> bool:
    identity: set = set()
    _year = year
    while _year:
        digit = _year % 10
        if digit in identity:
            return False
        identity.add(digit)
        _year //= 10
    return True

def solution(current_year: int) -> str:
    year = current_year + 1
    while True:
        if check(year):
            return str(year)
        year += 1
if __name__ == '__main__':
    current_year: int = int(sys.stdin.readline().rstrip())
    sys.stdout.write(solution(current_year))

# Is there enough ink?
# Is there enough ink for printing the image?
# 
# You will get an image and the level of ink for each primary color in the tank of the printer. The image is a matrix where each cell is the color of a pixel. The color is a string of a RGB hexadecimal notation (e.g white is 'ffffff' and black is '000000'). Each primary color is a integer.
# 
# A pixel with the color code 'fefdfc' need 1 unit of Red, 2 units of Green and 3 units of Blue.
# 
# A pixel with the color code '00ff01' need 255 units of Red, 0 units of Green and 254 units of Blue.
# 
# The image is two dimensional. E.g: image = [["ffffff", "ffffff"], ["ffffff", "ffffff"]]
# 
# Your task is to determine if they are enough ink in the tank to print the image.
# 
# If the ink is enough, the "enough_ink()" function should return True. False otherwise.
# 
# Have fun!
# 
# FUNDAMENTALS
# Solution
def enough_ink(image, r, g, b):
    for chunk in image:
        for char in chunk:
            ned_r, ned_g, ned_b = [255 - int(char[i:i+2], 16) for i in (0, 2, 4)]
            r, g, b = r - ned_r, g - ned_g, b - ned_b
            if any(i < 0 for i in (r, g, b)): return False
    return True

# Path Finder #3: the Alpinist
# Task
# You are at start location [0, 0] in mountain area of NxN and you can only move in one of the four cardinal directions (i.e. North, East, South, West). Return minimal number of climb rounds to target location [N-1, N-1]. Number of climb rounds between adjacent locations is defined as difference of location altitudes (ascending or descending).
# 
# Location altitude is defined as an integer number (0-9).
# 
# Path Finder Series:
# #1: can you reach the exit?
# #2: shortest path
# #3: the Alpinist
# #4: where are you?
# #5: there's someone here
# ALGORITHMS
 from heapq import heappop, heappush
def path_finder(area):
    mtrx = [list(map(int, line)) for line in area.split('\n')]
    n = len(mtrx)
    heap = [(0, 0, 0)]
    costs = [[float('inf')] * n for _ in range(n)]
    costs[0][0] = 0
    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]
    while heap:
        current_cost, cur_r, cur_c = heappop(heap)
        if cur_r == cur_c == n - 1:
            return current_cost
        for dr, dc in directions:
            nxt_r, nxt_c = cur_r + dr, cur_c + dc
            if 0 <= nxt_r < n and 0 <= nxt_c < n:
                climb_cost = abs(mtrx[nxt_r][nxt_c] - mtrx[cur_r][cur_c])
                new_cost = current_cost + climb_cost
                if new_cost < costs[nxt_r][nxt_c]:
                    costs[nxt_r][nxt_c] = new_cost
                    heappush(heap, (new_cost, nxt_r, nxt_c))
                    
# 330. Patching Array
# Given a sorted integer array nums and an integer n, add/patch elements to the array such that any number in the range [1, n] inclusive can be formed by the sum of some elements in the array.
#
# Return the minimum number of patches required.
#
#
#
# Example 1:
#
# Input: nums = [1,3], n = 6
# Output: 1
# Explanation:
# Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.
# Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].
# Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].
# So we only need 1 patch.
# Example 2:
#
# Input: nums = [1,5,10], n = 20
# Output: 2
# Explanation: The two patches can be [2, 4].
# Example 3:
#
# Input: nums = [1,2,2], n = 5
# Output: 0
#
#
# Constraints:
#
# 1 <= nums.length <= 1000
# 1 <= nums[i] <= 104
# nums is sorted in ascending order.
# 1 <= n <= 231 - 1
class Solution:
    def minPatches(self, nums: List[int], n: int) -> int:
        added: int = 0
        index: int = 0
        missing: int = 1
        while missing <= n:
            if index < len(nums) and nums[index] <= missing:
                missing += nums[index]
                index += 1
            else:
                missing += missing
                added += 1
        return added

# 2952. Minimum Number of Coins to be Added
# You are given a 0-indexed integer array coins, representing the values of the coins available, and an integer target.
# 
# An integer x is obtainable if there exists a subsequence of coins that sums to x.
# 
# Return the minimum number of coins of any value that need to be added to the array so that every integer in the range [1, target] is obtainable.
# 
# A subsequence of an array is a new non-empty array that is formed from the original array by deleting some (possibly none) of the elements without disturbing the relative positions of the remaining elements.
# 
#  
# 
# Example 1:
# 
# Input: coins = [1,4,10], target = 19
# Output: 2
# Explanation: We need to add coins 2 and 8. The resulting array will be [1,2,4,8,10].
# It can be shown that all integers from 1 to 19 are obtainable from the resulting array, and that 2 is the minimum number of coins that need to be added to the array. 
# Example 2:
# 
# Input: coins = [1,4,10,5,7,19], target = 19
# Output: 1
# Explanation: We only need to add the coin 2. The resulting array will be [1,2,4,5,7,10,19].
# It can be shown that all integers from 1 to 19 are obtainable from the resulting array, and that 1 is the minimum number of coins that need to be added to the array. 
# Example 3:
# 
# Input: coins = [1,1,1], target = 20
# Output: 3
# Explanation: We need to add coins 4, 8, and 16. The resulting array will be [1,1,1,4,8,16].
# It can be shown that all integers from 1 to 20 are obtainable from the resulting array, and that 3 is the minimum number of coins that need to be added to the array.
#  
# 
# Constraints:
# 
# 1 <= target <= 105
# 1 <= coins.length <= 105
# 1 <= coins[i] <= target
class Solution:
    def minimumAddedCoins(self, coins: List[int], target: int) -> int:
        n: int = max(coins)
        storage: list[int] = [0] * (n + 1)
        for coin in coins:
            storage[coin] += 1
        missing: int = 1
        added: int = 0
        index: int = 0
        while missing <= target:
            while index < n + 1 and storage[index] == 0:
                index += 1
            if index < n + 1 and index <= missing:
                missing += index * storage[index]
                index += 1
            else:
                missing += missing
                added += 1
        return added

# 3186. Maximum Total Damage With Spell Casting
# A magician has various spells.
#
# You are given an array power, where each element represents the damage of a spell. Multiple spells can have the same damage value.
#
# It is a known fact that if a magician decides to cast a spell with a damage of power[i], they cannot cast any spell with a damage of power[i] - 2, power[i] - 1, power[i] + 1, or power[i] + 2.
#
# Each spell can be cast only once.
#
# Return the maximum possible total damage that a magician can cast.
#
#
#
# Example 1:
#
# Input: power = [1,1,3,4]
#
# Output: 6
#
# Explanation:
#
# The maximum possible damage of 6 is produced by casting spells 0, 1, 3 with damage 1, 1, 4.
#
# Example 2:
#
# Input: power = [7,1,6,6]
#
# Output: 13
#
# Explanation:
#
# The maximum possible damage of 13 is produced by casting spells 1, 2, 3 with damage 1, 6, 6.
#
#
#
# Constraints:
#
# 1 <= power.length <= 105
# 1 <= power[i] <= 109
class Solution:
    def maximumTotalDamage(self, power: List[int]) -> int:
        ht = dict()
        for num in power:
            ht[num] = ht.get(num, 0) + 1
        spells = sorted(ht.keys())
        k = len(spells)
        dp = [0] * k
        for spell_index in range(k):
            if spell_index == 0:
                dp[spell_index] = spells[spell_index] * ht[spells[spell_index]]
            else:
                dp[spell_index] = dp[spell_index - 1]
            current_damage = spells[spell_index] * ht[spells[spell_index]]
            previous_damage_index = spell_index - 1
            while previous_damage_index >= 0 and spells[previous_damage_index] >= spells[spell_index] - 2:
                previous_damage_index -= 1
            if previous_damage_index >= 0:
                dp[spell_index] = max(dp[spell_index], current_damage + dp[previous_damage_index])
            else:
                dp[spell_index] = max(dp[spell_index], current_damage)
        return max(dp)


# 3184. Count Pairs That Form a Complete Day I
# Given an integer array hours representing times in hours, return an integer denoting the number of pairs i, j where i < j and hours[i] + hours[j] forms a complete day.
# 
# A complete day is defined as a time duration that is an exact multiple of 24 hours.
# 
# For example, 1 day is 24 hours, 2 days is 48 hours, 3 days is 72 hours, and so on.
# 
#  
# 
# Example 1:
# 
# Input: hours = [12,12,30,24,24]
# 
# Output: 2
# 
# Explanation:
# 
# The pairs of indices that form a complete day are (0, 1) and (3, 4).
# 
# Example 2:
# 
# Input: hours = [72,48,24,3]
# 
# Output: 3
# 
# Explanation:
# 
# The pairs of indices that form a complete day are (0, 1), (0, 2), and (1, 2).
# 
#  
# 
# Constraints:
# 
# 1 <= hours.length <= 100
# 1 <= hours[i] <= 109
# Solution Brute Force O(N**2) O(1)
class Solution:
    def countCompleteDayPairs(self, hours: List[int]) -> int:
        count: int = 0
        for i in range(len(hours)):
            for j in range(i + 1, len(hours)):
                if (hours[i] + hours[j]) % 24 == 0:
                    count += 1
        return count
# Solution HashTable O(N) O(1)
class Solution:
    def countCompleteDayPairs(self, hours: List[int]) -> int:
        hours_of_the_day: list[int] = [0] * 24
        total: int = 0
        for hour in hours:
            total += hours_of_the_day[hour % 24]
            remainder = (24 - hour % 24) % 24
            hours_of_the_day[remainder] += 1
        return total
        
# 3185. Count Pairs That Form a Complete Day II
# Given an integer array hours representing times in hours, return an integer denoting the number of pairs i, j where i < j and hours[i] + hours[j] forms a complete day.
#
# A complete day is defined as a time duration that is an exact multiple of 24 hours.
#
# For example, 1 day is 24 hours, 2 days is 48 hours, 3 days is 72 hours, and so on.
#
#
#
# Example 1:
#
# Input: hours = [12,12,30,24,24]
#
# Output: 2
#
# Explanation: The pairs of indices that form a complete day are (0, 1) and (3, 4).
#
# Example 2:
#
# Input: hours = [72,48,24,3]
#
# Output: 3
#
# Explanation: The pairs of indices that form a complete day are (0, 1), (0, 2), and (1, 2).
#
#
#
# Constraints:
#
# 1 <= hours.length <= 5 * 105
# 1 <= hours[i] <= 109
class Solution:
    def countCompleteDayPairs(self, hours: List[int]) -> int:
        hours_of_the_day: list[int] = [0] * 24
        total: int = 0
        for hour in hours:
            total += hours_of_the_day[hour % 24]
            remainder = (24 - hour % 24) % 24
            hours_of_the_day[remainder] += 1
        return total

# B. Queue at the School
# B. Queue at the School
# time limit per test2 seconds
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# During the break the schoolchildren, boys and girls, formed a queue of n people in the canteen. Initially the children stood in the order they entered the canteen. However, after a while the boys started feeling awkward for standing in front of the girls in the queue and they started letting the girls move forward each second.
#
# Let's describe the process more precisely. Let's say that the positions in the queue are sequentially numbered by integers from 1 to n, at that the person in the position number 1 is served first. Then, if at time x a boy stands on the i-th position and a girl stands on the (i + 1)-th position, then at time x + 1 the i-th position will have a girl and the (i + 1)-th position will have a boy. The time is given in seconds.
#
# You've got the initial position of the children, at the initial moment of time. Determine the way the queue is going to look after t seconds.
#
# Input
# The first line contains two integers n and t (1 ≤ n, t ≤ 50), which represent the number of children in the queue and the time after which the queue will transform into the arrangement you need to find.
#
# The next line contains string s, which represents the schoolchildren's initial arrangement. If the i-th position in the queue contains a boy, then the i-th character of string s equals "B", otherwise the i-th character equals "G".
#
# Output
# Print string a, which describes the arrangement after t seconds. If the i-th position has a boy after the needed time, then the i-th character a must equal "B", otherwise it must equal "G".
#
# Examples
# inputCopy
# 5 1
# BGGBG
# outputCopy
# GBGGB
# inputCopy
# 5 2
# BGGBG
# outputCopy
# GGBGB
# inputCopy
# 4 1
# GGGB
# outputCopy
# GGGB
# Solution Simulation O(N) O(1)
import sys

def solution(n: int ,t: int, queue: list) -> str:
    start_of_the_queue: int = 0
    for _ in range(t):
        while start_of_the_queue < n and queue[start_of_the_queue] == 'G':
            start_of_the_queue += 1
        person = start_of_the_queue
        while person < n - 1:
            if queue[person] == 'B' and queue[person + 1] == 'G':
                queue[person], queue[person + 1] = queue[person + 1], queue[person]
                person += 2
            else:
                person += 1
    return ''.join(queue)

if __name__ == '__main__':
    n, t = map(int, sys.stdin.readline().rstrip().split())
    queue: list = list(sys.stdin.readline().rstrip())
    sys.stdout.write(solution(n, t, queue))
    
# Spot the Differences
# This kata is part of the collection Mary's Puzzle Books.
# 
# Mary brought home a "spot the differences" book. The book is full of a bunch of problems, and each problem consists of two strings that are similar. However, in each string there are a few characters that are different. An example puzzle from her book is:
# 
# String 1: "abcdefg"
# String 2: "abcqetg"
# Notice how the "d" from String 1 has become a "q" in String 2, and "f" from String 1 has become a "t" in String 2.
# 
# It's your job to help Mary solve the puzzles. Write a program spot_diff/Spot that will compare the two strings and return a list with the positions where the two strings differ. In the example above, your program should return [3, 5] because String 1 is different from String 2 at positions 3 and 5.
# 
# NOTES:
# 
# • If both strings are the same, return []
# 
# • Both strings will always be the same length
# 
# • Capitalization and punctuation matter
# 
# STRINGSFUNDAMENTALS
def spot_diff(s1, s2):
    return [i for i in range(len(s1)) if s1[i] != s2[i]]

# A. Alice and Books
# A. Alice and Books
# time limit per test1 second
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# Alice has n
#  books. The 1
# -st book contains a1
#  pages, the 2
# -nd book contains a2
#  pages, …
# , the n
# -th book contains an
#  pages. Alice does the following:
#
# She divides all the books into two non-empty piles. Thus, each book ends up in exactly one of the two piles.
# Alice reads one book with the highest number in each pile.
# Alice loves reading very much. Help her find the maximum total number of pages she can read by dividing the books into two piles.
#
# Input
# Each test consists of multiple test cases. The first line contains a single integer t
#  (1≤t≤500
# ) — the number of test cases. The description of the test cases follows.
#
# The first line of each test case contains a single integer n
#  (2≤n≤100
# ) — the number of books Alice has.
#
# The second line of each test case contains n
#  integers a1,a2,…,an
#  (1≤ai≤109
# ) — the number of pages in each book.
#
# Output
# For each test case, output a single integer — the maximum number of pages Alice can read.
#
# Example
# inputCopy
# 5
# 2
# 1 1
# 4
# 2 3 3 1
# 5
# 2 2 3 2 2
# 2
# 10 3
# 3
# 1 2 3
# outputCopy
# 2
# 4
# 5
# 13
# 5
# Note
# In the first test case, Alice can put book number 1
#  in the first pile, and book number 2
#  in the second pile. Then she will read a1+a2=1+1=2
#  pages.
#
# In the second test case, Alice can put books with numbers 2
#  and 3
#  in the first pile, and books with numbers 1
#  and 4
#  in the second pile. Then she will read the book with the highest number 3
#  from the first pile, and the book with the highest number 4
#  from the second pile. Then she will read a3+a4=3+1=4
#  pages.
import sys

def solution(t) -> None:
    for _ in range(t):
        n = int(sys.stdin.readline().rstrip())
        books = list(map(int, sys.stdin.readline().rstrip().split()))
        print(max(books[:-1]) + books[-1])

if __name__ == '__main__':
    t = int(sys.stdin.readline().rstrip())
    solution(t)
    
# B. New Bakery
# B. New Bakery
# time limit per test1 second
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# Bob decided to open a bakery. On the opening day, he baked n
#  buns that he can sell. The usual price of a bun is a
#  coins, but to attract customers, Bob organized the following promotion:
#
# Bob chooses some integer k
#  (0≤k≤min(n,b)
# ).
# Bob sells the first k
#  buns at a modified price. In this case, the price of the i
# -th (1≤i≤k
# ) sold bun is (b−i+1)
#  coins.
# The remaining (n−k)
#  buns are sold at a
#  coins each.
# Note that k
#  can be equal to 0
# . In this case, Bob will sell all the buns at a
#  coins each.
#
# Help Bob determine the maximum profit he can obtain by selling all n
#  buns.
#
# Input
# Each test consists of multiple test cases. The first line contains a single integer t
#  (1≤t≤104
# ) — the number of test cases. The description of the test cases follows.
#
# The only line of each test case contains three integers n
# , a
# , and b
#  (1≤n,a,b≤109
# ) — the number of buns, the usual price of a bun, and the price of the first bun to be sold at a modified price.
#
# Output
# For each test case, output a single integer — the maximum profit that Bob can obtain.
#
# Example
# inputCopy
# 7
# 4 4 5
# 5 5 9
# 10 10 5
# 5 5 11
# 1000000000 1000000000 1000000000
# 1000000000 1000000000 1
# 1000 1 1000
# outputCopy
# 17
# 35
# 100
# 45
# 1000000000000000000
# 1000000000000000000
# 500500
# Note
# In the first test case, it is optimal for Bob to choose k=1
# . Then he will sell one bun for 5
#  coins, and three buns at the usual price for 4
#  coins each. Then the profit will be 5+4+4+4=17
#  coins.
#
# In the second test case, it is optimal for Bob to choose k=5
# . Then he will sell all the buns at the modified price and obtain a profit of 9+8+7+6+5=35
#  coins.
#
# In the third test case, it is optimal for Bob to choose k=0
# . Then he will sell all the buns at the usual price and obtain a profit of 10⋅10=100
#  coins.
import sys

def solution() -> str:
    n, a, b = map(int, sys.stdin.readline().rstrip().split())
    if b < a:
        return str(n * a)
    max_decreasing_elements = min(n, b - a + 1)
    total = 0
    if max_decreasing_elements > 0:
        first_term = b
        last_term = b - (max_decreasing_elements - 1)
        total += max_decreasing_elements * (first_term + last_term) // 2
    remaining_elements = n - max_decreasing_elements
    if remaining_elements > 0:
        total += remaining_elements * a
    return str(total)

if __name__ == '__main__':
    t = int(sys.stdin.readline().rstrip())
    for _ in range(t):
        print(solution())
        
# A. Chat room
# A. Chat room
# time limit per test1 second
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# Vasya has recently learned to type and log on to the Internet. He immediately entered a chat room and decided to say hello to everybody. Vasya typed the word s. It is considered that Vasya managed to say hello if several letters can be deleted from the typed word so that it resulted in the word "hello". For example, if Vasya types the word "ahhellllloou", it will be considered that he said hello, and if he types "hlelo", it will be considered that Vasya got misunderstood and he didn't manage to say hello. Determine whether Vasya managed to say hello by the given word s.
# 
# Input
# The first and only line contains the word s, which Vasya typed. This word consisits of small Latin letters, its length is no less that 1 and no more than 100 letters.
# 
# Output
# If Vasya managed to say hello, print "YES", otherwise print "NO".
# 
# Examples
# inputCopy
# ahhellllloou
# outputCopy
# YES
# inputCopy
# hlelo
# outputCopy
# NO
import sys


def solution(n: str) -> str:
    letters = ['h', 'e', 'l', 'l', 'o']
    for char in n:
        if char == letters[0]:
            letters.pop(0)
            if not letters:
                return 'YES'
    return 'NO' if letters else 'YES'


if __name__ == '__main__':
    n = sys.stdin.readline().rstrip()
    sys.stdout.write(solution(n))
    
# 633. Sum of Square Numbers
# Given a non-negative integer c, decide whether there're two integers a and b such that a2 + b2 = c.
# 
#  
# 
# Example 1:
# 
# Input: c = 5
# Output: true
# Explanation: 1 * 1 + 2 * 2 = 5
# Example 2:
# 
# Input: c = 3
# Output: false
#  
# 
# Constraints:
# 
# 0 <= c <= 231 - 1
class Solution:
    def judgeSquareSum(self, c: int) -> bool:
        left, right = 0, int(c**.5) + 1
        while left <= right:
            sm: int = left**2 + right**2
            if sm == c:
                return True
            elif sm > c:
                right -= 1
            else:
                left += 1
        return False

# Sum of (Two) Squares
 Complete the function that takes a non-negative integer, and returns a list of non-negative integer pairs whose values - when squared - sum to the given integer.
# 
# For example, given the parameter 25, the function should return the two pairs [0, 5] and [3, 4] because 0^2 + 5^2 = 25 and 3^2 + 4^2 = 25.
# 
# Return the pairs in ascending order, so e.g. [[0, 5], [3, 4]] not [[5, 0], [3, 4]] or [[3, 4], [0, 5]], etc.
# 
# If the given value cannot be expressed as the sum of two squares, return an empty array.
# 
# Note: The upper bound of the parameter value will be 2,147,483,647
# 
# Examples
#   0  -->  [ [0, 0] ]
#   1  -->  [ [0, 1] ]
#   2  -->  [ [1, 1] ]
#   3  -->  []
#   4  -->  [ [0, 2] ]
#   5  -->  [ [1, 2] ]
#  25  -->  [ [0, 5], [3, 4] ]
# 325  -->  [ [1, 18], [6, 17], [10, 15] ]
# MATHEMATICSALGORITHMS
def all_squared_pairs(n):
    left, right = 0, int(n**.5) + 1
    ans: list[int] = []
    while left <= right:
        sm: int = left**2 + right**2
        if sm == n:
            ans.append([left, right])
            left += 1
        elif sm > n:
            right -= 1
        else:
            left += 1
    return ans
    
# 826. Most Profit Assigning Work
# You have n jobs and m workers. You are given three arrays: difficulty, profit, and worker where:
# 
# difficulty[i] and profit[i] are the difficulty and the profit of the ith job, and
# worker[j] is the ability of jth worker (i.e., the jth worker can only complete a job with difficulty at most worker[j]).
# Every worker can be assigned at most one job, but one job can be completed multiple times.
# 
# For example, if three workers attempt the same job that pays $1, then the total profit will be $3. If a worker cannot complete any job, their profit is $0.
# Return the maximum profit we can achieve after assigning the workers to the jobs.
# 
#  
# 
# Example 1:
# 
# Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]
# Output: 100
# Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get a profit of [20,20,30,30] separately.
# Example 2:
# 
# Input: difficulty = [85,47,57], profit = [24,66,99], worker = [40,25,25]
# Output: 0
#  
# 
# Constraints:
# 
# n == difficulty.length
# n == profit.length
# m == worker.length
# 1 <= n, m <= 104
# 1 <= difficulty[i], profit[i], worker[i] <= 105
# Complexity
# Time complexity: O(NlogN + MlogM)
#
# Space complexity: O(M)
# Where N is lenght of workers and M is length of jobs
#
# Code
from heapq import heappush, heappop
class Solution:
    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:
        jobs: list[tuple[int, int]] = []
        worker.sort()
        for idx in range(len(profit)):
            heappush(jobs, (difficulty[idx], profit[idx]))
        total_profit: int = 0
        most_payment_job = heappop(jobs)
        for work in worker:
            while jobs and work >= jobs[0][0]:
                new_job = heappop(jobs)
                if new_job[1] >= most_payment_job[1]:
                    most_payment_job = new_job
            if work >= most_payment_job[0]:
                total_profit += most_payment_job[1]
        return total_profit

# A. In Search of an Easy Problem
# A. In Search of an Easy Problem
# time limit per test1 second
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# When preparing a tournament, Codeforces coordinators try treir best to make the first problem as easy as possible. This time the coordinator had chosen some problem and asked n
#  people about their opinions. Each person answered whether this problem is easy or hard.
# 
# If at least one of these n
#  people has answered that the problem is hard, the coordinator decides to change the problem. For the given responses, check if the problem is easy enough.
# 
# Input
# The first line contains a single integer n
#  (1≤n≤100
# ) — the number of people who were asked to give their opinions.
# 
# The second line contains n
#  integers, each integer is either 0
#  or 1
# . If i
# -th integer is 0
# , then i
# -th person thinks that the problem is easy; if it is 1
# , then i
# -th person thinks that the problem is hard.
# 
# Output
# Print one word: "EASY" if the problem is easy according to all responses, or "HARD" if there is at least one person who thinks the problem is hard.
# 
# You may print every letter in any register: "EASY", "easy", "EaSY" and "eAsY" all will be processed correctly.
# 
# Examples
# inputCopy
# 3
# 0 0 1
# outputCopy
# HARD
# inputCopy
# 1
# 0
# outputCopy
# EASY
# Note
# In the first example the third person says it's a hard problem, so it should be replaced.
# 
# In the second example the problem easy for the only person, so it doesn't have to be replaced.
import sys

def solution(n: str) -> bool:
    return ['EASY', 'HARD']['1' in n]

if __name__ == '__main__':
    _ = sys.stdin.readline()
    sys.stdout.write(solution(sys.stdin.readline().rstrip()))

# Temperature converter
# Write a function convert_temp(temp, from_scale, to_scale) converting temperature from one scale to another. Return converted temp value.
#
# Round converted temp value to an integer(!).
#
# Reading: http://en.wikipedia.org/wiki/Conversion_of_units_of_temperature
#
# possible scale inputs:
#     "C"  for Celsius
#     "F"  for Fahrenheit
#     "K"  for Kelvin
#     "R"  for Rankine
#     "De" for Delisle
#     "N"  for Newton
#     "Re" for Réaumur
#     "Ro" for Rømer
# temp is a number, from_scale and to_scale are strings.
#
# convert_temp(   100, "C",  "F") # => 212
# convert_temp(    40, "Re", "C") # => 50
# convert_temp(    60, "De", "F") # => 140
# convert_temp(373.15, "K",  "N") # => 33
# convert_temp(   666, "K",  "K") # => 666
# FUNCTIONAL PROGRAMMINGDATA STRUCTURESSTRINGSMATHEMATICSFUNDAMENTALS
    return temp
def convert_temp(temp, from_scale, to_scale):
    if from_scale == to_scale: return temp
    scale = {
        'C': {
            'C': lambda x: x,
            'F': lambda x: x * (9 / 5) + 32,
            'K': lambda x: x + 273.15,
            'R': lambda x: (x + 273.15) * (9 / 5),
            'De': lambda x: (100 - x) * (3 / 2),
            'N': lambda x: x * (33 / 100),
            'Re': lambda x: x * (4 / 5),
            'Ro': lambda x: (x * (21/40) + 7.5)
        },
        'F': {'C': lambda x: (x - 32) * (5 / 9)},
        'K': {'C': lambda x: x - 273.15},
        'R': {'C': lambda x: (x - 491.67) * (5 / 9)},
        'De': {'C': lambda x: 100 - x * (2 / 3)},
        'N': {'C': lambda x: x * (100 / 33)},
        'Re': {'C': lambda x: x * (5 / 4)},
        'Ro': {'C': lambda x:  (x - 7.5) * (40/21)}
    }
    celsius = scale.get(from_scale).get('C')(temp)
    return int(scale.get('C').get(to_scale)(celsius))

# 1482. Minimum Number of Days to Make m Bouquets
# You are given an integer array bloomDay, an integer m and an integer k.
# 
# You want to make m bouquets. To make a bouquet, you need to use k adjacent flowers from the garden.
# 
# The garden consists of n flowers, the ith flower will bloom in the bloomDay[i] and then can be used in exactly one bouquet.
# 
# Return the minimum number of days you need to wait to be able to make m bouquets from the garden. If it is impossible to make m bouquets return -1.
# 
#  
# 
# Example 1:
# 
# Input: bloomDay = [1,10,3,10,2], m = 3, k = 1
# Output: 3
# Explanation: Let us see what happened in the first three days. x means flower bloomed and _ means flower did not bloom in the garden.
# We need 3 bouquets each should contain 1 flower.
# After day 1: [x, _, _, _, _]   // we can only make one bouquet.
# After day 2: [x, _, _, _, x]   // we can only make two bouquets.
# After day 3: [x, _, x, _, x]   // we can make 3 bouquets. The answer is 3.
# Example 2:
# 
# Input: bloomDay = [1,10,3,10,2], m = 3, k = 2
# Output: -1
# Explanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.
# Example 3:
# 
# Input: bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3
# Output: 12
# Explanation: We need 2 bouquets each should have 3 flowers.
# Here is the garden after the 7 and 12 days:
# After day 7: [x, x, x, x, _, x, x]
# We can make one bouquet of the first three flowers that bloomed. We cannot make another bouquet from the last three flowers that bloomed because they are not adjacent.
# After day 12: [x, x, x, x, x, x, x]
# It is obvious that we can make two bouquets in different ways.
#  
# 
# Constraints:
# 
# bloomDay.length == n
# 1 <= n <= 105
# 1 <= bloomDay[i] <= 109
# 1 <= m <= 106
# 1 <= k <= n
class Solution:
    def check(
            self, current_day: int, upper_boundary: int,
            needed_flowers_for_bouquet: int,
            needed_bouquets: int, days: list[int]
    ) -> bool:
        length_of_bouquet, count_bouquets = 0, 0
        current_index: int = 0
        while current_index < upper_boundary:
            while current_index < upper_boundary and days[current_index] <= current_day:
                length_of_bouquet += 1
                if length_of_bouquet == needed_flowers_for_bouquet:
                    count_bouquets += 1
                    length_of_bouquet = 0
                current_index += 1
            if current_index < upper_boundary and days[current_index] > current_day:
                length_of_bouquet = 0
            if count_bouquets >= needed_bouquets:
                return True
            current_index += 1
        return count_bouquets >= needed_bouquets

    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:
        n: int = len(bloomDay)
        if m * k > n:
            return - 1
        left, right = min(bloomDay), max(bloomDay)
        while left < right:
            middle: int = (left + right) >> 1
            if self.check(middle, n, k, m, bloomDay):
                right = middle
            else:
                left = middle + 1
        return left

# Calculate Parity bit!
# A parity bit, or check bit, is a bit added to a string of bits to ensure that the total number of 1-bits in the string is even or odd. Parity bits are used as the simplest form of error detecting code.
#
# You have two parameters, one being the wanted parity (always 'even' or 'odd'), and the other being the binary representation of the number you want to check.
#
# Your task is to return an integer (0 or 1), whose parity bit you need to add to the binary representation so that the parity of the resulting string is as expected.
#
# Example:
#
#   Parity: 'even'
#   Bin: '0101010'
#   Result: 1
# Because there is an odd number of 1-bits (3) you need to put another 1 to it to get an even number of 1-bits.
#
# For more information: https://en.wikipedia.org/wiki/Parity_bit
#
# FUNDAMENTALS
def check_parity(parity, bin_str): 
    ht = {'even': 0, 'odd': 1}
    return int(not bin_str.count('1') % 2 == ht.get(parity))

# A. Lucky Division
# A. Lucky Division
# time limit per test2 seconds
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.
#
# Petya calls a number almost lucky if it could be evenly divided by some lucky number. Help him find out if the given number n is almost lucky.
#
# Input
# The single line contains an integer n (1 ≤ n ≤ 1000) — the number that needs to be checked.
#
# Output
# In the only line print "YES" (without the quotes), if number n is almost lucky. Otherwise, print "NO" (without the quotes).
#
# Examples
# inputCopy
# 47
# outputCopy
# YES
# inputCopy
# 16
# outputCopy
# YES
# inputCopy
# 78
# outputCopy
# NO
# Note
# Note that all lucky numbers are almost lucky as any number is evenly divisible by itself.
#
# In the first sample 47 is a lucky number. In the second sample 16 is divisible by 4.
import sys


def solution(n: str) -> bool:
    if all(i in {'4', '7'} for i in n):
        return True
    n = int(n)
    variables: list = [4, 7, 44, 47, 74, 77, 444, 447, 474, 744, 747, 774, 777]
    if any(n % i == 0 for i in variables):
        return True
    return False


if __name__ == '__main__':
    n = sys.stdin.readline().rstrip()
    sys.stdout.write(['NO', 'YES'][solution(n)])
    
# A. George and Accommodation
# A. George and Accommodation
# time limit per test1 second
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# George has recently entered the BSUCP (Berland State University for Cool Programmers). George has a friend Alex who has also entered the university. Now they are moving into a dormitory.
# 
# George and Alex want to live in the same room. The dormitory has n rooms in total. At the moment the i-th room has pi people living in it and the room can accommodate qi people in total (pi ≤ qi). Your task is to count how many rooms has free place for both George and Alex.
# 
# Input
# The first line contains a single integer n (1 ≤ n ≤ 100) — the number of rooms.
# 
# The i-th of the next n lines contains two integers pi and qi (0 ≤ pi ≤ qi ≤ 100) — the number of people who already live in the i-th room and the room's capacity.
# 
# Output
# Print a single integer — the number of rooms where George and Alex can move in.
# 
# Examples
# inputCopy
# 3
# 1 1
# 2 2
# 3 3
# outputCopy
# 0
# inputCopy
# 3
# 1 10
# 0 10
# 10 10
# outputCopy
# 2
import sys


def solution(n: int) -> int:
    total: int = 0
    for _ in range(n):
        x, y = map(int, sys.stdin.readline().rstrip().split())
        total += y - x >= 2
    return total


if __name__ == '__main__':
    n: int = int(sys.stdin.readline().rstrip())
    sys.stdout.write(str(solution(n)))
    
# Smallest possible sum
# Description
# Given an array X of positive integers, its elements are to be transformed by running the following operation on them as many times as required:
#
# if X[i] > X[j] then X[i] = X[i] - X[j]
#
# When no more transformations are possible, return its sum ("smallest possible sum").
#
# For instance, the successive transformation of the elements of input X = [6, 9, 21] is detailed below:
#
# X_1 = [6, 9, 12] # -> X_1[2] = X[2] - X[1] = 21 - 9
# X_2 = [6, 9, 6]  # -> X_2[2] = X_1[2] - X_1[0] = 12 - 6
# X_3 = [6, 3, 6]  # -> X_3[1] = X_2[1] - X_2[0] = 9 - 6
# X_4 = [6, 3, 3]  # -> X_4[2] = X_3[2] - X_3[1] = 6 - 3
# X_5 = [3, 3, 3]  # -> X_5[1] = X_4[0] - X_4[1] = 6 - 3
# The returning output is the sum of the final transformation (here 9).
#
# Example
# solution([6, 9, 21]) #-> 9
# Solution steps:
# [6, 9, 12] #-> X[2] = 21 - 9
# [6, 9, 6] #-> X[2] = 12 - 6
# [6, 3, 6] #-> X[1] = 9 - 6
# [6, 3, 3] #-> X[2] = 6 - 3
# [3, 3, 3] #-> X[1] = 6 - 3
# Additional notes:
# There are performance tests consisted of very big numbers and arrays of size at least 30000. Please write an efficient algorithm to prevent timeout.
#
# ALGORITHMSMATHEMATICSARRAYS
from heapq import heappush, heappop, heapify
def solution(lst):
    if len(lst) == 1:
        return lst[0]
    ans: int = 0
    ht = dict()
    for i in lst:
        ht[i] = ht.get(i, 0) + 1
    hp = list(-i for i in ht.keys())
    heapify(hp)
    while hp:
        x = -heappop(hp)
        if hp and x > -hp[0]:
            next_ = x - -hp[0]
            ht[next_] = ht.get(next_, 0) + ht[x]
            del ht[x]
            heappush(hp, -next_)
    return sum(k * v for k,v in ht.items())
    
# 1552. Magnetic Force Between Two Balls
# In the universe Earth C-137, Rick discovered a special form of magnetic force between two balls if they are put in his new invented basket. Rick has n empty baskets, the ith basket is at position[i], Morty has m balls and needs to distribute the balls into the baskets such that the minimum magnetic force between any two balls is maximum.
#
# Rick stated that magnetic force between two different balls at positions x and y is |x - y|.
#
# Given the integer array position and the integer m. Return the required force.
#
#
#
# Example 1:
#
#
# Input: position = [1,2,3,4,7], m = 3
# Output: 3
# Explanation: Distributing the 3 balls into baskets 1, 4 and 7 will make the magnetic force between ball pairs [3, 3, 6]. The minimum magnetic force is 3. We cannot achieve a larger minimum magnetic force than 3.
# Example 2:
#
# Input: position = [5,4,3,2,1,1000000000], m = 2
# Output: 999999999
# Explanation: We can use baskets 1 and 1000000000.
#
#
# Constraints:
#
# n == position.length
# 2 <= n <= 105
# 1 <= position[i] <= 109
# All integers in position are distinct.
# 2 <= m <= position.length
# Solution Binary Search O(NlogN) O(1)
class Solution:
    def check(
        self, array: list[int], target: int,
        needed: int, upper_boundary: int
    ):
        slow, fast = upper_boundary - 1, upper_boundary - 2
        count_pairs: int = 0
        while fast >= 0:
            if array[slow] - array[fast] >= target:
                count_pairs += 1
                slow = fast
            if array[slow] <= target: break # other numbers will be smaller than target, so just break loop
            fast -= 1
            if count_pairs >= needed - 1: # case if already have needed count of pairs
                return True
        return count_pairs >= needed - 1

    def maxDistance(self, position: List[int], m: int) -> int:
        position.sort()
        n: int = len(position)
        left, right = 1, position[-1] - position[0]
        while left <= right:
            middle: int = left + (right - left) // 2
            result: bool = self.check(position, middle, m, n)
            if result:
                left = middle + 1
            else:
                right = middle - 1
        return left - 1

# A. Magnets
# A. Magnets
# time limit per test1 second
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# Mad scientist Mike entertains himself by arranging rows of dominoes. He doesn't need dominoes, though: he uses rectangular magnets instead. Each magnet has two poles, positive (a "plus") and negative (a "minus"). If two magnets are put together at a close distance, then the like poles will repel each other and the opposite poles will attract each other.
#
# Mike starts by laying one magnet horizontally on the table. During each following step Mike adds one more magnet horizontally to the right end of the row. Depending on how Mike puts the magnet on the table, it is either attracted to the previous one (forming a group of multiple magnets linked together) or repelled by it (then Mike lays this magnet at some distance to the right from the previous one). We assume that a sole magnet not linked to others forms a group of its own.
#
#
# Mike arranged multiple magnets in a row. Determine the number of groups that the magnets formed.
#
# Input
# The first line of the input contains an integer n (1 ≤ n ≤ 100000) — the number of magnets. Then n lines follow. The i-th line (1 ≤ i ≤ n) contains either characters "01", if Mike put the i-th magnet in the "plus-minus" position, or characters "10", if Mike put the magnet in the "minus-plus" position.
#
# Output
# On the single line of the output print the number of groups of magnets.
#
# Examples
# inputCopy
# 6
# 10
# 10
# 10
# 01
# 10
# 10
# outputCopy
# 3
# inputCopy
# 4
# 01
# 01
# 10
# 10
# outputCopy
# 2
# Note
# The first testcase corresponds to the figure. The testcase has three groups consisting of three, one and two magnets.
#
# The second testcase has two groups, each consisting of two magnets.
import sys

def solution(n: int) -> str:
    total_groups: int = 1
    prev: str = None
    for _ in range(n):
        current: str = sys.stdin.readline().rstrip()
        if prev is None:
            prev = current
        elif prev[-1] == current[0]:
            total_groups += 1
            prev = current
    return str(total_groups)


if __name__ == '__main__':
    n: int = int(sys.stdin.readline().rstrip())
    sys.stdout.write(solution(n))

# Student Rankings
# Often times in schools, at the end of a semester or term, the teacher or professor will post the grades publically for everyone to see the day after the finals. Students can go to a public bulletin and check their grades to see how they did on an exam and where their ranking stands. This kata, Student Rankings will have you, the professor automate the list making for the many classes you're in charge of!
# 
# Input
# Your function `post_grades` will receive a list of students denoted as *students*.
# example_student_list = [
#   'S01 - Student Name A - 95 98.4 92.15', 
#   'S02 - Student Name B - 100 96.4 90', 
#   'S03 - Student Name C - 84.2 90.5 92.8', 
#   'S04 - Student Name D - 80 96.4 88.4'
# ]
# Each student will have three things split by the - character:
# 
# A student id i.e. S01
# A student name i.e. Student Name A
# A list of grades separated by spaces i.e. 95 98.4 92.15
# To make it easy for the professor, each student will be represented as a single string.
# 
# Output
# Write a function `post_grades(students)` that returns a sorted list of pairs containing the `student id` and the `average score`. So for the example list provided, the output would look like the following:
# result = [('S02',95.47),('S01',95.18),('S03',89.17),('S04',88.27)]
# Notes:
# 
# For an empty list, return the empty list []
# The list should sort from highest average score to lowest average score i.e. 100 -> 0
# FUNDAMENTALS
def post_grades(students):
    output = []
    for stud in students:
        id_, name, score = stud.split('-')
        score = list(map(float, score[1:].split()))
        output.append((id_[:-1], sum(score) / len(score)))
    return sorted(output, key=lambda x: x[1], reverse=True)

# 1052. Grumpy Bookstore Owner
# There is a bookstore owner that has a store open for n minutes. Every minute, some number of customers enter the store. You are given an integer array customers of length n where customers[i] is the number of the customer that enters the store at the start of the ith minute and all those customers leave after the end of that minute.
# 
# On some minutes, the bookstore owner is grumpy. You are given a binary array grumpy where grumpy[i] is 1 if the bookstore owner is grumpy during the ith minute, and is 0 otherwise.
# 
# When the bookstore owner is grumpy, the customers of that minute are not satisfied, otherwise, they are satisfied.
# 
# The bookstore owner knows a secret technique to keep themselves not grumpy for minutes consecutive minutes, but can only use it once.
# 
# Return the maximum number of customers that can be satisfied throughout the day.
# 
#  
# 
# Example 1:
# 
# Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3
# Output: 16
# Explanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. 
# The maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16.
# Example 2:
# 
# Input: customers = [1], grumpy = [0], minutes = 1
# Output: 1
#  
# 
# Constraints:
# 
# n == customers.length == grumpy.length
# 1 <= minutes <= n <= 2 * 104
# 0 <= customers[i] <= 1000
# grumpy[i] is either 0 or 1.
class Solution:
    def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:
        already_satisfied: int = 0
        max_subarray_sum: int = 0
        current_subarray_sum: int = 0
        length_of_current_subarray: int = 0
        left: int = 0
        for right in range(len(customers)):
            while left <= right and length_of_current_subarray >= minutes:
                if grumpy[left]: # case when owner is grumpy
                    current_subarray_sum -= customers[left]
                left += 1
                length_of_current_subarray -= 1
            if grumpy[right]: # case when owner is grumpy
                current_subarray_sum += customers[right]
                max_subarray_sum = max(max_subarray_sum, current_subarray_sum)
            else: # bookstore owner not grumpy
                already_satisfied += customers[right]
            length_of_current_subarray += 1
        return already_satisfied + max_subarray_sum

# A. Twins
# A. Twins
# time limit per test2 seconds
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# Imagine that you have a twin brother or sister. Having another person that looks exactly like you seems very unusual. It's hard to say if having something of an alter ego is good or bad. And if you do have a twin, then you very well know what it's like.
# 
# Now let's imagine a typical morning in your family. You haven't woken up yet, and Mom is already going to work. She has been so hasty that she has nearly forgotten to leave the two of her darling children some money to buy lunches in the school cafeteria. She fished in the purse and found some number of coins, or to be exact, n coins of arbitrary values a1, a2, ..., an. But as Mom was running out of time, she didn't split the coins for you two. So she scribbled a note asking you to split the money equally.
# 
# As you woke up, you found Mom's coins and read her note. "But why split the money equally?" — you thought. After all, your twin is sleeping and he won't know anything. So you decided to act like that: pick for yourself some subset of coins so that the sum of values of your coins is strictly larger than the sum of values of the remaining coins that your twin will have. However, you correctly thought that if you take too many coins, the twin will suspect the deception. So, you've decided to stick to the following strategy to avoid suspicions: you take the minimum number of coins, whose sum of values is strictly more than the sum of values of the remaining coins. On this basis, determine what minimum number of coins you need to take to divide them in the described manner.
# 
# Input
# The first line contains integer n (1 ≤ n ≤ 100) — the number of coins. The second line contains a sequence of n integers a1, a2, ..., an (1 ≤ ai ≤ 100) — the coins' values. All numbers are separated with spaces.
# 
# Output
# In the single line print the single number — the minimum needed number of coins.
# 
# Examples
# inputCopy
# 2
# 3 3
# outputCopy
# 2
# inputCopy
# 3
# 2 1 2
# outputCopy
# 2
# Note
# In the first sample you will have to take 2 coins (you and your twin have sums equal to 6, 0 correspondingly). If you take 1 coin, you get sums 3, 3. If you take 0 coins, you get sums 0, 6. Those variants do not satisfy you as your sum should be strictly more that your twins' sum.
# 
# In the second sample one coin isn't enough for us, too. You can pick coins with values 1, 2 or 2, 2. In any case, the minimum number of coins equals 2.
import sys


def solution(n: int) -> str:
    lst = list(map(int, sys.stdin.readline().rstrip().split()))
    lst.sort(reverse=True)
    remaining_sum: int = sum(lst)
    your_sum: int = 0
    coin_used: int = 0
    for coin in lst:
        coin_used += 1
        your_sum += coin
        remaining_sum -= coin
        if your_sum > remaining_sum:
            return str(coin_used)


if __name__ == '__main__':
    n: int = int(sys.stdin.readline().rstrip())
    sys.stdout.write(solution(n))

# Simple Fun #6: Is Infinite Process?
# Task
# Given integers a and b, determine whether the following pseudocode results in an infinite loop
# 
#  while (a !== b){
#      a++
#      b--
#  }
# Assume that the program is executed on a virtual machine which can store arbitrary long numbers and execute forever.
# 
# Example
# For a = 2 and b = 6, the output should be
# 
# isInfiniteProcess(a, b) = false (or equivalent in PHP)
# 
# For a = 2 and b = 3, the output should be
# 
# isInfiniteProcess(a, b) = true (or equivalent in PHP)
# 
# Input/Output
# [input] integer a
# Constraints: 0 ≤ a ≤ 100.
# 
# [input] integer b
# Constraints: 0 ≤ b ≤ 100.
# 
# [output] a boolean value
# true if the pseudocode will never stop, false otherwise.
# 
# PUZZLES
def is_infinite_process(a, b):
    idx: int = 0
    while a != b and idx < 101:
        idx += 1
        a += 1
        b -= 1
    return idx == 101
    
# 1248. Count Number of Nice Subarrays
# Given an array of integers nums and an integer k. A continuous subarray is called nice if there are k odd numbers on it.
# 
# Return the number of nice sub-arrays.
# 
#  
# 
# Example 1:
# 
# Input: nums = [1,1,2,1,1], k = 3
# Output: 2
# Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].
# Example 2:
# 
# Input: nums = [2,4,6], k = 1
# Output: 0
# Explanation: There are no odd numbers in the array.
# Example 3:
# 
# Input: nums = [2,2,2,1,2,2,1,2,2,2], k = 2
# Output: 16
#  
# 
# Constraints:
# 
# 1 <= nums.length <= 50000
# 1 <= nums[i] <= 10^5
# 1 <= k <= nums.length
# HashTable and PrefixSum
# Complexity
# Time complexity: O(N)
# Space complexity: O(N)
class Solution:
    def numberOfSubarrays(self, nums: List[int], k: int) -> int:
        for idx in range(len(nums)):
            nums[idx] = 1 if nums[idx] % 2 != 0 else 0
        prefix_sum: int = 0
        ht: dict[int, int] = {0: 1}
        total: int = 0
        for cur in nums:
            prefix_sum += cur
            total += ht.get(prefix_sum - k, 0)
            ht[prefix_sum] = ht.get(prefix_sum, 0) + 1
        return total

# Sliding Window
# Complexity
# Time complexity: O(N)
# Space complexity: O(1)
class Solution:
    def numberOfSubarrays(self, nums: List[int], k: int) -> int:
        total_subarrays: int = 0
        possible_variations: int = 0
        odd_numbers_in_subarray: int = 0
        left_pointer: int = 0
        for right_pointer in range(len(nums)):
            odd_numbers_in_subarray += nums[right_pointer] & 1
            if odd_numbers_in_subarray == k:
                possible_variations = 0
                while odd_numbers_in_subarray == k:
                    odd_numbers_in_subarray -= nums[left_pointer] & 1
                    possible_variations += 1
                    left_pointer += 1
            total_subarrays += possible_variations
        return total_subarrays

# 3190. Find Minimum Operations to Make All Elements Divisible by Three
# You are given an integer array nums. In one operation, you can add or subtract 1 from any element of nums.
#
# Return the minimum number of operations to make all elements of nums divisible by 3.
#
#
#
# Example 1:
#
# Input: nums = [1,2,3,4]
#
# Output: 3
#
# Explanation:
#
# All array elements can be made divisible by 3 using 3 operations:
#
# Subtract 1 from 1.
# Add 1 to 2.
# Subtract 1 from 4.
# Example 2:
#
# Input: nums = [3,6,9]
#
# Output: 0
#
#
#
# Constraints:
#
# 1 <= nums.length <= 50
# 1 <= nums[i] <= 50
class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        return sum(i % 3 != 0 for i in nums)

# 3191. Minimum Operations to Make Binary Array Elements Equal to One I
# You are given a 
# binary array
#  nums.
# 
# You can do the following operation on the array any number of times (possibly zero):
# 
# Choose any 3 consecutive elements from the array and flip all of them.
# Flipping an element means changing its value from 0 to 1, and from 1 to 0.
# 
# Return the minimum number of operations required to make all elements in nums equal to 1. If it is impossible, return -1.
# 
#  
# 
# Example 1:
# 
# Input: nums = [0,1,1,1,0,0]
# 
# Output: 3
# 
# Explanation:
# We can do the following operations:
# 
# Choose the elements at indices 0, 1 and 2. The resulting array is nums = [1,0,0,1,0,0].
# Choose the elements at indices 1, 2 and 3. The resulting array is nums = [1,1,1,0,0,0].
# Choose the elements at indices 3, 4 and 5. The resulting array is nums = [1,1,1,1,1,1].
# Example 2:
# 
# Input: nums = [0,1,1,1]
# 
# Output: -1
# 
# Explanation:
# It is impossible to make all elements equal to 1.
# 
#  
# 
# Constraints:
# 
# 3 <= nums.length <= 105
# 0 <= nums[i] <= 1
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        idx: int = 0
        count: int = 0
        while idx < len(nums) - 2:
            if nums[idx] == 0:
                count += 1
                nums[idx], nums[idx + 1], nums[idx + 2] = 1, int(not nums[idx + 1]), int(not nums[idx + 2])
            idx += 1
        return [-1, count][nums[-2] == nums[-1] == 1]
        
# 3192. Minimum Operations to Make Binary Array Elements Equal to One II
# You are given a 
# binary array
#  nums.
# 
# You can do the following operation on the array any number of times (possibly zero):
# 
# Choose any index i from the array and flip all the elements from index i to the end of the array.
# Flipping an element means changing its value from 0 to 1, and from 1 to 0.
# 
# Return the minimum number of operations required to make all elements in nums equal to 1.
# 
#  
# 
# Example 1:
# 
# Input: nums = [0,1,1,0,1]
# 
# Output: 4
# 
# Explanation:
# We can do the following operations:
# 
# Choose the index i = 1. The resulting array will be nums = [0,0,0,1,0].
# Choose the index i = 0. The resulting array will be nums = [1,1,1,0,1].
# Choose the index i = 4. The resulting array will be nums = [1,1,1,0,0].
# Choose the index i = 3. The resulting array will be nums = [1,1,1,1,1].
# Example 2:
# 
# Input: nums = [1,0,0,0]
# 
# Output: 1
# 
# Explanation:
# We can do the following operation:
# 
# Choose the index i = 1. The resulting array will be nums = [1,1,1,1].
#  
# 
# Constraints:
# 
# 1 <= nums.length <= 105
# 0 <= nums[i] <= 1
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        accumulate: int = 0
        idx: int = 0
        count: int = 0
        while idx < len(nums):
            nums[idx] = [nums[idx], int(not nums[idx])][accumulate]
            if nums[idx] == 0:
                accumulate = not accumulate
                count += 1
            idx += 1
        return count

# 1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit
# Given an array of integers nums and an integer limit, return the size of the longest non-empty subarray such that the absolute difference between any two elements of this subarray is less than or equal to limit.
#
#
#
# Example 1:
#
# Input: nums = [8,2,4,7], limit = 4
# Output: 2
# Explanation: All subarrays are:
# [8] with maximum absolute diff |8-8| = 0 <= 4.
# [8,2] with maximum absolute diff |8-2| = 6 > 4.
# [8,2,4] with maximum absolute diff |8-2| = 6 > 4.
# [8,2,4,7] with maximum absolute diff |8-2| = 6 > 4.
# [2] with maximum absolute diff |2-2| = 0 <= 4.
# [2,4] with maximum absolute diff |2-4| = 2 <= 4.
# [2,4,7] with maximum absolute diff |2-7| = 5 > 4.
# [4] with maximum absolute diff |4-4| = 0 <= 4.
# [4,7] with maximum absolute diff |4-7| = 3 <= 4.
# [7] with maximum absolute diff |7-7| = 0 <= 4.
# Therefore, the size of the longest subarray is 2.
# Example 2:
#
# Input: nums = [10,1,2,4,7,2], limit = 5
# Output: 4
# Explanation: The subarray [2,4,7,2] is the longest since the maximum absolute diff is |2-7| = 5 <= 5.
# Example 3:
#
# Input: nums = [4,2,2,2,4,4,2,2], limit = 0
# Output: 3
#
#
# Constraints:
#
# 1 <= nums.length <= 105
# 1 <= nums[i] <= 109
# 0 <= limit <= 109
# Solution Monotonic Queue O(N) O(N)
from collections import deque
class Solution:
    def longestSubarray(self, nums: List[int], limit: int) -> int:
        minimum_item = deque()
        maximum_item = deque()
        left_pointer: int = 0
        max_length_of_subarray: int = 0
        for right_pointer in range(len(nums)):
            while minimum_item and nums[right_pointer] < minimum_item[-1]:
                minimum_item.pop()
            minimum_item.append(nums[right_pointer])
            while maximum_item and nums[right_pointer] > maximum_item[-1]:
                maximum_item.pop()
            maximum_item.append(nums[right_pointer])
            while maximum_item[0] - minimum_item[0] > limit:
                if nums[left_pointer] == minimum_item[0]:
                    minimum_item.popleft()
                if nums[left_pointer] == maximum_item[0]:
                    maximum_item.popleft()
                left_pointer += 1
            max_length_of_subarray = max(max_length_of_subarray, right_pointer - left_pointer + 1)
        return max_length_of_subarray
# Solution Monotonic Queue with more native logic O(N) O(N)
from collections import deque
class Solution:
    def longestSubarray(self, nums: List[int], limit: int) -> int:
        minimum_item = deque()
        maximum_item = deque()
        left_pointer: int = 0
        max_length_of_subarray: int = 0
        for right_pointer in range(len(nums)):
            while minimum_item and nums[right_pointer] < nums[minimum_item[-1]]:
                minimum_item.pop()
            minimum_item.append(right_pointer)
            while maximum_item and nums[right_pointer] > nums[maximum_item[-1]]:
                maximum_item.pop()
            maximum_item.append(right_pointer)
            while minimum_item and maximum_item and nums[maximum_item[0]] - nums[minimum_item[0]] > limit:
                if left_pointer >= minimum_item[0]:
                    minimum_item.popleft()
                if left_pointer >= maximum_item[0]:
                    maximum_item.popleft()
                left_pointer += 1
            max_length_of_subarray = max(max_length_of_subarray, right_pointer - left_pointer + 1)
        return max_length_of_subarray

# 3194. Minimum Average of Smallest and Largest Elements
# You have an array of floating point numbers averages which is initially empty. You are given an array nums of n integers where n is even.
# 
# You repeat the following procedure n / 2 times:
# 
# Remove the smallest element, minElement, and the largest element maxElement, from nums.
# Add (minElement + maxElement) / 2 to averages.
# Return the minimum element in averages.
# 
#  
# 
# Example 1:
# 
# Input: nums = [7,8,3,4,15,13,4,1]
# 
# Output: 5.5
# 
# Explanation:
# 
# step	nums	averages
# 0	[7,8,3,4,15,13,4,1]	[]
# 1	[7,8,3,4,13,4]	[8]
# 2	[7,8,4,4]	[8,8]
# 3	[7,4]	[8,8,6]
# 4	[]	[8,8,6,5.5]
# The smallest element of averages, 5.5, is returned.
# Example 2:
# 
# Input: nums = [1,9,8,3,10,5]
# 
# Output: 5.5
# 
# Explanation:
# 
# step	nums	averages
# 0	[1,9,8,3,10,5]	[]
# 1	[9,8,3,5]	[5.5]
# 2	[8,5]	[5.5,6]
# 3	[]	[5.5,6,6.5]
# Example 3:
# 
# Input: nums = [1,2,3,7,8,9]
# 
# Output: 5.0
# 
# Explanation:
# 
# step	nums	averages
# 0	[1,2,3,7,8,9]	[]
# 1	[2,3,7,8]	[5]
# 2	[3,7]	[5,5]
# 3	[]	[5,5,5]
#  
# 
# Constraints:
# 
# 2 <= n == nums.length <= 50
# n is even.
# 1 <= nums[i] <= 50
class Solution:
    def minimumAverage(self, nums: List[int]) -> float:
        nums.sort()
        left, right = 0, len(nums) - 1
        min_average: float = float('inf')
        while left < right:
            min_average = min(min_average, (nums[left] + nums[right]) / 2)
            left, right = left + 1, right - 1
        return min_average

# 3195. Find the Minimum Area to Cover All Ones I
# You are given a 2D binary array grid. Find a rectangle with horizontal and vertical sides with the smallest area, such that all the 1's in grid lie inside this rectangle.
# 
# Return the minimum possible area of the rectangle.
# 
#  
# 
# Example 1:
# 
# Input: grid = [[0,1,0],[1,0,1]]
# 
# Output: 6
# 
# Explanation:
# 
# 
# 
# The smallest rectangle has a height of 2 and a width of 3, so it has an area of 2 * 3 = 6.
# 
# Example 2:
# 
# Input: grid = [[0,0],[1,0]]
# 
# Output: 1
# 
# Explanation:
# 
# 
# 
# The smallest rectangle has both height and width 1, so its area is 1 * 1 = 1.
# 
#  
# 
# Constraints:
# 
# 1 <= grid.length, grid[i].length <= 1000
# grid[i][j] is either 0 or 1.
# The input is generated such that there is at least one 1 in grid.
class Solution:
    def minimumArea(self, grid: List[List[int]]) -> int:
        up = left = float('inf')
        down = right = float('-inf')
        for row in range(len(grid)):
            for col in range(len(grid[0])):
                if grid[row][col]:
                    up = min(up, row)
                    down = max(down, row)
                    right = max(right, col)
                    left = min(left, col)
        area: int = (right - left + 1) * (down - up + 1)
        return area

# A. Calculating Function
# A. Calculating Function
# time limit per test1 second
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# For a positive integer n let's define a function f:
#
# f(n) =  - 1 + 2 - 3 + .. + ( - 1)nn
#
# Your task is to calculate f(n) for a given integer n.
#
# Input
# The single line contains the positive integer n (1 ≤ n ≤ 1015).
#
# Output
# Print f(n) in a single line.
#
# Examples
# inputCopy
# 4
# outputCopy
# 2
# inputCopy
# 5
# outputCopy
# -3
# Note
# f(4) =  - 1 + 2 - 3 + 4 = 2
#
# f(5) =  - 1 + 2 - 3 + 4 - 5 =  - 3
import sys

def solution(n: int) -> str:
    answer: int = 0
    negative: int = ((n + 1) // 2) * (1 + (n if n & 1 else n - 1)) // 2
    positive: int = (n // 2) * (2 + (n if not n & 1 else n - 1)) // 2
    answer = positive - negative
    return str(answer)

if __name__ == '__main__':
    n: int = int(sys.stdin.readline().rstrip())
    sys.stdout.write(solution(n))

# Tunnel Digging
# Given a list r, return how long it would take a tunnel boring machine to excavate a tunnel through r.
#
# r is a list that contain the following sections made of combinations of the following:
#
# Very hard rock []: this section takes 60 minutes to excavate
# Hard Rock {}: this section takes 50 minutes to excavate
# Somewhat Hard Rock (): this section takes 40 minutes to excavate
# Somewhat Soft Rock ||: this section takes 30 minutes to excavate
# Soft Rock ::: this section takes 20 minutes to excavate
# Broken Rock   : this section only needs to be cleared (see below)
# After every 3 sections it excavates, the machine needs to stop for 30 minutes so workers can remove the excavated rock.
#
# Notes:
# The returned time should be in minutes
# 'r' may contain sections with only one half. Example: [ should equal 30
# Examples
# tunnel_digging(['()', ')']) # returns 60
# tunnel_digging([': ', '  ', ': ']) # returns 50
# tunnel_digging(['|)', '{ ', '{ ', '|]', '{ ', ' }']) # returns 240
# tunnel_digging(['( ', '()', '(}', '[]', '{ ', '{ ']) # returns 275
# tunnel_digging(['  ', '{ ', '[ ', '[)', '[}']) # returns 190
# tunnel_digging(['{ ', ' }', '[}', ': ', '[ ', ':|']) # returns 230
# FUNDAMENTALS
def tunnel_digging(r):
    ht: dict[str, int] = {
        '[': 30, ']': 30, '{': 25, '}': 25,
        '(': 20, ')': 20, '|': 15, ':': 10,
        ' ': 0,
    }
    total: int = 0
    moves: int = 0
    for move in r:
        for char in move:
            total += ht.get(char)
        moves += 1
        if moves % 3 == 0:
            total += 30
    return total

# 995. Minimum Number of K Consecutive Bit Flips
# You are given a binary array nums and an integer k.
# 
# A k-bit flip is choosing a subarray of length k from nums and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.
# 
# Return the minimum number of k-bit flips required so that there is no 0 in the array. If it is not possible, return -1.
# 
# A subarray is a contiguous part of an array.
# 
#  
# 
# Example 1:
# 
# Input: nums = [0,1,0], k = 1
# Output: 2
# Explanation: Flip nums[0], then flip nums[2].
# Example 2:
# 
# Input: nums = [1,1,0], k = 2
# Output: -1
# Explanation: No matter how we flip subarrays of size 2, we cannot make the array become [1,1,1].
# Example 3:
# 
# Input: nums = [0,0,0,1,0,1,1,0], k = 3
# Output: 3
# Explanation: 
# Flip nums[0],nums[1],nums[2]: nums becomes [1,1,1,1,0,1,1,0]
# Flip nums[4],nums[5],nums[6]: nums becomes [1,1,1,1,1,0,0,0]
# Flip nums[5],nums[6],nums[7]: nums becomes [1,1,1,1,1,1,1,1]
#  
# 
# Constraints:
# 
# 1 <= nums.length <= 105
# 1 <= k <= nums.length
from collections import deque
class Solution:
    def minKBitFlips(self, nums: List[int], k: int) -> int:
        periods = deque()
        total_flips: int = 0
        for idx in range(len(nums)):
            while periods and idx > periods[0]:
                periods.popleft()
            nums[idx] = [nums[idx], int(not nums[idx])][len(periods) % 2]
            if nums[idx] == 0 and idx < len(nums) - k + 1:
                total_flips += 1
                nums[idx] = 1
                periods.append(idx + k - 1)
            elif nums[idx] == 0:
                return -1
        return total_flips

# A. Even Odds
# A. Even Odds
# time limit per test1 second
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# Being a nonconformist, Volodya is displeased with the current state of things, particularly with the order of natural numbers (natural number is positive integer number). He is determined to rearrange them. But there are too many natural numbers, so Volodya decided to start with the first n. He writes down the following sequence of numbers: firstly all odd integers from 1 to n (in ascending order), then all even integers from 1 to n (also in ascending order). Help our hero to find out which number will stand at the position number k.
#
# Input
# The only line of input contains integers n and k (1 ≤ k ≤ n ≤ 1012).
#
# Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.
#
# Output
# Print the number that will stand at the position number k after Volodya's manipulations.
#
# Examples
# inputCopy
# 10 3
# outputCopy
# 5
# inputCopy
# 7 7
# outputCopy
# 6
# Note
# In the first sample Volodya's sequence will look like this: {1, 3, 5, 7, 9, 2, 4, 6, 8, 10}. The third place in the sequence is therefore occupied by the number 5.
import sys

def solution(n: int, k: int) -> str:
    odd = (n + 1) // 2
    even = n // 2
    if k <= odd:
        return str(1 + (k - 1)*2)
    k -= odd
    return str(2 + (k - 1) * 2)

if __name__ == '__main__':
    n, k = map(int, sys.stdin.readline().rstrip().split())
    sys.stdout.write(solution(n, k))

# Simple Fun #182: Happy "g"
# Task
# Let's say that "g" is happy in the given string, if there is another "g" immediately to the right or to the left of it.
#
# Find out if all "g"s in the given string are happy.
#
# Example
# For str = "gg0gg3gg0gg", the output should be true.
#
# For str = "gog", the output should be false.
#
# Input/Output
# [input] string str
# A random string of lower case letters, numbers and spaces.
#
# [output] a boolean value
# true if all "g"s are happy, false otherwise.
#
# PUZZLESSTRINGSREGULAR EXPRESSIONS
def happy_g(st):
    idx: int = 0
    while idx < len(st):
        if st[idx] == 'g':
            if idx > 0 and st[idx - 1] == 'g': idx += 1
            elif idx + 1 == len(st): return False
            elif st[idx + 1] != 'g': return False
            else: idx += 1
        else:
            idx += 1
    return True

# A. Ultra-Fast Mathematician
# A. Ultra-Fast Mathematician
# time limit per test2 seconds
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# Shapur was an extremely gifted student. He was great at everything including Combinatorics, Algebra, Number Theory, Geometry, Calculus, etc. He was not only smart but extraordinarily fast! He could manage to sum 1018 numbers in a single second.
# 
# One day in 230 AD Shapur was trying to find out if any one can possibly do calculations faster than him. As a result he made a very great contest and asked every one to come and take part.
# 
# In his contest he gave the contestants many different pairs of numbers. Each number is made from digits 0 or 1. The contestants should write a new number corresponding to the given pair of numbers. The rule is simple: The i-th digit of the answer is 1 if and only if the i-th digit of the two given numbers differ. In the other case the i-th digit of the answer is 0.
# 
# Shapur made many numbers and first tried his own speed. He saw that he can perform these operations on numbers of length ∞ (length of a number is number of digits in it) in a glance! He always gives correct answers so he expects the contestants to give correct answers, too. He is a good fellow so he won't give anyone very big numbers and he always gives one person numbers of same length.
# 
# Now you are going to take part in Shapur's contest. See if you are faster and more accurate.
# 
# Input
# There are two lines in each input. Each of them contains a single number. It is guaranteed that the numbers are made from 0 and 1 only and that their length is same. The numbers may start with 0. The length of each number doesn't exceed 100.
# 
# Output
# Write one line — the corresponding answer. Do not omit the leading 0s.
# 
# Examples
# inputCopy
# 1010100
# 0100101
# outputCopy
# 1110001
# inputCopy
# 000
# 111
# outputCopy
# 111
# inputCopy
# 1110
# 1010
# outputCopy
# 0100
# inputCopy
# 01110
# 01100
# outputCopy
# 00010
import sys

def solution(x: str, y: str) -> str:
    return ''.join(['0', '1'][xi != yi] for xi, yi in zip(x, y))

if __name__ == '__main__':
    x: str = sys.stdin.readline().rstrip()
    y: str = sys.stdin.readline().rstrip()
    sys.stdout.write(solution(x, y))
    
# Go: Stone Scoring
# One traditional method of determining the winning side of a Go match is called stone scoring. This method has some flaws but is algorithmically the easiest one. Therefore, we will start of with this method.
# 
# Your puzzle inputs are list of lists that represents a Go board like:
# 
# board = [
#     ["W","W","W","B","B","B"],
#     ["W","W","W","W","B","B"],
#     ["W","W","W","B","B","B"],
#     ["W","X","W","B","B","B"],
#     ["X","W","B","B","B","B"],
#     ["W","W","B","X","B","X"]
# ]
# "B"s represent fields with black stones, "W"s represent fields with white stones, and "X"s represent empty fields. Your task is to determine the winning side, i.e., the side with more stones on the board. Then, return either "W" or "B" and the number of the side's stones as a tuple depending on which side has more stones on the board. If there is a tie, return a "T" and the number of stones of one side as a tuple, e.g. ("T", 32). Empty fields, i.e., "X"s, are not considered in this method for determining the winning side. Thus, they can be ignored.
# 
# In the example, "B" has 17 stones on the boards whereas "W" only has 15. Hence, the black side won and ("B", 17) should be returned.
# 
# Be aware that the board can vary in size but is at least of size 3x3!
# 
# LISTSFUNDAMENTALS
def determine_winner(board):
    black: int = 0
    white: int = 0
    for row in range(len(board)):
        for col in range(len(board[0])):
            black += board[row][col] == 'B'
            white += board[row][col] == 'W'
    return ('T', white) if white == black else (['B', 'W'][white > black], max(white, black))
    
# 1038. Binary Search Tree to Greater Sum Tree
# Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.
#
# As a reminder, a binary search tree is a tree that satisfies these constraints:
#
# The left subtree of a node contains only nodes with keys less than the node's key.
# The right subtree of a node contains only nodes with keys greater than the node's key.
# Both the left and right subtrees must also be binary search trees.
#
#
# Example 1:
#
#
# Input: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
# Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
# Example 2:
#
# Input: root = [0,null,1]
# Output: [1,null,1]
#
#
# Constraints:
#
# The number of nodes in the tree is in the range [1, 100].
# 0 <= Node.val <= 100
# All the values in the tree are unique.
#
#
# Note: This question is the same as 538: https://leetcode.com/problems/convert-bst-to-greater-tree/
class Solution:
    def bstToGst(self, root: TreeNode) -> TreeNode:
        self.accumulate: int = 0   
        def dfs(node):
            if not node:return  
            dfs(node.right)
            self.accumulate += node.val
            node.val = self.accumulate
            dfs(node.left)
        dfs(root)
        return root
        
# 538. Convert BST to Greater Tree
# Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.
# 
# As a reminder, a binary search tree is a tree that satisfies these constraints:
# 
# The left subtree of a node contains only nodes with keys less than the node's key.
# The right subtree of a node contains only nodes with keys greater than the node's key.
# Both the left and right subtrees must also be binary search trees.
#  
# 
# Example 1:
# 
# 
# Input: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
# Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
# Example 2:
# 
# Input: root = [0,null,1]
# Output: [1,null,1]
#  
# 
# Constraints:
# 
# The number of nodes in the tree is in the range [0, 104].
# -104 <= Node.val <= 104
# All the values in the tree are unique.
# root is guaranteed to be a valid binary search tree.
#  
# 
# Note: This question is the same as 1038: https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def convertBST(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        self.accumulate: int = 0
        def dfs(root):
            if not root: return 
            dfs(root.right)
            self.accumulate += root.val
            root.val = self.accumulate
            dfs(root.left)
        dfs(root)
        return root

# A. Presents
# A. Presents
# time limit per test2 seconds
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# Little Petya very much likes gifts. Recently he has received a new laptop as a New Year gift from his mother. He immediately decided to give it to somebody else as what can be more pleasant than giving somebody gifts. And on this occasion he organized a New Year party at his place and invited n his friends there.
#
# If there's one thing Petya likes more that receiving gifts, that's watching others giving gifts to somebody else. Thus, he safely hid the laptop until the next New Year and made up his mind to watch his friends exchanging gifts while he does not participate in the process. He numbered all his friends with integers from 1 to n. Petya remembered that a friend number i gave a gift to a friend number pi. He also remembered that each of his friends received exactly one gift.
#
# Now Petya wants to know for each friend i the number of a friend who has given him a gift.
#
# Input
# The first line contains one integer n (1 ≤ n ≤ 100) — the quantity of friends Petya invited to the party. The second line contains n space-separated integers: the i-th number is pi — the number of a friend who gave a gift to friend number i. It is guaranteed that each friend received exactly one gift. It is possible that some friends do not share Petya's ideas of giving gifts to somebody else. Those friends gave the gifts to themselves.
#
# Output
# Print n space-separated integers: the i-th number should equal the number of the friend who gave a gift to friend number i.
#
# Examples
# inputCopy
# 4
# 2 3 4 1
# outputCopy
# 4 1 2 3
# inputCopy
# 3
# 1 3 2
# outputCopy
# 1 3 2
# inputCopy
# 2
# 1 2
# outputCopy
# 1 2
import sys

def solution(n: int, friends: list) -> str:
    output: list = [0] * n
    for idx in range(n):
        output[friends[idx] - 1] = str(idx + 1)
    return ' '.join(output)

if __name__ == '__main__':
    n: int = int(sys.stdin.readline().rstrip())
    friends: list = list(map(int, sys.stdin.readline().rstrip().split()))
    sys.stdout.write(solution(n, friends))
    
# 1982A. Soccer
# A. Soccer
# time limit per test1 second
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# Dima loves watching soccer. In such a game, the score on the scoreboard is represented as x
#  : y
# , where x
#  is the number of goals of the first team, and y
#  is the number of goals of the second team. At any given time, only one team can score a goal, so the score x
#  : y
#  can change to either (x+1)
#  : y
# , or x
#  : (y+1)
# .
# 
# While watching a soccer game, Dima was distracted by very important matters, and after some time, he returned to watching the game. Dima remembers the score right before he was distracted, and the score right after he returned. Given these two scores, he wonders the following question. Is it possible that, while Dima was not watching the game, the teams never had an equal score?
# 
# It is guaranteed that at neither of the two time points Dima remembers the teams had equal scores. However, it is possible that the score did not change during his absence.
# 
# Help Dima and answer the question!
# 
# Input
# Each test consists of several test cases. The first line contains an integer t
#  (1≤t≤104
# ) — the number of test cases. Then follows the description of the test cases.
# 
# The first line of each test case contains two integers x1,y1
#  (0≤x1,y1≤109
# , x1≠y1
# ) — the score before Dima was distracted.
# 
# The second line of each test case contains two integers x2,y2
#  (x1≤x2≤109
# , y1≤y2≤109
# , x2≠y2
# ) — the score when Dima returned.
# 
# Output
# For each test case, output "YES" without quotes if it is possible, that the teams never had a tie while Dima was away, otherwise output "NO" without quotes.
# 
# You can output each letter in any case (for example, the strings "yEs", "yes", "Yes", and "YES" will be recognized as a positive answer).
# 
# Example
# inputCopy
# 6
# 1 0
# 5 0
# 1 2
# 3 2
# 1 2
# 4 5
# 1 2
# 4 3
# 1 2
# 1 2
# 998244353 0
# 1000000000 999999999
# outputCopy
# YES
# NO
# YES
# NO
# YES
# YES
# Note
# In the first test case, the score before Dima left was 1
#  : 0
# . When he leaves, the first team scores several goals in a row until the score becomes 5
#  : 0
# , so the answer is YES.
# 
# In the second test case, the score could only change as follows:
# 
# 1
#  : 2
# 2
#  : 2
# 3
#  : 2
# In this scenario, there is a moment when the teams have an equal score, so the answer is NO.
# 
# In the third test case, one of the possible developments is:
# 
# 1
#  : 2
# 1
#  : 3
# 2
#  : 3
# 2
#  : 4
# 2
#  : 5
# 3
#  : 5
# 4
#  : 5
# In this scenario, there was no time when the score was equal, so the answer is YES.
# Solution O(1) O(1)
import sys


def solution(t: int) -> None:
    for _ in range(t):
        x, y = map(int, sys.stdin.readline().rstrip().split())
        xn, yn = map(int, sys.stdin.readline().rstrip().split())
        if x == y and xn != yn:
            print('YES')
        elif x > y and xn > yn:
            print('YES')
        elif y > x and yn > xn:
            print('YES')
        else:
            print('NO')


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)
    
# 1382. Balance a Binary Search Tree
# Given the root of a binary search tree, return a balanced binary search tree with the same node values. If there is more than one answer, return any of them.
#
# A binary search tree is balanced if the depth of the two subtrees of every node never differs by more than 1.
#
#
#
# Example 1:
#
#
# Input: root = [1,null,2,null,3,null,4,null,null]
# Output: [2,1,3,null,null,null,4]
# Explanation: This is not the only correct answer, [3,1,4,null,2] is also correct.
# Example 2:
#
#
# Input: root = [2,1,3]
# Output: [2,1,3]
#
#
# Constraints:
#
# The number of nodes in the tree is in the range [1, 104].
# 1 <= Node.val <= 105
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def balanceBST(self, root: TreeNode) -> TreeNode:
        self.array: list[int] = []
        def inorder_traversal(root) -> None:
            if not root: return
            inorder_traversal(root.left)
            self.array.append(root.val)
            inorder_traversal(root.right)
        def constructed_bst(left, right):
            if left > right: return
            middle: int = (left + right) >> 1
            left = constructed_bst(left, middle - 1)
            right = constructed_bst(middle + 1, right)
            return TreeNode(self.array[middle], left, right)
        inorder_traversal(root)
        return constructed_bst(0, len(self.array) - 1)
    
# Simple Fun #59: Reverse On Diagonals
# Task
# Given a square matrix, your task is to reverse the order of elements on both of its longest diagonals.
# 
# The longest diagonals of a square matrix are defined as follows:
# 
# the first longest diagonal goes from the top left corner to the bottom right one;
# the second longest diagonal goes from the top right corner to the bottom left one.
# Example
# For the matrix
# 
# 1, 2, 3
# 4, 5, 6
# 7, 8, 9
# the output should be:
# 
# 9, 2, 7
# 4, 5, 6
# 3, 8, 1
# Input/Output
# [input] 2D integer array matrix
# 
# Constraints: 1 ≤ matrix.length ≤ 10, matrix.length = matrix[i].length, 1 ≤ matrix[i][j] ≤ 1000
# 
# [output] 2D integer array
# 
# Matrix with the order of elements on its longest diagonals reversed.
# 
# PUZZLES
def reverse_on_diagonals(matrix):
    idx: int = 0
    middle: int = len(matrix) // 2
    for row in range(len(matrix)):
        if idx == middle: break
        matrix[idx][idx], matrix[-idx - 1][-idx - 1] = matrix[-idx - 1][-idx - 1], matrix[idx][idx]
        idx += 1
    idx = 0
    for row in range(len(matrix)):
        if idx == middle: break
        matrix[idx][-idx - 1], matrix[-idx - 1][idx] = matrix[-idx - 1][idx], matrix[idx][-idx - 1]
        idx += 1
    return matrix

# B. Drinks
# B. Drinks
# time limit per test2 seconds
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# Little Vasya loves orange juice very much. That's why any food and drink in his kitchen necessarily contains orange juice. There are n drinks in his fridge, the volume fraction of orange juice in the i-th drink equals pi percent.
#
# One day Vasya decided to make himself an orange cocktail. He took equal proportions of each of the n drinks and mixed them. Then he wondered, how much orange juice the cocktail has.
#
# Find the volume fraction of orange juice in the final drink.
#
# Input
# The first input line contains a single integer n (1 ≤ n ≤ 100) — the number of orange-containing drinks in Vasya's fridge. The second line contains n integers pi (0 ≤ pi ≤ 100) — the volume fraction of orange juice in the i-th drink, in percent. The numbers are separated by a space.
#
# Output
# Print the volume fraction in percent of orange juice in Vasya's cocktail. The answer will be considered correct if the absolute or relative error does not exceed 10  - 4.
#
# Examples
# inputCopy
# 3
# 50 50 100
# outputCopy
# 66.666666666667
# inputCopy
# 4
# 0 25 50 75
# outputCopy
# 37.500000000000
# Note
# Note to the first sample: let's assume that Vasya takes x milliliters of each drink from the fridge. Then the volume of pure juice in the cocktail will equal  milliliters. The total cocktail's volume equals 3·x milliliters, so the volume fraction of the juice in the cocktail equals , that is, 66.(6) percent.
import sys

def solution(n: int, juice: list) -> str:
    return str(sum(juice) / n)

if __name__ == '__main__':
    n: int = int(sys.stdin.readline().rstrip())
    juice: list = list(map(int, sys.stdin.readline().rstrip().split()))
    sys.stdout.write(solution(n, juice))
    
# 1791. Find Center of Star Graph
# There is an undirected star graph consisting of n nodes labeled from 1 to n. A star graph is a graph where there is one center node and exactly n - 1 edges that connect the center node with every other node.
#
# You are given a 2D integer array edges where each edges[i] = [ui, vi] indicates that there is an edge between the nodes ui and vi. Return the center of the given star graph.
#
#
#
# Example 1:
#
#
# Input: edges = [[1,2],[2,3],[4,2]]
# Output: 2
# Explanation: As shown in the figure above, node 2 is connected to every other node, so 2 is the center.
# Example 2:
#
# Input: edges = [[1,2],[5,1],[1,3],[1,4]]
# Output: 1
#
#
# Constraints:
#
# 3 <= n <= 105
# edges.length == n - 1
# edges[i].length == 2
# 1 <= ui, vi <= n
# ui != vi
# The given edges represent a valid star graph.
# HashSet, works only in valid start graph
# Complexity
# Time complexity: O(N), but in the real definition of start graph it will take O(1), because we only need one iteration to check start graph
# Space complexity: O(N)
# Code
class Solution:
    def findCenter(self, edges: List[List[int]]) -> int:
        ways: set[int] = set()
        for path in edges:
            start, end = path
            if start in ways: return start
            if end in ways: return end
            ways.add(start)
            ways.add(end)

# HashMap, works on every star graph(also in invalid star graph)
# Complexity
# Time complexity: O(N)
# Space complexity: O(N)
# Code
from collections import defaultdict
class Solution:
    def findCenter(self, edges: List[List[int]]) -> int:
        ways: dict[int, int] = defaultdict(int)
        n: int = len(edges)
        for path in edges:
            start, end = path
            ways[start] += 1
            ways[end] += 1
        for vertex in ways:
            if ways[vertex] == n:
                return vertex

# Tricky hack, but works only in valid star graph
# Complexity
# Time complexity: O(1)
# Space complexity: O(1)
# Code
class Solution:
    def findCenter(self, edges: List[List[int]]) -> int:
        return edges[0][0] if edges[0][0] in edges[1] else edges[0][1]

# Geometric sequence - sum of all elements
# Background
# 
# A geometric progression/series is the sum of a geometric sequence.
# 
# A geometric sequence is a sequence of numbers that scale by a common ratio, usually denoted as r. To get the next term, multiply the current term by this value. The first term is provided for this kata.
# 
# For example, the first 4 terms of the geometric sequence with first term 2 and ratio 3 is 2, 6, 18, 54. Notice that, given any term, it is 3 times larger than the last term for this case.
# 
# A geometric series is just the first n terms of the sequence summed together. As an example, the sum of the first 4 terms of the example provided above is 90.
# 
# Kata Task
# 
# Write a function geometric_sequence_sum(a, r, n), which will help you compute a geometric progression/series.
# 
# The parameters provided are as follows:
# 
# a is the first term
# r is the common ratio
# n is the amount of terms
# Example:
# 
# geometric_sequence_sum(2, 3, 5) should return 242.
# 
# Input constraints:
# 
# a: 1 - 10
# r: -10 - 10
# n: 2-15
# Tests:
# 
# 5 fixed tests
# 50 random tests
# For tests with decimal values your solution must have precision of 1e-9.
# 
# More info: https://en.wikipedia.org/wiki/Geometric_progression
# 
# FUNDAMENTALS
def geometric_sequence_sum(a, r, n):
    x: int = a
    total: int = x
    n -= 1
    for i in range(n):
        x *= r
        total += x
    return total

# 2285. Maximum Total Importance of Roads
# You are given an integer n denoting the number of cities in a country. The cities are numbered from 0 to n - 1.
# 
# You are also given a 2D integer array roads where roads[i] = [ai, bi] denotes that there exists a bidirectional road connecting cities ai and bi.
# 
# You need to assign each city with an integer value from 1 to n, where each value can only be used once. The importance of a road is then defined as the sum of the values of the two cities it connects.
# 
# Return the maximum total importance of all roads possible after assigning the values optimally.
# 
#  
# 
# Example 1:
# 
# 
# Input: n = 5, roads = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]
# Output: 43
# Explanation: The figure above shows the country and the assigned values of [2,4,5,3,1].
# - The road (0,1) has an importance of 2 + 4 = 6.
# - The road (1,2) has an importance of 4 + 5 = 9.
# - The road (2,3) has an importance of 5 + 3 = 8.
# - The road (0,2) has an importance of 2 + 5 = 7.
# - The road (1,3) has an importance of 4 + 3 = 7.
# - The road (2,4) has an importance of 5 + 1 = 6.
# The total importance of all roads is 6 + 9 + 8 + 7 + 7 + 6 = 43.
# It can be shown that we cannot obtain a greater total importance than 43.
# Example 2:
# 
# 
# Input: n = 5, roads = [[0,3],[2,4],[1,3]]
# Output: 20
# Explanation: The figure above shows the country and the assigned values of [4,3,2,5,1].
# - The road (0,3) has an importance of 4 + 5 = 9.
# - The road (2,4) has an importance of 2 + 1 = 3.
# - The road (1,3) has an importance of 3 + 5 = 8.
# The total importance of all roads is 9 + 3 + 8 = 20.
# It can be shown that we cannot obtain a greater total importance than 20.
#  
# 
# Constraints:
# 
# 2 <= n <= 5 * 104
# 1 <= roads.length <= 5 * 104
# roads[i].length == 2
# 0 <= ai, bi <= n - 1
# ai != bi
# There are no duplicate roads.
 from collections import defaultdict
class Solution:
    def maximumImportance(self, n: int, roads: List[List[int]]) -> int:
        vertex: dict[int, int] = defaultdict(int)
        for path in roads:
            start, end = path
            vertex[start] += 1
            vertex[end] += 1
        frequences: list[int] = sorted(vertex.values())
        total: int = 0
        accumulate: int = n
        for vertex in range(len(frequences) - 1, -1, -1):
            total += frequences[vertex] * accumulate
            accumulate -= 1
        return total

# A. Is your horseshoe on the other hoof?
# A. Is your horseshoe on the other hoof?
# time limit per test2 seconds
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# Valera the Horse is going to the party with friends. He has been following the fashion trends for a while, and he knows that it is very popular to wear all horseshoes of different color. Valera has got four horseshoes left from the last year, but maybe some of them have the same color. In this case he needs to go to the store and buy some few more horseshoes, not to lose face in front of his stylish comrades.
#
# Fortunately, the store sells horseshoes of all colors under the sun and Valera has enough money to buy any four of them. However, in order to save the money, he would like to spend as little money as possible, so you need to help Valera and determine what is the minimum number of horseshoes he needs to buy to wear four horseshoes of different colors to a party.
#
# Input
# The first line contains four space-separated integers s1, s2, s3, s4 (1 ≤ s1, s2, s3, s4 ≤ 109) — the colors of horseshoes Valera has.
#
# Consider all possible colors indexed with integers.
#
# Output
# Print a single integer — the minimum number of horseshoes Valera needs to buy.
#
# Examples
# inputCopy
# 1 7 3 3
# outputCopy
# 1
# inputCopy
# 7 7 7 7
# outputCopy
# 3
import sys

def solution(shoes: list) -> str:
    return str(max(4 - len(set(shoes)), 0))

if __name__ == '__main__':
    shoes: list = list(map(int, sys.stdin.readline().rstrip().split()))
    sys.stdout.write(solution(shoes))

# Thue-Morse Sequence
# Given a positive integer n, return first n dgits of Thue-Morse sequence, as a string (see examples).
# 
# Thue-Morse sequence is a binary sequence with 0 as the first element. The rest of the sequence is obtained by adding the boolean (binary) complement of a group obtained so far.
# 
# For example:
# 
# 0
# 01
# 0110
# 01101001
# and so on...
# alt
# 
# Ex.:
# 
#  1 --> "0"
#  2 --> "01"
#  5 --> "01101"
# 10 --> "0110100110"
# You don't need to test if n is valid - it will always be a positive integer.
# n will be between 1 and 10000
# Thue-Morse on Wikipedia
# 
# Another kata on Thue-Morse by @myjinxin2015
# 
# STRINGSBINARYALGORITHMS
def thue_morse(n):
    if n == 1: return '0'
    n -= 1
    digits: list[str] = ['0']
    accumulate: int = ''
    while len(digits) <= n:
        new_pair: list[str] = [['1', '0'][i == '1'] for i in digits]
        digits.extend(new_pair)
    return ''.join(digits[:n + 1])

# A. HQ9+
# A. HQ9+
# time limit per test2 seconds
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# HQ9+ is a joke programming language which has only four one-character instructions:
#
# "H" prints "Hello, World!",
# "Q" prints the source code of the program itself,
# "9" prints the lyrics of "99 Bottles of Beer" song,
# "+" increments the value stored in the internal accumulator.
# Instructions "H" and "Q" are case-sensitive and must be uppercase. The characters of the program which are not instructions are ignored.
#
# You are given a program written in HQ9+. You have to figure out whether executing this program will produce any output.
#
# Input
# The input will consist of a single line p which will give a program in HQ9+. String p will contain between 1 and 100 characters, inclusive. ASCII-code of each character of p will be between 33 (exclamation mark) and 126 (tilde), inclusive.
#
# Output
# Output "YES", if executing the program will produce any output, and "NO" otherwise.
#
# Examples
# inputCopy
# Hi!
# outputCopy
# YES
# inputCopy
# Codeforces
# outputCopy
# NO
# Note
# In the first case the program contains only one instruction — "H", which prints "Hello, World!".
#
# In the second case none of the program characters are language instructions.
import sys

def solution(n: str) -> str:
    return ['NO', 'YES'][any(char in 'HQ9' for char in n)]

if __name__ == '__main__':
    n: str = sys.stdin.readline().rstrip()
    sys.stdout.write(solution(n))
    
# 2192. All Ancestors of a Node in a Directed Acyclic Graph
# You are given a positive integer n representing the number of nodes of a Directed Acyclic Graph (DAG). The nodes are numbered from 0 to n - 1 (inclusive).
# 
# You are also given a 2D integer array edges, where edges[i] = [fromi, toi] denotes that there is a unidirectional edge from fromi to toi in the graph.
# 
# Return a list answer, where answer[i] is the list of ancestors of the ith node, sorted in ascending order.
# 
# A node u is an ancestor of another node v if u can reach v via a set of edges.
# 
#  
# 
# Example 1:
# 
# 
# Input: n = 8, edgeList = [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]]
# Output: [[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]]
# Explanation:
# The above diagram represents the input graph.
# - Nodes 0, 1, and 2 do not have any ancestors.
# - Node 3 has two ancestors 0 and 1.
# - Node 4 has two ancestors 0 and 2.
# - Node 5 has three ancestors 0, 1, and 3.
# - Node 6 has five ancestors 0, 1, 2, 3, and 4.
# - Node 7 has four ancestors 0, 1, 2, and 3.
# Example 2:
# 
# 
# Input: n = 5, edgeList = [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
# Output: [[],[0],[0,1],[0,1,2],[0,1,2,3]]
# Explanation:
# The above diagram represents the input graph.
# - Node 0 does not have any ancestor.
# - Node 1 has one ancestor 0.
# - Node 2 has two ancestors 0 and 1.
# - Node 3 has three ancestors 0, 1, and 2.
# - Node 4 has four ancestors 0, 1, 2, and 3.
#  
# 
# Constraints:
# 
# 1 <= n <= 1000
# 0 <= edges.length <= min(2000, n * (n - 1) / 2)
# edges[i].length == 2
# 0 <= fromi, toi <= n - 1
# fromi != toi
# There are no duplicate edges.
# The graph is directed and acyclic.
# Brute force with Breadth First Search
# Complexity
# Time complexity: O(N**3)
# Space complexity: O(N**2)
# Code
from collections import defaultdict
class Solution:
    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:
        vertexes: list[list[int]] = [set() for _ in range(n)]
        vertex_edges: dict[int, list[int]] = defaultdict(list)
        for path in edges:
            start_vertex, end_vertex = path
            vertex_edges[end_vertex].append(start_vertex)

        for vertex in range(n):
            current_edges = vertex_edges[vertex].copy()
            while current_edges:
                current_edge = current_edges.pop(0)
                if current_edge not in vertexes[vertex]:
                    vertexes[vertex].add(current_edge)
                    current_edges.extend(vertex_edges[current_edge])

        return [sorted(edges) for edges in vertexes]

# Depth First Search with Memoization
# Complexity
# Time complexity: O(N**2)
# Space complexity: O(N**2)
# Code
from collections import defaultdict
class Solution:
    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:
        vertex_edges: dict[int, list[int]] = defaultdict(list)
        for path in edges:
            start_vertex, end_vertex = path
            vertex_edges[end_vertex].append(start_vertex)

        memo: dict[int, set[int]] = {}
        def dfs(vertex):
            if vertex in memo:
                return memo[vertex]
            ancestors: set[int] = set()
            for current_ancestor in vertex_edges[vertex]:
                ancestors.add(current_ancestor)
                ancestors.update(dfs(current_ancestor))
            memo[vertex] = ancestors
            return ancestors

        vertex_ancestors: list[list[int]] = []
        for vertex in range(n):
            vertex_ancestors.append(sorted(dfs(vertex)))

        return vertex_ancestors

# Read the time
# Given time in 24-hour format, convert it to words.
# 
# For example:
# 13:00 = one o'clock 
# 13:09 = nine minutes past one 
# 13:15 = quarter past one 
# 13:29 = twenty nine minutes past one
# 13:30 = half past one 
# 13:31 = twenty nine minutes to two
# 13:45 = quarter to two 
# 00:48 = twelve minutes to one
# 00:08 = eight minutes past midnight
# 12:00 = twelve o'clock
# 00:00 = midnight
# 
# Note: If minutes == 0, use 'o'clock'. If minutes <= 30, use 'past', and for minutes > 30, use 'to'. 
# More examples in test cases. Good luck!
# 
# FUNDAMENTALS
def solve(time):
    first_part, second_part = map(int, time.split(':'))
    string_representation: dict[int, str] = {
        0: 'midnight',
        1: 'one', 2: 'two', 3: 'three', 4: 'four',
        5: 'five', 6: 'six', 7: 'seven', 8: 'eight',
        9: 'nine', 10: 'ten', 11: 'eleven', 12: 'twelve'
    }
    tens: dict[int, str] = {
        11: 'eleven', 12: 'twelve', 13: 'thirteen',
        14: 'fourteen', 16: 'sixteen', 17: 'seventeen',
        18: 'eighteen', 19: 'nineteen', 2: 'twenty',
        3: 'thrity', 4: 'fourty', 5: 'fifty'
    }
    if first_part == second_part == 0:
        return string_representation[0]
    more_than_half: bool = second_part > 30
    if more_than_half:
        first_part += 1
    if first_part > 12:
        first_part %= 12
    if second_part == 0:
        return f"{string_representation.get(first_part)} o'clock"
    if second_part % 30 == 0:
        return f"half past {string_representation[first_part]}"
    elif second_part % 15 == 0:
        return f"quarter {'to' if more_than_half else 'past'} {string_representation[first_part]}"
    if more_than_half:
        second_part = 60 - second_part
    if second_part in {1, 59}:
        return f"one minute {'to' if more_than_half else 'past'} {string_representation[first_part]}"
    else:
        if second_part in tens and second_part > 10:
            second_part = tens[second_part]
        elif second_part <= 10:
            second_part = string_representation[second_part]
        else:
            if second_part % 10 == 0:
                second_part = f'{tens[second_part // 10]}'
            else:
                second_part = f'{tens[second_part // 10]} {string_representation[second_part % 10]}'
        return f"{second_part} minutes {'to' if more_than_half else 'past'} {string_representation[first_part]}"

# 684. Redundant Connection
# In this problem, a tree is an undirected graph that is connected and has no cycles.
#
# You are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. The added edge has two different vertices chosen from 1 to n, and was not an edge that already existed. The graph is represented as an array edges of length n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph.
#
# Return an edge that can be removed so that the resulting graph is a tree of n nodes. If there are multiple answers, return the answer that occurs last in the input.
#
#
#
# Example 1:
#
#
# Input: edges = [[1,2],[1,3],[2,3]]
# Output: [2,3]
# Example 2:
#
#
# Input: edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]
# Output: [1,4]
#
#
# Constraints:
#
# n == edges.length
# 3 <= n <= 1000
# edges[i].length == 2
# 1 <= ai < bi <= edges.length
# ai != bi
# There are no repeated edges.
# The given graph is connected.
class UnionFind:
    def __init__(self, count_nodes: int) -> None:
        self.parents: list[int] = list(range(count_nodes + 1))
        self.ranks: list[int] = [1] * (count_nodes + 1)
        self.connections: int = count_nodes

    def find(self, node: int) -> int:
        while node != self.parents[node]:
            node = self.parents[node]
            self.parents[node] = self.parents[self.parents[node]]
        return self.parents[node]

    def union(self, node_x: int, node_y: int) -> bool:
        parent_x, parent_y = self.find(node_x), self.find(node_y)
        if parent_x == parent_y:
            return False
        elif self.ranks[parent_x] > self.ranks[parent_y]:
            self.ranks[parent_x] += self.ranks[parent_y]
            self.parents[parent_y] = parent_x
        else:
            self.ranks[parent_y] += self.ranks[parent_x]
            self.parents[parent_x] = parent_y
        self.connections -= 1
        return True

    def is_connected(self) -> bool:
        return self.connections <= 1


class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        disjoints_set = UnionFind(len(edges))
        for start_vertex, end_vertex in edges:
            if not disjoints_set.union(start_vertex, end_vertex):
                return [start_vertex, end_vertex]

# 1579. Remove Max Number of Edges to Keep Graph Fully Traversable
# Alice and Bob have an undirected graph of n nodes and three types of edges:
# 
# Type 1: Can be traversed by Alice only.
# Type 2: Can be traversed by Bob only.
# Type 3: Can be traversed by both Alice and Bob.
# Given an array edges where edges[i] = [typei, ui, vi] represents a bidirectional edge of type typei between nodes ui and vi, find the maximum number of edges you can remove so that after removing the edges, the graph can still be fully traversed by both Alice and Bob. The graph is fully traversed by Alice and Bob if starting from any node, they can reach all other nodes.
# 
# Return the maximum number of edges you can remove, or return -1 if Alice and Bob cannot fully traverse the graph.
# 
#  
# 
# Example 1:
# 
# 
# 
# Input: n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]
# Output: 2
# Explanation: If we remove the 2 edges [1,1,2] and [1,1,3]. The graph will still be fully traversable by Alice and Bob. Removing any additional edge will not make it so. So the maximum number of edges we can remove is 2.
# Example 2:
# 
# 
# 
# Input: n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]
# Output: 0
# Explanation: Notice that removing any edge will not make the graph fully traversable by Alice and Bob.
# Example 3:
# 
# 
# 
# Input: n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]]
# Output: -1
# Explanation: In the current graph, Alice cannot reach node 4 from the other nodes. Likewise, Bob cannot reach 1. Therefore it's impossible to make the graph fully traversable.
#  
# 
#  
# 
# Constraints:
# 
# 1 <= n <= 105
# 1 <= edges.length <= min(105, 3 * n * (n - 1) / 2)
# edges[i].length == 3
# 1 <= typei <= 3
# 1 <= ui < vi <= n
# All tuples (typei, ui, vi) are distinct.
class UnionFind:
    def __init__(self, count_nodes: int) -> None:
        self.parents: list[int] = list(range(count_nodes + 1))
        self.ranks: list[int] = [1] * (count_nodes + 1)
        self.connections: int = count_nodes

    def find(self, node: int) -> int:
        while node != self.parents[node]:
            node = self.parents[node]
            self.parents[node] = self.parents[self.parents[node]]
        return self.parents[node]

    def union(self, node_x: int, node_y: int) -> bool:
        parent_x, parent_y = self.find(node_x), self.find(node_y)
        if parent_x == parent_y: return False # already connected
        elif self.ranks[parent_x] > self.ranks[parent_y]:
           self.ranks[parent_x] += self.ranks[parent_y]
           self.parents[parent_y] = parent_x
        else:
            self.ranks[parent_y] += self.ranks[parent_x]
            self.parents[parent_x] = parent_y
        self.connections -= 1
        return True

    def is_connected(self) -> bool:
        return self.connections <= 1

class Solution:
    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:
        alice, bob = UnionFind(n), UnionFind(n)
        minimum_needed_edges: int = 0
        for type_edge, start_vertex, end_vertex in edges:
            if type_edge == 3:
                minimum_needed_edges += alice.union(start_vertex, end_vertex) | bob.union(start_vertex, end_vertex)
        for type_edge, start_vertex, end_vertex in edges:
            if type_edge == 1:
                minimum_needed_edges += alice.union(start_vertex, end_vertex)
            elif type_edge == 2:
                minimum_needed_edges += bob.union(start_vertex, end_vertex)
        if not alice.is_connected() or not bob.is_connected():
            return -1
        return len(edges) - minimum_needed_edges

# 3200. Maximum Height of a Triangle
# You are given two integers red and blue representing the count of red and blue colored balls. You have to arrange these balls to form a triangle such that the 1st row will have 1 ball, the 2nd row will have 2 balls, the 3rd row will have 3 balls, and so on.
#
# All the balls in a particular row should be the same color, and adjacent rows should have different colors.
#
# Return the maximum height of the triangle that can be achieved.
#
#
#
# Example 1:
#
# Input: red = 2, blue = 4
#
# Output: 3
#
# Explanation:
#
#
#
# The only possible arrangement is shown above.
#
# Example 2:
#
# Input: red = 2, blue = 1
#
# Output: 2
#
# Explanation:
#
#
# The only possible arrangement is shown above.
#
# Example 3:
#
# Input: red = 1, blue = 1
#
# Output: 1
#
# Example 4:
#
# Input: red = 10, blue = 1
#
# Output: 2
#
# Explanation:
#
#
# The only possible arrangement is shown above.
#
#
#
# Constraints:
#
# 1 <= red, blue <= 100
class Solution:
    def maxHeightOfTriangle(self, red: int, blue: int) -> int:
        copy_x, copy_y = red, blue
        layers = [copy_x, copy_y]
        flag = False
        accs = [1, 2]
        count_copy: int = 0
        while True: # Simulate red, blue positions first
            if layers[flag] - accs[flag] >= 0:
                count_copy += 1
                layers[flag] -= accs[flag]
                accs[flag] += 2
                flag = not flag
            else: break
        layers = [blue, red]
        accs = [1, 2]
        main_total: int = 0
        flag = False
        while True: # Simluate blue, red positions second
            if layers[flag] - accs[flag] >= 0:
                main_total += 1
                layers[flag] -= accs[flag]
                accs[flag] += 2
                flag = not flag
            else: break
        return max(main_total, count_copy) # return maximum of them

# A. Hulk
# A. Hulk
# time limit per test1 second
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# Dr. Bruce Banner hates his enemies (like others don't). As we all know, he can barely talk when he turns into the incredible Hulk. That's why he asked you to help him to express his feelings.
# 
# Hulk likes the Inception so much, and like that his feelings are complicated. They have n layers. The first layer is hate, second one is love, third one is hate and so on...
# 
# For example if n = 1, then his feeling is "I hate it" or if n = 2 it's "I hate that I love it", and if n = 3 it's "I hate that I love that I hate it" and so on.
# 
# Please help Dr. Banner.
# 
# Input
# The only line of the input contains a single integer n (1 ≤ n ≤ 100) — the number of layers of love and hate.
# 
# Output
# Print Dr.Banner's feeling in one line.
# 
# Examples
# inputCopy
# 1
# outputCopy
# I hate it
# inputCopy
# 2
# outputCopy
# I hate that I love it
# inputCopy
# 3
# outputCopy
# I hate that I love that I hate it
import sys

def solution(n: int) -> str:
    words: list = [['I love', 'I hate'][i & 1] for i in range(1, n + 1)]
    return ' that '.join(words) + ' it'

if __name__ == '__main__':
    n: int = int(sys.stdin.readline().rstrip())
    sys.stdout.write(solution(n))

# How many feelings?
# You have two arguments: string - a string of random letters(only lowercase) and array - an array of strings(feelings). Your task is to return how many specific feelings are in the array.
# 
# For example:
# 
# string -> 'yliausoenvjw'
# array -> ['anger', 'awe', 'joy', 'love', 'grief']
# output -> '3 feelings.' // 'awe', 'joy', 'love'
# 
# 
# string -> 'griefgriefgrief'
# array -> ['anger', 'awe', 'joy', 'love', 'grief']
# output -> '1 feeling.' // 'grief'
# 
# 
# string -> 'abcdkasdfvkadf'
# array -> ['desire', 'joy', 'shame', 'longing', 'fear']
# output -> '0 feelings.'
# If the feeling can be formed once - plus one to the answer.
# 
# If the feeling can be formed several times from different letters - plus one to the answer.
# 
# Eeach letter in string participates in the formation of all feelings. 'angerw' -> 2 feelings: 'anger' and 'awe'.
# 
# FUNDAMENTALSSTRINGS
def count_feelings(st, arr):
    arr = [''.join(sorted(word)) for word in arr]
    st = ''.join(sorted(st))
    count: int = 0
    for feel in arr:
        equal: bool = True
        idx: int = 0
        for char in feel:
            while idx < len(st) and st[idx] != char:
                idx += 1
            if idx >= len(st):
                equal = False
                break
            idx += 1
        count += equal
    return f"{count} feeling{'s' if count != 1 else ''}."

# 1550. Three Consecutive Odds
# Given an integer array arr, return true if there are three consecutive odd numbers in the array. Otherwise, return false.
#
#
# Example 1:
#
# Input: arr = [2,6,4,1]
# Output: false
# Explanation: There are no three consecutive odds.
# Example 2:
#
# Input: arr = [1,2,34,3,4,5,7,23,12]
# Output: true
# Explanation: [5,7,23] are three consecutive odds.
#
#
# Constraints:
#
# 1 <= arr.length <= 1000
# 1 <= arr[i] <= 1000
class Solution:
    def threeConsecutiveOdds(self, arr: List[int]) -> bool:
        in_a_row: int = 0
        for num in arr:
            if num & 1:
                in_a_row += 1
                if in_a_row == 3: return True
            else: in_a_row = 0
        return False

# Pitches and Notes
# In music, if you double (or halve) the pitch of any note you will get to the same note again.
#
# "Concert A" is fixed at 440 Hz, and every other note is defined based on that. 880 Hz is also an A, as is 1760 Hz, as is 220 Hz.
#
# There are 12 notes in Western music: A, A#, B, C, C#, D, D#, E, F, F#, G, G#. You are given a preloaded dictionary with these 12 notes and one of the pitches that creates that note (starting at Concert A).
#
# Now, given a pitch (in Hz), return the corresponding note. (All inputs will be valid notes).
#
# For reference, the notes dictionary looks like this:
#
# notes_dictionary = {
#     440: "A",
#     466.16: "A#",
#     493.88: "B",
#     523.25: "C",
#     554.37: "C#",
#     587.33: "D",
#     622.25: "D#",
#     659.25: "E",
#     698.46: "F",
#     739.99: "F#",
#     783.99: "G",
#     830.61: "G#"
# }
# Musicians: all pitches based on equal tempermanent, taken from here.
#
# FUNDAMENTALS
def get_note(pitch):
    notes_dictionary = {
        440: "A",
        466.16: "A#",
        493.88: "B",
        523.25: "C",
        554.37: "C#", 
        587.33: "D", 
        622.25: "D#", 
        659.25: "E", 
        698.46: "F", 
        739.99: "F#", 
        783.99: "G", 
        830.61: "G#"
    }
    copy_pitch: int = pitch
    while copy_pitch > 200:
        if copy_pitch in notes_dictionary: return notes_dictionary[copy_pitch]
        copy_pitch /= 2
    while copy_pitch < 1000:
        if copy_pitch in notes_dictionary: return notes_dictionary[copy_pitch]
        copy_pitch *= 2
        
# A. Gravity Flip
# A. Gravity Flip
# time limit per test1 second
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# Little Chris is bored during his physics lessons (too easy), so he has built a toy box to keep himself occupied. The box is special, since it has the ability to change gravity.
#
# There are n columns of toy cubes in the box arranged in a line. The i-th column contains ai cubes. At first, the gravity in the box is pulling the cubes downwards. When Chris switches the gravity, it begins to pull all the cubes to the right side of the box. The figure shows the initial and final configurations of the cubes in the box: the cubes that have changed their position are highlighted with orange.
#
#
# Given the initial configuration of the toy cubes in the box, find the amounts of cubes in each of the n columns after the gravity switch!
#
# Input
# The first line of input contains an integer n (1 ≤ n ≤ 100), the number of the columns in the box. The next line contains n space-separated integer numbers. The i-th number ai (1 ≤ ai ≤ 100) denotes the number of cubes in the i-th column.
#
# Output
# Output n integer numbers separated by spaces, where the i-th number is the amount of cubes in the i-th column after the gravity switch.
#
# Examples
# inputCopy
# 4
# 3 2 1 2
# outputCopy
# 1 2 2 3
# inputCopy
# 3
# 2 3 8
# outputCopy
# 2 3 8
# Note
# The first example case is shown on the figure. The top cube of the first column falls to the top of the last column; the top cube of the second column falls to the top of the third column; the middle cube of the first column falls to the top of the second column.
#
# In the second example case the gravity switch does not change the heights of the columns.
import sys

def solution(n: int, cubes: list) -> str:
    cubes.sort()

    return ' '.join(str(cube) for cube in cubes)

if __name__ == '__main__':
    n: int = int(sys.stdin.readline().rstrip())
    cubes: list = list(map(int, sys.stdin.readline().rstrip().split()))
    sys.stdout.write(solution(n, cubes))

# 350. Intersection of Two Arrays II
# Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.
#
#
#
# Example 1:
#
# Input: nums1 = [1,2,2,1], nums2 = [2,2]
# Output: [2,2]
# Example 2:
#
# Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
# Output: [4,9]
# Explanation: [9,4] is also accepted.
#
#
# Constraints:
#
# 1 <= nums1.length, nums2.length <= 1000
# 0 <= nums1[i], nums2[i] <= 1000
#
#
# Follow up:
#
# What if the given array is already sorted? How would you optimize your algorithm?
# What if nums1's size is small compared to nums2's size? Which algorithm is better?
# What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?
# Questions:
# What if the given array is already sorted? How would you optimize your algorithm?
# Answer: Insted of using extra space for creation hashmap for each array we can use Two Pointers or Binary Search approaches.
# What if nums1's size is small compared to nums2's size? Which algorithm is better?
# Answer: Binary Search approach will works better than Two pointers, because we don't need to traverse between all second array for finding element. We can juse do int in "log time".
# What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?
# Answer: So we can use Binary Search approach to be able make more efficient operations on memory disk.

# HashTable Counting
# Complexity
# Time complexity: O(N)
# Space complexity: O(N)
# Code
from collections import defaultdict
class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        boundary_nums1: int = len(nums1)
        boundary_nums2: int = len(nums2)
        storage_nums1: dict[int, int] = defaultdict(int)
        storage_nums2: dict[int, int] = defaultdict(int)
        duplicate: list[int] = []
        idx: int = 0
        while idx < boundary_nums1:
            storage_nums1[nums1[idx]] += 1
            idx += 1
        idx = 0
        while idx < boundary_nums2:
            storage_nums2[nums2[idx]] += 1
            idx += 1
        for num in storage_nums1:
            if num in storage_nums2:
                duplicate.extend([num] * min(storage_nums1[num], storage_nums2[num]))
        return duplicate

# Two Pointers
# Complexity
# Time complexity: O(NlogN), because in problem case arrays not sorted and we need to sort them, if array being already sorted, time complexity equals to O(N)
# Space complexity: O(N), because we use output array to store duplicate numbers
# Code
class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        nums1.sort()
        nums2.sort()
        duplicate: list[int] = []
        pointer_nums1 = pointer_nums2 = 0
        while pointer_nums1 < len(nums1) and pointer_nums2 < len(nums2):
            if nums1[pointer_nums1] == nums2[pointer_nums2]:
                duplicate.append(nums1[pointer_nums1])
                pointer_nums1 += 1
                pointer_nums2 += 1
            elif nums1[pointer_nums1] > nums2[pointer_nums2]:
                pointer_nums2 += 1
            else:
                pointer_nums1 += 1
        return duplicate

# Binary Search
# Complexity
# Time complexity: O(NlogN), because in problem case arrays not sorted and we need to sort them, if array being already sorted, time complexity equals to O(N)
# Space complexity: O(N), because we use output array to store duplicate numbers
# Code
class Solution:
    def leftmost_binary_search(self, sequence: list[int], target: int) -> int:
        left_pointer, right_pointer = 0, len(sequence) - 1
        while left_pointer <= right_pointer:
            middle_pointer: int = (left_pointer + right_pointer) >> 1
            if sequence[middle_pointer] >= target:
                right_pointer = middle_pointer - 1
            else:
                left_pointer = middle_pointer + 1
        return right_pointer + 1

    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        nums1.sort()
        nums2.sort()
        duplicate: list[int] = []
        if len(nums1) > len(nums2):
            nums1, nums2 = nums2, nums1
        upper_boundary: int = len(nums1)
        lower_boundary: int = 0
        upper_search_boundary: int = len(nums2)
        while lower_boundary < upper_boundary:
            target: int = nums1[lower_boundary]
            start_pointer: int = self.leftmost_binary_search(nums2, target)
            frequences_in_second_array: int = 0
            while start_pointer < upper_search_boundary and nums2[start_pointer] == target:
                frequences_in_second_array += 1
                start_pointer += 1
            frequences_in_first_array: int = 0
            while lower_boundary < upper_boundary and nums1[lower_boundary] == target:
                frequences_in_first_array += 1
                lower_boundary += 1
            if frequences_in_second_array > 0:
                duplicate.extend([target] * min(frequences_in_first_array, frequences_in_second_array))
        return duplicate

# Asyncio - The Beginning
# Story
# As you walk the streets with your crush beside you, you are thinking about the world and how everything works... Wait!! Your crush? Shit, you are dreaming again.
# 
# Task
# Now implement a coroutine dreaming which sleeps for n seconds and then returns m ** n without entirely blocking the execution of other coroutines that might be running.
# 
# Note
# 0 < n < 7
# 
# 0 < m < 100
# 
# ASYNCHRONOUSStory
# As you walk the streets with your crush beside you, you are thinking about the world and how everything works... Wait!! Your crush? Shit, you are dreaming again.
# 
# Task
# Now implement a coroutine dreaming which sleeps for n seconds and then returns m ** n without entirely blocking the execution of other coroutines that might be running.
# 
# Note
# 0 < n < 7
# 
# 0 < m < 100
# 
# ASYNCHRONOUS
import asyncio

async def dreaming(n, m):
    await asyncio.sleep(n)
    return m ** n 

# A. Divisibility Problem
# A. Divisibility Problem
# time limit per test1 second
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# You are given two positive integers a
#  and b
# . In one move you can increase a
#  by 1
#  (replace a
#  with a+1
# ). Your task is to find the minimum number of moves you need to do in order to make a
#  divisible by b
# . It is possible, that you have to make 0
#  moves, as a
#  is already divisible by b
# . You have to answer t
#  independent test cases.
# 
# Input
# The first line of the input contains one integer t
#  (1≤t≤104
# ) — the number of test cases. Then t
#  test cases follow.
# 
# The only line of the test case contains two integers a
#  and b
#  (1≤a,b≤109
# ).
# 
# Output
# For each test case print the answer — the minimum number of moves you need to do in order to make a
#  divisible by b
# .
# 
# Example
# inputCopy
# 5
# 10 4
# 13 9
# 100 13
# 123 456
# 92 46
# outputCopy
# 2
# 5
# 4
# 333
# 0
# Solution O(1) O(1) Math
import sys

def solution(n: int) -> None:
    for _ in range(n):
        x, y = map(int, sys.stdin.readline().rstrip().split())
        if x <= y: print(y - x)
        else:
            if x % y == 0:
                print(0)
            else:
                print(y - x % y)

if __name__ == '__main__':
    n: int = int(sys.stdin.readline().rstrip())
    solution(n)
    
# 1509. Minimum Difference Between Largest and Smallest Value in Three Moves
# You are given an integer array nums.
#
# In one move, you can choose one element of nums and change it to any value.
#
# Return the minimum difference between the largest and smallest value of nums after performing at most three moves.
#
#
#
# Example 1:
#
# Input: nums = [5,3,2,4]
# Output: 0
# Explanation: We can make at most 3 moves.
# In the first move, change 2 to 3. nums becomes [5,3,3,4].
# In the second move, change 4 to 3. nums becomes [5,3,3,3].
# In the third move, change 5 to 3. nums becomes [3,3,3,3].
# After performing 3 moves, the difference between the minimum and maximum is 3 - 3 = 0.
# Example 2:
#
# Input: nums = [1,5,0,10,14]
# Output: 1
# Explanation: We can make at most 3 moves.
# In the first move, change 5 to 0. nums becomes [1,0,0,10,14].
# In the second move, change 10 to 0. nums becomes [1,0,0,0,14].
# In the third move, change 14 to 1. nums becomes [1,0,0,0,1].
# After performing 3 moves, the difference between the minimum and maximum is 1 - 0 = 1.
# It can be shown that there is no way to make the difference 0 in 3 moves.
# Example 3:
#
# Input: nums = [3,100,20]
# Output: 0
# Explanation: We can make at most 3 moves.
# In the first move, change 100 to 7. nums becomes [3,7,20].
# In the second move, change 20 to 7. nums becomes [3,7,7].
# In the third move, change 3 to 7. nums becomes [7,7,7].
# After performing 3 moves, the difference between the minimum and maximum is 7 - 7 = 0.
#
#
# Constraints:
#
# 1 <= nums.length <= 105
# -109 <= nums[i] <= 109
class Solution:
    def minDifference(self, nums: List[int]) -> int:
        if len(nums) < 5: return 0
        nums.sort() # Ascending order
        a: int = nums[-4] - nums[0] # Last with first
        b: int = nums[-3] - nums[1] # Second last with second first
        c: int = nums[-2] - nums[2] # Third last with thrid first
        d: int = nums[-1] - nums[3] # Last with fourth first
        return min(a, b, c, d)

# A. I Wanna Be the Guy
# A. I Wanna Be the Guy
# time limit per test1 second
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# There is a game called "I Wanna Be the Guy", consisting of n levels. Little X and his friend Little Y are addicted to the game. Each of them wants to pass the whole game.
# 
# Little X can pass only p levels of the game. And Little Y can pass only q levels of the game. You are given the indices of levels Little X can pass and the indices of levels Little Y can pass. Will Little X and Little Y pass the whole game, if they cooperate each other?
# 
# Input
# The first line contains a single integer n (1 ≤  n ≤ 100).
# 
# The next line contains an integer p (0 ≤ p ≤ n) at first, then follows p distinct integers a1, a2, ..., ap (1 ≤ ai ≤ n). These integers denote the indices of levels Little X can pass. The next line contains the levels Little Y can pass in the same format. It's assumed that levels are numbered from 1 to n.
# 
# Output
# If they can pass all the levels, print "I become the guy.". If it's impossible, print "Oh, my keyboard!" (without the quotes).
# 
# Examples
# inputCopy
# 4
# 3 1 2 3
# 2 2 4
# outputCopy
# I become the guy.
# inputCopy
# 4
# 3 1 2 3
# 2 2 3
# outputCopy
# Oh, my keyboard!
# Note
# In the first sample, Little X can pass levels [1 2 3], and Little Y can pass level [2 4], so they can pass all the levels both.
# 
# In the second sample, no one can pass level 4.
import sys

def solution(n: int, x_n: int, x: list, y_n: int, y: list) -> str:
    return ['Oh, my keyboard!', 'I become the guy.'][len(set(x) | set(y)) >= n]

if __name__ == '__main__':
    n: int = int(sys.stdin.readline().rstrip())
    x: list = list(map(int, sys.stdin.readline().rstrip().split()))
    x_n: int = x[0]
    y: list = list(map(int, sys.stdin.readline().rstrip().split()))
    y_n: int = y[0]
    sys.stdout.write(solution(n, x_n, x[1:], y_n, y[1:]))
    
# Tree-D Printer
# Your task is simple enough. You will write a function which takes a tree as its input. Your function should output one string with the values of the nodes in an order corresponding to a breadth first search. This string also should be broken into levels corresponding to the depth of the nodes tree, and there should be a space between each value. For example if the following tree were input to our function :
# 
# alt text
# 
# the output would be a string and look something like this:
# 
# 2 
# 7 5 
# 2 6 9 
# 5 11 4 
# All nodes in the tree will have two properties, .value and .children. You may assume the .value property will always be either a string or a number. The .children property will be an array containing all of the node's children. The tree is NOT necessarily a binary tree, each node may have many children nodes
# 
# You may implement whatever method you see fit to search the tree. There are both breadth first and depth first approaches.
# 
# ALGORITHMS
# Solution
# preloaded TreeNode class:
"""
class TreeNode:
    def __init__(self, value, children = None):
        self.value = value
        self.children = [] if children is None else children
"""
from preloaded import TreeNode

def tree_printer(tree : TreeNode) -> str:
    current_nodes = []
    next_nodes = []
    current_nodes.append(tree)
    output_array: list[str] = []
    while current_nodes:
        local_array: list[str] = []
        for node in current_nodes:
            local_array.append(node.value)
            if node.children is not None:
                next_nodes.extend(node.children)
        local_array = ' '.join(str(el) for el in local_array)
        output_array.append(local_array)
        current_nodes = next_nodes
        next_nodes = []
    return '\n'.join(output_array)

# 2181. Merge Nodes in Between Zeros
# You are given the head of a linked list, which contains a series of integers separated by 0's. The beginning and end of the linked list will have Node.val == 0.
#
# For every two consecutive 0's, merge all the nodes lying in between them into a single node whose value is the sum of all the merged nodes. The modified list should not contain any 0's.
#
# Return the head of the modified linked list.
#
#
#
# Example 1:
#
#
# Input: head = [0,3,1,0,4,5,2,0]
# Output: [4,11]
# Explanation:
# The above figure represents the given linked list. The modified list contains
# - The sum of the nodes marked in green: 3 + 1 = 4.
# - The sum of the nodes marked in red: 4 + 5 + 2 = 11.
# Example 2:
#
#
# Input: head = [0,1,0,3,0,2,2,0]
# Output: [1,3,4]
# Explanation:
# The above figure represents the given linked list. The modified list contains
# - The sum of the nodes marked in green: 1 = 1.
# - The sum of the nodes marked in red: 3 = 3.
# - The sum of the nodes marked in yellow: 2 + 2 = 4.
#
#
# Constraints:
#
# The number of nodes in the list is in the range [3, 2 * 105].
# 0 <= Node.val <= 1000
# There are no two consecutive nodes with Node.val == 0.
# The beginning and end of the linked list have Node.val == 0.
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:
        accumulate: int = 0
        tmp = head
        local_tmp = tmp.next
        while local_tmp:
            while local_tmp and local_tmp.val != 0:
                accumulate += local_tmp.val
                local_tmp = local_tmp.next
            if accumulate:
                tmp.val = accumulate
                tmp.next = local_tmp if local_tmp.next else None
                accumulate = 0
                tmp = tmp.next
            local_tmp = local_tmp.next
        return head

# Lojban Numbers
# Lojban Numbers
# Counting in Lojban, an artificial language developed over the last forty years, is easier than in most languages. The numbers from zero to nine are:
# 
# 1 pa 4 vo 7 ze
# 2 re 5 mu 8 bi 0 no
# 3 ci 6 xa 9 so
# Larger numbers are created by gluing the digits together. For example, 123 is pareci.
# 
# Write a program that reads in a Lojban string (representing a number less than or equal to 1,000,000) and outputs it in numbers.
# 
# Example:
# renonore  # Lojban string
# 2002  # Number
# Input/Output
# [input] string representing the number in Lojban pareci
# Constraints: Lojban number ≤ 1,000,000
# [output] integer representing the Lojban number 123
# Source: 2002 British Informatics Olympiad
def convert_lojban(lojban):
    dictionary: dict[int, str] = {
        'no': 0, 'pa': 1, 're': 2,
        'ci': 3, 'vo': 4, 'mu': 5,
        'xa': 6, 'ze': 7, 'bi': 8, 'so': 9,
    }
    number: int = 0
    while lojban:
        number = number * 10 + dictionary.get(lojban[:2])
        lojban = lojban[2:]
    return number

# A. Pangram
# A. Pangram
# time limit per test2 seconds
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# A word or a sentence in some language is called a pangram if all the characters of the alphabet of this language appear in it at least once. Pangrams are often used to demonstrate fonts in printing or test the output devices.
# 
# You are given a string consisting of lowercase and uppercase Latin letters. Check whether this string is a pangram. We say that the string contains a letter of the Latin alphabet if this letter occurs in the string in uppercase or lowercase.
# 
# Input
# The first line contains a single integer n (1 ≤ n ≤ 100) — the number of characters in the string.
# 
# The second line contains the string. The string consists only of uppercase and lowercase Latin letters.
# 
# Output
# Output "YES", if the string is a pangram and "NO" otherwise.
# 
# Examples
# inputCopy
# 12
# toosmallword
# outputCopy
# NO
# inputCopy
# 35
# TheQuickBrownFoxJumpsOverTheLazyDog
# outputCopy
# YES
import sys

def solution(word: str) -> str:
    word_: str = word.lower()
    return ['NO', 'YES'][len(set(word_)) >= 26]

if __name__ == '__main__':
    n: int = int(sys.stdin.readline().rstrip())
    word: str = sys.stdin.readline().rstrip()
    sys.stdout.write(solution(word))
    
# 2058. Find the Minimum and Maximum Number of Nodes Between Critical Points
# A critical point in a linked list is defined as either a local maxima or a local minima.
# 
# A node is a local maxima if the current node has a value strictly greater than the previous node and the next node.
# 
# A node is a local minima if the current node has a value strictly smaller than the previous node and the next node.
# 
# Note that a node can only be a local maxima/minima if there exists both a previous node and a next node.
# 
# Given a linked list head, return an array of length 2 containing [minDistance, maxDistance] where minDistance is the minimum distance between any two distinct critical points and maxDistance is the maximum distance between any two distinct critical points. If there are fewer than two critical points, return [-1, -1].
# 
#  
# 
# Example 1:
# 
# 
# Input: head = [3,1]
# Output: [-1,-1]
# Explanation: There are no critical points in [3,1].
# Example 2:
# 
# 
# Input: head = [5,3,1,2,5,1,2]
# Output: [1,3]
# Explanation: There are three critical points:
# - [5,3,1,2,5,1,2]: The third node is a local minima because 1 is less than 3 and 2.
# - [5,3,1,2,5,1,2]: The fifth node is a local maxima because 5 is greater than 2 and 1.
# - [5,3,1,2,5,1,2]: The sixth node is a local minima because 1 is less than 5 and 2.
# The minimum distance is between the fifth and the sixth node. minDistance = 6 - 5 = 1.
# The maximum distance is between the third and the sixth node. maxDistance = 6 - 3 = 3.
# Example 3:
# 
# 
# Input: head = [1,3,2,2,3,2,2,2,7]
# Output: [3,3]
# Explanation: There are two critical points:
# - [1,3,2,2,3,2,2,2,7]: The second node is a local maxima because 3 is greater than 1 and 2.
# - [1,3,2,2,3,2,2,2,7]: The fifth node is a local maxima because 3 is greater than 2 and 2.
# Both the minimum and maximum distances are between the second and the fifth node.
# Thus, minDistance and maxDistance is 5 - 2 = 3.
# Note that the last node is not considered a local maxima because it does not have a next node.
#  
# 
# Constraints:
# 
# The number of nodes in the list is in the range [2, 105].
# 1 <= Node.val <= 105
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:
        distances: list[int] = []
        tmp = head
        idx: int = 1
        while tmp:
            if tmp.next and tmp.next.next:
                left, middle, right = tmp, tmp.next, tmp.next.next
                if middle.val < left.val and middle.val < right.val:
                    distances.append(idx + 1)
                elif middle.val > left.val and middle.val > right.val:
                    distances.append(idx + 1)
            idx += 1
            tmp = tmp.next
        if len(distances) < 2: return [-1, -1]
        max_distance: int = distances[-1] - distances[0]
        min_distance: int = min(y - x for x, y in zip(distances, distances[1::]))
        return [min_distance, max_distance]

# A. Arrival of the General
# A. Arrival of the General
# time limit per test2 seconds
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# A Ministry for Defense sent a general to inspect the Super Secret Military Squad under the command of the Colonel SuperDuper. Having learned the news, the colonel ordered to all n squad soldiers to line up on the parade ground.
# 
# By the military charter the soldiers should stand in the order of non-increasing of their height. But as there's virtually no time to do that, the soldiers lined up in the arbitrary order. However, the general is rather short-sighted and he thinks that the soldiers lined up correctly if the first soldier in the line has the maximum height and the last soldier has the minimum height. Please note that the way other solders are positioned does not matter, including the case when there are several soldiers whose height is maximum or minimum. Only the heights of the first and the last soldier are important.
# 
# For example, the general considers the sequence of heights (4, 3, 4, 2, 1, 1) correct and the sequence (4, 3, 1, 2, 2) wrong.
# 
# Within one second the colonel can swap any two neighboring soldiers. Help him count the minimum time needed to form a line-up which the general will consider correct.
# 
# Input
# The first input line contains the only integer n (2 ≤ n ≤ 100) which represents the number of soldiers in the line. The second line contains integers a1, a2, ..., an (1 ≤ ai ≤ 100) the values of the soldiers' heights in the order of soldiers' heights' increasing in the order from the beginning of the line to its end. The numbers are space-separated. Numbers a1, a2, ..., an are not necessarily different.
# 
# Output
# Print the only integer — the minimum number of seconds the colonel will need to form a line-up the general will like.
# 
# Examples
# inputCopy
# 4
# 33 44 11 22
# outputCopy
# 2
# inputCopy
# 7
# 10 10 58 31 63 40 76
# outputCopy
# 10
# Note
# In the first sample the colonel will need to swap the first and second soldier and then the third and fourth soldier. That will take 2 seconds. The resulting position of the soldiers is (44, 33, 22, 11).
# 
# In the second sample the colonel may swap the soldiers in the following sequence:
# 
# (10, 10, 58, 31, 63, 40, 76)
# (10, 58, 10, 31, 63, 40, 76)
# (10, 58, 10, 31, 63, 76, 40)
# (10, 58, 10, 31, 76, 63, 40)
# (10, 58, 31, 10, 76, 63, 40)
# (10, 58, 31, 76, 10, 63, 40)
# (10, 58, 31, 76, 63, 10, 40)
# (10, 58, 76, 31, 63, 10, 40)
# (10, 76, 58, 31, 63, 10, 40)
# (76, 10, 58, 31, 63, 10, 40)
# (76, 10, 58, 31, 63, 40, 10)
import sys


def solution(n: int, soldiers: list) -> str:
    mx: int = max(soldiers)
    mn: int = min(soldiers)
    swaps: int = 0
    mx_index: int = soldiers.index(mx)
    mn_index: int = 0
    for idx in range(n):
        if soldiers[idx] == mn:
            mn_index = idx
    swaps: int = mx_index + (n - 1 - mn_index)
    return str(swaps if mx_index < mn_index else swaps - 1)


if __name__ == '__main__':
    n: int = int(sys.stdin.readline().rstrip())
    soldiers: list = list(map(int, sys.stdin.readline().rstrip().split()))
    sys.stdout.write(solution(n, soldiers))

# [Code Golf] Knight's Next Position
# The knight is a piece in the game of chess. It may move two squares vertically and one square horizontally or two squares horizontally and one square vertically. For a visual representation of the possible moves, take a look here (second image).
# 
# Given the current position of the knight on the chessboard (e.g."b8") return all its possible next positions, alphabetically sorted (e.g. ["a6", "c6", "d7"])
# 
# Your code can be maximum 170 150 bytes long (I underestimated your skills ;-)
# 
# 
# Note: this is the code golf version of this kata
# 
# My other katas
# If you enjoyed this kata then please try my other katas! :-)
# 
# Translations are welcome!
# ...except for Ruby, which will arrive soon
# 
# RESTRICTEDPUZZLES
def next_pos(p):d=int(p[1]);i=ord(p[0])-97;h=[-2,-1,1,2];return [chr(i+x+97)+str(d+y)for x in h for y in h if abs(x)!=abs(y)and(0<=i+x<8)&(1<=d+y<=8)]

# 2582. Pass the Pillow
# There are n people standing in a line labeled from 1 to n. The first person in the line is holding a pillow initially. Every second, the person holding the pillow passes it to the next person standing in the line. Once the pillow reaches the end of the line, the direction changes, and people continue passing the pillow in the opposite direction.
#
# For example, once the pillow reaches the nth person they pass it to the n - 1th person, then to the n - 2th person and so on.
# Given the two positive integers n and time, return the index of the person holding the pillow after time seconds.
#
#
#
# Example 1:
#
# Input: n = 4, time = 5
# Output: 2
# Explanation: People pass the pillow in the following way: 1 -> 2 -> 3 -> 4 -> 3 -> 2.
# After five seconds, the 2nd person is holding the pillow.
# Example 2:
#
# Input: n = 3, time = 2
# Output: 3
# Explanation: People pass the pillow in the following way: 1 -> 2 -> 3.
# After two seconds, the 3rd person is holding the pillow.
#
#
# Constraints:
#
# 2 <= n <= 1000
# 1 <= time <= 1000
# Simulation
# Complexity
# Time complexity: O(N)
# Space complexity: O(1)
# Code
class Solution:
    def passThePillow(self, n: int, time: int) -> int:
        pillow: int = 1
        reverse: bool = False
        while time:
            if reverse:
                pillow -= 1
            else:
                pillow += 1
            if pillow == 1 or pillow == n:
                reverse = not reverse
            time -= 1
        return pillow

# Math
# Complexity
# Time complexity: O(1)
# Space complexity: O(1)
# Code
class Solution:
    def passThePillow(self, n: int, time: int) -> int:
        whole: int = time // (n - 1)
        remainder: int = time % (n - 1)
        return 1 + remainder if whole & 1 == 0 else n - remainder

# A. Expression
# A. Expression
# time limit per test1 second
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# Petya studies in a school and he adores Maths. His class has been studying arithmetic expressions. On the last class the teacher wrote three positive integers a, b, c on the blackboard. The task was to insert signs of operations '+' and '*', and probably brackets between the numbers so that the value of the resulting expression is as large as possible. Let's consider an example: assume that the teacher wrote numbers 1, 2 and 3 on the blackboard. Here are some ways of placing signs and brackets:
# 
# 1+2*3=7
# 1*(2+3)=5
# 1*2*3=6
# (1+2)*3=9
# Note that you can insert operation signs only between a and b, and between b and c, that is, you cannot swap integers. For instance, in the given sample you cannot get expression (1+3)*2.
# 
# It's easy to see that the maximum value that you can obtain is 9.
# 
# Your task is: given a, b and c print the maximum value that you can get.
# 
# Input
# The input contains three integers a, b and c, each on a single line (1 ≤ a, b, c ≤ 10).
# 
# Output
# Print the maximum value of the expression that you can obtain.
# 
# Examples
# inputCopy
# 1
# 2
# 3
# outputCopy
# 9
# inputCopy
# 2
# 10
# 3
# outputCopy
# 60
import sys


def solution(a: int, b: int, c: int) -> str:
    return str(max(
        a * b * c, (a + b) * c, a * (b + c),
        a * (b * c), a + b + c
    ))


if __name__ == '__main__':
    a: int = int(sys.stdin.readline().rstrip())
    b: int = int(sys.stdin.readline().rstrip())
    c: int = int(sys.stdin.readline().rstrip())
    sys.stdout.write(solution(a, b, c))
    
# Fun with trees: is perfect
# A perfect binary tree is a binary tree in which all interior nodes have two children and all leaves have the same depth or same level.
# 
# You are given a class called TreeNode. Implement the method isPerfect which determines if a given tree denoted by its root node is perfect.
# 
# Note: TreeNode class contains helper methods for tree creation, which might be handy for your solution. Feel free to update those methods, but make sure you keep their signatures intact (since they are used from within test cases).
# 
# You can (and should) add more tests to validate your solution, since not all cases are covered in the example test cases.
# 
# This kata is part of fun with trees series:
# 
# Fun with trees: max sum
# Fun with trees: array to tree
# Fun with trees: is perfect
# TREESRECURSIONBINARY TREESBINARY SEARCH TREESDATA STRUCTURESALGORITHMS
from preloaded import TreeNode
# preloaded TreeNode class:
"""
class TreeNode:
    def __init__(self, value, left = None, right = None):
        self.value = value
        self.left  = left
        self.right = right
"""
def is_perfect(tree : TreeNode) -> bool:
    current_nodes = [tree]
    next_nodes = []
    while current_nodes:
        count_parent_nodes: int = len(current_nodes)
        for parent_node in current_nodes:
            if parent_node is None: continue
            if parent_node.left is not None: next_nodes.append(parent_node.left)
            if parent_node.right is not None: next_nodes.append(parent_node.right)
        if count_parent_nodes * 2 != len(next_nodes) and next_nodes: return False
        current_nodes = next_nodes
        next_nodes = []
    return True

# 1476. Subrectangle Queries
# Implement the class SubrectangleQueries which receives a rows x cols rectangle as a matrix of integers in the constructor and supports two methods:
# 
# 1. updateSubrectangle(int row1, int col1, int row2, int col2, int newValue)
# 
# Updates all values with newValue in the subrectangle whose upper left coordinate is (row1,col1) and bottom right coordinate is (row2,col2).
# 2. getValue(int row, int col)
# 
# Returns the current value of the coordinate (row,col) from the rectangle.
#  
# 
# Example 1:
# 
# Input
# ["SubrectangleQueries","getValue","updateSubrectangle","getValue","getValue","updateSubrectangle","getValue","getValue"]
# [[[[1,2,1],[4,3,4],[3,2,1],[1,1,1]]],[0,2],[0,0,3,2,5],[0,2],[3,1],[3,0,3,2,10],[3,1],[0,2]]
# Output
# [null,1,null,5,5,null,10,5]
# Explanation
# SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,2,1],[4,3,4],[3,2,1],[1,1,1]]);  
# // The initial rectangle (4x3) looks like:
# // 1 2 1
# // 4 3 4
# // 3 2 1
# // 1 1 1
# subrectangleQueries.getValue(0, 2); // return 1
# subrectangleQueries.updateSubrectangle(0, 0, 3, 2, 5);
# // After this update the rectangle looks like:
# // 5 5 5
# // 5 5 5
# // 5 5 5
# // 5 5 5 
# subrectangleQueries.getValue(0, 2); // return 5
# subrectangleQueries.getValue(3, 1); // return 5
# subrectangleQueries.updateSubrectangle(3, 0, 3, 2, 10);
# // After this update the rectangle looks like:
# // 5   5   5
# // 5   5   5
# // 5   5   5
# // 10  10  10 
# subrectangleQueries.getValue(3, 1); // return 10
# subrectangleQueries.getValue(0, 2); // return 5
# Example 2:
# 
# Input
# ["SubrectangleQueries","getValue","updateSubrectangle","getValue","getValue","updateSubrectangle","getValue"]
# [[[[1,1,1],[2,2,2],[3,3,3]]],[0,0],[0,0,2,2,100],[0,0],[2,2],[1,1,2,2,20],[2,2]]
# Output
# [null,1,null,100,100,null,20]
# Explanation
# SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,1,1],[2,2,2],[3,3,3]]);
# subrectangleQueries.getValue(0, 0); // return 1
# subrectangleQueries.updateSubrectangle(0, 0, 2, 2, 100);
# subrectangleQueries.getValue(0, 0); // return 100
# subrectangleQueries.getValue(2, 2); // return 100
# subrectangleQueries.updateSubrectangle(1, 1, 2, 2, 20);
# subrectangleQueries.getValue(2, 2); // return 20
#  
# 
# Constraints:
# 
# There will be at most 500 operations considering both methods: updateSubrectangle and getValue.
# 1 <= rows, cols <= 100
# rows == rectangle.length
# cols == rectangle[i].length
# 0 <= row1 <= row2 < rows
# 0 <= col1 <= col2 < cols
# 1 <= newValue, rectangle[i][j] <= 10^9
# 0 <= row < rows
# 0 <= col < cols
# Solution
# General idea
# initialization of matrix:
# we can simplify represent matrix as list contains list integers
# updateSubrectangle:
# Create first loop in range row1 and row2(inclusive) and in the first loop we create second loop in range from col1 to col2(inclusive) and in each cell change old value to new value
# getValue:
# Just return cell by given row and col indexes.
# Complexity
# Time complexity: Technically O(NM), but be more generally its O(N)
# Space complexity: O(1), because we don't need to allocate some extra space for updateSubrectangle and getValue operations
# Code
class SubrectangleQueries:

    def __init__(self, rectangle: List[List[int]]):
        self.mtrx: list[list[int]] = rectangle

    def updateSubrectangle(self, row1: int, col1: int, row2: int, col2: int, newValue: int) -> None:
        for row in range(row1, row2 + 1):
            for col in range(col1, col2 + 1):
                self.mtrx[row][col] = newValue


    def getValue(self, row: int, col: int) -> int:
        return self.mtrx[row][col]



# Your SubrectangleQueries object will be instantiated and called as such:
# obj = SubrectangleQueries(rectangle)
# obj.updateSubrectangle(row1,col1,row2,col2,newValue)
# param_2 = obj.getValue(row,col)

# 1302. Deepest Leaves Sum
# Given the root of a binary tree, return the sum of values of its deepest leaves.
#  
# 
# Example 1:
# 
# 
# Input: root = [1,2,3,4,5,null,6,7,null,null,null,null,8]
# Output: 15
# Example 2:
# 
# Input: root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]
# Output: 19
#  
# 
# Constraints:
# 
# The number of nodes in the tree is in the range [1, 104].
# 1 <= Node.val <= 100
# Solution
# Breath First Search (BFS)
# General idea
# Traverse through all layers of tree.
# At the each layer calculate sum of its leaves(variable "current_layer_leaves_sum") and
# if sum more than 0, just store it in global variable "sum_leaves".
# At the end return global variable "sum_leaves"
# Complexity
# Time complexity: O(N)
# Space complexity: O(M) where M is length of layer nodes
# Code
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def deepestLeavesSum(self, root: Optional[TreeNode]) -> int:
        current_nodes: list[TreeNode] = [root]
        next_nodes: list[TreeNode] = []
        sum_leaves: int = 0
        while current_nodes:
            current_layer_leaves_sum: int = 0
            for node in current_nodes:
                if node is None: continue
                if node.left is not None: next_nodes.append(node.left)
                if node.right is not None: next_nodes.append(node.right)
                if node.left is None and node.right is None:
                    current_layer_leaves_sum += node.val
            current_nodes = next_nodes
            next_nodes = []
            if current_layer_leaves_sum:
                sum_leaves = current_layer_leaves_sum
        return sum_leaves

# Depth First Search (DFS)
# General idea
# Traverse through all nodes of tree by "postorder" traverse.
# At the each node store variable represent current depth/level of tree and
# if current depth/level more than global variable "current_max_depth" - we should
# change value of "current_max_depth" on current depth and change sum
# global variable "sum_leaves" to current node value.
# If depth/level of current node is equal with "current_max_depth" - we just
# increment variable "sum_leaves" by current node value. At the end of DFS traversing, just return "sum_leaves"
# Complexity
# Time complexity: O(N)
# Space complexity: O(N)
# Code
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def deepestLeavesSum(self, root: Optional[TreeNode]) -> int:
        current_max_depth: int = 0
        sum_leaves: int = 0
        def dfs(root, depth):
            if root is None: return
            dfs(root.left, depth + 1)
            dfs(root.right, depth + 1)
            nonlocal current_max_depth, sum_leaves
            if depth > current_max_depth:
                current_max_depth = depth
                sum_leaves = root.val
            elif depth == current_max_depth:
                sum_leaves += root.val
        dfs(root, depth=current_max_depth)
        return sum_leaves

# 3206. Alternating Groups I
# There is a circle of red and blue tiles. You are given an array of integers colors. The color of tile i is represented by colors[i]:
# 
# colors[i] == 0 means that tile i is red.
# colors[i] == 1 means that tile i is blue.
# Every 3 contiguous tiles in the circle with alternating colors (the middle tile has a different color from its left and right tiles) is called an alternating group.
# 
# Return the number of alternating groups.
# 
# Note that since colors represents a circle, the first and the last tiles are considered to be next to each other.
# 
#  
# 
# Example 1:
# 
# Input: colors = [1,1,1]
# 
# Output: 0
# 
# Explanation:
# 
# 
# 
# Example 2:
# 
# Input: colors = [0,1,0,0,1]
# 
# Output: 3
# 
# Explanation:
# 
# 
# 
# Alternating groups:
# 
# 
# 
#  
# 
# Constraints:
# 
# 3 <= colors.length <= 100
# 0 <= colors[i] <= 1
class Solution:
    def numberOfAlternatingGroups(self, colors: List[int]) -> int:
        groups: int = 0
        if colors[-1] == colors[1] != colors[0]: groups += 1
        if colors[-2] == colors[0] != colors[-1]: groups += 1
        for idx in range(len(colors) - 2):
            if colors[idx] == colors[idx + 2] != colors[idx + 1]:
                groups += 1
        return groups

# 3207. Maximum Points After Enemy Battles
# You are given an integer array enemyEnergies denoting the energy values of various enemies.
# 
# You are also given an integer currentEnergy denoting the amount of energy you have initially.
# 
# You start with 0 points, and all the enemies are unmarked initially.
# 
# You can perform either of the following operations zero or multiple times to gain points:
# 
# Choose an unmarked enemy, i, such that currentEnergy >= enemyEnergies[i]. By choosing this option:
# You gain 1 point.
# Your energy is reduced by the enemy's energy, i.e. currentEnergy = currentEnergy - enemyEnergies[i].
# If you have at least 1 point, you can choose an unmarked enemy, i. By choosing this option:
# Your energy increases by the enemy's energy, i.e. currentEnergy = currentEnergy + enemyEnergies[i].
# The enemy i is marked.
# Return an integer denoting the maximum points you can get in the end by optimally performing operations.
# 
#  
# 
# Example 1:
# 
# Input: enemyEnergies = [3,2,2], currentEnergy = 2
# 
# Output: 3
# 
# Explanation:
# 
# The following operations can be performed to get 3 points, which is the maximum:
# 
# First operation on enemy 1: points increases by 1, and currentEnergy decreases by 2. So, points = 1, and currentEnergy = 0.
# Second operation on enemy 0: currentEnergy increases by 3, and enemy 0 is marked. So, points = 1, currentEnergy = 3, and marked enemies = [0].
# First operation on enemy 2: points increases by 1, and currentEnergy decreases by 2. So, points = 2, currentEnergy = 1, and marked enemies = [0].
# Second operation on enemy 2: currentEnergy increases by 2, and enemy 2 is marked. So, points = 2, currentEnergy = 3, and marked enemies = [0, 2].
# First operation on enemy 1: points increases by 1, and currentEnergy decreases by 2. So, points = 3, currentEnergy = 1, and marked enemies = [0, 2].
# Example 2:
# 
# Input: enemyEnergies = [2], currentEnergy = 10
# 
# Output: 5
# 
# Explanation:
# 
# Performing the first operation 5 times on enemy 0 results in the maximum number of points.
# 
#  
# 
# Constraints:
# 
# 1 <= enemyEnergies.length <= 105
# 1 <= enemyEnergies[i] <= 109
# 0 <= currentEnergy <= 109
# Solution Greedy Sorting O(NlogN) O(1)
# General idea
# For solving this problem "greedy" approach will enough.
#
# Firstly - sorting array in ascending order
# Until array is not empty, at each iteration we have 3 conditions in decision tree:
# If first(smallest) element small or equal than our energy - choose them. Increase point by whole part of energy that can be wasted on this element. Current energy value will be equal remainder of dividing by module (currentEnergy by module cost_energy_element)
# If we have at least 1 point - just choose last(biggest) element. Increase current energy and pop element form array
# If we don't have enough point to choose element - we just should break loop
# Return collected points
# Complexity
# Time complexity: O(NlogN)
# Space complexity: O(1)
# Code
class Solution:
    def maximumPoints(self, enemyEnergies: List[int], currentEnergy: int) -> int:
        enemyEnergies.sort()
        points: int = 0
        while enemyEnergies:
            if currentEnergy >= enemyEnergies[0]:
                points += currentEnergy // enemyEnergies[0]
                currentEnergy %= enemyEnergies[0]
            elif points > 0:
                currentEnergy += enemyEnergies.pop()
            else:
                break
        return points


# Solution Greedy O(N) O(1)
class Solution:
    def maximumPoints(self, enemyEnergies: List[int], currentEnergy: int) -> int:
        minimum_value: int = min(enemyEnergies)
        total_possible_energy: int = currentEnergy + sum(enemyEnergies) - minimum_value
        if currentEnergy < minimum_value: return 0
        return total_possible_energy // minimum_value

# 3208. Alternating Groups II
# There is a circle of red and blue tiles. You are given an array of integers colors and an integer k. The color of tile i is represented by colors[i]:
# 
# colors[i] == 0 means that tile i is red.
# colors[i] == 1 means that tile i is blue.
# An alternating group is every k contiguous tiles in the circle with alternating colors (each tile in the group except the first and last one has a different color from its left and right tiles).
# 
# Return the number of alternating groups.
# 
# Note that since colors represents a circle, the first and the last tiles are considered to be next to each other.
# 
#  
# 
# Example 1:
# 
# Input: colors = [0,1,0,1,0], k = 3
# 
# Output: 3
# 
# Explanation:
# 
# 
# 
# Alternating groups:
# 
# 
# 
# Example 2:
# 
# Input: colors = [0,1,0,0,1,0,1], k = 6
# 
# Output: 2
# 
# Explanation:
# 
# 
# 
# Alternating groups:
# 
# 
# 
# Example 3:
# 
# Input: colors = [1,1,0,1], k = 4
# 
# Output: 0
# 
# Explanation:
# 
# 
# 
#  
# 
# Constraints:
# 
# 3 <= colors.length <= 105
# 0 <= colors[i] <= 1
# 3 <= k <= colors.length
class Solution:
    def numberOfAlternatingGroups(self, colors: List[int], k: int) -> int:
        colors: list[int] = colors[-k + 1:] + colors
        groups: int = 0
        left_pointer: int = 0
        prev_pointer: int = 0
        for right in range(len(colors)):
            while colors[right] == colors[prev_pointer] and left_pointer < right:
                left_pointer += 1
            prev_pointer = right

            if right - left_pointer + 1 >= k:
                groups += 1
        return groups

# 3209. Number of Subarrays With AND Value of K
# Given an array of integers nums and an integer k, return the number of 
# subarrays
#  of nums where the bitwise AND of the elements of the subarray equals k.
# 
#  
# 
# Example 1:
# 
# Input: nums = [1,1,1], k = 1
# 
# Output: 6
# 
# Explanation:
# 
# All subarrays contain only 1's.
# 
# Example 2:
# 
# Input: nums = [1,1,2], k = 1
# 
# Output: 3
# 
# Explanation:
# 
# Subarrays having an AND value of 1 are: [1,1,2], [1,1,2], [1,1,2].
# 
# Example 3:
# 
# Input: nums = [1,2,3], k = 2
# 
# Output: 2
# 
# Explanation:
# 
# Subarrays having an AND value of 2 are: [1,2,3], [1,2,3].
# 
#  
# 
# Constraints:
# 
# 1 <= nums.length <= 105
# 0 <= nums[i], k <= 109
 from collections import defaultdict
class Solution:
    def countSubarrays(self, nums: List[int], k: int) -> int:
        n: int = len(nums)
        count: int = 0
        current_subs: dict[int, int] = defaultdict(int)
        for num in nums:
            new_subs = defaultdict(int)
            for sub in current_subs:
                new_sub = sub & num
                new_subs[new_sub] += current_subs[sub]
            new_subs[num] += 1
            current_subs = new_subs
            count += current_subs[k]
        return count

# A. Insomnia cure
# A. Insomnia cure
# time limit per test2 seconds
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# «One dragon. Two dragon. Three dragon», — the princess was counting. She had trouble falling asleep, and she got bored of counting lambs when she was nine.
# 
# However, just counting dragons was boring as well, so she entertained herself at best she could. Tonight she imagined that all dragons were here to steal her, and she was fighting them off. Every k-th dragon got punched in the face with a frying pan. Every l-th dragon got his tail shut into the balcony door. Every m-th dragon got his paws trampled with sharp heels. Finally, she threatened every n-th dragon to call her mom, and he withdrew in panic.
# 
# How many imaginary dragons suffered moral or physical damage tonight, if the princess counted a total of d dragons?
# 
# Input
# Input data contains integer numbers k, l, m, n and d, each number in a separate line (1 ≤ k, l, m, n ≤ 10, 1 ≤ d ≤ 105).
# 
# Output
# Output the number of damaged dragons.
# 
# Examples
# inputCopy
# 1
# 2
# 3
# 4
# 12
# outputCopy
# 12
# inputCopy
# 2
# 3
# 4
# 5
# 24
# outputCopy
# 17
# Note
# In the first case every first dragon got punched with a frying pan. Some of the dragons suffered from other reasons as well, but the pan alone would be enough.
# 
# In the second case dragons 1, 7, 11, 13, 17, 19 and 23 escaped unharmed.
import sys

def solution(k: int, l: int, m: int, n: int, d: int) -> str:
    suffered: int = 0
    punishments: list = [k, l, m, n]
    for dragon in range(1, d + 1):
        if any(dragon % punishment == 0 for punishment in punishments):
            suffered += 1
    return str(suffered)

if __name__ == '__main__':
    k: int = int(sys.stdin.readline().rstrip())
    l: int = int(sys.stdin.readline().rstrip())
    m: int = int(sys.stdin.readline().rstrip())
    n: int = int(sys.stdin.readline().rstrip())
    d: int = int(sys.stdin.readline().rstrip())
    sys.stdout.write(solution(k, l, m, n, d))
    
# 1518. Water Bottles
# There are numBottles water bottles that are initially full of water. You can exchange numExchange empty water bottles from the market with one full water bottle.
# 
# The operation of drinking a full water bottle turns it into an empty bottle.
# 
# Given the two integers numBottles and numExchange, return the maximum number of water bottles you can drink.
# 
#  
# 
# Example 1:
# 
# 
# Input: numBottles = 9, numExchange = 3
# Output: 13
# Explanation: You can exchange 3 empty bottles to get 1 full water bottle.
# Number of water bottles you can drink: 9 + 3 + 1 = 13.
# Example 2:
# 
# 
# Input: numBottles = 15, numExchange = 4
# Output: 19
# Explanation: You can exchange 4 empty bottles to get 1 full water bottle. 
# Number of water bottles you can drink: 15 + 3 + 1 = 19.
#  
# 
# Constraints:
# 
# 1 <= numBottles <= 100
# 2 <= numExchange <= 100
class Solution:
    def numWaterBottles(self, numBottles: int, numExchange: int) -> int:
        bottles: int = numBottles
        empty_bottles: int = numBottles
        while empty_bottles >= numExchange:
            can_get: int = empty_bottles // numExchange
            bottles += can_get
            empty_bottles = empty_bottles % numExchange + can_get
        return bottles

# 3210. Find the Encrypted String
# You are given a string s and an integer k. Encrypt the string using the following algorithm:
#
# For each character c in s, replace c with the kth character after c in the string (in a cyclic manner).
# Return the encrypted string.
#
#
#
# Example 1:
#
# Input: s = "dart", k = 3
#
# Output: "tdar"
#
# Explanation:
#
# For i = 0, the 3rd character after 'd' is 't'.
# For i = 1, the 3rd character after 'a' is 'd'.
# For i = 2, the 3rd character after 'r' is 'a'.
# For i = 3, the 3rd character after 't' is 'r'.
# Example 2:
#
# Input: s = "aaa", k = 1
#
# Output: "aaa"
#
# Explanation:
#
# As all the characters are the same, the encrypted string will also be the same.
#
#
#
# Constraints:
#
# 1 <= s.length <= 100
# 1 <= k <= 104
# s consists only of lowercase English letters.
class Solution:
    def getEncryptedString(self, s: str, k: int) -> str:
        n: int = len(s)
        return ''.join(s[(idx + k) % n] for idx in range(n))

# 3211. Generate Binary Strings Without Adjacent Zeros
# You are given a positive integer n.
# 
# A binary string x is valid if all 
# substrings
#  of x of length 2 contain at least one "1".
# 
# Return all valid strings with length n, in any order.
# 
#  
# 
# Example 1:
# 
# Input: n = 3
# 
# Output: ["010","011","101","110","111"]
# 
# Explanation:
# 
# The valid strings of length 3 are: "010", "011", "101", "110", and "111".
# 
# Example 2:
# 
# Input: n = 1
# 
# Output: ["0","1"]
# 
# Explanation:
# 
# The valid strings of length 1 are: "0" and "1".
# 
#  
# 
# Constraints:
# 
# 1 <= n <= 18
class Solution:
    def __init__(self):
        self.memo: dict[int, list[str]] = {
            1: ['0', '1'], 2: ['01', '10', '11']
        }
    def validStrings(self, n: int) -> List[str]:
        if n in self.memo: return self.memo[n]
        previous_valid_strings: list[str] = self.validStrings(n-1)
        valid_strings: list[str] = []
        for s in previous_valid_strings:
            if s[-1] == '1':
                valid_strings.append(s + '0')
                valid_strings.append(s + '1')
            elif s[-1] == '0': valid_strings.append(s + '1')
        self.memo[n] = valid_strings
        return valid_strings
        
# 3212. Count Submatrices With Equal Frequency of X and Y
# Given a 2D character matrix grid, where grid[i][j] is either 'X', 'Y', or '.', return the number of 
# submatrices
#  that contains:
# 
# grid[0][0]
# an equal frequency of 'X' and 'Y'.
# at least one 'X'.
#  
# 
# Example 1:
# 
# Input: grid = [["X","Y","."],["Y",".","."]]
# 
# Output: 3
# 
# Explanation:
# 
# 
# 
# Example 2:
# 
# Input: grid = [["X","X"],["X","Y"]]
# 
# Output: 0
# 
# Explanation:
# 
# No submatrix has an equal frequency of 'X' and 'Y'.
# 
# Example 3:
# 
# Input: grid = [[".","."],[".","."]]
# 
# Output: 0
# 
# Explanation:
# 
# No submatrix has at least one 'X'.
# 
#  
# 
# Constraints:
# 
# 1 <= grid.length, grid[i].length <= 1000
# grid[i][j] is either 'X', 'Y', or '.'.
class Solution:
    def numberOfSubmatrices(self, grid: List[List[str]]) -> int:
        rows: int = len(grid)
        cols: int = len(grid[0])
        prefix_x: list[int] = [[0] * (cols + 1) for _ in range(rows + 1)]
        prefix_y: list[int] = [[0] * (cols + 1) for _ in range(rows + 1)]
        for i in range(1, rows + 1):
            for j in range(1, cols + 1):
                prefix_x[i][j] = prefix_x[i-1][j] + prefix_x[i][j-1] - prefix_x[i-1][j-1] + (grid[i-1][j-1] == 'X')
                prefix_y[i][j] = prefix_y[i-1][j] + prefix_y[i][j-1] - prefix_y[i-1][j-1] + (grid[i-1][j-1] == 'Y')
        valid_submatrices: int = 0
        for i in range(1, rows + 1):
            for j in range(1, cols + 1):
                count_x = prefix_x[i][j] - prefix_x[0][j] - prefix_x[i][0] + prefix_x[0][0]
                count_y = prefix_y[i][j] - prefix_y[0][j] - prefix_y[i][0] + prefix_y[0][0]
                if count_x == count_y and count_x > 0: valid_submatrices += 1
        return valid_submatrices

# Binary Tree Serpentine Traversal
# Given the root node of a binary tree, write a function that will traverse the tree in a serpentine fashion. You could also think of this as a zig-zag.
# 
# We want to visit the first level from left to right, the second level from right to left, third level from left to right, and so on...
# 
# The function will return a list of the visited nodes in serpentine order.
# 
# The tree is not necessarily balanced. It is very important that you start the first level from left to right!
# 
# A Node has 3 properties: data (a number or string) left (a reference to the left child) right (a refencence to the right child)
# 
# The empty reference if there is no child is undefined (JS) / None (Python)
# 
# Example:
# 
#     A
#    /\
#   B  C
#  /\  /\
# D E F G
# Should result in ["A", "C", "B", "D", "E", "F", "G"]
# 
# BINARY TREESTREESRECURSIONALGORITHMS
from preloaded import Node

def serpentine_traversal(root_node : Node) -> list:
    reverse: bool = False
    current_nodes: list[Node] = [root_node]
    next_nodes: list[Node] = []
    output: list[Node] = []
    while current_nodes:
        for node in current_nodes[::-1]:
            if node is None: continue
            output.append(node.data)
            if reverse is False:
                if node.left is not None: next_nodes.append(node.left)
                if node.right is not None: next_nodes.append(node.right)
            else:
                if node.right is not None: next_nodes.append(node.right)
                if node.left is not None: next_nodes.append(node.left)
        reverse = not reverse
        current_nodes = next_nodes
        next_nodes = []
    return output

# 1823. Find the Winner of the Circular Game
# There are n friends that are playing a game. The friends are sitting in a circle and are numbered from 1 to n in clockwise order. More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 <= i < n, and moving clockwise from the nth friend brings you to the 1st friend.
# 
# The rules of the game are as follows:
# 
# Start at the 1st friend.
# Count the next k friends in the clockwise direction including the friend you started at. The counting wraps around the circle and may count some friends more than once.
# The last friend you counted leaves the circle and loses the game.
# If there is still more than one friend in the circle, go back to step 2 starting from the friend immediately clockwise of the friend who just lost and repeat.
# Else, the last friend in the circle wins the game.
# Given the number of friends, n, and an integer k, return the winner of the game.
# 
#  
# 
# Example 1:
# 
# 
# Input: n = 5, k = 2
# Output: 3
# Explanation: Here are the steps of the game:
# 1) Start at friend 1.
# 2) Count 2 friends clockwise, which are friends 1 and 2.
# 3) Friend 2 leaves the circle. Next start is friend 3.
# 4) Count 2 friends clockwise, which are friends 3 and 4.
# 5) Friend 4 leaves the circle. Next start is friend 5.
# 6) Count 2 friends clockwise, which are friends 5 and 1.
# 7) Friend 1 leaves the circle. Next start is friend 3.
# 8) Count 2 friends clockwise, which are friends 3 and 5.
# 9) Friend 5 leaves the circle. Only friend 3 is left, so they are the winner.
# Example 2:
# 
# Input: n = 6, k = 5
# Output: 1
# Explanation: The friends leave in this order: 5, 4, 6, 2, 3. The winner is friend 1.
#  
# 
# Constraints:
# 
# 1 <= k <= n <= 500
#  
# 
# Follow up:
# 
# Could you solve this problem in linear time with constant space?
# Math
# Complexity
# Time complexity: O(N)
# Space complexity: O(1)
# Code
class Solution:
    def findTheWinner(self, n: int, k: int) -> int:
        start: int = 1
        for module in range(2, n + 1):
            start = (start + k - 1) % module + 1
        return start

# Simulation
# Complexity
# Time complexity: O(N**2)
# Space complexity: O(N)
# Code
class Solution:
    def findTheWinner(self, n: int, k: int) -> int:
        survivors: list[int] = list(range(1, n + 1))
        start: int = 0
        while len(survivors) != 1:
            start = (start + k - 1) % len(survivors)
            survivors.pop(start)
        return survivors[0]

# Clothes size number converter
# Description
# You have clothes international size as text (xs, s, xxl).
# Your goal is to return European number size as an number from that size
#
# Notice that there is arbitrary amount of modifiers (x), excluding m size and input can be any string
#
# Linearity
# Base size for medium (m) is 38
# (then, small (s), is 36 and large (l) is 40)
#
# As you can see scale is linear, modifier x continues that by adding or subtracting 2 from resulting size
#
# Invalid cases
# Function should handle wrong/invalid sizes
#
# Valid input has any base size (s/m/l) and any amount of modifiers (x) before base size (like xxl).
# Notice that you cannot apply modifier for m size, consider that case as invalid!
# Anything else is disallowed and should be considered as invalid (None for Python).
#
# Invalid examples: xxx, sss, xm, other string
#
# Valid Examples
# xs: 34
# s: 36
# m: 38
# l: 40
# xl: 42
#
# STRINGSFUNDAMENTALS
def size_to_number(size):
    if len(size) == 1:
        return 38 if size == 'm' else 36 if size == 's' else 40 if size == 'l' else None
    if len(set(size)) == 2 and 'x' in size and ('s' in size or 'l' in size):
        if 'l' in size and size.index('l') < size.index('x'): return
        if 's' in size and size.index('s') < size.index('x'): return
        acc: int = size.count('x') * 2
        return 36 - acc if 's' in size else 40 + acc

# A. Hit the Lottery
# A. Hit the Lottery
# time limit per test1 second
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# Allen has a LOT of money. He has n
#  dollars in the bank. For security reasons, he wants to withdraw it in cash (we will not disclose the reasons here). The denominations for dollar bills are 1
# , 5
# , 10
# , 20
# , 100
# . What is the minimum number of bills Allen could receive after withdrawing his entire balance?
# 
# Input
# The first and only line of input contains a single integer n
#  (1≤n≤109
# ).
# 
# Output
# Output the minimum number of bills that Allen could receive.
# 
# Examples
# inputCopy
# 125
# outputCopy
# 3
# inputCopy
# 43
# outputCopy
# 5
# inputCopy
# 1000000000
# outputCopy
# 10000000
# Note
# In the first sample case, Allen can withdraw this with a 100
#  dollar bill, a 20
#  dollar bill, and a 5
#  dollar bill. There is no way for Allen to receive 125
#  dollars in one or two bills.
# 
# In the second sample case, Allen can withdraw two 20
#  dollar bills and three 1
#  dollar bills.
# 
# In the third sample case, Allen can withdraw 100000000
#  (ten million!) 100
#  dollar bills.
import sys


def solution(n: int) -> str:
    total_bills: int = 0
    total_bills += n // 100
    n %= 100
    total_bills += n // 20
    n %= 20
    total_bills += n // 10
    n %= 10
    total_bills += n // 5
    n %= 5
    total_bills += n
    return str(total_bills)


if __name__ == '__main__':
    n: int = int(sys.stdin.readline().rstrip())
    sys.stdout.write(solution(n))
    
# A. Anton and Letters
# A. Anton and Letters
# time limit per test2 seconds
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# Recently, Anton has found a set. The set consists of small English letters. Anton carefully wrote out all the letters from the set in one line, separated by a comma. He also added an opening curved bracket at the beginning of the line and a closing curved bracket at the end of the line.
#
# Unfortunately, from time to time Anton would forget writing some letter and write it again. He asks you to count the total number of distinct letters in his set.
#
# Input
# The first and the single line contains the set of letters. The length of the line doesn't exceed 1000. It is guaranteed that the line starts from an opening curved bracket and ends with a closing curved bracket. Between them, small English letters are listed, separated by a comma. Each comma is followed by a space.
#
# Output
# Print a single number — the number of distinct letters in Anton's set.
#
# Examples
# inputCopy
# {a, b, c}
# outputCopy
# 3
# inputCopy
# {b, a, b, a}
# outputCopy
# 2
# inputCopy
# {}
# outputCopy
# 0
import sys


def solution(n: str) -> str:
    return str(len(set([char for char in n if char not in '{} ,'])))


if __name__ == '__main__':
    n: str = sys.stdin.readline().rstrip()
    sys.stdout.write(solution(n))
    
# 1701. Average Waiting Time
# There is a restaurant with a single chef. You are given an array customers, where customers[i] = [arrivali, timei]:
#
# arrivali is the arrival time of the ith customer. The arrival times are sorted in non-decreasing order.
# timei is the time needed to prepare the order of the ith customer.
# When a customer arrives, he gives the chef his order, and the chef starts preparing it once he is idle. The customer waits till the chef finishes preparing his order. The chef does not prepare food for more than one customer at a time. The chef prepares food for customers in the order they were given in the input.
#
# Return the average waiting time of all customers. Solutions within 10-5 from the actual answer are considered accepted.
#
#
#
# Example 1:
#
# Input: customers = [[1,2],[2,5],[4,3]]
# Output: 5.00000
# Explanation:
# 1) The first customer arrives at time 1, the chef takes his order and starts preparing it immediately at time 1, and finishes at time 3, so the waiting time of the first customer is 3 - 1 = 2.
# 2) The second customer arrives at time 2, the chef takes his order and starts preparing it at time 3, and finishes at time 8, so the waiting time of the second customer is 8 - 2 = 6.
# 3) The third customer arrives at time 4, the chef takes his order and starts preparing it at time 8, and finishes at time 11, so the waiting time of the third customer is 11 - 4 = 7.
# So the average waiting time = (2 + 6 + 7) / 3 = 5.
# Example 2:
#
# Input: customers = [[5,2],[5,4],[10,3],[20,1]]
# Output: 3.25000
# Explanation:
# 1) The first customer arrives at time 5, the chef takes his order and starts preparing it immediately at time 5, and finishes at time 7, so the waiting time of the first customer is 7 - 5 = 2.
# 2) The second customer arrives at time 5, the chef takes his order and starts preparing it at time 7, and finishes at time 11, so the waiting time of the second customer is 11 - 5 = 6.
# 3) The third customer arrives at time 10, the chef takes his order and starts preparing it at time 11, and finishes at time 14, so the waiting time of the third customer is 14 - 10 = 4.
# 4) The fourth customer arrives at time 20, the chef takes his order and starts preparing it immediately at time 20, and finishes at time 21, so the waiting time of the fourth customer is 21 - 20 = 1.
# So the average waiting time = (2 + 6 + 4 + 1) / 4 = 3.25.
#
#
# Constraints:
#
# 1 <= customers.length <= 105
# 1 <= arrivali, timei <= 104
# arrivali <= arrivali+1
class Solution:
    def averageWaitingTime(self, customers: List[List[int]]) -> float:
        average: int = 0
        current_time: int = 0
        for customer in customers:
            current_time = max(customer[0], current_time) + customer[1]
            average += current_time - customer[0]
        return average / len(customers)
# Where customer[0] - arrival time for customer
# And customer[1] - cooking time for customer

# A. Kefa and First Steps
# A. Kefa and First Steps
# time limit per test2 seconds
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# Kefa decided to make some money doing business on the Internet for exactly n days. He knows that on the i-th day (1 ≤ i ≤ n) he makes ai money. Kefa loves progress, that's why he wants to know the length of the maximum non-decreasing subsegment in sequence ai. Let us remind you that the subsegment of the sequence is its continuous fragment. A subsegment of numbers is called non-decreasing if all numbers in it follow in the non-decreasing order.
#
# Help Kefa cope with this task!
#
# Input
# The first line contains integer n (1 ≤ n ≤ 105).
#
# The second line contains n integers a1,  a2,  ...,  an (1 ≤ ai ≤ 109).
#
# Output
# Print a single integer — the length of the maximum non-decreasing subsegment of sequence a.
#
# Examples
# inputCopy
# 6
# 2 2 1 3 4 1
# outputCopy
# 3
# inputCopy
# 3
# 2 2 9
# outputCopy
# 3
# Note
# In the first test the maximum non-decreasing subsegment is the numbers from the third to the fifth one.
#
# In the second test the maximum non-decreasing subsegment is the numbers from the first to the third one.
import sys


def solution(n: int, arr: list) -> str:
    start_index: int = 0
    mx_sequence: int = float('-inf')
    mx_item: int = float('-inf')
    for idx in range(n):
        if arr[idx] < mx_item:
            mx_sequence = max(mx_sequence, idx - start_index)
            start_index = idx
            mx_item = arr[idx]
        elif arr[idx] > mx_item:
            mx_item = arr[idx]
    mx_sequence = max(mx_sequence, n - start_index)
    return str(mx_sequence)


if __name__ == '__main__':
    n: int = int(sys.stdin.readline().rstrip())
    arr: list = list(map(int, sys.stdin.readline().rstrip().split()))
    sys.stdout.write(solution(n, arr))
    
# Personalized brand list
# Assume you are creating a webshop and you would like to help the user in the search. You have products with brands, prices and name. You have the history of opened products (the most recently opened being the first item).
#
# Your task is to create a list of brands ordered by popularity, if two brands have the same popularity level then choose the one which was opened last from the two and second the other one.
#
# Product popularity is calculated from the history. If a product is more times in the history than it is more popular.
#
# Your function will have one parameter which will be always an array/list of object.
#
# example product: { name: "Phone", price: 25, brand: "Fake brand" }
#
# ALGORITHMS
from collections import Counter
def sorted_brands(history):
    storage = Counter([i['brand'] for i in history])
    store = list(storage.keys())
    store.sort(key=lambda x: storage[x], reverse=True)
    return store
    
# 2265. Count Nodes Equal to Average of Subtree
# Given the root of a binary tree, return the number of nodes where the value of the node is equal to the average of the values in its subtree.
#
# Note:
#
# The average of n elements is the sum of the n elements divided by n and rounded down to the nearest integer.
# A subtree of root is a tree consisting of root and all of its descendants.
#
#
# Example 1:
#
#
# Input: root = [4,8,5,0,1,null,6]
# Output: 5
# Explanation:
# For the node with value 4: The average of its subtree is (4 + 8 + 5 + 0 + 1 + 6) / 6 = 24 / 6 = 4.
# For the node with value 5: The average of its subtree is (5 + 6) / 2 = 11 / 2 = 5.
# For the node with value 0: The average of its subtree is 0 / 1 = 0.
# For the node with value 1: The average of its subtree is 1 / 1 = 1.
# For the node with value 6: The average of its subtree is 6 / 1 = 6.
# Example 2:
#
#
# Input: root = [1]
# Output: 1
# Explanation: For the node with value 1: The average of its subtree is 1 / 1 = 1.
#
#
# Constraints:
#
# The number of nodes in the tree is in the range [1, 1000].
# 0 <= Node.val <= 1000
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    correct_nodes: int = 0

    def dfs(self, root):
        if root is None: return 0, 0
        left_nodes, left_sum_nodes = self.dfs(root.left)
        right_nodes, right_sum_nodes = self.dfs(root.right)
        current_nodes_count: int = 1 + left_nodes + right_nodes
        current_sum_nodes: int = root.val + left_sum_nodes + right_sum_nodes
        average: int = current_sum_nodes // current_nodes_count
        if root.val == average: self.correct_nodes += 1
        return current_nodes_count, current_sum_nodes

    def averageOfSubtree(self, root: TreeNode) -> int:
        self.dfs(root)
        return self.correct_nodes

# 1598. Crawler Log Folder
# The Leetcode file system keeps a log each time some user performs a change folder operation.
# 
# The operations are described below:
# 
# "../" : Move to the parent folder of the current folder. (If you are already in the main folder, remain in the same folder).
# "./" : Remain in the same folder.
# "x/" : Move to the child folder named x (This folder is guaranteed to always exist).
# You are given a list of strings logs where logs[i] is the operation performed by the user at the ith step.
# 
# The file system starts in the main folder, then the operations in logs are performed.
# 
# Return the minimum number of operations needed to go back to the main folder after the change folder operations.
# 
#  
# 
# Example 1:
# 
# 
# 
# Input: logs = ["d1/","d2/","../","d21/","./"]
# Output: 2
# Explanation: Use this change folder operation "../" 2 times and go back to the main folder.
# Example 2:
# 
# 
# 
# Input: logs = ["d1/","d2/","./","d3/","../","d31/"]
# Output: 3
# Example 3:
# 
# Input: logs = ["d1/","../","../","../"]
# Output: 0
#  
# 
# Constraints:
# 
# 1 <= logs.length <= 103
# 2 <= logs[i].length <= 10
# logs[i] contains lowercase English letters, digits, '.', and '/'.
# logs[i] follows the format described in the statement.
# Folder names consist of lowercase English letters and digits.
# Linked List (Stack LIFO representation)
# Complexity
# Time complexity: O(N)
# Space complexity: O(N)
# Code
from collections import deque
class Solution:
    def minOperations(self, logs: List[str]) -> int:
        file_storage = deque()
        for log in logs:
            if log == '../':
                if file_storage: file_storage.pop()
            elif log != './':
                file_storage.append(log)
        return len(file_storage)

# Recursive
# Note:
# Solution uses Tail Recursion Optimization(TRO),
# but Python interpretator can't define cases were need to optimize TRO cases.
# Complexity
# Time complexity: O(N)
# Space complexity: O(N)
# Code
class Solution:
    def minOperations(self, logs: List[str], idx: int = 0, depth: int = 0) -> int:
        if idx == len(logs): return depth
        if logs[idx] == '../':
            return self.minOperations(logs, idx + 1, max(depth - 1, 0))
        return self.minOperations(logs, idx + 1, depth + (1 if logs[idx] != './' else 0))

# Iterative loop
# Complexity
# Time complexity: O(N)
# Space complexity: O(1)
# Code
class Solution:
    def minOperations(self, logs: List[str], idx: int = 0, depth: int = 0) -> int:
        depth: int = 0
        for log in logs:
            if log == '../': depth = max(depth - 1, 0)
            elif log != './': depth += 1
        return depth

# A. Dubstep
# A. Dubstep
# time limit per test2 seconds
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# Vasya works as a DJ in the best Berland nightclub, and he often uses dubstep music in his performance. Recently, he has decided to take a couple of old songs and make dubstep remixes from them.
# 
# Let's assume that a song consists of some number of words. To make the dubstep remix of this song, Vasya inserts a certain number of words "WUB" before the first word of the song (the number may be zero), after the last word (the number may be zero), and between words (at least one between any pair of neighbouring words), and then the boy glues together all the words, including "WUB", in one string and plays the song at the club.
# 
# For example, a song with words "I AM X" can transform into a dubstep remix as "WUBWUBIWUBAMWUBWUBX" and cannot transform into "WUBWUBIAMWUBX".
# 
# Recently, Petya has heard Vasya's new dubstep track, but since he isn't into modern music, he decided to find out what was the initial song that Vasya remixed. Help Petya restore the original song.
# 
# Input
# The input consists of a single non-empty string, consisting only of uppercase English letters, the string's length doesn't exceed 200 characters. It is guaranteed that before Vasya remixed the song, no word contained substring "WUB" in it; Vasya didn't change the word order. It is also guaranteed that initially the song had at least one word.
# 
# Output
# Print the words of the initial song that Vasya used to make a dubsteb remix. Separate the words with a space.
# 
# Examples
# inputCopy
# WUBWUBABCWUB
# outputCopy
# ABC 
# inputCopy
# WUBWEWUBAREWUBWUBTHEWUBCHAMPIONSWUBMYWUBFRIENDWUB
# outputCopy
# WE ARE THE CHAMPIONS MY FRIEND 
# Note
# In the first sample: "WUBWUBABCWUB" = "WUB" + "WUB" + "ABC" + "WUB". That means that the song originally consisted of a single word "ABC", and all words "WUB" were added by Vasya.
# 
# In the second sample Vasya added a single word "WUB" between all neighbouring words, in the beginning and in the end, except for words "ARE" and "THE" — between them Vasya added two "WUB".
import sys


def solution(n: str) -> str:
    output: list = []
    pointer: int = 0
    while pointer < len(n):
        if n[pointer:].startswith('WUB'):
            pointer += 3
            continue
        word: str = ''
        while pointer < len(n) and n[pointer:pointer + 3] != 'WUB':
            word += n[pointer]
            pointer += 1
        output.append(word)
    return ' '.join(output)


if __name__ == '__main__':
    n: str = sys.stdin.readline().rstrip()
    sys.stdout.write(solution(n))
    
# Best Stock Profit in Single Sale
# You're a buyer/seller and your buisness is at stake... You need to make profit... Or at least, you need to lose the least amount of money!
# Knowing a list of prices for buy/sell operations, you need to pick two of them. Buy/sell market is evolving across time and the list represent this evolution. First, you need to buy one item, then sell it later. Find the best profit you can do.
#
# Example:
# Given an array of prices [3, 10, 8, 4], the best profit you could make would be 7 because you buy at 3 first, then sell at 10.
#
# Input:
# A list of prices (integers), of length 2 or more.
#
# Output:
# The result of the best buy/sell operation, as an integer.
#
# Note:
# Be aware you'll face lists with several thousands of elements, so think about performance.
#
# ALGORITHMS
def max_profit(prices):
    profit: int = float('-inf')
    local_min: int = float('inf')
    for price in prices:
        if price < local_min:
            if local_min != float('inf'):
                profit = max(profit, price - local_min)
            local_min = price
        else:
            profit = max(profit, price - local_min)
    return profit if profit != float('-inf') else -1

# 1315. Sum of Nodes with Even-Valued Grandparent
# Given the root of a binary tree, return the sum of values of nodes with an even-valued grandparent. If there are no nodes with an even-valued grandparent, return 0.
#
# A grandparent of a node is the parent of its parent if it exists.
#
#
#
# Example 1:
#
#
# Input: root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]
# Output: 18
# Explanation: The red nodes are the nodes with even-value grandparent while the blue nodes are the even-value grandparents.
# Example 2:
#
#
# Input: root = [1]
# Output: 0
#
#
# Constraints:
#
# The number of nodes in the tree is in the range [1, 104].
# 1 <= Node.val <= 100
# DFS
# Complexity
# Time complexity: O(N)
# Space complexity: O(N)
# Code
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    sum_even_nodes: int = 0

    def dfs(self, root, is_even: bool) -> None:
        if root is None: return
        if is_even:
            if root.left: self.sum_even_nodes += root.left.val
            if root.right: self.sum_even_nodes += root.right.val
        self.dfs(root.left, root.val & 1 == 0)
        self.dfs(root.right, root.val & 1 == 0)

    def sumEvenGrandparent(self, root: TreeNode) -> int:
        self.dfs(root, False)
        return self.sum_even_nodes

# BFS
# Complexity
# Time complexity: O(N)
# Space complexity: O(N)
# Code
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
from collections import deque
class Solution:
    def sumEvenGrandparent(self, root: TreeNode) -> int:
        grandparents = deque()
        current_nodes = deque()
        current_nodes.append(root)
        sum_even_nodes: int = 0
        while current_nodes:
            grandparent: bool = bool(grandparents and grandparents.popleft() & 1 == 0)
            current_node = current_nodes.popleft()
            if current_node:
                if current_node.left:
                    if grandparent: sum_even_nodes += current_node.left.val
                    grandparents.append(current_node.val)
                    current_nodes.append(current_node.left)
                if current_node.right:
                    if grandparent: sum_even_nodes += current_node.right.val
                    grandparents.append(current_node.val)
                    current_nodes.append(current_node.right)
        return sum_even_nodes

# 1190. Reverse Substrings Between Each Pair of Parentheses
# You are given a string s that consists of lower case English letters and brackets.
# 
# Reverse the strings in each pair of matching parentheses, starting from the innermost one.
# 
# Your result should not contain any brackets.
# 
#  
# 
# Example 1:
# 
# Input: s = "(abcd)"
# Output: "dcba"
# Example 2:
# 
# Input: s = "(u(love)i)"
# Output: "iloveu"
# Explanation: The substring "love" is reversed first, then the whole string is reversed.
# Example 3:
# 
# Input: s = "(ed(et(oc))el)"
# Output: "leetcode"
# Explanation: First, we reverse the substring "oc", then "etco", and finally, the whole string.
#  
# 
# Constraints:
# 
# 1 <= s.length <= 2000
# s only contains lower case English characters and parentheses.
# It is guaranteed that all parentheses are balanced.
# Solution Stack
# Note:
# In Python, string is immutable object, so because this solution uses list of alphabet characters for perfomance.
# You can use a whole string, if it mutable in your language.
# Complexity
# Time complexity: O(N)
# Space complexity: O(N)
# Code
class Solution:
    def reverseParentheses(self, s: str) -> str:
        storage: list[list[str]] = []
        current_substring: list[str] = []
        for char in s:
            if char == '(':
                storage.append(current_substring)
                current_substring = []
            elif char == ')':
                current_substring = storage.pop() + current_substring[::-1]
            else:
                current_substring.append(char)
        return ''.join(current_substring)

# A. Anton and Polyhedrons
# A. Anton and Polyhedrons
# time limit per test2 seconds
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# Anton's favourite geometric figures are regular polyhedrons. Note that there are five kinds of regular polyhedrons:
#
# Tetrahedron. Tetrahedron has 4 triangular faces.
# Cube. Cube has 6 square faces.
# Octahedron. Octahedron has 8 triangular faces.
# Dodecahedron. Dodecahedron has 12 pentagonal faces.
# Icosahedron. Icosahedron has 20 triangular faces.
# All five kinds of polyhedrons are shown on the picture below:
#
#
# Anton has a collection of n polyhedrons. One day he decided to know, how many faces his polyhedrons have in total. Help Anton and find this number!
#
# Input
# The first line of the input contains a single integer n (1 ≤ n ≤ 200 000) — the number of polyhedrons in Anton's collection.
#
# Each of the following n lines of the input contains a string si — the name of the i-th polyhedron in Anton's collection. The string can look like this:
#
# "Tetrahedron" (without quotes), if the i-th polyhedron in Anton's collection is a tetrahedron.
# "Cube" (without quotes), if the i-th polyhedron in Anton's collection is a cube.
# "Octahedron" (without quotes), if the i-th polyhedron in Anton's collection is an octahedron.
# "Dodecahedron" (without quotes), if the i-th polyhedron in Anton's collection is a dodecahedron.
# "Icosahedron" (without quotes), if the i-th polyhedron in Anton's collection is an icosahedron.
# Output
# Output one number — the total number of faces in all the polyhedrons in Anton's collection.
#
# Examples
# inputCopy
# 4
# Icosahedron
# Cube
# Tetrahedron
# Dodecahedron
# outputCopy
# 42
# inputCopy
# 3
# Dodecahedron
# Octahedron
# Octahedron
# outputCopy
# 28
# Note
# In the first sample Anton has one icosahedron, one cube, one tetrahedron and one dodecahedron. Icosahedron has 20 faces, cube has 6 faces, tetrahedron has 4 faces and dodecahedron has 12 faces. In total, they have 20 + 6 + 4 + 12 = 42 faces.
# Solution HashMap O(N) O(1)
import sys


def solution(n: int) -> str:
    total_hedrons: int = 0
    hedrons: dict = {
        'Tetrahedron': 4, 'Cube': 6, 'Octahedron': 8,
        'Dodecahedron': 12, 'Icosahedron': 20
    }
    for _ in range(n):
        polyhedron: str = sys.stdin.readline().rstrip()
        total_hedrons += hedrons[polyhedron]
    return str(total_hedrons)


if __name__ == '__main__':
    n: int = int(sys.stdin.readline().rstrip())
    sys.stdout.write(solution(n))
    
# Decode Diagonal
# Decode the diagonal.
# Given a grid of characters. Output a decoded message as a string.
# 
# Input
# 
#   H Z R R Q
#   D I F C A E A !
#   G H T E L A E 
#   L M N H P R F 
#   X Z R P E
# Output
# 
# HITHERE! (diagonally down right ↘ and diagonally up right ↗ if you can't go further).
# 
# The message ends when there is no space at the right up or down diagonal.
# 
# To make things even clearer: the same example, but in a simplified view
# 
#   H _ _ _ _
#   _ I _ _ _ _ _ !
#   _ _ T _ _ _ E 
#   _ _ _ H _ R _
#   _ _ _ _ E
# ALGORITHMS
def get_diagonal_code(grid):
    if not grid: return ''
    grid = [floor.split() for floor in grid.split('\n')]
    if len(grid) == 1: return grid[0][0]
    output: list[str] = []
    row = col = 0
    swap: bool = True
    while swap:
        swap = False
        while row < len(grid) and col < len(grid[row]):
            output.append(grid[row][col])
            row, col = row + 1, col + 1
        if row < len(grid): break
        row -= 2

        while row >= 0 and col < len(grid[row]):
            output.append(grid[row][col])
            row, col = row - 1, col + 1
            swap = True

        if row > 0: break
        if row == -1: row = 1
        if col >= len(grid[row]): break
    return ''.join(output)

# 654. Maximum Binary Tree
# You are given an integer array nums with no duplicates. A maximum binary tree can be built recursively from nums using the following algorithm:
#
# Create a root node whose value is the maximum value in nums.
# Recursively build the left subtree on the subarray prefix to the left of the maximum value.
# Recursively build the right subtree on the subarray suffix to the right of the maximum value.
# Return the maximum binary tree built from nums.
#
#
#
# Example 1:
#
#
# Input: nums = [3,2,1,6,0,5]
# Output: [6,3,5,null,2,0,null,null,1]
# Explanation: The recursive calls are as follow:
# - The largest value in [3,2,1,6,0,5] is 6. Left prefix is [3,2,1] and right suffix is [0,5].
#     - The largest value in [3,2,1] is 3. Left prefix is [] and right suffix is [2,1].
#         - Empty array, so no child.
#         - The largest value in [2,1] is 2. Left prefix is [] and right suffix is [1].
#             - Empty array, so no child.
#             - Only one element, so child is a node with value 1.
#     - The largest value in [0,5] is 5. Left prefix is [0] and right suffix is [].
#         - Only one element, so child is a node with value 0.
#         - Empty array, so no child.
# Example 2:
#
#
# Input: nums = [3,2,1]
# Output: [3,null,2,null,1]
#
#
# Constraints:
#
# 1 <= nums.length <= 1000
# 0 <= nums[i] <= 1000
# All integers in nums are unique.
# Monotonic Stack
# Complexity
# Time complexity: O(N)
# Space complexity: O(N)
# Code
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def constructMaximumBinaryTree(self, nums: List[int]) -> Optional[TreeNode]:
        stack: list[TreeNode] = []
        for node in nums:
            tree: TreeNode = TreeNode(node)
            while stack and stack[-1].val < tree.val:
                tree.left = stack.pop()
            if stack:
                stack[-1].right = tree
            stack.append(tree)
        return stack[0]

# DFS
# Complexity
# Time complexity: O(N**2)
# Space complexity: O(N)
# Code
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def dfs(self, root, left: int, right: int) -> Optional[TreeNode]:
        if left >= right: return

        max_element, max_element_index = root[left], left
        for idx in range(left, right):
            if root[idx] > max_element:
                max_element, max_element_index = root[idx], idx

        left_subtree = self.dfs(root, left, max_element_index)
        right_subtree = self.dfs(root, max_element_index + 1, right)
        head_of_tree = TreeNode(val=max_element, left=left_subtree, right=right_subtree)
        return head_of_tree

    def constructMaximumBinaryTree(self, nums: List[int]) -> Optional[TreeNode]:
        tree: TreeNode = self.dfs(nums, 0, len(nums))
        return tree

# B. Taxi
# B. Taxi
# time limit per test3 seconds
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# After the lessons n groups of schoolchildren went outside and decided to visit Polycarpus to celebrate his birthday. We know that the i-th group consists of si friends (1 ≤ si ≤ 4), and they want to go to Polycarpus together. They decided to get there by taxi. Each car can carry at most four passengers. What minimum number of cars will the children need if all members of each group should ride in the same taxi (but one taxi can take more than one group)?
# 
# Input
# The first line contains integer n (1 ≤ n ≤ 105) — the number of groups of schoolchildren. The second line contains a sequence of integers s1, s2, ..., sn (1 ≤ si ≤ 4). The integers are separated by a space, si is the number of children in the i-th group.
# 
# Output
# Print the single number — the minimum number of taxis necessary to drive all children to Polycarpus.
# 
# Examples
# inputCopy
# 5
# 1 2 4 3 3
# outputCopy
# 4
# inputCopy
# 8
# 2 3 4 4 2 1 3 1
# outputCopy
# 5
# Note
# In the first test we can sort the children into four cars like this:
# 
# the third group (consisting of four children),
# the fourth group (consisting of three children),
# the fifth group (consisting of three children),
# the first and the second group (consisting of one and two children, correspondingly).
# There are other ways to sort the groups into four cars.
import sys


def solution(n: int, groups: list) -> str:
    groups.sort()
    taxes: int = 0
    left_pointer: int = 0
    right_pointer: int = n - 1
    while left_pointer <= right_pointer:
        total_passengers: int = groups[right_pointer]
        while left_pointer < right_pointer and total_passengers + groups[left_pointer] <= 4:
            total_passengers += groups[left_pointer]
            left_pointer += 1
        right_pointer -= 1
        taxes += 1
    return str(taxes)


if __name__ == '__main__':
    n: int = int(sys.stdin.readline().rstrip())
    groups: list = list(map(int, sys.stdin.readline().rstrip().split()))
    sys.stdout.write(solution(n, groups))
    
# 1717. Maximum Score From Removing Substrings
# You are given a string s and two integers x and y. You can perform two types of operations any number of times.
# 
# Remove substring "ab" and gain x points.
# For example, when removing "ab" from "cabxbae" it becomes "cxbae".
# Remove substring "ba" and gain y points.
# For example, when removing "ba" from "cabxbae" it becomes "cabxe".
# Return the maximum points you can gain after applying the above operations on s.
# 
#  
# 
# Example 1:
# 
# Input: s = "cdbcbbaaabab", x = 4, y = 5
# Output: 19
# Explanation:
# - Remove the "ba" underlined in "cdbcbbaaabab". Now, s = "cdbcbbaaab" and 5 points are added to the score.
# - Remove the "ab" underlined in "cdbcbbaaab". Now, s = "cdbcbbaa" and 4 points are added to the score.
# - Remove the "ba" underlined in "cdbcbbaa". Now, s = "cdbcba" and 5 points are added to the score.
# - Remove the "ba" underlined in "cdbcba". Now, s = "cdbc" and 5 points are added to the score.
# Total score = 5 + 4 + 5 + 5 = 19.
# Example 2:
# 
# Input: s = "aabbaaxybbaabb", x = 5, y = 4
# Output: 20
#  
# 
# Constraints:
# 
# 1 <= s.length <= 105
# 1 <= x, y <= 104
# s consists of lowercase English letters.
# Solution Stack
# General idea:
# Choose substring that gives max points and count
# how many it contains in string using stack for counting and processing.
# After, you should iterate from entire first stack and count how many second substring contains in first stack,
# uses second stack for counting. In the end return total sum of points.
# Complexity
# Time complexity: O(N)
# Space complexity: O(N)
# Code
class Solution:
    def maximumGain(self, s: str, x: int, y: int) -> int:
        first_substring: str = ['a', 'b'] if x >= y else ['b', 'a']
        first_points: int = max(x, y)
        second_substring: str = ['a', 'b'] if x < y else ['b', 'a']
        second_points: int = min(x, y)
        total_points: int = 0

        first_stack: list[str] = []
        for char in s:
            first_stack.append(char)
            while first_stack and first_stack[-2:] == first_substring:
                total_points += first_points
                first_stack.pop()
                first_stack.pop()

        second_stack: list[str] = []
        for char in first_stack:
            second_stack.append(char)
            while second_stack and second_stack[-2:] == second_substring:
                total_points += second_points
                second_stack.pop()
                second_stack.pop()

        return total_points

# Sort binary tree by levels
# You are given a binary tree:
# 
# class Node:
#     def __init__(self, L, R, n):
#         self.left = L
#         self.right = R
#         self.value = n
# Your task is to return the list with elements from tree sorted by levels, which means the root element goes first, then root children (from left to right) are second and third, and so on.
# 
# Return empty list if root is None.
# 
# Example 1 - following tree:
# 
#                  2
#             8        9
#           1  3     4   5
# Should return following list:
# 
# [2,8,9,1,3,4,5]
# Example 2 - following tree:
# 
#                  1
#             8        4
#               3        5
#                          7
# Should return following list:
# 
# [1,8,4,3,5,7]
# TREESBINARY TREESPERFORMANCEALGORITHMSSORTING
def tree_by_levels(node):
    output: list[int] = []
    current_nodes: list = [node]
    next_nodes: list = []
    while current_nodes:
        for current_node in current_nodes:
            if current_node is None: continue
            output.append(current_node.value)
            if current_node.left is not None: next_nodes.append(current_node.left)
            if current_node.right is not None: next_nodes.append(current_node.right)
        current_nodes = next_nodes
        next_nodes = []
    return output
    
# 2391. Minimum Amount of Time to Collect Garbage
# You are given a 0-indexed array of strings garbage where garbage[i] represents the assortment of garbage at the ith house. garbage[i] consists only of the characters 'M', 'P' and 'G' representing one unit of metal, paper and glass garbage respectively. Picking up one unit of any type of garbage takes 1 minute.
# 
# You are also given a 0-indexed integer array travel where travel[i] is the number of minutes needed to go from house i to house i + 1.
# 
# There are three garbage trucks in the city, each responsible for picking up one type of garbage. Each garbage truck starts at house 0 and must visit each house in order; however, they do not need to visit every house.
# 
# Only one garbage truck may be used at any given moment. While one truck is driving or picking up garbage, the other two trucks cannot do anything.
# 
# Return the minimum number of minutes needed to pick up all the garbage.
# 
#  
# 
# Example 1:
# 
# Input: garbage = ["G","P","GP","GG"], travel = [2,4,3]
# Output: 21
# Explanation:
# The paper garbage truck:
# 1. Travels from house 0 to house 1
# 2. Collects the paper garbage at house 1
# 3. Travels from house 1 to house 2
# 4. Collects the paper garbage at house 2
# Altogether, it takes 8 minutes to pick up all the paper garbage.
# The glass garbage truck:
# 1. Collects the glass garbage at house 0
# 2. Travels from house 0 to house 1
# 3. Travels from house 1 to house 2
# 4. Collects the glass garbage at house 2
# 5. Travels from house 2 to house 3
# 6. Collects the glass garbage at house 3
# Altogether, it takes 13 minutes to pick up all the glass garbage.
# Since there is no metal garbage, we do not need to consider the metal garbage truck.
# Therefore, it takes a total of 8 + 13 = 21 minutes to collect all the garbage.
# Example 2:
# 
# Input: garbage = ["MMM","PGM","GP"], travel = [3,10]
# Output: 37
# Explanation:
# The metal garbage truck takes 7 minutes to pick up all the metal garbage.
# The paper garbage truck takes 15 minutes to pick up all the paper garbage.
# The glass garbage truck takes 15 minutes to pick up all the glass garbage.
# It takes a total of 7 + 15 + 15 = 37 minutes to collect all the garbage.
#  
# 
# Constraints:
# 
# 2 <= garbage.length <= 105
# garbage[i] consists of only the letters 'M', 'P', and 'G'.
# 1 <= garbage[i].length <= 10
# travel.length == garbage.length - 1
# 1 <= travel[i] <= 100
class Solution:
    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:
        total_time: int = 0
        metal_track_position: int = 0
        paper_track_position: int = 0
        glass_track_position: int = 0
        for home in range(len(garbage)):

            if 'M' in garbage[home]:
                if metal_track_position != home:
                    total_time += sum(travel[metal_track_position:home])
                    metal_track_position = home
                total_time += garbage[home].count('M')

            if 'P' in garbage[home]:
                if paper_track_position != home:
                    total_time += sum(travel[paper_track_position:home])
                    paper_track_position = home
                total_time += garbage[home].count('P')

            if 'G' in garbage[home]:
                if glass_track_position != home:
                    total_time += sum(travel[glass_track_position:home])
                    glass_track_position = home
                total_time += garbage[home].count('G')

        return total_time

# 2751. Robot Collisions
# There are n 1-indexed robots, each having a position on a line, health, and movement direction.
# 
# You are given 0-indexed integer arrays positions, healths, and a string directions (directions[i] is either 'L' for left or 'R' for right). All integers in positions are unique.
# 
# All robots start moving on the line simultaneously at the same speed in their given directions. If two robots ever share the same position while moving, they will collide.
# 
# If two robots collide, the robot with lower health is removed from the line, and the health of the other robot decreases by one. The surviving robot continues in the same direction it was going. If both robots have the same health, they are both removed from the line.
# 
# Your task is to determine the health of the robots that survive the collisions, in the same order that the robots were given, i.e. final heath of robot 1 (if survived), final health of robot 2 (if survived), and so on. If there are no survivors, return an empty array.
# 
# Return an array containing the health of the remaining robots (in the order they were given in the input), after no further collisions can occur.
# 
# Note: The positions may be unsorted.
# 
#  
#  
# 
# Example 1:
# 
# 
# 
# Input: positions = [5,4,3,2,1], healths = [2,17,9,15,10], directions = "RRRRR"
# Output: [2,17,9,15,10]
# Explanation: No collision occurs in this example, since all robots are moving in the same direction. So, the health of the robots in order from the first robot is returned, [2, 17, 9, 15, 10].
# Example 2:
# 
# 
# 
# Input: positions = [3,5,2,6], healths = [10,10,15,12], directions = "RLRL"
# Output: [14]
# Explanation: There are 2 collisions in this example. Firstly, robot 1 and robot 2 will collide, and since both have the same health, they will be removed from the line. Next, robot 3 and robot 4 will collide and since robot 4's health is smaller, it gets removed, and robot 3's health becomes 15 - 1 = 14. Only robot 3 remains, so we return [14].
# Example 3:
# 
# 
# 
# Input: positions = [1,2,5,6], healths = [10,10,11,11], directions = "RLRL"
# Output: []
# Explanation: Robot 1 and robot 2 will collide and since both have the same health, they are both removed. Robot 3 and 4 will collide and since both have the same health, they are both removed. So, we return an empty array, [].
#  
# 
# Constraints:
# 
# 1 <= positions.length == healths.length == directions.length == n <= 105
# 1 <= positions[i], healths[i] <= 109
# directions[i] == 'L' or directions[i] == 'R'
# All values in positions are distinct
class Solution:
    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:
        line: list[list[int]] = []
        for idx in range(len(positions)):
            line.append([idx + 1, positions[idx], healths[idx], directions[idx]])
        line.sort(key=lambda x: x[1])

        stack: list[list[int]] = []
        for robot in line:
            if not stack: stack.append(robot) # Case 1
            elif stack:
                if stack[-1][-1] == robot[-1]: # Case 2
                    stack.append(robot)
                    continue
                elif stack[-1][-1] == 'L' and robot[-1] == 'R': # Case 3
                    stack.append(robot)
                    continue
                while stack and stack[-1][-1] == 'R' and robot[-1] == 'L' and stack[-1][2] < robot[2]: # Case 4
                    stack.pop()
                    robot[2] -= 1
                if stack and stack[-1][-1] == 'R' and robot[-1] == 'L' and stack[-1][2] == robot[2]: # Case 4.1
                    stack.pop()
                elif stack and stack[-1][-1] == 'R' and robot[-1] == 'L' and stack[-1][2] > robot[2]: # Case 4.2
                    stack[-1][2] -= 1
                elif not stack or (stack and stack[-1][-1] == robot[-1]): # Case 4.3
                    stack.append(robot)

        stack.sort(key=lambda x: x[0])
        return [robot[2] for robot in stack]

# 735. Asteroid Collision
# We are given an array asteroids of integers representing asteroids in a row.
#
# For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.
#
# Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.
#
#
#
# Example 1:
#
# Input: asteroids = [5,10,-5]
# Output: [5,10]
# Explanation: The 10 and -5 collide resulting in 10. The 5 and 10 never collide.
# Example 2:
#
# Input: asteroids = [8,-8]
# Output: []
# Explanation: The 8 and -8 collide exploding each other.
# Example 3:
#
# Input: asteroids = [10,2,-5]
# Output: [10]
# Explanation: The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10.
#
#
# Constraints:
#
# 2 <= asteroids.length <= 104
# -1000 <= asteroids[i] <= 1000
# asteroids[i] != 0
class Solution:
    def asteroidCollision(self, asteroids: List[int]) -> List[int]:
        stack: list[int] = []
        for asteroid in asteroids:
            if not stack:
                stack.append(asteroid)
                continue
            elif not bool(stack[-1] > 0 and asteroid < 0):
                stack.append(asteroid)
                continue
            smashed_current: bool = False
            while stack and stack[-1] > 0 and asteroid < 0:
                if stack[-1] < abs(asteroid): stack.pop()
                elif stack[-1] > abs(asteroid):
                    smashed_current = True
                    break
                else:
                    smashed_current = True
                    stack.pop()
                    break
            if not smashed_current: stack.append(asteroid)
        return stack

# A. Games
# A. Games
# time limit per test1 second
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# Manao works on a sports TV. He's spent much time watching the football games of some country. After a while he began to notice different patterns. For example, each team has two sets of uniforms: home uniform and guest uniform. When a team plays a game at home, the players put on the home uniform. When a team plays as a guest on somebody else's stadium, the players put on the guest uniform. The only exception to that rule is: when the home uniform color of the host team matches the guests' uniform, the host team puts on its guest uniform as well. For each team the color of the home and guest uniform is different.
#
# There are n teams taking part in the national championship. The championship consists of n·(n - 1) games: each team invites each other team to its stadium. At this point Manao wondered: how many times during the championship is a host team going to put on the guest uniform? Note that the order of the games does not affect this number.
#
# You know the colors of the home and guest uniform for each team. For simplicity, the colors are numbered by integers in such a way that no two distinct colors have the same number. Help Manao find the answer to his question.
#
# Input
# The first line contains an integer n (2 ≤ n ≤ 30). Each of the following n lines contains a pair of distinct space-separated integers hi, ai (1 ≤ hi, ai ≤ 100) — the colors of the i-th team's home and guest uniforms, respectively.
#
# Output
# In a single line print the number of games where the host team is going to play in the guest uniform.
#
# Examples
# inputCopy
# 3
# 1 2
# 2 4
# 3 4
# outputCopy
# 1
# inputCopy
# 4
# 100 42
# 42 100
# 5 42
# 100 5
# outputCopy
# 5
# inputCopy
# 2
# 1 2
# 1 2
# outputCopy
# 0
# Note
# In the first test case the championship consists of 6 games. The only game with the event in question is the game between teams 2 and 1 on the stadium of team 2.
#
# In the second test sample the host team will have to wear guest uniform in the games between teams: 1 and 2, 2 and 1, 2 and 3, 3 and 4, 4 and 2 (the host team is written first).
import sys


def solution(n: int, colors: list) -> str:
    times: int = 0
    for first_team in range(n):
        for second_team in range(n):
            if first_team == second_team: continue
            if colors[first_team][0] == colors[second_team][1]:
                times += 1
    return str(times)


if __name__ == '__main__':
    n: int = int(sys.stdin.readline().rstrip())
    colors: list = [list(map(int, sys.stdin.readline().rstrip().split())) for _ in range(n)]
    sys.stdout.write(solution(n, colors))


# Fun with trees: array to tree
# You are given an array of integers. Implement a function which creates a complete binary tree from the array (complete meaning that every level of the tree, except possibly the last, is completely filled).
#
# The elements of the array are to be taken left-to-right, and put into the tree top-to-bottom, left-to-right.
#
# For example, given the array [17, 0, -4, 3, 15] you should create the following tree:
#
#     17
#    /  \
#   0   -4
#  / \
# 3   15
# A tree node type is preloaded for you:
#
# class Node:
#     def __init__(self, value, left=None, right=None):
#         self.value = value
#         self.left = left
#         self.right = right
# This kata is part of fun with trees series:
#
# Fun with trees: max sum
# Fun with trees: array to tree
# Fun with trees: is perfect
# TREESARRAYSBINARY TREESDATA STRUCTURESALGORITHMS
from preloaded import Node


def array_to_tree(arr):
    if not arr: return None
    head = Node(arr[0])
    current_nodes: list = [head]
    next_nodes: list = []
    idx: int = 1
    while idx < len(arr):
        for node in current_nodes:
            if idx < len(arr):
                node.left = Node(arr[idx])
                next_nodes.append(node.left)
                idx += 1
            if idx < len(arr):
                node.right = Node(arr[idx])
                next_nodes.append(node.right)
                idx += 1
        current_nodes = next_nodes
        next_nodes = []
    return head

# 2161. Partition Array According to Given Pivot
# You are given a 0-indexed integer array nums and an integer pivot. Rearrange nums such that the following conditions are satisfied:
# 
# Every element less than pivot appears before every element greater than pivot.
# Every element equal to pivot appears in between the elements less than and greater than pivot.
# The relative order of the elements less than pivot and the elements greater than pivot is maintained.
# More formally, consider every pi, pj where pi is the new position of the ith element and pj is the new position of the jth element. For elements less than pivot, if i < j and nums[i] < pivot and nums[j] < pivot, then pi < pj. Similarly for elements greater than pivot, if i < j and nums[i] > pivot and nums[j] > pivot, then pi < pj.
# Return nums after the rearrangement.
# 
#  
# 
# Example 1:
# 
# Input: nums = [9,12,5,10,14,3,10], pivot = 10
# Output: [9,5,3,10,10,12,14]
# Explanation: 
# The elements 9, 5, and 3 are less than the pivot so they are on the left side of the array.
# The elements 12 and 14 are greater than the pivot so they are on the right side of the array.
# The relative ordering of the elements less than and greater than pivot is also maintained. [9, 5, 3] and [12, 14] are the respective orderings.
# Example 2:
# 
# Input: nums = [-3,4,3,2], pivot = 2
# Output: [-3,2,4,3]
# Explanation: 
# The element -3 is less than the pivot so it is on the left side of the array.
# The elements 4 and 3 are greater than the pivot so they are on the right side of the array.
# The relative ordering of the elements less than and greater than pivot is also maintained. [-3] and [4, 3] are the respective orderings.
#  
# 
# Constraints:
# 
# 1 <= nums.length <= 105
# -106 <= nums[i] <= 106
# pivot equals to an element of nums.
class Solution:
    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:
        less_than_pivot: list[int] = []
        equals_to_pivot: list[int] = []
        more_than_pivot: list[int] = []
        for num in nums:
            if num < pivot:
                less_than_pivot.append(num)
            elif num > pivot:
                more_than_pivot.append(num)
            else:
                equals_to_pivot.append(num)
        return less_than_pivot + equals_to_pivot + more_than_pivot

# 1409. Queries on a Permutation With Key
# Given the array queries of positive integers between 1 and m, you have to process all queries[i] (from i=0 to i=queries.length-1) according to the following rules:
# 
# In the beginning, you have the permutation P=[1,2,3,...,m].
# For the current i, find the position of queries[i] in the permutation P (indexing from 0) and then move this at the beginning of the permutation P. Notice that the position of queries[i] in P is the result for queries[i].
# Return an array containing the result for the given queries.
# 
#  
# 
# Example 1:
# 
# Input: queries = [3,1,2,1], m = 5
# Output: [2,1,2,1] 
# Explanation: The queries are processed as follow: 
# For i=0: queries[i]=3, P=[1,2,3,4,5], position of 3 in P is 2, then we move 3 to the beginning of P resulting in P=[3,1,2,4,5]. 
# For i=1: queries[i]=1, P=[3,1,2,4,5], position of 1 in P is 1, then we move 1 to the beginning of P resulting in P=[1,3,2,4,5]. 
# For i=2: queries[i]=2, P=[1,3,2,4,5], position of 2 in P is 2, then we move 2 to the beginning of P resulting in P=[2,1,3,4,5]. 
# For i=3: queries[i]=1, P=[2,1,3,4,5], position of 1 in P is 1, then we move 1 to the beginning of P resulting in P=[1,2,3,4,5]. 
# Therefore, the array containing the result is [2,1,2,1].  
# Example 2:
# 
# Input: queries = [4,1,2,2], m = 4
# Output: [3,1,2,0]
# Example 3:
# 
# Input: queries = [7,5,5,8,3], m = 8
# Output: [6,5,0,7,5]
#  
# 
# Constraints:
# 
# 1 <= m <= 10^3
# 1 <= queries.length <= m
# 1 <= queries[i] <= m
class Solution:
    def processQueries(self, queries: List[int], m: int) -> List[int]:
        output: list[int] = []
        diapazone: list[int] = list(range(1, m + 1))
        for query in queries:
            idx: int = diapazone.index(query)
            output.append(idx)
            diapazone.pop(idx)
            diapazone = [query] + diapazone
        return output

# 3216. Lexicographically Smallest String After a Swap
# Given a string s containing only digits, return the 
# lexicographically smallest string
#  that can be obtained after swapping adjacent digits in s with the same parity at most once.
# 
# Digits have the same parity if both are odd or both are even. For example, 5 and 9, as well as 2 and 4, have the same parity, while 6 and 9 do not.
# 
#  
# 
# Example 1:
# 
# Input: s = "45320"
# 
# Output: "43520"
# 
# Explanation:
# 
# s[1] == '5' and s[2] == '3' both have the same parity, and swapping them results in the lexicographically smallest string.
# 
# Example 2:
# 
# Input: s = "001"
# 
# Output: "001"
# 
# Explanation:
# 
# There is no need to perform a swap because s is already the lexicographically smallest.
# 
#  
# 
# Constraints:
# 
# 2 <= s.length <= 100
# s consists only of digits.
class Solution:
    def getSmallestString(self, s: str) -> str:
        output: list[str] = list(s)
        for idx in range(len(output) - 1):
            x, y = output[idx], output[idx + 1]
            if int(x) & 1 == int(y) & 1 == 1 and x > y:
                output[idx], output[idx + 1] = output[idx + 1], output[idx]
                break
            elif int(x) & 1 == int(y) & 1 == 0 and x > y:
                output[idx], output[idx + 1] = output[idx + 1], output[idx]
                break
        return ''.join(output)
        
# 3217. Delete Nodes From Linked List Present in Array
# You are given an array of integers nums and the head of a linked list. Return the head of the modified linked list after removing all nodes from the linked list that have a value that exists in nums.
#
#
#
# Example 1:
#
# Input: nums = [1,2,3], head = [1,2,3,4,5]
#
# Output: [4,5]
#
# Explanation:
#
#
#
# Remove the nodes with values 1, 2, and 3.
#
# Example 2:
#
# Input: nums = [1], head = [1,2,1,2,1,2]
#
# Output: [2,2,2]
#
# Explanation:
#
#
#
# Remove the nodes with value 1.
#
# Example 3:
#
# Input: nums = [5], head = [1,2,3,4]
#
# Output: [1,2,3,4]
#
# Explanation:
#
#
#
# No node has value 5.
#
#
#
# Constraints:
#
# 1 <= nums.length <= 105
# 1 <= nums[i] <= 105
# All elements in nums are unique.
# The number of nodes in the given list is in the range [1, 105].
# 1 <= Node.val <= 105
# The input is generated such that there is at least one node in the linked list that has a value not present in nums.
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def modifiedList(self, nums: List[int], head: Optional[ListNode]) -> Optional[ListNode]:
        to_delete: set[int] = set(nums)
        tmp = head
        while tmp:
            if head and head.val in to_delete:
                head = head.next
                tmp = head
            elif tmp.next and tmp.next.val in to_delete:
                tmp.next = tmp.next.next
            else:
                tmp = tmp.next
        return head
        
# 3218. Minimum Cost for Cutting Cake I
# There is an m x n cake that needs to be cut into 1 x 1 pieces.
# 
# You are given integers m, n, and two arrays:
# 
# horizontalCut of size m - 1, where horizontalCut[i] represents the cost to cut along the horizontal line i.
# verticalCut of size n - 1, where verticalCut[j] represents the cost to cut along the vertical line j.
# In one operation, you can choose any piece of cake that is not yet a 1 x 1 square and perform one of the following cuts:
# 
# Cut along a horizontal line i at a cost of horizontalCut[i].
# Cut along a vertical line j at a cost of verticalCut[j].
# After the cut, the piece of cake is divided into two distinct pieces.
# 
# The cost of a cut depends only on the initial cost of the line and does not change.
# 
# Return the minimum total cost to cut the entire cake into 1 x 1 pieces.
# 
#  
# 
# Example 1:
# 
# Input: m = 3, n = 2, horizontalCut = [1,3], verticalCut = [5]
# 
# Output: 13
# 
# Explanation:
# 
# 
# 
# Perform a cut on the vertical line 0 with cost 5, current total cost is 5.
# Perform a cut on the horizontal line 0 on 3 x 1 subgrid with cost 1.
# Perform a cut on the horizontal line 0 on 3 x 1 subgrid with cost 1.
# Perform a cut on the horizontal line 1 on 2 x 1 subgrid with cost 3.
# Perform a cut on the horizontal line 1 on 2 x 1 subgrid with cost 3.
# The total cost is 5 + 1 + 1 + 3 + 3 = 13.
# 
# Example 2:
# 
# Input: m = 2, n = 2, horizontalCut = [7], verticalCut = [4]
# 
# Output: 15
# 
# Explanation:
# 
# Perform a cut on the horizontal line 0 with cost 7.
# Perform a cut on the vertical line 0 on 1 x 2 subgrid with cost 4.
# Perform a cut on the vertical line 0 on 1 x 2 subgrid with cost 4.
# The total cost is 7 + 4 + 4 = 15.
# 
#  
# 
# Constraints:
# 
# 1 <= m, n <= 20
# horizontalCut.length == m - 1
# verticalCut.length == n - 1
# 1 <= horizontalCut[i], verticalCut[i] <= 103
# Time complexity: O((M + N)log(N+M)), that simplify equal to O(NlogN)
# Space complexity: O(M + N) == O(N)
# Code
import heapq
class Solution:
    def minimumCost(self, m: int, n: int, horizontalCut: List[int], verticalCut: List[int]) -> int:
        horizontalCut.sort(reverse=True)
        verticalCut.sort(reverse=True)
        h_pieces = v_pieces = 1
        total_cost: int = 0
        pq = []
        for cost in horizontalCut:
            heapq.heappush(pq, (-cost, 'H'))
        for cost in verticalCut:
            heapq.heappush(pq, (-cost, 'V'))
        while pq:
            cost, cut_type = heapq.heappop(pq)
            cost *= -1
            if cut_type == 'H':
                total_cost += cost * v_pieces
                h_pieces += 1
            else:
                total_cost += cost * h_pieces
                v_pieces += 1

        return total_cost

# 3219. Minimum Cost for Cutting Cake II
# There is an m x n cake that needs to be cut into 1 x 1 pieces.
# 
# You are given integers m, n, and two arrays:
# 
# horizontalCut of size m - 1, where horizontalCut[i] represents the cost to cut along the horizontal line i.
# verticalCut of size n - 1, where verticalCut[j] represents the cost to cut along the vertical line j.
# In one operation, you can choose any piece of cake that is not yet a 1 x 1 square and perform one of the following cuts:
# 
# Cut along a horizontal line i at a cost of horizontalCut[i].
# Cut along a vertical line j at a cost of verticalCut[j].
# After the cut, the piece of cake is divided into two distinct pieces.
# 
# The cost of a cut depends only on the initial cost of the line and does not change.
# 
# Return the minimum total cost to cut the entire cake into 1 x 1 pieces.
# 
#  
# 
# Example 1:
# 
# Input: m = 3, n = 2, horizontalCut = [1,3], verticalCut = [5]
# 
# Output: 13
# 
# Explanation:
# 
# 
# 
# Perform a cut on the vertical line 0 with cost 5, current total cost is 5.
# Perform a cut on the horizontal line 0 on 3 x 1 subgrid with cost 1.
# Perform a cut on the horizontal line 0 on 3 x 1 subgrid with cost 1.
# Perform a cut on the horizontal line 1 on 2 x 1 subgrid with cost 3.
# Perform a cut on the horizontal line 1 on 2 x 1 subgrid with cost 3.
# The total cost is 5 + 1 + 1 + 3 + 3 = 13.
# 
# Example 2:
# 
# Input: m = 2, n = 2, horizontalCut = [7], verticalCut = [4]
# 
# Output: 15
# 
# Explanation:
# 
# Perform a cut on the horizontal line 0 with cost 7.
# Perform a cut on the vertical line 0 on 1 x 2 subgrid with cost 4.
# Perform a cut on the vertical line 0 on 1 x 2 subgrid with cost 4.
# The total cost is 7 + 4 + 4 = 15.
# 
#  
# 
# Constraints:
# 
# 1 <= m, n <= 105
# horizontalCut.length == m - 1
# verticalCut.length == n - 1
# 1 <= horizontalCut[i], verticalCut[i] <= 103
# Time complexity: O((M + N)log(M + N)), that simplify to O(NlogN)
# Space complexity: O(M + N) == O(N)
# Code
import heapq
class Solution:
    def minimumCost(self, m: int, n: int, horizontalCut: List[int], verticalCut: List[int]) -> int:
        horizontalCut.sort(reverse=True)
        verticalCut.sort(reverse=True)
        h_pieces = v_pieces = 1
        total_cost: int = 0
        pq = []
        for cost in horizontalCut:
            heapq.heappush(pq, (-cost, 'H'))
        for cost in verticalCut:
            heapq.heappush(pq, (-cost, 'V'))
        while pq:
            cost, cut_type = heapq.heappop(pq)
            cost *= -1
            if cut_type == 'H':
                total_cost += cost * v_pieces
                h_pieces += 1
            else:
                total_cost += cost * h_pieces
                v_pieces += 1

        return total_cost

# 726. Number of Atoms
# Given a string formula representing a chemical formula, return the count of each atom.
# 
# The atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.
# 
# One or more digits representing that element's count may follow if the count is greater than 1. If the count is 1, no digits will follow.
# 
# For example, "H2O" and "H2O2" are possible, but "H1O2" is impossible.
# Two formulas are concatenated together to produce another formula.
# 
# For example, "H2O2He3Mg4" is also a formula.
# A formula placed in parentheses, and a count (optionally added) is also a formula.
# 
# For example, "(H2O2)" and "(H2O2)3" are formulas.
# Return the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on.
# 
# The test cases are generated so that all the values in the output fit in a 32-bit integer.
# 
#  
# 
# Example 1:
# 
# Input: formula = "H2O"
# Output: "H2O"
# Explanation: The count of elements are {'H': 2, 'O': 1}.
# Example 2:
# 
# Input: formula = "Mg(OH)2"
# Output: "H2MgO2"
# Explanation: The count of elements are {'H': 2, 'Mg': 1, 'O': 2}.
# Example 3:
# 
# Input: formula = "K4(ON(SO3)2)2"
# Output: "K4N2O14S4"
# Explanation: The count of elements are {'K': 4, 'N': 2, 'O': 14, 'S': 4}.
#  
# 
# Constraints:
# 
# 1 <= formula.length <= 1000
# formula consists of English letters, digits, '(', and ')'.
# formula is always valid.
from collections import defaultdict


class Solution:
    current_atom: str = ''
    current_points: int = 0

    def add_atom(self, current_group: dict[str, int]) -> None:
        current_group[self.current_atom] += self.current_points if self.current_points else 1
        self.current_atom = ''
        self.current_points = 0

    def extend_groups(self, current_group: dict[str, int], prev_group: dict[str, int]) -> None:
        for atom in prev_group:
            current_group[atom] += prev_group[atom]

    def countOfAtoms(self, formula: str) -> str:
        atoms: dict[str, int] = defaultdict(int)
        stack: list[dict[str, int]] = []

        idx: int = 0
        while idx < len(formula):
            if formula[idx].islower():
                self.current_atom += formula[idx]
                idx += 1

            elif formula[idx].isupper():
                if self.current_atom: self.add_atom(atoms)
                self.current_atom = formula[idx]
                idx += 1

            elif formula[idx] == '(':
                if self.current_atom: self.add_atom(atoms)

                stack.append(atoms)
                atoms = defaultdict(int)
                idx += 1

            elif formula[idx] == ')':
                if self.current_atom: self.add_atom(atoms)

                idx += 1
                while idx < len(formula) and formula[idx].isdigit():
                    self.current_points = self.current_points * 10 + int(formula[idx])
                    idx += 1
                self.current_points = max(self.current_points, 1)

                for atom in atoms:
                    atoms[atom] = self.current_points * atoms[atom]
                self.current_points = 0

                if stack: self.extend_groups(atoms, stack.pop())

            elif formula[idx].isdigit():
                self.current_points = self.current_points * 10 + int(formula[idx])
                idx += 1

        if self.current_atom: self.add_atom(atoms)

        while stack:
            self.extend_groups(atoms, stack.pop())

        return ''.join(f'{atom}{atoms[atom] if atoms[atom] > 1 else ""}' for atom in sorted(atoms))

# A. IQ test
# A. IQ test
# time limit per test2 seconds
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# Bob is preparing to pass IQ test. The most frequent task in this test is to find out which one of the given n numbers differs from the others. Bob observed that one number usually differs from the others in evenness. Help Bob — to check his answers, he needs a program that among the given n numbers finds one that is different in evenness.
# 
# Input
# The first line contains integer n (3 ≤ n ≤ 100) — amount of numbers in the task. The second line contains n space-separated natural numbers, not exceeding 100. It is guaranteed, that exactly one of these numbers differs from the others in evenness.
# 
# Output
# Output index of number that differs from the others in evenness. Numbers are numbered from 1 in the input order.
# 
# Examples
# inputCopy
# 5
# 2 4 7 8 10
# outputCopy
# 3
# inputCopy
# 4
# 1 2 1 1
# outputCopy
# 2
import sys


def solution(n: int, numbers: list) -> str:
    eveness: int = (numbers[0] & 1) + (numbers[1] & 1) + (numbers[2] & 1)
    odd: bool = eveness >= 2
    for idx in range(n):
        if bool(numbers[idx] & 1) != odd: return str(idx + 1)


if __name__ == '__main__':
    n: int = int(sys.stdin.readline().rstrip())
    numbers: list = list(map(int, sys.stdin.readline().rstrip().split()))
    sys.stdout.write(solution(n, numbers))

# Molecule to atoms
# For a given chemical formula represented by a string, count the number of atoms of each element contained in the molecule and return an object (associative array in PHP, Dictionary<string, int> in C#, Map<String,Integer> in Java).
# 
# For example:
# 
# water = 'H2O'
# parse_molecule(water)                 # return {H: 2, O: 1}
# 
# magnesium_hydroxide = 'Mg(OH)2'
# parse_molecule(magnesium_hydroxide)   # return {Mg: 1, O: 2, H: 2}
# 
# var fremy_salt = 'K4[ON(SO3)2]2'
# parse_molecule(fremySalt)             # return {K: 4, O: 14, N: 2, S: 4}
# As you can see, some formulas have brackets in them. The index outside the brackets tells you that you have to multiply count of each atom inside the bracket on this index. For example, in Fe(NO3)2 you have one iron atom, two nitrogen atoms and six oxygen atoms.
# 
# Note that brackets may be round, square or curly and can also be nested. Index after the braces is optional.
# 
# PARSINGALGORITHMSSTRINGS
from collections import defaultdict


class Solution:
    current_atom: str = ''
    current_points: int = 0

    def add_atom(self, current_group: dict[str, int]) -> None:
        current_group[self.current_atom] += self.current_points if self.current_points else 1
        self.current_atom = ''
        self.current_points = 0

    def extend_groups(self, current_group: dict[str, int], prev_group: dict[str, int]) -> None:
        for atom in prev_group:
            current_group[atom] += prev_group[atom]

    def countOfAtoms(self, formula: str) -> str:
        print(formula)
        atoms: dict[str, int] = defaultdict(int)
        stack: list[dict[str, int]] = []

        idx: int = 0
        while idx < len(formula):
            if formula[idx].islower():
                self.current_atom += formula[idx]
                idx += 1

            elif formula[idx].isupper():
                if self.current_atom: self.add_atom(atoms)
                self.current_atom = formula[idx]
                idx += 1

            elif formula[idx] in '{[(':
                if self.current_atom: self.add_atom(atoms)

                stack.append(atoms)
                atoms = defaultdict(int)
                idx += 1

            elif formula[idx] in '}])':
                if self.current_atom: self.add_atom(atoms)

                idx += 1
                while idx < len(formula) and formula[idx].isdigit():
                    self.current_points = self.current_points * 10 + int(formula[idx])
                    idx += 1
                self.current_points = max(self.current_points, 1)

                for atom in atoms:
                    atoms[atom] = self.current_points * atoms[atom]
                self.current_points = 0

                if stack: self.extend_groups(atoms, stack.pop())

            elif formula[idx].isdigit():
                self.current_points = self.current_points * 10 + int(formula[idx])
                idx += 1

        if self.current_atom: self.add_atom(atoms)

        while stack:
            self.extend_groups(atoms, stack.pop())

        return atoms


def parse_molecule(formula):
    return Solution().countOfAtoms(formula)

# 2810. Faulty Keyboard
# Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.
# 
# You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.
# 
# Return the final string that will be present on your laptop screen.
# 
#  
# 
# Example 1:
# 
# Input: s = "string"
# Output: "rtsng"
# Explanation: 
# After typing first character, the text on the screen is "s".
# After the second character, the text is "st". 
# After the third character, the text is "str".
# Since the fourth character is an 'i', the text gets reversed and becomes "rts".
# After the fifth character, the text is "rtsn". 
# After the sixth character, the text is "rtsng". 
# Therefore, we return "rtsng".
# Example 2:
# 
# Input: s = "poiinter"
# Output: "ponter"
# Explanation: 
# After the first character, the text on the screen is "p".
# After the second character, the text is "po". 
# Since the third character you type is an 'i', the text gets reversed and becomes "op". 
# Since the fourth character you type is an 'i', the text gets reversed and becomes "po".
# After the fifth character, the text is "pon".
# After the sixth character, the text is "pont". 
# After the seventh character, the text is "ponte". 
# After the eighth character, the text is "ponter". 
# Therefore, we return "ponter".
#  
# 
# Constraints:
# 
# 1 <= s.length <= 100
# s consists of lowercase English letters.
# s[0] != 'i'
# Solutions
# Simulation with reversing
# Complexity
# Time complexity: O(N**2)
# Space complexity: O(N)
# Code
class Solution:
    def finalString(self, s: str) -> str:
        current_string: list[str] = []
        for char in s:
            if char == 'i': current_string = current_string[::-1]
            else: current_string.append(char)
        return ''.join(current_string)

# Bit Manipulation
# Complexity
# Time complexity: O(N)
# Space complexity: O(N)
# Code
from collections import deque
class Solution:
    def finalString(self, s: str) -> str:
        current_string = deque()
        reverse_time: int = s.count('i') & 1
        for char in s:
            if char == 'i': reverse_time ^= 1
            else: current_string.appendleft(char) if reverse_time else current_string.append(char)
        return ''.join(current_string)

# 1630. Arithmetic Subarrays
# A sequence of numbers is called arithmetic if it consists of at least two elements, and the difference between every two consecutive elements is the same. More formally, a sequence s is arithmetic if and only if s[i+1] - s[i] == s[1] - s[0] for all valid i.
# 
# For example, these are arithmetic sequences:
# 
# 1, 3, 5, 7, 9
# 7, 7, 7, 7
# 3, -1, -5, -9
# The following sequence is not arithmetic:
# 
# 1, 1, 2, 5, 7
# You are given an array of n integers, nums, and two arrays of m integers each, l and r, representing the m range queries, where the ith query is the range [l[i], r[i]]. All the arrays are 0-indexed.
# 
# Return a list of boolean elements answer, where answer[i] is true if the subarray nums[l[i]], nums[l[i]+1], ... , nums[r[i]] can be rearranged to form an arithmetic sequence, and false otherwise.
# 
#  
# 
# Example 1:
# 
# Input: nums = [4,6,5,9,3,7], l = [0,0,2], r = [2,3,5]
# Output: [true,false,true]
# Explanation:
# In the 0th query, the subarray is [4,6,5]. This can be rearranged as [6,5,4], which is an arithmetic sequence.
# In the 1st query, the subarray is [4,6,5,9]. This cannot be rearranged as an arithmetic sequence.
# In the 2nd query, the subarray is [5,9,3,7]. This can be rearranged as [3,5,7,9], which is an arithmetic sequence.
# Example 2:
# 
# Input: nums = [-12,-9,-3,-12,-6,15,20,-25,-20,-15,-10], l = [0,1,6,4,8,7], r = [4,4,9,7,9,10]
# Output: [false,true,false,false,true,true]
#  
# 
# Constraints:
# 
# n == nums.length
# m == l.length
# m == r.length
# 2 <= n <= 500
# 1 <= m <= 500
# 0 <= l[i] < r[i] < n
# -105 <= nums[i] <= 105
# Sorting
# Complexity
# Time complexity: O(N**2 * log(N))
# Space complexity: O(N)
# Code
class Solution:
    def checkArithmeticSubarrays(self, nums: List[int], l: List[int], r: List[int]) -> List[bool]:
        output: list[bool] = []
        for idx in range(len(l)):
            d: int = None
            invalid: bool = False
            inner_range = sorted(nums[l[idx]:r[idx] + 1])
            for x, y in zip(inner_range, inner_range[1:]):
                if d is None:
                    d = y - x
                elif y - x != d:
                    invalid = True
                    output.append(False)
                    break
            if not invalid: output.append(True)
        return output

# Without sorting, by arithmetic properties
# Complexity
# Time complexity: O(N**2)
# Space complexity: O(N)
# Code
class Solution:
    def check(self, sequence: list[int]) -> bool:
        min_el: int = min(sequence)
        max_el: int = max(sequence)
        if (max_el - min_el) % (len(sequence) - 1) != 0: return False
        diff: int = (max_el - min_el) / (len(sequence) - 1)
        storage: set[int] = set(sequence)
        current_el: int = min_el + diff
        while current_el < max_el:
            if current_el not in storage: return False
            current_el += diff
        return True

    def checkArithmeticSubarrays(self, nums: List[int], l: List[int], r: List[int]) -> List[bool]:
        output: list[bool] = []
        for idx in range(len(l)):
            output.append(self.check(nums[l[idx]:r[idx] + 1]))
        return output

# A. cAPS lOCK
# A. cAPS lOCK
# time limit per test0.5 second
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# wHAT DO WE NEED cAPS LOCK FOR?
# 
# Caps lock is a computer keyboard key. Pressing it sets an input mode in which typed letters are capital by default. If it is pressed by accident, it leads to accidents like the one we had in the first passage.
# 
# Let's consider that a word has been typed with the Caps lock key accidentally switched on, if:
# 
# either it only contains uppercase letters;
# or all letters except for the first one are uppercase.
# In this case we should automatically change the case of all letters. For example, the case of the letters that form words "hELLO", "HTTP", "z" should be changed.
# 
# Write a program that applies the rule mentioned above. If the rule cannot be applied, the program should leave the word unchanged.
# 
# Input
# The first line of the input data contains a word consisting of uppercase and lowercase Latin letters. The word's length is from 1 to 100 characters, inclusive.
# 
# Output
# Print the result of the given word's processing.
# 
# Examples
# inputCopy
# cAPS
# outputCopy
# Caps
# inputCopy
# Lock
# outputCopy
# Lock
import sys


def solution(n: str) -> str:
    if all(char.isupper() for char in n) or (n[0].islower and all(char.isupper() for char in n[1:])):
        return ''.join(i.lower() if i.isupper() else i.upper() for i in n)
    return n


if __name__ == '__main__':
    n: str = sys.stdin.readline().rstrip()
    sys.stdout.write(solution(n))
    
# 2196. Create Binary Tree From Descriptions
# You are given a 2D integer array descriptions where descriptions[i] = [parenti, childi, isLefti] indicates that parenti is the parent of childi in a binary tree of unique values. Furthermore,
# 
# If isLefti == 1, then childi is the left child of parenti.
# If isLefti == 0, then childi is the right child of parenti.
# Construct the binary tree described by descriptions and return its root.
# 
# The test cases will be generated such that the binary tree is valid.
# 
#  
# 
# Example 1:
# 
# 
# Input: descriptions = [[20,15,1],[20,17,0],[50,20,1],[50,80,0],[80,19,1]]
# Output: [50,20,80,15,17,19]
# Explanation: The root node is the node with value 50 since it has no parent.
# The resulting binary tree is shown in the diagram.
# Example 2:
# 
# 
# Input: descriptions = [[1,2,1],[2,3,0],[3,4,1]]
# Output: [1,2,null,null,3,4]
# Explanation: The root node is the node with value 1 since it has no parent.
# The resulting binary tree is shown in the diagram.
#  
# 
# Constraints:
# 
# 1 <= descriptions.length <= 104
# descriptions[i].length == 3
# 1 <= parenti, childi <= 105
# 0 <= isLefti <= 1
# The binary tree described by descriptions is valid.
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:
        heads: dict[int, TreeNode] = dict()
        childs: set[int] = set()
        for path in descriptions:
            current_head = TreeNode(path[0]) if path[0] not in heads else heads[path[0]]
            current_child = heads[path[1]] if path[1] in heads else TreeNode(path[1])
            if path[2]:
                current_head.left = current_child
            else:
                current_head.right = current_child

            heads[current_child.val] = current_child
            heads[current_head.val] = current_head
            childs.add(current_child.val)

        for node in heads:
            if node not in childs:
                return heads[node]

# Simple Fun #97: Video Part
# Task
# You have been watching a video for some time. Knowing the total video duration find out what portion of the video you have already watched.
# 
# Example
# For part = "02:20:00" and total = "07:00:00", the output should be [1, 3].
# 
# You have watched 1 / 3 of the whole video.
# 
# Input/Output
# [input] string part
# 
# A string of the following format "hh:mm:ss" representing the time you have been watching the video.
# 
# [input] string total
# 
# A string of the following format "hh:mm:ss" representing the total video duration.
# 
# [output] an integer array
# 
# An array of the following format [a, b] (where a / b is a reduced fraction).
# 
# PUZZLES
from math import gcd
def video_part(part, total):
    ch, cm, cs = map(int, part.split(':'))
    th, tm, ts = map(int, total.split(':'))
    x = th * 3600 + tm * 60 + ts
    y = ch * 3600 + cm * 60 + cs
    d = gcd(x, y)
    return [y // d, x // d]

# 108. Convert Sorted Array to Binary Search Tree
# Given an integer array nums where the elements are sorted in ascending order, convert it to a 
# height-balanced
#  binary search tree.
# 
#  
# 
# Example 1:
# 
# 
# Input: nums = [-10,-3,0,5,9]
# Output: [0,-3,9,-10,null,5]
# Explanation: [0,-10,5,null,-3,null,9] is also accepted:
# 
# Example 2:
# 
# 
# Input: nums = [1,3]
# Output: [3,1]
# Explanation: [1,null,3] and [3,1] are both height-balanced BSTs.
#  
# 
# Constraints:
# 
# 1 <= nums.length <= 104
# -104 <= nums[i] <= 104
# nums is sorted in a strictly increasing order.
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def construct(self, arr: list[int], left: int, right: int) -> Optional[TreeNode]:
        if left > right: return
        middle: int = (right + left) >> 1
        left_subtree = self.construct(arr, left, middle - 1)
        right_subtree = self.construct(arr, middle + 1, right)
        return TreeNode(arr[middle], left_subtree, right_subtree)

    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        return self.construct(nums, 0, len(nums) - 1)

# A. Candies and Two Sisters
# A. Candies and Two Sisters
# time limit per test1 second
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# There are two sisters Alice and Betty. You have n
#  candies. You want to distribute these n
#  candies between two sisters in such a way that:
# 
# Alice will get a
#  (a>0
# ) candies;
# Betty will get b
#  (b>0
# ) candies;
# each sister will get some integer number of candies;
# Alice will get a greater amount of candies than Betty (i.e. a>b
# );
# all the candies will be given to one of two sisters (i.e. a+b=n
# ).
# Your task is to calculate the number of ways to distribute exactly n
#  candies between sisters in a way described above. Candies are indistinguishable.
# 
# Formally, find the number of ways to represent n
#  as the sum of n=a+b
# , where a
#  and b
#  are positive integers and a>b
# .
# 
# You have to answer t
#  independent test cases.
# 
# Input
# The first line of the input contains one integer t
#  (1≤t≤104
# ) — the number of test cases. Then t
#  test cases follow.
# 
# The only line of a test case contains one integer n
#  (1≤n≤2⋅109
# ) — the number of candies you have.
# 
# Output
# For each test case, print the answer — the number of ways to distribute exactly n
#  candies between two sisters in a way described in the problem statement. If there is no way to satisfy all the conditions, print 0
# .
# 
# Example
# inputCopy
# 6
# 7
# 1
# 2
# 3
# 2000000000
# 763243547
# outputCopy
# 3
# 0
# 0
# 1
# 999999999
# 381621773
# Note
# For the test case of the example, the 3
#  possible ways to distribute candies are:
# 
# a=6
# , b=1
# ;
# a=5
# , b=2
# ;
# a=4
# , b=3
# .
import sys


def solution(t: int) -> None:
    for _ in range(t):
        n: int = int(sys.stdin.readline().rstrip())
        print(n - (n // 2 + 1))


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)

# Recaman Sequence
# Return the nth term of the Recamán's sequence.
#
# a(0) = 0;
#
#         a(n-1) - n, if this value is positive and not yet in the sequence
#       /
# a(n) <
#       \
#         a(n-1) + n, otherwise
# input range: 0 – 30 000
#
# Numberphile video about Recamán's sequence
#
# ALGORITHMSPERFORMANCE
def recaman(n):
    sequence = [0]
    seen = {0}

    for i in range(1, n + 1):
        previous = sequence[-1]
        potential = previous - i

        if potential > 0 and potential not in seen:
            sequence.append(potential)
            seen.add(potential)
        else:
            sequence.append(previous + i)
            seen.add(previous + i)

    return sequence[n]

# 2096. Step-By-Step Directions From a Binary Tree Node to Another
# You are given the root of a binary tree with n nodes. Each node is uniquely assigned a value from 1 to n. You are also given an integer startValue representing the value of the start node s, and a different integer destValue representing the value of the destination node t.
# 
# Find the shortest path starting from node s and ending at node t. Generate step-by-step directions of such path as a string consisting of only the uppercase letters 'L', 'R', and 'U'. Each letter indicates a specific direction:
# 
# 'L' means to go from a node to its left child node.
# 'R' means to go from a node to its right child node.
# 'U' means to go from a node to its parent node.
# Return the step-by-step directions of the shortest path from node s to node t.
# 
#  
# 
# Example 1:
# 
# 
# Input: root = [5,1,2,3,null,6,4], startValue = 3, destValue = 6
# Output: "UURL"
# Explanation: The shortest path is: 3 → 1 → 5 → 2 → 6.
# Example 2:
# 
# 
# Input: root = [2,1], startValue = 2, destValue = 1
# Output: "L"
# Explanation: The shortest path is: 2 → 1.
#  
# 
# Constraints:
# 
# The number of nodes in the tree is n.
# 2 <= n <= 105
# 1 <= Node.val <= n
# All the values in the tree are unique.
# 1 <= startValue, destValue <= n
# startValue != destValue
# Iterative DFS
# Complexity
# Time complexity: O(N)
# Space complexity: O(N)
# Code
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def dfs(self, root, target):
        callstack: list = [(root, '')]
        while callstack:
            cur_node, path = callstack.pop()
            if cur_node.val == target:
                return path
            if cur_node.left:
                callstack.append((cur_node.left, path + 'L'))
            if cur_node.right:
                callstack.append((cur_node.right, path + 'R'))

    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:
        start: str = self.dfs(root, startValue)
        end: str = self.dfs(root, destValue)
        idx: int = 0
        while idx < len(start) and idx < len(end) and start[idx] == end[idx]:
            idx += 1
        return 'U' * len(start[idx:]) + end[idx:]

# Recursive DFS
# Complexity
# Time complexity: O(N)
# Space complexity: O(N)
# Code
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def dfs(self, root, target, path):
        if not root: return False
        elif root.val == target:
            return True

        path.append('L')
        if self.dfs(root.left, target, path):
            return True
        path.pop()

        path.append('R')
        if self.dfs(root.right, target, path):
            return True
        path.pop()

        return False

    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:
        path_to_start_node: list[str] = []
        self.dfs(root, startValue, path_to_start_node)
        path_to_end_node: list[str] = []
        self.dfs(root, destValue, path_to_end_node)
        idx: int = 0
        while (
            idx < len(path_to_start_node)
            and idx < len(path_to_end_node)
            and path_to_start_node[idx] == path_to_end_node[idx]
        ):
            idx += 1
        return 'U' * len(path_to_start_node[idx:]) + ''.join(path_to_end_node[idx:])
        
# 1110. Delete Nodes And Return Forest
# Given the root of a binary tree, each node in the tree has a distinct value.
# 
# After deleting all nodes with a value in to_delete, we are left with a forest (a disjoint union of trees).
# 
# Return the roots of the trees in the remaining forest. You may return the result in any order.
# 
#  
# 
# Example 1:
# 
# 
# Input: root = [1,2,3,4,5,6,7], to_delete = [3,5]
# Output: [[1,2,null,4],[6],[7]]
# Example 2:
# 
# Input: root = [1,2,4,null,3], to_delete = [3]
# Output: [[1,2,4]]
#  
# 
# Constraints:
# 
# The number of nodes in the given tree is at most 1000.
# Each node has a distinct value between 1 and 1000.
# to_delete.length <= 1000
# to_delete contains distinct values between 1 and 1000.

# HashTable
# Complexity
# Time complexity: O(N)
# Space complexity: O(N)
# Code
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    nodes: dict[int, TreeNode] = {}

    def dfs(self, root: TreeNode, to_delete: set[int]):
        if not root: return
        if root.val in to_delete:
            if root.val in self.nodes:
                del self.nodes[root.val]
            if root.left:
                self.nodes[root.left.val] = root.left
            if root.right:
                self.nodes[root.right.val] = root.right
            self.dfs(root.left, to_delete)
            self.dfs(root.right, to_delete)
            return None
        else:
            root.left = self.dfs(root.left, to_delete)
            root.right = self.dfs(root.right, to_delete)
            return root

    def delNodes(self, root: Optional[TreeNode], to_delete: List[int]) -> List[TreeNode]:
        self.nodes.clear()
        to_delete: set[int] = set(to_delete)
        if root.val not in to_delete:
            self.nodes[root.val] = root
        self.dfs(root, to_delete)

        return self.nodes.values()

# Array
# Complexity
# Time complexity: O(N)
# Space complexity: O(N)
# Code
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    nodes: list[TreeNode] = []

    def dfs(self, root: TreeNode, to_delete: bool, targets: set[int]):
        if not root: return
        to_be_deleted: bool = root.val in targets
        if to_delete and not to_be_deleted:
            self.nodes.append(root)
        root.left = self.dfs(root.left, to_be_deleted, targets)
        root.right = self.dfs(root.right, to_be_deleted, targets)
        return None if to_be_deleted else root

    def delNodes(self, root: Optional[TreeNode], to_delete: List[int]) -> List[TreeNode]:
        self.nodes.clear()
        targets = set(to_delete)
        self.dfs(root, True, targets)

        return self.nodes

# Simple Fun #240: Increasing Number
# Task
# You are given a positive integer x and you should perform n operations, where on the ith operation you increase x in such a way that its new value is divisible by i (operations are numbered from 1 to n).
#
# Your task is to find the minimal value of x you can obtain by performing n operations described above.
#
# Input/Output
# [input] integer x
#
# Starting positive integer.
#
# 1 ≤ x ≤ 15.
#
# [input] integer n
#
# The number of operations.
#
# 2 ≤ n ≤ 100.
#
# [output] an integer
#
# The minimal possible value you can obtain after the described operations.
#
# Example
#
# For x = 9 and n = 5, the output should be 15.
#
# x=9 and n=5 means number starting from 9 and do increase operation 5 times.
#
# In each ith operation, x should increase to a multiple of i.
#
# 5 times operation:
#
# x starting from 9
# 1st operation: 9 is already a multiple of 1, no need increase anymore.
# 2nd operation: increase x to 10, which is a multiple of 2.
# 3rd operation: increase x to 12, which is a multiple of 3.
# 4th operation: 12 is already a multiple of 4.
# 5th operation: increase x to 15, which is a multiple of 5.
# PUZZLES
def increasing_number(x, n):
    acc: int = 1
    while acc <= n:
        if x % acc == 0:
            acc += 1
        else:
            x += 1
    return x
    
# A. Amusing Joke
# A. Amusing Joke
# time limit per test2 seconds
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# So, the New Year holidays are over. Santa Claus and his colleagues can take a rest and have guests at last. When two "New Year and Christmas Men" meet, thear assistants cut out of cardboard the letters from the guest's name and the host's name in honor of this event. Then the hung the letters above the main entrance. One night, when everyone went to bed, someone took all the letters of our characters' names. Then he may have shuffled the letters and put them in one pile in front of the door.
# 
# The next morning it was impossible to find the culprit who had made the disorder. But everybody wondered whether it is possible to restore the names of the host and his guests from the letters lying at the door? That is, we need to verify that there are no extra letters, and that nobody will need to cut more letters.
# 
# Help the "New Year and Christmas Men" and their friends to cope with this problem. You are given both inscriptions that hung over the front door the previous night, and a pile of letters that were found at the front door next morning.
# 
# Input
# The input file consists of three lines: the first line contains the guest's name, the second line contains the name of the residence host and the third line contains letters in a pile that were found at the door in the morning. All lines are not empty and contain only uppercase Latin letters. The length of each line does not exceed 100.
# 
# Output
# Print "YES" without the quotes, if the letters in the pile could be permuted to make the names of the "New Year and Christmas Men". Otherwise, print "NO" without the quotes.
# 
# Examples
# inputCopy
# SANTACLAUS
# DEDMOROZ
# SANTAMOROZDEDCLAUS
# outputCopy
# YES
# inputCopy
# PAPAINOEL
# JOULUPUKKI
# JOULNAPAOILELUPUKKI
# outputCopy
# NO
# inputCopy
# BABBONATALE
# FATHERCHRISTMAS
# BABCHRISTMASBONATALLEFATHER
# outputCopy
# NO
# Note
# In the first sample the letters written in the last line can be used to write the names and there won't be any extra letters left.
# 
# In the second sample letter "P" is missing from the pile and there's an extra letter "L".
# 
# In the third sample there's an extra letter "L".
import sys


def solution(guest: str, host: str, morning: str) -> str:
    return ['NO', 'YES'][sorted(guest + host) == sorted(morning)]


if __name__ == '__main__':
    guest: str = sys.stdin.readline().rstrip()
    host: str = sys.stdin.readline().rstrip()
    morning: str = sys.stdin.readline().rstrip()
    sys.stdout.write(solution(guest, host, morning))
    
# C. Registration system
# C. Registration system
# time limit per test5 seconds
# memory limit per test64 megabytes
# inputstdin
# outputstdout
# A new e-mail service "Berlandesk" is going to be opened in Berland in the near future. The site administration wants to launch their project as soon as possible, that's why they ask you to help. You're suggested to implement the prototype of site registration system. The system should work on the following principle.
# 
# Each time a new user wants to register, he sends to the system a request with his name. If such a name does not exist in the system database, it is inserted into the database, and the user gets the response OK, confirming the successful registration. If the name already exists in the system database, the system makes up a new user name, sends it to the user as a prompt and also inserts the prompt into the database. The new name is formed by the following rule. Numbers, starting with 1, are appended one after another to name (name1, name2, ...), among these numbers the least i is found so that namei does not yet exist in the database.
# 
# Input
# The first line contains number n (1 ≤ n ≤ 105). The following n lines contain the requests to the system. Each request is a non-empty line, and consists of not more than 32 characters, which are all lowercase Latin letters.
# 
# Output
# Print n lines, which are system responses to the requests: OK in case of successful registration, or a prompt with a new name, if the requested name is already taken.
# 
# Examples
# inputCopy
# 4
# abacaba
# acaba
# abacaba
# acab
# outputCopy
# OK
# OK
# abacaba1
# OK
# inputCopy
# 6
# first
# first
# second
# second
# third
# third
# outputCopy
# OK
# first1
# OK
# second1
# OK
# third1
import sys


def solution(n: int) -> None:
    storage: dict = dict()
    for _ in range(n):
        name: str = sys.stdin.readline().rstrip()
        acc: int = 1
        if name not in storage:
            storage[name] = 0
            print('OK')
        else:
            acc: int = storage[name] + 1
            new_name: str = name + str(acc)
            storage[name] = acc
            storage[new_name] = 0
            print(new_name)


if __name__ == '__main__':
    n: int = int(sys.stdin.readline().rstrip())
    solution(n)
    
# 1530. Number of Good Leaf Nodes Pairs
# You are given the root of a binary tree and an integer distance. A pair of two different leaf nodes of a binary tree is said to be good if the length of the shortest path between them is less than or equal to distance.
# 
# Return the number of good leaf node pairs in the tree.
# 
#  
# 
# Example 1:
# 
# 
# Input: root = [1,2,3,null,4], distance = 3
# Output: 1
# Explanation: The leaf nodes of the tree are 3 and 4 and the length of the shortest path between them is 3. This is the only good pair.
# Example 2:
# 
# 
# Input: root = [1,2,3,4,5,6,7], distance = 3
# Output: 2
# Explanation: The good pairs are [4,5] and [6,7] with shortest path = 2. The pair [4,6] is not good because the length of ther shortest path between them is 4.
# Example 3:
# 
# Input: root = [7,1,4,6,null,5,3,null,null,null,null,null,2], distance = 3
# Output: 1
# Explanation: The only good pair is [2,5].
#  
# 
# Constraints:
# 
# The number of nodes in the tree is in the range [1, 210].
# 1 <= Node.val <= 100
# 1 <= distance <= 10
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    good_pairs: int = 0
    def dfs(self, root, distance):
        if not root: return []
        if not root.left and not root.right:
            return [1]
        left_leafs: list[int] = self.dfs(root.left, distance)
        right_leafs: list[int] = self.dfs(root.right, distance)
        for l_leaf in left_leafs:
            for r_leaf in right_leafs:
                if l_leaf + r_leaf <= distance:
                    self.good_pairs += 1
        return [dist_leaf + 1 for dist_leaf in left_leafs + right_leafs if dist_leaf + 1 < distance]

    def countPairs(self, root: TreeNode, distance: int) -> int:
        self.dfs(root, distance)
        return self.good_pairs

# Math challenge #2 [Easy]
# Given a non-degenerate triangle with lengths a, b, and c, return
#
# the radius of a circle inscribed in the triangle (r)
# the radius of a circle circumscribed on the triangle (R)
# Examples:
#
# radii(3, 4, 5) = (1, 2.5)                                   (r = 1, right triangle, thales theorem, so R = 5 / 2 = 2.5)
# radii(1, 1, 1) = (sqrt(3) / 6, sqrt(3) / 3)
# radii(2, 1, 2) = (0.3872983346207417, 1.032795558988644)    (maths, blah blah blah)
# No golfing limit for this one, because I felt that this kata wasn't very... golfable. But if you want to beat me, I got a 74 char solution, and I would really like to see limit being pushed further.
#
# Enjoy!
#
# Also, please check out the rest of the katas in this series! https://www.codewars.com/collections/math-challenges-1
#
# MATHEMATICS
def radii(a, b, c):
    s: float = (a + b + c) / 2
    A: float = (s*(s - a)*(s - b)*(s - c))**.5
    return (A / s, (a * b * c) / (4 * A))

# 1380. Lucky Numbers in a Matrix
# Given an m x n matrix of distinct numbers, return all lucky numbers in the matrix in any order.
#
# A lucky number is an element of the matrix such that it is the minimum element in its row and maximum in its column.
#
#
#
# Example 1:
#
# Input: matrix = [[3,7,8],[9,11,13],[15,16,17]]
# Output: [15]
# Explanation: 15 is the only lucky number since it is the minimum in its row and the maximum in its column.
# Example 2:
#
# Input: matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]]
# Output: [12]
# Explanation: 12 is the only lucky number since it is the minimum in its row and the maximum in its column.
# Example 3:
#
# Input: matrix = [[7,8],[1,2]]
# Output: [7]
# Explanation: 7 is the only lucky number since it is the minimum in its row and the maximum in its column.
#
#
# Constraints:
#
# m == mat.length
# n == mat[i].length
# 1 <= n, m <= 50
# 1 <= matrix[i][j] <= 105.
# All elements in the matrix are distinct.
# Solution HashSet O(NM) O(N + M)
class Solution:
    def luckyNumbers (self, matrix: List[List[int]]) -> List[int]:
        min_in_a_row: set[int] = set(min(row) for row in matrix)
        max_in_a_col: set[int] = set(max(matrix[row][col] for row in range(len(matrix))) for col in range(len(matrix[0])))
        return [luck_num for luck_num in min_in_a_row if luck_num in max_in_a_col]
        
# A. Fox And Snake
# A. Fox And Snake
# time limit per test2 seconds
# memory limit per test256 megabytes
# inputstdin
# outputstdout
# Fox Ciel starts to learn programming. The first task is drawing a fox! However, that turns out to be too hard for a beginner, so she decides to draw a snake instead.
# 
# A snake is a pattern on a n by m table. Denote c-th cell of r-th row as (r, c). The tail of the snake is located at (1, 1), then it's body extends to (1, m), then goes down 2 rows to (3, m), then goes left to (3, 1) and so on.
# 
# Your task is to draw this snake for Fox Ciel: the empty cells should be represented as dot characters ('.') and the snake cells should be filled with number signs ('#').
# 
# Consider sample tests in order to understand the snake pattern.
# 
# Input
# The only line contains two integers: n and m (3 ≤ n, m ≤ 50).
# 
# n is an odd number.
# 
# Output
# Output n lines. Each line should contain a string consisting of m characters. Do not output spaces.
# 
# Examples
# inputCopy
# 3 3
# outputCopy
# ###
# ..#
# ###
# inputCopy
# 3 4
# outputCopy
# ####
# ...#
# ####
# inputCopy
# 5 3
# outputCopy
# ###
# ..#
# ###
# #..
# ###
# inputCopy
# 9 9
# outputCopy
# #########
# ........#
# #########
# #........
# #########
# ........#
# #########
# #........
# #########
# Solution O(N) O(1)
import sys


def solution(n: int, m: int) -> None:
    row = 0
    flag: bool = False
    print('#' * m)
    row += 1
    while row < n:
        if not flag:
            print('.' * (m - 1) + '#')
        else:
            print('#' + '.' * (m - 1))
        print('#' * m)
        row += 2
        flag = not flag


if __name__ == '__main__':
    n, m = map(int, sys.stdin.readline().rstrip().split())
    solution(n, m)

# Shuffle the List to Maximize Count of Greater Values
# Task
# 
# The function is given two lists of equal length a and b. Shuffle the first list a such that the count of a[i] > b[i] for 0 <= i < len(a) is maximized. Return the shuffled list a.
# 
# Example 1:
# 
# a = [3, 5], b = [4, 2]
# Explanation:
# 
# After shuffling a, we want to maximize the count of elements where a[i] > b[i].
# Possible shuffled outputs include [5, 3].
# In [5, 3], we have:
# For i = 0: a[0] = 5 and b[0] = 4, so 5 > 4.
# For i = 1: a[1] = 3 and b[1] = 2, so 3 > 2.
# Thus, both conditions a[0] > b[0] and a[1] > b[1] are satisfied.
# Output:
# 
# [5, 3]
# Example 2:
# 
# a = [2, 7, 11, 15], b = [1, 10, 4, 11])
# Output:
# 
# [2, 11, 7, 15]
# Example 3:
# 
# a = [12, 24, 8, 32], b = [13, 25, 32, 11]
# Explanation:
# 
# In [24, 32, 8, 12], we have:
# For i = 0: a[0] = 24 and b[0] = 13, so 24 > 13.
# For i = 1: a[1] = 32 and b[1] = 25, so 32 > 25.
# For i = 2: a[2] = 8 and b[2] = 32, so 8 < 32.
# For i = 3: a[3] = 12 and b[3] = 11, so 12 > 11.
# Thus, three conditions a[0] > b[0], a[1] > b[1], and a[3] > b[3] are satisfied.
# Output:
# 
# [24, 32, 8, 12]
# Example 4:
# 
# a = [2, 2, 5], b = [1, 3, 4]
# Explanation:
# 
# In [2, 5, 2], we have:
# 
# For i = 0: a[0] = 2 and b[0] = 1, so 2 > 1.
# For i = 1: a[1] = 5 and b[1] = 3, so 5 > 3.
# For i = 2: a[2] = 2 and b[2] = 4, so 2 < 4.
# Thus, two conditions a[0] > b[0] and a[1] > b[1] are satisfied.
# 
# Output:
# 
# [2, 5, 2]
# Notes
# 
# There can be multiple valid solutions to this problem since the order of elements in the shuffled list a can vary.
# 
# The helper function in the preloaded section checks the number of elements in a that are greater than the corresponding elements in b to validate the solution.
# 
# 1 <= length of lists <= 10^3
def shuffle_a(a, b):
    changed: list[tuple[int]] = []
    left: list[tuple[int]] = []
    a.sort()
    b_ = [(value, index) for index, value in enumerate(b)]
    idxs: list[int] = list(range(len(a)))
    b_.sort(key=lambda x: x[0])
    a_idx: int = 0
    b_idx: int = 0

    while a_idx < len(a) and b_idx < len(b):
        if a[a_idx] > b_[b_idx][0]:
            changed.append((a[a_idx], b_[b_idx][1]))
            a_idx += 1
            idxs.remove(b_[b_idx][1])
            b_idx += 1
        else:
            left.append(a[a_idx])
            a_idx += 1
    if idxs:
        left = [(left[idx], idxs[idx]) for idx in range(len(idxs))]
    output = changed + left
    return [i[0] for i in sorted(output, key=lambda x: x[1])]

# 1605. Find Valid Matrix Given Row and Column Sums
# You are given two arrays rowSum and colSum of non-negative integers where rowSum[i] is the sum of the elements in the ith row and colSum[j] is the sum of the elements of the jth column of a 2D matrix. In other words, you do not know the elements of the matrix, but you do know the sums of each row and column.
# 
# Find any matrix of non-negative integers of size rowSum.length x colSum.length that satisfies the rowSum and colSum requirements.
# 
# Return a 2D array representing any matrix that fulfills the requirements. It's guaranteed that at least one matrix that fulfills the requirements exists.
# 
#  
# 
# Example 1:
# 
# Input: rowSum = [3,8], colSum = [4,7]
# Output: [[3,0],
#          [1,7]]
# Explanation: 
# 0th row: 3 + 0 = 3 == rowSum[0]
# 1st row: 1 + 7 = 8 == rowSum[1]
# 0th column: 3 + 1 = 4 == colSum[0]
# 1st column: 0 + 7 = 7 == colSum[1]
# The row and column sums match, and all matrix elements are non-negative.
# Another possible matrix is: [[1,2],
#                              [3,5]]
# Example 2:
# 
# Input: rowSum = [5,7,10], colSum = [8,6,8]
# Output: [[0,5,0],
#          [6,1,0],
#          [2,0,8]]
#  
# 
# Constraints:
# 
# 1 <= rowSum.length, colSum.length <= 500
# 0 <= rowSum[i], colSum[i] <= 108
# sum(rowSum) == sum(colSum)
class Solution:
    def restoreMatrix(self, rowSum: List[int], colSum: List[int]) -> List[List[int]]:
        n, m = len(rowSum), len(colSum)
        mtrx: list[list[int]] = [[0] * m for _ in range(n)]
        row = col = 0
        while row < n and col < m:
            current_ceil: int = min(rowSum[row], colSum[col])
            mtrx[row][col] = current_ceil
            rowSum[row] -= current_ceil
            if rowSum[row] == 0:
                row += 1
            colSum[col] -= current_ceil
            if colSum[col] == 0:
                col += 1
        return mtrx

# A. Puzzles
# A. Puzzles
# time limit per test1 second
# memory limit per test256 megabytes
# inputstdin
# outputstdout
# The end of the school year is near and Ms. Manana, the teacher, will soon have to say goodbye to a yet another class. She decided to prepare a goodbye present for her n students and give each of them a jigsaw puzzle (which, as wikipedia states, is a tiling puzzle that requires the assembly of numerous small, often oddly shaped, interlocking and tessellating pieces).
#
# The shop assistant told the teacher that there are m puzzles in the shop, but they might differ in difficulty and size. Specifically, the first jigsaw puzzle consists of f1 pieces, the second one consists of f2 pieces and so on.
#
# Ms. Manana doesn't want to upset the children, so she decided that the difference between the numbers of pieces in her presents must be as small as possible. Let A be the number of pieces in the largest puzzle that the teacher buys and B be the number of pieces in the smallest such puzzle. She wants to choose such n puzzles that A - B is minimum possible. Help the teacher and find the least possible value of A - B.
#
# Input
# The first line contains space-separated integers n and m (2 ≤ n ≤ m ≤ 50). The second line contains m space-separated integers f1, f2, ..., fm (4 ≤ fi ≤ 1000) — the quantities of pieces in the puzzles sold in the shop.
#
# Output
# Print a single integer — the least possible difference the teacher can obtain.
#
# Examples
# inputCopy
# 4 6
# 10 12 10 7 5 22
# outputCopy
# 5
# Note
# Sample 1. The class has 4 students. The shop sells 6 puzzles. If Ms. Manana buys the first four puzzles consisting of 10, 12, 10 and 7 pieces correspondingly, then the difference between the sizes of the largest and the smallest puzzle will be equal to 5. It is impossible to obtain a smaller difference. Note that the teacher can also buy puzzles 1, 3, 4 and 5 to obtain the difference 5.
import sys

def solution(n: int, m: int, pieces: list) -> str:
    pieces.sort()
    differences: int = float('inf')
    left = 0
    right = min(n - 1, m - 1)
    while right < m:
        differences = min(differences, pieces[right] - pieces[left])
        left += 1
        right += 1
    return str(differences)

if __name__ == '__main__':
    n, m = map(int, sys.stdin.readline().rstrip().split())
    pieces: list = list(map(int, sys.stdin.readline().rstrip().split()))
    sys.stdout.write(solution(n, m , pieces))

# Simple Fun #347: Bulb Maze I
# Description
# You are fleeing from enemies through a maze. You need to reach the exit through many rooms that are laid out in a straight line.
# 
# Some rooms have a light bulb. If the light bulb is lit when you enter the room, the enemy will see you and you will be caught. In other words, you can only walk in the darkness.
# 
# Fortunately, the status of these bulbs (on/off) is switched automatically every minute. So you have a chance to go through the maze, if the lightbulbs are turned off at the right time.
# 
# You have to be constantly on the move, otherwise the enemy will catch up to you.
# 
# Specifications
# The rooms are represented by a string, e.g. "xo oxox".
# 
# 'x' means there is a bulb in the room, and its initial status is off
# 'o' means there is a bulb in the room, and its initial status is on
# ' '(space) means a room without bulb, it is always dark.
# Your task is to determine if you can go through the maze. Return true if you can, false otherwise.
# 
# Notes
# Your initial position is at the leftmost room; the exit position is at the rightmost.
# Your moving speed is 1 minute per room. You have to keep moving constantly, i.e. you cannot wait for the next room to become dark.
# You have to start moving immediately.
# Examples
# For "xo oxox", the output should be true:
# 
# step 0 :  xo oxox
#           ^ <--------You are here
# step 1 :  ox xoxo
#            ^ <--------You are here
# step 2 :  xo oxox
#             ^ <--------You are here
# step 3 :  ox xoxo
#              ^ <--------You are here
# step 4 :  xo oxox
#               ^ <--------You are here
# step 5 :  ox xoxo
#                ^ <--------You are here
# step 6 :  xo oxox
#                 ^ <--------You are here
# step 7 :  ox xoxo
#                  ^ <--------You've go through the maze :)
# For "xo  oxox", the output should be false:
# 
# step 0 :  xo  oxox
#           ^ <--------You are here
# step 1 :  ox  xoxo
#            ^ <--------You are here
# step 2 :  xo  oxox
#             ^ <--------You are here
# step 3 :  ox  xoxo
#              ^ <--------You are here
# step 4 :  xo  oxox
#               ^ <--------You were caught by the enemy :(
# Happy Coding ^_^
# 
# FUNDAMENTALS
def bulb_maze(maze):
    move: int = 0
    switch: dict[str, str] = {'x': 'o', 'o': 'x'}
    for room in maze:
        if room != ' ':
            if [room, switch[room]][move & 1] == 'o': return False
        move += 1
    return True
    
# 3222. Find the Winning Player in Coin Game
# You are given two positive integers x and y, denoting the number of coins with values 75 and 10 respectively.
# 
# Alice and Bob are playing a game. Each turn, starting with Alice, the player must pick up coins with a total value 115. If the player is unable to do so, they lose the game.
# 
# Return the name of the player who wins the game if both players play optimally.
# 
#  
# 
# Example 1:
# 
# Input: x = 2, y = 7
# 
# Output: "Alice"
# 
# Explanation:
# 
# The game ends in a single turn:
# 
# Alice picks 1 coin with a value of 75 and 4 coins with a value of 10.
# Example 2:
# 
# Input: x = 4, y = 11
# 
# Output: "Bob"
# 
# Explanation:
# 
# The game ends in 2 turns:
# 
# Alice picks 1 coin with a value of 75 and 4 coins with a value of 10.
# Bob picks 1 coin with a value of 75 and 4 coins with a value of 10.
#  
# 
# Constraints:
# 
# 1 <= x, y <= 100
class Solution:
    def losingPlayer(self, x: int, y: int) -> str:
        return ['Bob', 'Alice'][min(x, y // 4) & 1]
        
# 3223. Minimum Length of String After Operations
# You are given a string s.
# 
# You can perform the following process on s any number of times:
# 
# Choose an index i in the string such that there is at least one character to the left of index i that is equal to s[i], and at least one character to the right that is also equal to s[i].
# Delete the closest character to the left of index i that is equal to s[i].
# Delete the closest character to the right of index i that is equal to s[i].
# Return the minimum length of the final string s that you can achieve.
# 
#  
# 
# Example 1:
# 
# Input: s = "abaacbcbb"
# 
# Output: 5
# 
# Explanation:
# We do the following operations:
# 
# Choose index 2, then remove the characters at indices 0 and 3. The resulting string is s = "bacbcbb".
# Choose index 3, then remove the characters at indices 0 and 5. The resulting string is s = "acbcb".
# Example 2:
# 
# Input: s = "aa"
# 
# Output: 2
# 
# Explanation:
# We cannot perform any operations, so we return the length of the original string.
# 
#  
# 
# Constraints:
# 
# 1 <= s.length <= 2 * 105
# s consists only of lowercase English letters.
# We have only two choices:
# If current frequences of character is odd - at the end being at most 1 character
# Otherwise, if frequences is even, we can have at most 2 characters
# Complexity
# Time complexity: O(N)
# Space complexity: O(N)
# Code
from collections import defaultdict
class Solution:
    def minimumLength(self, s: str) -> int:
        storage: dict[str, int] = defaultdict(int)
        for char in s:
            storage[char] += 1
        for char in storage:
            storage[char] = 1 if storage[char] & 1 else 2
        return sum(storage.values())
        
# 3224. Minimum Array Changes to Make Differences Equal
# You are given an integer array nums of size n where n is even, and an integer k.
# 
# You can perform some changes on the array, where in one change you can replace any element in the array with any integer in the range from 0 to k.
# 
# You need to perform some changes (possibly none) such that the final array satisfies the following condition:
# 
# There exists an integer X such that abs(a[i] - a[n - i - 1]) = X for all (0 <= i < n).
# Return the minimum number of changes required to satisfy the above condition.
# 
#  
# 
# Example 1:
# 
# Input: nums = [1,0,1,2,4,3], k = 4
# 
# Output: 2
# 
# Explanation:
# We can perform the following changes:
# 
# Replace nums[1] by 2. The resulting array is nums = [1,2,1,2,4,3].
# Replace nums[3] by 3. The resulting array is nums = [1,2,1,3,4,3].
# The integer X will be 2.
# 
# Example 2:
# 
# Input: nums = [0,1,2,3,3,6,5,4], k = 6
# 
# Output: 2
# 
# Explanation:
# We can perform the following operations:
# 
# Replace nums[3] by 0. The resulting array is nums = [0,1,2,0,3,6,5,4].
# Replace nums[4] by 4. The resulting array is nums = [0,1,2,0,4,6,5,4].
# The integer X will be 4.
# 
#  
# 
# Constraints:
# 
# 2 <= n == nums.length <= 105
# n is even.
# 0 <= nums[i] <= k <= 105
from collections import defaultdict
class Solution:
    def minChanges(self, nums: List[int], k: int) -> int:
        n: int = len(nums)
        pairs: list[tuple[int, int]] = []
        freq: dict[int, int] = defaultdict(int)
        for i in range(n // 2):
            freq[abs(nums[i] - nums[n - i - 1])] += 1
            pairs.append((nums[i], nums[n - i - 1]))

        change_count: dict[int, int] = defaultdict(int)
        # Sorting freq by frequences and values in descending order
        freq = sorted(freq, key=lambda x: (freq[x], x), reverse=True)
        for X in freq[:100]: # Give first 100(or less if len(freq) < 100) possible X
            current_changes: int = 0 # Needed swaps
            for a, b in pairs:
                if abs(a - b) != X:
                    if 0 <= a - X <= k or 0 <= b + X <= k:
                        current_changes += 1 # Swap one number
                    elif 0 <= b - X <= k or 0 <= a + X <= k:
                        current_changes += 1 # Swap one number
                    else:
                        current_changes += 2 # Swap two number
            change_count[X] = current_changes # For current X store count fo swaps

        return min(change_count.values())

# 3226. Number of Bit Changes to Make Two Integers Equal
# You are given two positive integers n and k.
# 
# You can choose any bit in the binary representation of n that is equal to 1 and change it to 0.
# 
# Return the number of changes needed to make n equal to k. If it is impossible, return -1.
# 
#  
# 
# Example 1:
# 
# Input: n = 13, k = 4
# 
# Output: 2
# 
# Explanation:
# Initially, the binary representations of n and k are n = (1101)2 and k = (0100)2.
# We can change the first and fourth bits of n. The resulting integer is n = (0100)2 = k.
# 
# Example 2:
# 
# Input: n = 21, k = 21
# 
# Output: 0
# 
# Explanation:
# n and k are already equal, so no changes are needed.
# 
# Example 3:
# 
# Input: n = 14, k = 13
# 
# Output: -1
# 
# Explanation:
# It is not possible to make n equal to k.
# 
#  
# 
# Constraints:
# 
# 1 <= n, k <= 106
class Solution:
    def minChanges(self, n: int, k: int) -> int:
        bin_n, bin_k = bin(n)[2:], bin(k)[2:]

        if len(bin_k) < len(bin_n):
            bin_k = '0' * (len(bin_n) - len(bin_k)) + bin_k
        elif len(bin_k) > len(bin_n):
            bin_n = '0' * (len(bin_k) - len(bin_n)) + bin_n

        if any(b_k == '1' and b_n == '0' for b_n, b_k in zip(bin_n, bin_k)):
            return -1

        return sum(b_n != b_k for b_n, b_k in zip(bin_n, bin_k))

# 3227. Vowels Game in a String
# Alice and Bob are playing a game on a string.
# 
# You are given a string s, Alice and Bob will take turns playing the following game where Alice starts first:
# 
# On Alice's turn, she has to remove any non-empty 
# substring
#  from s that contains an odd number of vowels.
# On Bob's turn, he has to remove any non-empty 
# substring
#  from s that contains an even number of vowels.
# The first player who cannot make a move on their turn loses the game. We assume that both Alice and Bob play optimally.
# 
# Return true if Alice wins the game, and false otherwise.
# 
# The English vowels are: a, e, i, o, and u.
# 
#  
# 
# Example 1:
# 
# Input: s = "leetcoder"
# 
# Output: true
# 
# Explanation:
# Alice can win the game as follows:
# 
# Alice plays first, she can delete the underlined substring in s = "leetcoder" which contains 3 vowels. The resulting string is s = "der".
# Bob plays second, he can delete the underlined substring in s = "der" which contains 0 vowels. The resulting string is s = "er".
# Alice plays third, she can delete the whole string s = "er" which contains 1 vowel.
# Bob plays fourth, since the string is empty, there is no valid play for Bob. So Alice wins the game.
# Example 2:
# 
# Input: s = "bbcd"
# 
# Output: false
# 
# Explanation:
# There is no valid play for Alice in her first turn, so Alice loses the game.
# 
#  
# 
# Constraints:
# 
# 1 <= s.length <= 105
# s consists only of lowercase English letters.
class Solution:
    def doesAliceWin(self, s: str) -> bool:
        vowels: int = 0
        for char in s:
            if char in {'a', 'e', 'o', 'u', 'i'}:
                vowels += 1
        return vowels > 0

# 3228. Maximum Number of Operations to Move Ones to the End
# You are given a 
# binary string
#  s.
# 
# You can perform the following operation on the string any number of times:
# 
# Choose any index i from the string where i + 1 < s.length such that s[i] == '1' and s[i + 1] == '0'.
# Move the character s[i] to the right until it reaches the end of the string or another '1'. For example, for s = "010010", if we choose i = 1, the resulting string will be s = "000110".
# Return the maximum number of operations that you can perform.
# 
#  
# 
# Example 1:
# 
# Input: s = "1001101"
# 
# Output: 4
# 
# Explanation:
# 
# We can perform the following operations:
# 
# Choose index i = 0. The resulting string is s = "0011101".
# Choose index i = 4. The resulting string is s = "0011011".
# Choose index i = 3. The resulting string is s = "0010111".
# Choose index i = 2. The resulting string is s = "0001111".
# Example 2:
# 
# Input: s = "00111"
# 
# Output: 0
# 
#  
# 
# Constraints:
# 
# 1 <= s.length <= 105
# s[i] is either '0' or '1'.
# General idea:
# Calculate how many ones you have staring from 0 index to end of string.
# Id current char is "1" - increment ones
# At each iteration mark boolean "move" variable to False
# If you need move to next '1' character, mark boolean "move" variable on True
# If "move" variable is True - add count of ones to total score
# Complexity
# Time complexity: O(N)
# Space complexity: O(1)
# Code
class Solution:
    def maxOperations(self, s: str) -> int:
        score: int = 0
        ones: int = 0

        idx: int = 0
        while idx < len(s):
            if s[idx] == '1':
                ones += 1
                idx += 1

            move: bool = False
            while idx < len(s) and s[idx] != '1':
                idx += 1
                move = True

            if move:
                score += ones
        return score

# 3229. Minimum Operations to Make Array Equal to Target
# You are given two positive integer arrays nums and target, of the same length.
# 
# In a single operation, you can select any 
# subarray
#  of nums and increment or decrement each element within that subarray by 1.
# 
# Return the minimum number of operations required to make nums equal to the array target.
# 
#  
# 
# Example 1:
# 
# Input: nums = [3,5,1,2], target = [4,6,2,4]
# 
# Output: 2
# 
# Explanation:
# 
# We will perform the following operations to make nums equal to target:
# - Increment nums[0..3] by 1, nums = [4,6,2,3].
# - Increment nums[3..3] by 1, nums = [4,6,2,4].
# 
# Example 2:
# 
# Input: nums = [1,3,2], target = [2,1,4]
# 
# Output: 5
# 
# Explanation:
# 
# We will perform the following operations to make nums equal to target:
# - Increment nums[0..0] by 1, nums = [2,3,2].
# - Decrement nums[1..1] by 1, nums = [2,2,2].
# - Decrement nums[1..1] by 1, nums = [2,1,2].
# - Increment nums[2..2] by 1, nums = [2,1,3].
# - Increment nums[2..2] by 1, nums = [2,1,4].
# 
#  
# 
# Constraints:
# 
# 1 <= nums.length == target.length <= 105
# 1 <= nums[i], target[i] <= 108
# General idea:
# For minimize operations we should choose maximum subarray contain integers with same needed operations. For definition of subarray we can use sliding window approach. Lets define a "way"* (using first element of array) and iterate from entire array of needed differences. At each iteration check:
# If current number "way"* not equal with "way"* of our subarray, we should make all needed numbers in subarray positive(for simplify work of helper function) and calculatate needed operations on that subarray. Then move left pointer to current right pointer and define new "way"*
# If current number "way"* same as in subarray, just continue iterating, meaning increasing our subarray
# After end of loop we should check array on case where our subarray have all same opeartions and our subarray size is the same as length of array. Meaning that sliding window increases all iteration
# *way = boolean, define integer either negative or positive.
#
# Helper funcion idea
# Function will take 3 arguments: array(meaning our subarray), left and right pointers definding length of current subarray(sliding window)
# For making minimum operations we need choose maximum consecutive inegers(subarray) that not separate with 0. Then recursive call for current subarray with less boundary pointers.
# Example:
# 1) [2, 1, 2] -> we can use subarray with size equal of array size, because all numbers need to descrease to zero(for this we creating all number positive in main function, before calling helper function)
# 2) [1, 0, 1] -> we cannot use subarray with length of array, because our integers seprated with zero, so we use number at index 0
# 3) [0, 0, 1] -> we only can use subarray contain integer with number at index 2
# We need only 3 operation to make all numbers in subarray equal to 0
# If left pointer more than right - return 0, because it means that our subarray have 0 length
# Create a local right pointer for definding new sliding window. Iterate from until local_right pointer less than global right pointer.- - In loop create second loop with condition: "until local right pointer less that global right pointer and current integer not equal to 0". At each iteration of inner loop, choosing minimum element that can be use for operations(because see at example code above, we cant swapp all integers at 2 operations, because number at index 1 have value 1 and its less than value of her neighbours. So it means that minimum value will separate our subarray on two subarrays)
# After ending inner loop we should check that minimum value extist(it means that we found subarray) and if it is, we should subtract minimum value from all integers in subarray and add minimum_value to total needed operation, make minimum_value on infinity and add to total needed operation recursive call for our subarray with boundaries: left to local right poniter.
# At the end of each iteration in outer loop, just increase our local right pointer
# After the end of outer loop check on case where we our subarray already have all similar integers without zeros. Like [1, 2, 3, 4] and length of our current subarray is 4, thats equals to array length. Calculate minimum operations by adding minimum value to total needed operation, then subtract minimum value from all integers in subarray and add result of recursive call(with boundaries: left to local_right + 1 because we iterate until local_right less than global right) to total needed operations
# Note:
# While subtracting minimum value from all integers in subarray, we should keep in mind that each integer can't be less that 0
# Similar problem:
# 1526
#
# Complexity
# Time complexity: O(N**2)
# Space complexity: O(N)
# Code
class Solution:
    def needed_operations(self, arr: list[int], left: int, right: int) -> int:
        operations: int = 0
        if left > right: return operations # our subarray have 0 length

        local_right: int = left
        min_value: int = float('inf') # Define minimum value that we can use to minimuze total operations
        while local_right < right:
            # Create second loop until we can increase sliding window
            while local_right < right and arr[local_right] != 0:
                min_value = min(min_value, arr[local_right])
                local_right += 1
            # If subarray exist
            if min_value != float('inf'):
                # Subtract minimum value from all numbers in subarray
                arr[left:local_right] = [max(x - min_value, 0) for x in arr[left:local_right]]
                operations += min_value
                min_value = float('inf')
                # Create recursive call to count how many operations needed perform on subarray
                operations += self.needed_operations(arr, left, local_right)

            local_right += 1 # Move our sliding window length
        # Case where subarray can be same size as array length
        if min_value != float('inf'):
            arr[left:local_right + 1] = [max(x - min_value, 0) for x in arr[left:local_right + 1]]
            operations += min_value # Minimum number that we can choose to minimize operations
            # Caclulate needed operations on our subarray by recursive call
            operations += self.needed_operations(arr, left, local_right + 1)

        return operations

    def minimumOperations(self, nums: List[int], target: List[int]) -> int:
        needed: list[int] = [i_nums - i_target for i_nums, i_target in zip(nums, target)]
        operations: int = 0
        left: int = 0
        way: bool = needed[left] > 0 # Define current way of subarray
        for right in range(len(nums)):
            current_way: bool = needed[right] > 0 # Way of current element
            if current_way != way:
                # Makes all integers positive for simplify logic of helper function
                needed[left:right] = [abs(i) for i in needed[left:right]]
                # Calculate how many operations we need make on our subarray
                operations += self.needed_operations(needed, left, right)

                left = right # Move left pointer to right
                way = current_way # Take current way of number to new current way of subarray
        # Case where our subarray can be same size as array length
        needed[left:len(nums)] = [abs(i) for i in needed[left:len(nums)]]
        operations += self.needed_operations(needed, left, len(nums))

        return operations

# A. Dragons
# A. Dragons
# time limit per test2 seconds
# memory limit per test256 megabytes
# inputstdin
# outputstdout
# Kirito is stuck on a level of the MMORPG he is playing now. To move on in the game, he's got to defeat all n dragons that live on this level. Kirito and the dragons have strength, which is represented by an integer. In the duel between two opponents the duel's outcome is determined by their strength. Initially, Kirito's strength equals s.
# 
# If Kirito starts duelling with the i-th (1 ≤ i ≤ n) dragon and Kirito's strength is not greater than the dragon's strength xi, then Kirito loses the duel and dies. But if Kirito's strength is greater than the dragon's strength, then he defeats the dragon and gets a bonus strength increase by yi.
# 
# Kirito can fight the dragons in any order. Determine whether he can move on to the next level of the game, that is, defeat all dragons without a single loss.
# 
# Input
# The first line contains two space-separated integers s and n (1 ≤ s ≤ 104, 1 ≤ n ≤ 103). Then n lines follow: the i-th line contains space-separated integers xi and yi (1 ≤ xi ≤ 104, 0 ≤ yi ≤ 104) — the i-th dragon's strength and the bonus for defeating it.
# 
# Output
# On a single line print "YES" (without the quotes), if Kirito can move on to the next level and print "NO" (without the quotes), if he can't.
# 
# Examples
# inputCopy
# 2 2
# 1 99
# 100 0
# outputCopy
# YES
# inputCopy
# 10 1
# 100 100
# outputCopy
# NO
# Note
# In the first sample Kirito's strength initially equals 2. As the first dragon's strength is less than 2, Kirito can fight it and defeat it. After that he gets the bonus and his strength increases to 2 + 99 = 101. Now he can defeat the second dragon and move on to the next level.
# 
# In the second sample Kirito's strength is too small to defeat the only dragon and win.
import sys

def solution(s: int, n: int, dragons: list) -> str:
    dragons.sort(key=lambda x: (x[0], x[1]))
    for dragon in dragons:
        if dragon[0] >= s: return 'NO'
        s += dragon[1]
    return 'YES'

if __name__ == '__main__':
    s, n = map(int, sys.stdin.readline().rstrip().split())
    dragons: list = list(tuple(map(int, sys.stdin.readline().rstrip().split())) for _ in range(n))
    sys.stdout.write(solution(s, n, dragons))

# Scraping: Get the Year a CodeWarrior Joined
# #Task: Write a function get_member_since which accepts a username from someone at Codewars and returns an string containing the month and year separated by a space that they joined CodeWars.
#
# ###If you want/don't want your username to be in the tests, ask me in the discourse area. There can't be too many though because the server may time out.
#
# #Example:
#
# >>> get_member_since('dpleshkov')
# Jul 2016
# >>> get_member_since('jhoffner')
# Oct 2012
# #Libraries/Recommendations:
#
# ##Python:
#
# urllib.request.urlopen: Opens up a webpage.
# re: The RegEx library for Python.
# bs4(BeautifulSoup): A tool for scraping HTML and XML.
# Python 2 is not working for this kata. :(
# #Notes:
#
# Time out / server errors often happen with the test cases depending on the status of the codewars website. Try submitting your code a few times or at different hours of the day if needed.
# Feel free to voice your comments and concerns in the discourse area.
# STRINGSREGULAR EXPRESSIONSFUNDAMENTALS
from urllib.request import urlopen
from bs4 import BeautifulSoup
def get_member_since(username):
    username = username.encode('ascii', 'ignore').decode('ascii')
    username = username.replace(' ', '%20')
    url = f'https://www.codewars.com/users/{username}'
    response = urlopen(url)
    soup = BeautifulSoup(response.read(), 'html.parser')
    stats = soup.select('div#app > div#shell > main#shell_content > div > section.user-profile > div.w-full > div > div.flex-box > div.stat-box > div.stat')
    for stat in stats:
        if 'Member Since' in stat.b.text:
            return stat.b.next.next

# 2392. Build a Matrix With Conditions
# You are given a positive integer k. You are also given:
# 
# a 2D integer array rowConditions of size n where rowConditions[i] = [abovei, belowi], and
# a 2D integer array colConditions of size m where colConditions[i] = [lefti, righti].
# The two arrays contain integers from 1 to k.
# 
# You have to build a k x k matrix that contains each of the numbers from 1 to k exactly once. The remaining cells should have the value 0.
# 
# The matrix should also satisfy the following conditions:
# 
# The number abovei should appear in a row that is strictly above the row at which the number belowi appears for all i from 0 to n - 1.
# The number lefti should appear in a column that is strictly left of the column at which the number righti appears for all i from 0 to m - 1.
# Return any matrix that satisfies the conditions. If no answer exists, return an empty matrix.
# 
#  
# 
# Example 1:
# 
# 
# Input: k = 3, rowConditions = [[1,2],[3,2]], colConditions = [[2,1],[3,2]]
# Output: [[3,0,0],[0,0,1],[0,2,0]]
# Explanation: The diagram above shows a valid example of a matrix that satisfies all the conditions.
# The row conditions are the following:
# - Number 1 is in row 1, and number 2 is in row 2, so 1 is above 2 in the matrix.
# - Number 3 is in row 0, and number 2 is in row 2, so 3 is above 2 in the matrix.
# The column conditions are the following:
# - Number 2 is in column 1, and number 1 is in column 2, so 2 is left of 1 in the matrix.
# - Number 3 is in column 0, and number 2 is in column 1, so 3 is left of 2 in the matrix.
# Note that there may be multiple correct answers.
# Example 2:
# 
# Input: k = 3, rowConditions = [[1,2],[2,3],[3,1],[2,3]], colConditions = [[2,1]]
# Output: []
# Explanation: From the first two conditions, 3 has to be below 1 but the third conditions needs 3 to be above 1 to be satisfied.
# No matrix can satisfy all the conditions, so we return the empty matrix.
#  
# 
# Constraints:
# 
# 2 <= k <= 400
# 1 <= rowConditions.length, colConditions.length <= 104
# rowConditions[i].length == colConditions[i].length == 2
# 1 <= abovei, belowi, lefti, righti <= k
# abovei != belowi
# lefti != righti
 from collections import defaultdict
class Solution:
    def dfs(self, source, destinations, visited, previous_path, path):
        # Case if we have cycle
        if source in previous_path: return -1
        # Case if vertex already been visited, but its not a cycle(like children or tail of graph)
        if source in visited: return
        # Add vertex in visited path of global DFS vertexes
        visited.add(source)
        # Add vertex to current DFS path
        previous_path.add(source)
        # Iterate from all possible destionations from current source
        for destination in destinations[source]:
            # Make DFS on each destination
            # Case if we have cycle
            if self.dfs(destination, destinations, visited, previous_path, path) == -1:
                return -1
        # Add current vertex to path
        path.append(source)
        # Clear current DFS path
        previous_path.remove(source)

    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:
        # Make adjasency list representing rows conditions
        row_vertexes: dict[int, set[int]] = defaultdict(set)
        for source, destination in rowConditions:
            row_vertexes[source].add(destination)
        # Make topoligical sorting for rows conditions
        row_path: list[int] = []
        row_visited: set[int] = set()
        row_previous_path: set[int] = set()
        for vertex in range(1, k + 1):
            if self.dfs(vertex, row_vertexes, row_visited, row_previous_path, row_path) == -1:
                return []
        row_path.reverse()
        # Create adjasency list represent columns conditions
        col_vertexes: dict[int, set[int]] = defaultdict(set)
        for source, destination in colConditions:
            col_vertexes[source].add(destination)
        # Make topological sort for columns conditions
        col_path: list[int] = []
        col_visited: set[int] = set()
        col_previous_path: set[int] = set()
        for vertex in range(1, k + 1):
            if self.dfs(vertex, col_vertexes, col_visited, col_previous_path, col_path) == -1:
                return []
        col_path.reverse()
        # Define correct position for each number in (1 to k) inclusive range
        positions: dict[int, list[int, int]] = defaultdict(list)
        # Initially define correct row position for each number
        for vertex in range(1, k + 1):
            positions[row_path[vertex - 1]].append(vertex - 1)
        # Then define correct col position for each number
        for vertex in range(1, k + 1):
            positions[col_path[vertex - 1]].append(vertex - 1)
        # Construct k*k matrix
        mtrx: list[list[int]] = [[0] * k for _ in range(k)]
        # Place numbers by his correct row and col positions
        for ceil in positions:
            row, col = positions[ceil]
            mtrx[row][col] = ceil

        return mtrx

# 1526. Minimum Number of Increments on Subarrays to Form a Target Array
# You are given an integer array target. You have an integer array initial of the same size as target with all elements initially zeros.
# 
# In one operation you can choose any subarray from initial and increment each value by one.
# 
# Return the minimum number of operations to form a target array from initial.
# 
# The test cases are generated so that the answer fits in a 32-bit integer.
# 
#  
# 
# Example 1:
# 
# Input: target = [1,2,3,2,1]
# Output: 3
# Explanation: We need at least 3 operations to form the target array from the initial array.
# [0,0,0,0,0] increment 1 from index 0 to 4 (inclusive).
# [1,1,1,1,1] increment 1 from index 1 to 3 (inclusive).
# [1,2,2,2,1] increment 1 at index 2.
# [1,2,3,2,1] target array is formed.
# Example 2:
# 
# Input: target = [3,1,1,2]
# Output: 4
# Explanation: [0,0,0,0] -> [1,1,1,1] -> [1,1,1,2] -> [2,1,1,2] -> [3,1,1,2]
# Example 3:
# 
# Input: target = [3,1,5,4,2]
# Output: 7
# Explanation: [0,0,0,0,0] -> [1,1,1,1,1] -> [2,1,1,1,1] -> [3,1,1,1,1] -> [3,1,2,2,2] -> [3,1,3,3,2] -> [3,1,4,4,2] -> [3,1,5,4,2].
#  
# 
# Constraints:
# 
# 1 <= target.length <= 105
# 1 <= target[i] <= 105
class Solution:
    def minNumberOperations(self, target: List[int]) -> int:
        target: list[int] = [0] + target + [0]
        operations: int = 0
        for idx in range(len(target)):
            operations += abs(target[idx] - target[idx - 1])
        return operations // 2

# 2418. Sort the People
# You are given an array of strings names, and an array heights that consists of distinct positive integers. Both arrays are of length n.
#
# For each index i, names[i] and heights[i] denote the name and height of the ith person.
#
# Return names sorted in descending order by the people's heights.
#
#
#
# Example 1:
#
# Input: names = ["Mary","John","Emma"], heights = [180,165,170]
# Output: ["Mary","Emma","John"]
# Explanation: Mary is the tallest, followed by Emma and John.
# Example 2:
#
# Input: names = ["Alice","Bob","Bob"], heights = [155,185,150]
# Output: ["Bob","Alice","Bob"]
# Explanation: The first Bob is the tallest, followed by Alice and the second Bob.
#
#
# Constraints:
#
# n == names.length == heights.length
# 1 <= n <= 103
# 1 <= names[i].length <= 20
# 1 <= heights[i] <= 105
# names[i] consists of lower and upper case English letters.
# All the values of heights are distinct.
class Solution:
    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:
       names_storage: dict[int, str] = dict((height, name) for height, name in zip(heights, names))
       return [names_storage[people] for people in sorted(names_storage, reverse=True)]

# A. Sum of Round Numbers
# A. Sum of Round Numbers
# time limit per test1 second
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# A positive (strictly greater than zero) integer is called round if it is of the form d00...0. In other words, a positive integer is round if all its digits except the leftmost (most significant) are equal to zero. In particular, all numbers from 1
#  to 9
#  (inclusive) are round.
# 
# For example, the following numbers are round: 4000
# , 1
# , 9
# , 800
# , 90
# . The following numbers are not round: 110
# , 707
# , 222
# , 1001
# .
# 
# You are given a positive integer n
#  (1≤n≤104
# ). Represent the number n
#  as a sum of round numbers using the minimum number of summands (addends). In other words, you need to represent the given number n
#  as a sum of the least number of terms, each of which is a round number.
# 
# Input
# The first line contains an integer t
#  (1≤t≤104
# ) — the number of test cases in the input. Then t
#  test cases follow.
# 
# Each test case is a line containing an integer n
#  (1≤n≤104
# ).
# 
# Output
# Print t
#  answers to the test cases. Each answer must begin with an integer k
#  — the minimum number of summands. Next, k
#  terms must follow, each of which is a round number, and their sum is n
# . The terms can be printed in any order. If there are several answers, print any of them.
# 
# Example
# inputCopy
# 5
# 5009
# 7
# 9876
# 10000
# 10
# outputCopy
# 2
# 5000 9
# 1
# 7 
# 4
# 800 70 6 9000 
# 1
# 10000 
# 1
# 10
import sys


def solution(t: int) -> None:
    dividers: list = [10000, 1000, 100, 10, 1]
    for _ in range(t):
        n: int = int(sys.stdin.readline().rstrip())
        parts: list = []
        for divide in dividers:
            acc: int = n // divide
            if acc:
                parts.append(str(divide * acc))
            n %= divide
        print(len(parts))
        print(' '.join(parts))


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)

# Typing series #2 --> the [shift] function
# Been a while, but here's part 2!
# 
# You are given a string of lowercase letters and spaces that you need to type out. In the string there is a special function: [shift]. Once you encounter a [shift] , you capitalise the character right after it, as if you're actually holding the key. Return the final string .
# 
# 
# 
# e.g. [shift]john [shift]green return John Green (capitalise the j and g)
# 
# Walkthrough:
# 
# [shift]
# J capitalise the j
# Jo
# Joh
# John
# John[space]
# John G capitalise the g
# John Gr
# John Gre
# John Gree
# John Green
# 
# John Green
# 
# 
# 
# e.g. [shift]n[shift]o[shift]o[shift]o return NOOO (capitalise all the letters)
# 
# Walkthrough:
# 
# [shift]
# N capitalise the n
# NO capitalise the O
# NOO capitalise the O
# NOOO capitalise the O
# 
# NOOO
# 
# Notice if we want to capitalise a long string of letters, it will look very confusing viually. So, let's add two new functions, holdshift and unshift. It's self-explanatory.
# 
# 
# 
# Some examples:
# 
# [holdshift]uppercase[unshift] return UPPERCASE (holdshift all letters)
# 
# Walkthrough:
# 
# [holdshift]
# U
# UP
# UPP
# ...
# 
# UPPERCASE
# [unshift]
# 
# UPPERCASE
# 
# 
# 
# unshift can also apply to normal shift, but since normal shift only affects the character right after, unshift would have to be directly after normal shift for it to affect it.
# 
# Example: [shift][unshift]dont [shift][unshift]shift returns dont shift
# 
# Walkthrough:
# 
# [shift][unshift] cancels
# dont[space]
# [shift][unshift] cancels
# dont shift
# 
# dont shift
# 
# 
# 
# Whew! That was lengthy!
# 
# Ok, to summerise:
# 
# [shift] capitalises the character right after it ([shift]a -> A)
# [holdshift] capitalises all the characters after it until it reaches unshift ([holdshift]one[unshift]two -> ONEtwo)
# [unshift] releases shift (either [shift] or [holdshift])
# [shift][unshift]d returns d
# Other necessary things you might want to know:
# 
# Shifting a space is a space
# After a [holdshift], there is always an unshift, without any functions in between
# After unshifting, the next function called will not be an unshift (you can't release something if you're not pressing it)
# Things like [shift][holdshift] or [shift][shift] or [holdshift][shift]can't occur, but [shift][unshift] can
# The string will never start with [unshift] for obvious reasons
# Good luck! More examples in the example tests (The description took me way too long lol)
# 
# Please give this a good rating, I spent a really long time coding this.
# 
# Thank you!
def type_out(strng):
    lowercase: bool = True
    output: list[str] = []
    idx: int = 0
    while idx < len(strng):
        if strng[idx] == '[':
            if strng[idx:].startswith('[unshift]'):
                lowercase = True
                idx += 9
            elif strng[idx:].startswith('[holdshift]'):
                lowercase = False
                idx += 11
            else:
                idx += 7
                if strng[idx] != '[':
                    output.append(strng[idx].upper())
                    idx += 1
        else:
            output.append([strng[idx].upper(), strng[idx].lower()][lowercase])
            idx += 1
    return ''.join(output)

# 1636. Sort Array by Increasing Frequency
# Given an array of integers nums, sort the array in increasing order based on the frequency of the values. If multiple values have the same frequency, sort them in decreasing order.
#
# Return the sorted array.
#
#
#
# Example 1:
#
# Input: nums = [1,1,2,2,2,3]
# Output: [3,1,1,2,2,2]
# Explanation: '3' has a frequency of 1, '1' has a frequency of 2, and '2' has a frequency of 3.
# Example 2:
#
# Input: nums = [2,3,1,3,2]
# Output: [1,3,3,2,2]
# Explanation: '2' and '3' both have a frequency of 2, so they are sorted in decreasing order.
# Example 3:
#
# Input: nums = [-1,1,-6,4,5,-6,1,4,1]
# Output: [5,-1,4,4,-6,-6,1,1,1]
#
#
# Constraints:
#
# 1 <= nums.length <= 100
# -100 <= nums[i] <= 100
from collections import defaultdict
class Solution:
    def frequencySort(self, nums: List[int]) -> List[int]:
        frequence: dict[int, int] = defaultdict(int)
        for num in nums:
            frequence[num] += 1
        nums.sort(key=lambda x: (frequence[x], -x))
        return nums

    # A. Police Recruits
# A. Police Recruits
# time limit per test1 second
# memory limit per test256 megabytes
# inputstdin
# outputstdout
# The police department of your city has just started its journey. Initially, they don’t have any manpower. So, they started hiring new recruits in groups.
# 
# Meanwhile, crimes keeps occurring within the city. One member of the police force can investigate only one crime during his/her lifetime.
# 
# If there is no police officer free (isn't busy with crime) during the occurrence of a crime, it will go untreated.
# 
# Given the chronological order of crime occurrences and recruit hirings, find the number of crimes which will go untreated.
# 
# Input
# The first line of input will contain an integer n (1 ≤ n ≤ 105), the number of events. The next line will contain n space-separated integers.
# 
# If the integer is -1 then it means a crime has occurred. Otherwise, the integer will be positive, the number of officers recruited together at that time. No more than 10 officers will be recruited at a time.
# 
# Output
# Print a single integer, the number of crimes which will go untreated.
# 
# Examples
# inputCopy
# 3
# -1 -1 1
# outputCopy
# 2
# inputCopy
# 8
# 1 -1 1 -1 -1 1 1 1
# outputCopy
# 1
# inputCopy
# 11
# -1 -1 2 -1 -1 -1 -1 -1 -1 -1 -1
# outputCopy
# 8
# Note
# Lets consider the second example:
# 
# Firstly one person is hired.
# Then crime appears, the last hired person will investigate this crime.
# One more person is hired.
# One more crime appears, the last hired person will investigate this crime.
# Crime appears. There is no free policeman at the time, so this crime will go untreated.
# One more person is hired.
# One more person is hired.
# One more person is hired.
# The answer is one, as one crime (on step 5) will go untreated.
import sys


def solution(n: int, events: list) -> str:
    current: int = 0
    unreated: int = 0
    for event in events:
        if event < 0:
            if current > 0:
                current -= 1
            else:
                unreated += 1
        else:
            current += event
    return str(unreated)


if __name__ == '__main__':
    n: int = int(sys.stdin.readline().rstrip())
    events: list = list(map(int, sys.stdin.readline().rstrip().split()))
    sys.stdout.write(solution(n, events))

# Bear the Freelancer
# Story
# Bear the Freelancer charges clients on the hour, but he adjusts his rate depending on how close friends he is with his clients. For close friends, he charges $25 per hour, for his other friends he charges $50, for his acquaintances his hourly rate is $100, reaching $125 for all his other clients.
# 
# Input
# You’ll receive a list of lists, representing all the jobs Bear the Freelancer carried out for the month. Each array within the outer list is comprised of the number of hours worked, and the proximity to the client as a string, the possible values being 'Close Friend', 'Friend', 'Acquaintance', or any other string for the rest of his clients. The recognition of those three strings ('Close Friend', 'Friend', and 'Acquaintance') should be case insensitive.
# 
# Example
# 
# [[10, 'Close Friend'], [3, 'Acquaintance'], [7, 'Lead from web'], [6, 'Friend'], [2, 'From advertisements']]
# In this example, he'll be charging 10 hours at $25, 3 hours at $100, 7 hours at $125, 6 hours at $50, and 2 hours at $125, for a total of $1975.
# 
# Expected Output
# The total amount of dollars Bear the Freelancer has invoiced for his work. For an empty array, return 0.
# 
# Example
# 
# 1975
# FUNDAMENTALS
def bear_dollars(jobs):
    prices: dict[str, int] = {
        'Close Friend': 25, 'Friend': 50,
        'Acquaintance': 100, '': 125
    }
    total_cost: int = 0
    for event in jobs:
        if event[1].title() in prices:
            total_cost += event[0] * prices[event[1].title()]
        else: total_cost += event[0] * prices['']
    return total_cost

# 2191. Sort the Jumbled Numbers
# You are given a 0-indexed integer array mapping which represents the mapping rule of a shuffled decimal system. mapping[i] = j means digit i should be mapped to digit j in this system.
# 
# The mapped value of an integer is the new integer obtained by replacing each occurrence of digit i in the integer with mapping[i] for all 0 <= i <= 9.
# 
# You are also given another integer array nums. Return the array nums sorted in non-decreasing order based on the mapped values of its elements.
# 
# Notes:
# 
# Elements with the same mapped values should appear in the same relative order as in the input.
# The elements of nums should only be sorted based on their mapped values and not be replaced by them.
#  
# 
# Example 1:
# 
# Input: mapping = [8,9,4,0,2,1,3,5,7,6], nums = [991,338,38]
# Output: [338,38,991]
# Explanation: 
# Map the number 991 as follows:
# 1. mapping[9] = 6, so all occurrences of the digit 9 will become 6.
# 2. mapping[1] = 9, so all occurrences of the digit 1 will become 9.
# Therefore, the mapped value of 991 is 669.
# 338 maps to 007, or 7 after removing the leading zeros.
# 38 maps to 07, which is also 7 after removing leading zeros.
# Since 338 and 38 share the same mapped value, they should remain in the same relative order, so 338 comes before 38.
# Thus, the sorted array is [338,38,991].
# Example 2:
# 
# Input: mapping = [0,1,2,3,4,5,6,7,8,9], nums = [789,456,123]
# Output: [123,456,789]
# Explanation: 789 maps to 789, 456 maps to 456, and 123 maps to 123. Thus, the sorted array is [123,456,789].
#  
# 
# Constraints:
# 
# mapping.length == 10
# 0 <= mapping[i] <= 9
# All the values of mapping[i] are unique.
# 1 <= nums.length <= 3 * 104
# 0 <= nums[i] < 109
# Stable sort
# General idea:
# In python builting sorting methods, also called "Timsort". Sorting have "stable" property, what means, if some value have equal priority value they will sort in them relative order. In this case we should only use key for sorting as mapped value for each numver. For simplify mapping we can create helper function.
# Complexity
# Time complexity: O(NlogN)
# Space complexity: O(N)
# Code
class Solution:
    def convert(self, x: int, storage: list[int]) -> int:
        n: int = 0
        pieces: list[int] = []
        valid: bool = True
        while valid:
            acc: int = x % 10
            pieces.append(acc)
            x //= 10
            if x == 0: valid = False
        for piece in pieces[::-1]:
            n = n * 10 + storage[piece]
        return n

    def sortJumbled(self, mapping: List[int], nums: List[int]) -> List[int]:
        nums.sort(key=lambda x: self.convert(x, mapping))
        return nums

# Not Stable sort
# General idea:
# If we choose sorting algorithms that doesnt contain "stable" property. For saving relative order with same priority values of numbers we should create a hashmap to keep track (mapped value of number, his index) for each number in array. At the end just sorting by values of hashmap for each number.
# Complexity
# Time complexity: O(NlogN)
# Space complexity: O(N)
# Code
class Solution:
    def convert(self, x: int, storage: list[int]) -> int:
        n: int = 0
        pieces: list[int] = []
        valid: bool = True
        while valid:
            acc: int = x % 10
            pieces.append(acc)
            x //= 10
            if x == 0: valid = False
        for piece in pieces[::-1]:
            n = n * 10 + storage[piece]
        return n

    def sortJumbled(self, mapping: List[int], nums: List[int]) -> List[int]:
        jumbled: dict[int, tuple[int, int]] = {}
        for idx in range(len(nums)):
            jumbled[nums[idx]] = (self.convert(nums[idx], mapping), idx)
        nums.sort(key=lambda x: (jumbled[x][0], jumbled[x][1]))
        return nums

# A. The New Year: Meeting Friends
# A. The New Year: Meeting Friends
# time limit per test1 second
# memory limit per test256 megabytes
# inputstandard input
# outputstandard output
# There are three friend living on the straight line Ox in Lineland. The first friend lives at the point x1, the second friend lives at the point x2, and the third friend lives at the point x3. They plan to celebrate the New Year together, so they need to meet at one point. What is the minimum total distance they have to travel in order to meet at some point and celebrate the New Year?
# 
# It's guaranteed that the optimal answer is always integer.
# 
# Input
# The first line of the input contains three distinct integers x1, x2 and x3 (1 ≤ x1, x2, x3 ≤ 100) — the coordinates of the houses of the first, the second and the third friends respectively.
# 
# Output
# Print one integer — the minimum total distance the friends need to travel in order to meet together.
# 
# Examples
# inputCopy
# 7 1 4
# outputCopy
# 6
# inputCopy
# 30 20 10
# outputCopy
# 20
# Note
# In the first sample, friends should meet at the point 4. Thus, the first friend has to travel the distance of 3 (from the point 7 to the point 4), the second friend also has to travel the distance of 3 (from the point 1 to the point 4), while the third friend should not go anywhere because he lives at the point 4.
import sys


def solution(friends: list) -> str:
    total: int = float('inf')
    for x in range(1, 101):
        local_total: int = sum(abs(friend - x) for friend in friends)
        total = min(total, local_total)
    return str(total)


if __name__ == '__main__':
    friends: list = list(map(int, sys.stdin.readline().rstrip().split()))
    sys.stdout.write(solution(friends))
    
# Complete The Pattern #8 - Number Pyramid
# Task:
# You have to write a function pattern which creates the following Pattern(See Examples) upto n(parameter) number of rows.
# 
# Rules/Note:
# If the Argument is 0 or a Negative Integer then it should return "" i.e. empty string.
# All the lines in the pattern have same length i.e equal to the number of characters in the last line.
# Range of n is (-∞,100]
# Examples:
# pattern(5):
# 
#     1    
#    121   
#   12321  
#  1234321 
# 123454321
# pattern(10):
# 
#          1         
#         121        
#        12321       
#       1234321      
#      123454321     
#     12345654321    
#    1234567654321   
#   123456787654321  
#  12345678987654321 
# 1234567890987654321
# pattern(15):
# 
#               1              
#              121             
#             12321            
#            1234321           
#           123454321          
#          12345654321         
#         1234567654321        
#        123456787654321       
#       12345678987654321      
#      1234567890987654321     
#     123456789010987654321    
#    12345678901210987654321   
#   1234567890123210987654321  
#  123456789012343210987654321 
# 12345678901234543210987654321
# pattern(20):
# 
#                    1                   
#                   121                  
#                  12321                 
#                 1234321                
#                123454321               
#               12345654321              
#              1234567654321             
#             123456787654321            
#            12345678987654321           
#           1234567890987654321          
#          123456789010987654321         
#         12345678901210987654321        
#        1234567890123210987654321       
#       123456789012343210987654321      
#      12345678901234543210987654321     
#     1234567890123456543210987654321    
#    123456789012345676543210987654321   
#   12345678901234567876543210987654321  
#  1234567890123456789876543210987654321 
# 123456789012345678909876543210987654321
# ###Amazing Fact:
# 
# Hint: Use \n in string to jump to next line
# 
# ASCII ARTFUNDAMENTALS
def pattern(n):
    if n <= 0: return ''
    lines: list[str] = []
    boundary: int = n * 2 - 1
    sequence: str = ''
    for line in range(1, n + 1):
        sequence += str(line % 100 % 10)
        current_side: str = ' ' * ((boundary - max((line * 2 - 1), 1)) // 2)
        lines.append(current_side + sequence + sequence[::-1][1::] + current_side)
    return '\n'.join(lines)

# 912. Sort an Array
# Given an array of integers nums, sort the array in ascending order and return it.
#
# You must solve the problem without using any built-in functions in O(nlog(n)) time complexity and with the smallest space complexity possible.
#
#
#
# Example 1:
#
# Input: nums = [5,2,3,1]
# Output: [1,2,3,5]
# Explanation: After sorting the array, the positions of some numbers are not changed (for example, 2 and 3), while the positions of other numbers are changed (for example, 1 and 5).
# Example 2:
#
# Input: nums = [5,1,1,2,0,0]
# Output: [0,0,1,1,2,5]
# Explanation: Note that the values of nums are not necessairly unique.
#
#
# Constraints:
#
# 1 <= nums.length <= 5 * 104
# -5 * 104 <= nums[i] <= 5 * 104
# Merge Sort
# Complexity
# Time complexity: O(NlogN)
# Space complexity: O(N)
# Code
class Solution:
    def merge_sort(self, arr: list[int]) -> list[int]:
        n: int = len(arr)
        if n <= 1:
            return arr
        middle: int = n >> 1
        left_part: list[int] = self.merge_sort(arr[:middle])
        right_part: list[int] = self.merge_sort(arr[middle:])
        output: list[int] = []
        n_left, n_right = len(left_part), len(right_part)
        left_idx = right_idx = 0
        while left_idx < n_left and right_idx < n_right:
            if left_part[left_idx] < right_part[right_idx]:
                output.append(left_part[left_idx])
                left_idx += 1
            else:
                output.append(right_part[right_idx])
                right_idx += 1
        return output + left_part[left_idx:] + right_part[right_idx:]

    def sortArray(self, nums: List[int]) -> List[int]:
        return self.merge_sort(nums)

# Counting Sort
# Complexity
# Time complexity: O(N)
# Space complexity: O(N)
# Code
class Solution:
    def counting_sort(self, arr: list[int]) -> list[int]:
        storage: list[int] = [0] * 100_001
        for num in arr:
            storage[num + 50_000] += 1
        output: list[int] = []
        for num in range(100_001):
            if storage[num]:
                output.extend([num - 50_000] * storage[num])
        return output

    def sortArray(self, nums: List[int]) -> List[int]:
        return self.counting_sort(nums)
        
# B. Vanya and Lanterns
# B. Vanya and Lanterns
# time limit per test1 second
# memory limit per test256 megabytes
# inputstdin
# outputstdout
# Vanya walks late at night along a straight street of length l, lit by n lanterns. Consider the coordinate system with the beginning of the street corresponding to the point 0, and its end corresponding to the point l. Then the i-th lantern is at the point ai. The lantern lights all points of the street that are at the distance of at most d from it, where d is some positive number, common for all lanterns.
# 
# Vanya wonders: what is the minimum light radius d should the lanterns have to light the whole street?
# 
# Input
# The first line contains two integers n, l (1 ≤ n ≤ 1000, 1 ≤ l ≤ 109) — the number of lanterns and the length of the street respectively.
# 
# The next line contains n integers ai (0 ≤ ai ≤ l). Multiple lanterns can be located at the same point. The lanterns may be located at the ends of the street.
# 
# Output
# Print the minimum light radius d, needed to light the whole street. The answer will be considered correct if its absolute or relative error doesn't exceed 10 - 9.
# 
# Examples
# inputCopy
# 7 15
# 15 5 3 7 9 14 0
# outputCopy
# 2.5000000000
# inputCopy
# 2 5
# 2 5
# outputCopy
# 2.0000000000
# Note
# Consider the second sample. At d = 2 the first lantern will light the segment [0, 4] of the street, and the second lantern will light segment [3, 5]. Thus, the whole street will be lit.
import sys


def solution(n_lanterns: int, length_of_street: int, lanterns: list) -> str:
    lanterns = sorted(set(lanterns))
    diffs: list = []
    diffs.append(lanterns[0] if lanterns[0] != 0 else 0)
    for x, y in zip(lanterns[1:], lanterns):
        diffs.append((x - y) / 2)
    if lanterns[-1] != length_of_street:
        diffs.append(length_of_street - lanterns[-1])
    diffs.sort()
    return str(diffs[-1])


if __name__ == '__main__':
    n_lanterns, length_of_street = map(int, sys.stdin.readline().rstrip().split())
    lanterns: list = list(map(int, sys.stdin.readline().rstrip().split()))
    sys.stdout.write(solution(n_lanterns, length_of_street, lanterns))

# Manage the Robot Factory: Day 1
# Explanation
# It's your first day in the robot factory and your supervisor thinks that you should start with an easy task. So you are responsible for purchasing raw materials needed to produce the robots.
# 
# A complete robot weights 50 kilogram. Iron is the only material needed to create a robot. All iron is inserted in the first machine; the output of this machine is the input for the next one, and so on. The whole process is sequential. Unfortunately not all machines are first class, so a given percentage of their inputs are destroyed during processing.
# 
# Task
# You need to figure out how many kilograms of iron you need to buy to build the requested number of robots.
# 
# Example
# Three machines are used to create a robot. Each of them produces 10% scrap. Your target is to deliver 90 robots.
# The method will be called with the following parameters:
# 
# CalculateScrap(scrapOfTheUsedMachines, numberOfRobotsToProduce)
# CalculateScrap(int[] { 10, 10, 10 }, 90)
# Assumptions
# The scrap is less than 100%.
# The scrap is never negative.
# There is at least one machine in the manufacturing line.
# Except for scrap there is no material lost during manufacturing.
# The number of produced robots is always a positive number.
# You can only buy full kilograms of iron.
# ALGORITHMS
def calculate_scrap(scraps, number_of_robots):
    start: int = 50
    for per in scraps[::-1]:
        one_per: float = start / (100 - per)
        tot: float = per * one_per
        start += tot
    ans: float = start * number_of_robots
    return int(ans) + 1 if int(ans) != ans else ans

# 832. Flipping an Image
# Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.
#
# To flip an image horizontally means that each row of the image is reversed.
#
# For example, flipping [1,1,0] horizontally results in [0,1,1].
# To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.
#
# For example, inverting [0,1,1] results in [1,0,0].
#
#
# Example 1:
#
# Input: image = [[1,1,0],[1,0,1],[0,0,0]]
# Output: [[1,0,0],[0,1,0],[1,1,1]]
# Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].
# Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]]
# Example 2:
#
# Input: image = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]
# Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
# Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].
# Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
#
#
# Constraints:
#
# n == image.length
# n == image[i].length
# 1 <= n <= 20
# images[i][j] is either 0 or 1.
class Solution:
    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:
        for row in range(len(image)):
            image[row] = [~ceil & 1 for ceil in image[row][::-1]]
        return image
        
# 2331. Evaluate Boolean Binary Tree
# You are given the root of a full binary tree with the following properties:
# 
# Leaf nodes have either the value 0 or 1, where 0 represents False and 1 represents True.
# Non-leaf nodes have either the value 2 or 3, where 2 represents the boolean OR and 3 represents the boolean AND.
# The evaluation of a node is as follows:
# 
# If the node is a leaf node, the evaluation is the value of the node, i.e. True or False.
# Otherwise, evaluate the node's two children and apply the boolean operation of its value with the children's evaluations.
# Return the boolean result of evaluating the root node.
# 
# A full binary tree is a binary tree where each node has either 0 or 2 children.
# 
# A leaf node is a node that has zero children.
# 
#  
# 
# Example 1:
# 
# 
# Input: root = [2,1,3,null,null,0,1]
# Output: true
# Explanation: The above diagram illustrates the evaluation process.
# The AND node evaluates to False AND True = False.
# The OR node evaluates to True OR False = True.
# The root node evaluates to True, so we return true.
# Example 2:
# 
# Input: root = [0]
# Output: false
# Explanation: The root node is a leaf node and it evaluates to false, so we return false.
#  
# 
# Constraints:
# 
# The number of nodes in the tree is in the range [1, 1000].
# 0 <= Node.val <= 3
# Every node has either 0 or 2 children.
# Leaf nodes have a value of 0 or 1.
# Non-leaf nodes have a value of 2 or 3.
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def evaluateTree(self, root: Optional[TreeNode]) -> bool:
        if not root.left and not root.right:
            return bool(root.val)
        if root.val == 2:
            return self.evaluateTree(root.left) or self.evaluateTree(root.right)
        else:
            return self.evaluateTree(root.left) and self.evaluateTree(root.right)

# 1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance
# There are n cities numbered from 0 to n-1. Given the array edges where edges[i] = [fromi, toi, weighti] represents a bidirectional and weighted edge between cities fromi and toi, and given the integer distanceThreshold.
# 
# Return the city with the smallest number of cities that are reachable through some path and whose distance is at most distanceThreshold, If there are multiple such cities, return the city with the greatest number.
# 
# Notice that the distance of a path connecting cities i and j is equal to the sum of the edges' weights along that path.
# 
#  
# 
# Example 1:
# 
# 
# Input: n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4
# Output: 3
# Explanation: The figure above describes the graph. 
# The neighboring cities at a distanceThreshold = 4 for each city are:
# City 0 -> [City 1, City 2] 
# City 1 -> [City 0, City 2, City 3] 
# City 2 -> [City 0, City 1, City 3] 
# City 3 -> [City 1, City 2] 
# Cities 0 and 3 have 2 neighboring cities at a distanceThreshold = 4, but we have to return city 3 since it has the greatest number.
# Example 2:
# 
# 
# Input: n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2
# Output: 0
# Explanation: The figure above describes the graph. 
# The neighboring cities at a distanceThreshold = 2 for each city are:
# City 0 -> [City 1] 
# City 1 -> [City 0, City 4] 
# City 2 -> [City 3, City 4] 
# City 3 -> [City 2, City 4]
# City 4 -> [City 1, City 2, City 3] 
# The city 0 has 1 neighboring city at a distanceThreshold = 2.
#  
# 
# Constraints:
# 
# 2 <= n <= 100
# 1 <= edges.length <= n * (n - 1) / 2
# edges[i].length == 3
# 0 <= fromi < toi < n
# 1 <= weighti, distanceThreshold <= 10^4
# All pairs (fromi, toi) are distinct.
import heapq
class Solution:
    def dijkstra(self, source: int, paths: list[list[int, int]], boundary: int) -> int:
        destinations: dict[int, int] = dict()
        score: int = 0
        min_heap: list[tuple[int, int]] = [(0, source)]
        while min_heap:
            cur_weight, cur_vertex = heapq.heappop(min_heap)
            if cur_vertex in destinations: continue
            destinations[cur_vertex] = cur_weight
            if cur_weight <= boundary: score += 1
            for neighbor in paths[cur_vertex]:
                if neighbor[0] in destinations: continue
                heapq.heappush(min_heap, (cur_weight + neighbor[1], neighbor[0]))
        return score - 1

    def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:
        # Represent adjacency list: vertex = [i1, i2, ..., in]
        # Where i = [neighbor, weight]
        vertexes: dict[int, list[list[int, int]]] = dict()
        for vertex in range(n):
            if vertex not in vertexes:
                vertexes[vertex] = []
        # Fill the adjacency list
        for path in edges:
            source, destination, weight = path
            if weight > distanceThreshold: continue
            vertexes[source].append([destination, weight])
            vertexes[destination].append([source, weight])
        # Calculate maximum vertex with minimum possible neighbors
        min_edge = min_neighbors = float('inf')
        for vertex in range(n):
            cost: int = self.dijkstra(vertex, vertexes, distanceThreshold)
            if cost <= min_neighbors:
                min_edge, min_neighbors = vertex, cost

        return min_edge

# A. Buy a Shovel
# A. Buy a Shovel
# time limit per test1 second
# memory limit per test256 megabytes
# Polycarp urgently needs a shovel! He comes to the shop and chooses an appropriate one. The shovel that Policarp chooses is sold for k burles. Assume that there is an unlimited number of such shovels in the shop.
# 
# In his pocket Polycarp has an unlimited number of "10-burle coins" and exactly one coin of r burles (1 ≤ r ≤ 9).
# 
# What is the minimum number of shovels Polycarp has to buy so that he can pay for the purchase without any change? It is obvious that he can pay for 10 shovels without any change (by paying the requied amount of 10-burle coins and not using the coin of r burles). But perhaps he can buy fewer shovels and pay without any change. Note that Polycarp should buy at least one shovel.
# 
# Input
# The single line of input contains two integers k and r (1 ≤ k ≤ 1000, 1 ≤ r ≤ 9) — the price of one shovel and the denomination of the coin in Polycarp's pocket that is different from "10-burle coins".
# 
# Remember that he has an unlimited number of coins in the denomination of 10, that is, Polycarp has enough money to buy any number of shovels.
# 
# Output
# Print the required minimum number of shovels Polycarp has to buy so that he can pay for them without any change.
# 
# Examples
# inputCopy
# 117 3
# outputCopy
# 9
# inputCopy
# 237 7
# outputCopy
# 1
# inputCopy
# 15 2
# outputCopy
# 2
# Note
# In the first example Polycarp can buy 9 shovels and pay 9·117 = 1053 burles. Indeed, he can pay this sum by using 10-burle coins and one 3-burle coin. He can't buy fewer shovels without any change.
# 
# In the second example it is enough for Polycarp to buy one shovel.
# 
# In the third example Polycarp should buy two shovels and pay 2·15 = 30 burles. It is obvious that he can pay this sum without any change.
import sys


def solution(k: int, r: int) -> str:
    shovel_count: int = 1
    shovel_cost: int = k
    while (d := shovel_cost - shovel_cost // 10 * 10) != 0 and d != r:
        shovel_cost += k
        shovel_count += 1
    return str(shovel_count)


if __name__ == '__main__':
    k, r = map(int, sys.stdin.readline().rstrip().split())
    sys.stdout.write(solution(k, r))

# Readability is King
# We will use the Flesch–Kincaid Grade Level to evaluate the readability of a piece of text. This grade level is an approximation for what schoolchildren are able to understand a piece of text. For example, a piece of text with a grade level of 7 can be read by seventh-graders and beyond.
#
# The way to calculate the grade level is as follows:
#
# (0.39 * average number of words per sentence) + (11.8 * average number of syllables per word) - 15.59
# Write a function that will calculate the Flesch–Kincaid grade level for any given string. Return the grade level rounded to two decimal points.
#
# Ignore hyphens, dashes, apostrophes, parentheses, ellipses and abbreviations.
#
# Remember that the text can contain more than one sentence: code accordingly!
#
# HINT: Count the number of vowels as an approximation for the number of syllables, but count groups of vowels as one (e.g. deal is one syllable). Do not count y as a vowel!
#
# Example
# "The turtle is leaving." ==> 3.67
# The average number of words per sentence is 4 and the average number of syllables per word is 1.5. The score is then (0.39 * 4) +  (11.8 * 1.5) - 15.59 = 3.67
#
# MATHEMATICSALGORITHMS
def flesch_kincaid(text):
    sentences: list[str] = [text]
    for sep in '!?.':
        after_sep: list[str] = []
        for seq in sentences:
            after_sep.extend([i for i in seq.split(sep) if i])
        sentences = after_sep

    sillables: list[int] = []
    average_words: float = sum(len(seq.split()) for seq in sentences) / len(sentences)
    for sentence in sentences:
        for word in sentence.split():
            sillable: int = 0
            char: int = 0
            flag: bool = False
            while char < len(word):
                if word[char] in 'AEOIUaeoiu':
                    if flag:
                        char += 1
                    else:
                        sillable += 1
                        flag = True
                else:
                    char += 1
                    flag = False
            sillables.append(sillable)

    average_sillables: float = sum(sillables) / len(sillables)
    return round((0.39 * average_words) + (11.8 * average_sillables) - 15.59, 2)

# 2976. Minimum Cost to Convert String I
# You are given two 0-indexed strings source and target, both of length n and consisting of lowercase English letters. You are also given two 0-indexed character arrays original and changed, and an integer array cost, where cost[i] represents the cost of changing the character original[i] to the character changed[i].
#
# You start with the string source. In one operation, you can pick a character x from the string and change it to the character y at a cost of z if there exists any index j such that cost[j] == z, original[j] == x, and changed[j] == y.
#
# Return the minimum cost to convert the string source to the string target using any number of operations. If it is impossible to convert source to target, return -1.
#
# Note that there may exist indices i, j such that original[j] == original[i] and changed[j] == changed[i].
#
#
#
# Example 1:
#
# Input: source = "abcd", target = "acbe", original = ["a","b","c","c","e","d"], changed = ["b","c","b","e","b","e"], cost = [2,5,5,1,2,20]
# Output: 28
# Explanation: To convert the string "abcd" to string "acbe":
# - Change value at index 1 from 'b' to 'c' at a cost of 5.
# - Change value at index 2 from 'c' to 'e' at a cost of 1.
# - Change value at index 2 from 'e' to 'b' at a cost of 2.
# - Change value at index 3 from 'd' to 'e' at a cost of 20.
# The total cost incurred is 5 + 1 + 2 + 20 = 28.
# It can be shown that this is the minimum possible cost.
# Example 2:
#
# Input: source = "aaaa", target = "bbbb", original = ["a","c"], changed = ["c","b"], cost = [1,2]
# Output: 12
# Explanation: To change the character 'a' to 'b' change the character 'a' to 'c' at a cost of 1, followed by changing the character 'c' to 'b' at a cost of 2, for a total cost of 1 + 2 = 3. To change all occurrences of 'a' to 'b', a total cost of 3 * 4 = 12 is incurred.
# Example 3:
#
# Input: source = "abcd", target = "abce", original = ["a"], changed = ["e"], cost = [10000]
# Output: -1
# Explanation: It is impossible to convert source to target because the value at index 3 cannot be changed from 'd' to 'e'.
#
#
# Constraints:
#
# 1 <= source.length == target.length <= 105
# source, target consist of lowercase English letters.
# 1 <= cost.length == original.length == changed.length <= 2000
# original[i], changed[i] are lowercase English letters.
# 1 <= cost[i] <= 106
# original[i] != changed[i]
# Solution Dijkstra Memoization HashMap Graph String O(N ElogV M) O(V + E)
import heapq
from collections import defaultdict
class Solution:
    def dijkstra(self, vertex, paths, target):
        min_heap: list[tuple(int, str)] = [(0, vertex)]
        seen: set[int] = set()
        while min_heap:
            cur_weight, cur_vertex = heapq.heappop(min_heap)
            if cur_vertex == target: return cur_weight
            if cur_vertex in seen: continue
            seen.add(cur_vertex)
            for neighbor in paths.get(cur_vertex, []):
                neighbor_vertex, neighbor_weight = neighbor, paths[cur_vertex][neighbor]
                if neighbor_vertex in seen: continue
                heapq.heappush(min_heap, [cur_weight + neighbor_weight, neighbor_vertex])
        return -1

    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:
        adj_list: dict[str, dict[str, int]] = defaultdict(dict)
        for idx in range(len(original)):
            edges = adj_list[original[idx]]
            if changed[idx] in edges:
                edges[changed[idx]] = min(cost[idx], edges[changed[idx]])
            else:
                edges[changed[idx]] = cost[idx]
        memo: dict[tuple[str, str], int] = dict()
        total_cost = 0
        for idx in range(len(source)):
            if source[idx] != target[idx]:
                if (source[idx], target[idx]) in memo:
                    cost = memo[(source[idx], target[idx])]
                else:
                    cost = self.dijkstra(source[idx], adj_list, target[idx])
                    if cost == -1: return -1
                    memo[(source[idx], target[idx])] = cost
                total_cost += cost
        return total_cost

# A. New Year and Hurry
# A. New Year and Hurry
# time limit per test1 second
# memory limit per test256 megabytes
# Limak is going to participate in a contest on the last day of the 2016. The contest will start at 20:00 and will last four hours, exactly until midnight. There will be n problems, sorted by difficulty, i.e. problem 1 is the easiest and problem n is the hardest. Limak knows it will take him 5·i minutes to solve the i-th problem.
# 
# Limak's friends organize a New Year's Eve party and Limak wants to be there at midnight or earlier. He needs k minutes to get there from his house, where he will participate in the contest first.
# 
# How many problems can Limak solve if he wants to make it to the party?
# 
# Input
# The only line of the input contains two integers n and k (1 ≤ n ≤ 10, 1 ≤ k ≤ 240) — the number of the problems in the contest and the number of minutes Limak needs to get to the party from his house.
# 
# Output
# Print one integer, denoting the maximum possible number of problems Limak can solve so that he could get to the party at midnight or earlier.
# 
# Examples
# inputCopy
# 3 222
# outputCopy
# 2
# inputCopy
# 4 190
# outputCopy
# 4
# inputCopy
# 7 1
# outputCopy
# 7
# Note
# In the first sample, there are 3 problems and Limak needs 222 minutes to get to the party. The three problems require 5, 10 and 15 minutes respectively. Limak can spend 5 + 10 = 15 minutes to solve first two problems. Then, at 20:15 he can leave his house to get to the party at 23:57 (after 222 minutes). In this scenario Limak would solve 2 problems. He doesn't have enough time to solve 3 problems so the answer is 2.
# 
# In the second sample, Limak can solve all 4 problems in 5 + 10 + 15 + 20 = 50 minutes. At 20:50 he will leave the house and go to the party. He will get there exactly at midnight.
# 
# In the third sample, Limak needs only 1 minute to get to the party. He has enough time to solve all 7 problems.
import sys


def solution(n: int, k: int) -> str:
    total_minutes: int = 240 - k
    tasks_done: int = 0
    for i in range(1, n + 1):
        if total_minutes - 5 * i >= 0:
            tasks_done += 1
            total_minutes -= 5 * i
        else:
            break
    return str(tasks_done)


if __name__ == '__main__':
    n, k = map(int, sys.stdin.readline().rstrip().split())
    sys.stdout.write(solution(n, k))


# #6 Matrices: How Many Matrices Do These Elements Produce?
# When we have a 2x2 square matrix we may have up to 24 different ones changing the positions of the elements.
# 
# We show some of them
# 
# a  b   a  b    a  c    a  c   a  d    a  d    b  a    b  a
# c  d   d  c    d  b    b  d   b  c    c  b    c  d    d  c
# You may think to generate the remaining ones until completing the set of 24 matrices.
# 
# Given a certain matrix of numbers, that may be repeated or not, calculate the total number of possible matrices that may be generated, changing the position of the elements.
# 
# E.g: Case one
# 
# A = [[1,2,3],
#      [3,4,5]]   #a 2x3 rectangle matrix with number 3 twice
# generates a set of 360 different matrices
# 
# Case two
# 
# A = [[1,1,1], 
#      [2,2,3], 
#      [3,3,3]]
# generates a set of 1260 different matrices.
# 
# Case three
# 
# A = [[1,2,3],
#      [4,5,6],
#      [7,8,9]]
# generates a set of 362880 different matrices
# 
# This kata is not meant to apply a brute force algorithm to try to count the total amount of marices.
# 
# Features of The Random Tests
# 
# number of tests = 100
# 2 ≤ m ≤ 9
# 2 ≤ n ≤ 9
# Enjoy it!
# 
# Available only in Python 2, Javascript and Ruby by the moment.
# 
# PERMUTATIONSMATRIXDATA STRUCTURESFUNDAMENTALS
from math import factorial, prod
def count_perms(matrix):
    storage: dict[int, int] = dict()
    for row in matrix:
        for ceil in row:
            storage[ceil] = storage.get(ceil, 0) + 1
    total_repetive: int = factorial(len(matrix) * len(matrix[0]))
    needed: int = prod(factorial(x) for x in storage.values())
    return total_repetive // needed

# 100. Same Tree
# Given the roots of two binary trees p and q, write a function to check if they are the same or not.
# 
# Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.
# 
#  
# 
# Example 1:
# 
# 
# Input: p = [1,2,3], q = [1,2,3]
# Output: true
# Example 2:
# 
# 
# Input: p = [1,2], q = [1,null,2]
# Output: false
# Example 3:
# 
# 
# Input: p = [1,2,1], q = [1,1,2]
# Output: false
#  
# 
# Constraints:
# 
# The number of nodes in both trees is in the range [0, 100].
# -104 <= Node.val <= 104
# DFS
# Complexity
# Time complexity: O(N)
# Space complexity: O(N)
# Code
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        if not p and not q: return True
        if (p is None and q) or (p and q is None): return False
        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
# BFS
# Complexity
# Time complexity: O(N)
# Space complexity: O(N)
# Code
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        current_p_nodes: list[TreeNode] = [p]
        current_q_nodes: list[TreeNode] = [q]

        next_p_nodes: list[TreeNode] = []
        next_q_nodes: list[TreeNode] = []
        while current_p_nodes and current_q_nodes:
            for _ in range(len(current_p_nodes)):
                p_node, q_node = current_p_nodes.pop(), current_q_nodes.pop()
                if p_node == q_node == None: continue
                if (p_node is None and q_node) or (p_node and q_node is None):
                    return False
                if p_node.val != q_node.val: return False

                next_p_nodes.append(p_node.left)
                next_p_nodes.append(p_node.right)
                next_q_nodes.append(q_node.left)
                next_q_nodes.append(q_node.right)

            current_p_nodes = next_p_nodes
            current_q_nodes = next_q_nodes

        return current_p_nodes == current_q_nodes

# A. I_love_%username%
# A. I_love_%username%
# time limit per test2 seconds
# memory limit per test256 megabytes
# Vasya adores sport programming. He can't write programs but he loves to watch the contests' progress. Vasya even has a favorite coder and Vasya pays special attention to him.
#
# One day Vasya decided to collect the results of all contests where his favorite coder participated and track the progress of his coolness. For each contest where this coder participated, he wrote out a single non-negative number — the number of points his favorite coder earned in the contest. Vasya wrote out the points for the contest in the order, in which the contests run (naturally, no two contests ran simultaneously).
#
# Vasya considers a coder's performance in a contest amazing in two situations: he can break either his best or his worst performance record. First, it is amazing if during the contest the coder earns strictly more points that he earned on each past contest. Second, it is amazing if during the contest the coder earns strictly less points that he earned on each past contest. A coder's first contest isn't considered amazing. Now he wants to count the number of amazing performances the coder had throughout his whole history of participating in contests. But the list of earned points turned out long and Vasya can't code... That's why he asks you to help him.
#
# Input
# The first line contains the single integer n (1 ≤ n ≤ 1000) — the number of contests where the coder participated.
#
# The next line contains n space-separated non-negative integer numbers — they are the points which the coder has earned. The points are given in the chronological order. All points do not exceed 10000.
#
# Output
# Print the single number — the number of amazing performances the coder has had during his whole history of participating in the contests.
#
# Examples
# inputCopy
# 5
# 100 50 200 150 200
# outputCopy
# 2
# inputCopy
# 10
# 4664 6496 5814 7010 5762 5736 6944 4850 3698 7242
# outputCopy
# 4
# Note
# In the first sample the performances number 2 and 3 are amazing.
#
# In the second sample the performances number 2, 4, 9 and 10 are amazing.
import sys


def solution(n: int, contests: list) -> str:
    max_rate: int = contests[0]
    min_rate: int = contests[0]
    amaizing: int = 0
    for rate in range(1, n):
        if contests[rate] > max_rate:
            max_rate = contests[rate]
            amaizing += 1
        elif contests[rate] < min_rate:
            min_rate = contests[rate]
            amaizing += 1
    return str(amaizing)


if __name__ == '__main__':
    n: int = int(sys.stdin.readline().rstrip())
    contests: list = list(map(int, sys.stdin.readline().rstrip().split()))
    sys.stdout.write(solution(n, contests))

# Color Choice
# You know combinations: for example, if you take 5 cards from a 52 cards deck you have 2,598,960 different combinations.
#
# In mathematics the number of x combinations you can take from a set of n elements is called the binomial coefficient of n and x, or more often n choose x. The formula to compute n choose x is:
#
# n! / (x! * (n - x)!)
#
# where ! is the factorial operator.
#
# You are a renowned poster designer and painter. You are asked to provide 6 posters all having the same design each in 2 colors. Posters must all have a different color combination and you have the choice of 4 colors: red, blue, yellow, green. How many colors can you choose for each poster?
#
# The answer is two since 4 choose 2 = 6. The combinations will be: {red, blue}, {red, yellow}, {red, green}, {blue, yellow}, {blue, green}, {yellow, green}.
#
# Now same question but you have 35 posters to provide and 7 colors available. How many colors for each poster? If you take combinations 7 choose 2 you will get 21 with the above formula. But 21 schemes aren't enough for 35 posters. If you take 7 choose 5 combinations you will get 21 too. Fortunately if you take 7 choose 3 or 7 choose 4 combinations you get 35 and so each poster will have a different combination of 3 colors or 4 colors. You will take 3 colors because it's less expensive.
#
# Hence the problem:
# Knowing m (number of posters to design) and n (total number of available colors), let us search x, the number of colors for each poster so that each poster has a unique combination of colors and the number of combinations is exactly the same as the number of posters m.
#
# In other words, you must find x such that:
#
# n choose x = m
#
# for a given m >= 0 and a given n > 0. If there are several solutions, return the smallest. If there are no solutions, return -1.
#
# Examples:
# (m =  6, n = 4) -->  2
# (m =  4, n = 4) -->  1
# (m =  4, n = 2) --> -1
# (m = 35, n = 7) -->  3
# (m = 36, n = 7) --> -1
#
# a = 47129212243960
# (m = a,     n = 50) --> 20
# (m = a + 1, n = 50) --> -1
# COMBINATORICSMATHEMATICS
 from math import factorial
def checkchoose(m, n):
    for x in range(n + 1):
        b_c: int = int(factorial(n) // (factorial(x) * factorial(n - x)))
        if b_c == m: return x
    return -1

# 2045. Second Minimum Time to Reach Destination
# A city is represented as a bi-directional connected graph with n vertices where each vertex is labeled from 1 to n (inclusive). The edges in the graph are represented as a 2D integer array edges, where each edges[i] = [ui, vi] denotes a bi-directional edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself. The time taken to traverse any edge is time minutes.
#
# Each vertex has a traffic signal which changes its color from green to red and vice versa every change minutes. All signals change at the same time. You can enter a vertex at any time, but can leave a vertex only when the signal is green. You cannot wait at a vertex if the signal is green.
#
# The second minimum value is defined as the smallest value strictly larger than the minimum value.
#
# For example the second minimum value of [2, 3, 4] is 3, and the second minimum value of [2, 2, 4] is 4.
# Given n, edges, time, and change, return the second minimum time it will take to go from vertex 1 to vertex n.
#
# Notes:
#
# You can go through any vertex any number of times, including 1 and n.
# You can assume that when the journey starts, all signals have just turned green.
#
#
# Example 1:
#
#        
# Input: n = 5, edges = [[1,2],[1,3],[1,4],[3,4],[4,5]], time = 3, change = 5
# Output: 13
# Explanation:
# The figure on the left shows the given graph.
# The blue path in the figure on the right is the minimum time path.
# The time taken is:
# - Start at 1, time elapsed=0
# - 1 -> 4: 3 minutes, time elapsed=3
# - 4 -> 5: 3 minutes, time elapsed=6
# Hence the minimum time needed is 6 minutes.
#
# The red path shows the path to get the second minimum time.
# - Start at 1, time elapsed=0
# - 1 -> 3: 3 minutes, time elapsed=3
# - 3 -> 4: 3 minutes, time elapsed=6
# - Wait at 4 for 4 minutes, time elapsed=10
# - 4 -> 5: 3 minutes, time elapsed=13
# Hence the second minimum time is 13 minutes.
# Example 2:
#
#
# Input: n = 2, edges = [[1,2]], time = 3, change = 2
# Output: 11
# Explanation:
# The minimum time path is 1 -> 2 with time = 3 minutes.
# The second minimum time path is 1 -> 2 -> 1 -> 2 with time = 11 minutes.
#
#
# Constraints:
#
# 2 <= n <= 104
# n - 1 <= edges.length <= min(2 * 104, n * (n - 1) / 2)
# edges[i].length == 2
# 1 <= ui, vi <= n
# ui != vi
# There are no duplicate edges.
# Each vertex can be reached directly or indirectly from every other vertex.
# 1 <= time, change <= 103
from collections import deque


class Solution:
    def validate_time(self, current_time: int, change: int) -> int:
        whole: int = current_time // change
        # If current whole part is odd, it means
        # that we on red signal
        if whole & 1:
            return change * (whole + 1) - current_time if current_time % change != 0 else change
        return 0

    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:
        # Create adjacency list
        adj_list: list[list[int]] = [[] for _ in range(n + 1)]
        for u, v in edges:
            adj_list[u].append(v)
            adj_list[v].append(u)

        edges = deque([(1, False)])
        # Initial time to destination all vertex
        first_time_seen: list[int] = [None] * (n + 1)
        # Initial time to destination all vertex
        second_time_seen: list[int] = [None] * (n + 1)
        # Start with vertex1 and set destination time to "0"
        first_time_seen[1] = 0
        while edges:
            cur_edge, seen = edges.popleft()
            current_time = first_time_seen[cur_edge] if not seen else second_time_seen[cur_edge]
            # Make a step to all neighbor edges
            current_time += self.validate_time(current_time, change) + time

            for neighbor in adj_list[cur_edge]:
                # If we not see neighbor edge
                if first_time_seen[neighbor] == None:
                    first_time_seen[neighbor] = current_time
                    edges.append((neighbor, False))
                # If we already seen the neighbor edge
                # and current time of destination is strickly more than previouse time destination
                # For case when: second shortest path can have equal time with first shortest path
                elif second_time_seen[neighbor] == None and first_time_seen[neighbor] != current_time:
                    # If we found last edge(meaning traversing from 1 to n)
                    if neighbor == n: return current_time
                    second_time_seen[neighbor] = current_time
                    edges.append((neighbor, True))
        return 0

# 3232. Find if Digit Game Can Be Won
# You are given an array of positive integers nums.
#
# Alice and Bob are playing a game. In the game, Alice can choose either all single-digit numbers or all double-digit numbers from nums, and the rest of the numbers are given to Bob. Alice wins if the sum of her numbers is strictly greater than the sum of Bob's numbers.
#
# Return true if Alice can win this game, otherwise, return false.
#
#
#
# Example 1:
#
# Input: nums = [1,2,3,4,10]
#
# Output: false
#
# Explanation:
#
# Alice cannot win by choosing either single-digit or double-digit numbers.
#
# Example 2:
#
# Input: nums = [1,2,3,4,5,14]
#
# Output: true
#
# Explanation:
#
# Alice can win by choosing single-digit numbers which have a sum equal to 15.
#
# Example 3:
#
# Input: nums = [5,5,5,25]
#
# Output: true
#
# Explanation:
#
# Alice can win by choosing double-digit numbers which have a sum equal to 25.
#
#
#
# Constraints:
#
# 1 <= nums.length <= 100
# 1 <= nums[i] <= 99
# Solution
# General idea:
# Only if sum of singles and doubles digits in array is equal, then Alice can't win the game, in other cases she always wins.
# Complexity
# Time complexity: O(N)
# Space complexity: O(1)
# Code
class Solution:
    def canAliceWin(self, nums: List[int]) -> bool:
        single: int = 0
        double: int = 0
        for num in nums:
            if num < 10: single += num
            else: double += num
        return single != double

# 3233. Find the Count of Numbers Which Are Not Special
# You are given 2 positive integers l and r. For any number x, all positive divisors of x except x are called the proper divisors of x.
# 
# A number is called special if it has exactly 2 proper divisors. For example:
# 
# The number 4 is special because it has proper divisors 1 and 2.
# The number 6 is not special because it has proper divisors 1, 2, and 3.
# Return the count of numbers in the range [l, r] that are not special.
# 
#  
# 
# Example 1:
# 
# Input: l = 5, r = 7
# 
# Output: 3
# 
# Explanation:
# 
# There are no special numbers in the range [5, 7].
# 
# Example 2:
# 
# Input: l = 4, r = 16
# 
# Output: 11
# 
# Explanation:
# 
# The special numbers in the range [4, 16] are 4 and 9.
# 
#  
# 
# Constraints:
# 
# 1 <= l <= r <= 109
import math
class Solution:
    def sieve_of_eratosthenes(self, limit: int) -> list[int]:
        is_prime: list[bool] = [True] * (limit + 1)
        is_prime[0] = is_prime[1] = False
        for start in range(2, int(math.sqrt(limit)) + 1):
            if is_prime[start]:
                for multiple in range(start*start, limit + 1, start):
                    is_prime[multiple] = False
        return [num for num, prime in enumerate(is_prime) if prime]

    def nonSpecialCount(self, l: int, r: int) -> int:
        upper_limit: int = int(math.sqrt(r)) + 1
        primes: list[int] = self.sieve_of_eratosthenes(upper_limit)
        semi_primes: int = 0
        for i in range(len(primes)):
            semi_prime = primes[i]**2
            if l <= semi_prime <= r:
                semi_primes += 1
            if semi_prime > r: break
        return (r - l + 1) - semi_primes

# 1395. Count Number of Teams
# There are n soldiers standing in a line. Each soldier is assigned a unique rating value.
# 
# You have to form a team of 3 soldiers amongst them under the following rules:
# 
# Choose 3 soldiers with index (i, j, k) with rating (rating[i], rating[j], rating[k]).
# A team is valid if: (rating[i] < rating[j] < rating[k]) or (rating[i] > rating[j] > rating[k]) where (0 <= i < j < k < n).
# Return the number of teams you can form given the conditions. (soldiers can be part of multiple teams).
# 
#  
# 
# Example 1:
# 
# Input: rating = [2,5,3,4,1]
# Output: 3
# Explanation: We can form three teams given the conditions. (2,3,4), (5,4,1), (5,3,1). 
# Example 2:
# 
# Input: rating = [2,1,3]
# Output: 0
# Explanation: We can't form any team given the conditions.
# Example 3:
# 
# Input: rating = [1,2,3,4]
# Output: 4
#  
# 
# Constraints:
# 
# n == rating.length
# 3 <= n <= 1000
# 1 <= rating[i] <= 105
# All the integers in rating are unique.
class Solution:
    def numTeams(self, rating: List[int]) -> int:
        teams: int = 0
        for j in range(len(rating)):
            left_greater = left_less = right_greater = right_less = 0
            for i in range(j):
                if rating[i] < rating[j]: left_less += 1
                elif rating[i] > rating[j]: left_greater += 1
            for k in range(j + 1, len(rating)):
                if rating[k] < rating[j]: right_less += 1
                elif rating[k] > rating[j]: right_greater += 1
            teams += left_less * right_greater + left_greater * right_less
        return teams
        
# A. Soft Drinking
# A. Soft Drinking
# time limit per test2 seconds
# memory limit per test256 megabytes
# This winter is so cold in Nvodsk! A group of n friends decided to buy k bottles of a soft drink called "Take-It-Light" to warm up a bit. Each bottle has l milliliters of the drink. Also they bought c limes and cut each of them into d slices. After that they found p grams of salt.
#
# To make a toast, each friend needs nl milliliters of the drink, a slice of lime and np grams of salt. The friends want to make as many toasts as they can, provided they all drink the same amount. How many toasts can each friend make?
#
# Input
# The first and only line contains positive integers n, k, l, c, d, p, nl, np, not exceeding 1000 and no less than 1. The numbers are separated by exactly one space.
#
# Output
# Print a single integer — the number of toasts each friend can make.
#
# Examples
# inputCopy
# 3 4 5 10 8 100 3 1
# outputCopy
# 2
# inputCopy
# 5 100 10 1 19 90 4 3
# outputCopy
# 3
# inputCopy
# 10 1000 1000 25 23 1 50 1
# outputCopy
# 0
# Note
# A comment to the first sample:
#
# Overall the friends have 4 * 5 = 20 milliliters of the drink, it is enough to make 20 / 3 = 6 toasts. The limes are enough for 10 * 8 = 80 toasts and the salt is enough for 100 / 1 = 100 toasts. However, there are 3 friends in the group, so the answer is min(6, 80, 100) / 3 = 2.
import sys


def solution(n: int, k: int, l: int, c: int, d: int, p: int, nl: int, np: int) -> str:
    total_mil: int = k * l
    lime_slices: int = c * d
    return str(min(total_mil // nl, lime_slices, p // np) // n)


if __name__ == '__main__':
    n, k, l, c, d, p, nl, np = map(int, sys.stdin.readline().rstrip().split())
    sys.stdout.write(solution(n, k, l, c, d, p, nl, np))

# Merge overlapping strings
# This kata requires you to write a function which merges two strings together. It does so by merging the end of the first string with the start of the second string together when they are an exact match.
# 
# "abcde" + "cdefgh" => "abcdefgh"
# "abaab" + "aabab" => "abaabab"
# "abc" + "def" => "abcdef"
# "abc" + "abc" => "abc"
# NOTE: The algorithm should always use the longest possible overlap.
# 
# "abaabaab" + "aabaabab" would be "abaabaabab" and not "abaabaabaabab"
# ALGORITHMSSTRINGS
def merge_strings(first, second):
    for idx in range(len(first)):
        if second.startswith(first[idx:]):
            return first[:idx] + second
    return first + second

# 1653. Minimum Deletions to Make String Balanced
# You are given a string s consisting only of characters 'a' and 'b'​​​​.
# 
# You can delete any number of characters in s to make s balanced. s is balanced if there is no pair of indices (i,j) such that i < j and s[i] = 'b' and s[j]= 'a'.
# 
# Return the minimum number of deletions needed to make s balanced.
# 
#  
# 
# Example 1:
# 
# Input: s = "aababbab"
# Output: 2
# Explanation: You can either:
# Delete the characters at 0-indexed positions 2 and 6 ("aababbab" -> "aaabbb"), or
# Delete the characters at 0-indexed positions 3 and 6 ("aababbab" -> "aabbbb").
# Example 2:
# 
# Input: s = "bbaaaaabb"
# Output: 2
# Explanation: The only solution is to delete the first two characters.
#  
# 
# Constraints:
# 
# 1 <= s.length <= 105
# s[i] is 'a' or 'b'​​.
class Solution:
    def minimumDeletions(self, s: str) -> int:
        total_deletions: int = 0
        prev_b: int = 0
        for char in s:
            if char == 'a':
                total_deletions = min(total_deletions + 1, prev_b)
            else: prev_b += 1
        return total_deletions
        
# A. Vasya the Hipster
# A. Vasya the Hipster
# time limit per test1 second
# memory limit per test256 megabytes
# One day Vasya the Hipster decided to count how many socks he had. It turned out that he had a red socks and b blue socks.
# 
# According to the latest fashion, hipsters should wear the socks of different colors: a red one on the left foot, a blue one on the right foot.
# 
# Every day Vasya puts on new socks in the morning and throws them away before going to bed as he doesn't want to wash them.
# 
# Vasya wonders, what is the maximum number of days when he can dress fashionable and wear different socks, and after that, for how many days he can then wear the same socks until he either runs out of socks or cannot make a single pair from the socks he's got.
# 
# Can you help him?
# 
# Input
# The single line of the input contains two positive integers a and b (1 ≤ a, b ≤ 100) — the number of red and blue socks that Vasya's got.
# 
# Output
# Print two space-separated integers — the maximum number of days when Vasya can wear different socks and the number of days when he can wear the same socks until he either runs out of socks or cannot make a single pair from the socks he's got.
# 
# Keep in mind that at the end of the day Vasya throws away the socks that he's been wearing on that day.
# 
# Examples
# inputCopy
# 3 1
# outputCopy
# 1 1
# inputCopy
# 2 3
# outputCopy
# 2 0
# inputCopy
# 7 3
# outputCopy
# 3 2
# Note
# In the first sample Vasya can first put on one pair of different socks, after that he has two red socks left to wear on the second day.
import sys


def solution(a: int, b: int) -> str:
    diffs: int = min(a, b)
    a -= diffs
    b -= diffs
    return f'{diffs} {a // 2 + b // 2}'


if __name__ == '__main__':
    a, b = map(int, sys.stdin.readline().rstrip().split())
    sys.stdout.write(solution(a, b))

# The alphabet product
# I have four positive integers, A, B, C and D, where A < B < C < D. The input is a list of the integers A, B, C, D, AxB, BxC, CxD, DxA in some order. Your task is to return the value of D.
# 
# LOGIC
def alphabet(ns):
    ns.sort()
    a, b = ns[:2]
    ans: list[int] = []
    first: bool = False
    second: bool = False
    for idx in range(2, len(ns)):
        if not first and  a * b == ns[idx]:
            first = True
            continue
        if not second and ns[idx] % b == 0 and ns[idx] // b > b:
            second = True
            continue
        else: ans.append(ns[idx])
        if len(ans) == 2: break
    return ans[-1]

# 112. Path Sum
# Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.
# 
# A leaf is a node with no children.
# 
#  
# 
# Example 1:
# 
# 
# Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
# Output: true
# Explanation: The root-to-leaf path with the target sum is shown.
# Example 2:
# 
# 
# Input: root = [1,2,3], targetSum = 5
# Output: false
# Explanation: There two root-to-leaf paths in the tree:
# (1 --> 2): The sum is 3.
# (1 --> 3): The sum is 4.
# There is no root-to-leaf path with sum = 5.
# Example 3:
# 
# Input: root = [], targetSum = 0
# Output: false
# Explanation: Since the tree is empty, there are no root-to-leaf paths.
#  
# 
# Constraints:
# 
# The number of nodes in the tree is in the range [0, 5000].
# -1000 <= Node.val <= 1000
# -1000 <= targetSum <= 1000
# Solution
# Depth First Search
# Complexity
# Time complexity: O(N)
# Space complexity: O(N)
# Code
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int, total_sum: int = 0) -> bool:
        if not root: return False
        if not root.left and not root.right and total_sum + root.val == targetSum:
            return True
        left_subtree = self.hasPathSum(root.left, targetSum, total_sum + root.val)
        right_subtree = self.hasPathSum(root.right, targetSum, total_sum + root.val)
        return left_subtree or right_subtree

# Breadth First Search
# Complexity
# Time complexity: O(N)
# Space complexity: O(N)
# Code
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if not root: return False
        queue: list[tuple[int, int]] = [(root, targetSum - root.val)]
        while queue:
            cur_root, cur_sum = queue.pop()
            if not cur_root.left and not cur_root.right and cur_sum == 0:
                return True
            if cur_root.left:
                queue.append((cur_root.left, cur_sum - cur_root.left.val))
            if cur_root.right:
                queue.append((cur_root.right, cur_sum - cur_root.right.val))
        return False

# 110. Balanced Binary Tree
# Given a binary tree, determine if it is 
# height-balanced
# .
# 
#  
# 
# Example 1:
# 
# 
# Input: root = [3,9,20,null,null,15,7]
# Output: true
# Example 2:
# 
# 
# Input: root = [1,2,2,3,3,null,null,4,4]
# Output: false
# Example 3:
# 
# Input: root = []
# Output: true
#  
# 
# Constraints:
# 
# The number of nodes in the tree is in the range [0, 5000].
# -104 <= Node.val <= 104
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def dfs(self, root):
        if not root: return 0
        left_subtree = self.dfs(root.left)
        right_subtree = self.dfs(root.right)
        if left_subtree < 0 or right_subtree < 0 or abs(left_subtree - right_subtree) > 1:
            return -1
        return max(left_subtree, right_subtree) + 1

    def isBalanced(self, root: Optional[TreeNode], current_depth: int = 0) -> bool:
        return self.dfs(root) >= 0

# 1105. Filling Bookcase Shelves
# You are given an array books where books[i] = [thicknessi, heighti] indicates the thickness and height of the ith book. You are also given an integer shelfWidth.
#
# We want to place these books in order onto bookcase shelves that have a total width shelfWidth.
#
# We choose some of the books to place on this shelf such that the sum of their thickness is less than or equal to shelfWidth, then build another level of the shelf of the bookcase so that the total height of the bookcase has increased by the maximum height of the books we just put down. We repeat this process until there are no more books to place.
#
# Note that at each step of the above process, the order of the books we place is the same order as the given sequence of books.
#
# For example, if we have an ordered list of 5 books, we might place the first and second book onto the first shelf, the third book on the second shelf, and the fourth and fifth book on the last shelf.
# Return the minimum possible height that the total bookshelf can be after placing shelves in this manner.
#
#
#
# Example 1:
#
#
# Input: books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelfWidth = 4
# Output: 6
# Explanation:
# The sum of the heights of the 3 shelves is 1 + 3 + 2 = 6.
# Notice that book number 2 does not have to be on the first shelf.
# Example 2:
#
# Input: books = [[1,3],[2,4],[3,2]], shelfWidth = 6
# Output: 4
#
#
# Constraints:
#
# 1 <= books.length <= 1000
# 1 <= thicknessi <= shelfWidth <= 1000
# 1 <= heighti <= 1000
class Solution:
    def minHeightShelves(self, books: List[List[int]], shelfWidth: int) -> int:
        return self.dp_books(books, shelfWidth)

    def dp_books(self, books: list[list[int]], boundary: int) -> int:
        min_heights: list[int] = [float('inf')] * (len(books) + 1)
        min_heights[0] = 0

        for book_idx in range(1, len(books) + 1):
            current_height: int = 0
            current_width: int = 0

            for prev_book in range(book_idx - 1, -1, -1):
                cur_book_width, cur_book_height = books[prev_book]

                if current_width + cur_book_width > boundary: break

                current_width += cur_book_width
                current_height = max(current_height, cur_book_height)

                min_heights[book_idx] = min(min_heights[book_idx], min_heights[prev_book] + current_height)

        return min_heights[len(books)]
        
# A. Restoring Three Numbers
# A. Restoring Three Numbers
# time limit per test1 second
# memory limit per test256 megabytes
# Polycarp has guessed three positive integers a
# , b
#  and c
# . He keeps these numbers in secret, but he writes down four numbers on a board in arbitrary order — their pairwise sums (three numbers) and sum of all three numbers (one number). So, there are four numbers on a board in random order: a+b
# , a+c
# , b+c
#  and a+b+c
# .
# 
# You have to guess three numbers a
# , b
#  and c
#  using given numbers. Print three guessed integers in any order.
# 
# Pay attention that some given numbers a
# , b
#  and c
#  can be equal (it is also possible that a=b=c
# ).
# 
# Input
# The only line of the input contains four positive integers x1,x2,x3,x4
#  (2≤xi≤109
# ) — numbers written on a board in random order. It is guaranteed that the answer exists for the given number x1,x2,x3,x4
# .
# 
# Output
# Print such positive integers a
# , b
#  and c
#  that four numbers written on a board are values a+b
# , a+c
# , b+c
#  and a+b+c
#  written in some order. Print a
# , b
#  and c
#  in any order. If there are several answers, you can print any. It is guaranteed that the answer exists.
# 
# Examples
# inputCopy
# 3 6 5 4
# outputCopy
# 2 1 3
# inputCopy
# 40 40 40 60
# outputCopy
# 20 20 20
# inputCopy
# 201 101 101 200
# outputCopy
# 1 100 100
import sys


def solution(nums: list) -> str:
    abc: int = max(nums)
    numbers: list = []
    for num in nums:
        if num == abc: continue
        numbers.append(abc - num)
    return ' '.join(str(num) for num in numbers)


if __name__ == '__main__':
    nums: list = list(map(int, sys.stdin.readline().rstrip().split()))
    sys.stdout.write(solution(nums))

# Where Are My Glasses?
# Oh no! I've lost my glasses, but paradoxically, I need glasses to find my glasses!
# 
# Please help me out by showing me the index in the list which contains my glasses. They look like two capital Os, with at least one dash in between!
# 
# This means that both O--O and O------------O are valid glasses, but not O----#--O for example!
# Search thoroughly, you might find my glasses in places such as 'dustO-Odust'
# Examples
# ["phone", "O-O", "coins", "keys"] ➞ 1
# 
# ["OO", "wallet", "O##O", "O----O"] ➞ 3
# 
# ["O--#--O", "dustO---Odust", "more dust"] ➞ 1
# Notes
# All lists will include one valid pair of glasses because I swear I dropped them around here somewhere ...
# All elements in the list are strings.
# REGULAR EXPRESSIONS
import re
def find_glasses(lst):
    for idx in range(len(lst)):
        if re.search(r'O-+O', lst[idx]):
            return idx

# 144. Binary Tree Preorder Traversal
# Given the root of a binary tree, return the preorder traversal of its nodes' values.
# 
#  
# 
# Example 1:
# 
# 
# Input: root = [1,null,2,3]
# Output: [1,2,3]
# Example 2:
# 
# Input: root = []
# Output: []
# Example 3:
# 
# Input: root = [1]
# Output: [1]
#  
# 
# Constraints:
# 
# The number of nodes in the tree is in the range [0, 100].
# -100 <= Node.val <= 100
#  
# 
# Follow up: Recursive solution is trivial, could you do it iteratively?
# Solution
# Dfs recursive way
# Complexity
# Time complexity: O(N)
# Space complexity: O(N)
# Code
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode], order: list[int] = None) -> List[int]:
        if order is None: order = []
        if not root: return order
        order += [root.val]
        self.preorderTraversal(root.left, order)
        self.preorderTraversal(root.right, order)
        return order

# Dfs iterative way
# Complexity
# Time complexity: O(N)
# Space complexity: O(N)
# Code
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode], order: list[int] = None) -> List[int]:
        order: list[int] = []
        queue: list[TreeNode] = [root]
        while queue:
            cur_root: TreeNode = queue.pop()
            if not cur_root: continue
            order.append(cur_root.val)
            queue.append(cur_root.right)
            queue.append(cur_root.left)
        return order

# 145. Binary Tree Postorder Traversal
# Given the root of a binary tree, return the postorder traversal of its nodes' values.
# 
#  
# 
# Example 1:
# 
# 
# Input: root = [1,null,2,3]
# Output: [3,2,1]
# Example 2:
# 
# Input: root = []
# Output: []
# Example 3:
# 
# Input: root = [1]
# Output: [1]
#  
# 
# Constraints:
# 
# The number of the nodes in the tree is in the range [0, 100].
# -100 <= Node.val <= 100
#  
# 
# Follow up: Recursive solution is trivial, could you do it iteratively?
# Recursive way
# Complexity
# Time complexity: O(N)
# Space complexity: O(N)
# Code
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode], order: list[int] = None) -> List[int]:
        if order is None:
            order = []
        if not root: return order
        self.postorderTraversal(root.left, order)
        self.postorderTraversal(root.right, order)
        order.append(root.val)
        return order

# Iterative way
# Complexity
# Time complexity: O(N)
# Space complexity: O(N)
# Code
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        order: list[int] = []
        queue: list[TreeNode] = [(root, False)]
        while queue:
            cur_root, seen = queue.pop()
            if cur_root and not seen:
                queue += [(cur_root, True), (cur_root.right, False), (cur_root.left, False)]
            elif cur_root:
                order.append(cur_root.val)
        return order

# 2678. Number of Senior Citizens
# You are given a 0-indexed array of strings details. Each element of details provides information about a given passenger compressed into a string of length 15. The system is such that:
# 
# The first ten characters consist of the phone number of passengers.
# The next character denotes the gender of the person.
# The following two characters are used to indicate the age of the person.
# The last two characters determine the seat allotted to that person.
# Return the number of passengers who are strictly more than 60 years old.
# 
#  
# 
# Example 1:
# 
# Input: details = ["7868190130M7522","5303914400F9211","9273338290F4010"]
# Output: 2
# Explanation: The passengers at indices 0, 1, and 2 have ages 75, 92, and 40. Thus, there are 2 people who are over 60 years old.
# Example 2:
# 
# Input: details = ["1313579440F2036","2921522980M5644"]
# Output: 0
# Explanation: None of the passengers are older than 60.
#  
# 
# Constraints:
# 
# 1 <= details.length <= 100
# details[i].length == 15
# details[i] consists of digits from '0' to '9'.
# details[i][10] is either 'M' or 'F' or 'O'.
# The phone numbers and seat numbers of the passengers are distinct.
# Because we already know about "static" size of each detail, we can use simple one liner to count all senior citizens
# Solution Counting O(N) O(1)
class Solution:
    def countSeniors(self, details: List[str]) -> int:
        senior_citizens: int = 0
        for citizen in details:
            age: int = int(citizen[-4:-2])
            if age > 60: senior_citizens += 1
        return senior_citizens
# Solution One liner
class Solution:
    def countSeniors(self, details: List[str]) -> int:
       return sum(detail[-4:-2] > '60' for detail in details)

# B. T-primes
# B. T-primes
# time limit per test2 seconds
# memory limit per test256 megabytes
# We know that prime numbers are positive integers that have exactly two distinct positive divisors. Similarly, we'll call a positive integer t Т-prime, if t has exactly three distinct positive divisors.
#
# You are given an array of n positive integers. For each of them determine whether it is Т-prime or not.
#
# Input
# The first line contains a single positive integer, n (1 ≤ n ≤ 105), showing how many numbers are in the array. The next line contains n space-separated integers xi (1 ≤ xi ≤ 1012).
#
# Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is advised to use the cin, cout streams or the %I64d specifier.
#
# Output
# Print n lines: the i-th line should contain "YES" (without the quotes), if number xi is Т-prime, and "NO" (without the quotes), if it isn't.
#
# Examples
# inputCopy
# 3
# 4 5 6
# outputCopy
# YES
# NO
# NO
# Note
# The given test has three numbers. The first number 4 has exactly three divisors — 1, 2 and 4, thus the answer for this number is "YES". The second number 5 has two divisors (1 and 5), and the third number 6 has four divisors (1, 2, 3, 6), hence the answer for them is "NO".
# Solution Math O(N) O(k) where k is length of primes
import math
import sys


def sieve_of_eratosthenes(limit: int) -> list:
    is_prime: list[bool] = [True] * (limit + 1)
    is_prime[0] = is_prime[1] = False
    for start in range(2, int(math.sqrt(limit)) + 1):
        if is_prime[start]:
            for multiple in range(start * start, limit + 1, start):
                is_prime[multiple] = False
    return [num for num, prime in enumerate(is_prime) if prime]


def solution(n: int, nums: list) -> str:
    upper_boundary: int = int(math.sqrt(max(nums))) + 1
    primes: set = set(sieve_of_eratosthenes(upper_boundary))
    for num in nums:
        root: int = math.sqrt(num)
        if root != int(root):
            print('NO')
        else:
            print(['NO', 'YES'][int(root) in primes])


if __name__ == '__main__':
    n: int = int(sys.stdin.readline().rstrip())
    nums: list = list(map(int, sys.stdin.readline().rstrip().split()))
    solution(n, nums)

# Stern-Brocot Sequence Part I
# The Stern-Brocot sequence is much like the Fibonacci sequence and has some cool implications. Let's learn about it:
# 
# It starts with [1, 1] and adds two new terms every iteration: nextTerm which is the sum of a previous pair; and termAfterThat which is the second term of this previous pair. Here is how to find those terms:
# 
# [1, 1] + [nextTerm: 1 + 1 = 2; termAfterThat: 1] ==> [1, 1, 2, 1]
#  ^  ^
# Then you shift the pairs with one index in the sequence:
# 
# [1, 1, 2, 1] + [1 + 2, 2] ==> [1, 1, 2, 1, 3, 2]
#     ^  ^
# And so on... doing this for 2 more iterations will yield:
# 
# [1, 1, 2, 1, 3, 2, 3, 1, 4, 3]
# Complete the code that takes a positive integer n, and returns the index of the first occurrence of n in the sequence. Note: indexing start at zero.
# 
# Examples
# [1, 1, 2, 1, 3, 2, 3, 1, 4, 3, ...]
#        ^     ^           ^
# n = 2 ==> 2 
# n = 3 ==> 4
# n = 4 ==> 8
# NUMBER THEORYALGORITHMS
def stern_brocot(n):
    storage: list[int] = [1, 1]
    first_idx: int = 0
    while True:
        if storage[first_idx] == n: return first_idx
        sum_pair: int = storage[first_idx] + storage[first_idx + 1]
        first_idx += 1
        after_that: int = storage[first_idx]
        storage.append(sum_pair)
        storage.append(after_that)
        
# A. Sum
# A. Sum
# time limit per test1 second
# memory limit per test256 megabytes
# You are given three integers a
# , b
# , and c
# . Determine if one of them is the sum of the other two.
# 
# Input
# The first line contains a single integer t
#  (1≤t≤9261
# ) — the number of test cases.
# 
# The description of each test case consists of three integers a
# , b
# , c
#  (0≤a,b,c≤20
# ).
# 
# Output
# For each test case, output "YES" if one of the numbers is the sum of the other two, and "NO" otherwise.
# 
# You can output the answer in any case (for example, the strings "yEs", "yes", "Yes" and "YES" will be recognized as a positive answer).
# 
# Example
# inputCopy
# 7
# 1 4 3
# 2 5 8
# 9 11 20
# 0 0 0
# 20 20 20
# 4 12 3
# 15 7 8
# outputCopy
# YES
# NO
# YES
# YES
# NO
# NO
# YES
# Note
# In the first test case, 1+3=4
# .
# 
# In the second test case, none of the numbers is the sum of the other two.
# 
# In the third test case, 9+11=20
# .
import sys


def solution(t: int) -> None:
    for _ in range(t):
        a, b, c = map(int, sys.stdin.readline().rstrip().split())
        print(['NO', 'YES'][(a + b == c or c + b == a or a + c == b)])


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)

# 2134. Minimum Swaps to Group All 1's Together II
# A swap is defined as taking two distinct positions in an array and swapping the values in them.
# 
# A circular array is defined as an array where we consider the first element and the last element to be adjacent.
# 
# Given a binary circular array nums, return the minimum number of swaps required to group all 1's present in the array together at any location.
# 
#  
# 
# Example 1:
# 
# Input: nums = [0,1,0,1,1,0,0]
# Output: 1
# Explanation: Here are a few of the ways to group all the 1's together:
# [0,0,1,1,1,0,0] using 1 swap.
# [0,1,1,1,0,0,0] using 1 swap.
# [1,1,0,0,0,0,1] using 2 swaps (using the circular property of the array).
# There is no way to group all 1's together with 0 swaps.
# Thus, the minimum number of swaps required is 1.
# Example 2:
# 
# Input: nums = [0,1,1,1,0,0,1,1,0]
# Output: 2
# Explanation: Here are a few of the ways to group all the 1's together:
# [1,1,1,0,0,0,0,1,1] using 2 swaps (using the circular property of the array).
# [1,1,1,1,1,0,0,0,0] using 2 swaps.
# There is no way to group all 1's together with 0 or 1 swaps.
# Thus, the minimum number of swaps required is 2.
# Example 3:
# 
# Input: nums = [1,1,0,0,1]
# Output: 0
# Explanation: All the 1's are already grouped together due to the circular property of the array.
# Thus, the minimum number of swaps required is 0.
#  
# 
# Constraints:
# 
# 1 <= nums.length <= 105
# nums[i] is either 0 or 1.
class Solution:
    def minSwaps(self, nums: List[int]) -> int:
        zeros: int = 0
        ones: int = nums.count(1)
        k: int = len(nums)
        min_operations: int = float('inf')
        left: int = 0
        for right in range(k * 2):
            if nums[right % k] == 0: zeros += 1
            while right - left + 1 > ones:
                if nums[left % k] == 0: zeros -= 1
                left += 1
            if right - left + 1 == ones:
                min_operations = min(min_operations, zeros)
        return min_operations

# 1460. Make Two Arrays Equal by Reversing Subarrays
# You are given two integer arrays of equal length target and arr. In one step, you can select any non-empty subarray of arr and reverse it. You are allowed to make any number of steps.
# 
# Return true if you can make arr equal to target or false otherwise.
# 
#  
# 
# Example 1:
# 
# Input: target = [1,2,3,4], arr = [2,4,1,3]
# Output: true
# Explanation: You can follow the next steps to convert arr to target:
# 1- Reverse subarray [2,4,1], arr becomes [1,4,2,3]
# 2- Reverse subarray [4,2], arr becomes [1,2,4,3]
# 3- Reverse subarray [4,3], arr becomes [1,2,3,4]
# There are multiple ways to convert arr to target, this is not the only way to do so.
# Example 2:
# 
# Input: target = [7], arr = [7]
# Output: true
# Explanation: arr is equal to target without any reverses.
# Example 3:
# 
# Input: target = [3,7,9], arr = [3,7,11]
# Output: false
# Explanation: arr does not have value 9 and it can never be converted to target.
#  
# 
# Constraints:
# 
# target.length == arr.length
# 1 <= target.length <= 1000
# 1 <= target[i] <= 1000
# 1 <= arr[i] <= 1000
# Solution Hash Table Counting
# General idea:
# Arrays can be rearranged to equals, only if they have same frequences of same numbers, order doesn't matter. That's all.
# Complexity
# Time complexity: O(N)
# Space complexity: O(N)
# Code
class Solution:
    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:
        # Storage frequence of each integer in both arrays
        storage: dict[int, int] = dict()
        for i in range(len(target)):
            # Target array will be increment counter of each number
            storage[target[i]] = storage.get(target[i], 0) + 1
            # Current arr will be decrease counter
            storage[arr[i]] = storage.get(arr[i], 0) - 1
        # At the end of counting and substracting, our hasmap should have only zeroes in values if it not, it means that we have some numbers that not contains in other array.
        for num in storage:
            if storage[num] != 0: return False
        return True

# B. Xenia and Ringroad
# B. Xenia and Ringroad
# time limit per test2 seconds
# memory limit per test256 megabytes
# Xenia lives in a city that has n houses built along the main ringroad. The ringroad houses are numbered 1 through n in the clockwise order. The ringroad traffic is one way and also is clockwise.
#
# Xenia has recently moved into the ringroad house number 1. As a result, she's got m things to do. In order to complete the i-th task, she needs to be in the house number ai and complete all tasks with numbers less than i. Initially, Xenia is in the house number 1, find the minimum time she needs to complete all her tasks if moving from a house to a neighboring one along the ringroad takes one unit of time.
#
# Input
# The first line contains two integers n and m (2 ≤ n ≤ 105, 1 ≤ m ≤ 105). The second line contains m integers a1, a2, ..., am (1 ≤ ai ≤ n). Note that Xenia can have multiple consecutive tasks in one house.
#
# Output
# Print a single integer — the time Xenia needs to complete all tasks.
#
# Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.
#
# Examples
# inputCopy
# 4 3
# 3 2 3
# outputCopy
# 6
# inputCopy
# 4 3
# 2 3 3
# outputCopy
# 2
# Note
# In the first test example the sequence of Xenia's moves along the ringroad looks as follows: 1 → 2 → 3 → 4 → 1 → 2 → 3. This is optimal sequence. So, she needs 6 time units.
import sys

def solution(n: int, m: int, houses: list) -> str:
    total_moves: int = 0
    current_position: int = 1
    for home in houses:
        if current_position == home: continue
        if home < current_position:
            total_moves += n - current_position + home
        else:
            total_moves += home - current_position
        current_position = home
    return str(total_moves)

if __name__ == '__main__':
    n, m = map(int, sys.stdin.readline().rstrip().split())
    houses: list = list(map(int, sys.stdin.readline().rstrip().split()))
    sys.stdout.write(solution(n, m, houses))

# Digitwise addition
# Digitwise addition is a special kind of addition where instead of adding 1 normally to the number, it adds 1 to every digit of that number. If the digit is a 9, we replace it with a "10" without carrying over to the next digit.
#
# Examples:
#
# 123 -> 234
#
# 910 -> 1021
#
# 789 -> 8910
# Program a function that takes two numbers, N and K, and outputs the number of digits in N after applying Digitwise addition K times. Since the answer can be very large, return the answer modulo 10 ** 9 + 7
#
# Specifications: 1 <= N <= 10^9, 1 <= K <= 10^5
#
# Example 1:
#
# digitwise_addition(9812, 2) -> 6
#
# # Explanation:
# # 9812 -> 10923 -> 211034 -> 6 digits
# Example 2:
#
# digitwise_addition(9899, 3) -> 8
#
# # Explanation:
# # 9899 -> 1091010 -> 21102121 -> 32213232 -> 8 digits
# Subtask 1: K <= 20, 30 tests
#
# Subtask 2: K <= 50, 20 tests
#
# Subtask 3: K <= 10^5, 50 tests
#
# ALGORITHMSMATHEMATICS
def digitwise_addition(N, K):
    MOD = 10 ** 9 + 7

    # Initialize a list to store the mappings for each digit
    addition = [
        [1],  # 0 -> 1
        [2],  # 1 -> 2
        [3],  # 2 -> 3
        [4],  # 3 -> 4
        [5],  # 4 -> 5
        [6],  # 5 -> 6
        [7],  # 6 -> 7
        [8],  # 7 -> 8
        [9],  # 8 -> 9
        [1, 0]  # 9 -> 1, 0
    ]

    # Initialize a count list to keep track of the occurrences of each digit
    count = [0] * 10
    for digit in str(N):
        count[int(digit)] += 1

    # Iterate K times to simulate the process
    for _ in range(K):
        new_count = [0] * 10
        for digit in range(10):
            for new_digit in addition[digit]:
                new_count[new_digit] = (new_count[new_digit] + count[digit]) % MOD
        count = new_count

    # Sum the counts of all digits
    total_count = sum(count) % MOD

    return total_count

# 3238. Find the Number of Winning Players
# You are given an integer n representing the number of players in a game and a 2D array pick where pick[i] = [xi, yi] represents that the player xi picked a ball of color yi.
#
# Player i wins the game if they pick strictly more than i balls of the same color. In other words,
#
# Player 0 wins if they pick any ball.
# Player 1 wins if they pick at least two balls of the same color.
# ...
# Player i wins if they pick at leasti + 1 balls of the same color.
# Return the number of players who win the game.
#
# Note that multiple players can win the game.
#
#
#
# Example 1:
#
# Input: n = 4, pick = [[0,0],[1,0],[1,0],[2,1],[2,1],[2,0]]
#
# Output: 2
#
# Explanation:
#
# Player 0 and player 1 win the game, while players 2 and 3 do not win.
#
# Example 2:
#
# Input: n = 5, pick = [[1,1],[1,2],[1,3],[1,4]]
#
# Output: 0
#
# Explanation:
#
# No player wins the game.
#
# Example 3:
#
# Input: n = 5, pick = [[1,1],[2,4],[2,4],[2,4]]
#
# Output: 1
#
# Explanation:
#
# Player 2 wins the game by picking 3 balls with color 4.
#
#
#
# Constraints:
#
# 2 <= n <= 10
# 1 <= pick.length <= 100
# pick[i].length == 2
# 0 <= xi <= n - 1
# 0 <= yi <= 10
class Solution:
    def winningPlayerCount(self, n: int, pick: List[List[int]]) -> int:
        # Store frequences of all colors that collected each player
        # map[key = player; value = map[key=color, value=frequence]]
        storage: dict[int, dict[int, int]] = dict()
        for match in pick:
            player, color = match
            if player not in storage:
                storage[player] = dict()
            storage[player][color] = storage[player].get(color, 0) + 1
        winners: int = 0
        for player in storage:
            for color in storage[player]:
                if storage[player][color] > player:
                    winners += 1
                    break
        return winners

# 3239. Minimum Number of Flips to Make Binary Grid Palindromic I
# You are given an m x n binary matrix grid.
# 
# A row or column is considered palindromic if its values read the same forward and backward.
# 
# You can flip any number of cells in grid from 0 to 1, or from 1 to 0.
# 
# Return the minimum number of cells that need to be flipped to make either all rows palindromic or all columns palindromic.
# 
#  
# 
# Example 1:
# 
# Input: grid = [[1,0,0],[0,0,0],[0,0,1]]
# 
# Output: 2
# 
# Explanation:
# 
# 
# 
# Flipping the highlighted cells makes all the rows palindromic.
# 
# Example 2:
# 
# Input: grid = [[0,1],[0,1],[0,0]]
# 
# Output: 1
# 
# Explanation:
# 
# 
# 
# Flipping the highlighted cell makes all the columns palindromic.
# 
# Example 3:
# 
# Input: grid = [[1],[0]]
# 
# Output: 0
# 
# Explanation:
# 
# All rows are already palindromic.
# 
#  
# 
# Constraints:
# 
# m == grid.length
# n == grid[i].length
# 1 <= m * n <= 2 * 105
# 0 <= grid[i][j] <= 1
class Solution:
    def how_many(self, arr: list[int]) -> int:
        left: int = 0
        right: int = len(arr) - 1
        needed: int = 0
        while left < right:
            if arr[left] != arr[right]:
                needed += 1
            left += 1
            right -= 1
        return needed

    def minFlips(self, grid: List[List[int]]) -> int:
        needed_for_row: int = 0
        needed_for_col: int = 0
        for row in grid:
            needed_for_row += self.how_many(row)
        for col in range(len(grid[0])):
            cols: list[int] = [grid[row][col] for row in range(len(grid))]
            needed_for_col += self.how_many(cols)
        return min(needed_for_row, needed_for_col)

# 1493. Longest Subarray of 1's After Deleting One Element
# Given a binary array nums, you should delete one element from it.
# 
# Return the size of the longest non-empty subarray containing only 1's in the resulting array. Return 0 if there is no such subarray.
# 
#  
# 
# Example 1:
# 
# Input: nums = [1,1,0,1]
# Output: 3
# Explanation: After deleting the number in position 2, [1,1,1] contains 3 numbers with value of 1's.
# Example 2:
# 
# Input: nums = [0,1,1,1,0,1,1,0,1]
# Output: 5
# Explanation: After deleting the number in position 4, [0,1,1,1,1,1,0,1] longest subarray with value of 1's is [1,1,1,1,1].
# Example 3:
# 
# Input: nums = [1,1,1]
# Output: 2
# Explanation: You must delete one element.
#  
# 
# Constraints:
# 
# 1 <= nums.length <= 105
# nums[i] is either 0 or 1.
class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        zeros: int = 0
        left: int = 0
        right: int = 0
        mx_length: int = 0
        for right in range(len(nums)):
            if nums[right] == 0: zeros += 1
            while zeros > 1:
                if nums[left] == 0:
                    zeros -= 1
                left += 1
            mx_length = max(mx_length, right - left)
        return mx_length

# A. YES or YES?
# A. YES or YES?
# time limit per test1 second
# memory limit per test256 megabytes
# There is a string s
#  of length 3
# , consisting of uppercase and lowercase English letters. Check if it is equal to "YES" (without quotes), where each letter can be in any case. For example, "yES", "Yes", "yes" are all allowable.
# 
# Input
# The first line of the input contains an integer t
#  (1≤t≤103
# ) — the number of testcases.
# 
# The description of each test consists of one line containing one string s
#  consisting of three characters. Each character of s
#  is either an uppercase or lowercase English letter.
# 
# Output
# For each test case, output "YES" (without quotes) if s
#  satisfies the condition, and "NO" (without quotes) otherwise.
# 
# You can output "YES" and "NO" in any case (for example, strings "yES", "yes" and "Yes" will be recognized as a positive response).
# 
# Example
# inputCopy
# 10
# YES
# yES
# yes
# Yes
# YeS
# Noo
# orZ
# yEz
# Yas
# XES
# outputCopy
# YES
# YES
# YES
# YES
# YES
# NO
# NO
# NO
# NO
# NO
# Note
# The first five test cases contain the strings "YES", "yES", "yes", "Yes", "YeS". All of these are equal to "YES", where each character is either uppercase or lowercase.
import sys


def solution(t: int) -> None:
    for _ in range(t):
        word: str = sys.stdin.readline().rstrip()
        print(['NO', 'YES'][word.lower() == 'yes'])


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)

# 1508. Range Sum of Sorted Subarray Sums
# You are given the array nums consisting of n positive integers. You computed the sum of all non-empty continuous subarrays from the array and then sorted them in non-decreasing order, creating a new array of n * (n + 1) / 2 numbers.
# 
# Return the sum of the numbers from index left to index right (indexed from 1), inclusive, in the new array. Since the answer can be a huge number return it modulo 109 + 7.
# 
#  
# 
# Example 1:
# 
# Input: nums = [1,2,3,4], n = 4, left = 1, right = 5
# Output: 13 
# Explanation: All subarray sums are 1, 3, 6, 10, 2, 5, 9, 3, 7, 4. After sorting them in non-decreasing order we have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le = 1 to ri = 5 is 1 + 2 + 3 + 3 + 4 = 13. 
# Example 2:
# 
# Input: nums = [1,2,3,4], n = 4, left = 3, right = 4
# Output: 6
# Explanation: The given array is the same as example 1. We have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le = 3 to ri = 4 is 3 + 3 = 6.
# Example 3:
# 
# Input: nums = [1,2,3,4], n = 4, left = 1, right = 10
# Output: 50
#  
# 
# Constraints:
# 
# n == nums.length
# 1 <= nums.length <= 1000
# 1 <= nums[i] <= 100
# 1 <= left <= right <= n * (n + 1) / 2
# Brute Force
# Complexity
# Time complexity: O(N**2 logN)
# Space complexity: O(N**2)
# Code
class Solution:
    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:
        storage: list[int] = []
        for i in range(len(nums)):
            cul_sum: int = 0
            for j in range(i, len(nums)):
                cul_sum += nums[j]
                storage.append(cul_sum)
        storage.sort()
        return sum(storage[left - 1: right]) % (10**9+7)

# Heap
# Complexity
# Time complexity: O(N**2 logN)
# Space complexity: O(N**2)
# Code
class Solution:
    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:
        storage: list[tuple[int]] = [(value, index) for index, value in enumerate(nums)]
        heapify(storage)
        total_sum: int = 0
        for idx in range(1, right + 1):
            cur_val, cur_idx = heappop(storage)
            if idx >= left: total_sum += cur_val
            if cur_idx + 1 < n: heappush(storage, (cur_val + nums[cur_idx + 1], cur_idx + 1))
        return total_sum % (10**9 + 7)

# 3242. Design Neighbor Sum Service
# You are given a n x n 2D array grid containing distinct elements in the range [0, n2 - 1].
# 
# Implement the neighborSum class:
# 
# neighborSum(int [][]grid) initializes the object.
# int adjacentSum(int value) returns the sum of elements which are adjacent neighbors of value, that is either to the top, left, right, or bottom of value in grid.
# int diagonalSum(int value) returns the sum of elements which are diagonal neighbors of value, that is either to the top-left, top-right, bottom-left, or bottom-right of value in grid.
# 
# 
#  
# 
# Example 1:
# 
# Input:
# 
# ["neighborSum", "adjacentSum", "adjacentSum", "diagonalSum", "diagonalSum"]
# 
# [[[[0, 1, 2], [3, 4, 5], [6, 7, 8]]], [1], [4], [4], [8]]
# 
# Output: [null, 6, 16, 16, 4]
# 
# Explanation:
# 
# 
# 
# The adjacent neighbors of 1 are 0, 2, and 4.
# The adjacent neighbors of 4 are 1, 3, 5, and 7.
# The diagonal neighbors of 4 are 0, 2, 6, and 8.
# The diagonal neighbor of 8 is 4.
# Example 2:
# 
# Input:
# 
# ["neighborSum", "adjacentSum", "diagonalSum"]
# 
# [[[[1, 2, 0, 3], [4, 7, 15, 6], [8, 9, 10, 11], [12, 13, 14, 5]]], [15], [9]]
# 
# Output: [null, 23, 45]
# 
# Explanation:
# 
# 
# 
# The adjacent neighbors of 15 are 0, 10, 7, and 6.
# The diagonal neighbors of 9 are 4, 12, 14, and 15.
#  
# 
# Constraints:
# 
# 3 <= n == grid.length == grid[0].length <= 10
# 0 <= grid[i][j] <= n2 - 1
# All grid[i][j] are distinct.
# value in adjacentSum and diagonalSum will be in the range [0, n2 - 1].
# At most 2 * n2 calls will be made to adjacentSum and diagonalSum.
class neighborSum:

    def __init__(self, grid: List[List[int]]):
        self.mtrx: list[list[int]] = grid
        self.positions: dict[int, tuple[int]] = dict()
        for row in range(len(self.mtrx)):
            for col in range(len(self.mtrx)):
                self.positions[self.mtrx[row][col]] = (row, col)

    def search(self, value: int) -> tuple[int, int]:
        return self.positions[value]

    def adjacentSum(self, value: int) -> int:
        row, col = self.search(value)
        sm: int = 0
        # upper element
        if row - 1 >= 0: sm += self.mtrx[row - 1][col]
        # left side element
        if col - 1 >= 0: sm += self.mtrx[row][col - 1]
        # right side element
        if col + 1 < len(self.mtrx): sm += self.mtrx[row][col + 1]
        # bottom element
        if row + 1 < len(self.mtrx): sm += self.mtrx[row + 1][col]
        return sm

    def diagonalSum(self, value: int) -> int:
        row, col = self.search(value)
        sm: int = 0
        # upper left element
        if row - 1 >= 0 and col - 1 >= 0: sm += self.mtrx[row - 1][col - 1]
        # lower left element
        if row + 1 < len(self.mtrx) and col - 1 >= 0: sm += self.mtrx[row + 1][col - 1]
        # lower right element
        if row + 1 < len(self.mtrx) and col + 1 < len(self.mtrx): sm += self.mtrx[row + 1][col + 1]
        # upper right element
        if row - 1 >= 0 and col + 1 < len(self.mtrx): sm += self.mtrx[row - 1][col + 1]
        return sm



# Your neighborSum object will be instantiated and called as such:
# obj = neighborSum(grid)
# param_1 = obj.adjacentSum(value)
# param_2 = obj.diagonalSum(value)

# 3243. Shortest Distance After Road Addition Queries I
# You are given an integer n and a 2D integer array queries.
#
# There are n cities numbered from 0 to n - 1. Initially, there is a unidirectional road from city i to city i + 1 for all 0 <= i < n - 1.
#
# queries[i] = [ui, vi] represents the addition of a new unidirectional road from city ui to city vi. After each query, you need to find the length of the shortest path from city 0 to city n - 1.
#
# Return an array answer where for each i in the range [0, queries.length - 1], answer[i] is the length of the shortest path from city 0 to city n - 1 after processing the first i + 1 queries.
#
#
#
# Example 1:
#
# Input: n = 5, queries = [[2,4],[0,2],[0,4]]
#
# Output: [3,2,1]
#
# Explanation:
#
#
#
# After the addition of the road from 2 to 4, the length of the shortest path from 0 to 4 is 3.
#
#
#
# After the addition of the road from 0 to 2, the length of the shortest path from 0 to 4 is 2.
#
#
#
# After the addition of the road from 0 to 4, the length of the shortest path from 0 to 4 is 1.
#
# Example 2:
#
# Input: n = 4, queries = [[0,3],[0,2]]
#
# Output: [1,1]
#
# Explanation:
#
#
#
# After the addition of the road from 0 to 3, the length of the shortest path from 0 to 3 is 1.
#
#
#
# After the addition of the road from 0 to 2, the length of the shortest path remains 1.
#
#
#
# Constraints:
#
# 3 <= n <= 500
# 1 <= queries.length <= 500
# queries[i].length == 2
# 0 <= queries[i][0] < queries[i][1] < n
# 1 < queries[i][1] - queries[i][0]
# There are no repeated roads among the queries.
# Complexity
# Time
# complexity: O(K(V + E)logV) where k is length of queries
# Space
# complexity: O(N)
# 
# Code
import heapq


class Solution:
    def dijkstra(self, start: int, target: int, paths: dict[int, list[int]]) -> int:
        min_heap: list[tuple[int]] = [(0, start)]
        seen: set[int] = set()
        while min_heap:
            cur_cost, vertex = heapq.heappop(min_heap)
            if vertex in seen: continue
            seen.add(vertex)
            if vertex == target: return cur_cost
            for neighbor in paths[vertex]:
                if neighbor in seen: continue
                heapq.heappush(min_heap, (cur_cost + 1, neighbor))

    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:
        paths: dict[int, list[int]] = dict()
        for vertex in range(n):
            if vertex not in paths:
                paths[vertex] = []
            if vertex == n - 1: continue
            paths[vertex].append(vertex + 1)
        answer: list[int] = []
        for query in queries:
            source, destination = query
            paths[source].append(destination)
            answer.append(self.dijkstra(0, n - 1, paths))
        return answer

# Blocks in an Irregular Pyramid
# Consider a pyramid made up of blocks. Each layer of the pyramid is a rectangle of blocks, and the dimensions of these rectangles increment as you descend the pyramid. So, if a layer is a 3x6 rectangle of blocks, then the next layer will be a 4x7 rectangle of blocks. A 1x10 layer will be on top of a 2x11 layer on top of a 3x12 layer, and so on.
#
# Task
# Given the dimensions of a pyramid's topmost layer w,l, and its height h (aka the number of layers), return the total number of blocks in the pyramid.
#
# Examples
# num_blocks(1, 1, 2) will return 5. This pyramid starts with a 1x1 layer and has 2 layers total. So, there is 1 block in the first layer, and 2x2=4 blocks in the second. Thus, 5 is the total number of blocks.
#
# num_blocks(2, 4, 3) will return 47. This pyramid has 3 layers: 2x4, 3x5, and 4x6. So, there are 47 blocks total.
#
# Notes
# All parameters will always be postive nonzero integers.
#
# Efficiency is important. There will be:
#
# 100 'small' cases with w, l, and h below 20.
# 100 'big' cases with w, l, and h between 1e9 and 1e10.
# MATHEMATICSALGORITHMS
def num_blocks(w, l, h):
    x0_y0: int = w * l
    n: int = h
    n1: int = n - 1

    term1 = n * x0_y0
    term2 = (n1 * n * (w + l)) // 2
    term3 = (n1 * n * (2 * n - 1)) // 6

    return term1 + term2 + term3

# 443. String Compression
# Given an array of characters chars, compress it using the following algorithm:
# 
# Begin with an empty string s. For each group of consecutive repeating characters in chars:
# 
# If the group's length is 1, append the character to s.
# Otherwise, append the character followed by the group's length.
# The compressed string s should not be returned separately, but instead, be stored in the input character array chars. Note that group lengths that are 10 or longer will be split into multiple characters in chars.
# 
# After you are done modifying the input array, return the new length of the array.
# 
# You must write an algorithm that uses only constant extra space.
# 
#  
# 
# Example 1:
# 
# Input: chars = ["a","a","b","b","c","c","c"]
# Output: Return 6, and the first 6 characters of the input array should be: ["a","2","b","2","c","3"]
# Explanation: The groups are "aa", "bb", and "ccc". This compresses to "a2b2c3".
# Example 2:
# 
# Input: chars = ["a"]
# Output: Return 1, and the first character of the input array should be: ["a"]
# Explanation: The only group is "a", which remains uncompressed since it's a single character.
# Example 3:
# 
# Input: chars = ["a","b","b","b","b","b","b","b","b","b","b","b","b"]
# Output: Return 4, and the first 4 characters of the input array should be: ["a","b","1","2"].
# Explanation: The groups are "a" and "bbbbbbbbbbbb". This compresses to "ab12".
#  
# 
# Constraints:
# 
# 1 <= chars.length <= 2000
# chars[i] is a lowercase English letter, uppercase English letter, digit, or symbol.
# Complexity
# Time complexity: O(N)
# Space complexity: O(1)
# Code
class Solution:
    def compress(self, chars: List[str]) -> int:
        main_index: int = 0
        left = right = 0
        for current_index in range(1, len(chars)):
            if chars[current_index] == chars[right]:
                right += 1
            elif left == right:
                chars[main_index] = chars[left]
                main_index += 1
                left = right = current_index
            else:
                chars[main_index] = chars[left]
                main_index += 1
                for num in str(right - left + 1):
                    chars[main_index] = num
                    main_index += 1
                left = right = current_index
        if left == right:
            chars[main_index] = chars[left]
            main_index += 1
        else:
            chars[main_index] = chars[left]
            main_index += 1
            for num in str(right - left + 1):
                chars[main_index] = num
                main_index += 1
        return main_index

# While loop
# Complexity
# Time complexity: O(N)
# Space complexity: O(1)
# Code
class Solution:
    def compress(self, chars: List[str]) -> int:
        main_index: int = 0
        left: int = 0
        while left < len(chars):
            right: int = left
            frequence: int = 0
            while right < len(chars) and chars[right] == chars[left]:
                right += 1
                frequence += 1
            chars[main_index] = chars[left]
            main_index += 1
            if frequence > 1:
                for num in str(frequence):
                    chars[main_index] = num
                    main_index += 1
            left = right
        return main_index
        
# 560. Subarray Sum Equals K
# Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.
# 
# A subarray is a contiguous non-empty sequence of elements within an array.
# 
#  
# 
# Example 1:
# 
# Input: nums = [1,1,1], k = 2
# Output: 2
# Example 2:
# 
# Input: nums = [1,2,3], k = 3
# Output: 2
#  
# 
# Constraints:
# 
# 1 <= nums.length <= 2 * 104
# -1000 <= nums[i] <= 1000
# -107 <= k <= 107
class Solution(object):
    def subarraySum(self, nums, k):
        count: int = 0
        prefix_sum: int = 0
        prefix_sum_count: dict[int, int] = {0: 1}
        for num in nums:
            prefix_sum += num
            if prefix_sum - k in prefix_sum_count:
                count += prefix_sum_count[prefix_sum - k]
            prefix_sum_count[prefix_sum] = prefix_sum_count.get(prefix_sum, 0) + 1
        return count

# 2053. Kth Distinct String in an Array
# A distinct string is a string that is present only once in an array.
#
# Given an array of strings arr, and an integer k, return the kth distinct string present in arr. If there are fewer than k distinct strings, return an empty string "".
#
# Note that the strings are considered in the order in which they appear in the array.
#
#
#
# Example 1:
#
# Input: arr = ["d","b","c","b","c","a"], k = 2
# Output: "a"
# Explanation:
# The only distinct strings in arr are "d" and "a".
# "d" appears 1st, so it is the 1st distinct string.
# "a" appears 2nd, so it is the 2nd distinct string.
# Since k == 2, "a" is returned.
# Example 2:
#
# Input: arr = ["aaa","aa","a"], k = 1
# Output: "aaa"
# Explanation:
# All strings in arr are distinct, so the 1st string "aaa" is returned.
# Example 3:
#
# Input: arr = ["a","b","a"], k = 3
# Output: ""
# Explanation:
# The only distinct string is "b". Since there are fewer than 3 distinct strings, we return an empty string "".
#
#
# Constraints:
#
# 1 <= k <= arr.length <= 1000
# 1 <= arr[i].length <= 5
# arr[i] consists of lowercase English letters.
class Solution:
    def kthDistinct(self, arr: List[str], k: int) -> str:
        storage: dict[str, int] = dict()
        for char in arr:
            storage[char] = storage.get(char, 0) + 1
        idx: int = 0
        for char in storage:
            if storage[char] == 1:
                idx += 1
            if k == idx: return char
        return ''

# A. Remove Smallest
# A. Remove Smallest
# time limit per test1 second
# memory limit per test256 megabytes
# You are given the array a
#  consisting of n
#  positive (greater than zero) integers.
# 
# In one move, you can choose two indices i
#  and j
#  (i≠j
# ) such that the absolute difference between ai
#  and aj
#  is no more than one (|ai−aj|≤1
# ) and remove the smallest of these two elements. If two elements are equal, you can remove any of them (but exactly one).
# 
# Your task is to find if it is possible to obtain the array consisting of only one element using several (possibly, zero) such moves or not.
# 
# You have to answer t
#  independent test cases.
# 
# Input
# The first line of the input contains one integer t
#  (1≤t≤1000
# ) — the number of test cases. Then t
#  test cases follow.
# 
# The first line of the test case contains one integer n
#  (1≤n≤50
# ) — the length of a
# . The second line of the test case contains n
#  integers a1,a2,…,an
#  (1≤ai≤100
# ), where ai
#  is the i
# -th element of a
# .
# 
# Output
# For each test case, print the answer: "YES" if it is possible to obtain the array consisting of only one element using several (possibly, zero) moves described in the problem statement, or "NO" otherwise.
# 
# Example
# inputCopy
# 5
# 3
# 1 2 2
# 4
# 5 5 5 5
# 3
# 1 2 4
# 4
# 1 3 4 4
# 1
# 100
# outputCopy
# YES
# YES
# NO
# NO
# YES
# Note
# In the first test case of the example, we can perform the following sequence of moves:
# 
# choose i=1
#  and j=3
#  and remove ai
#  (so a
#  becomes [2;2]
# );
# choose i=1
#  and j=2
#  and remove aj
#  (so a
#  becomes [2]
# ).
# In the second test case of the example, we can choose any possible i
#  and j
#  any move and it doesn't matter which element we remove.
# 
# In the third test case of the example, there is no way to get rid of 2
#  and 4
# .
import sys


def solution(t: int) -> None:
    for _ in range(t):
        n: int = int(sys.stdin.readline().rstrip())
        nums: list = sorted(map(int, sys.stdin.readline().rstrip().split()))
        print(['NO', 'YES'][all(x - y <= 1 for y, x in zip(nums, nums[1:])) or len(nums) == 1])


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)

# Node Mania
# This kata is about singly-linked lists. A linked list is an ordered set of data elements, each containing a link to its successor (and sometimes its predecessor, known as a double linked list). You are you to implement an algorithm to find the kth to last element.
#
# k will be an integer greater than or equal to 1.
#
# Example
# For example given the following linked list: a -> b -> c -> d
#
# if k = 1 then d should be returned
# if k = 2 then c should be returned
# if k = 3 then b should be returned
# if k = 4 then a should be returned
# if k exceeds the length of the list then None(Python) or null(Java, JavaScript) or false (C) should be returned
# Each item in the linked list is a Node containing two fields:
#
# data - the value of the node
# next - pointing to the next node in the list, or to a null reference (null/NULL/None, depending on your language) for the last Node.
# An empty list is represented as a null reference.
#
# LINKED LISTSALGORITHMSDATA STRUCTURES
# in preloaded:
#class Node:
#    def __init__(self, data, next = None):
#        self.data = data
#        self.next = next
from preloaded import Node

def search_k_from_end(linked_list : Node, k : int):
    storage: list[int] = []
    tmp = linked_list
    while tmp:
        storage.append(tmp.data)
        tmp = tmp.next
    return storage.pop(-k) if k <= len(storage) else None
    
# 146. LRU Cache
# Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.
# 
# Implement the LRUCache class:
# 
# LRUCache(int capacity) Initialize the LRU cache with positive size capacity.
# int get(int key) Return the value of the key if the key exists, otherwise return -1.
# void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.
# The functions get and put must each run in O(1) average time complexity.
# 
#  
# 
# Example 1:
# 
# Input
# ["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
# [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
# Output
# [null, null, null, 1, null, -1, null, -1, 3, 4]
# 
# Explanation
# LRUCache lRUCache = new LRUCache(2);
# lRUCache.put(1, 1); // cache is {1=1}
# lRUCache.put(2, 2); // cache is {1=1, 2=2}
# lRUCache.get(1);    // return 1
# lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}
# lRUCache.get(2);    // returns -1 (not found)
# lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}
# lRUCache.get(1);    // return -1 (not found)
# lRUCache.get(3);    // return 3
# lRUCache.get(4);    // return 4
#  
# 
# Constraints:
# 
# 1 <= capacity <= 3000
# 0 <= key <= 104
# 0 <= value <= 105
# At most 2 * 105 calls will be made to get and put.
class LRUCache:

    def __init__(self, capacity: int):
        self.hashmap: dict[int, int] = dict()
        self.capacity: int = capacity


    def get(self, key: int) -> int:
        if key not in self.hashmap: return -1
        # Move current element to the end of hashmap
        value: int = self.hashmap[key]
        del self.hashmap[key]
        self.hashmap[key] = value
        return value


    def put(self, key: int, value: int) -> None:
        if key in self.hashmap:
            # Move to the end updated element
            del self.hashmap[key]
            self.hashmap[key] = value
            return
        # If capacity exeeds, we should delete first element from hashmap
        if len(self.hashmap) == self.capacity:
            del self.hashmap[next(iter(self.hashmap))]
        # Inserting at the end of map new pair
        self.hashmap[key] = value


# Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)

# 3016. Minimum Number of Pushes to Type Word II
# You are given a string word containing lowercase English letters.
#
# Telephone keypads have keys mapped with distinct collections of lowercase English letters, which can be used to form words by pushing them. For example, the key 2 is mapped with ["a","b","c"], we need to push the key one time to type "a", two times to type "b", and three times to type "c" .
#
# It is allowed to remap the keys numbered 2 to 9 to distinct collections of letters. The keys can be remapped to any amount of letters, but each letter must be mapped to exactly one key. You need to find the minimum number of times the keys will be pushed to type the string word.
#
# Return the minimum number of pushes needed to type word after remapping the keys.
#
# An example mapping of letters to keys on a telephone keypad is given below. Note that 1, *, #, and 0 do not map to any letters.
#
#
#
#
# Example 1:
#
#
# Input: word = "abcde"
# Output: 5
# Explanation: The remapped keypad given in the image provides the minimum cost.
# "a" -> one push on key 2
# "b" -> one push on key 3
# "c" -> one push on key 4
# "d" -> one push on key 5
# "e" -> one push on key 6
# Total cost is 1 + 1 + 1 + 1 + 1 = 5.
# It can be shown that no other mapping can provide a lower cost.
# Example 2:
#
#
# Input: word = "xyzxyzxyzxyz"
# Output: 12
# Explanation: The remapped keypad given in the image provides the minimum cost.
# "x" -> one push on key 2
# "y" -> one push on key 3
# "z" -> one push on key 4
# Total cost is 1 * 4 + 1 * 4 + 1 * 4 = 12
# It can be shown that no other mapping can provide a lower cost.
# Note that the key 9 is not mapped to any letter: it is not necessary to map letters to every key, but to map all the letters.
# Example 3:
#
#
# Input: word = "aabbccddeeffgghhiiiiii"
# Output: 24
# Explanation: The remapped keypad given in the image provides the minimum cost.
# "a" -> one push on key 2
# "b" -> one push on key 3
# "c" -> one push on key 4
# "d" -> one push on key 5
# "e" -> one push on key 6
# "f" -> one push on key 7
# "g" -> one push on key 8
# "h" -> two pushes on key 9
# "i" -> one push on key 9
# Total cost is 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 2 * 2 + 6 * 1 = 24.
# It can be shown that no other mapping can provide a lower cost.
#
#
# Constraints:
#
# 1 <= word.length <= 105
# word consists of lowercase English letters.
# Solution HashTable Greedy Counting Sorting O(N) O(1)
class Solution:
    def minimumPushes(self, word: str) -> int:
        storage: dict[str, int] = dict()
        for char in word:
            storage[char] = storage.get(char, 0) + 1
        chars: list[str] = sorted(storage.keys(), key=lambda x: storage[x], reverse=True)
        total_cost: int = 0
        button: int = 2
        letters_in_button: int = 1
        for char in chars:
            total_cost += letters_in_button * storage[char]
            button += 1
            if button == 10:
                button = 2
                letters_in_button += 1
        return total_cost
        
# A. Again Twenty Five!
# A. Again Twenty Five!
# time limit per test0.5 seconds
# memory limit per test64 megabytes
# The HR manager was disappointed again. The last applicant failed the interview the same way as 24 previous ones. "Do I give such a hard task?" — the HR manager thought. "Just raise number 5 to the power of n and get last two digits of the number. Yes, of course, n can be rather big, and one cannot find the power using a calculator, but we need people who are able to think, not just follow the instructions."
# 
# Could you pass the interview in the machine vision company in IT City?
# 
# Input
# The only line of the input contains a single integer n (2 ≤ n ≤ 2·1018) — the power in which you need to raise number 5.
# 
# Output
# Output the last two digits of 5n without spaces between them.
# 
# Examples
# inputCopy
# 2
# outputCopy
# 25
import sys

def solution(n: int) -> str:
    result: int = 1
    base: int = 5
    modulus: int = 100
    while n > 0:
        if n & 1:
            result = (result * base) % modulus
        n >>= 1
        base = (base * base) % modulus
    return str(result).zfill(2) 
if __name__ == '__main__':
    n: int = int(sys.stdin.readline().rstrip())
    sys.stdout.write(solution(n))

# Levenshtein Distance
# In information theory and computer science, the Levenshtein distance is a string metric for measuring the difference between two sequences. Informally, the Levenshtein distance between two words is the minimum number of single-character edits (i.e. insertions, deletions or substitutions) required to change one word into the other.
# 
# (http://en.wikipedia.org/wiki/Levenshtein_distance)
# 
# Your task is to implement a function which calculates the Levenshtein distance for two arbitrary strings.
# 
# STRINGSALGORITHMS
def levenshtein(a,b):
    cost: int = sum(x != y for x, y in zip(a, b))
    if len(a) == len(b): return cost
    up: int = max(len(a), len(b))
    do: int = min(len(a), len(b))
    big: str = a if len(a) == up else b
    small: str = a if len(a) == do else b
    for i in range(up):
        if up - i < do: break
        cost = min(cost, sum(x != y for x, y in zip(big[i:], small)))
    return cost + (up - do)

# 22. Generate Parentheses
# Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
#
#
#
# Example 1:
#
# Input: n = 3
# Output: ["((()))","(()())","(())()","()(())","()()()"]
# Example 2:
#
# Input: n = 1
# Output: ["()"]
#
#
# Constraints:
#
# 1 <= n <= 8
class Solution:
    def backtrack(self, n: int, left: int, right: int, output: list[str], result: list[str]) -> None:
        if left >= n and right >= n:
            result.append(''.join(output))

        if left < n:
            output.append('(')
            self.backtrack(n, left + 1, right, output, result)
            output.pop()
        if right < left:
            output.append(')')
            self.backtrack(n, left, right + 1, output, result)
            output.pop()

    def generateParenthesis(self, n: int) -> List[str]:
        result: list[str] = []
        output: list[str] = []
        self.backtrack(n, 0, 0, output, result)
        return result

# 567. Permutation in String
# Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.
# 
# In other words, return true if one of s1's permutations is the substring of s2.
# 
#  
# 
# Example 1:
# 
# Input: s1 = "ab", s2 = "eidbaooo"
# Output: true
# Explanation: s2 contains one permutation of s1 ("ba").
# Example 2:
# 
# Input: s1 = "ab", s2 = "eidboaoo"
# Output: false
#  
# 
# Constraints:
# 
# 1 <= s1.length, s2.length <= 104
# s1 and s2 consist of lowercase English letters.
class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        storage: dict[str, int] = dict()
        for char in s1:
            storage[char] = storage.get(char, 0) + 1
        k: int = len(s1)
        left: int = 0
        for right in range(len(s2)):
            # Case when letter from s2 not exist in s1
            if s2[right] not in storage:
                while left < right:
                    storage[s2[left]] += 1
                    left += 1
                left += 1
            # Case when letter from s2 exist, but frequence of it letter is exeed
            elif storage[s2[right]] == 0:
                while storage[s2[right]] == 0:
                    storage[s2[left]] += 1
                    left += 1
                storage[s2[right]] -= 1
            # Case when letter from s2 exist in s1
            else: storage[s2[right]] -= 1
            if right - left + 1 == k: return True
        return False

# 933. Number of Recent Calls
# You have a RecentCounter class which counts the number of recent requests within a certain time frame.
# 
# Implement the RecentCounter class:
# 
# RecentCounter() Initializes the counter with zero recent requests.
# int ping(int t) Adds a new request at time t, where t represents some time in milliseconds, and returns the number of requests that has happened in the past 3000 milliseconds (including the new request). Specifically, return the number of requests that have happened in the inclusive range [t - 3000, t].
# It is guaranteed that every call to ping uses a strictly larger value of t than the previous call.
# 
#  
# 
# Example 1:
# 
# Input
# ["RecentCounter", "ping", "ping", "ping", "ping"]
# [[], [1], [100], [3001], [3002]]
# Output
# [null, 1, 2, 3, 3]
# 
# Explanation
# RecentCounter recentCounter = new RecentCounter();
# recentCounter.ping(1);     // requests = [1], range is [-2999,1], return 1
# recentCounter.ping(100);   // requests = [1, 100], range is [-2900,100], return 2
# recentCounter.ping(3001);  // requests = [1, 100, 3001], range is [1,3001], return 3
# recentCounter.ping(3002);  // requests = [1, 100, 3001, 3002], range is [2,3002], return 3
#  
# 
# Constraints:
# 
# 1 <= t <= 109
# Each test case will call ping with strictly increasing values of t.
# At most 104 calls will be made to ping.
# Binary Search
# Complexity
# Time complexity: O(NlogN)
# Space complexity: O(N)
# Code
class RecentCounter:
    def __init__(self):
        self.requests: list[int] = []

    def leftmost_binary_search(self, target: int) -> int:
        left: int = 0
        right: int = len(self.requests)
        while left <= right:
            middle: int = left + (right - left) // 2
            if self.requests[middle] >= target:
                right = middle - 1
            else: left = middle + 1
        return right + 1

    def ping(self, t: int) -> int:
        self.requests.append(t)
        lower_idx: int = self.leftmost_binary_search(t - 3_000)
        return len(self.requests) - lower_idx



# Your RecentCounter object will be instantiated and called as such:
# obj = RecentCounter()
# param_1 = obj.ping(t)

# Two pointers aka Sliding Window
# Complexity
# Time complexity: O(N)
# Space complexity: O(N)
# Code
class RecentCounter:
    def __init__(self):
        self.requests: list[int] = []
        self.left: int = 0

    def ping(self, t: int) -> int:
        self.requests.append(t)
        while self.requests[self.left] < t - 3_000:
            self.left += 1
        return len(self.requests) - self.left



# Your RecentCounter object will be instantiated and called as such:
# obj = RecentCounter()
# param_1 = obj.ping(t)

# A. Yet Another Two Integers Problem
# A. Yet Another Two Integers Problem
# time limit per test1 second
# memory limit per test256 megabytes
# You are given two integers a
#  and b
# .
#
# In one move, you can choose some integer k
#  from 1
#  to 10
#  and add it to a
#  or subtract it from a
# . In other words, you choose an integer k∈[1;10]
#  and perform a:=a+k
#  or a:=a−k
# . You may use different values of k
#  in different moves.
#
# Your task is to find the minimum number of moves required to obtain b
#  from a
# .
#
# You have to answer t
#  independent test cases.
#
# Input
# The first line of the input contains one integer t
#  (1≤t≤2⋅104
# ) — the number of test cases. Then t
#  test cases follow.
#
# The only line of the test case contains two integers a
#  and b
#  (1≤a,b≤109
# ).
#
# Output
# For each test case, print the answer: the minimum number of moves required to obtain b
#  from a
# .
#
# Example
# inputCopy
# 6
# 5 5
# 13 42
# 18 4
# 1337 420
# 123456789 1000000000
# 100500 9000
# outputCopy
# 0
# 3
# 2
# 92
# 87654322
# 9150
# Note
# In the first test case of the example, you don't need to do anything.
#
# In the second test case of the example, the following sequence of moves can be applied: 13→23→32→42
#  (add 10
# , add 9
# , add 10
# ).
#
# In the third test case of the example, the following sequence of moves can be applied: 18→10→4
#  (subtract 8
# , subtract 6
# ).
import sys


def solution(t: int) -> None:
    for _ in range(t):
        a, b = map(int, sys.stdin.readline().rstrip().split())
        remainder: int = max(a, b) - min(a, b)
        print(remainder // 10 + (remainder % 10 != 0))


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)

# Alex & snooker: scores.
# Alex is a devoted fan of snooker Masters and in particular, he recorded results of all matches. Help Alex to know the score of matches.
#
# Hint:
# A string with a score presented as follows: "24-79(72); 16-101(53); ..."
# "24" - Points scored the first player;
# "79" - the number of points of the second player.
# "(72)" - the maximum score for one approach.
# Also, the player's account may be expressed as 105(53,52):
# "105" - points in the frame, "53" and "52" - two separate numbers(not float) maximum points in the frame.
# Frames are separated by ";" and players score - "-"
# It should count the number of frames won by one and another player, and output the data as a "[10,7]"
#
# Statistics URL:
#
# STATISTICSARRAYSSTRINGSALGORITHMS
def frame(score):
    matches: list[str] = score.split('; ')
    first = second = 0
    for game in matches:
        while '(' in game:
            op: idx = game.index('(')
            cl: idx = game.index(')')
            game = game[:op] + game[cl + 1:]
        x, y = map(int, game.split('-'))
        if x > y:
            first += 1
        elif y > x:
            second += 1
    return [first, second]

# 273. Integer to English Words
# Convert a non-negative integer num to its English words representation.
# 
#  
# 
# Example 1:
# 
# Input: num = 123
# Output: "One Hundred Twenty Three"
# Example 2:
# 
# Input: num = 12345
# Output: "Twelve Thousand Three Hundred Forty Five"
# Example 3:
# 
# Input: num = 1234567
# Output: "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"
#  
# 
# Constraints:
# 
# 0 <= num <= 231 - 1
class Solution:
    def get_string_representation(self, n: int) -> list[str]:
        if n == 0: return ['Zero']
        modules: dict[int, str] = {
            1_000_000_000: 'Billion', 1_000_000: 'Million',
            1_000: 'Thousand', 100: 'Hundred', 90: 'Ninety',
            80: 'Eighty', 70: 'Seventy', 60: 'Sixty',
            50: 'Fifty', 40: 'Forty', 30: 'Thirty',
            20: 'Twenty', 19: 'Nineteen', 18: 'Eighteen',
            17: 'Seventeen', 16: 'Sixteen', 15: 'Fifteen',
            14: 'Fourteen', 13: 'Thirteen', 12: 'Twelve', 11: 'Eleven',
            10: 'Ten', 9: 'Nine', 8: 'Eight',
            7: 'Seven', 6: 'Six', 5: 'Five', 4: 'Four', 3: 'Three',
            2: 'Two', 1: 'One',
        }
        have_own_names: set[int] = {
            90, 80, 70, 60, 50, 40, 30, 20,
            19, 18, 17, 16, 15, 14, 13, 12,
            11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
        }
        output: list[str] = []
        for module in modules:
            if n >= module:
                if module in have_own_names:
                    output.append(modules[module])
                    n -= module
                else:
                    quotitent: int = n // module
                    str_quotitent: str = self.get_string_representation(quotitent)
                    # Because str_quotitent is list of strings
                    output.extend(str_quotitent)
                    output.append(modules[module])
                    n %= module
        return output

    def numberToWords(self, num: int) -> str:
        str_num: list[str] = self.get_string_representation(num)
        return ' '.join(str_num)

# 849. Maximize Distance to Closest Person
# You are given an array representing a row of seats where seats[i] = 1 represents a person sitting in the ith seat, and seats[i] = 0 represents that the ith seat is empty (0-indexed).
# 
# There is at least one empty seat, and at least one person sitting.
# 
# Alex wants to sit in the seat such that the distance between him and the closest person to him is maximized. 
# 
# Return that maximum distance to the closest person.
# 
#  
# 
# Example 1:
# 
# 
# Input: seats = [1,0,0,0,1,0,1]
# Output: 2
# Explanation: 
# If Alex sits in the second open seat (i.e. seats[2]), then the closest person has distance 2.
# If Alex sits in any other open seat, the closest person has distance 1.
# Thus, the maximum distance to the closest person is 2.
# Example 2:
# 
# Input: seats = [1,0,0,0]
# Output: 3
# Explanation: 
# If Alex sits in the last seat (i.e. seats[3]), the closest person is 3 seats away.
# This is the maximum distance possible, so the answer is 3.
# Example 3:
# 
# Input: seats = [0,1]
# Output: 1
#  
# 
# Constraints:
# 
# 2 <= seats.length <= 2 * 104
# seats[i] is 0 or 1.
# At least one seat is empty.
# At least one seat is occupied.
class Solution:
    def maxDistToClosest(self, seats: List[int]) -> int:
        left: int = 0
        max_distance: int = 0
        for right in range(len(seats)):
            if seats[right]:
                if left == 0 and seats[left] == 0:
                    max_distance = max(max_distance, right)
                else: max_distance = max(max_distance, (right - left) // 2)
                left = right
        return max(max_distance, len(seats) - left - 1)

# 885. Spiral Matrix III
# You start at the cell (rStart, cStart) of an rows x cols grid facing east. The northwest corner is at the first row and column in the grid, and the southeast corner is at the last row and column.
#
# You will walk in a clockwise spiral shape to visit every position in this grid. Whenever you move outside the grid's boundary, we continue our walk outside the grid (but may return to the grid boundary later.). Eventually, we reach all rows * cols spaces of the grid.
#
# Return an array of coordinates representing the positions of the grid in the order you visited them.
#
#
#
# Example 1:
#
#
# Input: rows = 1, cols = 4, rStart = 0, cStart = 0
# Output: [[0,0],[0,1],[0,2],[0,3]]
# Example 2:
#
#
# Input: rows = 5, cols = 6, rStart = 1, cStart = 4
# Output: [[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]
#
#
# Constraints:
#
# 1 <= rows, cols <= 100
# 0 <= rStart < rows
# 0 <= cStart < cols
class Solution:
    def check(self, cur_row: int, cur_col: int, rows: int, cols: int, result: list[list[int]]) -> None:
        if 0 <= cur_row < rows and 0 <= cur_col < cols:
            result.append([cur_row, cur_col])

    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:
        output: list[list[int]] = [[rStart, cStart]]
        cur_row, cur_col = rStart, cStart
        boundary: int = 1
        cur_col += 1
        # Make first move from center to right
        self.check(cur_row, cur_col, rows, cols, output)
        while len(output) < rows * cols:
            # Move from upper right corner to down right corner
            down_boundary: int = cur_row + boundary
            cur_row += 1
            while cur_row < down_boundary:
                self.check(cur_row, cur_col, rows, cols, output)
                cur_row += 1

            boundary += 1
            # Move from down right corner to down left corner
            left_boundary: int = cur_col - boundary
            while cur_col > left_boundary:
                self.check(cur_row, cur_col, rows, cols, output)
                cur_col -= 1
            # Move from down left corner to upper left corner
            upper_boundary: int = cur_row - boundary
            while cur_row > upper_boundary:
                self.check(cur_row, cur_col, rows, cols, output)
                cur_row -= 1
            # Move from upper left corner to upper right corner
            right_boundary: int = cur_col + boundary
            while cur_col <= right_boundary:
                self.check(cur_row, cur_col, rows, cols, output)
                cur_col += 1
            # Check upper right corner + 1
            self.check(cur_row, cur_col, rows, cols, output)

            boundary += 1

        return output

# A. Sereja and Dima
# A. Sereja and Dima
# time limit per test1 second
# memory limit per test256 megabytes
# Sereja and Dima play a game. The rules of the game are very simple. The players have n cards in a row. Each card contains a number, all numbers on the cards are distinct. The players take turns, Sereja moves first. During his turn a player can take one card: either the leftmost card in a row, or the rightmost one. The game ends when there is no more cards. The player who has the maximum sum of numbers on his cards by the end of the game, wins.
# 
# Sereja and Dima are being greedy. Each of them chooses the card with the larger number during his move.
# 
# Inna is a friend of Sereja and Dima. She knows which strategy the guys are using, so she wants to determine the final score, given the initial state of the game. Help her.
# 
# Input
# The first line contains integer n (1 ≤ n ≤ 1000) — the number of cards on the table. The second line contains space-separated numbers on the cards from left to right. The numbers on the cards are distinct integers from 1 to 1000.
# 
# Output
# On a single line, print two integers. The first number is the number of Sereja's points at the end of the game, the second number is the number of Dima's points at the end of the game.
# 
# Examples
# inputCopy
# 4
# 4 1 2 10
# outputCopy
# 12 5
# inputCopy
# 7
# 1 2 3 4 5 6 7
# outputCopy
# 16 12
# Note
# In the first sample Sereja will take cards with numbers 10 and 2, so Sereja's sum is 12. Dima will take cards with numbers 4 and 1, so Dima's sum is 5.
import sys


def solution(n: int, cards: list) -> str:
    dima: int = 0
    serj: int = 0
    flag: bool = True
    left: int = 0
    right: int = n - 1
    while left <= right:
        if cards[left] > cards[right]:
            current_card: int = cards[left]
            left += 1
        else:
            current_card: int = cards[right]
            right -= 1
        if flag:
            serj += current_card
        else:
            dima += current_card
        flag = not flag
    return f'{serj} {dima}'


if __name__ == '__main__':
    n: int = int(sys.stdin.readline().rstrip())
    cards: list = list(map(int, sys.stdin.readline().rstrip().split()))
    sys.stdout.write(solution(n, cards))

# Vector Affinity
# Calculate the number of items in a vector that appear at the same index in each vector, with the same value.
#
#    vector_affinity([1, 2, 3, 4, 5], [1, 2, 2, 4, 3]) # => 0.6
#    vector_affinity([1, 2, 3], [1, 2, 3]) # => 1.0
# Affinity value should be realized on a scale of 0.0 to 1.0, with 1.0 being absolutely identical. Two identical sets should always be evaulated as having an affinity or 1.0.
#
# Hint: The last example test case holds a significant clue to calculating the affinity correctly.
#
# DATA STRUCTURESALGORITHMS
def vector_affinity(a, b):
    score: int = sum(a[idx] == b[idx] for idx in range(min(len(a), len(b))))
    module: int = max(len(a), len(b))
    return score / module if module != 0 else [0.0, 1.0][len(a) == len(b)]

# A. Marathon
# A. Marathon
# time limit per test1 second
# memory limit per test256 megabytes
# You are given four distinct integers a
# , b
# , c
# , d
# .
#
# Timur and three other people are running a marathon. The value a
#  is the distance that Timur has run and b
# , c
# , d
#  correspond to the distances the other three participants ran.
#
# Output the number of participants in front of Timur.
#
# Input
# The first line contains a single integer t
#  (1≤t≤104
# ) — the number of test cases.
#
# The description of each test case consists of four distinct integers a
# , b
# , c
# , d
#  (0≤a,b,c,d≤104
# ).
#
# Output
# For each test case, output a single integer — the number of participants in front of Timur.
#
# Example
# inputCopy
# 4
# 2 3 4 1
# 10000 0 1 2
# 500 600 400 300
# 0 9999 10000 9998
# outputCopy
# 2
# 0
# 1
# 3
# Note
# For the first test case, there are 2
#  people in front of Timur, specifically the participants who ran distances of 3
#  and 4
# . The other participant is not in front of Timur because he ran a shorter distance than Timur.
#
# For the second test case, no one is in front of Timur, since he ran a distance of 10000
#  while all others ran a distance of 0
# , 1
# , and 2
#  respectively.
#
# For the third test case, only the second person is in front of Timur, who ran a total distance of 600
#  while Timur ran a distance of 500
# .
# Solution Math O(N) O(1)
import sys


def solution(t: int) -> None:
    for _ in range(t):
        peoples: list = list(map(int, sys.stdin.readline().rstrip().split()))
        print(sum(peoples[0] < people for people in peoples))


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)

# Swap Node Pairs In Linked List
# You are given the head node of a singly-linked list. Write a method that swaps each pair of nodes in the list, then returns the head node of the list. You have to swap the nodes themselves, not their values.
#
# Example:
#
# (A --> B --> C --> D) => (B --> A --> D --> C)
#
# The swapping should be done left to right, so if the list has an odd length, the last node stays in place:
#
# (A --> B --> C) => (B --> A --> C)
#
# The list will be composed of Nodes of the following specification:
#
# class Node:
#     def __init__(self, next=None):
#         self.next = next
# ALGORITHMSDATA STRUCTURESLINKED LISTS
from preloaded import Node

def swap_pairs(head):
    length: int = 0
    tmp: Node = head
    while tmp:
        length += 1
        tmp = tmp.next
    if length <= 1: return head
    first: Node = head
    second: Node = head.next
    first.next = second.next
    second.next = first
    head = second
    tmp = head.next
    while tmp:
        first: Node = tmp.next
        if not first: break
        second: Node = tmp.next.next
        if not second: break
        first.next = second.next
        second.next = first
        tmp.next = second
        tmp = tmp.next.next
    return head

# 840. Magic Squares In Grid
# A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum.
# 
# Given a row x col grid of integers, how many 3 x 3 contiguous magic square subgrids are there?
# 
# Note: while a magic square can only contain numbers from 1 to 9, grid may contain numbers up to 15.
# 
#  
# 
# Example 1:
# 
# 
# Input: grid = [[4,3,8,4],[9,5,1,9],[2,7,6,2]]
# Output: 1
# Explanation: 
# The following subgrid is a 3 x 3 magic square:
# 
# while this one is not:
# 
# In total, there is only one magic square inside the given grid.
# Example 2:
# 
# Input: grid = [[8]]
# Output: 0
#  
# 
# Constraints:
# 
# row == grid.length
# col == grid[i].length
# 1 <= row, col <= 10
# 0 <= grid[i][j] <= 15
class Solution:
    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:
        magic_squares: int = 0
        if len(grid) < 3 or len(grid[0]) < 3:
            return magic_squares

        row_rep: int = 0
        while row_rep + 3 <= len(grid):
            col_rep: int = 0
            while col_rep + 3 <= len(grid[0]):
                numbers_in_square: set[int] = set()
                square_sum: int = 0
                valid: bool = True
                for row in range(row_rep, row_rep + 3):
                    for col in range(col_rep, col_rep + 3):
                        ceil: int = grid[row][col]
                        if ceil in numbers_in_square or ceil == 0 or ceil > 9:
                            valid = False
                            break
                        else:
                            numbers_in_square.add(ceil)
                    if not valid: break
                if valid:
                    row_sum: int = sum(grid[row_rep][col_rep:col_rep + 3])
                    diag_sum: int = 0
                    idx: int = 0
                    for row in grid[row_rep:row_rep + 3]:
                        diag_sum += row[col_rep:col_rep + 3][idx]
                        idx += 1
                    reverse_diag_sum: int = 0
                    idx: int = 2
                    for row in grid[row_rep:row_rep + 3]:
                        reverse_diag_sum += row[col_rep:col_rep + 3][idx]
                        idx -= 1
                    if (
                        all(sum(grid[row][col_rep:col_rep + 3]) == row_sum for row in range(row_rep, row_rep + 3))
                        and all(
                            sum(grid[row][col] for row in range(row_rep, row_rep + 3)
                            ) == row_sum for col in range(col_rep, col_rep + 3)
                        ) and diag_sum == row_sum == reverse_diag_sum
                    ):
                        magic_squares += 1
                col_rep += 1
            row_rep += 1
        return magic_squares

# 56. Merge Intervals
# Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.
#
#
#
# Example 1:
#
# Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
# Output: [[1,6],[8,10],[15,18]]
# Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].
# Example 2:
#
# Input: intervals = [[1,4],[4,5]]
# Output: [[1,5]]
# Explanation: Intervals [1,4] and [4,5] are considered overlapping.
#
#
# Constraints:
#
# 1 <= intervals.length <= 104
# intervals[i].length == 2
# 0 <= starti <= endi <= 104
# Solution
# Merging in extra array
# Complexity
# Time complexity: O(NlogN)
# Space complexity: O(N)
# Code
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort()
        output: list[list[int]] = []
        start, end = intervals[0]
        for idx in range(1, len(intervals)):
            next_start, next_end = intervals[idx]
            if end >= next_start:
                end = max(end, next_end)
            else:
                output.append([start, end])
                start, end = next_start, next_end
        output.append([start, end])
        return output

# Merging in place
# Complexity
# Time complexity: O(NlogN)
# Space complexity: O(M), where M represent total count of merged intervals and in worst case it can be O(N),
# but operation of adding merged pairs in array have a O(1) time
# Code
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort()
        main_idx: int = 0
        start, end = intervals[0]
        for idx in range(1, len(intervals)):
            next_start, next_end = intervals[idx]
            if end >= next_start:
                end = max(end, next_end)
            else:
                intervals[main_idx] = [start, end]
                start, end = next_start, next_end
                main_idx += 1
        intervals[main_idx] = [start, end]
        main_idx += 1
        return intervals[:main_idx]

# 959. Regions Cut By Slashes
# An n x n grid is composed of 1 x 1 squares where each 1 x 1 square consists of a '/', '\', or blank space ' '. These characters divide the square into contiguous regions.
#
# Given the grid grid represented as a string array, return the number of regions.
#
# Note that backslash characters are escaped, so a '\' is represented as '\\'.
#
#
#
# Example 1:
#
#
# Input: grid = [" /","/ "]
# Output: 2
# Example 2:
#
#
# Input: grid = [" /","  "]
# Output: 1
# Example 3:
#
#
# Input: grid = ["/\\","\\/"]
# Output: 5
# Explanation: Recall that because \ characters are escaped, "\\/" refers to \/, and "/\\" refers to /\.
#
#
# Constraints:
#
# n == grid.length == grid[i].length
# 1 <= n <= 30
# grid[i][j] is either '/', '\', or ' '.
class Solution:
    def __init__(self):
        self.parent: list[int] = []
        self.rank: list[int] = []
        self.count: int = 0

    def regionsBySlashes(self, grid):
        n: int = len(grid)
        dots: int = n + 1
        self.parent: list[int] = [i for i in range(dots * dots)]
        self.rank: list[int] = [1] * (dots * dots)

        for row in range(dots):
            for col in range(dots):
                if row == 0 or col == 0 or row == n or col == n:
                    cell: int = row * dots + col
                    self.union(0, cell)

        for row in range(n):
            for col in range(n):
                if grid[row][col] == '\\':
                    cell1: int = row * dots + col
                    cell2: int = (row + 1) * dots + (col + 1)
                    self.union(cell1, cell2)
                elif grid[row][col] == '/':
                    cell1: int = (row + 1) * dots + col
                    cell2: int = row * dots + (col + 1)
                    self.union(cell1, cell2)

        return self.count

    def union(self, a, b):
        parent_a: int = self.find(a)
        parent_b: int = self.find(b)
        if parent_a == parent_b:
            self.count += 1
        else:
            if self.rank[parent_a] > self.rank[parent_b]:
                self.parent[parent_b] = parent_a
            elif self.rank[parent_a] < self.rank[parent_b]:
                self.parent[parent_a] = parent_b
            else:
                self.parent[parent_b] = parent_a
                self.rank[parent_a] += 1

    def find(self, a):
        if self.parent[a] == a:
            return a
        self.parent[a] = self.find(self.parent[a])
        return self.parent[a]

# A. Game With Sticks
# A. Game With Sticks
# time limit per test1 second
# memory limit per test256 megabytes
# After winning gold and silver in IOI 2014, Akshat and Malvika want to have some fun. Now they are playing a game on a grid made of n horizontal and m vertical sticks.
# 
# An intersection point is any point on the grid which is formed by the intersection of one horizontal stick and one vertical stick.
# 
# In the grid shown below, n = 3 and m = 3. There are n + m = 6 sticks in total (horizontal sticks are shown in red and vertical sticks are shown in green). There are n·m = 9 intersection points, numbered from 1 to 9.
# 
# 
# The rules of the game are very simple. The players move in turns. Akshat won gold, so he makes the first move. During his/her move, a player must choose any remaining intersection point and remove from the grid all sticks which pass through this point. A player will lose the game if he/she cannot make a move (i.e. there are no intersection points remaining on the grid at his/her move).
# 
# Assume that both players play optimally. Who will win the game?
# 
# Input
# The first line of input contains two space-separated integers, n and m (1 ≤ n, m ≤ 100).
# 
# Output
# Print a single line containing "Akshat" or "Malvika" (without the quotes), depending on the winner of the game.
# 
# Examples
# inputCopy
# 2 2
# outputCopy
# Malvika
# inputCopy
# 2 3
# outputCopy
# Malvika
# inputCopy
# 3 3
# outputCopy
# Akshat
# Note
# Explanation of the first sample:
# 
# The grid has four intersection points, numbered from 1 to 4.
# 
# 
# If Akshat chooses intersection point 1, then he will remove two sticks (1 - 2 and 1 - 3). The resulting grid will look like this.
# 
# 
# Now there is only one remaining intersection point (i.e. 4). Malvika must choose it and remove both remaining sticks. After her move the grid will be empty.
# 
# In the empty grid, Akshat cannot make any move, hence he will lose.
# 
# Since all 4 intersection points of the grid are equivalent, Akshat will lose no matter which one he picks.
import sys

def solution(n: int, m: int) -> str:
    return ['Malvika', 'Akshat'][min(n, m) & 1]

if __name__ == '__main__':
    n, m = map(int, sys.stdin.readline().rstrip().split())
    sys.stdout.write(solution(n, m))

# Linked Lists - Remove Duplicates
# Linked Lists - Remove Duplicates
#
# Write a RemoveDuplicates() function which takes a list sorted in increasing order and deletes any duplicate nodes from the list. Ideally, the list should only be traversed once. The head of the resulting list should be returned.
#
# var list = 1 -> 2 -> 3 -> 3 -> 4 -> 4 -> 5 -> null
# removeDuplicates(list) === 1 -> 2 -> 3 -> 4 -> 5 -> null
# If the passed in list is null/None/nil, simply return null.
#
# Note: Your solution is expected to work on long lists. Recursive solutions may fail due to stack size limitations.
#
# The push() and buildOneTwoThree() functions need not be redefined.
#
# Related Kata in order of expected completion (increasing difficulty):
#  Linked Lists - Push & BuildOneTwoThree
#  Linked Lists - Length & Count
#  Linked Lists - Get Nth Node
# Linked Lists - Insert Nth Node
# Linked Lists - Sorted Insert
# Linked Lists - Insert Sort
# Linked Lists - Append
# Linked Lists - Remove Duplicates
# Linked Lists - Move Node
# Linked Lists - Move Node In-place
# Linked Lists - Alternating Split
# Linked Lists - Front Back Split
# Linked Lists - Shuffle Merge
# Linked Lists - Sorted Merge
# Linked Lists - Merge Sort
# Linked Lists - Sorted Intersect
# Linked Lists - Iterative Reverse
# Linked Lists - Recursive Reverse
#
# Inspired by Stanford Professor Nick Parlante's excellent Linked List teachings.
#
# LINKED LISTSDATA STRUCTURESFUNDAMENTALS
class Node(object):
    def __init__(self, data):
        self.data = data
        self.next = None

def remove_duplicates(head):
    tmp: Node = head
    while tmp and tmp.next:
        if tmp.data == tmp.next.data:
            tmp.next = tmp.next.next
        else: tmp = tmp.next
    return head

# 438. Find All Anagrams in a String
# Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may return the answer in any order.
#
# An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.
#
#
#
# Example 1:
#
# Input: s = "cbaebabacd", p = "abc"
# Output: [0,6]
# Explanation:
# The substring with start index = 0 is "cba", which is an anagram of "abc".
# The substring with start index = 6 is "bac", which is an anagram of "abc".
# Example 2:
#
# Input: s = "abab", p = "ab"
# Output: [0,1,2]
# Explanation:
# The substring with start index = 0 is "ab", which is an anagram of "ab".
# The substring with start index = 1 is "ba", which is an anagram of "ab".
# The substring with start index = 2 is "ab", which is an anagram of "ab".
#
#
# Constraints:
#
# 1 <= s.length, p.length <= 3 * 104
# s and p consist of lowercase English letters.
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        anagrams: list[int] = []
        # Map of charackters that needed to create anagram of "p"
        needed: dict[str, int] = dict()
        for char in p:
            needed[char] = needed.get(char, 0) + 1
        # Length of valid anagram
        k: int = len(p)
        # Current length of sliding window
        length_window: int = 0
        # Start pointer of sliding window
        left: int = 0
        for right in range(len(s)):
            # If we meet charackter that doesnt exist in "p"
            if s[right] not in needed:
                while left < right:
                    needed[s[left]] += 1
                    left += 1
                    length_window -= 1
                left += 1
            # If we meet correct character, but his frequence is exceed
            elif needed[s[right]] == 0:
                while needed[s[right]] == 0:
                    needed[s[left]] += 1
                    left += 1
                    length_window -= 1
                needed[s[right]] -= 1
                length_window += 1
            # If we meet correct character and have frequence for him
            else:
                needed[s[right]] -= 1
                length_window += 1
            # Check if our length of sliding window is "k"
            if length_window == k:
                anagrams.append(left)

        return anagrams

# A. Cut Ribbon
# A. Cut Ribbon
# time limit per test1 second
# memory limit per test256 megabytes
# Polycarpus has a ribbon, its length is n. He wants to cut the ribbon in a way that fulfils the following two conditions:
#
# After the cutting each ribbon piece should have length a, b or c.
# After the cutting the number of ribbon pieces should be maximum.
# Help Polycarpus and find the number of ribbon pieces after the required cutting.
#
# Input
# The first line contains four space-separated integers n, a, b and c (1 ≤ n, a, b, c ≤ 4000) — the length of the original ribbon and the acceptable lengths of the ribbon pieces after the cutting, correspondingly. The numbers a, b and c can coincide.
#
# Output
# Print a single number — the maximum possible number of ribbon pieces. It is guaranteed that at least one correct ribbon cutting exists.
#
# Examples
# inputCopy
# 5 5 3 2
# outputCopy
# 2
# inputCopy
# 7 5 5 2
# outputCopy
# 2
# Note
# In the first example Polycarpus can cut the ribbon in such way: the first piece has length 2, the second piece has length 3.
#
# In the second example Polycarpus can cut the ribbon in such way: the first piece has length 5, the second piece has length 2.
from typing import List
import sys

def solution(n: int, a: int, b: int, c: int) -> str:
    modules: List[int] = sorted([a, b, c])
    dp: List[int] = [float('-inf')] * (n + 1)
    dp[0] = 0

    for piece in range(1, n + 1):
        for module in modules:
            if piece >= module:
                dp[piece] = max(dp[piece], dp[piece - module] + 1)

    return str(dp[n] if dp[n] != float('-inf') else 0)

if __name__ == "__main__":
    n, a, b, c = map(int, sys.stdin.readline().rstrip().split())
    sys.stdout.write(solution(n, a, b, c))

# 1568. Minimum Number of Days to Disconnect Island
# You are given an m x n binary grid grid where 1 represents land and 0 represents water. An island is a maximal 4-directionally (horizontal or vertical) connected group of 1's.
#
# The grid is said to be connected if we have exactly one island, otherwise is said disconnected.
#
# In one day, we are allowed to change any single land cell (1) into a water cell (0).
#
# Return the minimum number of days to disconnect the grid.
#
#
#
# Example 1:
#
#
# Input: grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]
#
# Output: 2
# Explanation: We need at least 2 days to get a disconnected grid.
# Change land grid[1][1] and grid[0][2] to water and get 2 disconnected island.
# Example 2:
#
#
# Input: grid = [[1,1]]
# Output: 2
# Explanation: Grid of full water is also disconnected ([[1,1]] -> [[0,0]]), 0 islands.
#
#
# Constraints:
#
# m == grid.length
# n == grid[i].length
# 1 <= m, n <= 30
# grid[i][j] is either 0 or 1.
class Solution:
    def next_valid_ceil(
        self, row: int, col: int, n: int, m: int, seen: set[int], grid: list[list[int]]
    ) -> bool:
        return 0 <= row < n and 0 <= col < m and grid[row][col] == 1 and (row, col) not in seen

    def dfs(
        self, row: int, col: int, grid: list[list[int]], seen: set[int]
    ) -> None:
        stack: list[tuple[int, int]] = [(row, col)]
        directions: list[tuple[int, int]] = [
            (-1, 0), (1, 0), (0, -1), (0, 1)
        ]
        while stack:
            row, col = stack.pop()
            for path in directions:
                next_row, next_col = row + path[0], col + path[1]
                if self.next_valid_ceil(next_row, next_col, len(grid), len(grid[0]), seen, grid):
                    seen.add((next_row, next_col))
                    stack.append((next_row, next_col))

    def count_islands(self, grid: list[list[int]]) -> int:
        seen: set[int] = set()
        islands: int = 0
        for row in range(len(grid)):
            for col in range(len(grid[0])):
                if grid[row][col] == 1 and (row, col) not in seen:
                    islands += 1
                    seen.add((row, col))
                    self.dfs(row, col, grid, seen)
        return islands

    def minDays(self, grid: List[List[int]]) -> int:
        if self.count_islands(grid) != 1:
            return 0

        for row in range(len(grid)):
            for col in range(len(grid[0])):
                if grid[row][col] == 1:
                    grid[row][col] = 0
                    if self.count_islands(grid) != 1:
                        return 1
                    grid[row][col] = 1

        return 2

# 3248. Snake in Matrix
# There is a snake in an n x n matrix grid and can move in four possible directions. Each cell in the grid is identified by the position: grid[i][j] = (i * n) + j.
#
# The snake starts at cell 0 and follows a sequence of commands.
#
# You are given an integer n representing the size of the grid and an array of strings commands where each command[i] is either "UP", "RIGHT", "DOWN", and "LEFT". It's guaranteed that the snake will remain within the grid boundaries throughout its movement.
#
# Return the position of the final cell where the snake ends up after executing commands.
#
#
#
# Example 1:
#
# Input: n = 2, commands = ["RIGHT","DOWN"]
#
# Output: 3
#
# Explanation:
#
# 0	1
# 2	3
# 0	1
# 2	3
# 0	1
# 2	3
# Example 2:
#
# Input: n = 3, commands = ["DOWN","RIGHT","UP"]
#
# Output: 1
#
# Explanation:
#
# 0	1	2
# 3	4	5
# 6	7	8
# 0	1	2
# 3	4	5
# 6	7	8
# 0	1	2
# 3	4	5
# 6	7	8
# 0	1	2
# 3	4	5
# 6	7	8
#
#
# Constraints:
#
# 2 <= n <= 10
# 1 <= commands.length <= 100
# commands consists only of "UP", "RIGHT", "DOWN", and "LEFT".
# The input is generated such the snake will not move outside of the boundaries.
class Solution:
    def finalPositionOfSnake(self, n: int, commands: List[str]) -> int:
        row = col = 0
        for command in commands:
            if command == 'RIGHT': col += 1
            elif command == 'LEFT': col -= 1
            elif command == 'UP': row -= 1
            else: row += 1
        return row * n + col

# 3249. Count the Number of Good Nodes
# There is an undirected tree with n nodes labeled from 0 to n - 1, and rooted at node 0. You are given a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.
#
# A node is good if all the
# subtrees
#  rooted at its children have the same size.
#
# Return the number of good nodes in the given tree.
#
# A subtree of treeName is a tree consisting of a node in treeName and all of its descendants.
#
#
#
# Example 1:
#
# Input: edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]]
#
# Output: 7
#
# Explanation:
#
#
# All of the nodes of the given tree are good.
#
# Example 2:
#
# Input: edges = [[0,1],[1,2],[2,3],[3,4],[0,5],[1,6],[2,7],[3,8]]
#
# Output: 6
#
# Explanation:
#
#
# There are 6 good nodes in the given tree. They are colored in the image above.
#
# Example 3:
#
# Input: edges = [[0,1],[1,2],[1,3],[1,4],[0,5],[5,6],[6,7],[7,8],[0,9],[9,10],[9,12],[10,11]]
#
# Output: 12
#
# Explanation:
#
#
# All nodes except node 9 are good.
#
#
#
# Constraints:
#
# 2 <= n <= 105
# edges.length == n - 1
# edges[i].length == 2
# 0 <= ai, bi < n
# The input is generated such that edges represents a valid tree.
class Solution:
    def countGoodNodes(self, edges: List[List[int]]) -> int:
        from collections import defaultdict, deque

        n: int = len(edges) + 1
        tree: dict[int, list[int]] = defaultdict(list)
        for u, v in edges:
            tree[u].append(v)
            tree[v].append(u)

        subtree_size: list[int] = [0] * n
        def dfs(node, parent):
            size = 1
            for neighbor in tree[node]:
                if neighbor != parent:
                    size += dfs(neighbor, node)
            subtree_size[node] = size
            return size

        dfs(0, -1)

        good_nodes_count: int = 0
        def is_good(node):
            sizes = set()
            for neighbor in tree[node]:
                if subtree_size[neighbor] < subtree_size[node]:  # Ensure it's a child
                    sizes.add(subtree_size[neighbor])
            return len(sizes) <= 1

        for node in range(n):
            if is_good(node):
                good_nodes_count += 1

        return good_nodes_count

# Linked Lists - Move Node
# Linked Lists - Move Node
#
# Write a MoveNode() function which takes the node from the front of the source list and moves it to the front of the destintation list. You should throw an error when the source list is empty. For simplicity, we use a Context object to store and return the state of the two linked lists. A Context object containing the two mutated lists should be returned by moveNode.
#
# MoveNode() is a handy utility function to have for later problems.
#
# JavaScript
# var source = 1 -> 2 -> 3 -> null
# var dest = 4 -> 5 -> 6 -> null
# moveNode(source, dest).source === 2 -> 3 -> null
# moveNode(source, dest).dest === 1 -> 4 -> 5 -> 6 -> null
# Python
# source = 1 -> 2 -> 3 -> None
# dest = 4 -> 5 -> 6 -> None
# move_node(source, dest).source == 2 -> 3 -> None
# move_node(source, dest).dest == 1 -> 4 -> 5 -> 6 -> None
# Ruby
# source = 1 -> 2 -> 3 -> nil
# dest = 4 -> 5 -> 6 -> nil
# move_node(source, dest).source == 2 -> 3 -> nil
# move_node(source, dest).dest == 1 -> 4 -> 5 -> 6 -> nil
# The push() and buildOneTwoThree() functions need not be redefined.
#
# There is another kata called Linked Lists - Move Node In-place that is related but more difficult.
#
# Related Kata in order of expected completion (increasing difficulty):
#  Linked Lists - Push & BuildOneTwoThree
#  Linked Lists - Length & Count
#  Linked Lists - Get Nth Node
# Linked Lists - Insert Nth Node
# Linked Lists - Sorted Insert
# Linked Lists - Insert Sort
# Linked Lists - Append
# Linked Lists - Remove Duplicates
# Linked Lists - Move Node
# Linked Lists - Move Node In-place
# Linked Lists - Alternating Split
# Linked Lists - Front Back Split
# Linked Lists - Shuffle Merge
# Linked Lists - Sorted Merge
# Linked Lists - Merge Sort
# Linked Lists - Sorted Intersect
# Linked Lists - Iterative Reverse
# Linked Lists - Recursive Reverse
#
# Inspired by Stanford Professor Nick Parlante's excellent Linked List teachings.
#
# LINKED LISTSDATA STRUCTURESFUNDAMENTALS
class Node(object):
    def __init__(self, data):
        self.data = data
        self.next = None

class Context(object):
    def __init__(self, source, dest):
        self.source = source
        self.dest = dest

def move_node(source, dest):
    if not source:
        raise Exception
    new_dest = Node(source.data)
    new_dest.next = dest
    dest = new_dest
    source = source.next
    return Context(source, dest)

# 703. Kth Largest Element in a Stream
# Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.
#
# Implement KthLargest class:
#
# KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums.
# int add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream.
#
#
# Example 1:
#
# Input
# ["KthLargest", "add", "add", "add", "add", "add"]
# [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]
# Output
# [null, 4, 5, 5, 8, 8]
#
# Explanation
# KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);
# kthLargest.add(3);   // return 4
# kthLargest.add(5);   // return 5
# kthLargest.add(10);  // return 5
# kthLargest.add(9);   // return 8
# kthLargest.add(4);   // return 8
#
#
# Constraints:
#
# 1 <= k <= 104
# 0 <= nums.length <= 104
# -104 <= nums[i] <= 104
# -104 <= val <= 104
# At most 104 calls will be made to add.
# It is guaranteed that there will be at least k elements in the array when you search for the kth element.
import heapq
class KthLargest:

    def __init__(self, k: int, nums: List[int]):
        self.k: int = k
        self.nums: list[int] = nums
        heapq.heapify(self.nums)
        while len(self.nums) > k:
            heapq.heappop(self.nums)

    def add(self, val: int) -> int:
        heapq.heappush(self.nums, val)
        while len(self.nums) > self.k:
            heapq.heappop(self.nums)
        return self.nums[0]


# Your KthLargest object will be instantiated and called as such:
# obj = KthLargest(k, nums)
# param_1 = obj.add(val)

# A. Spy Detected!
# A. Spy Detected!
# time limit per test2 seconds
# memory limit per test256 megabytes
# You are given an array a
#  consisting of n
#  (n≥3
# ) positive integers. It is known that in this array, all the numbers except one are the same (for example, in the array [4,11,4,4]
#  all numbers except one are equal to 4
# ).
#
# Print the index of the element that does not equal others. The numbers in the array are numbered from one.
#
# Input
# The first line contains a single integer t
#  (1≤t≤100
# ). Then t
#  test cases follow.
#
# The first line of each test case contains a single integer n
#  (3≤n≤100
# ) — the length of the array a
# .
#
# The second line of each test case contains n
#  integers a1,a2,…,an
#  (1≤ai≤100
# ).
#
# It is guaranteed that all the numbers except one in the a
#  array are the same.
#
# Output
# For each test case, output a single integer — the index of the element that is not equal to others.
#
# Example
# inputCopy
# 4
# 4
# 11 13 11 11
# 5
# 1 4 4 4 4
# 10
# 3 3 3 3 10 3 3 3 3 3
# 3
# 20 20 10
# outputCopy
# 2
# 1
# 5
# 3
import sys

def solution(t: int) -> None:
    for _ in range(t):
        n: int = int(sys.stdin.readline().rstrip())
        nums: list = list(map(int, sys.stdin.readline().rstrip().split()))
        hashset: set = set()
        hashset.add(nums[0])
        if nums[1] not in hashset:
            if nums[2] not in hashset:
                print(1)
            else:
                print(2)
        else:
            for idx in range(n):
                if nums[idx] not in hashset:
                    print(idx + 1)
                    break

if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)

# Binary search tree validation
# A binary search tree is a binary tree that is ordered. This means that if you were to convert the tree to an array using an in-order traversal, the array would be in sorted order. The benefit gained by this ordering is that when the tree is balanced, searching is a logarithmic time operation, since each node you look at that isn't the one you're searching for lets you discard half of the tree.
#
# If you haven't worked with binary trees before or don't understand what a traversal is, you can learn more about that here: https://www.codewars.com/kata/binary-tree-traversal.
#
# In this kata, you will write a function that will validate that a given binary tree is a binary search tree. The sort order is not predefined so it should work with either.
#
# These are valid binary search trees:
#
#     5
#    / \
#   2   7
#  / \   \
# 1   3   9
#
#
#   7
#  / \
# 9   2
# while these are not:
#
#   1
#  / \
# 2   3
#
#
#   5
#  / \
# 2   9
#  \
#   7
# There are several different approaches you can take to solve this kata. If you're not as comfortable with recursion I'd recommend practicing that.
#
# Note: no test case tree will contain duplicate numbers.
#
# TREESRECURSIONDATA STRUCTURESALGORITHMS
class T:
    def __init__(self,value,left=None,right=None):
        self.value=value
        self.left=left
        self.right=right

def is_bst(node, path: list[int] = None):
    if path is None:
        path = []
    if not node:
        return True
    if node.left:
        is_bst(node.left, path)
    path.append(node.value)
    if node.right:
        is_bst(node.right, path)

    return sorted(path) == path or sorted(path, reverse=True) == path

# 40. Combination Sum II
# Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.
#
# Each number in candidates may only be used once in the combination.
#
# Note: The solution set must not contain duplicate combinations.
#
#
#
# Example 1:
#
# Input: candidates = [10,1,2,7,6,1,5], target = 8
# Output:
# [
# [1,1,6],
# [1,2,5],
# [1,7],
# [2,6]
# ]
# Example 2:
#
# Input: candidates = [2,5,2,1,2], target = 5
# Output:
# [
# [1,2,2],
# [5]
# ]
#
#
# Constraints:
#
# 1 <= candidates.length <= 100
# 1 <= candidates[i] <= 50
# 1 <= target <= 30
class Solution:
    global_combs: list[list[int, ...], ...] = None

    def find_comb(
        self, candidates: list[int], target: int, cur_sum: int, cur_comb: list[int, ...], idx: int
    ) -> None:
        prev: int = -1

        for pointer in range(idx, len(candidates)):
            if cur_sum + candidates[pointer] > target: break
            if prev == candidates[pointer]: continue
            cur_comb.append(candidates[pointer])
            self.find_comb(candidates, target, cur_sum + candidates[pointer], cur_comb, pointer + 1)
            cur_comb.pop()
            prev = candidates[pointer]
        if cur_sum == target:
            self.global_combs.append(cur_comb.copy())


    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        self.global_combs = []
        candidates.sort()
        self.find_comb(candidates, target, 0, [], 0)
        return self.global_combs

# Some (but not all)
# Some but not all
# Description
# Your task is to create a function that given a sequence and a predicate, returns True if only some (but not all) the elements in the sequence are True after applying the predicate
#
# Examples
# some_but_not_all('abcdefg&%$', str.isalpha)
# >>> True
#
# some_but_not_all('&%$=', str.isalpha)
# >>> False
#
# some_but_not_all('abcdefg', str.isalpha)
# >>> False
#
# some_but_not_all([4, 1], lambda x: x>3)
# >>> True
#
# some_but_not_all([1, 1], lambda x: x>3)
# >>> False
#
# some_but_not_all([4, 4], lambda x: x>3)
# >>> False
# LISTSSTRINGSFUNDAMENTALS
def some_but_not_all(seq, pred):
    return any(pred(char) for char in seq) and not all(pred(char) for char in seq)

# A. Cheap Travel
# A. Cheap Travel
# time limit per test1 second
# memory limit per test256 megabytes
# Ann has recently started commuting by subway. We know that a one ride subway ticket costs a rubles. Besides, Ann found out that she can buy a special ticket for m rides (she can buy it several times). It costs b rubles. Ann did the math; she will need to use subway n times. Help Ann, tell her what is the minimum sum of money she will have to spend to make n rides?
#
# Input
# The single line contains four space-separated integers n, m, a, b (1 ≤ n, m, a, b ≤ 1000) — the number of rides Ann has planned, the number of rides covered by the m ride ticket, the price of a one ride ticket and the price of an m ride ticket.
#
# Output
# Print a single integer — the minimum sum in rubles that Ann will need to spend.
#
# Examples
# inputCopy
# 6 2 1 2
# outputCopy
# 6
# inputCopy
# 5 2 2 3
# outputCopy
# 8
# Note
# In the first sample one of the optimal solutions is: each time buy a one ride ticket. There are other optimal solutions. For example, buy three m ride tickets.
import sys


def solution(n: int, m: int, a: int, b: int) -> str:
    a_c: float = a
    mb_c: float = b / m
    if a_c <= mb_c:
        return str(n * a_c)
    c: int = n // m * b
    n %= m
    return str(c + min(b, n * a_c))


if __name__ == '__main__':
    n, m, a, b = map(int, sys.stdin.readline().rstrip().split())
    sys.stdout.write(solution(n, m, a, b))

# B. Borze
# # B. Borze
# time limit per test2 seconds
# memory limit per test256 megabytes
# Ternary numeric notation is quite popular in Berland. To telegraph the ternary number the Borze alphabet is used. Digit 0 is transmitted as «.», 1 as «-.» and 2 as «--». You are to decode the Borze code, i.e. to find out the ternary number given its representation in Borze alphabet.
#
# Input
# The first line contains a number in Borze code. The length of the string is between 1 and 200 characters. It's guaranteed that the given string is a valid Borze code of some ternary number (this number can have leading zeroes).
#
# Output
# Output the decoded ternary number. It can have leading zeroes.
#
# Examples
# inputCopy
# .-.--
# outputCopy
# 012
# inputCopy
# --.
# outputCopy
# 20
# inputCopy
# -..-.--
# outputCopy
# 1012
import sys


def solution(n: str) -> str:
    operations: dict[str, tuple[int, int]] = {'.': ('0', 1), '-.': ('1', 2), '--': ('2', 2)}
    decoded: list[str] = []
    idx: int = 0
    while idx < len(n):
        for operation in operations:
            if n[idx: idx + 2] == operation or n[idx: idx + 1] == operation:
                digit, move = operations[operation]
                decoded.append(digit)
                idx += move
    return ''.join(decoded)

if __name__ == '__main__':
    n: str = sys.stdin.readline().rstrip()
    sys.stdout.write(solution(n))

# All Balanced Parentheses
# # Write a function which makes a list of strings representing all of the ways you can balance n pairs of parentheses
#
# Examples
# balanced_parens(0) => [""]
# balanced_parens(1) => ["()"]
# balanced_parens(2) => ["()()","(())"]
# balanced_parens(3) => ["()()()","(())()","()(())","(()())","((()))"]
# ALGORITHMS
def balanced_parens(n):
    output: list[str] = []

    def generate(n: int, left: int, right: int, comb: list[str]):
        if left >= n and right >= n:
            output.append(''.join(comb))
            return
        if left < n:
            comb.append('(')
            generate(n, left + 1, right, comb)
            comb.pop()
        if right < left:
            comb.append(')')
            generate(n, left, right + 1, comb)
            comb.pop()

    generate(n, 0, 0, [])
    return output

# 719. Find K-th Smallest Pair Distance
# The distance of a pair of integers a and b is defined as the absolute difference between a and b.
#
# Given an integer array nums and an integer k, return the kth smallest distance among all the pairs nums[i] and nums[j] where 0 <= i < j < nums.length.
#
#
#
# Example 1:
#
# Input: nums = [1,3,1], k = 1
# Output: 0
# Explanation: Here are all the pairs:
# (1,3) -> 2
# (1,1) -> 0
# (3,1) -> 2
# Then the 1st smallest distance pair is (1,1), and its distance is 0.
# Example 2:
#
# Input: nums = [1,1,1], k = 2
# Output: 0
# Example 3:
#
# Input: nums = [1,6,1], k = 3
# Output: 5
#
#
# Constraints:
#
# n == nums.length
# 2 <= n <= 104
# 0 <= nums[i] <= 106
# 1 <= k <= n * (n - 1) / 2
class Solution:
    def smallestDistancePair(self, nums: List[int], k: int) -> int:
        nums.sort()
        low, high = 0, nums[-1] - nums[0]
        
        while low < high:
            mid: int = low + (high - low) // 2
            # Case if pairs less that k on middle difference
            if self.count_pairs(nums, mid) < k:
                low = mid + 1
            else:
                high = mid
        
        return low

    def count_pairs(self, nums: List[int], distance: int) -> int:
        count = left = 0
        for right in range(1, len(nums)):
            while nums[right] - nums[left] > distance:
                left += 1
            count += right - left
        return count

# 860. Lemonade Change
# At a lemonade stand, each lemonade costs $5. Customers are standing in a queue to buy from you and order one at a time (in the order specified by bills). Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill. You must provide the correct change to each customer so that the net transaction is that the customer pays $5.
#
# Note that you do not have any change in hand at first.
#
# Given an integer array bills where bills[i] is the bill the ith customer pays, return true if you can provide every customer with the correct change, or false otherwise.
#
#
#
# Example 1:
#
# Input: bills = [5,5,5,10,20]
# Output: true
# Explanation:
# From the first 3 customers, we collect three $5 bills in order.
# From the fourth customer, we collect a $10 bill and give back a $5.
# From the fifth customer, we give a $10 bill and a $5 bill.
# Since all customers got correct change, we output true.
# Example 2:
#
# Input: bills = [5,5,10,10,20]
# Output: false
# Explanation:
# From the first two customers in order, we collect two $5 bills.
# For the next two customers in order, we collect a $10 bill and give back a $5 bill.
# For the last customer, we can not give the change of $15 back because we only have two $10 bills.
# Since not every customer received the correct change, the answer is false.
#
#
# Constraints:
#
# 1 <= bills.length <= 105
# bills[i] is either 5, 10, or 20.
class Solution:
    def lemonadeChange(self, bills: List[int]) -> bool:
        fives: int = 0
        tens: int = 0
        for bill in bills:
            if bill == 5: fives += 1
            elif bill == 10:
                if fives:
                    fives -= 1
                else: return False
                tens += 1
            else:
                if tens and fives:
                    tens -= 1
                    fives -= 1
                elif fives > 2: fives -= 3
                else: return False
        return True

# A. Lucky?
# A. Lucky?
# time limit per test1 second
# memory limit per test256 megabytes
# A ticket is a string consisting of six digits. A ticket is considered lucky if the sum of the first three digits is equal to the sum of the last three digits. Given a ticket, output if it is lucky or not. Note that a ticket can have leading zeroes.
#
# Input
# The first line of the input contains an integer t
#  (1≤t≤103
# ) — the number of testcases.
#
# The description of each test consists of one line containing one string consisting of six digits.
#
# Output
# Output t
#  lines, each of which contains the answer to the corresponding test case. Output "YES" if the given ticket is lucky, and "NO" otherwise.
#
# You can output the answer in any case (for example, the strings "yEs", "yes", "Yes" and "YES" will be recognized as a positive answer).
#
# Example
# inputCopy
# 5
# 213132
# 973894
# 045207
# 000000
# 055776
# outputCopy
# YES
# NO
# YES
# YES
# NO
# Note
# In the first test case, the sum of the first three digits is 2+1+3=6
#  and the sum of the last three digits is 1+3+2=6
# , they are equal so the answer is "YES".
#
# In the second test case, the sum of the first three digits is 9+7+3=19
#  and the sum of the last three digits is 8+9+4=21
# , they are not equal so the answer is "NO".
#
# In the third test case, the sum of the first three digits is 0+4+5=9
#  and the sum of the last three digits is 2+0+7=9
# , they are equal so the answer is "YES".
import sys


def solution(t: int) -> None:
    for _ in range(t):
        n: str = sys.stdin.readline().rstrip()
        print(['NO', 'YES'][sum(map(int, n[:3])) == sum(map(int, n[3:]))])


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)

# Excel's COUNTIF, SUMIF and AVERAGEIF functions
# ##The Brief Microsoft Excel provides a number of useful functions for counting, summing, and averaging values if they meet a certain criteria. Your task is to write three functions that work similarly to Excel's COUNTIF, SUMIF and AVERAGEIF functions.
#
# ##Specifications Each function will take the same two arguments:
#
# A list object containing values to be counted, summed, or averaged.
# A criteria in either an integer, float, or string
# Integer or float indicates equality
# Strings can indicate >, >=, <, <= or <> (use the Excel-style "Not equal to" operator) to a number (ex. ">=3"). In the count_if function, a string without an operater indicates equality to this string.
# The tests will all include properly formatted inputs. The test cases all avoid rounding issues associated with floats.
#
# ##Examples
#
# count_if([1,3,5,7,9], 3)
# 1
#
# count_if(["John","Steve","John"], "John")
# 2
#
# sum_if([2,4,6,-1,3,1.5],">0")
# 16.5
#
# average_if([99,95.5,0,83],"<>0")
# 92.5
# ##Excel Function Documentation:
#
# COUNTIF
# SUMIF
# AVERAGEIF
# ALGORITHMS
from typing import Callable

funcs: dict[str, Callable] = {
    '<>': lambda item, key: item != key,
    '<=': lambda item, key: item <= key,
    '>=': lambda item, key: item >= key,
    '<': lambda item, key: item < key,
    '>': lambda item, key: item > key,
}


def is_number_regex(s: str) -> bool:
    return s.lstrip('-').replace('.','',1).replace('e-','',1).replace('e','',1).isdigit()


def parse(expression: str) -> tuple[Callable, str]:
    if isinstance(expression, (float, int)) or '>' not in expression and '<' not in expression:
        key = expression
        if isinstance(key, str):
            key = float(key) if is_number_regex(key) else key
        return lambda item, key: item == key, key

    for module in funcs:
        if expression.startswith(module):
            key = expression[len(module):]
            key = float(key) if is_number_regex(key) else key
            return funcs[module], key


def count_if(values,criteria):
    func, key = parse(criteria)
    return len([item for item in values if func(item, key)])


def sum_if(values,criteria):
    func, key = parse(criteria)
    return sum([item for item in values if func(item, key)])


def average_if(values,criteria):
    func, key = parse(criteria)
    objs: iter = [item for item in values if func(item, key)]
    return sum(objs) / len(objs)

# 624. Maximum Distance in Arrays
# You are given m arrays, where each array is sorted in ascending order.
#
# You can pick up two integers from two different arrays (each array picks one) and calculate the distance. We define the distance between two integers a and b to be their absolute difference |a - b|.
#
# Return the maximum distance.
#
#
#
# Example 1:
#
# Input: arrays = [[1,2,3],[4,5],[1,2,3]]
# Output: 4
# Explanation: One way to reach the maximum distance 4 is to pick 1 in the first or third array and pick 5 in the second array.
# Example 2:
#
# Input: arrays = [[1],[1]]
# Output: 0
#
#
# Constraints:
#
# m == arrays.length
# 2 <= m <= 105
# 1 <= arrays[i].length <= 500
# -104 <= arrays[i][j] <= 104
# arrays[i] is sorted in ascending order.
# There will be at most 105 integers in all the arrays.
# Solution 1 - Two pass greedy based in logic
# General idea:
# We should choose two biggest element and two smallest element for avoiding case
# when biggest and lowest element are in the same array.
# Store value and index of each max and min element and at the and make some checks
# Complexity
# Time complexity: O(N)
# Space complexity: O(1)
# Code
class Solution:
    def maxDistance(self, arrays: List[List[int]]) -> int:
        first_max = idx_first_max = None
        second_max = idx_second_max = None
        for arr_idx in range(len(arrays)):
            if first_max is None or arrays[arr_idx][-1] > first_max:
                second_max, idx_second_max = first_max, idx_first_max
                first_max, idx_first_max = arrays[arr_idx][-1], arr_idx
            elif second_max is None or arrays[arr_idx][-1] > second_max:
                second_max, idx_second_max = arrays[arr_idx][-1], arr_idx

        first_min = idx_first_min = None
        second_min = idx_second_min = None
        for arr_idx in range(len(arrays)):
            if first_min is None or arrays[arr_idx][0] < first_min:
                second_min, idx_second_min = first_min, idx_first_min
                first_min, idx_first_min = arrays[arr_idx][0], arr_idx
            elif second_min is None or arrays[arr_idx][0] < second_min:
                second_min, idx_second_min = arrays[arr_idx][0], arr_idx

        distances: list[int] = []
        if idx_first_max != idx_first_min:
            distances.append(abs(first_max - first_min))
        if idx_first_max != idx_second_min:
            distances.append(abs(first_max - second_min))
        if idx_second_max != idx_first_min:
            distances.append(abs(second_max - first_min))
        if idx_second_max != idx_second_min:
            distances.append(abs(second_max - second_min))
        return max(distances)

# Solution 2 - OnePass greedy
# General idea:
# In the loop from entire arrays choose most long distance.
# For avoiding case when min and max element in same array,
# we start min and max elements in first array and our loop will be starting from second array
# Complexity
# Time complexity: O(N)
# Space complexity: O(1)
# Code
class Solution:
    def maxDistance(self, arrays: List[List[int]]) -> int:
        min_element, max_element = arrays[0][0], arrays[0][-1]
        max_distance: int = float('-inf')
        for arr_idx in range(1, len(arrays)):
            max_distance = max(
                max_distance,
                abs(arrays[arr_idx][-1] - min_element),
                abs(max_element - arrays[arr_idx][0])
            )
            min_element = min(min_element, arrays[arr_idx][0])
            max_element = max(max_element, arrays[arr_idx][-1])
        return max_distance

# B. Interesting drink
# B. Interesting drink
# time limit per test2 seconds
# memory limit per test256 megabytes
# Vasiliy likes to rest after a hard work, so you may often meet him in some bar nearby. As all programmers do, he loves the famous drink "Beecola", which can be bought in n different shops in the city. It's known that the price of one bottle in the shop i is equal to xi coins.
#
# Vasiliy plans to buy his favorite drink for q consecutive days. He knows, that on the i-th day he will be able to spent mi coins. Now, for each of the days he want to know in how many different shops he can buy a bottle of "Beecola".
#
# Input
# The first line of the input contains a single integer n (1 ≤ n ≤ 100 000) — the number of shops in the city that sell Vasiliy's favourite drink.
#
# The second line contains n integers xi (1 ≤ xi ≤ 100 000) — prices of the bottles of the drink in the i-th shop.
#
# The third line contains a single integer q (1 ≤ q ≤ 100 000) — the number of days Vasiliy plans to buy the drink.
#
# Then follow q lines each containing one integer mi (1 ≤ mi ≤ 109) — the number of coins Vasiliy can spent on the i-th day.
#
# Output
# Print q integers. The i-th of them should be equal to the number of shops where Vasiliy will be able to buy a bottle of the drink on the i-th day.
#
# Example
# inputCopy
# 5
# 3 10 8 6 11
# 4
# 1
# 10
# 3
# 11
# outputCopy
# 0
# 4
# 1
# 5
# Note
# On the first day, Vasiliy won't be able to buy a drink in any of the shops.
#
# On the second day, Vasiliy can buy a drink in the shops 1, 2, 3 and 4.
#
# On the third day, Vasiliy can buy a drink only in the shop number 1.
#
# Finally, on the last day Vasiliy can buy a drink in any shop.
from typing import List
import sys


def leftmost_binary_search(arr: List[int], target: int) -> int:
    left: int = 0
    right: int = len(arr) - 1
    while left <= right:
        middle: int = left + (right - left) // 2
        if arr[middle] > target:
            right = middle - 1
        else:
            left = middle + 1
    return right + 1


def solution(n: int, bars: List[int], q: int) -> None:
    bars.sort()
    for day in range(q):
        money: int = int(sys.stdin.readline().rstrip())
        print(leftmost_binary_search(bars, money))

if __name__ == '__main__':
    n: int = int(sys.stdin.readline().rstrip())
    bars: List[int] = list(map(int, sys.stdin.readline().rstrip().split()))
    q: int = int(sys.stdin.readline().rstrip())
    solution(n, bars, q)

# Cuckoo Clock
# The cuckoo bird pops out of the cuckoo clock and chimes once on the quarter hour, half hour, and three-quarter hour. At the beginning of each hour (1-12), it chimes out the hour. Given the current time and a number n, determine the time when the cuckoo bird has chimed n  times.
#
# Input Parameters:
# initial_time - a string in the format "HH:MM", where 1 ≤ HH ≤ 12 and 0 ≤ MM ≤ 59, with leading 0’s if necessary.
# n - an integer representing the target number of chimes, with 1 <= n <= 200.
#
# Return Value: The time when the cuckoo bird has chimed n  times - a string in the same format as initial_time.
#
# If the cuckoo bird chimes at initial_time, include those chimes in the count. If the nth chime is reached on the hour, report the time at the start of that hour (i.e. assume the cuckoo finishes chiming before the minute is up).
#
# Example: "03:38", 19   should return "06:00".
# Explanation: It chimes once at "03:45", 4 times at "04:00", once each at "04:15", "04:30", "04:45", 5 times at "05:00", and once each at "05:15", "05:30", "05:45". At this point it has chimed 16 times, so the 19th chime occurs when it chimes 6 times at "06:00".
#
# Source: International Collegiate Programming Contest, North Central North American Regional, 2023.
#
# Related Kata: Fizz Buzz Cuckoo Clock
#
# STRINGSDATE TIME
def cuckoo_clock(initial_time, n):
    hours, minutes = map(int, initial_time.split(':'))
    whole: bool = False
    if minutes in {0, 15, 30, 45}:
        if minutes == 0:
            n -= hours
        else: n -= 1
    while n > 0:
        if minutes < 15:
            minutes = 15
        elif minutes < 30:
            minutes = 30
        elif minutes < 45:
            minutes = 45
        else:
            whole = True
            minutes = 0
            hours += 1
            if hours > 12:
                hours = 1
        if whole:
            whole = False
            n -= hours
        else:
            n -= 1

    if hours < 10:
        hours = '0' + str(hours)
    if minutes == 0:
        minutes = '00'
    return f'{hours}:{minutes}'

# 98. Validate Binary Search Tree
# # Given the root of a binary tree, determine if it is a valid binary search tree (BST).
#
# A valid BST is defined as follows:
#
# The left
# subtree
#  of a node contains only nodes with keys less than the node's key.
# The right subtree of a node contains only nodes with keys greater than the node's key.
# Both the left and right subtrees must also be binary search trees.
#
#
# Example 1:
#
#
# Input: root = [2,1,3]
# Output: true
# Example 2:
#
#
# Input: root = [5,1,4,null,null,3,6]
# Output: false
# Explanation: The root node's value is 5 but its right child's value is 4.
#
#
# Constraints:
#
# The number of nodes in the tree is in the range [1, 104].
# -231 <= Node.val <= 231 - 1
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    nodes: list[int] = None

    def dfs(self, root: Optional[TreeNode]) -> None:
        if not root: return
        self.dfs(root.left)
        self.nodes.append(root.val)
        self.dfs(root.right)

    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        if self.nodes is None:
            self.nodes = []
        self.dfs(root)

        left: int = 0
        for right in range(1, len(self.nodes)):
            if self.nodes[left] >= self.nodes[right]:
                return False
            left = right
        return True

# A. Division?
# A. Division?
# time limit per test1 second
# memory limit per test256 megabytes
# Codeforces separates its users into 4
#  divisions by their rating:
#
# For Division 1: 1900≤rating
# For Division 2: 1600≤rating≤1899
# For Division 3: 1400≤rating≤1599
# For Division 4: rating≤1399
# Given a rating
# , print in which division the rating
#  belongs.
#
# Input
# The first line of the input contains an integer t
#  (1≤t≤104
# ) — the number of testcases.
#
# The description of each test consists of one line containing one integer rating
#  (−5000≤rating≤5000
# ).
#
# Output
# For each test case, output a single line containing the correct division in the format "Division X", where X
#  is an integer between 1
#  and 4
#  representing the division for the corresponding rating.
#
# Example
# inputCopy
# 7
# -789
# 1299
# 1300
# 1399
# 1400
# 1679
# 2300
# outputCopy
# Division 4
# Division 4
# Division 4
# Division 4
# Division 3
# Division 2
# Division 1
# Note
# For test cases 1−4
# , the corresponding ratings are −789
# , 1299
# , 1300
# , 1399
# , so all of them are in division 4
# .
#
# For the fifth test case, the corresponding rating is 1400
# , so it is in division 3
# .
#
# For the sixth test case, the corresponding rating is 1679
# , so it is in division 2
# .
#
# For the seventh test case, the corresponding rating is 2300
# , so it is in division 1
# .
import sys


def solution(t: int) -> None:
    for _ in range(t):
        n: int = int(sys.stdin.readline().rstrip())
        x: int = 0
        if n >= 1900:
            x = 1
        elif 1600 <= n <= 1899:
            x = 2
        elif 1400 <= n <= 1599:
            x = 3
        else:
            x = 4
        print(f'Division {x}')

if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)

# Amidakuji
# Amidakuji is a method of lottery designed to create random pairings between two sets comprised of an equal number of elements.
#
# Your task is to write a function amidakuji that returns the final positions of each element. Note that the elements are an ascending sequence of consecutive integers starting with 0 (from left to right).
#
# Input
# Your function will receive an array/list of equal-length strings consisting of 0 and 1 characters; this represents the "ladder" structure. The 1s represent the rungs of the ladder and the 0s represent empty space.
#
# Each element begins at the top of its corresponding vertical rail, as illustrated in the diagram below.
# During the descent of the ladder, whenever a vertical rail intersects a horizontal rung, it swaps values with the adjacent connecting vertical rail.
#
# Output
# Your function should return an array of integers, with each integer in its final position.
#
# Test Example
#
# The diagram above is a visual representation of the test example below. The yellow highlighted path shows the path taken by the 2 value. Each time it encounters a crosspiece, it shifts position.
#
# ladder = [
#     '001001',
#     '010000',
#     '100100',
#     '001000',
#     '100101',
#     '010010',
#     '101001',
#     '010100'
# ]
#
# amidakuji(ladder) # [4, 2, 0, 5, 3, 6, 1]
# Other Technical Details
# A function visualizer is preloaded to help illustrate the structure of the ladder; you can call this function with test inputs
# No two rungs will ever be adjacent (so there is no ambiguity about directional path)
# Full Test Suite: 10 fixed tests and 100 randomly-generated tests
# Test input dimension upper bounds:
# maximum width: 20
# maximum height: 50
# Inputs will always be valid
# If you enjoyed this kata, be sure to check out my other katas
#
# ARRAYSFUNDAMENTALS
def amidakuji(ar):
    numbers: list[int] = list(range(len(ar[0]) + 1))
    for move in ar:
        for move_idx in range(len(move)):
            if move[move_idx] == '1':
                numbers[move_idx], numbers[move_idx + 1] = numbers[move_idx + 1], numbers[move_idx]
    return numbers

# 1014. Best Sightseeing Pair
# # You are given an integer array values where values[i] represents the value of the ith sightseeing spot. Two sightseeing spots i and j have a distance j - i between them.
#
# The score of a pair (i < j) of sightseeing spots is values[i] + values[j] + i - j: the sum of the values of the sightseeing spots, minus the distance between them.
#
# Return the maximum score of a pair of sightseeing spots.
#
#
#
# Example 1:
#
# Input: values = [8,1,5,2,6]
# Output: 11
# Explanation: i = 0, j = 2, values[i] + values[j] + i - j = 8 + 5 + 0 - 2 = 11
# Example 2:
#
# Input: values = [1,2]
# Output: 2
#
#
# Constraints:
#
# 2 <= values.length <= 5 * 104
# 1 <= values[i] <= 1000
# Solution
# Dynamic Programming with extra space
# Complexity
# Time complexity: O(N)
# Space complexity: O(N)
# Code
class Solution:
    def maxScoreSightseeingPair(self, values: List[int]) -> int:
        dp: list[int] = [0] * len(values)
        max_prev_day: int = values[0]
        for day in range(1, len(values)):
            max_prev_day -= 1
            dp[day] = max(dp[day - 1], values[day] + max_prev_day)
            max_prev_day = max(max_prev_day, values[day])
        return dp[-1]

# Dynamic Programming without extra space
# Complexity
# Time complexity: O(N)
# Space complexity: O(1)
# Code
class Solution:
    def maxScoreSightseeingPair(self, values: List[int]) -> int:
        profit: int = 0
        max_prev_day: int = values[0]
        for day in range(1, len(values)):
            max_prev_day -= 1
            profit = max(profit, values[day] + max_prev_day)
            max_prev_day = max(max_prev_day, values[day])
        return profit

# 931. Minimum Falling Path Sum
# Given an n x n array of integers matrix, return the minimum sum of any falling path through matrix.
#
# A falling path starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position (row, col) will be (row + 1, col - 1), (row + 1, col), or (row + 1, col + 1).
#
#
#
# Example 1:
#
#
# Input: matrix = [[2,1,3],[6,5,4],[7,8,9]]
# Output: 13
# Explanation: There are two falling paths with a minimum sum as shown.
# Example 2:
#
#
# Input: matrix = [[-19,57],[-40,-5]]
# Output: -59
# Explanation: The falling path with a minimum sum is shown.
#
#
# Constraints:
#
# n == matrix.length == matrix[i].length
# 1 <= n <= 100
# -100 <= matrix[i][j] <= 100
class Solution:
    def minFallingPathSum(self, matrix: List[List[int]]) -> int:
        for row in range(1, len(matrix)):
            for col in range(len(matrix[0])):
                matrix[row][col] += min(
                    matrix[max(0, row - 1)][max(0, col - 1)],
                    matrix[max(0, row - 1)][col],
                    matrix[max(0, row - 1)][min(len(matrix[row]) - 1, col + 1)]
                )
        return min(matrix[-1])

# 1937. Maximum Number of Points with Cost
# # You are given an m x n integer matrix points (0-indexed). Starting with 0 points, you want to maximize the number of points you can get from the matrix.
#
# To gain points, you must pick one cell in each row. Picking the cell at coordinates (r, c) will add points[r][c] to your score.
#
# However, you will lose points if you pick a cell too far from the cell that you picked in the previous row. For every two adjacent rows r and r + 1 (where 0 <= r < m - 1), picking cells at coordinates (r, c1) and (r + 1, c2) will subtract abs(c1 - c2) from your score.
#
# Return the maximum number of points you can achieve.
#
# abs(x) is defined as:
#
# x for x >= 0.
# -x for x < 0.
#
#
# Example 1:
#
#
# Input: points = [[1,2,3],[1,5,1],[3,1,1]]
# Output: 9
# Explanation:
# The blue cells denote the optimal cells to pick, which have coordinates (0, 2), (1, 1), and (2, 0).
# You add 3 + 5 + 3 = 11 to your score.
# However, you must subtract abs(2 - 1) + abs(1 - 0) = 2 from your score.
# Your final score is 11 - 2 = 9.
# Example 2:
#
#
# Input: points = [[1,5],[2,3],[4,2]]
# Output: 11
# Explanation:
# The blue cells denote the optimal cells to pick, which have coordinates (0, 1), (1, 1), and (2, 0).
# You add 5 + 3 + 4 = 12 to your score.
# However, you must subtract abs(1 - 1) + abs(1 - 0) = 1 from your score.
# Your final score is 12 - 1 = 11.
#
#
# Constraints:
#
# m == points.length
# n == points[r].length
# 1 <= m, n <= 105
# 1 <= m * n <= 105
# 0 <= points[r][c] <= 105
# Solution Dynamic Programming O(NM) O(M)
# Suggested problems:
# 121. Best Time to Buy and Sell Stock
# 1014. Best Sightseeing Pair
# 931. Minimum Falling Path Sum
# Complexity
# Time complexity: O(NM)
# Space complexity: O(M)
# Code
class Solution:
    def maxPoints(self, points: List[List[int]]) -> int:
        r, c = len(points), len(points[0])
        for row in range(1, r):
            # Best points from rightmost to left
            right: list[int] = [0] * c
            right[-1] = points[row - 1][-1]
            for col in range(c - 2, -1, -1):
                right[col] = max(right[col + 1] - 1, points[row - 1][col])
            # Best poitns from leftmost to right
            left: int = points[row - 1][0]
            # First element either with first left or first right points
            points[row][0] += max(left, right[0])

            for col in range(1, c):
                # Prev max point will be decrease by one every iteration
                # Choose max from either descreased prev max or point above
                left = max(left - 1, points[row - 1][col])
                # Add maximum point to current ceil
                points[row][col] += max(left, right[col])

        return max(points[-1])

# 264. Ugly Number II
# # An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.
#
# Given an integer n, return the nth ugly number.
#
#
#
# Example 1:
#
# Input: n = 10
# Output: 12
# Explanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers.
# Example 2:
#
# Input: n = 1
# Output: 1
# Explanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.
#
#
# Constraints:
#
# 1 <= n <= 1690
# Dynamic Programming
# Complexity
# Time complexity: O(N)
# Space complexity: O(N)
# Code
class Solution:
    def nthUglyNumber(self, n: int) -> int:
        dp: list[int] = []
        dp.append(1)
        acc2 = acc3 = acc5 = 0
        next_of_2: int = 2 * 1
        next_of_3: int = 3 * 1
        next_of_5: int = 5 * 1
        next_ugly: int = 1
        for i in range(n - 1):
            next_ugly = min(next_of_2, next_of_3, next_of_5)
            dp.append(next_ugly)
            if next_ugly == next_of_2:
                acc2 += 1
                next_of_2 = dp[acc2] * 2
            if next_ugly == next_of_3:
                acc3 += 1
                next_of_3 = dp[acc3] * 3
            if next_ugly == next_of_5:
                acc5 += 1
                next_of_5 = dp[acc5] * 5
        return next_ugly

# Min Heap (Priority Queue)
# Complexity
# Time complexity: O(NlogN)
# Space complexity: O(N)
# Code
import heapq
class Solution:
    def nthUglyNumber(self, n: int) -> int:
        seen: set[int] = set()
        ugly: int = 1
        ugly_heap: list[int] = [ugly]
        seen.add(ugly)
        modules: list[int] = [2, 3, 5]
        for _ in range(n):
            current_ugly = heapq.heappop(ugly_heap)
            for module in modules:
                new_ugly: int = current_ugly * module
                if new_ugly not in seen:
                    heapq.heappush(ugly_heap, new_ugly)
                    seen.add(new_ugly)
        return current_ugly

# 3254. Find the Power of K-Size Subarrays I
# You are given an array of integers nums of length n and a positive integer k.
#
# The power of an array is defined as:
#
# Its maximum element if all of its elements are consecutive and sorted in ascending order.
# -1 otherwise.
# You need to find the power of all
# subarrays
#  of nums of size k.
#
# Return an integer array results of size n - k + 1, where results[i] is the power of nums[i..(i + k - 1)].
#
#
#
# Example 1:
#
# Input: nums = [1,2,3,4,3,2,5], k = 3
#
# Output: [3,4,-1,-1,-1]
#
# Explanation:
#
# There are 5 subarrays of nums of size 3:
#
# [1, 2, 3] with the maximum element 3.
# [2, 3, 4] with the maximum element 4.
# [3, 4, 3] whose elements are not consecutive.
# [4, 3, 2] whose elements are not sorted.
# [3, 2, 5] whose elements are not consecutive.
# Example 2:
#
# Input: nums = [2,2,2,2,2], k = 4
#
# Output: [-1,-1]
#
# Example 3:
#
# Input: nums = [3,2,3,2,3,2], k = 2
#
# Output: [-1,3,-1,3,-1]
#
#
#
# Constraints:
#
# 1 <= n == nums.length <= 500
# 1 <= nums[i] <= 105
# 1 <= k <= n
class Solution:
    def resultsArray(self, nums: List[int], k: int) -> List[int]:
        if k == 1: return nums
        result: list[int] = []
        left: int = 0
        right: int = 1
        while left <= len(nums) - k and right < len(nums):
            if nums[right] - 1 == nums[right - 1]:
                if right - left + 1 == k:
                    result.append(nums[right])
                    left += 1
            else:
                while left < right and left <= len(nums) - k:
                    result.append(-1)
                    left += 1
            right += 1
        return result

# 3255. Find the Power of K-Size Subarrays II
# # You are given an array of integers nums of length n and a positive integer k.
#
# The power of an array is defined as:
#
# Its maximum element if all of its elements are consecutive and sorted in ascending order.
# -1 otherwise.
# You need to find the power of all
# subarrays
#  of nums of size k.
#
# Return an integer array results of size n - k + 1, where results[i] is the power of nums[i..(i + k - 1)].
#
#
#
# Example 1:
#
# Input: nums = [1,2,3,4,3,2,5], k = 3
#
# Output: [3,4,-1,-1,-1]
#
# Explanation:
#
# There are 5 subarrays of nums of size 3:
#
# [1, 2, 3] with the maximum element 3.
# [2, 3, 4] with the maximum element 4.
# [3, 4, 3] whose elements are not consecutive.
# [4, 3, 2] whose elements are not sorted.
# [3, 2, 5] whose elements are not consecutive.
# Example 2:
#
# Input: nums = [2,2,2,2,2], k = 4
#
# Output: [-1,-1]
#
# Example 3:
#
# Input: nums = [3,2,3,2,3,2], k = 2
#
# Output: [-1,3,-1,3,-1]
#
#
#
# Constraints:
#
# 1 <= n == nums.length <= 105
# 1 <= nums[i] <= 106
# 1 <= k <= n
class Solution:
    def resultsArray(self, nums: List[int], k: int) -> List[int]:
        if k == 1: return nums
        result: list[int] = []
        left: int = 0
        right: int = 1
        while left <= len(nums) - k and right < len(nums):
            if nums[right] - 1 == nums[right - 1]:
                if right - left + 1 == k:
                    result.append(nums[right])
                    left += 1
            else:
                while left < right and left <= len(nums) - k:
                    result.append(-1)
                    left += 1
            right += 1
        return result

# 3258. Count Substrings That Satisfy K-Constraint I
# # You are given a binary string s and an integer k.
#
# A binary string satisfies the k-constraint if either of the following conditions holds:
#
# The number of 0's in the string is at most k.
# The number of 1's in the string is at most k.
# Return an integer denoting the number of
# substrings
#  of s that satisfy the k-constraint.
#
#
#
# Example 1:
#
# Input: s = "10101", k = 1
#
# Output: 12
#
# Explanation:
#
# Every substring of s except the substrings "1010", "10101", and "0101" satisfies the k-constraint.
#
# Example 2:
#
# Input: s = "1010101", k = 2
#
# Output: 25
#
# Explanation:
#
# Every substring of s except the substrings with a length greater than 5 satisfies the k-constraint.
#
# Example 3:
#
# Input: s = "11111", k = 1
#
# Output: 15
#
# Explanation:
#
# All substrings of s satisfy the k-constraint.
#
#
#
# Constraints:
#
# 1 <= s.length <= 50
# 1 <= k <= s.length
# s[i] is either '0' or '1'.
class Solution:
    def countKConstraintSubstrings(self, s: str, k: int) -> int:
        total: int = 0
        ones = zeros = 0
        left: int = 0
        for right in range(len(s)):
            if s[right] == '1':
                ones += 1
            else: zeros += 1
            while ones > k and zeros > k:
                if s[left] == '1':
                    ones -= 1
                else: zeros -= 1
                left += 1
            total += right - left + 1
        return total

# 3259. Maximum Energy Boost From Two Drinks
# # You are given two integer arrays energyDrinkA and energyDrinkB of the same length n by a futuristic sports scientist. These arrays represent the energy boosts per hour provided by two different energy drinks, A and B, respectively.
#
# You want to maximize your total energy boost by drinking one energy drink per hour. However, if you want to switch from consuming one energy drink to the other, you need to wait for one hour to cleanse your system (meaning you won't get any energy boost in that hour).
#
# Return the maximum total energy boost you can gain in the next n hours.
#
# Note that you can start consuming either of the two energy drinks.
#
#
#
# Example 1:
#
# Input: energyDrinkA = [1,3,1], energyDrinkB = [3,1,1]
#
# Output: 5
#
# Explanation:
#
# To gain an energy boost of 5, drink only the energy drink A (or only B).
#
# Example 2:
#
# Input: energyDrinkA = [4,1,1], energyDrinkB = [1,1,3]
#
# Output: 7
#
# Explanation:
#
# To gain an energy boost of 7:
#
# Drink the energy drink A for the first hour.
# Switch to the energy drink B and we lose the energy boost of the second hour.
# Gain the energy boost of the drink B in the third hour.
#
#
# Constraints:
#
# n == energyDrinkA.length == energyDrinkB.length
# 3 <= n <= 105
# 1 <= energyDrinkA[i], energyDrinkB[i] <= 105
class Solution:
    def maxEnergyBoost(self, energyDrinkA: List[int], energyDrinkB: List[int]) -> int:
        n: int = len(energyDrinkA)

        dpA: list[int] = [0] * n
        dpB: list[int] = [0] * n

        dpA[0] = energyDrinkA[0]
        dpB[0] = energyDrinkB[0]

        dpA[1] = max(energyDrinkA[0], energyDrinkA[0] + energyDrinkA[1])
        dpB[1] = max(energyDrinkB[0], energyDrinkB[0] + energyDrinkB[1])

        for i in range(2, n):
            dpA[i] = max(dpA[i-1] + energyDrinkA[i], dpB[i-2] + energyDrinkA[i])
            dpB[i] = max(dpB[i-1] + energyDrinkB[i], dpA[i-2] + energyDrinkB[i])

        return max(dpA[n-1], dpB[n-1])

# A. Plus or Minus
# A. Plus or Minus
# time limit per test1 second
# memory limit per test256 megabytes
# You are given three integers a
# , b
# , and c
#  such that exactly one of these two equations is true:
#
# a+b=c
# a−b=c
# Output + if the first equation is true, and - otherwise.
# Input
# The first line contains a single integer t
#  (1≤t≤162
# ) — the number of test cases.
#
# The description of each test case consists of three integers a
# , b
# , c
#  (1≤a,b≤9
# , −8≤c≤18
# ). The additional constraint on the input: it will be generated so that exactly one of the two equations will be true.
#
# Output
# For each test case, output either + or - on a new line, representing the correct equation.
#
# Example
# inputCopy
# 11
# 1 2 3
# 3 2 1
# 2 9 -7
# 3 4 7
# 1 1 2
# 1 1 0
# 3 3 6
# 9 9 18
# 9 9 0
# 1 9 -8
# 1 9 10
# outputCopy
# +
# -
# -
# +
# +
# -
# +
# +
# -
# -
# +
# Note
# In the first test case, 1+2=3
# .
#
# In the second test case, 3−2=1
# .
#
# In the third test case, 2−9=−7
# . Note that c
#  can be negative.
import sys


def solution(t: int) -> None:
    for _ in range(t):
        a, b, c = map(int, sys.stdin.readline().rstrip().split())
        print(['-', '+'][a + b == c])


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)

# Factorial division
# You have to define a function to calculate the division of two factorial numbers. This can be useful for large numbers.
#
# In mathematics, the factorial of integer n is written as n!. It is equal to the product of n and every integer preceding it. For example: 5! = 5 * 4 * 3 * 2 * 1 = 120.
#
# Some hints: We can see that (n + 1)! = (n + 1) * n!. So (n + 1)! / n! = (n + 1)
#
# We know that 0! = 1 (because n! = (n + 1)! / (n + 1) therefore 0! = 1! / 1 = 1)
#
# And your solution should be able to calculate n! / d!.
#
# *** Please, don't worry about the parameters. You will only receive positive integers, and the first one will be greater than the second one
#
# MATHEMATICSALGORITHMS
def factorial_division(n, d):
    result = 1
    for i in range(d+1, n+1):
        result *= i
    return result

# 650. 2 Keys Keyboard
# There is only one character 'A' on the screen of a notepad. You can perform one of two operations on this notepad for each step:
#
# Copy All: You can copy all the characters present on the screen (a partial copy is not allowed).
# Paste: You can paste the characters which are copied last time.
# Given an integer n, return the minimum number of operations to get the character 'A' exactly n times on the screen.
#
#
#
# Example 1:
#
# Input: n = 3
# Output: 3
# Explanation: Initially, we have one character 'A'.
# In step 1, we use Copy All operation.
# In step 2, we use Paste operation to get 'AA'.
# In step 3, we use Paste operation to get 'AAA'.
# Example 2:
#
# Input: n = 1
# Output: 0
#
#
# Constraints:
#
# 1 <= n <= 1000
class Solution:
    def get_primes(self, n: int) -> list[int]:
        m: int = n + 1
        numbers: list[bool] = [True] * m
        for i in range(2, int(n**0.5 + 1)):
            if numbers[i]:
                for j in range(i*i, m, i):
                    numbers[j] = False

        primes: list[int] = []
        for i in range(2, m):
            if numbers[i]:
                primes.append(i)
        return primes

    def minSteps(self, n: int) -> int:
        if n == 1: return 0
        primes: list[int] = self.get_primes(n)
        if n in primes: return n
        total: int = 0
        while n:
            for prime in primes:
                if n % prime == 0:
                    n //= prime
                    total += prime
                if n == 1: return total
        return total

# A. Holiday Of Equality
# A. Holiday Of Equality
# time limit per test1 second
# memory limit per test256 megabytes
# In Berland it is the holiday of equality. In honor of the holiday the king decided to equalize the welfare of all citizens in Berland by the expense of the state treasury.
#
# Totally in Berland there are n citizens, the welfare of each of them is estimated as the integer in ai burles (burle is the currency in Berland).
#
# You are the royal treasurer, which needs to count the minimum charges of the kingdom on the king's present. The king can only give money, he hasn't a power to take away them.
#
# Input
# The first line contains the integer n (1 ≤ n ≤ 100) — the number of citizens in the kingdom.
#
# The second line contains n integers a1, a2, ..., an, where ai (0 ≤ ai ≤ 106) — the welfare of the i-th citizen.
#
# Output
# In the only line print the integer S — the minimum number of burles which are had to spend.
#
# Examples
# inputCopy
# 5
# 0 1 2 3 4
# outputCopy
# 10
# inputCopy
# 5
# 1 1 0 1 1
# outputCopy
# 1
# inputCopy
# 3
# 1 3 1
# outputCopy
# 4
# inputCopy
# 1
# 12
# outputCopy
# 0
# Note
# In the first example if we add to the first citizen 4 burles, to the second 3, to the third 2 and to the fourth 1, then the welfare of all citizens will equal 4.
#
# In the second example it is enough to give one burle to the third citizen.
#
# In the third example it is necessary to give two burles to the first and the third citizens to make the welfare of citizens equal 3.
#
# In the fourth example it is possible to give nothing to everyone because all citizens have 12 burles.
import sys
from typing import List


def solution(n: int, people: List[int]) -> str:
    richest: int = max(people)
    return str(sum(abs(man - richest) for man in people))


if __name__ == '__main__':
    n: int = int(sys.stdin.readline().rstrip())
    people: List[int] = list(map(int, sys.stdin.readline().rstrip().split()))
    sys.stdout.write(solution(n, people))

# Treasure Hunt with Clues
# # Inputs:
#
# A n × n grid with 1 ≤ n ≤ 9, and 2 integers row,col with 1 ≤ row,col ≤ n, indicating the starting position of the treasure hunt.
#
# Clues:
#
# Every cell of the grid contains a number between 11 and n2. These values provide the coordinates of the next cell to search. The treasure is found in a cell whose value matches its location. (The clue says "stay where you are"!) There will always be treasure reachable from the starting position.
#
# Output:
#
# The value in the treasure cell reached by following the clues from the starting position.
#
# Example:
#
# Consider the grid below, with starting position row=3,col=4.
# 34 21 32 44 25
# 21 41 43 14 31
# 31 45 52 42 23
# 33 15 51 44 35
# 21 52 33 13 44
#
# Indexes start from 1, so the value in cell 3,4 is 42. Thus the next clue is found in cell 4,2. The value there is 15. Seeking in cell 1,5 uncovers the clue 25, and cell 2,5 contains 31. Since the value in cell 3,1 is 31, that is the location of the treasure.
#
# Source: This kata extends a problem found on GitHub.
#
# Other Treasure-Hunt Kata:
#
# Bob's Treasure Map
#
# Treasure Map
#
# Pirate treasure chest codes
#
# Treasure hunt
#
# ARRAYS
def find_treasure(grid, row, col):
    while row * 10 + col != grid[row - 1][col - 1]:
        row, col = grid[row - 1][col - 1] // 10, grid[row - 1][col - 1] % 10
    return grid[row - 1][col - 1]

# A. Design Tutorial: Learn from Math
# A. Design Tutorial: Learn from Math
# time limit per test1 second
# memory limit per test256 megabytes
# One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
#
# For example, there is a statement called the "Goldbach's conjecture". It says: "each even number no less than four can be expressed as the sum of two primes". Let's modify it. How about a statement like that: "each integer no less than 12 can be expressed as the sum of two composite numbers." Not like the Goldbach's conjecture, I can prove this theorem.
#
# You are given an integer n no less than 12, express it as a sum of two composite numbers.
#
# Input
# The only line contains an integer n (12 ≤ n ≤ 106).
#
# Output
# Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
#
# Examples
# inputCopy
# 12
# outputCopy
# 4 8
# inputCopy
# 15
# outputCopy
# 6 9
# inputCopy
# 23
# outputCopy
# 8 15
# inputCopy
# 1000000
# outputCopy
# 500000 500000
# Note
# In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output "6 6" or "8 4" as well.
#
# In the second example, 15 = 6 + 9. Note that you can't output "1 14" because 1 is not a composite number.
import sys

def is_prime(x: int) -> bool:
    if x & 1 == 0: return False
    divider: int = 3
    while divider * divider <= n:
        if x % divider == 0:
            return False
        divider += 2
    return True

def solution(n: int) -> str:
    x, y = n // 2, n // 2 + int(n & 1 == 1)
    while (is_prime(x) or is_prime(y)) or x + y != n:
        while is_prime(x):
            x -= 1
            y += 1
        while is_prime(y):
            y += 1
            x -= 1
    return f'{x} {y}'


if __name__ == '__main__':
    n: int = int(sys.stdin.readline().rstrip())
    sys.stdout.write(solution(n))

# Simple Fun #190: Folding Paper
# Task
# John was in math class and got bored, so he decided to fold some origami from a rectangular a × b sheet of paper (a > b). His first step is to make a square piece of paper from the initial rectangular piece of paper by folding the sheet along the bisector of the right angle and cutting off the excess part.
#
# Folding
# After moving the square piece of paper aside, John wanted to make even more squares! He took the remaining (a-b) × b strip of paper and went on with the process until he was left with a square piece of paper.
#
# Your task is to determine how many square pieces of paper John can make.
#
# Example:
# For: a = 2, b = 1, the output should be 2.
#
# Given a = 2 and b = 1, John can fold a 1 × 1 then another 1 × 1.
#
# So the answer is 2.
#
# For: a = 10, b = 7, the output should be 6.
#
# We are given a = 10 and b = 7. The following is the order of squares John folds: 7 × 7, 3 × 3, 3 × 3, 1 × 1, 1 × 1, and 1 × 1.
#
# Here are pictures for the example cases.
#
# Resulting squares
# Input/Output
# [input] integer a
# 2 ≤ a ≤ 1000
#
# [input] integer b
# 1 ≤ b < a ≤ 1000
#
# [output] an integer
# The maximum number of squares.
#
# PUZZLES
def folding(a, b):
    if b == 0: return 0
    if b == 1: return a
    print('here is', a, b)
    return 1 + folding(max(b, a - b), min(b, a - b))

# 1140. Stone Game II
# Alice and Bob continue their games with piles of stones.  There are a number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].  The objective of the game is to end with the most stones.
#
# Alice and Bob take turns, with Alice starting first.  Initially, M = 1.
#
# On each player's turn, that player can take all the stones in the first X remaining piles, where 1 <= X <= 2M.  Then, we set M = max(M, X).
#
# The game continues until all the stones have been taken.
#
# Assuming Alice and Bob play optimally, return the maximum number of stones Alice can get.
#
#
#
# Example 1:
#
# Input: piles = [2,7,9,4,4]
# Output: 10
# Explanation:  If Alice takes one pile at the beginning, Bob takes two piles, then Alice takes 2 piles again. Alice can get 2 + 4 + 4 = 10 piles in total. If Alice takes two piles at the beginning, then Bob can take all three piles left. In this case, Alice get 2 + 7 = 9 piles in total. So we return 10 since it's larger.
# Example 2:
#
# Input: piles = [1,2,3,4,5,100]
# Output: 104
#
#
# Constraints:
#
# 1 <= piles.length <= 100
# 1 <= piles[i] <= 104
class Solution:
    def stoneGameII(self, piles: List[int]) -> int:
        n: int = len(piles)

        suffix_sum: list[int] = [0] * n
        suffix_sum[-1] = piles[-1]
        for idx in range(n - 2, -1, -1):
            suffix_sum[idx] = piles[idx] + suffix_sum[idx + 1]

        dp: list[list[int]] = [[0] * (n + 1) for _ in range(n)]

        for idx in range(n - 1, -1, -1):
            for possible_m in range(1, n + 1):
                # Case when we can get all remaining stones
                if idx + (2 * possible_m) >= n:
                    dp[idx][possible_m] = suffix_sum[idx]
                    continue
                for x in range(1, (2 * possible_m) + 1):
                    dp[idx][possible_m] = max(
                        dp[idx][possible_m],
                        suffix_sum[idx] - dp[idx + x][max(possible_m, x)]
                    )

        return dp[0][1]

# 664. Strange Printer
# There is a strange printer with the following two special properties:
#
# The printer can only print a sequence of the same character each time.
# At each turn, the printer can print new characters starting from and ending at any place and will cover the original existing characters.
# Given a string s, return the minimum number of turns the printer needed to print it.
#
#
#
# Example 1:
#
# Input: s = "aaabbb"
# Output: 2
# Explanation: Print "aaa" first and then print "bbb".
# Example 2:
#
# Input: s = "aba"
# Output: 2
# Explanation: Print "aaa" first and then print "b" from the second place of the string, which will cover the existing character 'a'.
#
#
# Constraints:
#
# 1 <= s.length <= 100
# s consists of lowercase English letters.
class Solution:
    def shorten_string(self, s: str) -> str:
        stack: list[str] = []
        for right in range(len(s)):
            if stack and stack[-1] == s[right]:
                continue
            else:
                stack.append(s[right])
        return ''.join(stack)

    def strangePrinter(self, s: str) -> int:
        s: str = self.shorten_string(s)
        n: int = len(s)
        # Max n constraint is 100, so initialize 100 + 1
        dp: list[list[int]] = [[0] * 101 for _ in range(101)]
        # Go from right to left
        for i in range(n - 1, -1, -1):
            # Initial state for current ceil
            dp[i][i] = 1
            # Go from current left to right
            for j in range(i + 1, n):
                if s[i] == s[j]:
                    dp[i][j] = dp[i][j - 1]
                    continue
                x: int = dp[i][j - 1] + 1
                # Choose minimum possible x
                for k in range(i + 1, j - 1):
                    if s[k] == s[j]:
                        x = min(x, dp[i][k - 1] + dp[k][j - 1])
                dp[i][j] = x
        return dp[0][n-1]

# COFFEE
# Description: John is really excited about coffee. He wrote some text messages earlier, but he's worried that they didn't convey his enthusiasm for coffee, so he's decided to resend them with coffee in all-caps:
#
# COFFEE
#
# Task: Write a function "coffee" that accepts a string as a parameter and returns that string with every instance of coffee in all caps.
#
# Input: string. The word "coffee" may occur more than once. It may have some capital letters or already be in all-caps. There may be punctuation in the string too. It will not be part of another word like "Coffeeburger", which isn't a word anyway.
#
# Output: string with all instances of coffee in all-caps:
#
# Examples:
#
# Input: "Did I only have two cups of coffee this morning? I need more." Output: "Did I only have two cups of COFFEE this morning? I need more."
#
# Input: "Coffee! Buy me a COFFEE!" Output: "COFFEE! Buy me a COFFEE!"
#
# Good luck!
#
# STRINGSREGULAR EXPRESSIONSFUNDAMENTALS
import re
def coffee(sentence):
    result: list[str] = re.findall('(?i)coffee', sentence, re.IGNORECASE)
    for res in result:
        sentence = sentence.replace(res, 'COFFEE')
    return sentence

# A. Odd Divisor
# A. Odd Divisor
# time limit per test2 seconds
# memory limit per test256 megabytes
# You are given an integer n
# . Check if n
#  has an odd divisor, greater than one (does there exist such a number x
#  (x>1
# ) that n
#  is divisible by x
#  and x
#  is odd).
#
# For example, if n=6
# , then there is x=3
# . If n=4
# , then such a number does not exist.
#
# Input
# The first line contains one integer t
#  (1≤t≤104
# ) — the number of test cases. Then t
#  test cases follow.
#
# Each test case contains one integer n
#  (2≤n≤1014
# ).
#
# Please note, that the input for some test cases won't fit into 32
# -bit integer type, so you should use at least 64
# -bit integer type in your programming language.
#
# Output
# For each test case, output on a separate line:
#
# "YES" if n
#  has an odd divisor, greater than one;
# "NO" otherwise.
# You can output "YES" and "NO" in any case (for example, the strings yEs, yes, Yes and YES will be recognized as positive).
#
# Example
# inputCopy
# 6
# 2
# 3
# 4
# 5
# 998244353
# 1099511627776
# outputCopy
# NO
# YES
# NO
# YES
# YES
# NO
import sys


def solution(t: int) -> None:
    for _ in range(t):
        n: int = int(sys.stdin.readline().rstrip())
        print(['NO', 'YES'][bin(n).count('1') > 1])



if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)

# 476. Number Complement
# The complement of an integer is the integer you get when you
# flip all the 0's to 1's and all the 1's to 0's in its binary representation.
# For example, The integer 5 is "101" in binary and its complement is "010" which is the integer 2.
# Given an integer num, return its complement.
#
# Example 1:
#
# Input: num = 5
# Output: 2
# Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.
# Example 2:
#
# Input: num = 1
# Output: 0
# Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.
#
# Constraints:
# 1 <= num < 231
# Note: This question is the same as 1009: https://leetcode.com/problems/complement-of-base-10-integer/
# Solution
# Solution Bit Manipulation O(N) O(N)
class Solution:
    def findComplement(self, num: int) -> int:
        return int(''.join(['1', '0'][char == '1'] for char in bin(num)[2:]), 2)

# 1009. Complement of Base 10 Integer
# The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.
#
# For example, The integer 5 is "101" in binary and its complement is "010" which is the integer 2.
# Given an integer n, return its complement.
#
#
#
# Example 1:
#
# Input: n = 5
# Output: 2
# Explanation: 5 is "101" in binary, with complement "010" in binary, which is 2 in base-10.
# Example 2:
#
# Input: n = 7
# Output: 0
# Explanation: 7 is "111" in binary, with complement "000" in binary, which is 0 in base-10.
# Example 3:
#
# Input: n = 10
# Output: 5
# Explanation: 10 is "1010" in binary, with complement "0101" in binary, which is 5 in base-10.
#
#
# Constraints:
#
# 0 <= n < 109
#
#
# Note: This question is the same as 476: https://leetcode.com/problems/number-complement/
class Solution:
    def bitwiseComplement(self, n: int) -> int:
        return int(''.join(['1', '0'][char == '1'] for char in bin(n)[2:]), 2)

# A. Codeforces Checking
# A. Codeforces Checking
# time limit per test1 second
# memory limit per test256 megabytes
# Given a lowercase Latin character (letter), check if it appears in the string codeforces
# .
#
# Input
# The first line of the input contains an integer t
#  (1≤t≤26
# ) — the number of test cases.
#
# The only line of each test case contains a character c
#  — a single lowercase Latin character (letter).
#
# Output
# For each test case, output "YES" (without quotes) if c
#  satisfies the condition, and "NO" (without quotes) otherwise.
#
# You can output the answer in any case (for example, the strings "yEs", "yes", "Yes" and "YES" will be recognized as a positive answer).
#
# Example
# inputCopy
# 10
# a
# b
# c
# d
# e
# f
# g
# h
# i
# j
# outputCopy
# NO
# NO
# YES
# YES
# YES
# YES
# NO
# NO
# NO
# NO
import sys



def solution(t: int) -> None:
    valid: set = set('codeforces')
    for _ in range(t):
        char: str = sys.stdin.readline().rstrip()
        print(['NO', 'YES'][char in valid])


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)

# Drinking Game
# Mike and Joe are fratboys that love beer and games that involve drinking. They play the following game: Mike chugs one beer, then Joe chugs 2 beers, then Mike chugs 3 beers, then Joe chugs 4 beers, and so on. Once someone can't drink what he is supposed to drink, he loses.
#
# Mike can chug at most A beers in total (otherwise he would pass out), while Joe can chug at most B beers in total. Who will win the game?
#
# Write the function game(A,B) that returns the winner, "Mike" or "Joe" accordingly, for any given integer values of A and B.
#
# Note: If either Mike or Joe cannot drink at least 1 beer, return the string "Non-drinkers can't play".
#
# STRINGSFUNDAMENTALS
def game(a, b):
    if a < 1 or b < 1:
        return "Non-drinkers can't play"
    level: int = 1
    players: list[int] = [a, b]
    first: bool = False
    while True:
        if players[first] - level < 0:
            return ['Mike', 'Joe'][not first]
        players[first] -= level
        level += 1
        first = not first

# A. Dislike of Threes
# A. Dislike of Threes
# time limit per test1 second
# memory limit per test256 megabytes
# Polycarp doesn't like integers that are divisible by 3
#  or end with the digit 3
#  in their decimal representation. Integers that meet both conditions are disliked by Polycarp, too.
#
# Polycarp starts to write out the positive (greater than 0
# ) integers which he likes: 1,2,4,5,7,8,10,11,14,16,…
# . Output the k
# -th element of this sequence (the elements are numbered from 1
# ).
#
# Input
# The first line contains one integer t
#  (1≤t≤100
# ) — the number of test cases. Then t
#  test cases follow.
#
# Each test case consists of one line containing one integer k
#  (1≤k≤1000
# ).
#
# Output
# For each test case, output in a separate line one integer x
#  — the k
# -th element of the sequence that was written out by Polycarp.
#
# Example
# inputCopy
# 10
# 1
# 2
# 3
# 4
# 5
# 6
# 7
# 8
# 9
# 1000
# outputCopy
# 1
# 2
# 4
# 5
# 7
# 8
# 10
# 11
# 14
# 1666
import sys
from typing import List


def solution(t: int) -> None:
    order: List[int] = [1]
    for _ in range(t):
        x: int = int(sys.stdin.readline().rstrip())
        while x > len(order):
            for num in range(order[-1] + 1, order[-1] + x + 1):
                if num % 3 != 0 and num % 10 != 3:
                    order.append(num)
        print(order[x - 1])


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)

# 592. Fraction Addition and Subtraction
# Given a string expression representing an expression of fraction addition and subtraction, return the calculation result in string format.
#
# The final result should be an irreducible fraction. If your final result is an integer, change it to the format of a fraction that has a denominator 1. So in this case, 2 should be converted to 2/1.
#
#
#
# Example 1:
#
# Input: expression = "-1/2+1/2"
# Output: "0/1"
# Example 2:
#
# Input: expression = "-1/2+1/2+1/3"
# Output: "1/3"
# Example 3:
#
# Input: expression = "1/3-1/2"
# Output: "-1/6"
#
#
# Constraints:
#
# The input string only contains '0' to '9', '/', '+' and '-'. So does the output.
# Each fraction (input and output) has the format ±numerator/denominator. If the first input fraction or the output is positive, then '+' will be omitted.
# The input only contains valid irreducible fractions, where the numerator and denominator of each fraction will always be in the range [1, 10]. If the denominator is 1, it means this fraction is actually an integer in a fraction format defined above.
# The number of given fractions will be in the range [1, 10].
# The numerator and denominator of the final result are guaranteed to be valid and in the range of 32-bit int.
class Solution:
    def parse_expression(self, expression: str) -> list[list[int, int]]:
        """
        Parse expression into fractions and return them.
        Time Complexity O(N)
        Memory Complexity O(N)
        """
        if expression[0] != '-':
            expression = '+' + expression

        fractions: list[list[int, int]] = []
        modules: dict[str, int] = {'+': 1, '-': -1}
        current_module: int = None
        numerator = denominator = 0
        numerator_flag: bool = False
        for char in expression:
            if char in '+-':
                if current_module is not None:
                    fractions.append([current_module * numerator, denominator])
                    numerator = denominator = 0
                current_module = modules[char]
                numerator_flag = not numerator_flag
            elif char == '/':
                numerator_flag = False
            else:
                if numerator_flag:
                    numerator = numerator * 10 + int(char)
                else:
                    denominator = denominator * 10 + int(char)

        fractions.append([current_module * numerator, denominator])
        return fractions

    def get_gcd(self, x: int, y: int) -> int:
        """
        Euclidean algorithm.
        Time Complexity O(log(min(x, y)))
        Memory Complexity O(1)
        """
        while x != 0:
            x, y = y % x, x
        return y

    def get_lcd(self, x: int, y: int) -> int:
        """
        Find Least Common Denominator of two integers.
        Time Complexity O(log(min(x, y)))
        Memory Complexity O(1)
        """
        return x * y // self.get_gcd(x, y)

    def simplify_fraction(self, numerator: int, denominator: int) -> list[int, int]:
        """
        Simplify fraction to irreducible fraction.
        Time Complexity O(log(min(x, y)))
        Memory Complexiy O(1)
        """
        negative: bool = numerator < 0 or denominator < 0
        numerator, denominator = abs(numerator), abs(denominator)
        gcd: int = self.get_gcd(numerator, denominator)
        return [(-1 if negative else 1) * (numerator // gcd), denominator // gcd]

    def operation_fractions(self, x: list[int, int], y: list[int, int]) -> list[int, int]:
        """
        Make addition or subtraction between two fractions and simplify the output.
        Time Complexity O(log(min(x, y)))
        Memory Complexity O(1)
        """
        if x[1] == y[1]:
            return [x[0] + y[0], x[1]]
        lcd: int = self.get_lcd(x[1], y[1])
        numerator: int = x[0] * (lcd // x[1]) + y[0] * (lcd // y[1])
        denominator: int = lcd
        numerator_denominator: list[int, int] = self.simplify_fraction(numerator, denominator)
        return numerator_denominator


    def fractionAddition(self, expression: str) -> str:
        """
        Solve expression of addition and subtraction fractions
        and return irreducible fraction.
        Time Complexity O(NlogD) where D is denominator of the fractions
        Memory Complexity O(N)
        """
        fractions: list[list[int, int]] = self.parse_expression(expression)

        current_fraction: list[int, int] = fractions[0]
        for idx in range(1, len(fractions)):
            next_fraction: list[int, int] = fractions[idx]
            current_fraction = self.operation_fractions(current_fraction, next_fraction)
        current_fraction = self.simplify_fraction(*current_fraction)

        return f'{current_fraction[0]}/{current_fraction[1]}'

# Multiples of 3 or 5
// Multiples of 3 or 5
// If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
// Finish the solution so that it returns the sum of all the multiples of 3 or 5 below the number passed in.
// Additionally, if the number is negative, return 0.
// Note: If the number is a multiple of both 3 and 5, only count it once.
// Courtesy of projecteuler.net (Problem 1)
// MATHEMATICSALGORITHMS
int solution(int number)
{
  int output = 0;
  for (int num = 1; num < number; num++) {
    if (num % 3 == 0 && num % 5 == 0) {
      output += num;
    } else if (num % 5 == 0) {
      output += num;
    } else if (num % 3 == 0) {
      output += num;
    }
  }
  return output;
}

# 564. Find the Closest Palindrome
# Given a string n representing an integer, return the closest integer (not including itself), which is a palindrome. If there is a tie, return the smaller one.
#
# The closest is defined as the absolute difference minimized between two integers.
#
#
#
# Example 1:
#
# Input: n = "123"
# Output: "121"
# Example 2:
#
# Input: n = "1"
# Output: "0"
# Explanation: 0 and 2 are the closest palindromes but we return the smallest which is 0.
#
#
# Constraints:
#
# 1 <= n.length <= 18
# n consists of only digits.
# n does not have leading zeros.
# n is representing an integer in the range [1, 1018 - 1].
class Solution:

    def choose_optimal(self, n: int, palindrome: list[str], even: bool, current_palindrome: int = 0) -> str:
        left: int = len(n) // 2
        if even: left -= 1
        if not even:
            # Case middle - 1
            current_middle: int = int(palindrome[left])
            if current_middle == 0:
                swap_neighbors = True
                current_middle = 9
            else: current_middle = current_middle - 1
            palindrome[left] = str(current_middle)
            palindrome_with_negative_middle: int = int(''.join(palindrome))
            # Case middle + 1
            if current_middle == 9:
                current_middle = 1
            else: current_middle = (current_middle + 2) % 10
            palindrome[left] = str(current_middle)
            palindrome_with_bigger_middle: int = int(''.join(palindrome))
            palindrome_less_on_one: int = int(
                ''.join(
                    '9' if idx == left else
                    str(9 if palindrome[idx] == '0' else int(palindrome[idx]) - 1)
                    for idx in range(len(palindrome))
                )
            )
            if palindrome_less_on_one == int(n):
                palindrome_less_on_one = 0
            return str(
                min(
                    current_palindrome,
                    palindrome_with_negative_middle, palindrome_with_bigger_middle,
                    int('9' * (len(n) - 1)),
                    int('1' + '0' * (len(n) - 1) + '1'),
                    palindrome_less_on_one,
                    key=lambda x: (abs(int(n) - x), x)
                )
            )
        # Case middle - 1
        current_middle: int = int(palindrome[left])
        if current_middle == 0:
            current_middle = 9
        else: current_middle = current_middle - 1
        palindrome[left] = str(current_middle)
        palindrome[left + 1] = str(current_middle)
        palindrome_with_negative_middle: int = int(''.join(palindrome))
        # Case middle + 1
        if current_middle == 9:
            current_middle = 1
        else: current_middle = (current_middle + 2) % 10
        palindrome[left] = str(current_middle)
        palindrome[left + 1] = str(current_middle)
        palindrome_with_bigger_middle: int = int(''.join(palindrome))
        palindrome_less_on_one: int = int(
            ''.join(
                '9' if idx in (left, left + 1) else
                str(9 if palindrome[idx] == '0' else int(palindrome[idx]) - 1)
                for idx in range(len(palindrome))
                )
            )
        if palindrome_less_on_one == int(n):
            palindrome_less_on_one = 0
        return str(
            min(
                current_palindrome,
                palindrome_with_negative_middle, palindrome_with_bigger_middle,
                int('9' * (len(n) - 1)),
                int('1' + '0' * (len(n) - 1) + '1'),
                palindrome_less_on_one,
                key=lambda x: (abs(int(n) - x), x)
            )
        )


    def make_palindrome(self, n: str) -> str:
        even: bool = len(n) & 1 == 0
        palindrome: list[str] = list(n)
        already_palindrome: bool = True
        middle_move: int = None
        left: int = 0
        right: int = len(n) - 1
        while left < right:
            if n[left] != n[right]:
                already_palindrome = False
                palindrome[right] = n[left]
            left += 1
            right -= 1
        current_palindrome: int = int(''.join(palindrome))

        if already_palindrome:
            return self.choose_optimal(n, palindrome, even)
        return self.choose_optimal(n, palindrome, even, current_palindrome)

    def nearestPalindromic(self, n: str) -> str:
        size: int = len(n)
        if size == 1:
            return str(int(n) - 1)

        return self.make_palindrome(n)

# A. Choosing Teams
# A. Choosing Teams
# time limit per test1 second
# memory limit per test256 megabytes
# The Saratov State University Olympiad Programmers Training Center (SSU OPTC) has n students. For each student you know the number of times he/she has participated in the ACM ICPC world programming championship. According to the ACM ICPC rules, each person can participate in the world championship at most 5 times.
#
# The head of the SSU OPTC is recently gathering teams to participate in the world championship. Each team must consist of exactly three people, at that, any person cannot be a member of two or more teams. What maximum number of teams can the head make if he wants each team to participate in the world championship with the same members at least k times?
#
# Input
# The first line contains two integers, n and k (1 ≤ n ≤ 2000; 1 ≤ k ≤ 5). The next line contains n integers: y1, y2, ..., yn (0 ≤ yi ≤ 5), where yi shows the number of times the i-th person participated in the ACM ICPC world championship.
#
# Output
# Print a single number — the answer to the problem.
#
# Examples
# inputCopy
# 5 2
# 0 4 5 1 0
# outputCopy
# 1
# inputCopy
# 6 4
# 0 1 2 3 4 5
# outputCopy
# 0
# inputCopy
# 6 5
# 0 0 0 0 0 0
# outputCopy
# 2
# Note
# In the first sample only one team could be made: the first, the fourth and the fifth participants.
#
# In the second sample no teams could be created.
#
# In the third sample two teams could be created. Any partition into two teams fits.
import sys
from typing import List


def solution(n: int, k: int, members: List[int]) -> str:
    valid_members: int = 0
    for member in members:
        if member + k <= 5:
            valid_members += 1
    return str(valid_members // 3)


if __name__ == '__main__':
    n, k = map(int, sys.stdin.readline().rstrip().split())
    members: List[int] = list(map(int, sys.stdin.readline().rstrip().split()))
    sys.stdout.write(solution(n, k, members))

# 3264. Final Array State After K Multiplication Operations I
# You are given an integer array nums, an integer k, and an integer multiplier.
#
# You need to perform k operations on nums. In each operation:
#
# Find the minimum value x in nums. If there are multiple occurrences of the minimum value, select the one that appears first.
# Replace the selected minimum value x with x * multiplier.
# Return an integer array denoting the final state of nums after performing all k operations.
#
#
#
# Example 1:
#
# Input: nums = [2,1,3,5,6], k = 5, multiplier = 2
#
# Output: [8,4,6,5,6]
#
# Explanation:
#
# Operation	Result
# After operation 1	[2, 2, 3, 5, 6]
# After operation 2	[4, 2, 3, 5, 6]
# After operation 3	[4, 4, 3, 5, 6]
# After operation 4	[4, 4, 6, 5, 6]
# After operation 5	[8, 4, 6, 5, 6]
# Example 2:
#
# Input: nums = [1,2], k = 3, multiplier = 4
#
# Output: [16,8]
#
# Explanation:
#
# Operation	Result
# After operation 1	[4, 2]
# After operation 2	[4, 8]
# After operation 3	[16, 8]
#
#
# Constraints:
#
# 1 <= nums.length <= 100
# 1 <= nums[i] <= 100
# 1 <= k <= 10
# 1 <= multiplier <= 5
import heapq
class Solution:
    def getFinalState(self, nums: List[int], k: int, multiplier: int) -> List[int]:
        heap: list[int] = []
        for idx in range(len(nums)):
            heapq.heappush(heap, (nums[idx], idx))
        for _ in range(k):
            curr_num, idx = heapq.heappop(heap)
            heapq.heappush(heap, (curr_num * multiplier, idx))
        while heap:
            curr_num, idx = heapq.heappop(heap)
            nums[idx] = curr_num
        return nums

# 3265. Count Almost Equal Pairs I
# You are given an array nums consisting of positive integers.
#
# We call two integers x and y in this problem almost equal if both integers can become equal after performing the following operation at most once:
#
# Choose either x or y and swap any two digits within the chosen number.
# Return the number of indices i and j in nums where i < j such that nums[i] and nums[j] are almost equal.
#
# Note that it is allowed for an integer to have leading zeros after performing an operation.
#
#
#
# Example 1:
#
# Input: nums = [3,12,30,17,21]
#
# Output: 2
#
# Explanation:
#
# The almost equal pairs of elements are:
#
# 3 and 30. By swapping 3 and 0 in 30, you get 3.
# 12 and 21. By swapping 1 and 2 in 12, you get 21.
# Example 2:
#
# Input: nums = [1,1,1,1,1]
#
# Output: 10
#
# Explanation:
#
# Every two elements in the array are almost equal.
#
# Example 3:
#
# Input: nums = [123,231]
#
# Output: 0
#
# Explanation:
#
# We cannot swap any two digits of 123 or 231 to reach the other.
#
#
#
# Constraints:
#
# 2 <= nums.length <= 100
# 1 <= nums[i] <= 106
# Solution Simulation String
# Fully Simulation
# Complexity
# Time complexity O(N**4)
# Space complexity:O(N)
# Code
class Solution:
    def is_almost_equal(self, x: int, y: int) -> int:
        str_x = str(x)
        str_y = str(y)
        if len(str_x) < len(str_y):
            str_x, str_y = str_y, str_x
        # Case when needed zeros to make pairs equal
        if len(str_x) - len(str_y) != 0:
            if '0' not in str_x: return 0
            list_x = list(str_x)
            zero_idxs: list[int] = [idx for idx in range(len(list_x)) if list_x[idx] == '0']
            for zero_idx in zero_idxs:
                list_x[zero_idx], list_x[0] = list_x[0], list_x[zero_idx]
                idx_x: int = 0
                while list_x[idx_x] == '0':
                    idx_x += 1
                if str_y == ''.join(list_x[idx_x:]):
                    return 1
                list_x[zero_idx], list_x[0] = list_x[0], list_x[zero_idx]
            return 0

        diff_indices = [i for i in range(len(str_x)) if str_x[i] != str_y[i]]
        # Case when integers already equal
        if not diff_indices: return 1
        # Case when need only one swap between integers
        elif len(diff_indices) == 2:
            i, j = diff_indices
            if (str_x[i] == str_y[j] and str_x[j] == str_y[i]):
                return 1
        return 0

    def countPairs(self, nums: List[int]) -> int:
        count: int = 0
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                count += self.is_almost_equal(nums[i], nums[j])
        return count

# Greedy Choice
# Complexity
# Time complexity O(N**3logN)
# Space complexity:O(N)
# Code
class Solution:
	def countPairs(self, nums: List[int]) -> int:
		almost_equals: int = 0
		for i in range(len(nums)):
			for j in range(i + 1 , len(nums)):
				str_i: str = str(nums[i])
				str_j: str = str(nums[j])
				if len(str_i) < len(str_j):
					str_i = '0' * (len(str_j) - len(str_i)) + str_i
				elif len(str_i) > len(str_j):
					str_j = '0' * (len(str_i) - len(str_j)) + str_j
				needed: int = 0
				for index in range(len(str_j)):
					if str_i[index] != str_j[index]:
						needed += 1
				if needed <= 2 and sorted(str_i) == sorted(str_j):
					almost_equals += 1
		return almost_equals

# A. Team Olympiad
# A. Team Olympiad
# time limit per test1 second
# memory limit per test256 megabytes
# The School №0 of the capital of Berland has n children studying in it. All the children in this school are gifted: some of them are good at programming, some are good at maths, others are good at PE (Physical Education). Hence, for each child we know value ti:
#
# ti = 1, if the i-th child is good at programming,
# ti = 2, if the i-th child is good at maths,
# ti = 3, if the i-th child is good at PE
# Each child happens to be good at exactly one of these three subjects.
#
# The Team Scientific Decathlon Olympias requires teams of three students. The school teachers decided that the teams will be composed of three children that are good at different subjects. That is, each team must have one mathematician, one programmer and one sportsman. Of course, each child can be a member of no more than one team.
#
# What is the maximum number of teams that the school will be able to present at the Olympiad? How should the teams be formed for that?
#
# Input
# The first line contains integer n (1 ≤ n ≤ 5000) — the number of children in the school. The second line contains n integers t1, t2, ..., tn (1 ≤ ti ≤ 3), where ti describes the skill of the i-th child.
#
# Output
# In the first line output integer w — the largest possible number of teams.
#
# Then print w lines, containing three numbers in each line. Each triple represents the indexes of the children forming the team. You can print both the teams, and the numbers in the triplets in any order. The children are numbered from 1 to n in the order of their appearance in the input. Each child must participate in no more than one team. If there are several solutions, print any of them.
#
# If no teams can be compiled, print the only line with value w equal to 0.
#
# Examples
# inputCopy
# 7
# 1 3 1 3 2 1 2
# outputCopy
# 2
# 3 5 2
# 6 7 4
# inputCopy
# 4
# 2 1 1 2
# outputCopy
# 0
import sys
from typing import List
from collections import defaultdict


def solution(n: int, skills: List[int]) -> None:
    storage: dict[str, List[int]] = defaultdict(list)
    moves: List[str] = ['p', 'm', 's']
    for skill_idx in range(n):
        storage[moves[skills[skill_idx] - 1]].append(skill_idx + 1)
    w: int = min(len(value) for value in storage.values()) if len(storage) == 3 else 0
    print(w)
    for team in range(w):
        print(f"{storage['p'][team]} {storage['m'][team]} {storage['s'][team]}")


if __name__ == '__main__':
    n: int = int(sys.stdin.readline().rstrip())
    skills: List[int] = list(map(int, sys.stdin.readline().rstrip().split()))
    solution(n, skills)

# How Much?
# I always thought that my old friend John was rather richer than he looked, but I never knew exactly how much money he actually had. One day (as I was plying him with questions) he said:
#
# "Imagine I have between m and n Zloty..." (or did he say Quetzal? I can't remember!)
# "If I were to buy 9 cars costing c each, I'd only have 1 Zloty (or was it Meticals?) left."
# "And if I were to buy 7 boats at b each, I'd only have 2 Ringglets (or was it Zloty?) left."
# Could you tell me in each possible case:
#
# how much money f he could possibly have ?
# the cost c of a car?
# the cost b of a boat?
# So, I will have a better idea about his fortune. Note that if m-n is big enough, you might have a lot of possible answers.
#
# Each answer should be given as ["M: f", "B: b", "C: c"] and all the answers as [ ["M: f", "B: b", "C: c"], ... ]. "M" stands for money, "B" for boats, "C" for cars.
#
# Note: m, n, f, b, c are positive integers, where 0 <= m <= n or m >= n >= 0. m and n are inclusive.
#
# Examples:
# howmuch(1, 100)      => [["M: 37", "B: 5", "C: 4"], ["M: 100", "B: 14", "C: 11"]]
# howmuch(1000, 1100)  => [["M: 1045", "B: 149", "C: 116"]]
# howmuch(10000, 9950) => [["M: 9991", "B: 1427", "C: 1110"]]
# howmuch(0, 200)      => [["M: 37", "B: 5", "C: 4"], ["M: 100", "B: 14", "C: 11"], ["M: 163", "B: 23", "C: 18"]]
# Explanation of the results for howmuch(1, 100):
#
# In the first answer his possible fortune is 37:
# so he can buy 7 boats each worth 5: 37 - 7 * 5 = 2
# or he can buy 9 cars worth 4 each: 37 - 9 * 4 = 1
# The second possible answer is 100:
# he can buy 7 boats each worth 14: 100 - 7 * 14 = 2
# or he can buy 9 cars worth 11: 100 - 9 * 11 = 1
# Note
# See "Sample Tests" to know the format of the return.
#
# FUNDAMENTALS
def howmuch(m, n):
    answer: list[lsit[str]] = []
    for money in range(min(m, n), max(m, n) + 1):
        b: int = money // 7
        while money > 7 * b + 2:
            b += 1
        if money != 7 * b + 2: continue
        c: int = money // 9
        while money > 9 * c + 1:
            c += 1
        if money != 9 * c  + 1: continue
        answer.append([f'M: {money}', f'B: {b}', f'C: {c}'])
    return answer

# 918. Maximum Sum Circular Subarray
# Given a circular integer array nums of length n, return the maximum possible sum of a non-empty subarray of nums.
#
# A circular array means the end of the array connects to the beginning of the array. Formally, the next element of nums[i] is nums[(i + 1) % n] and the previous element of nums[i] is nums[(i - 1 + n) % n].
#
# A subarray may only include each element of the fixed buffer nums at most once. Formally, for a subarray nums[i], nums[i + 1], ..., nums[j], there does not exist i <= k1, k2 <= j with k1 % n == k2 % n.
#
#
#
# Example 1:
#
# Input: nums = [1,-2,3,-2]
# Output: 3
# Explanation: Subarray [3] has maximum sum 3.
# Example 2:
#
# Input: nums = [5,-3,5]
# Output: 10
# Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10.
# Example 3:
#
# Input: nums = [-3,-2,-3]
# Output: -2
# Explanation: Subarray [-2] has maximum sum -2.
#
#
# Constraints:
#
# n == nums.length
# 1 <= n <= 3 * 104
# -3 * 104 <= nums[i] <= 3 * 104
class Solution:
    def maxSubarraySumCircular(self, nums: List[int]) -> int:
        total: int = 0
        cur_max_sum = cur_min_sum = 0
        max_sum = min_sum = nums[0]
        for num in nums:
            cur_max_sum = max(cur_max_sum + num, num)
            max_sum = max(max_sum, cur_max_sum)

            cur_min_sum = min(cur_min_sum + num, num)
            min_sum = min(min_sum, cur_min_sum)
            total += num
        return max(max_sum, total - min_sum) if max_sum > 0 else max_sum

# 53. Maximum Subarray
# Given an integer array nums, find the
# subarray
#  with the largest sum, and return its sum.
#
#
#
# Example 1:
#
# Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
# Output: 6
# Explanation: The subarray [4,-1,2,1] has the largest sum 6.
# Example 2:
#
# Input: nums = [1]
# Output: 1
# Explanation: The subarray [1] has the largest sum 1.
# Example 3:
#
# Input: nums = [5,4,-1,7,8]
# Output: 23
# Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.
#
#
# Constraints:
#
# 1 <= nums.length <= 105
# -104 <= nums[i] <= 104
#
#
# Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        max_sum: int = nums[0]
        cur_sum: int = nums[0]
        for right in range(1, len(nums)):
            cur_sum = max(cur_sum + nums[right], nums[right])
            max_sum = max(max_sum, cur_sum)
        return max_sum

# 978. Longest Turbulent Subarray
# Given an integer array arr, return the length of a maximum size turbulent subarray of arr.
#
# A subarray is turbulent if the comparison sign flips between each adjacent pair of elements in the subarray.
#
# More formally, a subarray [arr[i], arr[i + 1], ..., arr[j]] of arr is said to be turbulent if and only if:
#
# For i <= k < j:
# arr[k] > arr[k + 1] when k is odd, and
# arr[k] < arr[k + 1] when k is even.
# Or, for i <= k < j:
# arr[k] > arr[k + 1] when k is even, and
# arr[k] < arr[k + 1] when k is odd.
#
#
# Example 1:
#
# Input: arr = [9,4,2,10,7,8,8,1,9]
# Output: 5
# Explanation: arr[1] > arr[2] < arr[3] > arr[4] < arr[5]
# Example 2:
#
# Input: arr = [4,8,12,16]
# Output: 2
# Example 3:
#
# Input: arr = [100]
# Output: 1
#
#
# Constraints:
#
# 1 <= arr.length <= 4 * 104
# 0 <= arr[i] <= 109
# Solution Two Pointers
# General idea
# We only have to cases:
# Case 1:
# <><><><><>
# Case 2
# ><><><><><
# Complexity
# Time complexity: O(N)
# Space complexity: O(1)
# Code
class Solution:
    def maxTurbulenceSize(self, arr: List[int]) -> int:
        max_length: int = 1
        left: int = 0
        # Case 1
        for right in range(1, len(arr)):
            if (right - 1) & 1:
                if arr[right - 1] <= arr[right]:
                    left = right
            else:
                if arr[right - 1] >= arr[right]:
                    left = right

            max_length = max(max_length, right - left + 1)
        # Case 2
        left: int = 0
        for right in range(1, len(arr)):
            if (right - 1) & 1 == 0:
                if arr[right - 1] <= arr[right]:
                    left = right
            else:
                if arr[right - 1] >= arr[right]:
                    left = right

            max_length = max(max_length, right - left + 1)

        return max_length

# 590. N-ary Tree Postorder Traversal
# Given the root of an n-ary tree, return the postorder traversal of its nodes' values.
#
# Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)
#
#
#
# Example 1:
#
#
# Input: root = [1,null,3,2,4,null,5,6]
# Output: [5,6,3,2,4,1]
# Example 2:
#
#
# Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
# Output: [2,6,14,11,7,3,12,8,4,13,9,10,5,1]
#
#
# Constraints:
#
# The number of nodes in the tree is in the range [0, 104].
# 0 <= Node.val <= 104
# The height of the n-ary tree is less than or equal to 1000.
#
#
# Follow up: Recursive solution is trivial, could you do it iteratively?
# Recursive DFS Postorder
# Complexity
# Time complexity: O(N)
# Space complexity: O(N)
# Code
# Definition for a Node.
"""
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
"""

class Solution:

    def recursive_postorder(self, root: 'Node', order: list[int]) -> None:
        if not root: return
        for child in (root.children if root else []):
            if child:
                self.recursive_postorder(child, order)
        if root:
            order.append(root.val)
        return order

    def postorder(self, root: 'Node') -> List[int]:
        order: list[int] = []
        self.recursive_postorder(root, order)
        return order

# Iterative DFS Postorder
# Complexity
# Time complexity: O(N + M)
# Space complexity: O(N)
# Code
# Definition for a Node.
"""
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
"""

class Solution:
    def postorder(self, root: 'Node') -> List[int]:
        order: list[int] = []
        queue: list[tuple['Node', bool]] = [(root, False)]
        while root and queue:
            cur_node, seen = queue.pop()
            if seen:
                order.append(cur_node.val)
                continue
            queue.append((cur_node, True))
            for child in reversed(cur_node.children):
                if child:
                    queue.append((child, False))
        return order

# A. Medium Number
# A. Medium Number
# time limit per test1 second
# memory limit per test256 megabytes
# Given three distinct integers a
# , b
# , and c
# , find the medium number between all of them.
#
# The medium number is the number that is neither the minimum nor the maximum of the given three numbers.
#
# For example, the median of 5,2,6
#  is 5
# , since the minimum is 2
#  and the maximum is 6
# .
#
# Input
# The first line contains a single integer t
#  (1≤t≤6840
# ) — the number of test cases.
#
# The description of each test case consists of three distinct integers a
# , b
# , c
#  (1≤a,b,c≤20
# ).
#
# Output
# For each test case, output a single integer — the medium number of the three numbers.
#
# Example
# inputCopy
# 9
# 5 2 6
# 14 3 4
# 20 2 1
# 1 2 3
# 11 19 12
# 10 8 20
# 6 20 3
# 4 1 3
# 19 8 4
# outputCopy
# 5
# 4
# 2
# 2
# 12
# 10
# 6
# 3
# 8
import sys


def solution(t: int) -> None:
    for _ in range(t):
        abc: list = list(map(int, sys.stdin.readline().rstrip().split()))
        print(sorted(abc)[1])



if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)

# Highest Value Pyramid
# Pyramid building in Egypt
# You are a Pharaoh in ancient Egypt, and you want to build the perfect pyramid for yourself. There's only a limited number of stones, however, and different kinds of stones vary in their value. You want to maximize the value of your pyramid while keeping it exactly three layers high.
#
# In essence, you're given an array of integers, which represent the stones, and your task is to assemble the highest-value pyramid from them. The pyramid is made out of exactly three layers, containing:
#
# Top layer: 1 integer
# Middle layer: 2 identical integers
# Bottom layer: 3 identical integers
# Additionally, no integer can appear in two or more layers. That is, each layer is made from stones of the same value, and stones of the same value can be used at most in one layer.
#
# Graphically, the structure of the pyramid looks like this, where
# 𝑥
# ≠
# 𝑦
# ≠
# 𝑧
# x
# 
# =y
# 
# =z
#
#     [z]
#   [y] [y]
#  [x][x][x]
# Input
# The input is an array that may contain positive and negative integers, as well as zeros. The integers are in no specific order and can be repeated. The array may also be empty.
#
# Output
# The output is a single integer – the sum of all integers that make up the pyramid. For example, given input [1,1,1,2,2,2,3,3,3], the highest-value pyramid is:
#
#     [1]
#   [2] [2]
#  [3][3][3]
# And the sum is thus:
# 3
# ⋅
# 3
# +
# 2
# ⋅
# 2
# +
# 1
# =
# 14
# 3⋅3+2⋅2+1=14.
#
# If it's not possible to build a pyramid from the given array (e.g. [-1,-1,0,0,1,1] or an empty one []), return None, null, or other language-specific alternative.
#
# Clarification
# Remember that there's no rule for descending or ascending order, so there's no restriction on placing the highest integer from the array on top of the pyramid.
#
# FUNDAMENTALS
def pyramid(stones):
    storage: dict[int, int] = dict()
    for stone in stones:
        storage[stone] = storage.get(stone, 0) + 1
    available: list[int] = list(storage.keys())
    available.sort(key=lambda x: (x, storage[x]))
    third_idx: int = 0
    third: int = None
    for stone_idx in range(len(available)):
        if storage[available[stone_idx]] >= 3:
            if third is None or available[stone_idx] > third:
                third_idx, third = stone_idx, available[stone_idx]
    if third is None: return
    available.pop(third_idx)
    second_idx: int = 0
    second: int = None
    for stone_idx in range(len(available)):
        if storage[available[stone_idx]] >= 2:
            if second is None or second < available[stone_idx]:
                second_idx, second = stone_idx, available[stone_idx]
    if second is None: return
    available.pop(second_idx)
    if not available: return
    return 3 * third + 2 * second + max(available)

# 1514. Path with Maximum Probability
# You are given an undirected weighted graph of n nodes (0-indexed), represented by an edge list where edges[i] = [a, b] is an undirected edge connecting the nodes a and b with a probability of success of traversing that edge succProb[i].
#
# Given two nodes start and end, find the path with the maximum probability of success to go from start to end and return its success probability.
#
# If there is no path from start to end, return 0. Your answer will be accepted if it differs from the correct answer by at most 1e-5.
#
#
#
# Example 1:
#
#
#
# Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2
# Output: 0.25000
# Explanation: There are two paths from start to end, one having a probability of success = 0.2 and the other has 0.5 * 0.5 = 0.25.
# Example 2:
#
#
#
# Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2
# Output: 0.30000
# Example 3:
#
#
#
# Input: n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2
# Output: 0.00000
# Explanation: There is no path between 0 and 2.
#
#
# Constraints:
#
# 2 <= n <= 10^4
# 0 <= start, end < n
# start != end
# 0 <= a, b < n
# a != b
# 0 <= succProb.length == edges.length <= 2*10^4
# 0 <= succProb[i] <= 1
# There is at most one edge between every two nodes.
from collections import defaultdict
import heapq
class Solution:
    def dijkstra(self, start: int, end: int, adj_list: dict[int, list[tuple[int ,int]]], paths: list[int]) -> None:
        seen: set[int] = set()
        heap: list[int] = [(-0, start)]
        while heap:
            cost, cur_edge = heapq.heappop(heap)
            # Transform from negative to positive
            cost = -cost

            if cur_edge in seen:
                continue
            if paths[cur_edge] < cost:
                paths[cur_edge] = cost
            # If we just multiply first edge with start
            # with initial value 0, we always get 0, so transform to 1
            if cost == 0:
                cost = 1
            seen.add(cur_edge)
            for neighbor in adj_list.get(cur_edge, []):
                neighbor_edge, neighbor_weight = neighbor
                neighbor_weight: int = cost * neighbor_weight
                heapq.heappush(heap, (-neighbor_weight, neighbor_edge))


    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start_node: int, end_node: int) -> float:
        adj_list: dict[int, list[tuple[int, int]]] = defaultdict(list)
        for edge_idx in range(len(edges)):
            start, end = edges[edge_idx]
            weight: int = succProb[edge_idx]
            adj_list[start].append((end, weight))
            adj_list[end].append((start, weight))
        # We can use a little bit of optimization here, but it no nesscesarry
        # if adj_list.get(end_node, None) is None:
        #     return 0
        paths: list[int] = [0] * n
        self.dijkstra(start_node, end_node, adj_list, paths)

        return paths[end_node]

# Help the farmer to count rabbits, chickens and cows
# Farmer Bob have a big farm, where he growths chickens, rabbits and cows. It is very difficult to count the number of animals for each type manually, so he diceded to buy a system to do it. But he bought a cheap system that can count only total number of heads, total number of legs and total number of horns of animals on the farm. Help Bob to figure out how many chickens, rabbits and cows does he have?
#
# All chickens have 2 legs, 1 head and no horns; all rabbits have 4 legs, 1 head and no horns; all cows have 4 legs, 1 head and 2 horns.
#
# Your task is to write a function
#
# , which returns a dictionary
#
# {"rabbits" : rabbits_count, "chickens" : chickens_count, "cows" : cows_count}
# Parameters legs_number, heads_number, horns_number are integer, all tests have valid input.
#
# Example:
#
# get_animals_count(34, 11, 6); # Should return {"rabbits" : 3, "chickens" : 5, "cows" : 3}
# get_animals_count(154, 42, 10); # Should return {"rabbits" : 30, "chickens" : 7, "cows" : 5}
# FUNDAMENTALSALGORITHMSMATHEMATICS
def get_animals_count(legs_number, heads_number, horns_number):
    cows: int = min(legs_number // 4, heads_number, horns_number // 2)
    legs_number -= cows * 4
    heads_number -= cows
    left: int = 0
    right: int = heads_number
    while left <= right:
        middle: int = left + (right - left) // 2
        rabbits: int = middle
        chickens: int = heads_number - rabbits
        if rabbits * 4 + chickens * 2 > legs_number:
            right = middle - 1
        elif rabbits * 4 + chickens * 2 < legs_number:
            left = middle + 1
        else:
            return {
                "rabbits": rabbits,
                "chickens": chickens,
                "cows": cows
            }

# A. Boredom
# A. Boredom
# time limit per test1 second
# memory limit per test256 megabytes
# Alex doesn't like boredom. That's why whenever he gets bored, he comes up with games. One long winter evening he came up with a game and decided to play it.
#
# Given a sequence a consisting of n integers. The player can make several steps. In a single step he can choose an element of the sequence (let's denote it ak) and delete it, at that all elements equal to ak + 1 and ak - 1 also must be deleted from the sequence. That step brings ak points to the player.
#
# Alex is a perfectionist, so he decided to get as many points as possible. Help him.
#
# Input
# The first line contains integer n (1 ≤ n ≤ 105) that shows how many numbers are in Alex's sequence.
#
# The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 105).
#
# Output
# Print a single integer — the maximum number of points that Alex can earn.
#
# Examples
# inputCopy
# 2
# 1 2
# outputCopy
# 2
# inputCopy
# 3
# 1 2 3
# outputCopy
# 4
# inputCopy
# 9
# 1 2 1 3 2 2 2 2 3
# outputCopy
# 10
# Note
# Consider the third test example. At first step we need to choose any element equal to 2. After that step our sequence looks like this [2, 2, 2, 2]. Then we do 4 steps, on each step we choose any element equals to 2. In total we earn 10 points.
from typing import List
import sys


def solution(n: int, scores: List[int]) -> str:
    modules: dict[int, int] = dict()
    for num in scores:
        modules[num] = modules.get(num, 0) + 1
    moves: List[int] = sorted(modules.keys())
    dp: List[int] = [0] * len(moves)
    dp[0] = moves[0] * modules[moves[0]]
    move_idx: int = 1
    if move_idx < len(moves) and moves[move_idx] - 1 == moves[0]:
        dp[move_idx] = max(dp[0], moves[move_idx] * modules[moves[move_idx]])
        move_idx += 1
    while move_idx < len(moves):
        cur_num: int = moves[move_idx]
        cur_weight: int = cur_num * modules[cur_num]
        if cur_num - 1 == moves[move_idx - 1]:
            dp[move_idx] = max(dp[move_idx - 1], cur_weight + dp[move_idx - 2])
        else:
            dp[move_idx] = max(dp[move_idx - 1], cur_weight + dp[move_idx - 1])
        move_idx += 1
    return str(max(dp))



if __name__ == '__main__':
    n: int = int(sys.stdin.readline().rstrip())
    scores: List[int] = list(map(int, sys.stdin.readline().rstrip().split()))
    sys.stdout.write(solution(n, scores))

# 1905. Count Sub Islands
# You are given two m x n binary matrices grid1 and grid2 containing only 0's (representing water) and 1's (representing land). An island is a group of 1's connected 4-directionally (horizontal or vertical). Any cells outside of the grid are considered water cells.
#
# An island in grid2 is considered a sub-island if there is an island in grid1 that contains all the cells that make up this island in grid2.
#
# Return the number of islands in grid2 that are considered sub-islands.
#
#
#
# Example 1:
#
#
# Input: grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]
# Output: 3
# Explanation: In the picture above, the grid on the left is grid1 and the grid on the right is grid2.
# The 1s colored red in grid2 are those considered to be part of a sub-island. There are three sub-islands.
# Example 2:
#
#
# Input: grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]
# Output: 2
# Explanation: In the picture above, the grid on the left is grid1 and the grid on the right is grid2.
# The 1s colored red in grid2 are those considered to be part of a sub-island. There are two sub-islands.
#
#
# Constraints:
#
# m == grid1.length == grid2.length
# n == grid1[i].length == grid2[i].length
# 1 <= m, n <= 500
# grid1[i][j] and grid2[i][j] are either 0 or 1.
class Solution:
    def sub_islands(self, pos, mtrx, seen, points: list[tuple[int, int]]) -> None:
        if (
            pos in seen or
            not (0 <= pos[0] < len(mtrx)) or
            not (0 <= pos[1] < len(mtrx[0])) or
            mtrx[pos[0]][pos[1]] == 0
        ):
            return
        seen.add(pos)
        points.append((pos[0], pos[1]))
        next_row: int = pos[0]
        next_col: int = pos[1]
        self.sub_islands((next_row - 1, next_col), mtrx, seen, points)
        self.sub_islands((next_row + 1, next_col), mtrx, seen, points)
        self.sub_islands((next_row, next_col - 1), mtrx, seen, points)
        self.sub_islands((next_row, next_col + 1), mtrx, seen, points)


    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:
        seen: set[int] = set()
        valid_sub_islands: int = 0
        for row in range(len(grid2)):
            for col in range(len(grid2[0])):
                if grid2[row][col] == 1 and (row, col) not in seen:
                    points: list[tuple[int, int]] = []
                    self.sub_islands((row, col), grid2, seen, points)
                    valid_sub_islands += all(grid1[r][c] == 1 for r, c in points)
        return valid_sub_islands

# Simple Fun #250: Prefix Sums To Suffix Sums
# Have you finished this one? Now there is a complex version:
#
# Task
# Given the prefix sums of some array A, return suffix sums for the same array.
#
# Array of prefix sums is defined as:
#
# B[0] = A[0]
# B[1] = A[0] + A[1]
# B[2] = A[0] + A[1] + A[2]
# ...
# B[n - 1] = A[0] + A[1] + ... + A[n - 1]
# Array of suffix sums is defined as:
#
# B[0] = A[0] + A[1] + A[2] + ... + A[n - 1]
# B[1] =        A[1] + A[2] + ... + A[n - 1]
# ...
# B[n - 2] =             A[n - 2] + A[n - 1]
# B[n - 1] =                        A[n - 1]
# Input/Output
# [input] integer array prefixSums
#
# prefix sums of the orginal array.
#
# 1 ≤ prefixSums.length ≤ 10^4,
#
# -10^5 ≤ prefixSums[i] ≤ 10^5.
#
# [output] an integer array
#
# suffix sums of the orginal array.
#
# Example
# For prefixSums = [1, 3, 6, 10, 15],
#
# the output should be [15, 14, 12, 9, 5].
#
# You may verify that the initial array A is [1, 2, 3, 4, 5] (just try to calculate the prefix sums of it).
#
# Then following the rules, you can calculate the suffix sums of A.
#
# ALGORITHMS
def prefix_sums_to_suffix_sums(prefix_sums):
    suffix_sum: list[int] = [0] * len(prefix_sums)
    suffix_sum[0] = prefix_sums[-1]
    for i in range(1, len(prefix_sums)):
        suffix_sum[i] = prefix_sums[-1] - prefix_sums[i - 1]
    return suffix_sum

# A. Short Substrings
# A. Short Substrings
# time limit per test2 seconds
# memory limit per test256 megabytes
# Alice guesses the strings that Bob made for her.
#
# At first, Bob came up with the secret string a
#  consisting of lowercase English letters. The string a
#  has a length of 2
#  or more characters. Then, from string a
#  he builds a new string b
#  and offers Alice the string b
#  so that she can guess the string a
# .
#
# Bob builds b
#  from a
#  as follows: he writes all the substrings of length 2
#  of the string a
#  in the order from left to right, and then joins them in the same order into the string b
# .
#
# For example, if Bob came up with the string a
# ="abac", then all the substrings of length 2
#  of the string a
#  are: "ab", "ba", "ac". Therefore, the string b
# ="abbaac".
#
# You are given the string b
# . Help Alice to guess the string a
#  that Bob came up with. It is guaranteed that b
#  was built according to the algorithm given above. It can be proved that the answer to the problem is unique.
#
# Input
# The first line contains a single positive integer t
#  (1≤t≤1000
# ) — the number of test cases in the test. Then t
#  test cases follow.
#
# Each test case consists of one line in which the string b
#  is written, consisting of lowercase English letters (2≤|b|≤100
# ) — the string Bob came up with, where |b|
#  is the length of the string b
# . It is guaranteed that b
#  was built according to the algorithm given above.
#
# Output
# Output t
#  answers to test cases. Each answer is the secret string a
# , consisting of lowercase English letters, that Bob came up with.
#
# Example
# inputCopy
# 4
# abbaac
# ac
# bccddaaf
# zzzzzzzzzz
# outputCopy
# abac
# ac
# bcdaf
# zzzzzz
# Note
# The first test case is explained in the statement.
#
# In the second test case, Bob came up with the string a
# ="ac", the string a
#  has a length 2
# , so the string b
#  is equal to the string a
# .
#
# In the third test case, Bob came up with the string a
# ="bcdaf", substrings of length 2
#  of string a
#  are: "bc", "cd", "da", "af", so the string b
# ="bccddaaf".
import sys


def solution(t: int) -> None:
    for _ in range(t):
        b: str = sys.stdin.readline().rstrip()
        print(b[0] + b[1::2])


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)

# 947. Most Stones Removed with Same Row or Column
# On a 2D plane, we place n stones at some integer coordinate points. Each coordinate point may have at most one stone.
#
# A stone can be removed if it shares either the same row or the same column as another stone that has not been removed.
#
# Given an array stones of length n where stones[i] = [xi, yi] represents the location of the ith stone, return the largest possible number of stones that can be removed.
#
#
#
# Example 1:
#
# Input: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]
# Output: 5
# Explanation: One way to remove 5 stones is as follows:
# 1. Remove stone [2,2] because it shares the same row as [2,1].
# 2. Remove stone [2,1] because it shares the same column as [0,1].
# 3. Remove stone [1,2] because it shares the same row as [1,0].
# 4. Remove stone [1,0] because it shares the same column as [0,0].
# 5. Remove stone [0,1] because it shares the same row as [0,0].
# Stone [0,0] cannot be removed since it does not share a row/column with another stone still on the plane.
# Example 2:
#
# Input: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]
# Output: 3
# Explanation: One way to make 3 moves is as follows:
# 1. Remove stone [2,2] because it shares the same row as [2,0].
# 2. Remove stone [2,0] because it shares the same column as [0,0].
# 3. Remove stone [0,2] because it shares the same row as [0,0].
# Stones [0,0] and [1,1] cannot be removed since they do not share a row/column with another stone still on the plane.
# Example 3:
#
# Input: stones = [[0,0]]
# Output: 0
# Explanation: [0,0] is the only stone on the plane, so you cannot remove it.
#
#
# Constraints:
#
# 1 <= stones.length <= 1000
# 0 <= xi, yi <= 104
# No two stones are at the same coordinate point.
class Solution(object):
    def dfs(self, n: int, cur_ceil: int, seen: list[bool], stones: list[list[int]]) -> None:
        seen[cur_ceil] = True
        for i in range(n):
            if not seen[i]:
                cur_row, cur_col = stones[cur_ceil]
                if cur_row == stones[i][0] or cur_col == stones[i][1]:
                    self.dfs(n, i, seen, stones)

    def removeStones(self, stones: list[list[int]]) -> int:
        n: int = len(stones)
        group: int = 0
        seen: list[bool] = [False] * n

        for i in range(n):
            if not seen[i]:
                group += 1
                self.dfs(n, i, seen, stones)

        return n - group

# B. Balanced Array
# B. Balanced Array
# time limit per test1 second
# memory limit per test256 megabytes
# You are given a positive integer n
# , it is guaranteed that n
#  is even (i.e. divisible by 2
# ).
#
# You want to construct the array a
#  of length n
#  such that:
#
# The first n2
#  elements of a
#  are even (divisible by 2
# );
# the second n2
#  elements of a
#  are odd (not divisible by 2
# );
# all elements of a
#  are distinct and positive;
# the sum of the first half equals to the sum of the second half (∑i=1n2ai=∑i=n2+1nai
# ).
# If there are multiple answers, you can print any. It is not guaranteed that the answer exists.
#
# You have to answer t
#  independent test cases.
#
# Input
# The first line of the input contains one integer t
#  (1≤t≤104
# ) — the number of test cases. Then t
#  test cases follow.
#
# The only line of the test case contains one integer n
#  (2≤n≤2⋅105
# ) — the length of the array. It is guaranteed that that n
#  is even (i.e. divisible by 2
# ).
#
# It is guaranteed that the sum of n
#  over all test cases does not exceed 2⋅105
#  (∑n≤2⋅105
# ).
#
# Output
# For each test case, print the answer — "NO" (without quotes), if there is no suitable answer for the given test case or "YES" in the first line and any suitable array a1,a2,…,an
#  (1≤ai≤109
# ) satisfying conditions from the problem statement on the second line.
#
# Example
# inputCopy
# 5
# 2
# 4
# 6
# 8
# 10
# outputCopy
# NO
# YES
# 2 4 1 5
# NO
# YES
# 2 4 6 8 1 3 5 11
# NO
import sys


def solution(t: int) -> None:
    for _ in range(t):
        n: int = int(sys.stdin.readline().rstrip())
        if (n // 2) % 2 != 0:
            print("NO")
        else:
            print("YES")
            even_numbers = [i * 2 for i in range(1, n // 2 + 1)]
            odd_numbers = [i * 2 - 1 for i in range(1, n // 2)]
            odd_numbers.append(sum(even_numbers) - sum(odd_numbers))
            print(" ".join(map(str, even_numbers + odd_numbers)))


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)

# noobCode 02: TRICKY QUESTIONS ( primitives and operator precedence)
1 < 2 < 3 === true right? but could

3 < 2 < 1 === true too??

Here's your puzzle: Write a function greaterThanLessThan that takes three arguments, a, b, and c, and returns a boolean (true or false), such that:

greaterThanLessThan(1, 2 3) === true
and

greaterThanLessThan(3, 2 1) === true
But also

graterThanLessThan(-3, -2, -1) == false
with more examples on the expected behavior in the test cases.

Hints
Arguments do not necessarily have to be in strict ascending or descending order, as indicated by the example test cases.
Check out the included test cases - not all arguments are going to return true! It's up to you to figure out which ones do and which ones don't.

This challenge is a LOT easier than it might seem at first. Don't focus too much on building functions - just pay attention to precedence.
Best of luck!

Need some pointers? Brush up on your operator precedence here and you'll figure it out:
https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Operator_Precedence

Don't forget your primitives either:
https://developer.mozilla.org/en-US/docs/Glossary/Primitive
PUZZLES

bool greaterThanLessThan(long a, long b, long c) {
    return (a < b) < c;
}

# 2699. Modify Graph Edge Weights
# You are given an undirected weighted connected graph containing n nodes labeled from 0 to n - 1, and an integer array edges where edges[i] = [ai, bi, wi] indicates that there is an edge between nodes ai and bi with weight wi.
#
# Some edges have a weight of -1 (wi = -1), while others have a positive weight (wi > 0).
#
# Your task is to modify all edges with a weight of -1 by assigning them positive integer values in the range [1, 2 * 109] so that the shortest distance between the nodes source and destination becomes equal to an integer target. If there are multiple modifications that make the shortest distance between source and destination equal to target, any of them will be considered correct.
#
# Return an array containing all edges (even unmodified ones) in any order if it is possible to make the shortest distance from source to destination equal to target, or an empty array if it's impossible.
#
# Note: You are not allowed to modify the weights of edges with initial positive weights.
#
#
#
# Example 1:
#
#
#
# Input: n = 5, edges = [[4,1,-1],[2,0,-1],[0,3,-1],[4,3,-1]], source = 0, destination = 1, target = 5
# Output: [[4,1,1],[2,0,1],[0,3,3],[4,3,1]]
# Explanation: The graph above shows a possible modification to the edges, making the distance from 0 to 1 equal to 5.
# Example 2:
#
#
#
# Input: n = 3, edges = [[0,1,-1],[0,2,5]], source = 0, destination = 2, target = 6
# Output: []
# Explanation: The graph above contains the initial edges. It is not possible to make the distance from 0 to 2 equal to 6 by modifying the edge with weight -1. So, an empty array is returned.
# Example 3:
#
#
#
# Input: n = 4, edges = [[1,0,4],[1,2,3],[2,3,5],[0,3,-1]], source = 0, destination = 2, target = 6
# Output: [[1,0,4],[1,2,3],[2,3,5],[0,3,1]]
# Explanation: The graph above shows a modified graph having the shortest distance from 0 to 2 as 6.
#
#
# Constraints:
#
# 1 <= n <= 100
# 1 <= edges.length <= n * (n - 1) / 2
# edges[i].length == 3
# 0 <= ai, bi < n
# wi = -1 or 1 <= wi <= 107
# ai != bi
# 0 <= source, destination < n
# source != destination
# 1 <= target <= 109
# The graph is connected, and there are no self-loops or repeated edges
import heapq
from collections import defaultdict
class Solution:

    def dijkstra(
        self, start: int, end: int,
        adj_list: dict[int, list[tuple[int, int]]], paths: list[set[int]],
        costs: list[int], boundary: int
    ) -> None:
        seen: set[int] = set()
        heap: list[tuple[int, int]] = [(0, start)]
        costs[start] = 0

        while heap:
            cur_weight, cur_vertex = heapq.heappop(heap)
            if cur_vertex in seen: continue
            seen.add(cur_vertex)
            if cur_weight > boundary: return
            if cur_vertex == end: return
            for neighbor in adj_list.get(cur_vertex, []):
                neighbor_weight, neighbor_vertex = neighbor
                if cur_weight + neighbor_weight < costs[neighbor_vertex]:

                    costs[neighbor_vertex] = cur_weight + neighbor_weight
                    paths[neighbor_vertex].clear()
                    paths[neighbor_vertex].update(paths[cur_vertex])
                    paths[neighbor_vertex].add((cur_vertex, neighbor_vertex))

                heapq.heappush(heap, (cur_weight + neighbor_weight, neighbor_vertex))


    def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:
        should_be_changed: set[int] = set()
        adj_list: dict[int, list[tuple[int, int]]] = defaultdict(list)
        for idx in range(len(edges)):
            edge: list[int, int, int] = edges[idx]
            start, end, weight = edge
            if weight == -1:
                should_be_changed.add((start, end))
                edge[2] = 1
                weight = edge[2]
            adj_list[start].append((weight, end))
            adj_list[end].append((weight, start))

        for _ in range(n):
            paths: list[set[int]] = [set() for _ in range(n)]
            costs: list[int] = [float('inf')] * n
            self.dijkstra(source, destination, adj_list, paths, costs, target)
            if costs[destination] >= target: break

            for idx in range(len(edges)):
                edge: list[int, int, int] = edges[idx]
                if (
                    (edge[0], edge[1]) in should_be_changed and
                    (
                        (edge[0], edge[1]) in paths[destination] or
                        (edge[1], edge[0]) in paths[destination]
                    )
                ):
                    edge[2] += target - costs[destination]
                    for ceil_idx in range(len(adj_list[edge[0]])):
                        if adj_list[edge[0]][ceil_idx][1] == edge[1]:
                            adj_list[edge[0]][ceil_idx] = (edge[2], edge[1])
                            break
                    for ceil_idx in range(len(adj_list[edge[1]])):
                        if adj_list[edge[1]][ceil_idx][1] == edge[0]:
                            adj_list[edge[1]][ceil_idx] = (edge[2], edge[0])
                            break

                    break

        return edges if costs[destination] == target else []

# A. Download More RAM
# A. Download More RAM
# time limit per test1 second
# memory limit per test256 megabytes
# Did you know you can download more RAM? There is a shop with n
#  different pieces of software that increase your RAM. The i
# -th RAM increasing software takes ai
#  GB of memory to run (temporarily, once the program is done running, you get the RAM back), and gives you an additional bi
#  GB of RAM (permanently). Each software can only be used once. Your PC currently has k
#  GB of RAM.
#
# Note that you can't use a RAM-increasing software if it takes more GB of RAM to use than what you currently have.
#
# Since RAM is the most important thing in the world, you wonder, what is the maximum possible amount of RAM achievable?
#
# Input
# The first line of the input contains a single integer t
#  (1≤t≤100
# ) — the number of test cases. The description of test cases follows.
#
# The first line of each test case contains the integers n
#  and k
#  (1≤n≤100
# , 1≤k≤1000
# ). Then two lines follow, each containing n
#  integers describing the arrays a
#  and b
#  (1≤ai,bi≤1000
# ).
#
# Output
# For each test case, output a single line containing the largest amount of RAM you can achieve.
#
# Example
# inputCopy
# 4
# 3 10
# 20 30 10
# 9 100 10
# 5 1
# 1 1 5 1 1
# 1 1 1 1 1
# 5 1
# 2 2 2 2 2
# 100 100 100 100 100
# 5 8
# 128 64 32 16 8
# 128 64 32 16 8
# outputCopy
# 29
# 6
# 1
# 256
# Note
# In the first test case, you only have enough RAM to run the third software initially, but that increases your RAM to 20
#  GB, which allows you to use the first software, increasing your RAM to 29
#  GB. The only software left needs 30
#  GB of RAM, so you have to stop here.
#
# In the second test case, you can use the first, second, fourth and fifth software that need only 1
#  GB of RAM per software to run to increase your RAM to 5
#  GB, and then use the last remaining one to increase your RAM to 6
#  GB.
#
# In the third test case, all the software need more than 1
#  GB of RAM to run, so the amount of RAM you have stays at 1
#  GB.
import sys
from typing import List


def solution(t: int) -> None:
    for _ in range(t):
        n, k = map(int, sys.stdin.readline().rstrip().split())
        costs: List[int] = list(map(int, sys.stdin.readline().rstrip().split()))
        busts: List[int] = list(map(int, sys.stdin.readline().rstrip().split()))
        storage: List[List[int]] = [[costs[idx], busts[idx]] for idx in range(n)]
        storage.sort()
        for pair in storage:
            if k < pair[0]: break
            k += pair[1]
        sys.stdout.write(str(k) + '\n')


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)


Find the smallest integer in the array
Given an array of integers your solution should find the smallest integer.

For example:

Given [34, 15, 88, 2] your solution will return 2
Given [34, -345, -1, 100] your solution will return -345
You can assume, for the purpose of this kata, that the supplied array will not be empty.

FUNDAMENTALS
#include <vector>

using namespace std;

int findSmallest(vector <int> list)
{
  int min_el = list[0];
  for (int num : list) {
    if (min_el > num) {
      min_el = num;
    }
  }
  return min_el;
}

# 200. Number of Islands
# Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.
#
# An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.
#
#
#
# Example 1:
#
# Input: grid = [
#   ["1","1","1","1","0"],
#   ["1","1","0","1","0"],
#   ["1","1","0","0","0"],
#   ["0","0","0","0","0"]
# ]
# Output: 1
# Example 2:
#
# Input: grid = [
#   ["1","1","0","0","0"],
#   ["1","1","0","0","0"],
#   ["0","0","1","0","0"],
#   ["0","0","0","1","1"]
# ]
# Output: 3
#
#
# Constraints:
#
# m == grid.length
# n == grid[i].length
# 1 <= m, n <= 300
# grid[i][j] is '0' or '1'.
class Solution:
    def dfs(self, row: int, col: int, grid: list[list[str]], seen: set[tuple[int, int]]) -> None:
        if (row, col) in seen or not (0 <= row < len(grid)) or not (0 <= col < len(grid[0])) or grid[row][col] == '0':
            return
        seen.add((row, col))
        self.dfs(row + 1, col, grid, seen)
        self.dfs(row, col + 1, grid, seen)
        self.dfs(row - 1, col, grid, seen)
        self.dfs(row, col - 1, grid, seen)

    def numIslands(self, grid: List[List[str]]) -> int:
        seen: set[tuple[int, int]] = set()
        islands: int = 0
        for row in range(len(grid)):
            for col in range(len(grid[0])):
                if grid[row][col] == '1' and (row, col) not in seen:
                    self.dfs(row, col, grid, seen)
                    islands += 1
        return islands

# A. Mishka and Game
# A. Mishka and Game
# time limit per test1 second
# memory limit per test256 megabytes
# Mishka is a little polar bear. As known, little bears loves spending their free time playing dice for chocolates. Once in a wonderful sunny morning, walking around blocks of ice, Mishka met her friend Chris, and they started playing the game.
#
# Rules of the game are very simple: at first number of rounds n is defined. In every round each of the players throws a cubical dice with distinct numbers from 1 to 6 written on its faces. Player, whose value after throwing the dice is greater, wins the round. In case if player dice values are equal, no one of them is a winner.
#
# In average, player, who won most of the rounds, is the winner of the game. In case if two players won the same number of rounds, the result of the game is draw.
#
# Mishka is still very little and can't count wins and losses, so she asked you to watch their game and determine its result. Please help her!
#
# Input
# The first line of the input contains single integer n n (1 ≤ n ≤ 100) — the number of game rounds.
#
# The next n lines contains rounds description. i-th of them contains pair of integers mi and ci (1 ≤ mi,  ci ≤ 6) — values on dice upper face after Mishka's and Chris' throws in i-th round respectively.
#
# Output
# If Mishka is the winner of the game, print "Mishka" (without quotes) in the only line.
#
# If Chris is the winner of the game, print "Chris" (without quotes) in the only line.
#
# If the result of the game is draw, print "Friendship is magic!^^" (without quotes) in the only line.
#
# Examples
# inputCopy
# 3
# 3 5
# 2 1
# 4 2
# outputCopy
# Mishka
# inputCopy
# 2
# 6 1
# 1 6
# outputCopy
# Friendship is magic!^^
# inputCopy
# 3
# 1 5
# 3 3
# 2 2
# outputCopy
# Chris
# Note
# In the first sample case Mishka loses the first round, but wins second and third rounds and thus she is the winner of the game.
#
# In the second sample case Mishka wins the first round, Chris wins the second round, and the game ends with draw with score 1:1.
#
# In the third sample case Chris wins the first round, but there is no winner of the next two rounds. The winner of the game is Chris.
import sys


def solution(n: int) -> str:
    mi = ch = 0
    for _ in range(n):
        m, c = map(int, sys.stdin.readline().rstrip().split())
        mi += m > c
        ch += c > m
    return str(['Chris', 'Mishka'][mi > ch]) if mi != ch else 'Friendship is magic!^^'


if __name__ == '__main__':
    n: int = int(sys.stdin.readline().rstrip())
    sys.stdout.write(solution(n))


# Ragbaby cipher
# Introduction
# The ragbaby cipher is a substitution cipher that encodes/decodes a text using a keyed alphabet and their position in the plaintext word they are a part of.
#
# To encrypt the text This is an example. with the key cipher, first construct a keyed alphabet:
#
# c    i    p    h    e    r    a    b    d    f    g    j    k    l    m    n    o    q    s    t    u    v    w    x    y    z
# Then, number the letters in the text as follows:
#
# T    h    i    s         i    s         a    n         e    x    a    m    p    l    e    .
# 1    2    3    4         1    2         1    2         1    2    3    4    5    6    7
# To obtain the encoded text, replace each character of the word with the letter in the keyed alphabet the corresponding number of places to the right of it (wrapping if necessary). Non-alphabetic characters are preserved to mark word boundaries.
#
# Our ciphertext is then Urew pu bq rzfsbtj.
#
# Task
# Wirate functions encode and decode which accept 2 parameters:
#
# text - string - a text to encode/decode
# key - string - a key
# Notes
# handle lower and upper case in text string
# key consists of only lowercase characters
# CIPHERSSTRINGSFUNDAMENTALS
from string import ascii_lowercase

def encode(text, key):
    seen: set[str] = set()
    new_key: list[str] = []
    for letter in key:
        if letter not in seen:
            new_key.append(letter)
            seen.add(letter)
    keyed_alphabet: str = ''.join(new_key) + ''.join(letter for letter in ascii_lowercase if letter not in key)
    positions: dict[str, int] = dict((keyed_alphabet[idx], idx) for idx in range(26))
    encoded_message: list[str] = []
    char_idx: int = 1
    for letter in text:
        if letter.isalpha():
            is_upper: bool = letter.isupper()
            encoded_letter: str = keyed_alphabet[(positions[letter.lower()] + char_idx) % 26]
            encoded_message.append(encoded_letter.upper() if is_upper else encoded_letter)
            char_idx += 1
        else:
            encoded_message.append(letter)
            char_idx = 1

    return ''.join(encoded_message)

def decode(text, key):
    seen: set[str] = set()
    new_key: list[str] = []
    for letter in key:
        if letter not in seen:
            new_key.append(letter)
            seen.add(letter)
    keyed_alphabet: str = ''.join(new_key) + ''.join(letter for letter in ascii_lowercase if letter not in key)
    positions: dict[str, int] = dict((keyed_alphabet[idx], idx) for idx in range(26))
    encoded_message: list[str] = []
    char_idx: int = 1
    for letter in text:
        if letter.isalpha():
            is_upper: bool = letter.isupper()
            encoded_letter: str = keyed_alphabet[(positions[letter.lower()] + 26 - char_idx) % 26]
            encoded_message.append(encoded_letter.upper() if is_upper else encoded_letter)
            char_idx += 1
        else:
            encoded_message.append(letter)
            char_idx = 1

    return ''.join(encoded_message)

# 2022. Convert 1D Array Into 2D Array
# You are given a 0-indexed 1-dimensional (1D) integer array original, and two integers, m and n. You are tasked with creating a 2-dimensional (2D) array with  m rows and n columns using all the elements from original.
#
# The elements from indices 0 to n - 1 (inclusive) of original should form the first row of the constructed 2D array, the elements from indices n to 2 * n - 1 (inclusive) should form the second row of the constructed 2D array, and so on.
#
# Return an m x n 2D array constructed according to the above procedure, or an empty 2D array if it is impossible.
#
#
#
# Example 1:
#
#
# Input: original = [1,2,3,4], m = 2, n = 2
# Output: [[1,2],[3,4]]
# Explanation: The constructed 2D array should contain 2 rows and 2 columns.
# The first group of n=2 elements in original, [1,2], becomes the first row in the constructed 2D array.
# The second group of n=2 elements in original, [3,4], becomes the second row in the constructed 2D array.
# Example 2:
#
# Input: original = [1,2,3], m = 1, n = 3
# Output: [[1,2,3]]
# Explanation: The constructed 2D array should contain 1 row and 3 columns.
# Put all three elements in original into the first row of the constructed 2D array.
# Example 3:
#
# Input: original = [1,2], m = 1, n = 1
# Output: []
# Explanation: There are 2 elements in original.
# It is impossible to fit 2 elements in a 1x1 2D array, so return an empty 2D array.
#
#
# Constraints:
#
# 1 <= original.length <= 5 * 104
# 1 <= original[i] <= 105
# 1 <= m, n <= 4 * 104
# Solutions Simulation Matrix Array
# Note:
# We can consider that output answer memory don't count as "computated" memory.
# In this case in both solutions memory will be O(1)
# Complexity
# Time complexity: O(MN)
# Space complexity: O(MN)
# Code
class Solution:
    def construct2DArray(self, original: List[int], m: int, n: int) -> List[List[int]]:
        if m * n != len(original):
            return []
        main_idx: int = 0
        output: list[list[int]] = []
        for row in range(m):
            cur_row: list[int] = []
            for col in range(n):
                cur_row.append(original[main_idx])
                main_idx += 1
            output.append(cur_row)
        return output

# C++
# Complexity
# Time complexity: O(MN)
# Space complexity: O(MN)
# Code
class Solution {
public:
    vector<vector<int>> construct2DArray(vector<int>& original, int m, int n) {
        vector<vector<int>> output = {};
        if (m * n != original.size()) {
            return output;
        }
        int main_idx = 0;
        for (int row = 0; row < m; row++) {
            vector<int> cur_row = {};
            for (int col = 0; col < n; col++) {
                cur_row.push_back(original[main_idx]);
                main_idx += 1;
            }
            output.push_back(cur_row);
        }
        return output;
    }
};

# A. Die Roll
# A. Die Roll
# time limit per test1 second
# memory limit per test64 megabytes
# Yakko, Wakko and Dot, world-famous animaniacs, decided to rest from acting in cartoons, and take a leave to travel a bit. Yakko dreamt to go to Pennsylvania, his Motherland and the Motherland of his ancestors. Wakko thought about Tasmania, its beaches, sun and sea. Dot chose Transylvania as the most mysterious and unpredictable place.
#
# But to their great regret, the leave turned to be very short, so it will be enough to visit one of the three above named places. That's why Yakko, as the cleverest, came up with a truly genius idea: let each of the three roll an ordinary six-sided die, and the one with the highest amount of points will be the winner, and will take the other two to the place of his/her dreams.
#
# Yakko thrown a die and got Y points, Wakko — W points. It was Dot's turn. But she didn't hurry. Dot wanted to know for sure what were her chances to visit Transylvania.
#
# It is known that Yakko and Wakko are true gentlemen, that's why if they have the same amount of points with Dot, they will let Dot win.
#
# Input
# The only line of the input file contains two natural numbers Y and W — the results of Yakko's and Wakko's die rolls.
#
# Output
# Output the required probability in the form of irreducible fraction in format «A/B», where A — the numerator, and B — the denominator. If the required probability equals to zero, output «0/1». If the required probability equals to 1, output «1/1».
#
# Examples
# inputCopy
# 4 2
# outputCopy
# 1/2
# Note
# Dot will go to Transylvania, if she is lucky to roll 4, 5 or 6 points.
import sys


def find_gcd(x: int, y: int) -> int:
    if x == 0:
        return y
    return find_gcd(y % x, x)


def solution(y: int, m: int) -> str:
    numerator: int = 6 - max(y, m) + 1
    denominator: int = 6
    gcd: int = find_gcd(numerator, denominator)
    return f'{numerator // gcd}/{denominator // gcd}'


if __name__ == '__main__':
    y, m = map(int, sys.stdin.readline().rstrip().split())
    sys.stdout.write(solution(y, m))

# A snail enters a bar!
# Problem Description:
#
# A snail is crawling along a rubber band that has an initial length of x units. The snail moves at a constant speed of y units per minute. As the snail crawls from the left end of the rubber band to the right end, the rubber band increases in length from the right side every minute, adding z units to its length.
#
# The question is: Will the snail be able to reach the right end of the rubber band within 1 year?
#
# Parameters:
#
# x: Initial length of the rubber band (in units), where 0.01 ≤ x ≤ 1,000,000.
# y: Speed of the snail (in units per minute), where 0.01 ≤ y ≤ 1,000,000.
# z: Amount by which the rubber band increases in length every minute (in units), where 0.01 ≤ z ≤ 1,000,000.
# Examples:
#
# Example 1:
#
# Initial length of the rubber band: x = 10 units
# Speed of the snail: y = 2 units/minute
# Increase rate of the rubber band: z = 1 unit/minute
# Outcome: true (The snail will reach the end in 10 minutes.)
# Example 2:
#
# Initial length of the rubber band: x = 100 units
# Speed of the snail: y = 1 unit/minute
# Increase rate of the rubber band: z = 2 units/minute
# Outcome: false (The snail will never reach the end.)
# Example 3:
#
# Initial length of the rubber band: x = 100,000 units
# Speed of the snail: y = 0.1 units/minute
# Increase rate of the rubber band: z = 0.05 units/minute
# Outcome: false (The snail will not be able to reach the end within one year.)
# MATHEMATICS
def can_snail_reach_end(length, speed, length_increases):
    boundary: int = 365 * 24 * 60
    if speed <= length_increases: return False
    return length / (speed - length_increases) <= boundary

bool canSnailReachEnd(double length, double speed, double lengthIncreases)
{
  int boundary = 365 * 24 * 60;
  if (speed <= lengthIncreases) {
    return false;
  }
  return (length / (speed - lengthIncreases)) <= boundary;
}

# 3270. Find the Key of the Numbers
# You are given three positive integers num1, num2, and num3.
#
# The key of num1, num2, and num3 is defined as a four-digit number such that:
#
# Initially, if any number has less than four digits, it is padded with leading zeros.
# The ith digit (1 <= i <= 4) of the key is generated by taking the smallest digit among the ith digits of num1, num2, and num3.
# Return the key of the three numbers without leading zeros (if any).
#
#
#
# Example 1:
#
# Input: num1 = 1, num2 = 10, num3 = 1000
#
# Output: 0
#
# Explanation:
#
# On padding, num1 becomes "0001", num2 becomes "0010", and num3 remains "1000".
#
# The 1st digit of the key is min(0, 0, 1).
# The 2nd digit of the key is min(0, 0, 0).
# The 3rd digit of the key is min(0, 1, 0).
# The 4th digit of the key is min(1, 0, 0).
# Hence, the key is "0000", i.e. 0.
#
# Example 2:
#
# Input: num1 = 987, num2 = 879, num3 = 798
#
# Output: 777
#
# Example 3:
#
# Input: num1 = 1, num2 = 2, num3 = 3
#
# Output: 1
#
#
#
# Constraints:
#
# 1 <= num1, num2, num3 <= 9999
# Python
# Complexity
# Time complexity: O(1)
# Space complexity: O(1)
# Code
class Solution:
    def generateKey(self, num1: int, num2: int, num3: int) -> int:
        num1 = '0' * (4 - len(str(num1))) + str(num1)
        num2 = '0' * (4 - len(str(num2))) + str(num2)
        num3 = '0' * (4 - len(str(num3))) + str(num3)
        return int(''.join(min(pair) for pair in zip(num1, num2, num3)))

# C++
# Complexity
# Time complexity: O(1)
# Space complexity: O(1)
# Code
class Solution {
public:
    int generateKey(int num1, int num2, int num3) {
        string s_num1 = to_string(num1);
        string s_num2 = to_string(num2);
        string s_num3 = to_string(num3);
        while (s_num1.size() != 4) {
            s_num1 = "0" + s_num1;
        }
        while (s_num2.size() != 4) {
            s_num2 = "0" + s_num2;
        }
        while (s_num3.size() != 4) {
            s_num3 = "0" + s_num3;
        }

        string result = "";
        for (int idx = 0; idx < 4; idx++) {
            result += min({s_num1[idx], s_num2[idx], s_num3[idx]});
        }
        return stoi(result);
    }
};

# 3271. Hash Divided String
# You are given a string s of length n and an integer k, where n is a multiple of k. Your task is to hash the string s into a new string called result, which has a length of n / k.
#
# First, divide s into n / k
# substrings
# , each with a length of k. Then, initialize result as an empty string.
#
# For each substring in order from the beginning:
#
# The hash value of a character is the index of that character in the English alphabet (e.g., 'a' → 0, 'b' → 1, ..., 'z' → 25).
# Calculate the sum of all the hash values of the characters in the substring.
# Find the remainder of this sum when divided by 26, which is called hashedChar.
# Identify the character in the English lowercase alphabet that corresponds to hashedChar.
# Append that character to the end of result.
# Return result.
#
#
#
# Example 1:
#
# Input: s = "abcd", k = 2
#
# Output: "bf"
#
# Explanation:
#
# First substring: "ab", 0 + 1 = 1, 1 % 26 = 1, result[0] = 'b'.
#
# Second substring: "cd", 2 + 3 = 5, 5 % 26 = 5, result[1] = 'f'.
#
# Example 2:
#
# Input: s = "mxz", k = 3
#
# Output: "i"
#
# Explanation:
#
# The only substring: "mxz", 12 + 23 + 25 = 60, 60 % 26 = 8, result[0] = 'i'.
#
#
#
# Constraints:
#
# 1 <= k <= 100
# k <= s.length <= 1000
# s.length is divisible by k.
# s consists only of lowercase English letters.

# C++
# Complexity
# Time complexity: O(N)
#
# Space complexity: O(N)
#
# Code
class Solution {
public:
    string stringHash(string s, int k) {
        string result;
        int cur_sum = 0;
        string alphabet = "abcdefghijklmnopqrstuvwxyz";
        for (int idx = 0; idx < s.size(); idx++) {
            cur_sum += alphabet.find(s[idx]);
            if ((idx + 1) % k == 0) {
                result += alphabet[cur_sum % 26];
                cur_sum = 0;
            }
        }
        return result;
    }
};

# Python
# Complexity
# Time complexity: O(N)
#
# Space complexity: O(N)
#
# Code
from string import ascii_lowercase as al
class Solution:
    def stringHash(self, s: str, k: int) -> str:
        result: str = ''
        cur_sum: int = 0
        for idx in range(len(s)):
            cur_sum += al.index(s[idx])
            if (idx + 1) % k == 0:
                result += al[cur_sum % 26]
                cur_sum = 0
        return result

# 3274. Check if Two Chessboard Squares Have the Same Color
# You are given two strings, coordinate1 and coordinate2, representing the coordinates of a square on an 8 x 8 chessboard.
#
# Below is the chessboard for reference.
#
#
#
# Return true if these two squares have the same color and false otherwise.
#
# The coordinate will always represent a valid chessboard square. The coordinate will always have the letter first (indicating its column), and the number second (indicating its row).
#
#
#
# Example 1:
#
# Input: coordinate1 = "a1", coordinate2 = "c3"
#
# Output: true
#
# Explanation:
#
# Both squares are black.
#
# Example 2:
#
# Input: coordinate1 = "a1", coordinate2 = "h3"
#
# Output: false
#
# Explanation:
#
# Square "a1" is black and "h3" is white.
#
#
#
# Constraints:
#
# coordinate1.length == coordinate2.length == 2
# 'a' <= coordinate1[0], coordinate2[0] <= 'h'
# '1' <= coordinate1[1], coordinate2[1] <= '8'
# C++
# Complexity
# Time complexity: O(1)
#
# Space complexity: O(1)
#
# Code
class Solution {
public:
    bool checkTwoChessboards(string c1, string c2) {
        string alphabet = "abcdefgh";
        int col1= alphabet.find(c1[0]) + 1;
        int row1 = stoi(c1.substr(1));
        int col2 = alphabet.find(c2[0]) + 1;
        int row2 = stoi(c2.substr(1));
        return (
            (
                (col1 % 2 != 0 && row1 % 2 != 0 || col1 % 2 == 0 && row1 % 2 == 0) &&
                (col2 % 2 != 0 && row2 % 2 != 0 || col2 % 2 == 0 && row2 % 2 == 0)
             ) ||
            (
                (col1 % 2 != 0 && row1 % 2 == 0 || col1 % 2 == 0 && row1 % 2 != 0) &&
                (col2 % 2 != 0 && row2 % 2 == 0 || col2 % 2 == 0 && row2 % 2 != 0)
            )
        );
    }
};

# Python
# Simulation
# Complexity
# Time complexity: O(1)
#
# Space complexity: O(1)
#
# Code
class Solution:
    def checkTwoChessboards(self, c1: str, c2: str) -> bool:
        mtrx: list[list[bool]] = []
        flag: bool = True
        for i in range(8):
            cur_row: list[bool] = []
            for j in range(8):
                cur_row.append(flag)
                flag = not flag
            flag = not flag
            mtrx.append(cur_row)
        return mtrx[int(c1[1]) - 1][ord(c1[0]) - 97] == mtrx[int(c2[1]) - 1][ord(c2[0]) - 97]

# 3275. K-th Nearest Obstacle Queries
# There is an infinite 2D plane.
#
# You are given a positive integer k. You are also given a 2D array queries, which contains the following queries:
#
# queries[i] = [x, y]: Build an obstacle at coordinate (x, y) in the plane. It is guaranteed that there is no obstacle at this coordinate when this query is made.
# After each query, you need to find the distance of the kth nearest obstacle from the origin.
#
# Return an integer array results where results[i] denotes the kth nearest obstacle after query i, or results[i] == -1 if there are less than k obstacles.
#
# Note that initially there are no obstacles anywhere.
#
# The distance of an obstacle at coordinate (x, y) from the origin is given by |x| + |y|.
#
#
#
# Example 1:
#
# Input: queries = [[1,2],[3,4],[2,3],[-3,0]], k = 2
#
# Output: [-1,7,5,3]
#
# Explanation:
#
# Initially, there are 0 obstacles.
# After queries[0], there are less than 2 obstacles.
# After queries[1], there are obstacles at distances 3 and 7.
# After queries[2], there are obstacles at distances 3, 5, and 7.
# After queries[3], there are obstacles at distances 3, 3, 5, and 7.
# Example 2:
#
# Input: queries = [[5,5],[4,4],[3,3]], k = 1
#
# Output: [10,8,6]
#
# Explanation:
#
# After queries[0], there is an obstacle at distance 10.
# After queries[1], there are obstacles at distances 8 and 10.
# After queries[2], there are obstacles at distances 6, 8, and 10.
#
#
# Constraints:
#
# 1 <= queries.length <= 2 * 105
# All queries[i] are unique.
# -109 <= queries[i][0], queries[i][1] <= 109
# 1 <= k <= 105
import heapq
class Solution:
    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:
        results: list[int] = []
        min_heap: list[int] = []

        for (x, y) in queries:
            dist: int = abs(x) + abs(y)
            heapq.heappush(min_heap, -dist)

            if len(min_heap) > k:
                heapq.heappop(min_heap)

            results.append(-1 if len(min_heap) < k else -min_heap[0])

        return results

# 1894. Find the Student that Will Replace the Chalk
# There are n students in a class numbered from 0 to n - 1. The teacher will give each student a problem starting with the student number 0, then the student number 1, and so on until the teacher reaches the student number n - 1. After that, the teacher will restart the process, starting with the student number 0 again.
#
# You are given a 0-indexed integer array chalk and an integer k. There are initially k pieces of chalk. When the student number i is given a problem to solve, they will use chalk[i] pieces of chalk to solve that problem. However, if the current number of chalk pieces is strictly less than chalk[i], then the student number i will be asked to replace the chalk.
#
# Return the index of the student that will replace the chalk pieces.
#
#
#
# Example 1:
#
# Input: chalk = [5,1,5], k = 22
# Output: 0
# Explanation: The students go in turns as follows:
# - Student number 0 uses 5 chalk, so k = 17.
# - Student number 1 uses 1 chalk, so k = 16.
# - Student number 2 uses 5 chalk, so k = 11.
# - Student number 0 uses 5 chalk, so k = 6.
# - Student number 1 uses 1 chalk, so k = 5.
# - Student number 2 uses 5 chalk, so k = 0.
# Student number 0 does not have enough chalk, so they will have to replace it.
# Example 2:
#
# Input: chalk = [3,4,1,2], k = 25
# Output: 1
# Explanation: The students go in turns as follows:
# - Student number 0 uses 3 chalk so k = 22.
# - Student number 1 uses 4 chalk so k = 18.
# - Student number 2 uses 1 chalk so k = 17.
# - Student number 3 uses 2 chalk so k = 15.
# - Student number 0 uses 3 chalk so k = 12.
# - Student number 1 uses 4 chalk so k = 8.
# - Student number 2 uses 1 chalk so k = 7.
# - Student number 3 uses 2 chalk so k = 5.
# - Student number 0 uses 3 chalk so k = 2.
# Student number 1 does not have enough chalk, so they will have to replace it.
#
#
# Constraints:
#
# chalk.length == n
# 1 <= n <= 105
# 1 <= chalk[i] <= 105
# 1 <= k <= 109
# Solution Python O(N) O(1) Math Simulation Greedy
class Solution:
    def chalkReplacer(self, chalk: List[int], k: int) -> int:
        total_sum: int = sum(chalk)
        k %= total_sum
        idx: int = 0
        while k >= 0:
            if chalk[idx] > k: return idx
            k -= chalk[idx]
            idx = (idx + 1) % len(chalk)
# Solution C++ O(N) O(1) Math Simulation Greedy
class Solution {
public:
    int chalkReplacer(vector<int>& chalk, int k) {
        long long total_sum = 0;
        for (int num : chalk) {
            total_sum += num;
        }
        k %= total_sum;
        int idx = 0;
        while (k >= 0) {
            if (chalk[idx] > k) {
                return idx;
            }
            k -= chalk[idx];
            idx = (idx + 1) % chalk.size();
        }
        return idx;
    }
};


# A. Ilya and Bank Account
# A. Ilya and Bank Account
# time limit per test2 seconds
# memory limit per test256 megabytes
# Ilya is a very clever lion, he lives in an unusual city ZooVille. In this city all the animals have their rights and obligations. Moreover, they even have their own bank accounts. The state of a bank account is an integer. The state of a bank account can be a negative number. This means that the owner of the account owes the bank money.
#
# Ilya the Lion has recently had a birthday, so he got a lot of gifts. One of them (the gift of the main ZooVille bank) is the opportunity to delete the last digit or the digit before last from the state of his bank account no more than once. For example, if the state of Ilya's bank account is -123, then Ilya can delete the last digit and get his account balance equal to -12, also he can remove its digit before last and get the account balance equal to -13. Of course, Ilya is permitted not to use the opportunity to delete a digit from the balance.
#
# Ilya is not very good at math, and that's why he asks you to help him maximize his bank account. Find the maximum state of the bank account that can be obtained using the bank's gift.
#
# Input
# The single line contains integer n (10 ≤ |n| ≤ 109) — the state of Ilya's bank account.
#
# Output
# In a single line print an integer — the maximum state of the bank account that Ilya can get.
#
# Examples
# inputCopy
# 2230
# outputCopy
# 2230
# inputCopy
# -10
# outputCopy
# 0
# inputCopy
# -100003
# outputCopy
# -10000
# Note
# In the first test sample Ilya doesn't profit from using the present.
#
# In the second test sample you can delete digit 1 and get the state of the account equal to 0.
import sys


def solution(n: str) -> str:
    if n[0] != '-': return str(n)
    result: str = min(n[:-1], n[:-2] + n[-1])
    if result == '-0': return '0'
    return result


if __name__ == '__main__':
    n: str = sys.stdin.readline().rstrip()
    sys.stdout.write(solution(n))

# Pyramid Structure Analyzer
# In this kata, you are given the sum of the number of vertices, edges, and faces of an
#
# N-sided pyramid, which is equal to s. You need to return the number of vertices,edges,
#
# faces, and the number of sides of the base of the pyramid.
#
# MATHEMATICSALGORITHMS
def pyramid(s):
    N = (s - 2) // 4
    V = N + 1
    E = 2 * N
    F = N + 1
    return (V, E, F, N)

# Doors in the school
# In the morning all the doors in the school are closed. The school is quite big: there are N doors. Then pupils start coming. It might be hard to believe, but all of them want to study! Also, there are exactly N children studying in this school, and they come one by one.
#
# When these strange children pass by some doors they change their status (i.e. Open -> Closed, Closed -> Open). Each student has their number, and each i-th student alters the status of every i-th door. For example: when the first child comes to the schools, he changes every first door (he opens all of them). The second one changes the status of every second door (he closes some doors: the 2nd, the 4th and so on). Finally, when the last one – the n-th – comes to the school, he changes the status of each n-th door (there's only one such door, though).
#
# You need to count how many doors are left opened after all the students have come.
#
# Example:
#
#
#
# Here you can see red squares – closed doors, green – opened ones.
#
# Input:
#
# n – the number of doors and students, n ∈ N, n ∈ [1, 100000]
#
# Output:
#
# o – the number of opened doors, o ∈ N
#
# doors(5)
# Should return
#
# 2
# FUNDAMENTALSALGORITHMS
# Solution
def doors(n):
    doors: list[bool] = [False] * (n + 1)
    for mate in range(1, n + 1):
        for door_open in range(mate, n + 1, mate):
            doors[door_open] = not doors[door_open]
    return sum(doors)

# A. Football

# A. Football
# time limit per test2 seconds
# memory limit per test256 megabytes
# One day Vasya decided to have a look at the results of Berland 1910 Football Championship’s finals. Unfortunately he didn't find the overall score of the match; however, he got hold of a profound description of the match's process. On the whole there are n lines in that description each of which described one goal. Every goal was marked with the name of the team that had scored it. Help Vasya, learn the name of the team that won the finals. It is guaranteed that the match did not end in a tie.
#
# Input
# The first line contains an integer n (1 ≤ n ≤ 100) — the number of lines in the description. Then follow n lines — for each goal the names of the teams that scored it. The names are non-empty lines consisting of uppercase Latin letters whose lengths do not exceed 10 symbols. It is guaranteed that the match did not end in a tie and the description contains no more than two different teams.
#
# Output
# Print the name of the winning team. We remind you that in football the team that scores more goals is considered the winner.
#
# Examples
# inputCopy
# 1
# ABC
# outputCopy
# ABC
# inputCopy
# 5
# A
# ABA
# ABA
# A
# A
# outputCopy
# A
# Solution O(N) O(N)
import sys


def solution(n: int) -> str:
    commands: dict[str, int] = dict()
    for _ in range(n):
        command: str = sys.stdin.readline().rstrip()
        commands[command] = commands.get(command, 0) + 1
    return max(commands.keys(), key=lambda x: commands[x])


if __name__ == '__main__':
    n: int = int(sys.stdin.readline().rstrip())
    sys.stdout.write(solution(n))

# 874. Walking Robot Simulation
# A robot on an infinite XY-plane starts at point (0, 0) facing north. The robot can receive a sequence of these three possible types of commands:
#
# -2: Turn left 90 degrees.
# -1: Turn right 90 degrees.
# 1 <= k <= 9: Move forward k units, one unit at a time.
# Some of the grid squares are obstacles. The ith obstacle is at grid point obstacles[i] = (xi, yi). If the robot runs into an obstacle, then it will instead stay in its current location and move on to the next command.
#
# Return the maximum Euclidean distance that the robot ever gets from the origin squared (i.e. if the distance is 5, return 25).
#
# Note:
#
# North means +Y direction.
# East means +X direction.
# South means -Y direction.
# West means -X direction.
# There can be obstacle in [0,0].
#
#
# Example 1:
#
# Input: commands = [4,-1,3], obstacles = []
# Output: 25
# Explanation: The robot starts at (0, 0):
# 1. Move north 4 units to (0, 4).
# 2. Turn right.
# 3. Move east 3 units to (3, 4).
# The furthest point the robot ever gets from the origin is (3, 4), which squared is 32 + 42 = 25 units away.
# Example 2:
#
# Input: commands = [4,-1,4,-2,4], obstacles = [[2,4]]
# Output: 65
# Explanation: The robot starts at (0, 0):
# 1. Move north 4 units to (0, 4).
# 2. Turn right.
# 3. Move east 1 unit and get blocked by the obstacle at (2, 4), robot is at (1, 4).
# 4. Turn left.
# 5. Move north 4 units to (1, 8).
# The furthest point the robot ever gets from the origin is (1, 8), which squared is 12 + 82 = 65 units away.
# Example 3:
#
# Input: commands = [6,-1,-1,6], obstacles = []
# Output: 36
# Explanation: The robot starts at (0, 0):
# 1. Move north 6 units to (0, 6).
# 2. Turn right.
# 3. Turn right.
# 4. Move south 6 units to (0, 0).
# The furthest point the robot ever gets from the origin is (0, 6), which squared is 62 = 36 units away.
#
#
# Constraints:
#
# 1 <= commands.length <= 104
# commands[i] is either -2, -1, or an integer in the range [1, 9].
# 0 <= obstacles.length <= 104
# -3 * 104 <= xi, yi <= 3 * 104
# The answer is guaranteed to be less than 231.
class Solution:
    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:
        cur_x = cur_y = 0
        max_distance: int = 0
        north: bool = True
        east = south = west = False
        storage: set[tuple[int, int]] = set()
        for obstacle in obstacles:
            storage.add((obstacle[0], obstacle[1]))
        for command in commands:
            if command == -2:
                if north: north, west = False, True
                elif west: west, south = False, True
                elif south: south, east = False, True
                else: east, north = False, True
            elif command == -1:
                if north: north, east = False, True
                elif west: west, north = False, True
                elif south: south, west = False, True
                else: east, south = False, True
            else:
                if north:
                    for new_y in range(cur_y + 1, cur_y + command + 1):
                        if (cur_x, new_y) in storage: break
                        else: cur_y += 1
                elif west:
                    for new_x in range(cur_x - 1, cur_x - command - 1, -1):
                        if (new_x, cur_y) in storage: break
                        else: cur_x -= 1
                elif south:
                    for new_y in range(cur_y - 1, cur_y - command - 1, -1):
                        if (cur_x, new_y) in storage: break
                        else: cur_y -= 1
                else:
                    new_x: int = cur_x + command
                    for new_x in range(cur_x + 1, cur_x + command + 1):
                        if (new_x, cur_y) in storage: break
                        else: cur_x += 1
                max_distance = max(max_distance, cur_x**2 + cur_y**2)

        return max_distance

# A. Odd One Out
# A. Odd One Out
# time limit per test1 second
# memory limit per test256 megabytes
# You are given three digits a
# , b
# , c
# . Two of them are equal, but the third one is different from the other two.
#
# Find the value that occurs exactly once.
#
# Input
# The first line contains a single integer t
#  (1≤t≤270
# ) — the number of test cases.
#
# The only line of each test case contains three digits a
# , b
# , c
#  (0≤a
# , b
# , c≤9
# ). Two of the digits are equal, but the third one is different from the other two.
#
# Output
# For each test case, output the value that occurs exactly once.
#
# Example
# inputCopy
# 10
# 1 2 2
# 4 3 4
# 5 5 6
# 7 8 8
# 9 0 9
# 3 6 3
# 2 8 2
# 5 7 7
# 7 7 5
# 5 7 5
# outputCopy
# 1
# 3
# 6
# 7
# 0
# 6
# 8
# 5
# 5
# 7
import sys


def solution(t: int) -> None:
    for _ in range(t):
        a, b, c = map(int, sys.stdin.readline().rstrip().split())
        if a == b: print(c)
        elif b == c: print(a)
        else: print(b)


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)

# Simple Fun #384: Is Turing's Equation?
# Story
# Joe Stoy, in his book "Denotational Semantics", tells following story:
#
# The decision which way round the digits run is, of course, mathematically trivial.
# Indeed, one early British computer had numbers running from right to left (because
# the spot on an oscilloscope tube runs from left to right, but in serial logic the
# least significant digits are dealt with first).
#
# Turing used to mystify audiences at public lectures when, quite by accident, he would
# slip into this mode even for decimal arithmetic, and write things like 73+42=16.
#
# The next version of the machine was made more conventional simply by crossing the
# x-deflection wires: this, however, worried the engineers, whose waveforms were all
# backwards. That problem was in turn solved by providing a little window so that the
# engineers(who tended to be behind the computer anyway) could view the oscilloscope
# screen from the back.
#
# [C. Strachey - private communication.]
# You will play the role of the audience and judge on the truth value of Turing's equations.
#
# Task
# You are given a string s. It's an equation such as "a+b=c", where a, b, c are numbers made up of the digits 0 to 9. This includes possible leading or trailing zeros. The equations will not contain any spaces.
#
# Your task is to determine whether s is a valid Turing equation. Return true or false, respectively, in Turing's interpretation, i.e. the numbers being read backwards.
#
# Still struggling to understand the task? Look at the following examples ;-)
#
# Examples
# For s = "73+42=16", the output should be true.
#
# 73 -> 37
# 42 -> 24
# 16 -> 61
# 37+24==61
# For s = "5+8=13", the output should be false.
#
# 5 -> 5
# 8 -> 8
# 13 -> 31
# 5+8!=31
# For s = "10+20=30", the output should be true.
#
# 10 -> 01 -> 1
# 20 -> 02 -> 2
# 30 -> 03 -> 3
# 1+2==3
# Note
# All the numbers a,b,c no more than 10 digits, excluding leading zeros(read backwards)
#
# s contains only digits, "+" and "=", "-","*" or "/" will not appear in the string.
#
# Happy Coding ^_^
#
# FUNDAMENTALSSTRINGSMATHEMATICS
def is_turing_equation(s):
    # Split the string based on '+' and '=' to get a, b, c
    a, rest = s.split('+')
    b, c = rest.split('=')

    # Reverse the strings and convert to integers
    a_reversed = int(a[::-1])
    b_reversed = int(b[::-1])
    c_reversed = int(c[::-1])

    # Check if the sum of reversed a and b equals reversed c
    return a_reversed + b_reversed == c_reversed

# 2028. Find Missing Observations
# You have observations of n + m 6-sided dice rolls with each face numbered from 1 to 6. n of the observations went missing, and you only have the observations of m rolls. Fortunately, you have also calculated the average value of the n + m rolls.
#
# You are given an integer array rolls of length m where rolls[i] is the value of the ith observation. You are also given the two integers mean and n.
#
# Return an array of length n containing the missing observations such that the average value of the n + m rolls is exactly mean. If there are multiple valid answers, return any of them. If no such array exists, return an empty array.
#
# The average value of a set of k numbers is the sum of the numbers divided by k.
#
# Note that mean is an integer, so the sum of the n + m rolls should be divisible by n + m.
#
#
#
# Example 1:
#
# Input: rolls = [3,2,4,3], mean = 4, n = 2
# Output: [6,6]
# Explanation: The mean of all n + m rolls is (3 + 2 + 4 + 3 + 6 + 6) / 6 = 4.
# Example 2:
#
# Input: rolls = [1,5,6], mean = 3, n = 4
# Output: [2,3,2,2]
# Explanation: The mean of all n + m rolls is (1 + 5 + 6 + 2 + 3 + 2 + 2) / 7 = 3.
# Example 3:
#
# Input: rolls = [1,2,3,4], mean = 6, n = 4
# Output: []
# Explanation: It is impossible for the mean to be 6 no matter what the 4 missing rolls are.
#
#
# Constraints:
#
# m == rolls.length
# 1 <= n, m <= 105
# 1 <= rolls[i], mean <= 6
# Python O(N + M) O(N)
class Solution:
    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:
        m: int = len(rolls)
        N: int = m + n
        n_dolls: list[int] = []
        total_sum: int = sum(rolls)
        for _ in range(n):
            candidate: int = None
            for doll in range(1, 7):
                if (total_sum + doll + (n - 1)) / N <= mean:
                    candidate = doll

            if candidate:
                total_sum += candidate
                n -= 1
                n_dolls.append(candidate)
        return n_dolls if total_sum / N == mean else []

# C++ O(N + M) O(N)
class Solution {
public:
    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {
        int m = rolls.size();
        int total_sum = mean * (m + n);
        int current_sum = accumulate(rolls.begin(), rolls.end(), 0);
        int missing_sum = total_sum - current_sum;
        if (missing_sum < n || missing_sum > 6 * n) {
            return {};
        }   
        vector<int> n_rolls(n, 1);
        missing_sum -= n;

        for (int i = 0; i < n && missing_sum > 0; ++i) {
            int add = min(missing_sum, 5);
            n_rolls[i] += add;
            missing_sum -= add;
        }

        return n_rolls;
    }
};

# A1 Thick and Hearty
# Given two arrays a1 and a2 of positive integers find the set of common elements between them and return the elements (a set) that have a sum or difference equal to either array length.
#
# All elements will be positive integers greater than 0
# If there are no results an empty set should be returned
# Each operation should only use two elements
# Examples
#
# a1 = [1, 2, 3, 4, 5, 6]
# a2 = [1, 2, 4, 6, 7, 8, 9, 10]
# should return {2, 4, 6} because all three integers exist in both arrays and a1 has a length of 6 (2+4) and a2 has a length of 8 (2+6).
#
# a1 = [1, 2, 3, 5, 10, 15]
# a2 = [1, 2, 3, 4, 5, 6, 10, 12, 15, 16]
# should return {1, 5, 15} because all 3 integers exist in both arrays and a1 has a length of 6 (1+5) and a2 has a length of 10 (15-5).
#
# LISTSPERMUTATIONSFUNDAMENTALS
def a1_thick_and_hearty(a1, a2):
    candidates: set[int] = set(a1) & set(a2)
    result: set[int] = set()
    n: int = len(a1)
    m: int = len(a2)
    while candidates:
        candidate: int = candidates.pop()
        if abs(candidate - n) in candidates:
            result.add(candidate)
            result.add(abs(candidate - n))
        if abs(candidate - m) in candidates:
            result.add(candidate)
            result.add(abs(candidate - m))
        if abs(candidate + n) in candidates:
            result.add(candidate)
            result.add(abs(candidate + n))
        if abs(candidate + m) in candidates:
            result.add(candidate)
            result.add(abs(candidate + m))
    return result

# A. To My Critics
# A. To My Critics
# time limit per test1 second
# memory limit per test256 megabytes
# Suneet has three digits a
# , b
# , and c
# .
#
# Since math isn't his strongest point, he asks you to determine if you can choose any two digits to make a sum greater or equal to 10
# .
#
# Output "YES" if there is such a pair, and "NO" otherwise.
#
# Input
# The first line contains a single integer t
#  (1≤t≤1000
# ) — the number of test cases.
#
# The only line of each test case contains three digits a
# , b
# , c
#  (0≤a,b,c≤9
# ).
#
# Output
# For each test case, output "YES" if such a pair exists, and "NO" otherwise.
#
# You can output the answer in any case (for example, the strings "yEs", "yes", "Yes" and "YES" will be recognized as a positive answer).
#
# Example
# inputCopy
# 5
# 8 1 2
# 4 4 5
# 9 9 9
# 0 0 0
# 8 5 3
# outputCopy
# YES
# NO
# YES
# NO
# YES
# Note
# For the first test case, by choosing the digits 8
#  and 2
#  we can obtain a sum of 8+2=10
#  which satisfies the condition, thus the output should be "YES".
#
# For the second test case, any combination of chosen digits won't be at least 10
# , thus the output should be "NO" (note that we can not choose the digit on the same position twice).
#
# For the third test case, any combination of chosen digits will have a sum equal to 18
# , thus the output should be "YES".
import sys


def solution(t: int) -> None:
    for _ in range(t):
        a, b, c = map(int, sys.stdin.readline().rstrip().split())
        print(['NO', 'YES'][(a + b >= 10) or (b + c >= 10) or (a + c >= 10)])


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)

# A. Black Square
# A. Black Square
# time limit per test1 second
# memory limit per test256 megabytes
# Quite recently, a very smart student named Jury decided that lectures are boring, so he downloaded a game called "Black Square" on his super cool touchscreen phone.
#
# In this game, the phone's screen is divided into four vertical strips. Each second, a black square appears on some of the strips. According to the rules of the game, Jury must use this second to touch the corresponding strip to make the square go away. As Jury is both smart and lazy, he counted that he wastes exactly ai calories on touching the i-th strip.
#
# You've got a string s, describing the process of the game and numbers a1, a2, a3, a4. Calculate how many calories Jury needs to destroy all the squares?
#
# Input
# The first line contains four space-separated integers a1, a2, a3, a4 (0 ≤ a1, a2, a3, a4 ≤ 104).
#
# The second line contains string s (1 ≤ |s| ≤ 105), where the і-th character of the string equals "1", if on the i-th second of the game the square appears on the first strip, "2", if it appears on the second strip, "3", if it appears on the third strip, "4", if it appears on the fourth strip.
#
# Output
# Print a single integer — the total number of calories that Jury wastes.
#
# Examples
# inputCopy
# 1 2 3 4
# 123214
# outputCopy
# 13
# inputCopy
# 1 5 3 2
# 11221
# outputCopy
# 13
import sys


def solution(a: str, b: str, c: str, d: str, game: str) -> str:
    cost: list = [int(a), int(b), int(c), int(d)]
    wasted: int = 0
    idx: int = 0
    while idx < len(game):
        wasted += cost[int(game[idx]) - 1]
        idx += 1
    return str(wasted)


if __name__ == '__main__':
    a, b, c, d = sys.stdin.readline().rstrip().split()
    game: str = sys.stdin.readline().rstrip()
    sys.stdout.write(solution(a, b, c, d, game))

# 1367. Linked List in Binary Tree
# Given a binary tree root and a linked list with head as the first node.
#
# Return True if all the elements in the linked list starting from the head correspond to some downward path connected in the binary tree otherwise return False.
#
# In this context downward path means a path that starts at some node and goes downwards.
#
#
#
# Example 1:
#
#
#
# Input: head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
# Output: true
# Explanation: Nodes in blue form a subpath in the binary Tree.
# Example 2:
#
#
#
# Input: head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
# Output: true
# Example 3:
#
# Input: head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
# Output: false
# Explanation: There is no path in the binary tree that contains all the elements of the linked list from head.
#
#
# Constraints:
#
# The number of nodes in the tree will be in the range [1, 2500].
# The number of nodes in the list will be in the range [1, 100].
# 1 <= Node.val <= 100 for each node in the linked list and binary tree.
# Solution Depth-First-Search, Two Pointers(for second simplify solution)
# Python O(N*M) where N is length of Tree and M is length of Linked list
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def dfs_path_checker(self, root: Optional[TreeNode], tmp: Optional[ListNode]) -> bool:
        if not root: return False
        if root.val == tmp.val:
            tmp: Optional[ListNode] = tmp.next
            if not tmp: return True
            return self.dfs_path_checker(root.left, tmp) or self.dfs_path_checker(root.right, tmp)
        return False

    def dfs(self, root: Optional[TreeNode], head: Optional[ListNode]) -> bool:
        if not root: return False
        if root.val == head.val:
            tmp: Optinal[ListNode] = head
            result: bool = self.dfs_path_checker(root, tmp)
            if result: return True
        return self.dfs(root.left, head) or self.dfs(root.right, head)

    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:
        return self.dfs(root, head)
# C++ O(N*M)
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool pathChecker(TreeNode* root, ListNode* tmp) {
        if (not root) {
            return false;
        } else if (root->val == tmp->val) {
            tmp = tmp->next;
            if (not tmp) {
                return true;
            } else {
                return pathChecker(root->left, tmp) || pathChecker(root->right, tmp);
            }
        } else {
            return false;
        }
    };
    bool dfs(TreeNode* root, ListNode* tmp) {
        if (not root) {
            return false;
        } else if (root->val == tmp->val) {
            bool result = pathChecker(root, tmp);
            if (result) {
                return true;
            }
        }
        return dfs(root->left, tmp) || dfs(root->right, tmp);
    };

    bool isSubPath(ListNode* head, TreeNode* root) {
        return dfs(root, head);
    };
};

# Python simplify solution O(N*M) with Two Pointers
class Solution:
    def dfs(self, root: Optional[TreeNode], tmp: Optional[ListNode], head: Optional[TreeNode]) -> bool:
        if not tmp: return True
        if not root: return False

        if root.val == tmp.val:
            tmp = tmp.next
        elif root.val == head.val:
            head = head.next
        else:
            tmp = head
        return self.dfs(root.left, tmp, head) or self.dfs(root.right, tmp, head)

    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:
        return self.dfs(root, head, head)
# C++ simplify solution O(N*M)
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool dfs(TreeNode* root, ListNode* tmp, ListNode* head) {
        if (not tmp) {
            return true;
        }
        if (not root) {
            return false;
        }
        if (root->val == tmp->val) {
            tmp = tmp->next;
        } else if (root->val == head->val) {
            head = head->next;
        } else {
            tmp = head;
        }
        return dfs(root->left, tmp, head) || dfs(root->right, tmp, head);
    };

    bool isSubPath(ListNode* head, TreeNode* root) {
        return dfs(root, head, head);
    };
};

# C. K-th Not Divisible by n
# C. K-th Not Divisible by n
# time limit per test1 second
# memory limit per test256 megabytes
# You are given two positive integers n
#  and k
# . Print the k
# -th positive integer that is not divisible by n
# .
#
# For example, if n=3
# , and k=7
# , then all numbers that are not divisible by 3
#  are: 1,2,4,5,7,8,10,11,13…
# . The 7
# -th number among them is 10
# .
#
# Input
# The first line contains an integer t
#  (1≤t≤1000
# ) — the number of test cases in the input. Next, t
#  test cases are given, one per line.
#
# Each test case is two positive integers n
#  (2≤n≤109
# ) and k
#  (1≤k≤109
# ).
#
# Output
# For each test case print the k
# -th positive integer that is not divisible by n
# .
#
# Example
# inputCopy
# 6
# 3 7
# 4 12
# 2 1000000000
# 7 97
# 1000000000 1000000000
# 2 1
# outputCopy
# 10
# 15
# 1999999999
# 113
# 1000000001
# 1
# Python O(log(K * K)) O(1) Math
import sys


def binary_search(n: int, target: int) -> str:
    left: int = 0
    right: int = target * n
    while left <= right:
        middle: int = left + (right - left) // 2
        not_divisible: int = middle - middle // n
        if not_divisible > target:
            right = middle - 1
        elif not_divisible < target:
            left = middle + 1
        else: return str(middle) if middle % n != 0 else str(middle - 1)


def solution(t: int) -> None:
    for _ in range(t):
        n, k = map(int, sys.stdin.readline().rstrip().split())
        sys.stdout.write(binary_search(n, k) + '\n')


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)

# C++ O(log(K * K)) O(1) Math
#include <iostream>


long long binary_search(long long n, long long k) {
    long long left = 0;
    long long right = n * k;
    while (left <= right) {
        long long middle = left + (right - left) / 2;
        long long not_divisible = middle - middle / n;
        if (not_divisible > k) {
            right = middle - 1;
        } else if (not_divisible < k) {
            left = middle + 1;
        } else {
            if (middle % n == 0) {
                return middle - 1;
            } else {
                return middle;
            }
        }
    }
};


int main() {
    int t;
    std::cin >> t;
    for (int i = 0; i < t; i++) {
        long long n, k;
        std::cin >> n >> k;
        std::cout << binary_search(n, k) << std::endl;
    }
    return 0;
};

# Squared Spiral #2
# Squared Spiral #2
# Squared Spiral #2
# Given the coordinates (x,y) of a number on a square spiral, find out what is it's index in the sequence, like the drawings bellow.
#
# Coordinates
#          ...  ←  1,2  ←  2,2
#                           ↑
#                           ↑
#                           ↑
# -1,1  ←  0,1  ←  1,1     2,1
#   ↓               ↑       ↑
#   ↓               ↑       ↑
#   ↓               ↑       ↑
# -1,0     0,0  →  1,0     2,0
#   ↓                       ↑
#   ↓                       ↑
#   ↓                       ↑
# -1,-1 →  0,-1 →  1,-1 →  2,-1
# Numbers
#          ...  ←  013  ←  012
#                           ↑
#                           ↑
#                           ↑
#  004  ←  003  ←  002     011
#   ↓               ↑       ↑
#   ↓               ↑       ↑
#   ↓               ↑       ↑
#  005     000  →  001     010
#   ↓                       ↑
#   ↓                       ↑
#   ↓                       ↑
#  006  →  007  →  008  →  009
# The spiral starts at 0 which is located at coordinates (0,0), number 1 is at (1,0), number 2 is at (1,1), number 3 is at (0,1) and so on. The spiral always starts to the right and goes in an anti-clockwise direction.
#
# 100 fixed tests and another 500 random tests are performed with coordinates ranging from (-100,-100) to (100,100).
#
# GEOMETRYPUZZLES
# Python
def squared_spiral(x, y):
    cur_x = cur_y = number = 0
    if cur_x == x and cur_y == y: return number
    right: bool = True
    up = left = down = False
    step: int = 0
    while True:
        if right:
            right, up = False, True
            step += 1
            for move in range(step):
                cur_x += 1
                number += 1
                if cur_x == x and cur_y == y:
                    return number
        elif up:
            up, left = False, True
            for move in range(step):
                cur_y += 1
                number += 1
                if cur_x == x and cur_y == y:
                    return number
        elif left:
            left, down = False, True
            step += 1
            for move in range(step):
                cur_x -= 1
                number += 1
                if cur_x == x and cur_y == y:
                    return number
        else:
            down, right = False, True
            for move in range(step):
                cur_y -= 1
                number += 1
                if cur_x == x and cur_y == y:
                    return number

# C++
int squaredSpiral(int x, int y)
{
  int cur_x, cur_y, number;
  cur_x = cur_y = number = 0;
  if (cur_x == x && cur_y == y) {
    return number;
  }
  bool right, up, left, down;
  right = true;
  up = left = down = false;
  int step = 0;
  while (true) {
   if (right) {
     right = false;
     up = true;
     step += 1;
     for (int move = 0; move < step; move++) {
       cur_x += 1;
       number += 1;
       if (cur_x == x && cur_y == y) {
         return number;
       }
     }
   } else if (up) {
     up = false;
     left = true;
     for (int move = 0; move < step; move++) {
       cur_y += 1;
       number += 1;
       if (cur_x == x && cur_y == y) {
         return number;
       }
     }
   } else if (left) {
     left = false;
     down = true;
     step += 1;
     for (int move = 0; move < step; move++) {
       cur_x -= 1;
       number += 1;
       if (cur_x == x && cur_y == y) {
         return number;
       }
     }
   } else {
     down = false;
     right = true;
     for (int move = 0; move < step; move++) {
       cur_y -= 1;
       number += 1;
       if (cur_x == x && cur_y == y) {
         return number;
       }
     }
   }
  }
}

# 725. Split Linked List in Parts
# Given the head of a singly linked list and an integer k, split the linked list into k consecutive linked list parts.
#
# The length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null.
#
# The parts should be in the order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal to parts occurring later.
#
# Return an array of the k parts.
#
#
#
# Example 1:
#
#
# Input: head = [1,2,3], k = 5
# Output: [[1],[2],[3],[],[]]
# Explanation:
# The first element output[0] has output[0].val = 1, output[0].next = null.
# The last element output[4] is null, but its string representation as a ListNode is [].
# Example 2:
#
#
# Input: head = [1,2,3,4,5,6,7,8,9,10], k = 3
# Output: [[1,2,3,4],[5,6,7],[8,9,10]]
# Explanation:
# The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.
#
#
# Constraints:
#
# The number of nodes in the list is in the range [0, 1000].
# 0 <= Node.val <= 1000
# 1 <= k <= 50
# Solution
# Python O(N) O(K), where K is length of parts of linked list
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:
        n: int = 0
        tmp: Optional[ListNode] = head
        while tmp:
            n += 1
            tmp = tmp.next
        part_length: int = n // k - 1
        additional: int = [0, n % k][n > k and n % k != 0]
        linked_list_parts: list[Optional[ListNode]] = []
        for _ in range(k):
            if not head:
                linked_list_parts.append(head)
            else:
                tmp_head: Optional[ListNode] = head
                tmp: Optional[ListNode] = tmp_head
                for _ in range(part_length + int(additional > 0)):
                    tmp = tmp.next
                head = tmp.next
                tmp.next = None
                linked_list_parts.append(tmp_head)
                additional -= 1

        return linked_list_parts

# C++ O(N) O(K), where K is length of parts of linked list
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    vector<ListNode*> splitListToParts(ListNode* head, int k) {
        int n = 0;
        ListNode* tmp = head;
        while (tmp) {
            n += 1;
            tmp = tmp->next;
        }
        int part_length = n / k - 1;
        int remainder = 0;
        if (n % k != 0) {
            remainder += n % k;
        }
        vector<ListNode*> linked_list_parts;
        for (int i = 0; i < k; i++) {
            if (head) {
                ListNode* tmp_head = head;
                ListNode* tmp = tmp_head;
                for (int move = 0; move < part_length + (remainder > 0); move++) {
                    tmp = tmp->next;
                }
                head = tmp->next;
                tmp->next = nullptr;
                linked_list_parts.push_back(tmp_head);
                remainder -= 1;
            } else {
                linked_list_parts.push_back(head);
            }
        }
        return linked_list_parts;
    }
};

# A. Required Remainder
# A. Required Remainder
# time limit per test1 second
# memory limit per test256 megabytes
# You are given three integers x,y
#  and n
# . Your task is to find the maximum integer k
#  such that 0≤k≤n
#  that kmodx=y
# , where mod
#  is modulo operation. Many programming languages use percent operator % to implement it.
#
# In other words, with given x,y
#  and n
#  you need to find the maximum possible integer from 0
#  to n
#  that has the remainder y
#  modulo x
# .
#
# You have to answer t
#  independent test cases. It is guaranteed that such k
#  exists for each test case.
#
# Input
# The first line of the input contains one integer t
#  (1≤t≤5⋅104
# ) — the number of test cases. The next t
#  lines contain test cases.
#
# The only line of the test case contains three integers x,y
#  and n
#  (2≤x≤109; 0≤y<x; y≤n≤109
# ).
#
# It can be shown that such k
#  always exists under the given constraints.
#
# Output
# For each test case, print the answer — maximum non-negative integer k
#  such that 0≤k≤n
#  and kmodx=y
# . It is guaranteed that the answer always exists.
#
# Example
# inputCopy
# 7
# 7 5 12345
# 5 0 4
# 10 5 15
# 17 8 54321
# 499999993 9 1000000000
# 10 5 187
# 2 0 999999999
# outputCopy
# 12339
# 0
# 15
# 54306
# 999999995
# 185
# 999999998
# Note
# In the first test case of the example, the answer is 12339=7⋅1762+5
#  (thus, 12339mod7=5
# ). It is obvious that there is no greater integer not exceeding 12345
#  which has the remainder 5
#  modulo 7
# .
# Python O(1) O(1) Math
import sys


def solution(t: int) -> None:
    for _ in range(t):
        x, y, n = map(int, sys.stdin.readline().rstrip().split())
        m: int = (n - y) // x
        sys.stdout.write(str(m * x + y) + '\n')


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)
# C++ O(1) O(1) Math
#include <iostream>

int main() {
    int t;
    std::cin >> t;
    for (int i = 0; i < t; i++) {
        int x, y, n;
        std::cin >> x >> y >> n;
        std::cout << (n - y) / x * x + y << std::endl;
    }
};

# Pareto front
# Introduction
# Suppose you want to buy a train ticket. You want to minimize both the ticket cost and the travel time. 3 tickets are for sale:
#
# Ticket	Travel Time	Price
# A	2h00	50$
# B	1h20	75$
# C	2h30	100$
# It is difficult to compare tickets A and B, because there is a tradeoff between them: one is cheaper, and the other is faster.
#
# However, it is clear that both of them are better than C, because C is both slower and more expensive than either of them. It is said that C is Pareto-dominated by A and B, while Aand B are Pareto-efficient or Pareto-optimal.
#
# The set of all Pareto-optimums is called the Pareto front.
#
#
# On this graph, the axes f1 and f2 respectively represent the travel time and cost. The red line joins all the points in the Pareto front, which comprises A, B, and the dark blue squares. C and the light blue squares are the Pareto-dominated points.
#
# Task
# Your function takes as input a list of tuples. A tuple represents the characteristics of an object or situation (e.g. train tickets). You want to minimize every one of these characteristics. You have to return the Pareto front of the input, as a set of tuples.
#
# Examples
# [ (120, 50), (80, 75), (150, 100) ] -> { (120, 50), (80, 75) }
# This is the example with the train tickets, with the time expressed in minutes.
# [ (1, 2, 3), (1, 3, 2), (1, 5, 2), (2, 3, 3), (0, 7, 7) ] -> { (1, 2, 3), (1, 3, 2), (0, 7, 7) }
#
# * (1, 5, 2) and (2, 3, 3) are dominated by (1, 3, 2) and (1, 2, 3)
# * (0, 7, 7) is not dominated by any point because it has the smallest x
# * (1, 2, 3) and (1, 3, 2) are in a tradeoff; neither dominates the other
# [ (1), (4), (9), (1) ] -> { (1) }
# In 1D, the Pareto Optimum is the smallest element.
# ALGORITHMSMATHEMATICSMATRIXTUTORIALS
def pareto_front(points):
    def dominates(point1, point2):
        """ Return True if point1 dominates point2 """
        return all(x <= y for x, y in zip(point1, point2)) and any(x < y for x, y in zip(point1, point2))

    pareto_set = set()
    for point in points:
        is_dominated = False
        dominated_points = set()
        for other in pareto_set:
            if dominates(other, point):
                is_dominated = True
                break
            elif dominates(point, other):
                dominated_points.add(other)
        if not is_dominated:
            pareto_set -= dominated_points
            pareto_set.add(point)
    return pareto_set

# 3280. Convert Date to Binary
# You are given a string date representing a Gregorian calendar date in the yyyy-mm-dd format.
#
# date can be written in its binary representation obtained by converting year, month, and day to their binary representations without any leading zeroes and writing them down in year-month-day format.
#
# Return the binary representation of date.
#
#
#
# Example 1:
#
# Input: date = "2080-02-29"
#
# Output: "100000100000-10-11101"
#
# Explanation:
#
# 100000100000, 10, and 11101 are the binary representations of 2080, 02, and 29 respectively.
#
# Example 2:
#
# Input: date = "1900-01-01"
#
# Output: "11101101100-1-1"
#
# Explanation:
#
# 11101101100, 1, and 1 are the binary representations of 1900, 1, and 1 respectively.
#
#
#
# Constraints:
#
# date.length == 10
# date[4] == date[7] == '-', and all other date[i]'s are digits.
# The input is generated such that date represents a valid Gregorian calendar date between Jan 1st, 1900 and Dec 31st, 2100 (both inclusive).
class Solution:
    def convertDateToBinary(self, date: str) -> str:
        return '-'.join(bin(int(i))[2:] for i in date.split('-'))

# 3281. Maximize Score of Numbers in Ranges
# You are given an array of integers start and an integer d, representing n intervals [start[i], start[i] + d].
#
# You are asked to choose n integers where the ith integer must belong to the ith interval. The score of the chosen integers is defined as the minimum absolute difference between any two integers that have been chosen.
#
# Return the maximum possible score of the chosen integers.
#
#
#
# Example 1:
#
# Input: start = [6,0,3], d = 2
#
# Output: 4
#
# Explanation:
#
# The maximum possible score can be obtained by choosing integers: 8, 0, and 4. The score of these chosen integers is min(|8 - 0|, |8 - 4|, |0 - 4|) which equals 4.
#
# Example 2:
#
# Input: start = [2,6,13,13], d = 5
#
# Output: 5
#
# Explanation:
#
# The maximum possible score can be obtained by choosing integers: 2, 7, 13, and 18. The score of these chosen integers is min(|2 - 7|, |2 - 13|, |2 - 18|, |7 - 13|, |7 - 18|, |13 - 18|) which equals 5.
#
#
#
# Constraints:
#
# 2 <= start.length <= 105
# 0 <= start[i] <= 109
# 0 <= d <= 109
class Solution:
    def maxPossibleScore(self, start: List[int], d: int) -> int:
        def can_achieve(middle: int) -> bool:
            prev: int = start[0]
            for i in range(1, len(start)):
                next_val: int = max(prev + middle, start[i])
                if next_val > start[i] + d: return False
                prev = next_val
            return True
        start.sort()
        left, right = 0, (max(start) - min(start)) + d
        best: int = 0
        while left <= right:
            middle: int = left + (right - left) // 2
            if can_achieve(middle):
                best = middle
                left = middle + 1
            else:
                right = middle - 1
        return best

# 3282. Reach End of Array With Max Score
# You are given an integer array nums of length n.
#
# Your goal is to start at index 0 and reach index n - 1. You can only jump to indices greater than your current index.
#
# The score for a jump from index i to index j is calculated as (j - i) * nums[i].
#
# Return the maximum possible total score by the time you reach the last index.
#
#
#
# Example 1:
#
# Input: nums = [1,3,1,5]
#
# Output: 7
#
# Explanation:
#
# First, jump to index 1 and then jump to the last index. The final score is 1 * 1 + 2 * 3 = 7.
#
# Example 2:
#
# Input: nums = [4,3,1,3,2]
#
# Output: 16
#
# Explanation:
#
# Jump directly to the last index. The final score is 4 * 4 = 16.
#
#
#
# Constraints:
#
# 1 <= nums.length <= 105
# 1 <= nums[i] <= 105
# Python O(N) O(1) Dynamic Programming
class Solution:
    def findMaximumScore(self, nums: List[int]) -> int:
        n: int = len(nums)
        j: int = n - 1
        cur_max_number: int = 0
        steps_after_max_number: int = 0
        previous_best: int = 0
        max_score: int = 0
        for i in range(len(nums)):
            steps_after_max_number += 1
            if nums[i] <= cur_max_number: continue
            currrent_score: int = nums[i] * (j - i)
            previous_best += cur_max_number * steps_after_max_number
            max_score = max(max_score, currrent_score + previous_best)
            cur_max_number, steps_after_max_number = nums[i], 0
        return max_score

# C++ O(N) O(1) Dynamic Programming
class Solution {
public:
    long long findMaximumScore(vector<int>& nums) {
        long long n, j, cur_max_number, previous_best, steps_after_max_number;
        n = nums.size();
        j = n - 1;
        cur_max_number = 0;
        previous_best = 0;
        steps_after_max_number = 0;
        long long max_score = 0;
        for (int i = 0; i < n; i++) {
            steps_after_max_number += 1;
            if (nums[i] <= cur_max_number) {
                continue;
            }
            long long current_cost = (j - i) * nums[i];
            previous_best += cur_max_number * steps_after_max_number;
            max_score = std::max(max_score, current_cost + previous_best);
            cur_max_number = nums[i];
            steps_after_max_number = 0;
        }
        return max_score;
    }
};

# 2326. Spiral Matrix IV
# You are given two integers m and n, which represent the dimensions of a matrix.
#
# You are also given the head of a linked list of integers.
#
# Generate an m x n matrix that contains the integers in the linked list presented in spiral order (clockwise), starting from the top-left of the matrix. If there are remaining empty spaces, fill them with -1.
#
# Return the generated matrix.
#
#
#
# Example 1:
#
#
# Input: m = 3, n = 5, head = [3,0,2,6,8,1,7,9,4,2,5,5,0]
# Output: [[3,0,2,6,8],[5,0,-1,-1,1],[5,2,4,9,7]]
# Explanation: The diagram above shows how the values are printed in the matrix.
# Note that the remaining spaces in the matrix are filled with -1.
# Example 2:
#
#
# Input: m = 1, n = 4, head = [0,1,2]
# Output: [[0,1,2,-1]]
# Explanation: The diagram above shows how the values are printed from left to right in the matrix.
# The last space in the matrix is set to -1.
#
#
# Constraints:
#
# 1 <= m, n <= 105
# 1 <= m * n <= 105
# The number of nodes in the list is in the range [1, m * n].
# 0 <= Node.val <= 1000
# Python O(MN) O(MN)
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:
        mtrx: list[list[int]] = [[-1] * n for _ in range(m)]
        right: bool = True
        down = left = up = False
        start_row = start_col = 0
        while head:
            if right:
                right, down = False, True
                for i in range(n):
                    if head:
                        mtrx[start_row][start_col] = head.val
                        head = head.next
                    else: return mtrx
                    start_col += 1
                start_col -= 1
                start_row += 1
            elif down:
                down, left = False, True
                m -= 1
                for i in range(m):
                    if head:
                        mtrx[start_row][start_col] = head.val
                        head = head.next
                    else: return mtrx
                    start_row += 1
                start_row -= 1
                start_col -= 1
            elif left:
                left, up = False, True
                n -= 1
                for i in range(n):
                    if head:
                        mtrx[start_row][start_col] = head.val
                        head = head.next
                    else: return mtrx
                    start_col -= 1
                start_col += 1
                start_row -= 1
            else:
                up, right = False, True
                m -= 1
                n -= 1
                for i in range(m):
                    if head:
                        mtrx[start_row][start_col] = head.val
                        head = head.next
                    else: return mtrx
                    start_row -= 1
                start_row += 1
                start_col += 1
        return mtrx

# C++ O(MN) O(MN)
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {
        std::vector<std::vector<int>> mtrx(m, std::vector<int>(n, -1));
        int start_row = 0, start_col = 0;
        bool right, down, left, up;
        right = true;
        down = left = up = false;
        while (head) {
            if (right) {
                right = false;
                down = true;
                for (int move = 0; move < n; move++) {
                    if (head){
                        mtrx[start_row][start_col] = head->val;
                        head = head->next;
                    } else {
                        return mtrx;
                    }
                    start_col += 1;
                }
                start_col -= 1;
                start_row += 1;
            } else if (down) {
                down = false;
                left = true;
                m -= 1;
                for (int move = 0; move < m; move++) {
                    if (head) {
                        mtrx[start_row][start_col] = head->val;
                        head = head->next;
                    } else {
                        return mtrx;
                    }
                    start_row += 1;
                }
                start_row -= 1;
                start_col -= 1;
            } else if (left) {
                left = false;
                up = true;
                n -= 1;
                for (int move = 0; move < n; move++) {
                    if (head) {
                        mtrx[start_row][start_col] = head->val;
                        head = head->next;
                    } else {
                        return mtrx;
                    }
                    start_col -= 1;
                }
                start_col += 1;
                start_row -= 1;
            } else {
                up = false;
                right = true;
                m -= 1;
                n -= 1;
                for (int move = 0; move < m; move++) {
                    if (head) {
                        mtrx[start_row][start_col] = head->val;
                        head = head->next;
                    } else {
                        return mtrx;
                    }
                    start_row -= 1;
                }
                start_row += 1;
                start_col += 1;
            }
        }
        return mtrx;
    }
};

# B. Even Array
# B. Even Array
# time limit per test2 seconds
# memory limit per test256 megabytes
# You are given an array a[0…n−1]
#  of length n
#  which consists of non-negative integers. Note that array indices start from zero.
#
# An array is called good if the parity of each index matches the parity of the element at that index. More formally, an array is good if for all i
#  (0≤i≤n−1
# ) the equality imod2=a[i]mod2
#  holds, where xmod2
#  is the remainder of dividing x
#  by 2.
#
# For example, the arrays [0,5,2,1
# ] and [0,17,0,3
# ] are good, and the array [2,4,6,7
# ] is bad, because for i=1
# , the parities of i
#  and a[i]
#  are different: imod2=1mod2=1
# , but a[i]mod2=4mod2=0
# .
#
# In one move, you can take any two elements of the array and swap them (these elements are not necessarily adjacent).
#
# Find the minimum number of moves in which you can make the array a
#  good, or say that this is not possible.
#
# Input
# The first line contains a single integer t
#  (1≤t≤1000
# ) — the number of test cases in the test. Then t
#  test cases follow.
#
# Each test case starts with a line containing an integer n
#  (1≤n≤40
# ) — the length of the array a
# .
#
# The next line contains n
#  integers a0,a1,…,an−1
#  (0≤ai≤1000
# ) — the initial array.
#
# Output
# For each test case, output a single integer — the minimum number of moves to make the given array a
#  good, or -1 if this is not possible.
#
# Example
# inputCopy
# 4
# 4
# 3 2 7 6
# 3
# 3 2 6
# 1
# 7
# 7
# 4 9 2 1 18 3 0
# outputCopy
# 2
# 1
# -1
# 0
# Note
# In the first test case, in the first move, you can swap the elements with indices 0
#  and 1
# , and in the second move, you can swap the elements with indices 2
#  and 3
# .
#
# In the second test case, in the first move, you need to swap the elements with indices 0
#  and 1
# .
#
# In the third test case, you cannot make the array good.
import sys

def solution(t:int) -> None:
    for _ in range(t):
        n: int = int(sys.stdin.readline().rstrip())
        arr: list = list(map(int, sys.stdin.readline().rstrip().split()))
        ind: int = sum(i % 2 for i in range(n))
        arr_ind: dict = sum(i % 2 for i in arr)
        if ind == arr_ind:
            sys.stdout.write(str(sum(i % 2 != arr[i] % 2 for i in range(n)) // 2) + '\n')
        else:
            sys.stdout.write('-1' + '\n')


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)

# Sports League Table Ranking
# Note: There is a harder version (Sports League Table Ranking (with Head-to-head)) of this.
#
# Description
# You organize a sports league in a round-robin-system. Each team meets all other teams. In your league a win gives a team 2 points, a draw gives both teams 1 point. After some games you have to compute the order of the teams in your league. You use the following criteria to arrange the teams:
#
# Points
# Scoring differential (the difference between goals scored and those conceded)
# Goals scored
# First you sort the teams by their points. If two or more teams reached the same number of points, the second criteria comes into play and so on. Finally, if all criteria are the same, the teams share a place.
#
# Input
# number: Number of teams in your league.
# games: An array of arrays. Each item represents a played game with an array of four elements [TeamA,TeamB,GoalA,GoalB] (TeamA played against TeamB and scored GoalA goals and conceded GoalB goals ).
# Output
# positions: An array of positions. The i-th item should be the position of the i-th team in your league.
# Example
# number = 6
# games = [[0, 5, 2, 2],   // Team 0 - Team 5 => 2:2
#          [1, 4, 0, 2],   // Team 1 - Team 4 => 0:2
#          [2, 3, 1, 2],   // Team 2 - Team 3 => 1:2
#          [1, 5, 2, 2],   // Team 1 - Team 5 => 2:2
#          [2, 0, 1, 1],   // Team 2 - Team 0 => 1:1
#          [3, 4, 1, 1],   // Team 3 - Team 4 => 1:1
#          [2, 5, 0, 2],   // Team 2 - Team 5 => 0:2
#          [3, 1, 1, 1],   // Team 3 - Team 1 => 1:1
#          [4, 0, 2, 0]]   // Team 4 - Team 0 => 2:0
# You may compute the following table:
#
# Rank	Team	For : Against	GD	Points
# 1.	Team 4	5 : 1	+4	5
# 2.	Team 5	6 : 4	+2	4
# 3.	Team 3	4 : 3	+1	4
# 4.	Team 0	3 : 5	-2	2
# 4.	Team 1	3 : 5	-2	2
# 6.	Team 2	2 : 5	-3	1
# Team 5 and Team 3 reached the same number of points. But since Team 5 got a better scoring differential, it ranks better than Team 3. All values of Team 0 and Team 1 are the same, so these teams share the fourth place.
#
# In this example you have to return the array [4, 4, 6, 3, 1, 2].
#
# FUNDAMENTALSALGORITHMSARRAYSSORTING
def compute_ranks(number, games):
    storage: dict[int, list[int, int, int]] = dict()
    for team in range(number):
        storage[team] = [0, 0, 0]
    for game in games:
        com1, com2, gol1, gol2 = game
        com1_stats: list[int, int, int] = storage.get(com1, None)
        com1_stats[0] += 2 if gol1 > gol2 else 1 if gol1 == gol2 else 0
        com1_stats[1] += gol1 - gol2
        com1_stats[2] += gol1
        storage[com1] = com1_stats
        com2_stats: list[int, int, int] = storage.get(com2, None)
        com2_stats[0] += 2 if gol2 > gol1 else 1 if gol2 == gol1 else 0
        com2_stats[1] += gol2 - gol1
        com2_stats[2] += gol2
        storage[com2] = com2_stats
    scores: list[tuple[int, int, int]] = list({tuple(com) for com in storage.values()})
    scores.sort(reverse=True)
    output: list[int] = [scores.index(tuple(storage[team])) + 1 for team in storage.keys()]
    addition: int = 0
    move: bool = False
    rank: int = 1
    for _ in range(len(scores)):
        quantity: int = output.count(rank)
        move = quantity > 1
        if move:
            addition = quantity - 1
            rank += 1
            for team in range(number):
                if output[team] >= rank:
                    output[team] += addition
            rank += addition
        else: rank += 1
    return output

# 2807. Insert Greatest Common Divisors in Linked List
# Given the head of a linked list head, in which each node contains an integer value.
#
# Between every pair of adjacent nodes, insert a new node with a value equal to the greatest common divisor of them.
#
# Return the linked list after insertion.
#
# The greatest common divisor of two numbers is the largest positive integer that evenly divides both numbers.
#
#
#
# Example 1:
#
#
# Input: head = [18,6,10,3]
# Output: [18,6,6,2,10,1,3]
# Explanation: The 1st diagram denotes the initial linked list and the 2nd diagram denotes the linked list after inserting the new nodes (nodes in blue are the inserted nodes).
# - We insert the greatest common divisor of 18 and 6 = 6 between the 1st and the 2nd nodes.
# - We insert the greatest common divisor of 6 and 10 = 2 between the 2nd and the 3rd nodes.
# - We insert the greatest common divisor of 10 and 3 = 1 between the 3rd and the 4th nodes.
# There are no more adjacent nodes, so we return the linked list.
# Example 2:
#
#
# Input: head = [7]
# Output: [7]
# Explanation: The 1st diagram denotes the initial linked list and the 2nd diagram denotes the linked list after inserting the new nodes.
# There are no pairs of adjacent nodes, so we return the initial linked list.
#
#
# Constraints:
#
# The number of nodes in the list is in the range [1, 5000].
# 1 <= Node.val <= 1000
# Python O(NlogMin(x,y)) O(N)
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def gcd(self, x: int, y: int) -> int:
        if x == 0:
            return y
        return gcd(y % x, x)

    def insertGreatestCommonDivisors(self, head: Optional[ListNode]) -> Optional[ListNode]:
        tmp: Optional[ListNode] = head
        while tmp and tmp.next:
            x: int = tmp.val
            y: int = tmp.next.val
            gcd_x_y: int = self.gcd(x, y)
            tmp.next = ListNode(val=gcd_x_y, next=tmp.next)
            tmp = tmp.next.next
        return head

# C++ O(NlogMin(x,y)) O(N)
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    int gcd(int x, int y) {
        if (x == 0) {
            return y;
        }
        return gcd(y % x, x);
    };

    ListNode* insertGreatestCommonDivisors(ListNode* head) {
        ListNode* tmp = head;
        while (tmp && tmp->next) {
            int x = tmp->val;
            int y = tmp->next->val;
            ListNode* gcd_node = new ListNode(gcd(x, y), tmp->next);
            tmp->next = gcd_node;
            tmp = tmp->next->next;
        }
        return head;
    };
};

# A. Short Sort
# A. Short Sort
# time limit per test1 second
# memory limit per test256 megabytes
# There are three cards with letters a
# , b
# , c
#  placed in a row in some order. You can do the following operation at most once:
#
# Pick two cards, and swap them.
# Is it possible that the row becomes abc
#  after the operation? Output "YES" if it is possible, and "NO" otherwise.
# Input
# The first line contains a single integer t
#  (1≤t≤6
# ) — the number of test cases.
#
# The only line of each test case contains a single string consisting of each of the three characters a
# , b
# , and c
#  exactly once, representing the cards.
#
# Output
# For each test case, output "YES" if you can make the row abc
#  with at most one operation, or "NO" otherwise.
#
# You can output the answer in any case (for example, the strings "yEs", "yes", "Yes" and "YES" will be recognized as a positive answer).
#
# Example
# inputCopy
# 6
# abc
# acb
# bac
# bca
# cab
# cba
# outputCopy
# YES
# YES
# YES
# NO
# NO
# YES
# Note
# In the first test case, we don't need to do any operations, since the row is already abc
# .
#
# In the second test case, we can swap c
#  and b
# : acb→abc
# .
#
# In the third test case, we can swap b
#  and a
# : bac→abc
# .
#
# In the fourth test case, it is impossible to make abc
#  using at most one operation.
import sys


def solution(t: int) -> None:
    for _ in range(t):
        cards: str = sys.stdin.readline().rstrip()
        moves: int = sum(x != y for x, y in zip(cards, 'abc'))
        sys.stdout.write(str(['YES', 'NO'][moves % 2]) + '\n')


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)

# Operation Transformation
# You are given two positive integers a and b.
#
# You can perform the following operations on a so as to obtain b :
#
# (a-1)/2   (if (a-1) is divisible by 2)
# a/2       (if a is divisible by 2)
# a*2
# b will always be a power of 2.
#
# You are to write a function operation(a,b) that efficiently returns the minimum number of operations required to transform a into b.
#
# For example :
#
# operation(2,8) -> 2
# 2*2 = 4
# 4*2 = 8
#
# operation(9,2) -> 2
# (9-1)/2 = 4
# 4/2 = 2
#
# operation(1024,1024) -> 0
# FUNDAMENTALSALGORITHMS
from collections import deque

def operation(a, b):
    if a == b:return 0

    queue: list[tuple[int ,int]] = deque([(a, 0)])  # (current_value, operations_count)
    visited: list[int] = set([a])

    while queue:
        current, operations_count = queue.popleft()
        if current == b: return operations_count

        if (current - 1) % 2 == 0 and (current - 1) // 2 not in visited:
            new_value: int = (current - 1) // 2
            queue.append((new_value, operations_count + 1))
            visited.add(new_value)

        if current % 2 == 0 and current // 2 not in visited:
            new_value: int = current // 2
            queue.append((new_value, operations_count + 1))
            visited.add(new_value)

        if current * 2 not in visited:
            new_value: int = current * 2
            queue.append((new_value, operations_count + 1))
            visited.add(new_value)

    return -1

# Blind Numbers
# Nicky has had Myopia (Nearsightedness) since he was born. Because he always wears glasses, he really hates digits 00 and he loves digits 1 and 2. He calls numbers, that don't contain 00 (two consecutive zeros), the Blind Numbers. He will give you n, the digit-length of number in 10-adic system, and you need to help him to count how many numbers are there of length n, that only consist of digits 0, 1 and 2 and are not Blind Numbers.
#
# Note📝
# We include 0 in the begin of number also.
#
# The numbers will be very huge, so return the answer modulo 1000000007
#
# Example
# n = 3
#
# The answer is 22. The below list is all 27 possible numbers of length 3, with digits 0-2, and there 5 numbers that contain 00 so we not include those.
#
# [000, 001, 002, 010, 011, 012, 020, 021, 022, 100, 101, 102, 110, 111, 112, 120 121, 122, 200, 201, 202, 210 , 211, 212, 220, 221, 222]
# Constraints
# 1 ≤ n ≤ 500000
#
# MATHEMATICSFUNDAMENTALS
def blind_number(n):
    MOD = 1000000007

    dp0, dp1, dp2 = 1, 1, 1

    for i in range(2, n + 1):
        new_dp0 = (dp1 + dp2) % MOD
        new_dp1 = (dp0 + dp1 + dp2) % MOD
        new_dp2 = (dp0 + dp1 + dp2) % MOD

        dp0, dp1, dp2 = new_dp0, new_dp1, new_dp2

    return (dp0 + dp1 + dp2) % MOD

# A. Panoramix's Prediction
# A. Panoramix's Prediction
# time limit per test2 seconds
# memory limit per test256 megabytes
# A prime number is a number which has exactly two distinct divisors: one and itself. For example, numbers 2, 7, 3 are prime, and 1, 6, 4 are not.
#
# The next prime number after x is the smallest prime number greater than x. For example, the next prime number after 2 is 3, and the next prime number after 3 is 5. Note that there is exactly one next prime number after each number. So 5 is not the next prime number for 2.
#
# One cold April morning Panoramix predicted that soon Kakofonix will break free from his straitjacket, and this will be a black day for the residents of the Gallic countryside.
#
# Panoramix's prophecy tells that if some day Asterix and Obelix beat exactly x Roman soldiers, where x is a prime number, and next day they beat exactly y Roman soldiers, where y is the next prime number after x, then it's time to wait for Armageddon, for nothing can shut Kakofonix up while he sings his infernal song.
#
# Yesterday the Gauls beat n Roman soldiers and it turned out that the number n was prime! Today their victims were a troop of m Romans (m > n). Determine whether the Gauls should wait for the black day after today's victory of Asterix and Obelix?
#
# Input
# The first and only input line contains two positive integers — n and m (2 ≤ n < m ≤ 50). It is guaranteed that n is prime.
#
# Pretests contain all the cases with restrictions 2 ≤ n < m ≤ 4.
#
# Output
# Print YES, if m is the next prime number after n, or NO otherwise.
#
# Examples
# inputCopy
# 3 5
# outputCopy
# YES
# inputCopy
# 7 11
# outputCopy
# YES
# inputCopy
# 7 9
# outputCopy
# NO
# Solution
# Python O((M - N)**2) O(1)
import sys


def solution(n: int, m: int) -> str:
    for candidate in range(n + 1, m + 1):
        is_prime: bool = True
        for module in range(2, candidate - 1):
            if candidate % module == 0:
                is_prime = False
                break
        if is_prime: return ['NO', 'YES'][candidate == m]
    return 'NO'


if __name__ == '__main__':
    n, m = map(int, sys.stdin.readline().rstrip().split())
    sys.stdout.write(solution(n, m))

# C++ O((M - N) ** 2) O(1)
#include <iostream>

int main() {
    int n, m;
    std::cin >> n >> m;
    for (int candidate = n + 1; candidate <= m; ++candidate) {
        bool is_prime = true;
        for (int module = 2; module < candidate; ++module) {
            if (candidate % module == 0) {
                is_prime = false;
                break;
            }
        }
        if (is_prime) {
            std::cout << (candidate == m ? "YES" : "NO") << std::endl;
            return 0;
        }
    }
    std::cout << "NO" << std::endl;
}

# A. New Year Transportation
# A. New Year Transportation
# time limit per test2 seconds
# memory limit per test256 megabytes
# New Year is coming in Line World! In this world, there are n cells numbered by integers from 1 to n, as a 1 × n board. People live in cells. However, it was hard to move between distinct cells, because of the difficulty of escaping the cell. People wanted to meet people who live in other cells.
#
# So, user tncks0121 has made a transportation system to move between these cells, to celebrate the New Year. First, he thought of n - 1 positive integers a1, a2, ..., an - 1. For every integer i where 1 ≤ i ≤ n - 1 the condition 1 ≤ ai ≤ n - i holds. Next, he made n - 1 portals, numbered by integers from 1 to n - 1. The i-th (1 ≤ i ≤ n - 1) portal connects cell i and cell (i + ai), and one can travel from cell i to cell (i + ai) using the i-th portal. Unfortunately, one cannot use the portal backwards, which means one cannot move from cell (i + ai) to cell i using the i-th portal. It is easy to see that because of condition 1 ≤ ai ≤ n - i one can't leave the Line World using portals.
#
# Currently, I am standing at cell 1, and I want to go to cell t. However, I don't know whether it is possible to go there. Please determine whether I can go to cell t by only using the construted transportation system.
#
# Input
# The first line contains two space-separated integers n (3 ≤ n ≤ 3 × 104) and t (2 ≤ t ≤ n) — the number of cells, and the index of the cell which I want to go to.
#
# The second line contains n - 1 space-separated integers a1, a2, ..., an - 1 (1 ≤ ai ≤ n - i). It is guaranteed, that using the given transportation system, one cannot leave the Line World.
#
# Output
# If I can go to cell t using the transportation system, print "YES". Otherwise, print "NO".
#
# Examples
# inputCopy
# 8 4
# 1 2 1 2 1 2 1
# outputCopy
# YES
# inputCopy
# 8 5
# 1 2 1 2 1 1 1
# outputCopy
# NO
# Note
# In the first sample, the visited cells are: 1, 2, 4; so we can successfully visit the cell 4.
#
# In the second sample, the possible cells to visit are: 1, 2, 4, 6, 7, 8; so we can't visit the cell 5, which we want to visit.
# Python O(N) O(1)
import sys
from typing import List


def solution(n: int, t: int, cells: List[int]) -> str:
    start: int = 0
    while start + 1 < t:
        start += cells[start]
    return ['NO', 'YES'][start + 1 == t]



if __name__ == '__main__':
    n, t = map(int, sys.stdin.readline().rstrip().split())
    cells: List[int] = list(map(int, sys.stdin.readline().rstrip().split()))
    sys.stdout.write(solution(n, t, cells))
# C++ O(N) O(1)
#include <iostream>
#include <vector>

int main() {
    int n, t;
    std::cin >> n >> t;
    std::vector<int> cells;
    for (int idx = 0; idx < n; ++idx) {
        int number;
        std::cin >> number;
        cells.push_back(number);
    }
    int start = 0;
    while (start + 1 < t) {
        start += cells[start];
    }
    std::cout << (start + 1 == t? "YES" : "NO") << std::endl;
}

# Pointless Farmer
# You've harvested a fruit.
# But the Internal Raisin Service (IRS) doesn't allow you to eat your own produce, you have to launder it on the market first.
# When you visit the market, you are given three conversion offers, and for each conversion offer you must decide which direction to trade.
# A conversion offer is a pair of fruits, and to buy the second fruit for the first fruit, the action is "buy"
# The opposite direction is "sell".
#
# Given the offer ("apple", "orange"), if you have an apple, then you may buy an orange, or, if you have an orange, you may sell it for the apple.
#
# Example:
#
# pairs: [("apple", "orange"), ("orange", "pear"), ("apple", "pear")]
# harvested fruit: "apple"
#
# currently holding: apple
# ("apple", "orange")
# buy
# currently holding: orange
# ("orange", "pear")
# buy
# currently holding: pear
# ("apple", "pear")
# sell
# currently holding: apple (successfully ended up with the same fruit again)
# As input you receive three conversion offers together with your harvested fruit, and your output is a list of three actions of buy/sell, for the above example the output is: ["buy", "buy", "sell"].
# If it is not possible to end up with the original kind of fruit again after the three conversions, return "ERROR" instead of the list of actions.
#
# ALGORITHMS
def buy_or_sell(pairs, harvested_fruit):
    actions: list[str] = []
    current_fruit: str = harvested_fruit
    for deal in pairs:
        if deal[0] == current_fruit:
            actions.append('buy')
            current_fruit = deal[1]
        elif deal[1] == current_fruit:
            actions.append('sell')
            current_fruit = deal[0]
        else: return 'ERROR'
    return actions if current_fruit == harvested_fruit else 'ERROR'

# 1310. XOR Queries of a Subarray
# You are given an array arr of positive integers. You are also given the array queries where queries[i] = [lefti, righti].
#
# For each query i compute the XOR of elements from lefti to righti (that is, arr[lefti] XOR arr[lefti + 1] XOR ... XOR arr[righti] ).
#
# Return an array answer where answer[i] is the answer to the ith query.
#
#
#
# Example 1:
#
# Input: arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]]
# Output: [2,7,14,8]
# Explanation:
# The binary representation of the elements in the array are:
# 1 = 0001
# 3 = 0011
# 4 = 0100
# 8 = 1000
# The XOR values for queries are:
# [0,1] = 1 xor 3 = 2
# [1,2] = 3 xor 4 = 7
# [0,3] = 1 xor 3 xor 4 xor 8 = 14
# [3,3] = 8
# Example 2:
#
# Input: arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]]
# Output: [8,0,4,4]
#
#
# Constraints:
#
# 1 <= arr.length, queries.length <= 3 * 104
# 1 <= arr[i] <= 109
# queries[i].length == 2
# 0 <= lefti <= righti < arr.length
# Python O(N) O(N)
class Solution:
    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:
        prefix_sum: list[int] = []
        for num in arr:
            if not prefix_sum:
                prefix_sum.append(num)
            else: prefix_sum.append(num ^ prefix_sum[-1])
        output: list[int] = []
        for query in queries:
            left, right = query
            if left:
                output.append(prefix_sum[right] ^ prefix_sum[left - 1])
            else: output.append(prefix_sum[right])
        return output
# C++ O(N) O(N)
class Solution {
public:
    vector<int> xorQueries(vector<int>& arr, vector<vector<int>>& queries) {
        vector<int> prefix_sum;
        for (int num: arr) {
            if (prefix_sum.size()) {
                prefix_sum.push_back(num ^ prefix_sum[prefix_sum.size() - 1]);
            } else {
                prefix_sum.push_back(num);
            }
        }
        vector<int> output;
        for (vector<int> query : queries) {
            int left, right;
            left = query[0];
            right = query[1];
            if (left) {
                output.push_back(prefix_sum[right] ^ prefix_sum[left - 1]);
            } else {
                output.push_back(prefix_sum[right]);
            }
        }
        return output;
    }
};

# A. Raising Bacteria
# A. Raising Bacteria
# time limit per test1 second
# memory limit per test256 megabytes
# You are a lover of bacteria. You want to raise some bacteria in a box.
#
# Initially, the box is empty. Each morning, you can put any number of bacteria into the box. And each night, every bacterium in the box will split into two bacteria. You hope to see exactly x bacteria in the box at some moment.
#
# What is the minimum number of bacteria you need to put into the box across those days?
#
# Input
# The only line containing one integer x (1 ≤ x ≤ 109).
#
# Output
# The only line containing one integer: the answer.
#
# Examples
# inputCopy
# 5
# outputCopy
# 2
# inputCopy
# 8
# outputCopy
# 1
# Note
# For the first sample, we can add one bacterium in the box in the first day morning and at the third morning there will be 4 bacteria in the box. Now we put one more resulting 5 in the box. We added 2 bacteria in the process so the answer is 2.
#
# For the second sample, we can put one in the first morning and in the 4-th morning there will be 8 in the box. So the answer is 1.
import sys


def solution(n: int) -> str:
    return str(bin(n).count('1'))


if __name__ == '__main__':
    n: int = int(sys.stdin.readline().rstrip())
    sys.stdout.write(solution(n))

# Borda count
# You have to choose a collective solution using the Borda method. According to this method, the voting results are expressed in terms of the number of points scored by each of the candidates. So, in an election of n candidates, each voter ranks all candidates strictly in descending order of preference, for the first place according to preference n - 1 points are awarded to the candidate, n - 2 points for the second place, etc. (for the last place - 0 points). All points scored by each candidate are summed up. Then candidates with fewer points than the arithmetic mean are removed, and the method is repeated until there are only candidates with the same results or a candidate left.
#
# More information on Wikipedia
#
# For example there are 3 people with different preferences:
#
#   Maria:           Alexey:               Vladimir:
#       Coffee            Hot Chocolate         Coffee
#       Tea               Tea                   Hot Chocolate
#       Hot Chocolate     Coffee                Tea
#   Drink:    Score:
#   Coffee    (2 + 2 + 0) = 4
#   Tea       (1 + 1 + 0) = 2
#   Chocolate (2 + 1 + 0) = 3
#
#   Mean      (4 + 2 + 3) / 3 = 3
# So we exclude tea as 2 < 3, and the preference table takes the following form:
#
#   Maria           Alexey            Vladimir
#     Coffee          Hot Chocolate     Coffee
#     Hot Chocolate   Coffee            Hot Chocolate
# Next:
#
#   Drink:        Score:
#   Coffee        (1 + 0 + 1) = 2
#   Hot Chocolate (0 + 1 + 0) = 1
#
#   Mean           1.5
# Now we exclude hot chocolate (1 < 1.5) and we are done. Our collective solution is coffee.
#
# Input (dictionary):
#
# {'A': ['a', 'b', 'c'], 'B': ['b', 'c', 'a']}
#
# Output (set):
#
# {'a', 'b'}
#
# ALGORITHMS
def borda_count(table):
    while True:
        products: dict[str, int] = dict()
        for person in table:
            priority: int = len(table[person]) - 1
            for vote in table[person]:
                products[vote] = products.get(vote, 0) + priority
                priority -= 1
        mean: float = sum(products.values()) / len(products)
        is_change: bool = False
        for product in products:
            if products[product] < mean:
                for people in table:
                    table[people].remove(product)
                    is_change = True
        if not is_change: return products.keys()

# 2419. Longest Subarray With Maximum Bitwise AND
# You are given an integer array nums of size n.
#
# Consider a non-empty subarray from nums that has the maximum possible bitwise AND.
#
# In other words, let k be the maximum value of the bitwise AND of any subarray of nums. Then, only subarrays with a bitwise AND equal to k should be considered.
# Return the length of the longest such subarray.
#
# The bitwise AND of an array is the bitwise AND of all the numbers in it.
#
# A subarray is a contiguous sequence of elements within an array.
#
#
#
# Example 1:
#
# Input: nums = [1,2,3,3,2,2]
# Output: 2
# Explanation:
# The maximum possible bitwise AND of a subarray is 3.
# The longest subarray with that value is [3,3], so we return 2.
# Example 2:
#
# Input: nums = [1,2,3,4]
# Output: 1
# Explanation:
# The maximum possible bitwise AND of a subarray is 4.
# The longest subarray with that value is [4], so we return 1.
#
#
# Constraints:
#
# 1 <= nums.length <= 105
# 1 <= nums[i] <= 106
# Python O(N) O(1)
class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        answer: int = 1 # in constraints minimum length of "nums" is 1
        left: int = 0
        target: int = max(nums)
        for right in range(len(nums)):
            while left <= right and nums[right] != target:
                answer = max(answer, right - left)
                left += 1
            answer = max(answer, right - left + 1)
        return answer
# C++ O(N) O(1)
#include <algorithm>
class Solution {
public:
    int longestSubarray(vector<int>& nums) {
        int answer = 1; // in constraints minimum length of "nums" is 1
        int target = 0;
        for (int num : nums) {
            target = std::max(target, num);
        }
        int left = 0;
        for (int right = 0; right < nums.size(); ++right){
            while (left <= right && nums[right] != target) {
                answer = std::max(answer, right - left);
                left += 1;
            }
            answer = std::max(answer, right - left + 1);
        }
        return answer;
    }
};
# B. Fence
# B. Fence
# time limit per test1 second
# memory limit per test256 megabytes
# There is a fence in front of Polycarpus's home. The fence consists of n planks of the same width which go one after another from left to right. The height of the i-th plank is hi meters, distinct planks can have distinct heights.
#
# Fence for n = 7 and h = [1, 2, 6, 1, 1, 7, 1]
# Polycarpus has bought a posh piano and is thinking about how to get it into the house. In order to carry out his plan, he needs to take exactly k consecutive planks from the fence. Higher planks are harder to tear off the fence, so Polycarpus wants to find such k consecutive planks that the sum of their heights is minimal possible.
#
# Write the program that finds the indexes of k consecutive planks with minimal total height. Pay attention, the fence is not around Polycarpus's home, it is in front of home (in other words, the fence isn't cyclic).
#
# Input
# The first line of the input contains integers n and k (1 ≤ n ≤ 1.5·105, 1 ≤ k ≤ n) — the number of planks in the fence and the width of the hole for the piano. The second line contains the sequence of integers h1, h2, ..., hn (1 ≤ hi ≤ 100), where hi is the height of the i-th plank of the fence.
#
# Output
# Print such integer j that the sum of the heights of planks j, j + 1, ..., j + k - 1 is the minimum possible. If there are multiple such j's, print any of them.
#
# Examples
# inputCopy
# 7 3
# 1 2 6 1 1 7 1
# outputCopy
# 3
# Note
# In the sample, your task is to find three consecutive planks with the minimum sum of heights. In the given case three planks with indexes 3, 4 and 5 have the required attribute, their total height is 8.
# Python O(N) O(1)
import sys


def solution(n: int, k: int, fences: list) -> str:
    answer: int = 0
    left: int = 0
    window_sum: int = sum(fences[left:k])
    cur_sum: int = sum(fences[left:k])
    for right in range(k, n):
        cur_sum -= fences[left]
        left += 1
        cur_sum += fences[right]
        if window_sum > cur_sum:
            window_sum = cur_sum
            answer = left
    return str(answer + 1)


if __name__ == '__main__':
    n, k = map(int, sys.stdin.readline().rstrip().split())
    fences: list = list(map(int, sys.stdin.readline().rstrip().split()))
    sys.stdout.write(solution(n, k, fences))
# C++ O(N) O(1)
#include <iostream>
#include <vector>

int main() {
    int n, k;
    std::cin >> n >> k;
    std::vector<int> fences;
    for (int i = 0; i < n; ++i) {
        int fence;
        std::cin >> fence;
        fences.push_back(fence);
    }
    int answer = 0;
    int left = 0;
    int min_sum = 0;
    for (int index = 0; index < k; ++index) {
        min_sum += fences[index];
    }
    int cur_sum = min_sum;
    for (int right = k; right < n; ++right) {
        cur_sum -= fences[left];
        left += 1;
        cur_sum += fences[right];
        if (min_sum > cur_sum) {
            min_sum = cur_sum;
            answer = left;
        }
    }
    std::cout << answer + 1 << std::endl;
}

# Volume of a Cuboid
# Bob needs a fast way to calculate the volume of a cuboid with three values: the length, width and height of the cuboid. Write a function to help Bob with this calculation.
# GEOMETRYFUNDAMENTALSMATHEMATICS
double getVolumeOfCuboid(double length, double width, double height) {
  return length * width * height;
}

# 1371. Find the Longest Substring Containing Vowels in Even Counts
# Given the string s, return the size of the longest substring containing each vowel an even number of times. That is, 'a', 'e', 'i', 'o', and 'u' must appear an even number of times.
#
#
#
# Example 1:
#
# Input: s = "eleetminicoworoep"
# Output: 13
# Explanation: The longest substring is "leetminicowor" which contains two each of the vowels: e, i and o and zero of the vowels: a and u.
# Example 2:
#
# Input: s = "leetcodeisgreat"
# Output: 5
# Explanation: The longest substring is "leetc" which contains two e's.
# Example 3:
#
# Input: s = "bcbcbc"
# Output: 6
# Explanation: In this case, the given string "bcbcbc" is the longest because all vowels: a, e, i, o and u appear zero times.
#
#
# Constraints:
#
# 1 <= s.length <= 5 x 10^5
# s contains only lowercase English letters.
# Python O(N) O(N)
class Solution:
    def findTheLongestSubstring(self, s: str) -> int:
        seen: dict[int, int] = {0: -1}
        bit_mask: int = 0
        max_len: int = 0
        for index in range(len(s)):
            if s[index] in 'aeiou': bit_mask ^= ord(s[index]) - 96
            if bit_mask in seen:
                max_len = max(max_len, index - seen[bit_mask])
            else:
                seen[bit_mask] = index
        return max_len
# C++ O(N) O(N)
class Solution {
public:
    static int findTheLongestSubstring(string& s) {
        char vowels[26];
        std::memset(vowels, -1, 26);
        vowels[0] = 0;
        vowels['e'-'a'] = 1;
        vowels['i'-'a'] = 2;
        vowels['o'-'a'] = 3;
        vowels['u'-'a'] = 4;
        const int n = s.size();
        std::vector<char> bit_mask(n + 1, 0);
        int seen[32];
        std::memset(seen, -1, sizeof(seen));
        int max_len=0;
        seen[0]=0;
        for(int index = 0; index < s.size(); ++index){
            const char x = vowels[s[index] - 'a'];
            const char curr_bit_mask = bit_mask[index + 1] = bit_mask[index] ^ (x == -1? 0 : (1 << x));
            if (seen[curr_bit_mask]==-1) {
                seen[curr_bit_mask]=index + 1;
            }
            max_len = std::max(max_len, index - seen[curr_bit_mask] + 1);
        }
        return max_len;
    }
};

# 3285. Find Indices of Stable Mountains
# There are n mountains in a row, and each mountain has a height. You are given an integer array height where height[i] represents the height of mountain i, and an integer threshold.
#
# A mountain is called stable if the mountain just before it (if it exists) has a height strictly greater than threshold. Note that mountain 0 is not stable.
#
# Return an array containing the indices of all stable mountains in any order.
#
#
#
# Example 1:
#
# Input: height = [1,2,3,4,5], threshold = 2
#
# Output: [3,4]
#
# Explanation:
#
# Mountain 3 is stable because height[2] == 3 is greater than threshold == 2.
# Mountain 4 is stable because height[3] == 4 is greater than threshold == 2.
# Example 2:
#
# Input: height = [10,1,10,1,10], threshold = 3
#
# Output: [1,3]
#
# Example 3:
#
# Input: height = [10,1,10,1,10], threshold = 10
#
# Output: []
#
#
#
# Constraints:
#
# 2 <= n == height.length <= 100
# 1 <= height[i] <= 100
# 1 <= threshold <= 100
# Python O(N) O(N)
class Solution:
    def stableMountains(self, height: List[int], threshold: int) -> List[int]:
        stable: list[int] = []
        for idx in range(1, len(height)):
            if height[idx - 1] > threshold:
                stable.append(idx)
        return stable
# C++ O(N) O(N)
class Solution {
public:
    vector<int> stableMountains(vector<int>& height, int threshold) {
        std::vector<int> stable;
        for (int index = 1; index < height.size(); ++index) {
            if (height[index - 1] > threshold) {
                stable.push_back(index);
            }
        }
        return stable;
    }
};
# Python O(N) O(N) One Liner
class Solution:
    def stableMountains(self, height: List[int], threshold: int) -> List[int]:
        return [idx for idx in range(1, len(height)) if height[idx - 1] > threshold]

# 3286. Find a Safe Walk Through a Grid
# You are given an m x n binary matrix grid and an integer health.
#
# You start on the upper-left corner (0, 0) and would like to get to the lower-right corner (m - 1, n - 1).
#
# You can move up, down, left, or right from one cell to another adjacent cell as long as your health remains positive.
#
# Cells (i, j) with grid[i][j] = 1 are considered unsafe and reduce your health by 1.
#
# Return true if you can reach the final cell with a health value of 1 or more, and false otherwise.
#
#
#
# Example 1:
#
# Input: grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]], health = 1
#
# Output: true
#
# Explanation:
#
# The final cell can be reached safely by walking along the gray cells below.
#
#
# Example 2:
#
# Input: grid = [[0,1,1,0,0,0],[1,0,1,0,0,0],[0,1,1,1,0,1],[0,0,1,0,1,0]], health = 3
#
# Output: false
#
# Explanation:
#
# A minimum of 4 health points is needed to reach the final cell safely.
#
#
# Example 3:
#
# Input: grid = [[1,1,1],[1,0,1],[1,1,1]], health = 5
#
# Output: true
#
# Explanation:
#
# The final cell can be reached safely by walking along the gray cells below.
#
#
#
# Any path that does not go through the cell (1, 1) is unsafe since your health will drop to 0 when reaching the final cell.
#
#
#
# Constraints:
#
# m == grid.length
# n == grid[i].length
# 1 <= m, n <= 50
# 2 <= m * n
# 1 <= health <= m + n
# grid[i][j] is either 0 or 1.
# Python O(MN) O(MN)
class Solution:
    def findSafeWalk(self, grid: List[List[int]], health: int) -> bool:
        m, n = len(grid), len(grid[0])
        stack: list[tuple[int, int, int]] = [(0, 0, health)]
        seen: set[tuple[int, int, int]] = set()
        while stack:
            row, col, points = stack.pop()
            if not (0 <= row < m) or not (0 <= col < n) or points <= 0: continue
            if row == m - 1 and col == n - 1 and points - grid[row][col] > 0: return True
            if (row, col, points) in seen: continue
            seen.add((row, col, points))
            next_points: int = points - grid[row][col]
            stack.append((row + 1, col, next_points))
            stack.append((row - 1, col, next_points))
            stack.append((row, col + 1, next_points))
            stack.append((row, col - 1, next_points))
        return False
# C++ O(MNH) O(MN)
#include <vector>
#include <set>
#include <stack>

class Solution {
public:
    bool findSafeWalk(std::vector<std::vector<int>>& grid, int health) {
        int m = grid.size();
        int n = grid[0].size();
        std::stack<std::vector<int>> stack;
        stack.push({0, 0, health});
        std::set<std::tuple<int, int, int>> seen;
        while (!stack.empty()) {
            int row = stack.top()[0];
            int col = stack.top()[1];
            int cur_points = stack.top()[2];
            stack.pop();
            if (row < 0 || row >= m || col < 0 || col >= n) {
                continue;
            }
            if (row == m - 1 && col == n - 1 && cur_points - grid[row][col] > 0) {
                return true;
            }
            if (seen.count({row, col, cur_points})) {
                continue;
            }
            seen.insert({row, col, cur_points});
            int next_points = cur_points - grid[row][col];
            if (next_points > 0) {
                stack.push({row + 1, col, next_points});
                stack.push({row - 1, col, next_points});
                stack.push({row, col + 1, next_points});
                stack.push({row, col - 1, next_points});
            }
        }
        return false;
    }
};

# 3289. The Two Sneaky Numbers of Digitville
# In the town of Digitville, there was a list of numbers called nums containing integers from 0 to n - 1. Each number was supposed to appear exactly once in the list, however, two mischievous numbers sneaked in an additional time, making the list longer than usual.
#
# As the town detective, your task is to find these two sneaky numbers. Return an array of size two containing the two numbers (in any order), so peace can return to Digitville.
#
#
#
# Example 1:
#
# Input: nums = [0,1,1,0]
#
# Output: [0,1]
#
# Explanation:
#
# The numbers 0 and 1 each appear twice in the array.
#
# Example 2:
#
# Input: nums = [0,3,2,1,3,2]
#
# Output: [2,3]
#
# Explanation:
#
# The numbers 2 and 3 each appear twice in the array.
#
# Example 3:
#
# Input: nums = [7,1,5,4,3,4,6,0,9,5,8,2]
#
# Output: [4,5]
#
# Explanation:
#
# The numbers 4 and 5 each appear twice in the array.
#
#
#
# Constraints:
#
# 2 <= n <= 100
# nums.length == n + 2
# 0 <= nums[i] < n
# The input is generated such that nums contains exactly two repeated elements.
# Python O(N) O(N)
class Solution:
    def getSneakyNumbers(self, nums: List[int]) -> List[int]:
        hashmap: dict[int, int] = dict()
        for num in nums:
            hashmap[num] = hashmap.get(num, 0) + 1
        return [num for num in hashmap if hashmap[num] > 1]
# C++ O(N) O(N)
class Solution {
public:
    vector<int> getSneakyNumbers(vector<int>& nums) {
        std::vector<int> storage(101, 0);
        for (int num : nums) {
            storage[num]++;
        }
        std::vector<int> duplicate;
        for (int index = 0; index < 101; ++index) {
            if (storage[index] > 1) {
                duplicate.push_back(index);
            }
        }
        return duplicate;
    }
};

# 3290. Maximum Multiplication Score
# You are given an integer array a of size 4 and another integer array b of size at least 4.
#
# You need to choose 4 indices i0, i1, i2, and i3 from the array b such that i0 < i1 < i2 < i3. Your score will be equal to the value a[0] * b[i0] + a[1] * b[i1] + a[2] * b[i2] + a[3] * b[i3].
#
# Return the maximum score you can achieve.
#
#
#
# Example 1:
#
# Input: a = [3,2,5,6], b = [2,-6,4,-5,-3,2,-7]
#
# Output: 26
#
# Explanation:
# We can choose the indices 0, 1, 2, and 5. The score will be 3 * 2 + 2 * (-6) + 5 * 4 + 6 * 2 = 26.
#
# Example 2:
#
# Input: a = [-1,4,5,-2], b = [-5,-1,-3,-2,-4]
#
# Output: -1
#
# Explanation:
# We can choose the indices 0, 1, 3, and 4. The score will be (-1) * (-5) + 4 * (-1) + 5 * (-2) + (-2) * (-4) = -1.
#
#
#
# Constraints:
#
# a.length == 4
# 4 <= b.length <= 105
# -105 <= a[i], b[i] <= 105
# Python O(MN) O(MN)
class Solution:
    def maxScore(self, a: List[int], b: List[int]) -> int:
        n: int = len(b)
        dp: list[list[int]] = [[-float('inf')] * 5 for _ in range(n + 1)]
        dp[0][0] = 0
        for i in range(1, n + 1):
            for j in range(5):
                dp[i][j] = dp[i - 1][j]
            for j in range(1, 5):
                dp[i][j] = max(
                    dp[i][j],
                    dp[i - 1][j - 1] + a[j - 1] * b[i - 1]
                )
        return dp[n][4]
# C++ O(MN) O(MN)
#include <vector>
#include <limits>
#include <algorithm>

class Solution {
public:
    long long maxScore(std::vector<int>& a, std::vector<int>& b) {
        int n = b.size();
        std::vector<std::vector<long long>> dp(n + 1, std::vector<long long>(5, std::numeric_limits<long long>::min()));
        dp[0][0] = 0;
        for (int i = 1; i <= n; ++i) {
            for (int j = 0; j < 5; ++j) {
                dp[i][j] = dp[i - 1][j];
            }
            for (int j = 1; j < 5; ++j) {
                if (dp[i - 1][j - 1] != std::numeric_limits<long long>::min()){
                    dp[i][j] = std::max(
                        dp[i][j],
                        dp[i - 1][j - 1] + static_cast<long long>(a[j - 1]) * b[i - 1]
                    );
                }
            }
        }
        return dp[n][4];
    }
};

# A. Boring Apartments
# A. Boring Apartments
# time limit per test1 second
# memory limit per test256 megabytes
# There is a building consisting of 10 000
#  apartments numbered from 1
#  to 10 000
# , inclusive.
#
# Call an apartment boring, if its number consists of the same digit. Examples of boring apartments are 11,2,777,9999
#  and so on.
#
# Our character is a troublemaker, and he calls the intercoms of all boring apartments, till someone answers the call, in the following order:
#
# First he calls all apartments consisting of digit 1
# , in increasing order (1,11,111,1111
# ).
# Next he calls all apartments consisting of digit 2
# , in increasing order (2,22,222,2222
# )
# And so on.
# The resident of the boring apartment x
#  answers the call, and our character stops calling anyone further.
#
# Our character wants to know how many digits he pressed in total and your task is to help him to count the total number of keypresses.
#
# For example, if the resident of boring apartment 22
#  answered, then our character called apartments with numbers 1,11,111,1111,2,22
#  and the total number of digits he pressed is 1+2+3+4+1+2=13
# .
#
# You have to answer t
#  independent test cases.
#
# Input
# The first line of the input contains one integer t
#  (1≤t≤36
# ) — the number of test cases.
#
# The only line of the test case contains one integer x
#  (1≤x≤9999
# ) — the apartment number of the resident who answered the call. It is guaranteed that x
#  consists of the same digit.
#
# Output
# For each test case, print the answer: how many digits our character pressed in total.
#
# Example
# inputCopy
# 4
# 22
# 9999
# 1
# 777
# outputCopy
# 13
# 90
# 1
# 66
# Python O(logN) O(1)
import sys


def solution(t:int) -> None:
    for _ in range(t):
        x: int = int(sys.stdin.readline().rstrip())
        remainder: int = 0
        module: int = 0
        while x:
            remainder = x % 10
            x //= 10
            module += 1
        acc: int = 0
        for digit in range(1, module + 1):
            acc += digit
        sys.stdout.write(str(10 * (remainder - 1) + acc) + '\n')


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)
# C++ O(logN) O(1)
#include <iostream>

int main() {
    int t;
    std::cin >> t;
    for (int i = 0; i < t; ++i) {
        int x;
        std::cin >> x;
        int remainder = 1;
        int module = 0;
        while (x) {
            remainder = x % 10;
            x /= 10;
            module++;
        }
        int acc = 0;
        for (int digit = 1; digit <= module; ++digit) {
            acc += digit;
        }
        std::cout << (10 * (remainder - 1)) + acc << std::endl;
    }
}
# Common Denominators
/* Common denominators

You will have a list of rationals in the form

{ {numer_1, denom_1} , ... {numer_n, denom_n} }
or
[ [numer_1, denom_1] , ... [numer_n, denom_n] ]
or
[ (numer_1, denom_1) , ... (numer_n, denom_n) ]
where all numbers are positive ints. You have to produce a result in the form:

(N_1, D) ... (N_n, D)
or
[ [N_1, D] ... [N_n, D] ]
or
[ (N_1', D) , ... (N_n, D) ]
or
{{N_1, D} ... {N_n, D}}
or
"(N_1, D) ... (N_n, D)"
depending on the language (See Example tests) in which D is as small as possible and

N_1/D == numer_1/denom_1 ... N_n/D == numer_n,/denom_n.
Example:
convertFracs [(1, 2), (1, 3), (1, 4)] `shouldBe` [(6, 12), (4, 12), (3, 12)]
Note:
Due to the fact that the first translations were written long ago - more than 6 years - these first translations have only irreducible fractions.

Newer translations have some reducible fractions. To be on the safe side it is better to do a bit more work by simplifying fractions even if they don't have to be.

Note for Bash:
input is a string, e.g "2,4,2,6,2,8" output is then "6 12 4 12 3 12"

FUNDAMENTALSALGORITHMSMATHEMATICS */
#include <numeric>
#include <vector>
#include <string>
#include <sstream>
#include <iostream>

class Fracts {
public:
    static std::string convertFrac(std::vector<std::vector<unsigned long long>> &lst) {
        unsigned long long D = 1;
        for (const auto& frac : lst) {
            unsigned long long den = frac[1];
            D = (D * (den / std::gcd(D, den)));
        }
        std::ostringstream output;
        for (const auto& frac : lst) {
            unsigned long long num = frac[0];
            unsigned long long den = frac[1];
            output << "(" << (D / den) * num << "," << D << ")";
        }

        return output.str();
    }
};

# 539. Minimum Time Difference
# Given a list of 24-hour clock time points in "HH:MM" format, return the minimum minutes difference between any two time-points in the list.
#
#
# Example 1:
#
# Input: timePoints = ["23:59","00:00"]
# Output: 1
# Example 2:
#
# Input: timePoints = ["00:00","23:59","00:00"]
# Output: 0
#
#
# Constraints:
#
# 2 <= timePoints.length <= 2 * 104
# timePoints[i] is in the format "HH:MM".
# Python O(NlogN) O(N) DateTime
from datetime import datetime, timedelta
class Solution:
    def findMinDifference(self, timePoints: List[str]) -> int:
        timePoints.sort()
        answer: int = 23 * 60 * 60
        for idx in range(len(timePoints)):
            first_time = datetime.strptime(timePoints[idx], '%H:%M')
            second_time = datetime.strptime(timePoints[(idx + 1) % len(timePoints)], '%H:%M')
            if second_time < first_time:
                second_time += timedelta(days=1)
            answer = min(answer, (second_time - first_time).total_seconds() / 60)
        return int(answer)
# Python O(NlogN) O(1) Math
class Solution:
    def findMinDifference(self, timePoints: List[str]) -> int:
        for idx in range(len(timePoints)):
            hours, minutes = map(int, timePoints[idx].split(':'))
            timePoints[idx] = hours * 60 + minutes
        timePoints.sort()
        answer: int = 24 * 60 - timePoints[-1] + timePoints[0]
        for i in range(len(timePoints) - 1):
            answer = min(answer, timePoints[i + 1] - timePoints[i])
        return answer

# B. Books
# B. Books
# time limit per test2 seconds
# memory limit per test256 megabytes
# When Valera has got some free time, he goes to the library to read some books. Today he's got t free minutes to read. That's why Valera took n books in the library and for each book he estimated the time he is going to need to read it. Let's number the books by integers from 1 to n. Valera needs ai minutes to read the i-th book.
#
# Valera decided to choose an arbitrary book with number i and read the books one by one, starting from this book. In other words, he will first read book number i, then book number i + 1, then book number i + 2 and so on. He continues the process until he either runs out of the free time or finishes reading the n-th book. Valera reads each book up to the end, that is, he doesn't start reading the book if he doesn't have enough free time to finish reading it.
#
# Print the maximum number of books Valera can read.
#
# Input
# The first line contains two integers n and t (1 ≤ n ≤ 105; 1 ≤ t ≤ 109) — the number of books and the number of free minutes Valera's got. The second line contains a sequence of n integers a1, a2, ..., an (1 ≤ ai ≤ 104), where number ai shows the number of minutes that the boy needs to read the i-th book.
#
# Output
# Print a single integer — the maximum number of books Valera can read.
#
# Examples
# inputCopy
# 4 5
# 3 1 2 1
# outputCopy
# 3
# inputCopy
# 3 3
# 2 2 3
# outputCopy
# 1
import sys


def solution(t: int, n: int, books: list) -> str:
    left = 0
    current_time = 0
    max_books = 0

    for right in range(t):
        current_time += books[right]
        while current_time > n:
            current_time -= books[left]
            left += 1
        max_books = max(max_books, right - left + 1)

    return str(max_books)


if __name__ == '__main__':
    t, n = map(int, sys.stdin.readline().rstrip().split())
    books: list = list(map(int, sys.stdin.readline().rstrip().split()))
    sys.stdout.write(solution(t, n, books))

#  Task
# Sum all the numbers of a given array ( cq. list ), except the highest and the lowest element ( by value, not by index! ).
#
# The highest or lowest element respectively is a single element at each edge, even if there are more than one with the same value.
#
# Mind the input validation.
#
# Example
# { 6, 2, 1, 8, 10 } => 16
# { 1, 1, 11, 2, 3 } => 6
# Input validation
# If an empty value ( null, None, Nothing, nil etc. ) is given instead of an array, or the given array is an empty list or a list with only 1 element, return 0.
#
# FUNDAMENTALS
#include<vector>
using namespace std;

int sum(vector<int> numbers)
{
  if (numbers.size() < 2) {
    return 0;
  }
  int total_sum = 0, min_num = numbers[1], max_num = numbers[1];
  for (size_t index = 0; index < numbers.size(); ++index) {
    total_sum += numbers[index];
    if (min_num > numbers[index]) {
      min_num = numbers[index];
    }
    if (max_num < numbers[index]) {
      max_num = numbers[index];
    }
  }
  return total_sum - min_num - max_num;
}

# Find the number of trailing zeros in the binary representation of a number.
# Given a number n, find the number of trailing zeros in its binary representation.
#
# Examples:
# 4 should return 2 as it's represented as 100 and 5 should return 0  101
# Limits:
# 0 < n and n <= 10^4
# LOGICBITS
def trailing_zeros(n) ->int:
    target: str = bin(n)[2:]
    n: int = len(target) - 1
    while n >= 0 and target[n] == '0':
        n -= 1
    return len(target) - n - 1

# A. Maximum GCD
# A. Maximum GCD
# time limit per test1 second
# memory limit per test256 megabytes
# Let's consider all integers in the range from 1
#  to n
#  (inclusive).
#
# Among all pairs of distinct integers in this range, find the maximum possible greatest common divisor of integers in pair. Formally, find the maximum value of gcd(a,b)
# , where 1≤a<b≤n
# .
#
# The greatest common divisor, gcd(a,b)
# , of two positive integers a
#  and b
#  is the biggest integer that is a divisor of both a
#  and b
# .
#
# Input
# The first line contains a single integer t
#  (1≤t≤100
# )  — the number of test cases. The description of the test cases follows.
#
# The only line of each test case contains a single integer n
#  (2≤n≤106
# ).
#
# Output
# For each test case, output the maximum value of gcd(a,b)
#  among all 1≤a<b≤n
# .
#
# Example
# inputCopy
# 2
# 3
# 5
# outputCopy
# 1
# 2
# Note
# In the first test case, gcd(1,2)=gcd(2,3)=gcd(1,3)=1
# .
#
# In the second test case, 2
#  is the maximum possible value, corresponding to gcd(2,4)
# .
# Python O(1) O(1) Math
import sys


def solution(t: int) -> None:
    for _ in range(t):
        n: int = int(sys.stdin.readline().rstrip())
        sys.stdout.write(str([n // 2, (n - 1) // 2][n & 1]) + '\n')


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)

# C++ O(1) O(1) Math
#include <iostream>

int main() {
    int t;
    std::cin >> t;
    for (size_t i = 0; i < t; ++i) {
        int n;
        std::cin >> n;
        std::cout << (n % 2 == 0? n / 2 : (n - 1) / 2) << std::endl;
    }
}

# B. Sale
# B. Sale
# time limit per test2 seconds
# memory limit per test256 megabytes
# Once Bob got to a sale of old TV sets. There were n TV sets at that sale. TV set with index i costs ai bellars. Some TV sets have a negative price — their owners are ready to pay Bob if he buys their useless apparatus. Bob can «buy» any TV sets he wants. Though he's very strong, Bob can carry at most m TV sets, and he has no desire to go to the sale for the second time. Please, help Bob find out the maximum sum of money that he can earn.
#
# Input
# The first line contains two space-separated integers n and m (1 ≤ m ≤ n ≤ 100) — amount of TV sets at the sale, and amount of TV sets that Bob can carry. The following line contains n space-separated integers ai ( - 1000 ≤ ai ≤ 1000) — prices of the TV sets.
#
# Output
# Output the only number — the maximum sum of money that Bob can earn, given that he can carry at most m TV sets.
#
# Examples
# inputCopy
# 5 3
# -6 0 35 -2 4
# outputCopy
# 8
# inputCopy
# 4 2
# 7 0 0 -7
# outputCopy
# 7
from typing import List
import sys


def solution(t: int, m: int, tvs: List[int]) -> str:
    tvs.sort()
    init_balance: int = -tvs[0]
    for idx in range(1, m):
        if init_balance + -tvs[idx] < init_balance:
            break
        init_balance += -tvs[idx]
    return str(max(init_balance, 0))


if __name__ == '__main__':
    t, m = map(int, sys.stdin.readline().rstrip().split())
    tvs: List[int] = list(map(int, sys.stdin.readline().rstrip().split()))
    sys.stdout.write(solution(t, m, tvs))


# 179. Largest Number
# Given a list of non-negative integers nums, arrange them such that they form the largest number and return it.
#
# Since the result may be very large, so you need to return a string instead of an integer.
#
#
#
# Example 1:
#
# Input: nums = [10,2]
# Output: "210"
# Example 2:
#
# Input: nums = [3,30,34,5,9]
# Output: "9534330"
#
#
# Constraints:
#
# 1 <= nums.length <= 100
# 0 <= nums[i] <= 109
from functools import cmp_to_key
class Solution:
    def comparison(self, x: str, y: str) -> int:
            """
            For ascending order, ex:
                if x+y > y+x, then y should comes first.
                elif x+y < y+x, then x should comes first.
                else tie, choose any of them.
            """
            if x + y > y + x: return 1
            elif x + y < y + x: return -1
            return 0

    def largestNumber(self, nums: List[int]) -> str:
        answer: str = ''.join(sorted(map(str, nums), reverse=True, key=cmp_to_key(self.comparison)))
        return answer if answer[0] != '0' else '0'

# Soviet abacus
# Soviet abacus
# In the recent past, when calculators were not so common, the abacus was used to calculate prices
# Your task is to learn how to use them
#
# You will receive a matrix as input
# Size of matrix: 9x6
# Cost of a row:
# 1 = 0.01 (or 1 cent/penny)
# 2 = 0.1 (or 10 cents/pennies)
# 3 = 1
# 4 = 10
# 5 = 100
# 6 = 1000
# Each row has its own price (the price is indicated above). To get 1230 - you need to have 3 beads on the left on the 4th row, 2 beads on the 5th row and 1 bead on the 6th row. It is necessary to take into account only the consecutive beads on the left
#
# Because floating-point numbers should not be used for monetary amounts, as we want exact results, you will return a Decimal.
#
# Trivia: this abacus design was popular in the USSR.
#
# Example:
# First:
# [
#     [0, 0, 1, 0, 0, 0, 0, 0, 0],
#     [1, 1, 1, 0, 0, 0, 0, 0, 0],
#     [1, 0, 0, 0, 0, 0, 0, 0, 0],
#     [0, 0, 0, 0, 0, 0, 0, 0, 0],
#     [0, 0, 0, 0, 0, 0, 0, 0, 0],
#     [0, 0, 1, 0, 0, 0, 0, 0, 0],
# ] -> 1.3
#
# Second:
# [
#     [1, 0, 0, 1, 1, 1, 0, 0, 0],
#     [1, 0, 1, 0, 0, 1, 0, 0, 0],
#     [1, 1, 1, 0, 0, 1, 0, 0, 0],
#     [0, 0, 0, 0, 0, 0, 0, 0, 0],
#     [1, 1, 0, 0, 0, 0, 0, 0, 0],
#     [1, 0, 1, 0, 0, 0, 0, 0, 0],
# ] -> 1203.11
#
# Third:
# [
#     [1, 1, 1, 1, 1, 1, 0, 0, 0],
#     [1, 1, 1, 0, 0, 0, 0, 0, 0],
#     [1, 1, 1, 1, 0, 0, 0, 0, 0],
#     [1, 0, 0, 0, 0, 0, 0, 0, 0],
#     [1, 1, 0, 0, 0, 0, 0, 0, 0],
#     [1, 1, 1, 0, 0, 0, 0, 0, 0],
# ] -> 3214.36
# ALGORITHMSMATRIX
from decimal import Decimal

def abacus(abacus_rows: list[list[int]]) -> Decimal:
    amount: dict[int, int] = {1: 0.01, 2: 0.1, 3: 1, 4: 10, 5: 100, 6: 1000}
    result: int = 0
    for i in range(1, 7):
        move: bool = False
        for module in range(9):
            if abacus_rows[i - 1][module] == 0:
                result += module * amount[i]
                move = True
                break
        if not move and abacus_rows[i - 1][-1] == 1:
            result += 9 * amount[i]
    return Decimal(str(result)).quantize(Decimal('0.01'))

# 241. Different Ways to Add Parentheses
# Given a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.
#
# The test cases are generated such that the output values fit in a 32-bit integer and the number of different results does not exceed 104.
#
#
#
# Example 1:
#
# Input: expression = "2-1-1"
# Output: [0,2]
# Explanation:
# ((2-1)-1) = 0
# (2-(1-1)) = 2
# Example 2:
#
# Input: expression = "2*3-4*5"
# Output: [-34,-14,-10,-10,10]
# Explanation:
# (2*(3-(4*5))) = -34
# ((2*3)-(4*5)) = -14
# ((2*(3-4))*5) = -10
# (2*((3-4)*5)) = -10
# (((2*3)-4)*5) = 10
#
#
# Constraints:
#
# 1 <= expression.length <= 20
# expression consists of digits and the operator '+', '-', and '*'.
# All the integer values in the input expression are in the range [0, 99].
class Solution:
    def diffWaysToCompute(self, expression: str) -> List[int]:
        possible: list[int] = []
        for idx in range(len(expression)):
            operation: str = expression[idx]
            if operation in '+-*':
                left_part: list[int] = self.diffWaysToCompute(expression[:idx])
                right_part: list[int] = self.diffWaysToCompute(expression[idx+1:])
                for left in left_part:
                    for right in right_part:
                        if operation == '*':
                            possible.append(int(left) * int(right))
                        elif operation == '+':
                            possible.append(int(left) + int(right))
                        else:
                            possible.append(int(left) - int(right))
        if not possible:
            possible.append(int(expression))
        return possible

# A. Plus One on the Subset
# A. Plus One on the Subset
# time limit per test2 seconds
# memory limit per test256 megabytes
# Polycarp got an array of integers a[1…n]
#  as a gift. Now he wants to perform a certain number of operations (possibly zero) so that all elements of the array become the same (that is, to become a1=a2=⋯=an
# ).
#
# In one operation, he can take some indices in the array and increase the elements of the array at those indices by 1
# .
# For example, let a=[4,2,1,6,2]
# . He can perform the following operation: select indices 1, 2, and 4 and increase elements of the array in those indices by 1
# . As a result, in one operation, he can get a new state of the array a=[5,3,1,7,2]
# .
#
# What is the minimum number of operations it can take so that all elements of the array become equal to each other (that is, to become a1=a2=⋯=an
# )?
#
# Input
# The first line of the input contains a single integer t
#  (1≤t≤104
# )  — the number of test cases in the test.
#
# The following are descriptions of the input test cases.
#
# The first line of the description of each test case contains one integer n
#  (1≤n≤50
# )  — the array a
# .
#
# The second line of the description of each test case contains n
#  integers a1,a2,…,an
#  (1≤ai≤109
# )  — elements of the array a
# .
#
# Output
# For each test case, print one integer  — the minimum number of operations to make all elements of the array a
#  equal.
#
# Example
# inputCopy
# 3
# 6
# 3 4 2 4 1 2
# 3
# 1000 1002 998
# 2
# 12 11
# outputCopy
# 3
# 4
# 1
# Note
# First test case:
#
# a=[3,4,2,4,1,2]
#  take a3,a5
#  and perform an operation plus one on them, as a result we get a=[3,4,3,4,2,2]
# .
# a=[3,4,3,4,2,2]
#  we take a1,a5,a6
#  and perform an operation on them plus one, as a result we get a=[4,4,3,4,3,3]
# .
# a=[4,4,3,4,3,3]
#  we take a3,a5,a6
#  and perform an operation on them plus one, as a result we get a=[4,4,4,4,4,4]
# .
# There are other sequences of 3
#  operations, after the application of which all elements become equal.
#
# Second test case:
#
# a=[1000,1002,998]
#  2 times we take a1,a3
#  and perform an operation plus one on them, as a result we get a=[1002,1002,1000]
# .
# a=[1002,1002,1000]
#  also take a3
#  2 times and perform an operation plus one on it, as a result we get a=[1002,1002,1002]
# .
# Third test case:
#
# a=[12,11]
#  take a2
#  and perform an operation plus one on it, as a result we get a=[12,12]
# .
# Python O(N) O(1)
from typing import List
import sys


def solution(t: int) -> None:
    for _ in range(t):
        n: int = int(sys.stdin.readline().rstrip())
        numbers: List[int] = list(map(int, sys.stdin.readline().rstrip().split()))
        print(max(numbers) - min(numbers))


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)
# C++ O(1) O(1)
#include <iostream>

int main() {
    int t;
    std::cin >> t;
    for (int i = 0; i < t; ++i) {
        int n;
        std::cin >> n;
        int min_num = 10000000000;
        int max_num = 1;
        for (int j = 0; j < n; ++j) {
            int number;
            std::cin >> number;
            min_num = std::min(min_num, number);
            max_num = std::max(max_num, number);
        }
        std::cout << max_num - min_num << std::endl;
    }
}

#Find Maximum and Minimum Values of a List
/* Your task is to make two functions ( max and min, or maximum and minimum, etc., depending on the language ) that receive a list of integers as input, and return the largest and lowest number in that list, respectively.

Examples (Input -> Output)
* [4,6,2,1,9,63,-134,566]         -> max = 566, min = -134
* [-52, 56, 30, 29, -54, 0, -110] -> min = -110, max = 56
* [42, 54, 65, 87, 0]             -> min = 0, max = 87
* [5]                             -> min = 5, max = 5
Notes
You may consider that there will not be any empty arrays/vectors.
FUNDAMENTALS
*/
#include <vector>
using namespace std;

int min(vector<int> list){
    int min_number = list[0];
    for (int number : list) {
      min_number = std::min(min_number, number);
    }
    return min_number;
}

int max(vector<int> list){
    int max_number = list[0];
    for (int number : list) {
      max_number = std::max(max_number, number);
    }
    return max_number;
}

# 214. Shortest Palindrome
# You are given a string s. You can convert s to a
# palindrome
#  by adding characters in front of it.
#
# Return the shortest palindrome you can find by performing this transformation.
#
#
#
# Example 1:
#
# Input: s = "aacecaaa"
# Output: "aaacecaaa"
# Example 2:
#
# Input: s = "abcd"
# Output: "dcbabcd"
#
#
# Constraints:
#
# 0 <= s.length <= 5 * 104
# s consists of lowercase English letters only.
class Solution:
    def shortestPalindrome(self, s: str) -> str:
        concatenated_s: str = s + '#' + s[::-1]
        pattern: list[int | None] = [None] * len(concatenated_s)
        left, right = 0, 1
        while right < len(concatenated_s):
            if concatenated_s[left] == concatenated_s[right]:
                pattern[right] = left
                left, right = left + 1, right + 1
            elif left and pattern[left - 1] is not None:
                left = pattern[left - 1] + 1
            elif left: left = 0
            else: right += 1
        if pattern[-1] is None:
            return ''
        pattern_length: int = len(s) - pattern[-1] - 1
        return s[::-1][:pattern_length] + s

#
Sum of two lowest positive integers
/*
Create a function that returns the sum of the two lowest positive numbers given an array of minimum 4 positive integers. No floats or non-positive integers will be passed.

For example, when an array is passed like [19, 5, 42, 2, 77], the output should be 7.

[10, 343445353, 3453445, 3453545353453] should return 3453455.

ARRAYSFUNDAMENTALS
*/
#include <vector>

long sumTwoSmallestNumbers(std::vector<int> numbers)
{
    long int first = std::min(numbers[0], numbers[1]);
    long int second = std::max(numbers[0], numbers[1]);
    for (size_t idx = 2; idx < numbers.size(); ++idx) {
      if (first >= numbers[idx]) {
          second = first;
          first = numbers[idx];
      } else if (second > numbers[idx])  {
          second = numbers[idx];
      }
    }
    return first + second;
}

# A. Do Not Be Distracted!
# A. Do Not Be Distracted!
# time limit per test1 second
# memory limit per test256 megabytes
# Polycarp has 26
#  tasks. Each task is designated by a capital letter of the Latin alphabet.
#
# The teacher asked Polycarp to solve tasks in the following way: if Polycarp began to solve some task, then he must solve it to the end, without being distracted by another task. After switching to another task, Polycarp cannot return to the previous task.
#
# Polycarp can only solve one task during the day. Every day he wrote down what task he solved. Now the teacher wants to know if Polycarp followed his advice.
#
# For example, if Polycarp solved tasks in the following order: "DDBBCCCBBEZ", then the teacher will see that on the third day Polycarp began to solve the task 'B', then on the fifth day he got distracted and began to solve the task 'C', on the eighth day Polycarp returned to the task 'B'. Other examples of when the teacher is suspicious: "BAB", "AABBCCDDEEBZZ" and "AAAAZAAAAA".
#
# If Polycarp solved the tasks as follows: "FFGZZZY", then the teacher cannot have any suspicions. Please note that Polycarp is not obligated to solve all tasks. Other examples of when the teacher doesn't have any suspicious: "BA", "AFFFCC" and "YYYYY".
#
# Help Polycarp find out if his teacher might be suspicious.
#
# Input
# The first line contains an integer t
#  (1≤t≤1000
# ). Then t
#  test cases follow.
#
# The first line of each test case contains one integer n
#  (1≤n≤50
# ) — the number of days during which Polycarp solved tasks.
#
# The second line contains a string of length n
# , consisting of uppercase Latin letters, which is the order in which Polycarp solved the tasks.
#
# Output
# For each test case output:
#
# "YES", if the teacher cannot be suspicious;
# "NO", otherwise.
# You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as positive answer).
#
# Example
# inputCopy
# 5
# 3
# ABA
# 11
# DDBBCCCBBEZ
# 7
# FFGZZZY
# 1
# Z
# 2
# AB
# outputCopy
# NO
# NO
# YES
# YES
# YES
# Python O(N) O(N) Hashset
import sys


def solution(t: int) -> None:
    for _ in range(t):
        n: int = int(sys.stdin.readline().rstrip())
        tasks: str = sys.stdin.readline().rstrip()
        hashset: set = set()
        hashset.add(tasks[0])
        for idx in range(1, n):
            if tasks[idx] in hashset and tasks[idx] != tasks[idx - 1]:
                print('NO')
                break
            hashset.add(tasks[idx])
        else:
            print('YES')


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)

# C++ O(N) O(N) HashSet
#include <iostream>
#include <string>
#include <unordered_set>

int main() {
    int t;
    std::cin >> t;
    for (size_t i = 0; i < t; ++i) {
        int n;
        std::cin >> n;
        std::unordered_set<char> storage;
        std::string line;
        std::getline(std::cin, line);
        std::getline(std::cin, line);
        bool is_suspicious = true;
        storage.insert(line[0]);
        for (size_t j = 1; j < n; ++j) {
            if (storage.count(line[j]) && line[j] != line[j - 1]) {
                std::cout << "NO" << std::endl;
                is_suspicious = false;
                break;
            }
            storage.insert(line[j]);
        }
        if (is_suspicious) {
            std::cout << "YES" << std::endl;
        }
    }
}

# A. Chewbaсca and Number
# A. Chewbaсca and Number
# time limit per test1 second
# memory limit per test256 megabytes
# Luke Skywalker gave Chewbacca an integer number x. Chewbacca isn't good at numbers but he loves inverting digits in them. Inverting digit t means replacing it with digit 9 - t.
#
# Help Chewbacca to transform the initial number x to the minimum possible positive number by inverting some (possibly, zero) digits. The decimal representation of the final number shouldn't start with a zero.
#
# Input
# The first line contains a single integer x (1 ≤ x ≤ 1018) — the number that Luke Skywalker gave to Chewbacca.
#
# Output
# Print the minimum possible positive number that Chewbacca can obtain after inverting some digits. The number shouldn't contain leading zeroes.
#
# Examples
# inputCopy
# 27
# outputCopy
# 22
# inputCopy
# 4545
# outputCopy
# 4444
# Python O(N) O(1) Math Greedy String
from typing import List
import sys


def solution(n: str) -> None:
    answer: List[str] = []
    for index in range(len(n)):
        current_number: int = int(n[index])
        minimum_number: int = min(current_number, 9 - current_number)
        if index == 0 and minimum_number == 0:
            minimum_number = current_number
        answer.append(str(minimum_number))
    print(''.join(answer))


if __name__ == '__main__':
    n: str = sys.stdin.readline().rstrip()
    solution(n)

# C++ O(N) O(1) Math Greedy String
#include <iostream>
#include <string>

int main() {
    std::string init_number;
    std::cin >> init_number;
    std::string answer = "";
    for (size_t index = 0; index < init_number.size(); ++index) {
        int current_number = init_number[index] - '0';
        int minimum_number = std::min(current_number, 9 - current_number);
        if (index == 0 && minimum_number == 0) {
            minimum_number = current_number;
        }
        answer += std::to_string(minimum_number);

    }
    std::cout << answer << std::endl;
}

# 386. Lexicographical Numbers
# Given an integer n, return all the numbers in the range [1, n] sorted in lexicographical order.
#
# You must write an algorithm that runs in O(n) time and uses O(1) extra space.
#
#
#
# Example 1:
#
# Input: n = 13
# Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]
# Example 2:
#
# Input: n = 2
# Output: [1,2]
#
#
# Constraints:
#
# 1 <= n <= 5 * 104
# Python O(N) O(logN) Depth-First-Search
class Solution:
    def dfs(self, current: int, target: int, result: list[int]) -> None:
        if current > target:
            return
        if current > 0:
            result.append(current)
        for acc in range(10):
            if (current == 0 and acc == 0) or current * 10 + acc > target:
                continue
            self.dfs(current * 10 + acc, target, result)

    def lexicalOrder(self, n: int) -> List[int]:
        output: list[int] = []
        self.dfs(0, n, output)
        return output

# C++ O(N) O(logN) Depth-First-Search
class Solution {
public:
    void dfs(int current, int target, std::vector<int>& result) {
        if (current > target) {
            return;
        }
        if (current > 0) {
            result.push_back(current);
        }
        for (int acc = 0; acc < 10; ++acc) {
            if (
                (current == 0 && acc == 0) ||
                (current * 10 + acc > target)
            ) {
                continue;
            }
            dfs(current * 10 + acc, target, result);
        }
    }

    vector<int> lexicalOrder(int n) {
        std::vector<int> output = {};
        dfs(0, n, output);
        return output;
    }
};

# Two Sets of Equal Sum
# If possible, divide the integers 1,2,…,n into two sets of equal sum.
#
# Input
# A positive integer n <= 1,000,000.
#
# Output
# If it's not possible, return [ ] (Python, Javascript, Swift, Ruby) or ( ) (Python) or [ [],[] ] (Java, C#, C++, Kotlin) or None (Scala) or Nothing (Haskell).
# If it's possible, return two disjoint sets. Each integer from 1 to n must be in one of them. The integers in the first set must sum up to the same value as the integers in the second set. The sets can be returned in a tuple, list, or array, depending on language.
#
# Examples:
# For n = 8, valid answers include:
# [1, 3, 6, 8], [2, 4, 5, 7] (or [[1, 3, 6, 8], [2, 4, 5, 7]])
# [8, 1, 3, 2, 4], [5, 7, 6]
# [7, 8, 3], [6, 1, 5, 4, 2], and others.
#
# For n = 9 it is not possible. For example, try [6, 8, 9] and [1, 2, 3, 4, 5, 7], but the first sums to 23 and the second to 22. No other sets work either.
#
# Source: CSES
#
# ARRAYSALGORITHMS
# Solution
# C++
#include <vector>
#include <array>

std::array<std::vector<int>, 2> createTwoSetsOfEqualSum(int n) {
    std::array<std::vector<int>, 2> sets;
    long long total_sum = static_cast<long long>(n) * (n + 1) / 2;
    if (total_sum % 2 != 0) {
        return sets;
    }
    long long target = total_sum / 2;
    for (int num = n; num > 0; --num) {
        if (target >= num) {
            sets[0].push_back(num);
            target -= num;
        } else {
            sets[1].push_back(num);
        }
    }
    return sets;
}
# Python
def create_two_sets_of_equal_sum(n: int) -> tuple[list[int], list[int]]:
    total_sum: int = n * (n + 1) // 2
    if total_sum % 2 != 0: return []

    target: int = total_sum // 2
    set1, set2 = [], []
    for num in range(n, 0, -1):
        if target >= num:
            set1.append(num)
            target -= num
        else:
            set2.append(num)
    return (set1, set2)

# 1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold
# Given an array of integers arr and two integers k and threshold, return the number of sub-arrays of size k and average greater than or equal to threshold.
#
#
#
# Example 1:
#
# Input: arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4
# Output: 3
# Explanation: Sub-arrays [2,5,5],[5,5,5] and [5,5,8] have averages 4, 5 and 6 respectively. All other sub-arrays of size 3 have averages less than 4 (the threshold).
# Example 2:
#
# Input: arr = [11,13,17,23,29,31,7,5,2,3], k = 3, threshold = 5
# Output: 6
# Explanation: The first 6 sub-arrays of size 3 have averages greater than 5. Note that averages are not integers.
#
#
# Constraints:
#
# 1 <= arr.length <= 105
# 1 <= arr[i] <= 104
# 1 <= k <= arr.length
# 0 <= threshold <= 104
# Python O(N) O(1) Sliding Window
class Solution:
    def numOfSubarrays(self, arr: List[int], k: int, threshold: int) -> int:
        answer: int = 0
        left: int = 0
        current_sum: int = 0
        for right in range(len(arr)):
            if right - left + 1 > k:
                current_sum -= arr[left]
                left += 1
            current_sum += arr[right]
            if right - left + 1 == k:
                answer += current_sum / k >= threshold
        return answer
# C++ O(N) O(1) Sliding Window
class Solution {
public:
    int numOfSubarrays(vector<int>& arr, int k, int threshold) {
        int answer = 0;
        size_t left = 0;
        int current_sum = 0;
        for (size_t right = 0; right < arr.size(); ++right) {
            if (right - left + 1 > k) {
                current_sum -= arr[left];
                left += 1;
            }
            current_sum += arr[right];
            if (right - left + 1 == k) {
                answer += current_sum / k >= threshold;
            }
        }
        return answer;
    }
};

# 209. Minimum Size Subarray Sum
# Given an array of positive integers nums and a positive integer target, return the minimal length of a
# subarray
#  whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.
#
#
#
# Example 1:
#
# Input: target = 7, nums = [2,3,1,2,4,3]
# Output: 2
# Explanation: The subarray [4,3] has the minimal length under the problem constraint.
# Example 2:
#
# Input: target = 4, nums = [1,4,4]
# Output: 1
# Example 3:
#
# Input: target = 11, nums = [1,1,1,1,1,1,1,1]
# Output: 0
#
#
# Constraints:
#
# 1 <= target <= 109
# 1 <= nums.length <= 105
# 1 <= nums[i] <= 104
#
#
# Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).
# Python Sliding Window Greedy O(N) O(1)
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        min_length: int = float('inf')
        left: int = 0
        current_sum: int = 0
        for right in range(len(nums)):
            current_sum += nums[right]
            while current_sum >= target:
                min_length = min(min_length, right - left + 1)
                current_sum -= nums[left]
                left += 1
        return min_length if min_length != float('inf') else 0

# C++ Sliding Window Greedy O(N) O(1)
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int min_length = 100001;
        int current_sum = 0;
        int left = 0;
        for (int right = 0; right < nums.size(); ++right) {
            current_sum += nums[right];
            while (current_sum >= target) {
                min_length = std::min(min_length, right - left + 1);
                current_sum -= nums[left];
                left += 1;
            }
        }
        return min_length != 100001? min_length : 0;
    }
};

# 424. Longest Repeating Character Replacement
# You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.
#
# Return the length of the longest substring containing the same letter you can get after performing the above operations.
#
#
#
# Example 1:
#
# Input: s = "ABAB", k = 2
# Output: 4
# Explanation: Replace the two 'A's with two 'B's or vice versa.
# Example 2:
#
# Input: s = "AABABBA", k = 1
# Output: 4
# Explanation: Replace the one 'A' in the middle with 'B' and form "AABBBBA".
# The substring "BBBB" has the longest repeating letters, which is 4.
# There may exists other ways to achieve this answer too.
#
#
# Constraints:
#
# 1 <= s.length <= 105
# s consists of only uppercase English letters.
# 0 <= k <= s.length
# Python O(N) O(N) Sliding Window HashMap
class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        max_freq: int = 0
        max_length: int = 0
        storage: dict[str, int] = dict()
        left: int = 0
        for right in range(len(s)):
            storage[s[right]] = storage.get(s[right], 0) + 1
            max_freq = max(max_freq, storage[s[right]])
            if right - left + 1 - max_freq > k:
                storage[s[left]] -= 1
                left += 1
            max_length = max(max_length, right - left + 1)
        return max_length

# C++ O(N) O(N) Sliding Window HashMap
class Solution {
public:
    int characterReplacement(string s, int k) {
        int max_length = 0;
        std::unordered_map<char, int> storage;
        int max_freq = 0;
        int left = 0;
        for (int right = 0; right < s.size(); ++right) {
            storage[s[right]]++;
            max_freq = std::max(max_freq, storage[s[right]]);
            if (right - left + 1 - max_freq > k) {
                storage[s[left]]--;
                left++;
            }
            max_length = std::max(max_length, right - left + 1);
        }
        return max_length;
    }
};

# 440. K-th Smallest in Lexicographical Order
# Given two integers n and k, return the kth lexicographically smallest integer in the range [1, n].
#
#
#
# Example 1:
#
# Input: n = 13, k = 2
# Output: 10
# Explanation: The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.
# Example 2:
#
# Input: n = 1, k = 1
# Output: 1
#
#
# Constraints:
#
# 1 <= k <= n <= 109
# Python O(logN) O(logN) DFS
class Solution:
    def count_steps(self, curr: int, n: int) -> int:
        needed: int = 0
        number1: int = curr
        number2: int = curr + 1
        while number1 <= n:
            needed += min(n + 1, number2) - number1
            number1 *= 10
            number2 *= 10
        return needed

    def findKthNumber(self, n: int, k: int) -> int:
        curr: int = 1
        k -= 1
        while k > 0:
            needed_to_tranform: int = self.count_steps(curr, n)
            if needed_to_tranform <= k:
                curr += 1
                k -= needed_to_tranform
            else:
                curr *= 10
                k -= 1
        return curr

# C++ O(logN) O(logN) DFS
class Solution {
public:
    long int count_steps(long int n, long int number1, long int number2) {
        long int needed = 0;
        while (number1 <= n) {
            needed += std::min(n + 1, number2) - number1;
            number1 *= 10;
            number2 *= 10;
        }
        return needed;
    }

    int findKthNumber(long int n, long int k) {
        k -= 1;
        int current_number = 1;
        while (k > 0) {
            int needed_steps = count_steps(n, current_number, current_number + 1);
            if (needed_steps <= k) {
                k -= needed_steps;
                current_number += 1;
            } else {
                k -= 1;
                current_number *= 10;
            }
        }
        return current_number;
    }
};
# 3295. Report Spam Message
# You are given an array of strings message and an array of strings bannedWords.
#
# An array of words is considered spam if there are at least two words in it that exactly match any word in bannedWords.
#
# Return true if the array message is spam, and false otherwise.
#
#
#
# Example 1:
#
# Input: message = ["hello","world","leetcode"], bannedWords = ["world","hello"]
#
# Output: true
#
# Explanation:
#
# The words "hello" and "world" from the message array both appear in the bannedWords array.
#
# Example 2:
#
# Input: message = ["hello","programming","fun"], bannedWords = ["world","programming","leetcode"]
#
# Output: false
#
# Explanation:
#
# Only one word from the message array ("programming") appears in the bannedWords array.
#
#
#
# Constraints:
#
# 1 <= message.length, bannedWords.length <= 105
# 1 <= message[i].length, bannedWords[i].length <= 15
# message[i] and bannedWords[i] consist only of lowercase English letters.
# Python O(N) O(K), where K is length of distinct words in bannedWords
class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        deprecated: set[str] = set(bannedWords)
        count: int = 0
        for m in message:
            count += m in deprecated
            if count > 1: return True
        return False

# C++ O(N) O(K), where K is length of distinct words in bannedWords
class Solution {
public:
    bool reportSpam(vector<string>& message, vector<string>& bannedWords) {
        std::unordered_set<std::string> deprecated;
        for (std::string word : bannedWords) {
            deprecated.insert(word);
        }
        int count = 0;
        for (std::string word : message) {
            count += deprecated.count(word);
            if (count > 1) {
                return true;
            }
        }
        return false;
    }
};

# 3296. Minimum Number of Seconds to Make Mountain Height Zero
# You are given an integer mountainHeight denoting the height of a mountain.
#
# You are also given an integer array workerTimes representing the work time of workers in seconds.
#
# The workers work simultaneously to reduce the height of the mountain. For worker i:
#
# To decrease the mountain's height by x, it takes workerTimes[i] + workerTimes[i] * 2 + ... + workerTimes[i] * x seconds. For example:
# To reduce the height of the mountain by 1, it takes workerTimes[i] seconds.
# To reduce the height of the mountain by 2, it takes workerTimes[i] + workerTimes[i] * 2 seconds, and so on.
# Return an integer representing the minimum number of seconds required for the workers to make the height of the mountain 0.
#
#
#
# Example 1:
#
# Input: mountainHeight = 4, workerTimes = [2,1,1]
#
# Output: 3
#
# Explanation:
#
# One way the height of the mountain can be reduced to 0 is:
#
# Worker 0 reduces the height by 1, taking workerTimes[0] = 2 seconds.
# Worker 1 reduces the height by 2, taking workerTimes[1] + workerTimes[1] * 2 = 3 seconds.
# Worker 2 reduces the height by 1, taking workerTimes[2] = 1 second.
# Since they work simultaneously, the minimum time needed is max(2, 3, 1) = 3 seconds.
#
# Example 2:
#
# Input: mountainHeight = 10, workerTimes = [3,2,2,4]
#
# Output: 12
#
# Explanation:
#
# Worker 0 reduces the height by 2, taking workerTimes[0] + workerTimes[0] * 2 = 9 seconds.
# Worker 1 reduces the height by 3, taking workerTimes[1] + workerTimes[1] * 2 + workerTimes[1] * 3 = 12 seconds.
# Worker 2 reduces the height by 3, taking workerTimes[2] + workerTimes[2] * 2 + workerTimes[2] * 3 = 12 seconds.
# Worker 3 reduces the height by 2, taking workerTimes[3] + workerTimes[3] * 2 = 12 seconds.
# The number of seconds needed is max(9, 12, 12, 12) = 12 seconds.
#
# Example 3:
#
# Input: mountainHeight = 5, workerTimes = [1]
#
# Output: 15
#
# Explanation:
#
# There is only one worker in this example, so the answer is workerTimes[0] + workerTimes[0] * 2 + workerTimes[0] * 3 + workerTimes[0] * 4 + workerTimes[0] * 5 = 15.
#
#
#
# Constraints:
#
# 1 <= mountainHeight <= 105
# 1 <= workerTimes.length <= 104
# 1 <= workerTimes[i] <= 106
# Python Binary Search O(Nlog(mountainHeight)) O(N)
class Solution:
    def canReduceHeightInTime(self, workerTimes: list[int], mountainHeight: int, maxTime: int) -> bool:
        reduced: int = 0
        for time in workerTimes:
            max_x: int = 0
            left, right = 0, mountainHeight
            while left <= right:
                middle: int = left + (right - left) // 2
                if time * (middle * (middle + 1)) // 2 <= maxTime:
                    max_x = middle
                    left = middle + 1
                else:
                    right = middle - 1
            reduced += max_x
            if reduced >= mountainHeight:return True
        return reduced >= mountainHeight

    def minNumberOfSeconds(self, mountainHeight, workerTimes):
        low, high = 0, 10**18
        while low < high:
            middle: int = low + (high - low) // 2
            if self.canReduceHeightInTime(workerTimes, mountainHeight, middle):
                high = middle
            else:
                low = middle + 1
        return low
# Python Heap O(N + mountainHeightlog(N)) O(N)
import heapq
class Solution:
    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:
        heap: list[tuple[int, int, int]] = [(time, time, 1) for time in workerTimes]
        count: int = 0
        heapq.heapify(heap)
        while mountainHeight:
            total, start, module = heapq.heappop(heap)
            count = max(count, total)
            module += 1
            heapq.heappush(heap, (total + start * module, start, module))
            mountainHeight-= 1
        return count

# 8. String to Integer (atoi)
# Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer.
#
# The algorithm for myAtoi(string s) is as follows:
#
# Whitespace: Ignore any leading whitespace (" ").
# Signedness: Determine the sign by checking if the next character is '-' or '+', assuming positivity is neither present.
# Conversion: Read the integer by skipping leading zeros until a non-digit character is encountered or the end of the string is reached. If no digits were read, then the result is 0.
# Rounding: If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then round the integer to remain in the range. Specifically, integers less than -231 should be rounded to -231, and integers greater than 231 - 1 should be rounded to 231 - 1.
# Return the integer as the final result.
#
#
#
# Example 1:
#
# Input: s = "42"
#
# Output: 42
#
# Explanation:
#
# The underlined characters are what is read in and the caret is the current reader position.
# Step 1: "42" (no characters read because there is no leading whitespace)
#          ^
# Step 2: "42" (no characters read because there is neither a '-' nor '+')
#          ^
# Step 3: "42" ("42" is read in)
#            ^
# Example 2:
#
# Input: s = " -042"
#
# Output: -42
#
# Explanation:
#
# Step 1: "   -042" (leading whitespace is read and ignored)
#             ^
# Step 2: "   -042" ('-' is read, so the result should be negative)
#              ^
# Step 3: "   -042" ("042" is read in, leading zeros ignored in the result)
#                ^
# Example 3:
#
# Input: s = "1337c0d3"
#
# Output: 1337
#
# Explanation:
#
# Step 1: "1337c0d3" (no characters read because there is no leading whitespace)
#          ^
# Step 2: "1337c0d3" (no characters read because there is neither a '-' nor '+')
#          ^
# Step 3: "1337c0d3" ("1337" is read in; reading stops because the next character is a non-digit)
#              ^
# Example 4:
#
# Input: s = "0-1"
#
# Output: 0
#
# Explanation:
#
# Step 1: "0-1" (no characters read because there is no leading whitespace)
#          ^
# Step 2: "0-1" (no characters read because there is neither a '-' nor '+')
#          ^
# Step 3: "0-1" ("0" is read in; reading stops because the next character is a non-digit)
#           ^
# Example 5:
#
# Input: s = "words and 987"
#
# Output: 0
#
# Explanation:
#
# Reading stops at the first non-digit character 'w'.
#
#
#
# Constraints:
#
# 0 <= s.length <= 200
# s consists of English letters (lower-case and upper-case), digits (0-9), ' ', '+', '-', and '.'.
class Solution:
    def bound_output(self, output: int) -> int:
        lower_bound: int = -2**31
        upper_bound: int = 2**31 - 1
        if output > upper_bound: return upper_bound
        if output < lower_bound: return lower_bound
        return output

    def myAtoi(self, s: str) -> int:
        output: int = 0
        first_sign: bool = True
        negative: bool = False
        first_digit: bool = False
        for idx in range(len(s)):
            if s[idx] == '-':
                if not first_sign or first_digit: return self.bound_output(output * [1, -1][negative])
                first_sign = False
                negative = True
                first_digit = True
            elif s[idx] == '+':
                if not first_sign or first_digit: return self.bound_output(output * [1, -1][negative])
                first_sign = False
                first_digit = True
            elif s[idx].isdigit():
                first_digit = True
                output = output * 10 + int(s[idx])
            else:
                if not first_digit and s[idx] == ' ': continue
                return self.bound_output(output * [1, -1][negative])
        return self.bound_output(output * [1, -1][negative])

# A. Square String?
# A. Square String?
# time limit per test1 second
# memory limit per test256 megabytes
# A string is called square if it is some string written twice in a row. For example, the strings "aa", "abcabc", "abab" and "baabaa" are square. But the strings "aaa", "abaaab" and "abcdabc" are not square.
#
# For a given string s
#  determine if it is square.
#
# Input
# The first line of input data contains an integer t
#  (1≤t≤100
# ) —the number of test cases.
#
# This is followed by t
#  lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1
#  and 100
#  inclusive.
#
# Output
# For each test case, output on a separate line:
#
# YES if the string in the corresponding test case is square,
# NO otherwise.
# You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).
#
# Example
# inputCopy
# 10
# a
# aa
# aaa
# aaaa
# abab
# abcabc
# abacaba
# xxyy
# xyyx
# xyxy
# outputCopy
# NO
# YES
# NO
# YES
# YES
# YES
# NO
# NO
# NO
# YES
# Python O(N) O(1) Math String
import sys


def solution(t: int) -> None:
    for _ in range(t):
        n: str = sys.stdin.readline().rstrip()
        if len(n) & 1: sys.stdout.write('NO' + '\n')
        else: sys.stdout.write(['NO', 'YES'][n[:len(n) // 2] == n[len(n) // 2:]] + '\n')


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)

# C++ O(N) O(1) String Math
#include <iostream>
#include <string>

int main() {
    size_t t;
    std::cin >> t;
    for (size_t time = 0; time < t; ++time) {
        std::string n;
        std::cin >> n;
        if (n.size() % 2 != 0) {
            std::cout << "NO" << std::endl;
            continue;
        }
        std::cout << (n.substr(0, n.size() / 2) == n.substr(n.size() / 2, n.size())? "YES" : "NO") << std::endl;
    }
}

# Split Strings
/*
Complete the solution so that it splits the string into pairs of two characters. If the string contains an odd number of characters then it should replace the missing second character of the final pair with an underscore ('_').

Examples:

* 'abc' =>  ['ab', 'c_']
* 'abcdef' => ['ab', 'cd', 'ef']
REGULAR EXPRESSIONSSTRINGSALGORITHMS
*/
#include <string>
#include <vector>

std::vector<std::string> solution(const std::string &s)
{
    std::vector<std::string> storage;
    bool is_odd = s.size() % 2 == 1;
    for (size_t index = 0; index < s.size(); index += 2) {
        std::string pair;
        if (index == s.size() - 1 && is_odd) {
            pair = s[index];
            pair += '_';
        } else {
            pair = s[index];
            pair += s[index + 1];
        }
        storage.push_back(pair);
    }
    return storage;
}

# 167. Two Sum II - Input Array Is Sorted
# Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length.
#
# Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.
#
# The tests are generated such that there is exactly one solution. You may not use the same element twice.
#
# Your solution must use only constant extra space.
#
#
#
# Example 1:
#
# Input: numbers = [2,7,11,15], target = 9
# Output: [1,2]
# Explanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2].
# Example 2:
#
# Input: numbers = [2,3,4], target = 6
# Output: [1,3]
# Explanation: The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return [1, 3].
# Example 3:
#
# Input: numbers = [-1,0], target = -1
# Output: [1,2]
# Explanation: The sum of -1 and 0 is -1. Therefore index1 = 1, index2 = 2. We return [1, 2].
#
#
# Constraints:
#
# 2 <= numbers.length <= 3 * 104
# -1000 <= numbers[i] <= 1000
# numbers is sorted in non-decreasing order.
# -1000 <= target <= 1000
# The tests are generated such that there is exactly one solution.
# Python Two Pointers O(N) O(1)
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        left: int = 0
        right: int = len(numbers) - 1
        while left < right:
            if numbers[left] + numbers[right] > target:
                right -= 1
            elif numbers[left] + numbers[right] < target:
                left += 1
            else: return [left + 1, right + 1]

# C++ Two Pointers O(N) O(1)
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int left = 0;
        int right = numbers.size() - 1;
        while (left < right) {
            if (numbers[left] + numbers[right] > target) {
                right -= 1;
            } else if (numbers[left] + numbers[right] < target) {
                left += 1;
            } else {
                return {left + 1, right + 1};
            }
        }
        return {0, 0};
    }
};

# 80. Remove Duplicates from Sorted Array II
# Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.
#
# Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.
#
# Return k after placing the final result in the first k slots of nums.
#
# Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.
#
# Custom Judge:
#
# The judge will test your solution with the following code:
#
# int[] nums = [...]; // Input array
# int[] expectedNums = [...]; // The expected answer with correct length
#
# int k = removeDuplicates(nums); // Calls your implementation
#
# assert k == expectedNums.length;
# for (int i = 0; i < k; i++) {
#     assert nums[i] == expectedNums[i];
# }
# If all assertions pass, then your solution will be accepted.
#
#
#
# Example 1:
#
# Input: nums = [1,1,1,2,2,3]
# Output: 5, nums = [1,1,2,2,3,_]
# Explanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.
# It does not matter what you leave beyond the returned k (hence they are underscores).
# Example 2:
#
# Input: nums = [0,0,1,1,1,1,2,3,3]
# Output: 7, nums = [0,0,1,1,2,3,3,_,_]
# Explanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.
# It does not matter what you leave beyond the returned k (hence they are underscores).
#
#
# Constraints:
#
# 1 <= nums.length <= 3 * 104
# -104 <= nums[i] <= 104
# nums is sorted in non-decreasing order.
# Python O(N) O(1) Two Pointers
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        left: int = 1
        if len(nums) == 1: return left
        for right in range(2, len(nums)):
            if nums[right] != nums[left - 1]:
                left += 1
                nums[left] = nums[right]
        return left + 1

# C++ O(N) O(1) Two Pointers
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int left = 1;
        if (nums.size() == 1) {
            return left;
        }
        for (int right = 2; right < nums.size(); ++right) {
            if (nums[right] != nums[left - 1]) {
                left += 1;
                nums[left] = nums[right];
            }
        }
        return left + 1;
    }
};
# Python O(N) O(1) Two Pointers
class Solution:
    def maxArea(self, height: List[int]) -> int:
        ans: int = 0
        left, right = 0, len(height) - 1
        while left < right:
            ans = max(ans, min(height[left], height[right]) * (right - left))
            if height[left] <= height[right]:
                left += 1
            else:
                right -= 1
        return ans

# C++ O(N) O(1) Two Pointers
class Solution {
public:
    int maxArea(vector<int>& height) {
        int max_volume = 0;
        int left = 0;
        int right = height.size() - 1;
        while (left < right) {
            int current_volume = (right - left) * std::min(height[left], height[right]);
            max_volume = std::max(max_volume, current_volume);
            if (height[left] <= height[right]) {
                left += 1;
            } else {
                right -= 1;
            }
        }
        return max_volume;
    }
};

# 2707. Extra Characters in a String
# You are given a 0-indexed string s and a dictionary of words dictionary. You have to break s into one or more non-overlapping substrings such that each substring is present in dictionary. There may be some extra characters in s which are not present in any of the substrings.
#
# Return the minimum number of extra characters left over if you break up s optimally.
#
#
#
# Example 1:
#
# Input: s = "leetscode", dictionary = ["leet","code","leetcode"]
# Output: 1
# Explanation: We can break s in two substrings: "leet" from index 0 to 3 and "code" from index 5 to 8. There is only 1 unused character (at index 4), so we return 1.
#
# Example 2:
#
# Input: s = "sayhelloworld", dictionary = ["hello","world"]
# Output: 3
# Explanation: We can break s in two substrings: "hello" from index 3 to 7 and "world" from index 8 to 12. The characters at indices 0, 1, 2 are not used in any substring and thus are considered as extra characters. Hence, we return 3.
#
#
# Constraints:
#
# 1 <= s.length <= 50
# 1 <= dictionary.length <= 50
# 1 <= dictionary[i].length <= 50
# dictionary[i] and s consists of only lowercase English letters
# dictionary contains distinct words
class Solution:
    def minExtraChar(self, s: str, dictionary: List[str]) -> int:
        words: set[str] = set(dictionary)
        n: int = len(s)
        dp: list[int] = [0] * (n + 1)
        for i in range(n - 1, -1, -1):
            dp[i] = dp[i + 1] + 1
            for j in range(1, n - i + 1):
                if s[i:i + j] in words:
                    dp[i] = min(dp[i], dp[i + j])
        return dp[0]

# The Office II - Boredom Score
/*
Every now and then people in the office moves teams or departments. Depending what people are doing with their time they can become more or less boring. Time to assess the current team.

You will be provided with an object(staff) containing the staff names as keys, and the department they work in as values.

Each department has a different boredom assessment score, as follows:

accounts = 1
finance = 2
canteen = 10
regulation = 3
trading = 6
change = 6
IS = 8
retail = 5
cleaning = 4
pissing about = 25

Depending on the cumulative score of the team, return the appropriate sentiment:

<=80: 'kill me now'
< 100 & > 80: 'i can handle this'
100 or over: 'party time!!'

The Office I - Outed
The Office III - Broken Photocopier
The Office IV - Find a Meeting Room
The Office V - Find a Chair

ARRAYSFUNDAMENTALS
*/
#include <map>
#include <string>

std::string boredom(const std::map<std::string, std::string> &staff){
    int total = 0;
    for (auto pair : staff) {
      if (pair.second == "accounts") {
          total += 1;
      } else if (pair.second == "finance") {
          total += 2;
      } else if (pair.second == "canteen") {
          total += 10;
      } else if (pair.second == "regulation") {
          total += 3;
      } else if (pair.second == "trading") {
          total += 6;
      } else if (pair.second == "change") {
          total += 6;
      } else if (pair.second == "IS") {
          total += 8;
      } else if (pair.second == "retail") {
          total += 5;
      } else if (pair.second == "cleaning") {
          total += 4;
      } else if (pair.second == "pissing about") {
          total += 25;
      }
    }
    return (total <= 80? "kill me now" : total < 100? "i can handle this" : "party time!!");
}

# A. Stair, Peak, or Neither?
# A. Stair, Peak, or Neither?
# time limit per test1 second
# memory limit per test256 megabytes
# You are given three digits a
# , b
# , and c
# . Determine whether they form a stair, a peak, or neither.
#
# A stair satisfies the condition a<b<c
# .
# A peak satisfies the condition a<b>c
# .
# Input
# The first line contains a single integer t
#  (1≤t≤1000
# ) — the number of test cases.
#
# The only line of each test case contains three digits a
# , b
# , c
#  (0≤a
# , b
# , c≤9
# ).
#
# Output
# For each test case, output "STAIR" if the digits form a stair, "PEAK" if the digits form a peak, and "NONE" otherwise (output the strings without quotes).
#
# Example
# inputCopy
# 7
# 1 2 3
# 3 2 1
# 1 5 3
# 3 4 1
# 0 0 0
# 4 1 7
# 4 5 7
# outputCopy
# STAIR
# NONE
# PEAK
# PEAK
# NONE
# NONE
# STAIR
# C++ O(1) O(1)
#include <iostream>

int main() {
    int t;
    std::cin >> t;
    for (size_t i = 0; i < t; ++i) {
        int a, b, c;
        std::cin >> a >> b >> c;
        std::cout << (a < b && b < c? "STAIR" : a < b && b > c? "PEAK" : "NONE") << std::endl;
    }
}
# Python O(1) O(1)
import sys


def solution(t: int) -> None:
    for _ in range(t):
        a, b, c = map(int, sys.stdin.readline().rstrip().split())
        sys.stdout.write(('STAIR' if a < b < c else 'PEAK' if a < b > c else 'NONE') + '\n')


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)

# Highest and Lowest
/*
In this little assignment you are given a string of space separated numbers, and have to return the highest and lowest number.

Examples
Input: "1 2 3 4 5"   =>  Output: "5 1"
Input: "1 2 -3 4 5"  =>  Output: "5 -3"
Input: "1 9 3 4 -5"  =>  Output: "9 -5"
Notes
All numbers are valid Int32, no need to validate them.
There will always be at least one number in the input string.
Output string must be two numbers separated by a single space, and highest number is first.
FUNDAMENTALSSTRINGS
*/
#include <string>
#include <sstream>

std::string highAndLow(const std::string& numbers){
  std::istringstream iss(numbers);
  int min_number = 10e7;
  int max_number = -10e7;
  int number;
  while (iss >> number) {
    min_number = std::min(min_number, number);
    max_number = std::max(max_number, number);
  }
  return std::to_string(max_number) + " " + std::to_string(min_number);
}

# A. Creating Words
# A. Creating Words
# time limit per test1 second
# memory limit per test256 megabytes
# Matthew is given two strings a
#  and b
# , both of length 3
# . He thinks it's particularly funny to create two new words by swapping the first character of a
#  with the first character of b
# . He wants you to output a
#  and b
#  after the swap.
#
# Note that the new words may not necessarily be different.
#
# Input
# The first line contains t
#  (1≤t≤100
# )  — the number of test cases.
#
# The first and only line of each test case contains two space-separated strings, a
#  and b
# , both of length 3
# . The strings only contain lowercase Latin letters.
#
# Output
# For each test case, after the swap, output a
#  and b
# , separated by a space.
#
# Example
# inputCopy
# 6
# bit set
# cat dog
# hot dog
# uwu owo
# cat cat
# zzz zzz
# outputCopy
# sit bet
# dat cog
# dot hog
# owu uwo
# cat cat
# zzz zzz
# Solution
# Python O(N) O(1)
import sys


def solution(t: int) -> None:
    for _ in range(t):
        a, b = sys.stdin.readline().rstrip().split()
        sys.stdout.write(b[0] + a[1:] + ' ' + a[0] + b[1:] + '\n')


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)

# C++ O(N) O(1)
#include <iostream>
#include <string>

int main() {
    int t;
    std::cin >> t;
    for (size_t i = 0; i < t; ++i) {
        std::string a, b;
        std::cin >> a >> b;
        std::cout << b[0] << a.substr(1, a.size()) << " " << a[0] << b.substr(1, b.size()) << std::endl;
    }
}

# 3043. Find the Length of the Longest Common Prefix
# You are given two arrays with positive integers arr1 and arr2.
#
# A prefix of a positive integer is an integer formed by one or more of its digits, starting from its leftmost digit. For example, 123 is a prefix of the integer 12345, while 234 is not.
#
# A common prefix of two integers a and b is an integer c, such that c is a prefix of both a and b. For example, 5655359 and 56554 have a common prefix 565 while 1223 and 43456 do not have a common prefix.
#
# You need to find the length of the longest common prefix between all pairs of integers (x, y) such that x belongs to arr1 and y belongs to arr2.
#
# Return the length of the longest common prefix among all pairs. If no common prefix exists among them, return 0.
#
#
#
# Example 1:
#
# Input: arr1 = [1,10,100], arr2 = [1000]
# Output: 3
# Explanation: There are 3 pairs (arr1[i], arr2[j]):
# - The longest common prefix of (1, 1000) is 1.
# - The longest common prefix of (10, 1000) is 10.
# - The longest common prefix of (100, 1000) is 100.
# The longest common prefix is 100 with a length of 3.
# Example 2:
#
# Input: arr1 = [1,2,3], arr2 = [4,4,4]
# Output: 0
# Explanation: There exists no common prefix for any pair (arr1[i], arr2[j]), hence we return 0.
# Note that common prefixes between elements of the same array do not count.
#
#
# Constraints:
#
# 1 <= arr1.length, arr2.length <= 5 * 104
# 1 <= arr1[i], arr2[i] <= 108
class TrieNode:
    def __init__(self) -> None:
        self.childs: dict[str, TrieNode] = dict()


class Trie:
    def __init__(self) -> None:
        self.root: TrieNode = TrieNode()

    def insert(self, value: str) -> None:
        tmp: Trie = self.root
        for char in value:
            if char not in tmp.childs:
                tmp.childs[char] = TrieNode()
            tmp = tmp.childs[char]


class Solution:
    def longest_prefix(self, root1: Trie, root2: Trie, current_depth: int, max_depth: list[int]) -> int:
        if current_depth > max_depth[0]:
            max_depth[0] = current_depth
        for char in root1.childs:
            if root2.childs.get(char):
                self.longest_prefix(root1.childs[char], root2.childs[char], current_depth + 1, max_depth)
        return max_depth[0]

    def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:
        prefix_tree1: Trie = Trie()
        prefix_tree2: Trie = Trie()
        for word in arr1:
            prefix_tree1.insert(str(word))
        for word in arr2:
            prefix_tree2.insert(str(word))
        return self.longest_prefix(prefix_tree1.root, prefix_tree2.root, 0, [0])

# 2416. Sum of Prefix Scores of Strings
# You are given an array words of size n consisting of non-empty strings.
#
# We define the score of a string word as the number of strings words[i] such that word is a prefix of words[i].
#
# For example, if words = ["a", "ab", "abc", "cab"], then the score of "ab" is 2, since "ab" is a prefix of both "ab" and "abc".
# Return an array answer of size n where answer[i] is the sum of scores of every non-empty prefix of words[i].
#
# Note that a string is considered as a prefix of itself.
#
#
#
# Example 1:
#
# Input: words = ["abc","ab","bc","b"]
# Output: [5,4,3,2]
# Explanation: The answer for each string is the following:
# - "abc" has 3 prefixes: "a", "ab", and "abc".
# - There are 2 strings with the prefix "a", 2 strings with the prefix "ab", and 1 string with the prefix "abc".
# The total is answer[0] = 2 + 2 + 1 = 5.
# - "ab" has 2 prefixes: "a" and "ab".
# - There are 2 strings with the prefix "a", and 2 strings with the prefix "ab".
# The total is answer[1] = 2 + 2 = 4.
# - "bc" has 2 prefixes: "b" and "bc".
# - There are 2 strings with the prefix "b", and 1 string with the prefix "bc".
# The total is answer[2] = 2 + 1 = 3.
# - "b" has 1 prefix: "b".
# - There are 2 strings with the prefix "b".
# The total is answer[3] = 2.
# Example 2:
#
# Input: words = ["abcd"]
# Output: [4]
# Explanation:
# "abcd" has 4 prefixes: "a", "ab", "abc", and "abcd".
# Each prefix has a score of one, so the total is answer[0] = 1 + 1 + 1 + 1 = 4.
#
#
# Constraints:
#
# 1 <= words.length <= 1000
# 1 <= words[i].length <= 1000
# words[i] consists of lowercase English letters.
# Python Trie O(NM) O(NM)
class TrieNode:
    def __init__(self) -> None:
        self.childs: dict[str, TrieNode] = dict()
        self.count: int = 0


class Trie:
    def __init__(self) -> None:
        self.root: TrieNode = TrieNode()

    def insert(self, word: str) -> None:
        tmp: TrieNode = self.root
        for char in word:
            if char not in tmp.childs:
                tmp.childs[char] = TrieNode()
            tmp = tmp.childs[char]
            tmp.count += 1


class Solution:
    def sumPrefixScores(self, words: List[str]) -> List[int]:
        prefix_tree: Trie = Trie()
        scores: list[int] = []
        for word in words:
            prefix_tree.insert(word)
        for word in words:
            current_score: int = 0
            index: int = 0
            tmp: TrieNode = prefix_tree.root
            while index < len(word):
                tmp = tmp.childs[word[index]]
                current_score += tmp.count
                index += 1
            scores.append(current_score)
        return scores

# C++ Trie O(NM) O(NM)
#include <string>
#include <vector>
#include <unordered_map>

class Solution {
public:
    struct TrieNode {
        std::unordered_map<char, TrieNode*> childs;
        int count = 0;
    };

    TrieNode* createTrie(const std::vector<std::string>& words) {
        TrieNode* root = new TrieNode();
        for (const std::string& word : words) {
            TrieNode* tmp = root;
            for (char letter : word) {
                if (tmp->childs.find(letter) == tmp->childs.end()) {
                    tmp->childs[letter] = new TrieNode();
                }
                tmp = tmp->childs[letter];
                tmp->count++;
            }
        }
        return root;
    }

    std::vector<int> sumPrefixScores(const std::vector<std::string>& words) {
        TrieNode* prefixTree = createTrie(words);
        std::vector<int> scores;
        for (const std::string& word : words) {
            TrieNode* tmp = prefixTree;
            int currentScore = 0;
            for (char letter : word) {
                tmp = tmp->childs[letter];
                currentScore += tmp->count;
            }
            scores.push_back(currentScore);
        }
        return scores;
    }
};

# B. Two Buttons
# B. Two Buttons
# time limit per test2 seconds
# memory limit per test256 megabytes
# Vasya has found a strange device. On the front panel of a device there are: a red button, a blue button and a display showing some positive integer. After clicking the red button, device multiplies the displayed number by two. After clicking the blue button, device subtracts one from the number on the display. If at some point the number stops being positive, the device breaks down. The display can show arbitrarily large numbers. Initially, the display shows number n.
#
# Bob wants to get number m on the display. What minimum number of clicks he has to make in order to achieve this result?
#
# Input
# The first and the only line of the input contains two distinct integers n and m (1 ≤ n, m ≤ 104), separated by a space .
#
# Output
# Print a single number — the minimum number of times one needs to push the button required to get the number m out of number n.
#
# Examples
# inputCopy
# 4 6
# outputCopy
# 2
# inputCopy
# 10 1
# outputCopy
# 9
# Note
# In the first example you need to push the blue button once, and then push the red button once.
#
# In the second example, doubling the number is unnecessary, so we need to push the blue button nine times.
import sys
from collections import deque

def min_operations(n: int, m: int) -> int:
    if n >= m: return n - m
    queue = deque([(n, 0)])
    visited = set()
    min_count: int = 10**5
    while queue:
        current, steps = queue.popleft()
        if current >= m:
            min_count = min(min_count, steps + (current - m))
            continue
        next_double = current * 2
        if next_double not in visited and next_double <= 2 * m:  # Limit to avoid unnecessary large numbers
            visited.add(next_double)
            queue.append((next_double, steps + 1))
        next_decrement = current - 1
        if next_decrement >= 0 and next_decrement not in visited:
            visited.add(next_decrement)
            queue.append((next_decrement, steps + 1))
    return min_count

if __name__ == '__main__':
    n, m = map(int, sys.stdin.readline().rstrip().split())
    result = min_operations(n, m)
    sys.stdout.write(str(result) + '\n')

# V A P O R C O D E
/*
ASC Week 1 Challenge 4 (Medium #1)

Write a function that converts any sentence into a V A P O R W A V E sentence. a V A P O R W A V E sentence converts all the letters into uppercase, and adds 2 spaces between each letter (or special character) to create this V A P O R W A V E effect.

Note that spaces should be ignored in this case.

Examples
"Lets go to the movies"       -->  "L  E  T  S  G  O  T  O  T  H  E  M  O  V  I  E  S"
"Why isn't my code working?"  -->  "W  H  Y  I  S  N  '  T  M  Y  C  O  D  E  W  O  R  K  I  N  G  ?"
FUNDAMENTALS
*/
#include<string>

std::string vaporcode(const std::string &str) {
  std::string output = "";
  for (size_t index = 0; index < str.size(); ++index) {
    if (str[index] == ' ') {
      continue;
    }
    if (output.size()) {
      output += "  ";
    }
    output += std::toupper(str[index]);
  }
  return output;
}

# 729. My Calendar I
# You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a double booking.
#
# A double booking happens when two events have some non-empty intersection (i.e., some moment is common to both events.).
#
# The event can be represented as a pair of integers start and end that represents a booking on the half-open interval [start, end), the range of real numbers x such that start <= x < end.
#
# Implement the MyCalendar class:
#
# MyCalendar() Initializes the calendar object.
# boolean book(int start, int end) Returns true if the event can be added to the calendar successfully without causing a double booking. Otherwise, return false and do not add the event to the calendar.
#
#
# Example 1:
#
# Input
# ["MyCalendar", "book", "book", "book"]
# [[], [10, 20], [15, 25], [20, 30]]
# Output
# [null, true, false, true]
#
# Explanation
# MyCalendar myCalendar = new MyCalendar();
# myCalendar.book(10, 20); // return True
# myCalendar.book(15, 25); // return False, It can not be booked because time 15 is already booked by another event.
# myCalendar.book(20, 30); // return True, The event can be booked, as the first event takes every time less than 20, but not including 20.
#
#
# Constraints:
#
# 0 <= start < end <= 109
# At most 1000 calls will be made to book.
from sortedcontainers import SortedList

class MyCalendar:
    def __init__(self) -> None:
        self.calendar: list[tuple[int, int]] = SortedList()

    def book(self, start: int, end: int) -> bool:
        if not self.calendar:
            self.calendar.add((start, end))
            return True
        if (start, end) in self.calendar: return False
        previous: int = self.calendar.bisect_left((start, end)) - 1
        nxt: int = self.calendar.bisect_right((start, end))
        if (
            (previous == -1 or self.calendar[previous][1] <= start)
            and (nxt == len(self.calendar) or self.calendar[nxt][0] >= end)
        ):
            self.calendar.add((start, end))
            return True
        return False

# A. Polycarp and Coins
# A. Polycarp and Coins
# time limit per test1 second
# memory limit per test256 megabytes
# Polycarp must pay exactly n
#  burles at the checkout. He has coins of two nominal values: 1
#  burle and 2
#  burles. Polycarp likes both kinds of coins equally. So he doesn't want to pay with more coins of one type than with the other.
#
# Thus, Polycarp wants to minimize the difference between the count of coins of 1
#  burle and 2
#  burles being used. Help him by determining two non-negative integer values c1
#  and c2
#  which are the number of coins of 1
#  burle and 2
#  burles, respectively, so that the total value of that number of coins is exactly n
#  (i. e. c1+2⋅c2=n
# ), and the absolute value of the difference between c1
#  and c2
#  is as little as possible (i. e. you must minimize |c1−c2|
# ).
#
# Input
# The first line contains one integer t
#  (1≤t≤104
# ) — the number of test cases. Then t
#  test cases follow.
#
# Each test case consists of one line. This line contains one integer n
#  (1≤n≤109
# ) — the number of burles to be paid by Polycarp.
#
# Output
# For each test case, output a separate line containing two integers c1
#  and c2
#  (c1,c2≥0
# ) separated by a space where c1
#  is the number of coins of 1
#  burle and c2
#  is the number of coins of 2
#  burles. If there are multiple optimal solutions, print any one.
#
# Example
# inputCopy
# 6
# 1000
# 30
# 1
# 32
# 1000000000
# 5
# outputCopy
# 334 333
# 10 10
# 1 0
# 10 11
# 333333334 333333333
# 1 2
# Note
# The answer for the first test case is "334 333". The sum of the nominal values of all coins is 334⋅1+333⋅2=1000
# , whereas |334−333|=1
# . One can't get the better value because if |c1−c2|=0
# , then c1=c2
#  and c1⋅1+c1⋅2=1000
# , but then the value of c1
#  isn't an integer.
#
# The answer for the second test case is "10 10". The sum of the nominal values is 10⋅1+10⋅2=30
#  and |10−10|=0
# , whereas there's no number having an absolute value less than 0
# .
import sys


def solution(t: int) -> None:
    for _ in range(t):
        n: int = int(sys.stdin.readline().rstrip())
        c2 = n // 3
        c1 = n - 2 * c2
        if c1 >= 0:
            best_c1, best_c2 = c1, c2
        else:
            best_c1, best_c2 = 0, 0
        c2 += 1
        c1 = n - 2 * c2
        if c1 >= 0 and abs(c1 - c2) < abs(best_c1 - best_c2):
            best_c1, best_c2 = c1, c2
        sys.stdout.write(str(best_c1) + ' ' + str(best_c2) + '\n')


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)


# Switch on the Gravity
# Given a 2D array of some suspended blocks (represented as hastags), return another 2D array which shows the end result once gravity is switched on.
#
# Examples
# switch_gravity([
#   ["-", "#", "#", "-"],
#   ["-", "-", "-", "-"],
#   ["-", "-", "-", "-"],
#   ["-", "-", "-", "-"]
# ]) ➞ [
#   ["-", "-", "-", "-"],
#   ["-", "-", "-", "-"],
#   ["-", "-", "-", "-"],
#   ["-", "#", "#", "-"]
# ]
#
# switch_gravity([
#   ["-", "#", "#", "-"],
#   ["-", "-", "#", "-"],
#   ["-", "-", "-", "-"],
# ]) ➞ [
#   ["-", "-", "-", "-"],
#   ["-", "-", "#", "-"],
#   ["-", "#", "#", "-"]
# ]
#
# switch_gravity([
#   ["-", "#", "#", "#", "#", "-"],
#   ["#", "-", "-", "#", "#", "-"],
#   ["-", "#", "-", "-", "-", "-"],
#   ["-", "-", "-", "-", "-", "-"]
# ]) ➞ [
#   ["-", "-", "-", "-", "-", "-"],
#   ["-", "-", "-", "-", "-", "-"],
#   ["-", "#", "-", "#", "#", "-"],
#   ["#", "#", "#", "#", "#", "-"]
# ]
# Notes
# Each block falls individually, meaning there are no rigid objects. Think about it like falling sand in Minecraft as opposed to the rigid blocks in Tetris.
#
# ALGORITHMSMATRIXARRAYS
def switch_gravity(lst):
    for cur_col in range(len(lst[0])):
        cur_row: int = len(lst) - 1
        while cur_row >= 0 and lst[cur_row][cur_col] == '#':
            cur_row -= 1
        if cur_row < 0: continue
        for row in range(cur_row, -1, -1):
            if lst[row][cur_col] == '#':
                lst[cur_row][cur_col], lst[row][cur_col] = lst[row][cur_col], lst[cur_row][cur_col]
                cur_row -= 1
    return lst

# 731. My Calendar II
# You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a triple booking.
#
# A triple booking happens when three events have some non-empty intersection (i.e., some moment is common to all the three events.).
#
# The event can be represented as a pair of integers start and end that represents a booking on the half-open interval [start, end), the range of real numbers x such that start <= x < end.
#
# Implement the MyCalendarTwo class:
#
# MyCalendarTwo() Initializes the calendar object.
# boolean book(int start, int end) Returns true if the event can be added to the calendar successfully without causing a triple booking. Otherwise, return false and do not add the event to the calendar.
#
#
# Example 1:
#
# Input
# ["MyCalendarTwo", "book", "book", "book", "book", "book", "book"]
# [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]
# Output
# [null, true, true, true, false, true, true]
#
# Explanation
# MyCalendarTwo myCalendarTwo = new MyCalendarTwo();
# myCalendarTwo.book(10, 20); // return True, The event can be booked.
# myCalendarTwo.book(50, 60); // return True, The event can be booked.
# myCalendarTwo.book(10, 40); // return True, The event can be double booked.
# myCalendarTwo.book(5, 15);  // return False, The event cannot be booked, because it would result in a triple booking.
# myCalendarTwo.book(5, 10); // return True, The event can be booked, as it does not use time 10 which is already double booked.
# myCalendarTwo.book(25, 55); // return True, The event can be booked, as the time in [25, 40) will be double booked with the third event, the time [40, 50) will be single booked, and the time [50, 55) will be double booked with the second event.
#
#
# Constraints:
#
# 0 <= start < end <= 109
# At most 1000 calls will be made to book.
class MyCalendarTwo:
    def __init__(self) -> None:
        self.bookings: list[tuple[int, int]] = []
        self.overlap_bookings: list[tuple[int, int]] = []

    def book(self, start: int, end: int) -> bool:
        if self.check_for_overlapping(start, end): return False
        for booking in self.bookings:
            if self.does_overlap(booking[0], booking[1], start, end):
                self.overlap_bookings.append(
                    self.get_overlapped(booking[0], booking[1], start, end)
                )
        self.bookings.append((start, end))
        return True

    def check_for_overlapping(self, start: int, end: int) -> bool:
        return any(self.does_overlap(booking[0], booking[1], start, end) for booking in self.overlap_bookings)

    def does_overlap(
        self, start1: int, end1: int, start2: int, end2: int
    ) -> bool:
        return max(start1, start2) < min(end1, end2)

    def get_overlapped(
        self, start1: int, end1: int, start2: int, end2: int
    ) -> tuple[int, int]:
        return (max(start1, start2), min(end1, end2))

# Indexed capitalization
/*
Given a string and an array of integers representing indices, capitalize all letters at the given indices.

For example:

capitalize("abcdef",[1,2,5]) = "aBCdeF"
capitalize("abcdef",[1,2,5,100]) = "aBCdeF". There is no index 100.
The input will be a lowercase string with no spaces and an array of digits.

Good luck!

Be sure to also try:

Alternate capitalization

String array revisal

FUNDAMENTALS
*/
std::string capitalize(std::string s, std::vector<int> idxs)
{
  for (int index : idxs) {
    if (index >= s.size()) {
      continue;
    }
    s[index] = std::toupper(s[index]);
  }
  return s;
}

# A. Minimal Square
# A. Minimal Square
# time limit per test2 seconds
# memory limit per test256 megabytes
# Find the minimum area of a square land on which you can place two identical rectangular a×b
#  houses. The sides of the houses should be parallel to the sides of the desired square land.
#
# Formally,
#
# You are given two identical rectangles with side lengths a
#  and b
#  (1≤a,b≤100
# ) — positive integers (you are given just the sizes, but not their positions).
# Find the square of the minimum area that contains both given rectangles. Rectangles can be rotated (both or just one), moved, but the sides of the rectangles should be parallel to the sides of the desired square.
# Two rectangles can touch each other (side or corner), but cannot intersect. Rectangles can also touch the sides of the square but must be completely inside it. You can rotate the rectangles. Take a look at the examples for a better understanding.
#
# The picture shows a square that contains red and green rectangles.
# Input
# The first line contains an integer t
#  (1≤t≤10000
# ) —the number of test cases in the input. Then t
#  test cases follow.
#
# Each test case is a line containing two integers a
# , b
#  (1≤a,b≤100
# ) — side lengths of the rectangles.
#
# Output
# Print t
#  answers to the test cases. Each answer must be a single integer — minimal area of square land, that contains two rectangles with dimensions a×b
# .
#
# Example
# inputCopy
# 8
# 3 2
# 4 2
# 1 1
# 3 1
# 4 7
# 1 3
# 7 4
# 100 100
# outputCopy
# 16
# 16
# 4
# 9
# 64
# 9
# 64
# 40000
# Note
# Below are the answers for the first two test cases:
#include <iostream>
#include <cmath>

int main() {
    int t;
    std::cin >> t;
    for (size_t rep = 0; rep < t; ++rep) {
        int a, b;
        std::cin >> a >> b;
        int remainder = std::min(a, b) * 2;
        if (remainder < std::max(a, b)) {
            remainder = std::max(a, b);
        };
        std::cout << std::pow(remainder, 2) << std::endl;
    }
};

# 641. Design Circular Deque
# Design your implementation of the circular double-ended queue (deque).
#
# Implement the MyCircularDeque class:
#
# MyCircularDeque(int k) Initializes the deque with a maximum size of k.
# boolean insertFront() Adds an item at the front of Deque. Returns true if the operation is successful, or false otherwise.
# boolean insertLast() Adds an item at the rear of Deque. Returns true if the operation is successful, or false otherwise.
# boolean deleteFront() Deletes an item from the front of Deque. Returns true if the operation is successful, or false otherwise.
# boolean deleteLast() Deletes an item from the rear of Deque. Returns true if the operation is successful, or false otherwise.
# int getFront() Returns the front item from the Deque. Returns -1 if the deque is empty.
# int getRear() Returns the last item from Deque. Returns -1 if the deque is empty.
# boolean isEmpty() Returns true if the deque is empty, or false otherwise.
# boolean isFull() Returns true if the deque is full, or false otherwise.
#
#
# Example 1:
#
# Input
# ["MyCircularDeque", "insertLast", "insertLast", "insertFront", "insertFront", "getRear", "isFull", "deleteLast", "insertFront", "getFront"]
# [[3], [1], [2], [3], [4], [], [], [], [4], []]
# Output
# [null, true, true, true, false, 2, true, true, true, 4]
#
# Explanation
# MyCircularDeque myCircularDeque = new MyCircularDeque(3);
# myCircularDeque.insertLast(1);  // return True
# myCircularDeque.insertLast(2);  // return True
# myCircularDeque.insertFront(3); // return True
# myCircularDeque.insertFront(4); // return False, the queue is full.
# myCircularDeque.getRear();      // return 2
# myCircularDeque.isFull();       // return True
# myCircularDeque.deleteLast();   // return True
# myCircularDeque.insertFront(4); // return True
# myCircularDeque.getFront();     // return 4
#
#
# Constraints:
#
# 1 <= k <= 1000
# 0 <= value <= 1000
# At most 2000 calls will be made to insertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull.
# Python Double Linked List Design O(1) O(k)
class ListNode:
    def __init__(self, value: int, next_: ListNode = None, prev: ListNode = None) -> None:
        self.value: int = value
        self.next: ListNode = next_
        self.prev: ListNode = prev


class MyCircularDeque:

    def __init__(self, k: int):
        self.capacity: int = k
        self.size: int = 0
        self.head: ListNode = None
        self.tail: ListNode = self.head

    def insertFront(self, value: int) -> bool:
        if self.isFull(): return False
        if not self.size:
            self.head = ListNode(value=value)
            self.tail = self.head
            self.head.next = self.tail
            self.tail.prev = self.head
        else:
            self.head = ListNode(value=value, next_=self.head, prev=self.tail)
            self.head.next.prev = self.head
            self.tail.next = self.head
        self.size += 1
        return True

    def insertLast(self, value: int) -> bool:
        if self.isFull(): return False
        if not self.size:
            self.head = ListNode(value=value)
            self.tail = self.head
            self.head.next = self.tail
            self.tail.prev = self.head
        else:
            self.tail.next = ListNode(value=value, next_=self.head, prev=self.tail)
            self.tail = self.tail.next
            self.head.prev = self.tail
        self.size += 1
        return True

    def deleteFront(self) -> bool:
        if self.isEmpty(): return False
        if self.size == 1:
            self.head = None
            self.tail = self.head
        else:
            self.head = self.head.next
            self.head.prev = self.tail
            self.tail.next = self.head
        self.size -= 1
        return True

    def deleteLast(self) -> bool:
        if self.isEmpty(): return False
        if self.size == 1:
            self.head = None
            self.tail = self.head
        else:
            self.tail = self.tail.prev
            self.tail.next = self.head
            self.head.prev = self.tail
        self.size -= 1
        return True

    def getFront(self) -> int:
        if self.isEmpty(): return -1
        return self.head.value

    def getRear(self) -> int:
        if self.isEmpty(): return -1
        return self.tail.value

    def isEmpty(self) -> bool:
        return self.size == 0

    def isFull(self) -> bool:
        return self.size == self.capacity

# Your MyCircularDeque object will be instantiated and called as such:
# obj = MyCircularDeque(k)
# param_1 = obj.insertFront(value)
# param_2 = obj.insertLast(value)
# param_3 = obj.deleteFront()
# param_4 = obj.deleteLast()
# param_5 = obj.getFront()
# param_6 = obj.getRear()
# param_7 = obj.isEmpty()
# param_8 = obj.isFull()

# C++ O(1) O(k) Double Linked List
class DoubleListNode {
public:
    int value;
    DoubleListNode* next;
    DoubleListNode* prev;
    DoubleListNode(int val, DoubleListNode* nextNode = nullptr, DoubleListNode* prevNode = nullptr)
        : value(val), next(nextNode), prev(prevNode) {}
};
class MyCircularDeque {
private:
    int capacity;
    int size;
    DoubleListNode* head;
    DoubleListNode* tail;

public:
    MyCircularDeque(int k) : capacity(k), size(0), head(nullptr), tail(nullptr) {}

    bool insertFront(int value) {
        if (isFull()) {
            return false;
        }
        DoubleListNode* newNode = new DoubleListNode(value);
        if (isEmpty()) {
            head = tail = newNode;
            head->next = head;
            head->prev = head;
        } else {
            newNode->next = head;
            newNode->prev = tail;
            head->prev = newNode;
            tail->next = newNode;
            head = newNode;
        }
        size++;
        return true;
    }

    bool insertLast(int value) {
        if (isFull()) {
            return false;
        }
        DoubleListNode* newNode = new DoubleListNode(value);
        if (isEmpty()) {
            head = tail = newNode;
            head->next = head;
            head->prev = head;
        } else {
            newNode->prev = tail;
            newNode->next = head;
            tail->next = newNode;
            head->prev = newNode;
            tail = newNode;
        }
        size++;
        return true;
    }
    bool deleteFront() {
        if (isEmpty()) {
            return false;
        }
        if (size == 1) {
            delete head;
            head = tail = nullptr;
        } else {
            DoubleListNode* toDelete = head;
            head = head->next;
            head->prev = tail;
            tail->next = head;
            delete toDelete;
        }
        size--;
        return true;
    }

    bool deleteLast() {
        if (isEmpty()) {
            return false;
        }
        if (size == 1) {
            delete head;
            head = tail = nullptr;
        } else {
            DoubleListNode* toDelete = tail;
            tail = tail->prev;
            tail->next = head;
            head->prev = tail;
            delete toDelete;
        };
        size--;
        return true;
    }

    int getFront() {
        if (isEmpty()) {
            return -1;
        };
        return head->value;
    }

    int getRear() {
        if (isEmpty()) {
            return -1;
        };
        return tail->value;
    }

    bool isEmpty() {
        return size == 0;
    }

    bool isFull() {
        return size == capacity;
    }
};

/**
 * Your MyCircularDeque object will be instantiated and called as such:
 * MyCircularDeque* obj = new MyCircularDeque(k);
 * bool param_1 = obj->insertFront(value);
 * bool param_2 = obj->insertLast(value);
 * bool param_3 = obj->deleteFront();
 * bool param_4 = obj->deleteLast();
 * int param_5 = obj->getFront();
 * int param_6 = obj->getRear();
 * bool param_7 = obj->isEmpty();
 * bool param_8 = obj->isFull();
 */

# A. Love Story
# A. Love Story
# time limit per test1 second
# memory limit per test256 megabytes
# Timur loves codeforces. That's why he has a string s
#  having length 10
#  made containing only lowercase Latin letters. Timur wants to know how many indices string s
#  differs from the string "codeforces".
#
# For example string s=
#  "coolforsez" differs from "codeforces" in 4
#  indices, shown in bold.
#
# Help Timur by finding the number of indices where string s
#  differs from "codeforces".
#
# Note that you can't reorder the characters in the string s
# .
#
# Input
# The first line contains a single integer t
#  (1≤t≤1000
# ) — the number of test cases.
#
# Each test case is one line and contains the string s
# , consisting of exactly 10
#  lowercase Latin characters.
#
# Output
# For each test case, output a single integer — the number of indices where string s
#  differs.
#
# Example
# inputCopy
# 5
# coolforsez
# cadafurcie
# codeforces
# paiuforces
# forcescode
# outputCopy
# 4
# 5
# 0
# 4
# 9
# C++ O(1) O(1) String
#include <iostream>
#include <string>

int main() {
    int t;
    std::cin >> t;
    std::string valid = "codeforces";
    for (int rep = 0; rep < t; ++rep) {
        std::string n;
        std::cin >> n;
        int count = 0;
        for (size_t index = 0; index < valid.size(); ++index) {
            if (valid[index] != n[index]) {
                count++;
            }
        };
        std::cout << count << std::endl;
    }
}

# Python O(1) O(1) String
import sys


def solution(t: int) -> None:
    for _ in range(t):
        n: str = sys.stdin.readline().rstrip()
        sys.stdout.write(str(sum(n[idx] != 'codeforces'[idx] for idx in range(10))) + '\n')


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)

# From..To..Series #3: from char a to char b. Find a substring that contains most char c
# Description:
# Give you a string s, find a substring that starting with character a and ending with character b and contains most numbers of character c.
#
# Please note:
#
# The characters in the string can be: letters(a-z,A-Z), numbers(0-9), some punctuation marks(,.()[]{}) and space;
#
# a,b and c are three diffrent characters;
#
# Characters a and b can not appear in the middle of the substring;
#
# You should count the numbers of character c in the substring, instead of the length of the substring;
#
# A valid substring is only can from a to b, the substring from b to a is invalid;
#
# If more than one substring found, returns the first result(from left to right).
#
# If string s doesn't contains such a substring(from a to b and contains c), return "".
#
# Examples
# s="abacbaccb", a = "a", b = "b", c = "c"
# findSub(s,a,b,c) === "accb"
#
# s="abacbaccbbccca", a = "a", b = "b", c = "c"
# findSub(s,a,b,c) === "accb"
#
# s="x.z.z.yxzzzy", a = "x", b = "y", c = "z"
# findSub(s,a,b,c) === "xzzzy"
#
# s="x.z.z.z.yxzzzy", a = "x", b = "y", c = "z"
# findSub(s,a,b,c) === "x.z.z.z.y"
#
# s="xyx.yx..y", a = "x", b = "y", c = "z"
# findSub(s,a,b,c) === ""
#
# s="((( )))((  ))", a = "(", b = ")", c = " "
# findSub(s,a,b,c) === "(  )"
# FUNDAMENTALS
def find_sub(s, a, b, c):
    output: str = ''
    count_output: int = 0
    a_idx: int = 0
    c_count: int = 0
    is_valid: bool = False
    for b_idx in range(len(s)):
        if s[b_idx] == a:
            if is_valid:
                c_count = 0
                a_idx = b_idx
            else:
                a_idx = b_idx
                is_valid = True
        if s[b_idx] == b:
            if not is_valid: continue
            if c_count > count_output:
                count_output = c_count
                output = s[a_idx:b_idx + 1]
            c_count = 0
            is_valid = False
        elif s[b_idx] == c and is_valid: c_count += 1
    return output

# 2410. Maximum Matching of Players With Trainers
# You are given a 0-indexed integer array players, where players[i] represents the ability of the ith player. You are also given a 0-indexed integer array trainers, where trainers[j] represents the training capacity of the jth trainer.
#
# The ith player can match with the jth trainer if the player's ability is less than or equal to the trainer's training capacity. Additionally, the ith player can be matched with at most one trainer, and the jth trainer can be matched with at most one player.
#
# Return the maximum number of matchings between players and trainers that satisfy these conditions.
#
#
#
# Example 1:
#
# Input: players = [4,7,9], trainers = [8,2,5,8]
# Output: 2
# Explanation:
# One of the ways we can form two matchings is as follows:
# - players[0] can be matched with trainers[0] since 4 <= 8.
# - players[1] can be matched with trainers[3] since 7 <= 8.
# It can be proven that 2 is the maximum number of matchings that can be formed.
# Example 2:
#
# Input: players = [1,1,1], trainers = [10]
# Output: 1
# Explanation:
# The trainer can be matched with any of the 3 players.
# Each player can only be matched with one trainer, so the maximum answer is 1.
#
#
# Constraints:
#
# 1 <= players.length, trainers.length <= 105
# 1 <= players[i], trainers[j] <= 109
#
#
# Note: This question is the same as 445: Assign Cookies.
# Python O(NlogN) O(1) Two Pointers Sorting Greedy
class Solution:
    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:
        players.sort()
        trainers.sort()
        left: int = 0
        right: int = 0
        while left < len(players) and right < len(trainers):
            if players[left] <= trainers[right]:
                left += 1
            right += 1
        return left

# C++ O(NlogN) O(1) Two Pointers Sorting Greedy
class Solution {
public:
    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {
        size_t left = 0;
        size_t right = 0;
        int content = 0;
        std::sort(players.begin(), players.end());
        std::sort(trainers.begin(), trainers.end());
        while (left < players.size() && right < trainers.size()) {
            if (players[left] <= trainers[right]) {
                content++;
                left++;
            }
            right++;
        }
        return content;
    }
};

# 432. All O`one Data Structure
# Design a data structure to store the strings' count with the ability to return the strings with minimum and maximum counts.
#
# Implement the AllOne class:
#
# AllOne() Initializes the object of the data structure.
# inc(String key) Increments the count of the string key by 1. If key does not exist in the data structure, insert it with count 1.
# dec(String key) Decrements the count of the string key by 1. If the count of key is 0 after the decrement, remove it from the data structure. It is guaranteed that key exists in the data structure before the decrement.
# getMaxKey() Returns one of the keys with the maximal count. If no element exists, return an empty string "".
# getMinKey() Returns one of the keys with the minimum count. If no element exists, return an empty string "".
# Note that each function must run in O(1) average time complexity.
#
#
#
# Example 1:
#
# Input
# ["AllOne", "inc", "inc", "getMaxKey", "getMinKey", "inc", "getMaxKey", "getMinKey"]
# [[], ["hello"], ["hello"], [], [], ["leet"], [], []]
# Output
# [null, null, null, "hello", "hello", null, "hello", "leet"]
#
# Explanation
# AllOne allOne = new AllOne();
# allOne.inc("hello");
# allOne.inc("hello");
# allOne.getMaxKey(); // return "hello"
# allOne.getMinKey(); // return "hello"
# allOne.inc("leet");
# allOne.getMaxKey(); // return "hello"
# allOne.getMinKey(); // return "leet"
#
#
# Constraints:
#
# 1 <= key.length <= 10
# key consists of lowercase English letters.
# It is guaranteed that for each call to dec, key is existing in the data structure.
# At most 5 * 104 calls will be made to inc, dec, getMaxKey, and getMinKey.
# Python O(1) O(N) HashMap Double Linked List
class DoubleLinkedNode:
    def __init__(
            self,
            freq: int = 0,
            prev=None,
            next=None
    ) -> None:
        self.freq: int = freq
        self.prev: DoubleLinkedNode = prev
        self.next: DoubleLinkedNode = next
        self.keys: set[str] = set()


class AllOne:
    def __init__(self):
        self.hashmap: dict[str, DoubleLinkedNode] = dict()
        self.head: DoubleLinkedNode = DoubleLinkedNode()
        self.tail: DoubleLinkedNode = DoubleLinkedNode()
        self.head.next = self.tail
        self.tail.prev = self.head

    def inc(self, key: str) -> None:
        if key in self.hashmap:
            node: DoubleLinkedNode = self.hashmap[key]
            node.keys.remove(key)
            if not node.next or node.next.freq != node.freq + 1:
                node.next = DoubleLinkedNode(node.freq + 1, node, node.next)
                node.next.next.prev = node.next
            node.next.keys.add(key)
            self.hashmap[key] = node.next
            if not node.keys:
                node.next.prev = node.prev
                node.prev.next = node.next
        else:
            if not self.head.next or self.head.next.freq != 1:
                self.head.next = DoubleLinkedNode(1, self.head, self.head.next)
                self.head.next.next.prev = self.head.next
            self.head.next.keys.add(key)
            self.hashmap[key] = self.head.next

    def dec(self, key: str) -> None:
        if key not in self.hashmap: return
        node: DoubleLinkedNode = self.hashmap[key]
        node.keys.remove(key)
        if node.freq == 1:
            if not node.keys:
                node.prev.next = node.next
                node.next.prev = node.prev
            del self.hashmap[key]
            return
        if not node.prev or node.prev.freq != node.freq - 1:
            node.prev = DoubleLinkedNode(node.freq - 1, node.prev, node)
            node.prev.prev.next = node.prev
        node.prev.keys.add(key)
        self.hashmap[key] = node.prev
        if not node.keys:
            node.prev.next = node.next
            node.next.prev = node.prev

    def getMaxKey(self) -> str:
        if self.tail.prev.freq: return next(iter(self.tail.prev.keys))
        return ''

    def getMinKey(self) -> str:
        if self.head.next.freq: return next(iter(self.head.next.keys))
        return ''

# Your AllOne object will be instantiated and called as such:
# obj = AllOne()
# obj.inc(key)
# obj.dec(key)
# param_3 = obj.getMaxKey()
# param_4 = obj.getMinKey()

# C++ O(1) O(N) HashMap Double Linked List
#include <iostream>
#include <unordered_map>
#include <unordered_set>
#include <string>

class DoubleLinkedNode {
public:
    int freq;
    DoubleLinkedNode* prev;
    DoubleLinkedNode* next;
    std::unordered_set<std::string> keys;

    DoubleLinkedNode(int frequency = 0, DoubleLinkedNode* previous = nullptr, DoubleLinkedNode* nextNode = nullptr)
        : freq(frequency), prev(previous), next(nextNode) {}
};

class AllOne {
public:
    std::unordered_map<std::string, DoubleLinkedNode*> hashmap;
    DoubleLinkedNode* head;
    DoubleLinkedNode* tail;

    AllOne() {
        head = new DoubleLinkedNode();
        tail = new DoubleLinkedNode();
        head->next = tail;
        tail->prev = head;
    }

    void inc(std::string key) {
        if (hashmap.count(key)) {
            DoubleLinkedNode* node = hashmap[key];
            node->keys.erase(key);

            if (!node->next || node->next->freq != node->freq + 1) {
                DoubleLinkedNode* new_node = new DoubleLinkedNode(node->freq + 1, node, node->next);
                node->next->prev = new_node;
                node->next = new_node;
            }
            node->next->keys.insert(key);
            hashmap[key] = node->next;

            if (node->keys.empty()) {
                removeNode(node);
            }
        } else {
            if (head->next == tail || head->next->freq != 1) {
                DoubleLinkedNode* new_node = new DoubleLinkedNode(1, head, head->next);
                head->next->prev = new_node;
                head->next = new_node;
            }
            head->next->keys.insert(key);
            hashmap[key] = head->next;
        }
    }

    void dec(std::string key) {
        if (!hashmap.count(key)) return;

        DoubleLinkedNode* node = hashmap[key];
        node->keys.erase(key);
        if (node->freq == 1) {
            hashmap.erase(key);
            if (node->keys.empty()) {
                removeNode(node);
            }
            return;
        }

        if (!node->prev || node->prev->freq != node->freq - 1) {
            DoubleLinkedNode* new_node = new DoubleLinkedNode(node->freq - 1, node->prev, node);
            node->prev->next = new_node;
            node->prev = new_node;
        }
        node->prev->keys.insert(key);
        hashmap[key] = node->prev;

        if (node->keys.empty()) {
            removeNode(node);
        }
    }

    std::string getMaxKey() {
        if (tail->prev != head) {
            return *(tail->prev->keys.begin());
        }
        return "";
    }

    std::string getMinKey() {
        if (head->next != tail) {
            return *(head->next->keys.begin());
        }
        return "";
    }

private:
    void removeNode(DoubleLinkedNode* node) {
        node->prev->next = node->next;
        node->next->prev = node->prev;
        delete node;
    }
};


/**
 * Your AllOne object will be instantiated and called as such:
 * AllOne* obj = new AllOne();
 * obj->inc(key);
 * obj->dec(key);
 * string param_3 = obj->getMaxKey();
 * string param_4 = obj->getMinKey();
 */

# A. Spell Check
# A. Spell Check
# time limit per test1 second
# memory limit per test256 megabytes
# Timur likes his name. As a spelling of his name, he allows any permutation of the letters of the name. For example, the following strings are valid spellings of his name: Timur, miurT, Trumi, mriTu. Note that the correct spelling must have uppercased T and lowercased other letters.
#
# Today he wrote string s
#  of length n
#  consisting only of uppercase or lowercase Latin letters. He asks you to check if s
#  is the correct spelling of his name.
#
# Input
# The first line of the input contains an integer t
#  (1≤t≤103
# ) — the number of test cases.
#
# The first line of each test case contains an integer n
#  (1≤n≤10)
#  — the length of string s
# .
#
# The second line of each test case contains a string s
#  consisting of only uppercase or lowercase Latin characters.
#
# Output
# For each test case, output "YES" (without quotes) if s
#  satisfies the condition, and "NO" (without quotes) otherwise.
#
# You can output the answer in any case (for example, the strings "yEs", "yes", "Yes" and "YES" will be recognized as a positive answer).
#
# Example
# inputCopy
# 10
# 5
# Timur
# 5
# miurT
# 5
# Trumi
# 5
# mriTu
# 5
# timur
# 4
# Timr
# 6
# Timuur
# 10
# codeforces
# 10
# TimurTimur
# 5
# TIMUR
# outputCopy
# YES
# YES
# YES
# YES
# NO
# NO
# NO
# NO
# NO
# NO
# Python O(NlogN) O(N)
import sys


def solution(t: int) -> None:
    valid: list = sorted('Timur')
    for _ in range(t):
        n: int = int(sys.stdin.readline().rstrip())
        word: str = sys.stdin.readline().rstrip()
        sys.stdout.write(['NO', 'YES'][valid == sorted(word)] + '\n')


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)

# C++ O(NlogN) O(1)
#include <iostream>
#include <string>
#include <algorithm>

int main() {
    size_t t;
    std::cin >> t;
    std::string valid = "Timur";
    std::sort(valid.begin(), valid.end());
    for (size_t rep = 0; rep < t; ++rep) {
        int n;
        std::cin >> n;
        std::string name;
        std::cin >> name;
        std::sort(name.begin(), name.end());
        std::cout << (valid == name? "YES" : "NO") << std::endl;
    }
}

# Count characters in your string
/*
The main idea is to count all the occurring characters in a string. If you have a string like aba, then the result should be {'a': 2, 'b': 1}.

What if the string is empty? Then the result should be empty object literal, {}.

STRINGSFUNDAMENTALS
*/
#include <map>
#include <string>

std::map<char, unsigned> count(const std::string& string) {
    std::map<char, unsigned> storage;
    for (char letter : string) {
      storage[letter]++;
    }
    return storage;
}

# 24. Swap Nodes in Pairs
# Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)
#
#
#
# Example 1:
#
# Input: head = [1,2,3,4]
#
# Output: [2,1,4,3]
#
# Explanation:
#
#
#
# Example 2:
#
# Input: head = []
#
# Output: []
#
# Example 3:
#
# Input: head = [1]
#
# Output: [1]
#
# Example 4:
#
# Input: head = [1,2,3]
#
# Output: [2,1,3]
#
#
#
# Constraints:
#
# The number of nodes in the list is in the range [0, 100].
# 0 <= Node.val <= 100
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # Count length of linked list
        n: int = 0
        tmp: ListNode = head
        while tmp:
            n += 1
            tmp = tmp.next
        # Only need make even swaps
        if n & 1: n -= 1
        # If no needed swaps
        if not n: return head
        # Make swap head with second node
        second: ListNode = head.next
        head.next = second.next
        second.next = head
        head = second
        # Continue swaping for other nodes it it needed
        idx: int = 2
        first: ListNode = head.next
        while idx + 2 <= n:
            second: ListNode = first.next.next
            first.next.next = second.next
            second.next = first.next
            first.next = second
            idx += 2
            first = first.next.next
        return head

# 1381. Design a Stack With Increment Operation
# Design a stack that supports increment operations on its elements.
#
# Implement the CustomStack class:
#
# CustomStack(int maxSize) Initializes the object with maxSize which is the maximum number of elements in the stack.
# void push(int x) Adds x to the top of the stack if the stack has not reached the maxSize.
# int pop() Pops and returns the top of the stack or -1 if the stack is empty.
# void inc(int k, int val) Increments the bottom k elements of the stack by val. If there are less than k elements in the stack, increment all the elements in the stack.
#
#
# Example 1:
#
# Input
# ["CustomStack","push","push","pop","push","push","push","increment","increment","pop","pop","pop","pop"]
# [[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]
# Output
# [null,null,null,2,null,null,null,null,null,103,202,201,-1]
# Explanation
# CustomStack stk = new CustomStack(3); // Stack is Empty []
# stk.push(1);                          // stack becomes [1]
# stk.push(2);                          // stack becomes [1, 2]
# stk.pop();                            // return 2 --> Return top of the stack 2, stack becomes [1]
# stk.push(2);                          // stack becomes [1, 2]
# stk.push(3);                          // stack becomes [1, 2, 3]
# stk.push(4);                          // stack still [1, 2, 3], Do not add another elements as size is 4
# stk.increment(5, 100);                // stack becomes [101, 102, 103]
# stk.increment(2, 100);                // stack becomes [201, 202, 103]
# stk.pop();                            // return 103 --> Return top of the stack 103, stack becomes [201, 202]
# stk.pop();                            // return 202 --> Return top of the stack 202, stack becomes [201]
# stk.pop();                            // return 201 --> Return top of the stack 201, stack becomes []
# stk.pop();                            // return -1 --> Stack is empty return -1.
#
#
# Constraints:
#
# 1 <= maxSize, x, k <= 1000
# 0 <= val <= 100
# At most 1000 calls will be made to each method of increment, push and pop each separately.
# C++ O(1) for all operation O(N)
class CustomStack {
public:
    std::vector<int> stack;
    std::vector<int> increase;
    int global_index = -1;
    CustomStack(int maxSize) {
        stack.resize(maxSize);
        increase.resize(maxSize);
    }

    void push(int x) {
        if (global_index + 1 == stack.size()) {
            return;
        };
        global_index += 1;
        stack[global_index] = x;
    }

    int pop() {
        if (global_index < 0) {
            return -1;
        };
        int output = stack[global_index] + increase[global_index];
        if (global_index > 0) {
            increase[global_index - 1] += increase[global_index];
        };
        increase[global_index] = 0;
        global_index -= 1;
        return output;
    }

    void increment(int k, int val) {
        if (global_index < 0) {
            return;
        };
        increase[std::min(global_index, k - 1)] += val;
    }
};

/**
 * Your CustomStack object will be instantiated and called as such:
 * CustomStack* obj = new CustomStack(maxSize);
 * obj->push(x);
 * int param_2 = obj->pop();
 * obj->increment(k,val);
 */

# Python O(1) for all operation O(N)
class CustomStack:

    def __init__(self, maxSize: int):
        self.stack: list[int] = [0] * maxSize
        self.capacity: int = maxSize
        self.increase: list[int] = [0] * maxSize
        self.global_index: int = -1

    def push(self, x: int) -> None:
        if self.global_index + 1 == len(self.stack): return
        self.global_index += 1
        self.stack[self.global_index] = x

    def pop(self) -> int:
        if self.global_index < 0: return -1
        output: int = self.stack[self.global_index] + self.increase[self.global_index]
        if self.global_index > 0:
            self.increase[self.global_index - 1] += self.increase[self.global_index]
        self.increase[self.global_index] = 0
        self.global_index -= 1
        return output

    def increment(self, k: int, val: int) -> None:
        if self.global_index < 0: return
        self.increase[min(self.global_index, k - 1)] += val

# Your CustomStack object will be instantiated and called as such:
# obj = CustomStack(maxSize)
# obj.push(x)
# param_2 = obj.pop()
# obj.increment(k,val)

# A. Grasshopper on a Line
# A. Grasshopper on a Line
# time limit per test2 seconds
# memory limit per test256 megabytes
# You are given two integers x
#  and k
# . Grasshopper starts in a point 0
#  on an OX axis. In one move, it can jump some integer distance, that is not divisible by k
# , to the left or to the right.
#
# What's the smallest number of moves it takes the grasshopper to reach point x
# ? What are these moves? If there are multiple answers, print any of them.
#
# Input
# The first line contains a single integer t
#  (1≤t≤1000
# ) — the number of testcases.
#
# The only line of each testcase contains two integers x
#  and k
#  (1≤x≤100
# ; 2≤k≤100
# ) — the endpoint and the constraint on the jumps, respectively.
#
# Output
# For each testcase, in the first line, print a single integer n
#  — the smallest number of moves it takes the grasshopper to reach point x
# .
#
# In the second line, print n
#  integers, each of them not divisible by k
# . A positive integer would mean jumping to the right, a negative integer would mean jumping to the left. The endpoint after the jumps should be exactly x
# .
#
# Each jump distance should be from −109
#  to 109
# . In can be shown that, for any solution with the smallest number of jumps, there exists a solution with the same number of jumps such that each jump is from −109
#  to 109
# .
#
# It can be shown that the answer always exists under the given constraints. If there are multiple answers, print any of them.
#
# Example
# inputCopy
# 3
# 10 2
# 10 3
# 3 4
# outputCopy
# 2
# 7 3
# 1
# 10
# 1
# 3
# Python O(1) O(1) Math
import sys


def solution(t: int) -> None:
    for _ in range(t):
        x, k = map(int, sys.stdin.readline().rstrip().split())
        sys.stdout.write(['1\n' + str(x), '2\n' + str(x - 1) + ' ' + '1'][x % k == 0] + '\n')


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)

# C++ O(1) O(1) Math
#include <iostream>

int main() {
    size_t t;
    std::cin >> t;
    for (size_t rep = 0; rep < t; ++rep) {
        int x, k;
        std::cin >> x >> k;
        if (x % k != 0) {
            std::cout << 1 << std::endl << x << std::endl;
        } else {
            std::cout << 2 << std::endl << x - 1 << " " << 1 << std::endl;
        }
    }
}

# T.T.T.59: The language from the distant planet
# Description
# In AD 2050, human beings finally found a planet in the distant XY constellation, which is very suitable for human survival. Many spacecraft from the earth to the distant planet, the star immigrants began...
#
# Nearly 10 years later, Human civilization is built up in the new planet, they put the planet named "paradise" and they call themselves "new human beings".
#
# They created their own language on the basis of the English alphabet and binary. That is to say, their text is expressed in binary, but only limited to letters, they still use punctuation and spaces in English.
#
# They use some special rules:
#
# Their binary is the opposite of the "old human beings". That is to say, their 1 is equals to our 0 and their 0 is equals to our 1.
#
# They re-encode the English alphabet in the opposite order: "zyxwvutsrqponmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA", using binary 1 to 52. For example, z is 10, y is 01, x is 00, and so on.. Each letter ends with 2. See examples below:
#
# old human beings: Hello world!
# new human beings: 0100102(H)010012(e)00002(l)00002(l)00112(o)
#                   0112(w)00112(o)01102(r)00002(l)010002(d)!
#
# old human beings: I am new human beings.
# new human beings: 0100112(I) 001012(a)00012(m) 00102(n)010012(e)0112(w)
#                   011002(h)0012(u)00012(m)001012(a)00102(n)
#                   001102(b)010012(e)011012(i)00102(n)010112(g)01112(s).
# Task
# Complete two function encode and decode that can tranlate the words between "new human beings" and "old human beings".
#
# Examples
# encode("Hello world!") should return:
# "0100102010012000020000200112 0112001120110200002010002!"
#
# decode("0100102010012000020000200112 0112001120110200002010002!")
# should return: "Hello world!"
#
# decode(encode("Hello world!")) should return "Hello world!"
# PUZZLESGAMES
LANGUAGE: str = 'zyxwvutsrqponmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA'

def get_to_reverse_bin(expression: str) -> str:
    return ''.join(['1', '0'][int(num)] for num in expression)

def encode(s: str) -> str:
    encoded_message: list[str] = []
    words: list[str] = s.split(' ')
    for word in words:
        encoded_word: list[str] = []
        for char in word:
            if char.isalpha():
                position: int = get_to_reverse_bin(bin(LANGUAGE.index(char) + 1)[2:])
                encoded_word.append(position + '2')
            else:
                encoded_word.append(char)
        encoded_message.append(''.join(encoded_word))
    return ' '.join(encoded_message)

def decode(s: str) -> str:
    words: list[str] = s.split(' ')
    decoded_message: list[str] = []
    for word in words:
        letters: list[str] = word.split('2')
        decoded_letters: list[str] = []
        for letter in letters:
            chars: list[str] = []
            special_marks: list[str] = []
            for char in letter:
                if char.isdigit():
                    chars.append(char)
                else:
                    if chars: special_marks.append(char)
                    else: decoded_letters.append(char)
            if chars:
                correct_bin_representation: str = get_to_reverse_bin(''.join(chars))
                decoded_letters.append(LANGUAGE[int(correct_bin_representation, 2) - 1] + ''.join(special_marks))
            else: decoded_letters.append(''.join(special_marks))
        decoded_message.append(''.join(decoded_letters))
    return ' '.join(decoded_message)
    
# 1497. Check If Array Pairs Are Divisible by k# Given an array of integers arr of even length n and an integer k.
#
# We want to divide the array into exactly n / 2 pairs such that the sum of each pair is divisible by k.
#
# Return true If you can find a way to do that or false otherwise.
#
#
#
# Example 1:
#
# Input: arr = [1,2,3,4,5,10,6,7,8,9], k = 5
# Output: true
# Explanation: Pairs are (1,9),(2,8),(3,7),(4,6) and (5,10).
# Example 2:
#
# Input: arr = [1,2,3,4,5,6], k = 7
# Output: true
# Explanation: Pairs are (1,6),(2,5) and(3,4).
# Example 3:
#
# Input: arr = [1,2,3,4,5,6], k = 10
# Output: false
# Explanation: You can try all possible pairs to see that there is no way to divide arr into 3 pairs each with sum divisible by 10.
#
#
# Constraints:
#
# arr.length == n
# 1 <= n <= 105
# n is even.
# -109 <= arr[i] <= 109
# 1 <= k <= 105
# Python O(N) O(N) HashMap
class Solution:
    def canArrange(self, arr: List[int], k: int) -> bool:
        storage: dict[int, int] = dict()
        for num in arr:
            storage[(num % k + k) % k] = storage.get((num % k + k) % k, 0) + 1
        for num in arr:
            remainder: int = (num % k + k) % k
            if remainder == 0:
                if storage[0] & 1: return False
            elif storage.get(remainder, -1) != storage.get(k - remainder, -2):
                return False
        return True

# Give me data
# In this kata, your task is to write a function which will determine whether the user has or does not have the permission to download certain data.
#
# Data: movies, games, books.
# Info about user's permissions is stored in a database with the following form: "movies_allow", "games_deny" ..
#
# When user wants to download a game and the db contains "games_deny", your function should return False.
#
# The user can also have everything allowed or denied: "*_allow", "*_deny".
#
# You can also have everything denied and some data allowed: "*_deny", "movies_allow".
#
# Count on incorrectness of permissions: user can have same data allowed and denied e.g.: "books_allow", "books_deny" - which results in "books_deny".
#
# hint: specific data has a higher priority than "*", so watch out for cases like: "*_allow", "books_deny" - in this case, the user can download everything apart from books.
#
# Example:
#
# { "books_allow", "movies_deny" }, "movies"  =>  False
# { "books_allow", "movies_deny" }, "books"  =>  True
# { "*_allow", "books_allow", "movies_deny" }, "games"  =>  True
# { "*_allow", "*_deny" }, "movies"  =>  False
# LOGICSETSFUNDAMENTALS
def has_permission(user_info, accessing_data):
    for move in user_info.copy():
        if move.endswith('_deny'):
            if move[:-5] + '_allow' in user_info:
                user_info.remove(move[:-5] + '_allow')
    r: str = accessing_data
    if r + '_deny' in user_info: return False
    if r + '_allow' in user_info: return True
    return '*_allow' in user_info

# A. Vanya and Cubes
# A. Vanya and Cubes
# time limit per test1 second
# memory limit per test256 megabytes
# Vanya got n cubes. He decided to build a pyramid from them. Vanya wants to build the pyramid as follows: the top level of the pyramid must consist of 1 cube, the second level must consist of 1 + 2 = 3 cubes, the third level must have 1 + 2 + 3 = 6 cubes, and so on. Thus, the i-th level of the pyramid must have 1 + 2 + ... + (i - 1) + i cubes.
#
# Vanya wants to know what is the maximum height of the pyramid that he can make using the given cubes.
#
# Input
# The first line contains integer n (1 ≤ n ≤ 104) — the number of cubes given to Vanya.
#
# Output
# Print the maximum possible height of the pyramid in the single line.
#
# Examples
# inputCopy
# 1
# outputCopy
# 1
# inputCopy
# 25
# outputCopy
# 4
# Note
# Illustration to the second sample:
# C++ O(logN) O(1) Math
#include <iostream>

int main() {
    int n;
    std::cin >> n;
    int height = 0;
    int total = 0;
    while (true) {
        int cubes_needed = (height + 1) * (height + 2) / 2;
        if (total + cubes_needed > n) {
            break;
        }
        height += 1;
        total += cubes_needed;
    }
    std::cout << height << std::endl;
}
# Python O(logN) O(1) Math
import sys

def solution(n: int) -> str:
    height: int = 0
    total: int = 0
    while True:
        cubes_needed: int = (height + 1) * (height + 2) // 2
        if total + cubes_needed > n:
            break
        height += 1
        total += cubes_needed
    return str(height)

if __name__ == '__main__':
    n: int = int(sys.stdin.readline().rstrip())
    sys.stdout.write(solution(n) + "\n")

# 1331. Rank Transform of an Array
# Given an array of integers arr, replace each element with its rank.
#
# The rank represents how large the element is. The rank has the following rules:
#
# Rank is an integer starting from 1.
# The larger the element, the larger the rank. If two elements are equal, their rank must be the same.
# Rank should be as small as possible.
#
#
# Example 1:
#
# Input: arr = [40,10,20,30]
# Output: [4,1,2,3]
# Explanation: 40 is the largest element. 10 is the smallest. 20 is the second smallest. 30 is the third smallest.
# Example 2:
#
# Input: arr = [100,100,100]
# Output: [1,1,1]
# Explanation: Same elements share the same rank.
# Example 3:
#
# Input: arr = [37,12,28,9,100,56,80,5,12]
# Output: [5,3,4,2,8,6,7,1,3]
#
#
# Constraints:
#
# 0 <= arr.length <= 105
# -109 <= arr[i] <= 109
# Python O(NlogN) O(N) HashMap
class Solution:
    def arrayRankTransform(self, arr: List[int]) -> List[int]:
        hashmap: dict[int, set[int]] = dict()
        for idx in range(len(arr)):
            if arr[idx] not in hashmap:
                hashmap[arr[idx]] = set()
            hashmap[arr[idx]].add(idx)
        arr.sort()
        output: list[int] = [0] * len(arr)
        rank: int = 1
        for idx in range(len(arr) - 1):
            if arr[idx] != arr[idx + 1]:
                output[hashmap[arr[idx]].pop()] = rank
                rank += 1
            else:
                output[hashmap[arr[idx]].pop()] = rank
        if hashmap:
            output[hashmap[arr[-1]].pop()] = rank
        return output

# C++ O(NlogN) O(N) HashMap
class Solution {
public:
    vector<int> arrayRankTransform(vector<int>& arr) {
        if (!arr.size()) {
            return arr;
        }
        std::unordered_map<int, std::unordered_set<size_t>> hashmap;
        for (size_t index = 0; index < arr.size(); ++index) {
            hashmap[arr[index]].insert(index);
        }
        std::sort(arr.begin(), arr.end());
        std::vector<int> output(arr.size());
        int rank = 1;
        for (size_t index = 0; index < arr.size() - 1; ++index) {
            if (arr[index] != arr[index + 1]) {
                output[*(popFromSet(hashmap, arr[index]))] = rank;
                rank += 1;
            } else {
                output[*(popFromSet(hashmap, arr[index]))] = rank;
            }
        }
        output[*(popFromSet(hashmap, arr[arr.size() - 1]))] = rank;
        return output;
    }
private:
std::optional<size_t> popFromSet(std::unordered_map<int, std::unordered_set<size_t>>& hashmap, int key) {
    auto it = hashmap.find(key);
    if (it != hashmap.end() && !it->second.empty()) {
        auto set_it = it->second.begin();
        size_t value = *set_it;
        it->second.erase(set_it);
        if (it->second.empty()) {
            hashmap.erase(it);
        }
        return value;
    }
    return std::nullopt;
}
};

# Latin Squares
# A latin square is an n × n array filled with the integers 1 to n, each occurring once in each row and column.
#
# Here are examples of latin squares of size 4 and 7:
#
# [[1, 4, 3, 2],      [[2, 3, 1, 7, 4, 6, 5],
#  [4, 3, 2, 1],       [7, 1, 6, 5, 2, 4, 3],
#  [3, 2, 1, 4],       [6, 7, 5, 4, 1, 3, 2],
#  [2, 1, 4, 3]]       [4, 5, 3, 2, 6, 1, 7],
#                      [5, 6, 4, 3, 7, 2, 1],
#                      [1, 2, 7, 6, 3, 5, 4],
#                      [3, 4, 2, 1, 5, 7, 6]]
# Latin squares have many practical uses, for example in error-correcting-codes and the design of agricultural experiments. See https://en.wikipedia.org/wiki/Latin_square for more details. Sudoku is a special type of 9 x 9 latin square, with additional conditions.
#
# Task: Write a function that returns a latin square for any positive integer n.
#
# You might also enjoy Latin Square Validator and Euler Squares.
#
# ARRAYS
def make_latin_square(n):
    return [[(i + j) % n + 1 for j in range(n)] for i in range(n)]

# B. Fair Division
# time limit per test2 seconds
# memory limit per test256 megabytes
# Alice and Bob received n
#  candies from their parents. Each candy weighs either 1 gram or 2 grams. Now they want to divide all candies among themselves fairly so that the total weight of Alice's candies is equal to the total weight of Bob's candies.
#
# Check if they can do that.
#
# Note that candies are not allowed to be cut in half.
#
# Input
# The first line contains one integer t
#  (1≤t≤104
# ) — the number of test cases. Then t
#  test cases follow.
#
# The first line of each test case contains an integer n
#  (1≤n≤100
# ) — the number of candies that Alice and Bob received.
#
# The next line contains n
#  integers a1,a2,…,an
#  — the weights of the candies. The weight of each candy is either 1
#  or 2
# .
#
# It is guaranteed that the sum of n
#  over all test cases does not exceed 105
# .
#
# Output
# For each test case, output on a separate line:
#
# "YES", if all candies can be divided into two sets with the same weight;
# "NO" otherwise.
# You can output "YES" and "NO" in any case (for example, the strings yEs, yes, Yes and YES will be recognized as positive).
#
# Example
# inputCopy
# 5
# 2
# 1 1
# 2
# 1 2
# 4
# 1 2 1 2
# 3
# 2 2 2
# 3
# 2 1 2
# outputCopy
# YES
# NO
# YES
# NO
# NO
# Note
# In the first test case, Alice and Bob can each take one candy, then both will have a total weight of 1
# .
#
# In the second test case, any division will be unfair.
#
# In the third test case, both Alice and Bob can take two candies, one of weight 1
#  and one of weight 2
# .
#
# In the fourth test case, it is impossible to divide three identical candies between two people.
#
# In the fifth test case, any division will also be unfair.
import sys


def solution(t: int) -> None:
    for _ in range(t):
        n: int = int(sys.stdin.readline().rstrip())
        weights: list = list(map(int, sys.stdin.readline().rstrip().split()))
        total_weight: int = sum(weights)

        if total_weight % 2 != 0:
            sys.stdout.write('NO\n')
            continue

        target: int = total_weight // 2
        count1: int = weights.count(1)
        count2: int = weights.count(2)

        max_2s_used: int = min(count2, target // 2)
        weight_from_2s: int = max_2s_used * 2
        remaining_weight: int = target - weight_from_2s
        sys.stdout.write(['NO', 'YES'][remaining_weight <= count1] + '\n')



if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)


# 1590. Make Sum Divisible by P
# Given an array of positive integers nums, remove the smallest subarray (possibly empty) such that the sum of the remaining elements is divisible by p. It is not allowed to remove the whole array.
#
# Return the length of the smallest subarray that you need to remove, or -1 if it's impossible.
#
# A subarray is defined as a contiguous block of elements in the array.
#
#
#
# Example 1:
#
# Input: nums = [3,1,4,2], p = 6
# Output: 1
# Explanation: The sum of the elements in nums is 10, which is not divisible by 6. We can remove the subarray [4], and the sum of the remaining elements is 6, which is divisible by 6.
# Example 2:
#
# Input: nums = [6,3,5,2], p = 9
# Output: 2
# Explanation: We cannot remove a single element to get a sum divisible by 9. The best way is to remove the subarray [5,2], leaving us with [6,3] with sum 9.
# Example 3:
#
# Input: nums = [1,2,3], p = 3
# Output: 0
# Explanation: Here the sum is 6. which is already divisible by 3. Thus we do not need to remove anything.
#
#
# Constraints:
#
# 1 <= nums.length <= 105
# 1 <= nums[i] <= 109
# 1 <= p <= 109
class Solution:
    def minSubarray(self, nums: List[int], p: int) -> int:
        total_sum: int = sum(num % p for num in nums) % p
        if not total_sum: return 0
        hashmap: dict[int, int] = {0: -1}
        cur_sum: int = 0
        length: int = len(nums)
        for idx in range(len(nums)):
            cur_sum = (cur_sum + nums[idx]) % p
            remainder: int = (cur_sum - total_sum + p) % p
            if remainder in hashmap:
                length = min(length, idx - hashmap[remainder])
            hashmap[cur_sum] = idx
        return length if length != len(nums) else -1

# Latin Square Validator
# Background
# A latin square is an n × n array filled with the integers 1 to n, each occurring once in each row and column.
#
# Here are examples of latin squares of size 4 and 7:
#
# [ [1, 4, 3, 2],     [ [2, 3, 1, 7, 4, 6, 5],
#   [4, 3, 2, 1],       [7, 1, 6, 5, 2, 4, 3],
#   [3, 2, 1, 4],       [6, 7, 5, 4, 1, 3, 2],
#   [2, 1, 4, 3] ]      [4, 5, 3, 2, 6, 1, 7],
#                       [5, 6, 4, 3, 7, 2, 1],
#                       [1, 2, 7, 6, 3, 5, 4],
#                       [3, 4, 2, 1, 5, 7, 6] ]
# Latin squares have many practical uses, for example in error-correcting-codes and the design of agricultural experiments. See https://en.wikipedia.org/wiki/Latin_square for more details. Sudoku is a 9 x 9 latin square, with additional conditions.
#
# Creating a latin square of any size is fairly straightforward (see the kata Latin Squares). Validating that an arbitrary array is a latin square is slightly trickier, especially if you want to provide helpful feedback messages in case it's not.
#
# Task
# Write a function that validates if an input array is a latin square. It has two parameters, the array and a positive integer m > 1. To help the user with debugging, it should return an appropriate message, as detailed below. It must not modify the input array.
#
# Details
# The input array is guaranteed to be 2D and contain only integers. If it is a valid latin square of size m, the function should return "Valid latin square of size <m>". Otherwise, it should return one of the following messages:
#
# If the input array is not square, the function should return "Array not square"
#
# If the input array is square, but not of size m, the function should return "Array is wrong size". NOTE: When the array is both not square and the wrong size, the first point applies, so "Array not square" should be returned.
#
# If any value between 1 and m in the array occurs more than once in a particular row, the function should identify it and its row by returning "<value> occurs more than once in row <s>". If there are multiple such values, only one should be identified. Row indexes run from 1 to m.
#
# If any value between 1 and m in the array occurs more than once in a particular column, the function should return "<value> occurs more than once in column <t>". If there are multiple such values, only one should be identified. Column indexes run from 1 to m.
#
# If any value in the array is not between 1 and m, the function should identify it and its location by returning "<value> at <row>,<col> is not between 1 and <m>". If there are multiple such values, only one should be identified.
#
# If more than one of the above conditions occur, the function should return one of the appropriate messages. For example, suppose m is 4 and the array is
#
# [ [1, 2, 1, 1],
#   [5, 2, 3, 4],
#   [4, 3, 0, 2, 1],
#   [2, 1, 4, 3] ]
# Then the function can return any of the following:
#
# "Array not square"
# "1 occurs more than once in row 1"
# "2 occurs more than once in column 2"
# "5 at 2,1 is not between 1 and 4"
# "0 at 3,3 is not between 1 and 4"
# Worth Noting
# There is no known easily-computable formula for the number of latin squares of a given size (see https://en.wikipedia.org/wiki/Latin_square - Number of n × n Latin squares).
#
# If you like this kata, you might also be interested in Sudokuboard validator.
#
# STRINGSARRAYS
def verify_latin_square(array, m):
    mx_row: int = max(len(row) for row in array)
    mn_row: int = min(len(row) for row in array)
    if (len(array) != mx_row or mx_row != mn_row) and len(array) != m: return 'Array not square'
    if (len(array) != mx_row or mx_row != mn_row): return 'Array not square'
    if len(array) != m: return 'Array is wrong size'
    for row in range(m):
        cur_set: set[int] = set()
        for col in range(m):
            if array[row][col] in cur_set: return f'{array[row][col]} occurs more than once in row {row + 1}'
            elif not 1 <= array[row][col] <= m: return f'{array[row][col]} at {row + 1},{col + 1} is not between 1 and {m}'
            else: cur_set.add(array[row][col])
    for col in range(m):
        cur_set: set[int] = set()
        for row in range(m):
            if array[row][col] in cur_set: return f'{array[row][col]} occurs more than once in column {col + 1}'
            else: cur_set.add(array[row][col])
    return f'Valid latin square of size {m}'

# A. Minutes Before the New Year
# A. Minutes Before the New Year
# time limit per test1 second
# memory limit per test256 megabytes
# New Year is coming and you are excited to know how many minutes remain before the New Year. You know that currently the clock shows h
#  hours and m
#  minutes, where 0≤hh<24
#  and 0≤mm<60
# . We use 24-hour time format!
#
# Your task is to find the number of minutes before the New Year. You know that New Year comes when the clock shows 0
#  hours and 0
#  minutes.
#
# You have to answer t
#  independent test cases.
#
# Input
# The first line of the input contains one integer t
#  (1≤t≤1439
# ) — the number of test cases.
#
# The following t
#  lines describe test cases. The i
# -th line contains the time as two integers h
#  and m
#  (0≤h<24
# , 0≤m<60
# ). It is guaranteed that this time is not a midnight, i.e. the following two conditions can't be met at the same time: h=0
#  and m=0
# . It is guaranteed that both h
#  and m
#  are given without leading zeros.
#
# Output
# For each test case, print the answer on it — the number of minutes before the New Year.
#
# Example
# inputCopy
# 5
# 23 55
# 23 0
# 0 1
# 4 20
# 23 59
# outputCopy
# 5
# 60
# 1439
# 1180
# 1
# Python O(1) O(1) Math
import sys


def solution(t: int) -> None:
    for _ in range(t):
        h, m = map(int, sys.stdin.readline().rstrip().split())
        hours_remainder: int = 24 - h
        minutes_remainder: int = 0
        if m != 0:
            hours_remainder -= 1
            minutes_remainder = 60 - m
        sys.stdout.write(str(hours_remainder * 60 + minutes_remainder) + '\n')


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)

# C++ O(1) O(1) Math
#include <iostream>


int main() {
    size_t t;
    std::cin >> t;
    for (size_t rep = 0; rep < t; ++rep) {
        int h, m;
        std::cin >> h >> m;
        int hours_remainder = 24 - h;
        int minutes_remainder = 0;
        if (m != 0) {
            hours_remainder -= 1;
            minutes_remainder = 60 - m;
        }
        std::cout << hours_remainder * 60 + minutes_remainder << std::endl;
    }
}

# 2491. Divide Players Into Teams of Equal Skill
# You are given a positive integer array skill of even length n where skill[i] denotes the skill of the ith player. Divide the players into n / 2 teams of size 2 such that the total skill of each team is equal.
#
# The chemistry of a team is equal to the product of the skills of the players on that team.
#
# Return the sum of the chemistry of all the teams, or return -1 if there is no way to divide the players into teams such that the total skill of each team is equal.
#
#
#
# Example 1:
#
# Input: skill = [3,2,5,1,3,4]
# Output: 22
# Explanation:
# Divide the players into the following teams: (1, 5), (2, 4), (3, 3), where each team has a total skill of 6.
# The sum of the chemistry of all the teams is: 1 * 5 + 2 * 4 + 3 * 3 = 5 + 8 + 9 = 22.
# Example 2:
#
# Input: skill = [3,4]
# Output: 12
# Explanation:
# The two players form a team with a total skill of 7.
# The chemistry of the team is 3 * 4 = 12.
# Example 3:
#
# Input: skill = [1,1,2,3]
# Output: -1
# Explanation:
# There is no way to divide the players into teams such that the total skill of each team is equal.
#
#
# Constraints:
#
# 2 <= skill.length <= 105
# skill.length is even.
# 1 <= skill[i] <= 1000
# Python O(NlogN) O(1) Two Pointers Sorting
class Solution:
    def dividePlayers(self, skill: List[int]) -> int:
        skill.sort()
        median_skill: int = skill[0] + skill[-1]
        chemistry_sum: int = 0
        left: int = 0
        right: int = len(skill) - 1
        while left < right:
            cur_skill_sum: int = skill[left] + skill[right]
            if cur_skill_sum != median_skill: return -1
            chemistry_sum += skill[left] * skill[right]
            left += 1
            right -= 1
        return chemistry_sum

# C++ O(NlogN) O(1) Two Pointers Sorting
class Solution {
public:
    long long dividePlayers(vector<int>& skill) {
        std::sort(skill.begin(), skill.end());
        long long median_skill = skill[0] + skill[skill.size() - 1];
        long long chemistry_sum = 0;
        size_t left = 0;
        size_t right = skill.size() - 1;
        while (left < right){
            long long cur_skill_sum = skill[left] + skill[right];
            if (cur_skill_sum != median_skill) {
                return -1;
            }
            chemistry_sum += skill[left] * skill[right];
            left += 1;
            right -= 1;
        }
        return chemistry_sum;
    }
};

# Python O(N) O(N) Two Pointers Sorting Counting Sort
class Solution:
    def dividePlayers(self, skill: List[int]) -> int:
        sorted_skill: list[int] = [0] * (max(skill) + 1)
        for num in skill:
            sorted_skill[num] += 1
        left: int = 0
        right: int = len(sorted_skill) - 1
        while left < right and not sorted_skill[left]:
            left += 1
        while left < right and not sorted_skill[right]:
            right -= 1
        median_skill: int = left + right
        chemistry_sum: int = 0
        while left <= right and sorted_skill[left] > 0 and sorted_skill[right] > 0:
            cur_skill_sum: int = left + right
            if cur_skill_sum != median_skill: return -1
            chemistry_sum += left * right
            sorted_skill[left] -= 1
            sorted_skill[right] -= 1
            if sorted_skill[left] == 0: left += 1
            if sorted_skill[right] == 0: right -= 1
            while left <= right and not sorted_skill[left]:
                left += 1
            while left <= right and not sorted_skill[right]:
                right -= 1
        return chemistry_sum

# C++ O(N) O(N) Two Pointers Sorting Counting Sort
#include <vector>
#include <algorithm>

class Solution {
public:
    long long dividePlayers(std::vector<int>& skill) {
        std::vector<int> sorted_skill(*std::max_element(skill.begin(), skill.end()) + 1, 0);
        for (int num : skill) {
            sorted_skill[num]++;
        }
        int left = 0;
        int right = sorted_skill.size() - 1;
        while (left < right && sorted_skill[left] == 0) {
            left++;
        }
        while (left < right && sorted_skill[right] == 0) {
            right--;
        }
        long long median_skill = left + right;
        long long chemistry_sum = 0;
        while (left <= right && sorted_skill[left] > 0 && sorted_skill[right] > 0) {
            long long cur_skill_sum = left + right;
            if (cur_skill_sum != median_skill) {
                return -1;
            }
            chemistry_sum += static_cast<long long>(left) * right;
            sorted_skill[left]--;
            sorted_skill[right]--;
            if (sorted_skill[left] == 0) {
                left++;
            }
            if (sorted_skill[right] == 0) {
                right--;
            }
            while (left <= right && sorted_skill[left] == 0) {
                left++;
            }
            while (left <= right && sorted_skill[right] == 0) {
                right--;
            }
        }
        return chemistry_sum;
    }
};

# Emirps
/*
If you reverse the word "emirp" you will have the word "prime". That idea is related with the purpose of this kata: we should select all the primes that when reversed are a different prime (so palindromic primes should be discarded).

For example: 13, 17 are prime numbers and the reversed respectively are 31, 71 which are also primes, so 13 and 17 are "emirps". But primes 757, 787, 797 are palindromic primes, meaning that the reversed number is the same as the original, so they are not considered as "emirps" and should be discarded.

The emirps sequence is registered in OEIS as A006567

Your task
Create a function that receives one argument n, as an upper limit, and the return the following array:

[number_of_emirps_below_n, largest_emirp_below_n, sum_of_emirps_below_n]

Examples
find_emirp(10)
[0, 0, 0] ''' no emirps below 10 '''

find_emirp(50)
[4, 37, 98] ''' there are 4 emirps below 50: 13, 17, 31, 37; largest = 37; sum = 98 '''

find_emirp(100)
[8, 97, 418] ''' there are 8 emirps below 100: 13, 17, 31, 37, 71, 73, 79, 97; largest = 97; sum = 418 '''
Happy coding!!

Advise: Do not use a primality test. It will make your code very slow. Create a set of primes using a prime generator or a range of primes producer. Remember that search in a set is faster that in a sorted list or array

FUNDAMENTALSMATHEMATICSALGORITHMSDATA STRUCTURES
*/
#include <array>
#include <unordered_set>
#include <string>
#include <cmath>

bool is_prime(int n) {
  int upper_boundary = static_cast<int>(std::sqrt(n)) + 2;
  for (int mod = 2; mod < upper_boundary; ++mod) {
    if (n % mod == 0) {
      return false;
    }
  }
  return true;
}


std::array<int, 3> findEmirp(const int n) {
  std::unordered_set<int> hashset;
  int max_num = 0;
  int acc_sum = 0;
  for (int num = 13; num < n + 1; num+=2) {
    if (!is_prime(num)) {
      continue;
    }
    std::string rev_num = std::to_string(num);
    std::reverse(rev_num.begin(), rev_num.end());
    int rev_num_int = std::stoi(rev_num);
    if (is_prime(rev_num_int) && rev_num_int != num) {
      hashset.insert(num);
      max_num = std::max(max_num, num);
      acc_sum += num;
    }
  }
  return {static_cast<int>(hashset.size()), max_num, acc_sum};
}

# B. Two Arrays And Swaps
# B. Two Arrays And Swaps
# time limit per test1 second
# memory limit per test256 megabytes
# You are given two arrays a
#  and b
#  both consisting of n
#  positive (greater than zero) integers. You are also given an integer k
# .
#
# In one move, you can choose two indices i
#  and j
#  (1≤i,j≤n
# ) and swap ai
#  and bj
#  (i.e. ai
#  becomes bj
#  and vice versa). Note that i
#  and j
#  can be equal or different (in particular, swap a2
#  with b2
#  or swap a3
#  and b9
#  both are acceptable moves).
#
# Your task is to find the maximum possible sum you can obtain in the array a
#  if you can do no more than (i.e. at most) k
#  such moves (swaps).
#
# You have to answer t
#  independent test cases.
#
# Input
# The first line of the input contains one integer t
#  (1≤t≤200
# ) — the number of test cases. Then t
#  test cases follow.
#
# The first line of the test case contains two integers n
#  and k
#  (1≤n≤30;0≤k≤n
# ) — the number of elements in a
#  and b
#  and the maximum number of moves you can do. The second line of the test case contains n
#  integers a1,a2,…,an
#  (1≤ai≤30
# ), where ai
#  is the i
# -th element of a
# . The third line of the test case contains n
#  integers b1,b2,…,bn
#  (1≤bi≤30
# ), where bi
#  is the i
# -th element of b
# .
#
# Output
# For each test case, print the answer — the maximum possible sum you can obtain in the array a
#  if you can do no more than (i.e. at most) k
#  swaps.
#
# Example
# inputCopy
# 5
# 2 1
# 1 2
# 3 4
# 5 5
# 5 5 6 6 5
# 1 2 5 4 3
# 5 3
# 1 2 3 4 5
# 10 9 10 10 9
# 4 0
# 2 2 4 3
# 2 4 2 3
# 4 4
# 1 2 2 1
# 4 4 5 4
# outputCopy
# 6
# 27
# 39
# 11
# 17
# Note
# In the first test case of the example, you can swap a1=1
#  and b2=4
# , so a=[4,2]
#  and b=[3,1]
# .
#
# In the second test case of the example, you don't need to swap anything.
#
# In the third test case of the example, you can swap a1=1
#  and b1=10
# , a3=3
#  and b3=10
#  and a2=2
#  and b4=10
# , so a=[10,10,10,4,5]
#  and b=[1,9,3,2,9]
# .
#
# In the fourth test case of the example, you cannot swap anything.
#
# In the fifth test case of the example, you can swap arrays a
#  and b
# , so a=[4,4,5,4]
#  and b=[1,2,2,1]
# .
# Python O(NlogN) O(1) Two Pointers Sorting
import sys
from typing import List


def solution(t: int) -> None:
    for _ in range(t):
        n, k = map(int, sys.stdin.readline().rstrip().split())
        a: List[int] = list(map(int, sys.stdin.readline().rstrip().split()))
        b: List[int] = list(map(int, sys.stdin.readline().rstrip().split()))
        a.sort()
        b.sort()
        left: int = 0
        right: int = n - 1
        for _ in range(k):
            if a[left] >= b[right]: break
            a[left] = b[right]
            left += 1
            right -= 1
        sys.stdout.write(str(sum(a)) + '\n')


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)

# C++ O(NlogN) O(1) Two Pointers Sorting
#include <iostream>
#include <vector>
#include <numeric>
#include <algorithm>

int main() {
    size_t t;
    std::cin >> t;
    for (size_t rep = 0; rep < t; ++rep) {
        size_t n;
        int k;
        std::cin >> n >> k;
        std::vector<int> a_nums;
        for (size_t j = 0; j < n; ++j) {
            int num;
            std::cin >> num;
            a_nums.push_back(num);
        }
        std::vector<int> b_nums;
        for (size_t j = 0; j < n; ++j) {
            int num;
            std::cin >> num;
            b_nums.push_back(num);
        }
        std::sort(a_nums.begin(), a_nums.end());
        std::sort(b_nums.begin(), b_nums.end());
        size_t left = 0;
        size_t right = n - 1;
        for (int move = 0; move < k; ++move) {
            if (a_nums[left] >= b_nums[right]) {
                break;
            }
            a_nums[left] = b_nums[right];
            left += 1;
            right -= 1;
        }
        std::cout << std::accumulate(a_nums.begin(), a_nums.end(), 0) << std::endl;
    }
}

# A. Fair Playoff
# A. Fair Playoff
# time limit per test2 seconds
# memory limit per test256 megabytes
# Four players participate in the playoff tournament. The tournament is held according to the following scheme: the first player will play with the second, and the third player with the fourth, then the winners of the pairs will play in the finals of the tournament.
#
# It is known that in a match between two players, the one whose skill is greater will win. The skill of the i
# -th player is equal to si
#  and all skill levels are pairwise different (i. e. there are no two identical values in the array s
# ).
#
# The tournament is called fair if the two players with the highest skills meet in the finals.
#
# Determine whether the given tournament is fair.
#
# Input
# The first line contains a single integer t
#  (1≤t≤104
# ) — the number of test cases.
#
# A single line of test case contains four integers s1,s2,s3,s4
#  (1≤si≤100
# ) — skill of the players. It is guaranteed that all the numbers in the array are different.
#
# Output
# For each testcase, output YES if the tournament is fair, or NO otherwise.
#
# Example
# inputCopy
# 4
# 3 7 9 5
# 4 5 6 9
# 5 3 8 1
# 6 5 3 2
# outputCopy
# YES
# NO
# YES
# NO
# Note
# Consider the example:
#
# in the first test case, players 2
#  and 3
#  with skills 7
#  and 9
#  advance to the finals;
# in the second test case, players 2
#  and 4
#  with skills 5
#  and 9
#  advance to the finals. The player with skill 6
#  does not advance, but the player with skill 5
#  advances to the finals, so the tournament is not fair;
# in the third test case, players 1
#  and 3
#  with skills 5
#  and 8
#  advance to the finals;
# in the fourth test case, players 1
#  and 3
#  with skills 6
#  and 3
#  advance to the finals. The player with skill 5
#  does not advance, but the player with skill 3
#  advances to the finals, so the tournament is not fair.
# Python O(1) O(1) Math Greedy
import sys


def solution(t: int) -> None:
    for _ in range(t):
        a, b, c, d = map(int, sys.stdin.readline().rstrip().split())
        f_p_mn: int = min(a, b)
        f_p_mx: int = max(a, b)
        s_p_mn: int = min(c, d)
        s_p_mx: int = max(c, d)
        sys.stdout.write(['NO', 'YES'][f_p_mx > s_p_mn and s_p_mx > f_p_mn] + '\n')


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)

# C++ O(1) O(1) Math Greedy
#include <iostream>

int main() {
    int t;
    std::cin >> t;
    for (int rep = 0; rep < t; ++rep) {
        int a, b, c, d;
        std::cin >> a >> b >> c >> d;
        int f_p_mn = std::min(a, b);
        int f_p_mx = std::max(a, b);
        int s_p_mn = std::min(c, d);
        int s_p_mx = std::max(c, d);
        std::cout << (f_p_mx > s_p_mn && s_p_mx > f_p_mn ? "YES" : "NO") << std::endl;
    }
}

# Parse a linked list from a string
/*
Parse a linked list from a string
Related Kata
Although this Kata is not part of an official Series, you may want to complete this Kata before attempting this one as these two Kata are deeply related.

Preloaded
Preloaded for you is a class, struct or derived data type Node ( depending on the language ) used to construct linked lists in this Kata:

class Node {
  public:
    int data;
    Node *next;
    Node(int data, Node *next = nullptr): data(data), next(next) {}
};
Prerequisites
This Kata assumes that you are already familiar with the idea of a linked list. If you do not know what that is, you may want to read up on this article on Wikipedia. Specifically, the linked lists this Kata is referring to are singly linked lists, where the value of a specific node is stored in its data / $data/Data property, the reference to the next node is stored in its next / $next / Next property and the terminator for a list is null / NULL / nil / nullptr / null() / [].

Additionally, this Kata assumes that you have basic knowledge of Object-Oriented Programming ( or a similar concept ) in the programming language you are undertaking. If you have not come across Object-Oriented Programming in your selected language, you may want to try out an online course or read up on some code examples of OOP in your selected language up to ( but not necessarily including ) Classical Inheritance.

Specifically, if you are attempting this Kata in PHP and haven't come across OOP, you may want to try out the first 4 Kata in this Series.

Task
Create a function parse which accepts exactly one argument string / $string / s / strrep ( or similar, depending on the language ) which is a string representation of a linked list. Your function must return the corresponding linked list, constructed from instances of the Node class/struct/type. The string representation of a list has the following format: the value of the node, followed by a whitespace, an arrow and another whitespace (" -> "), followed by the rest of the linked list. Each string representation of a linked list will end in "null" / "NULL" / "nil" / "nullptr" / "null()" depending on the language you are undertaking this Kata in. For example, given the following string representation of a linked list:

"1 -> 2 -> 3 -> nullptr"
... your function should return:

Note that due to the way the constructor for Node is defined, if a second argument is not provided, the next / $next / Next field is automatically set to null / NULL / nil / nullptr ( or equivalent in your language ). That means your function could also return the following ( if it helps you better visualise what is actually going on ):

new Node(1, new Node(2, new Node(3, nullptr)))
Another example: given the following string input:

"0 -> 1 -> 4 -> 9 -> 16 -> nullptr"
... your function should return:

If the input string is just "null" / "NULL" / "nil" / "nullptr" / "null()", return null / NULL / nil / nullptr / null() / [] ( or equivalent ).

For the simplicity of this Kata, the values of the nodes in the string representation will always ever be non-negative integers, so the following would not occur: "Hello World -> Goodbye World -> 123 -> null" / "Hello World -> Goodbye World -> 123 -> NULL" / "Hello World -> Goodbye World -> 123 -> nil" / "Hello World -> Goodbye World -> 123 -> nullptr" ( depending on the language ). This also means that the values of each Node must also be non-negative integers so keep that in mind when you are parsing the list from the string.

Enjoy, and don't forget to check out my other Kata Series :D

LINKED LISTSRECURSIONALGORITHMS
*/
#include <iostream>
#include <string>
#include <vector>
#include <sstream>

void split(const std::string &s, const std::string &delim, std::vector<std::string> &elems) {
    size_t start = 0, end;
    while ((end = s.find(delim, start)) != std::string::npos) {
        elems.push_back(s.substr(start, end - start));
        start = end + delim.length();
    }
    elems.push_back(s.substr(start));
}

Node* parse(const std::string& s) {
    std::vector<std::string> nodes;
    split(s, " -> ", nodes);
    if (nodes.empty() || nodes[0] == "nullptr") {
        return nullptr;
    }

    Node* head = new Node(std::stoi(nodes[0]));
    Node* tmp = head;

    for (size_t index = 1; index < nodes.size(); ++index) {
        if (nodes[index] == "nullptr") {
            break;
        }
        tmp->next = new Node(std::stoi(nodes[index]));
        tmp = tmp->next;
    }
    return head;
}

# 1813. Sentence Similarity III
# You are given two strings sentence1 and sentence2, each representing a sentence composed of words. A sentence is a list of words that are separated by a single space with no leading or trailing spaces. Each word consists of only uppercase and lowercase English characters.
#
# Two sentences s1 and s2 are considered similar if it is possible to insert an arbitrary sentence (possibly empty) inside one of these sentences such that the two sentences become equal. Note that the inserted sentence must be separated from existing words by spaces.
#
# For example,
#
# s1 = "Hello Jane" and s2 = "Hello my name is Jane" can be made equal by inserting "my name is" between "Hello" and "Jane" in s1.
# s1 = "Frog cool" and s2 = "Frogs are cool" are not similar, since although there is a sentence "s are" inserted into s1, it is not separated from "Frog" by a space.
# Given two sentences sentence1 and sentence2, return true if sentence1 and sentence2 are similar. Otherwise, return false.
#
#
#
# Example 1:
#
# Input: sentence1 = "My name is Haley", sentence2 = "My Haley"
#
# Output: true
#
# Explanation:
#
# sentence2 can be turned to sentence1 by inserting "name is" between "My" and "Haley".
#
# Example 2:
#
# Input: sentence1 = "of", sentence2 = "A lot of words"
#
# Output: false
#
# Explanation:
#
# No single sentence can be inserted inside one of the sentences to make it equal to the other.
#
# Example 3:
#
# Input: sentence1 = "Eating right now", sentence2 = "Eating"
#
# Output: true
#
# Explanation:
#
# sentence2 can be turned to sentence1 by inserting "right now" at the end of the sentence.
#
#
#
# Constraints:
#
# 1 <= sentence1.length, sentence2.length <= 100
# sentence1 and sentence2 consist of lowercase and uppercase English letters and spaces.
# The words in sentence1 and sentence2 are separated by a single space.
# Python O(N) O(N) Two Pointers
class Solution:
    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:
        sentence1: list[str] = sentence1.split()
        sentence2: list[str] = sentence2.split()
        left: int = 0
        while left < min(len(sentence1), len(sentence2)):
            if sentence1[left] != sentence2[left]:
                break
            left += 1
        right_sentence_1: int = len(sentence1) - 1
        right_sentence_2: int = len(sentence2) - 1
        while right_sentence_1 >= 0 and right_sentence_2 >= 0:
            if sentence1[right_sentence_1] != sentence2[right_sentence_2]:
                break
            right_sentence_1 -= 1
            right_sentence_2 -= 1
        return left > min(right_sentence_1, right_sentence_2)

# C++ O(N) O(N) Two Pointers
class Solution {
public:
    bool areSentencesSimilar(string sentence1, string sentence2) {
        stringstream ss1(sentence1), ss2(sentence2);
        std::string word;
        std::vector<std::string> s1Words, s2Words;
        while (ss1 >> word) {
            s1Words.push_back(word);
        }
        while (ss2 >> word) {
            s2Words.push_back(word);
        }
        int left = 0;
        while (left < std::min(s1Words.size(), s2Words.size())) {
            if (s1Words[left] != s2Words[left]) {
                break;
            }
            ++left;
        }
        int right_sentence1 = s1Words.size() - 1;
        int right_sentence2 = s2Words.size() - 1;
        while (right_sentence1 >= 0 && right_sentence2 >= 0) {
            if (s1Words[right_sentence1] != s2Words[right_sentence2]) {
                break;
            }
            --right_sentence1;
            --right_sentence2;
        }
        return left > std::min(right_sentence1, right_sentence2);
    }
};

# 3309. Maximum Possible Number by Binary Concatenation
# You are given an array of integers nums of size 3.
#
# Return the maximum possible number whose binary representation can be formed by concatenating the binary representation of all elements in nums in some order.
#
# Note that the binary representation of any number does not contain leading zeros.
#
#
#
# Example 1:
#
# Input: nums = [1,2,3]
#
# Output: 30
#
# Explanation:
#
# Concatenate the numbers in the order [3, 1, 2] to get the result "11110", which is the binary representation of 30.
#
# Example 2:
#
# Input: nums = [2,8,16]
#
# Output: 1296
#
# Explanation:
#
# Concatenate the numbers in the order [2, 8, 16] to get the result "10100010000", which is the binary representation of 1296.
#
#
#
# Constraints:
#
# nums.length == 3
# 1 <= nums[i] <= 127
class Solution:
    def concatenate(self, a: int, b: int, c: int) -> int:
        return int(bin(a)[2:] + bin(b)[2:] + bin(c)[2:], 2)

    def maxGoodNumber(self, nums: List[int]) -> int:
        a, b, c = nums
        return max(
            self.concatenate(a, b, c),
            self.concatenate(b, a, c),
            self.concatenate(c, b, a),
            self.concatenate(c, a, b),
            self.concatenate(b, c, a),
            self.concatenate(a, c, b),
        )

# 3310. Remove Methods From Project
# You are maintaining a project that has n methods numbered from 0 to n - 1.
#
# You are given two integers n and k, and a 2D integer array invocations, where invocations[i] = [ai, bi] indicates that method ai invokes method bi.
#
# There is a known bug in method k. Method k, along with any method invoked by it, either directly or indirectly, are considered suspicious and we aim to remove them.
#
# A group of methods can only be removed if no method outside the group invokes any methods within it.
#
# Return an array containing all the remaining methods after removing all the suspicious methods. You may return the answer in any order. If it is not possible to remove all the suspicious methods, none should be removed.
#
#
#
# Example 1:
#
# Input: n = 4, k = 1, invocations = [[1,2],[0,1],[3,2]]
#
# Output: [0,1,2,3]
#
# Explanation:
#
#
#
# Method 2 and method 1 are suspicious, but they are directly invoked by methods 3 and 0, which are not suspicious. We return all elements without removing anything.
#
# Example 2:
#
# Input: n = 5, k = 0, invocations = [[1,2],[0,2],[0,1],[3,4]]
#
# Output: [3,4]
#
# Explanation:
#
#
#
# Methods 0, 1, and 2 are suspicious and they are not directly invoked by any other method. We can remove them.
#
# Example 3:
#
# Input: n = 3, k = 2, invocations = [[1,2],[0,1],[2,0]]
#
# Output: []
#
# Explanation:
#
#
#
# All methods are suspicious. We can remove them.
#
#
#
# Constraints:
#
# 1 <= n <= 105
# 0 <= k <= n - 1
# 0 <= invocations.length <= 2 * 105
# invocations[i] == [ai, bi]
# 0 <= ai, bi <= n - 1
# ai != bi
# invocations[i] != invocations[j]
# Python O(V(V + E)) O(V + E) Depth-First-Search
class Solution:
    def traverse(self, start: int, maps: dict[int, set[int]], visited: set[int]) -> None:
        nodes: list[int] = [start]
        while nodes:
            cur_node: int = nodes.pop()
            if cur_node in visited:
                continue
            visited.add(cur_node)
            for child in maps.get(cur_node, []):
                if child not in visited:
                    nodes.append(child)

    def remainingMethods(self, n: int, k: int, invocations: list[list[int]]) -> list[int]:
        adj_list: dict[int, set[int]] = {}
        for a, b in invocations:
            if a not in adj_list:
                adj_list[a] = set()
            adj_list[a].add(b)
        invalid: set[int] = set()
        valid: set[int] = set()
        self.traverse(k, adj_list, invalid)
        for node in range(n):
            if node not in invalid:
                self.traverse(node, adj_list, valid)
        if any(node in valid for node in invalid):
            return list(range(n))
        return list(valid)

# C++ O(V(V + E) O(V + E) Depth-First-Search
class Solution {
public:
    void traverse(int start, std::unordered_map<int, std::unordered_set<int>>& adj_list, std::unordered_set<int>& visited) {
        std::vector<int> nodes = {start};
        while (nodes.size()) {
            int cur_node = nodes[nodes.size() - 1];
            nodes.pop_back();
            if (visited.count(cur_node)) {
                continue;
            }
            visited.insert(cur_node);
            for (int child : adj_list[cur_node]) {
                if (!visited.count(child)) {
                    nodes.push_back(child);
                }
            }
        }
    }
    vector<int> remainingMethods(int n, int k, vector<vector<int>>& invocations) {
        std::unordered_map<int, std::unordered_set<int>> adj_list;
        for (vector<int> pair : invocations) {
            int source = pair[0], destination = pair[1];
            adj_list[source].insert(destination);
        }
        std::unordered_set<int> invalid, valid;
        traverse(k, adj_list, invalid);
        for (int node = 0; node < n; ++node) {
            if (invalid.count(node)) {
                continue;
            }
            traverse(node, adj_list, valid);
        }
        for (int node : invalid) {
            if (valid.count(node)) {
                std::vector<int> output;
                for (int i = 0; i < n; ++i) {
                    output.push_back(i);
                }
                return output;
            }
        }
        std::vector<int> output;
        for (int node : valid) {
            output.push_back(node);
        }
        return output;
    }
};

# A. A+B Again?
# A. A+B Again?
# time limit per test1 second
# memory limit per test256 megabytes
# Given a two-digit positive integer n
# , find the sum of its digits.
#
# Input
# The first line contains an integer t
#  (1≤t≤90
# ) — the number of test cases.
#
# The only line of each test case contains a single two-digit positive integer n
#  (10≤n≤99
# ).
#
# Output
# For each test case, output a single integer — the sum of the digits of n
# .
#
# Example
# inputCopy
# 8
# 77
# 21
# 40
# 34
# 19
# 84
# 10
# 99
# outputCopy
# 14
# 3
# 4
# 7
# 10
# 12
# 1
# 18
# Solution
# C++ O(1) O(1) String Math
#include <iostream>
#include <string>

int main() {
    int t;
    std::cin >> t;
    for (int i = 0; i < t; ++i) {
        std::string n;
        std::cin >> n;
        std::cout << (n[0] - '0') + (n[1] - '0') << std::endl;
    }
}

# Python O(1) O(1) Math String
import sys


def solution(t: int) -> None:
    for _ in range(t):
        n: str = sys.stdin.readline().rstrip()
        sys.stdout.write(str(int(n[0]) + int(n[1])) + '\n')


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)

# Number Sequence: Smarandache descrescendo symmetric sequence
# Build the sequence which is defined as follows
#
# 1,
# 1, 2, 1,
# 1, 2, 3, 2, 1,
# 1, 2, 3, 4, 3, 2, 1,
# 1, 2, 3, 4, 5, 4, 3, 2, 1,
# 1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1,
# 1, 2, 3, 4, 5, 6, 7, 6, 5, 4, 3, 2, 1,
# 1, 2, 3, 4, 5, 6, 7, 8, 7, 6, 5, 4, 3, 2, 1,
# 1, 2, 3, 4, 5, 6, 7, 8, 9, 8, 7, 6, 5, 4, 3, 2, 1,
# 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1,
# ...
# Task
# write a function solve(n, bound) which builds this sequence until an element in the sequnce equals bound (not including bound). Return the sum of every nth element of the sequence (not including the 0th element).
#
# Example
# solve(2, 4) produces the following sequence
#
# 1,
# 1, 2, 1,
# 1, 2, 3, 2, 1,
# 1, 2, 3,
#
# solve(2, 4) = 2 + 1 + 3 + 1 + 2 = 9
# Other examples
# solve(3, 3) = 1
# solve(2, 3) = 2 + 1 = 3
# Note
# bound will always be greater than 1 (bound>1)
#
# ALGORITHMS
# Python
def solve(n, bound):
    output: list[int] = [1]
    init: list[int] = [1]
    for module in range(2, bound):
        output.extend(init + [module] + init[::-1])
        init.append(module)
    output.extend(init)
    return sum(output[n::n])
# C++
#include <vector>

int solve(int n, int bound) {
  std::vector<int> output;
  for (int mod = 1; mod <= bound; ++mod) {
    for (int num = 1; num <= mod; ++num) {
      output.push_back(num);
    }
    if (mod == bound) {
      output.pop_back();
      break;
    }
    for (int num = mod - 1; num > 0; --num) {
      output.push_back(num);
    }
  }
  int sum = 0;
  for (size_t index = n; index < output.size(); index += static_cast<size_t>(n)) {
    sum += output[index];
  }
  return sum;
}

# 3304. Find the K-th Character in String Game I
# Alice and Bob are playing a game. Initially, Alice has a string word = "a".
#
# You are given a positive integer k.
#
# Now Bob will ask Alice to perform the following operation forever:
#
# Generate a new string by changing each character in word to its next character in the English alphabet, and append it to the original word.
# For example, performing the operation on "c" generates "cd" and performing the operation on "zb" generates "zbac".
#
# Return the value of the kth character in word, after enough operations have been done for word to have at least k characters.
#
# Note that the character 'z' can be changed to 'a' in the operation.
#
#
#
# Example 1:
#
# Input: k = 5
#
# Output: "b"
#
# Explanation:
#
# Initially, word = "a". We need to do the operation three times:
#
# Generated string is "b", word becomes "ab".
# Generated string is "bc", word becomes "abbc".
# Generated string is "bccd", word becomes "abbcbccd".
# Example 2:
#
# Input: k = 10
#
# Output: "c"
#
#
#
# Constraints:
#
# 1 <= k <= 500
class Solution:
    def kthCharacter(self, k: int) -> str:
        eng_al: str = 'abcdefghijklmnopqrstuvwxyz'
        output: list[str] = ['a']
        while len(output) < k:
            curr_sub: list[str] = []
            for char in output:
                curr_sub.append(eng_al[(ord(char) + 1) % 26 - 19])
            output.extend(curr_sub)
        return output[k - 1]

# 3305. Count of Substrings Containing Every Vowel and K Consonants I
# You are given a string word and a non-negative integer k.
#
# Return the total number of
# substrings
#  of word that contain every vowel ('a', 'e', 'i', 'o', and 'u') at least once and exactly k consonants.
#
#
#
# Example 1:
#
# Input: word = "aeioqq", k = 1
#
# Output: 0
#
# Explanation:
#
# There is no substring with every vowel.
#
# Example 2:
#
# Input: word = "aeiou", k = 0
#
# Output: 1
#
# Explanation:
#
# The only substring with every vowel and zero consonants is word[0..4], which is "aeiou".
#
# Example 3:
#
# Input: word = "ieaouqqieaouqq", k = 1
#
# Output: 3
#
# Explanation:
#
# The substrings with every vowel and one consonant are:
#
# word[0..5], which is "ieaouq".
# word[6..11], which is "qieaou".
# word[7..12], which is "ieaouq".
#
#
# Constraints:
#
# 5 <= word.length <= 250
# word consists only of lowercase English letters.
# 0 <= k <= word.length - 5
# Python Brute Force O(N**2) O(1)
class Solution:
    def countOfSubstrings(self, word: str, k: int) -> int:
        count: int = 0
        for left in range(len(word)):
            vow: dict = dict()
            const: int = 0
            for right in range(left, len(word)):
                if word[right] in 'aeoiu':
                    vow[word[right]] = vow.get(word[right], 0) + 1
                else: const += 1
                if len(vow) == 5 and const == k: count += 1
        return count
# Python Sliding Window O(N) O(1)
from collections import defaultdict
class Solution:
    def countOfSubstrings(self, word: str, k: int) -> int:
        vowels: set[str] = set("aeiou")
        hashmap: dict[str, int] = defaultdict(int)
        consonants: int = 0
        left: int = 0
        answer: int = 0
        for right in range(len(word)):
            if word[right] in vowels:
                hashmap[word[right]] += 1
            else: consonants += 1
            while consonants > k:
                if word[left] in hashmap :
                    hashmap[word[left]] -= 1
                    if hashmap[word[left]] == 0:
                        del hashmap[word[left]]
                else: consonants -= 1
                left += 1
            if len(hashmap) == 5 and consonants == k:
                answer += 1
                second_left: int = left
                second_hashmap: dict[str, int] = hashmap.copy()
                second_consonants: int = consonants
                while len(second_hashmap) == 5:
                    if word[second_left] in second_hashmap:
                        second_hashmap[word[second_left]] -= 1
                        if second_hashmap[word[second_left]] == 0:
                            del second_hashmap[word[second_left]]
                    else:second_consonants -= 1
                    second_left += 1
                    if second_consonants == k and len(second_hashmap) == 5:
                        answer += 1
                    if consonants < k: break
        return answer


# 2696. Minimum String Length After Removing Substrings
# You are given a string s consisting only of uppercase English letters.
#
# You can apply some operations to this string where, in one operation, you can remove any occurrence of one of the substrings "AB" or "CD" from s.
#
# Return the minimum possible length of the resulting string that you can obtain.
#
# Note that the string concatenates after removing the substring and could produce new "AB" or "CD" substrings.
#
#
#
# Example 1:
#
# Input: s = "ABFCACDB"
# Output: 2
# Explanation: We can do the following operations:
# - Remove the substring "ABFCACDB", so s = "FCACDB".
# - Remove the substring "FCACDB", so s = "FCAB".
# - Remove the substring "FCAB", so s = "FC".
# So the resulting length of the string is 2.
# It can be shown that it is the minimum length that we can obtain.
# Example 2:
#
# Input: s = "ACBBD"
# Output: 5
# Explanation: We cannot do any operations on the string so the length remains the same.
#
#
# Constraints:
#
# 1 <= s.length <= 100
# s consists only of uppercase English letters.
# Python O(N) O(N) Stack String
class Solution:
    def minLength(self, s: str) -> int:
        stack: list[str] = []
        for char in s:
            if stack:
                if char == 'B' and stack[-1] == 'A':
                    stack.pop()
                elif char == 'D' and stack[-1] == 'C':
                    stack.pop()
                else: stack.append(char)
            else: stack.append(char)
        return len(stack)

# C++ O(N) O(N) Stack String
class Solution {
public:
    int minLength(string s) {
        std::stack<char> storage;
        for (char letter : s) {
            if (!storage.empty()) {
                if (letter == 'B' && storage.top() == 'A') {
                    storage.pop();
                } else if (letter == 'D' && storage.top() == 'C') {
                    storage.pop();
                } else {
                    storage.push(letter);
                }
            } else {
                storage.push(letter);
            }
        }
        return storage.size();
    }
};

# A. Bachgold Problem
# A. Bachgold Problem
# time limit per test1 second
# memory limit per test256 megabytes
# Bachgold problem is very easy to formulate. Given a positive integer n represent it as a sum of maximum possible number of prime numbers. One can prove that such representation exists for any integer greater than 1.
#
# Recall that integer k is called prime if it is greater than 1 and has exactly two positive integer divisors — 1 and k.
#
# Input
# The only line of the input contains a single integer n (2 ≤ n ≤ 100 000).
#
# Output
# The first line of the output contains a single integer k — maximum possible number of primes in representation.
#
# The second line should contain k primes with their sum equal to n. You can print them in any order. If there are several optimal solution, print any of them.
#
# Examples
# inputCopy
# 5
# outputCopy
# 2
# 2 3
# inputCopy
# 6
# outputCopy
# 3
# 2 2 2
# Python O(N) O(1) Math
import sys


def solution(n: int) -> str:
    modules: list = [2, 3]
    sys.stdout.write(str(n // 2) + '\n')
    if n & 1 == 0:
        return ' '.join('2' for _ in range(n // 2))
    return ' '.join('2' for _ in range(n // 2 - 1)) + ' 3'


if __name__ == '__main__':
    n: int = int(sys.stdin.readline().rstrip())
    sys.stdout.write(solution(n))

# C++ O(N) O(1) Math
#include <iostream>

int main() {
    int n;
    std::cin >> n;
    std::cout << n / 2 << std::endl;
    if (n % 2 == 0) {
        for (int rep = 0; rep < n / 2; ++rep) {
            if (rep != 0) {
                std::cout << " ";
            }
            std::cout << 2;
        }
    } else {
        for (int rep = 0; rep < n / 2 - 1; ++rep) {
            if (rep != 0) {
                std::cout << " ";
            }
            std::cout << 2;
        }
        std::cout << " 3";
    }
}

# Fill None
# Task
# Write a function that accepts a list that can contain missing data, and an integer representing the method on how to fill the missing data if there is any. Missing data is represented as None. The list will only contain integers and None values.
#
# Note that depending on the language you attempt this kata with, None corresponds to:
#
# None (Python)
# undefined (Javascript)
# Nothing (Haskell)
# The fill method rules are outlined below:
#
# Fill method:
#   -1: backwards
#    0: nearest
#    1: forwards
# Example
# arr = [None, 1, None, None, None, 2, None]
#
# fill(arr, -1) == [1, 1, 2, 2, 2, 2, None]  # None replaced by closest int on the right
# fill(arr,  0) == [1, 1, 1, 1, 2, 2, 2]     # None replaced by closest int. If equidistant, choose the smallest int
# fill(arr,  1) == [None, 1, 1, 1, 1, 2, 2]  # None replaced by closest int on the left
# Notes
# [] should return []
# [None] should return [None]
# Arrays will only contain integers and None values
# FUNDAMENTALS
def get_right_bound(target: int, sources: list[int]) -> int:
    for idx in sources:
        if idx > target: return idx
    return -1


def get_left_bound(target: int, sources: list[int]) -> int:
    for idx in sources[::-1]:
        if idx < target: return idx
    return -1


def fill(arr, method=0):
    if method != 0:
        for idx in range(len(arr)):
            if arr[idx] is None:
                if method == -1:
                    arr[idx] = arr[min(idx + 1, len(arr) - 1)]
                else: arr[idx] = arr[max(idx - 1, 0)]
        for idx in range(len(arr) - 1, -1, -1):
            if arr[idx] is None:
                if method == -1:
                    arr[idx] = arr[min(idx + 1, len(arr) - 1)]
                else: arr[idx] = arr[max(idx - 1, 0)]
        return arr
    storage: list[int] = [idx for idx in range(len(arr)) if arr[idx] is not None]
    for idx in range(len(arr)):
        if arr[idx] is None:
            right_part: int = get_right_bound(idx, storage)
            left_part: int = get_left_bound(idx, storage)
            if right_part == left_part == -1: continue
            elif right_part == -1: right_part = left_part
            elif left_part == -1: left_part = right_part
            if idx - left_part == right_part - idx:
                arr[idx] = min(arr[left_part], arr[right_part])
            else:
                arr[idx] = arr[[left_part, right_part][idx - left_part > right_part - idx]]
    return arr

# 1963. Minimum Number of Swaps to Make the String Balanced
# You are given a 0-indexed string s of even length n. The string consists of exactly n / 2 opening brackets '[' and n / 2 closing brackets ']'.
#
# A string is called balanced if and only if:
#
# It is the empty string, or
# It can be written as AB, where both A and B are balanced strings, or
# It can be written as [C], where C is a balanced string.
# You may swap the brackets at any two indices any number of times.
#
# Return the minimum number of swaps to make s balanced.
#
#
#
# Example 1:
#
# Input: s = "][]["
# Output: 1
# Explanation: You can make the string balanced by swapping index 0 with index 3.
# The resulting string is "[[]]".
# Example 2:
#
# Input: s = "]]][[["
# Output: 2
# Explanation: You can do the following to make the string balanced:
# - Swap index 0 with index 4. s = "[]][][".
# - Swap index 1 with index 5. s = "[[][]]".
# The resulting string is "[[][]]".
# Example 3:
#
# Input: s = "[]"
# Output: 0
# Explanation: The string is already balanced.
#
#
# Constraints:
#
# n == s.length
# 2 <= n <= 106
# n is even.
# s[i] is either '[' or ']'.
# The number of opening brackets '[' equals n / 2, and the number of closing brackets ']' equals n / 2.
# C++ O(N) O(1) Two Pointers Greedy
class Solution {
public:
    int minSwaps(string s) {
        int open_br = 0, close_br = 0;
        int right = s.size() - 1;
        int swaps = 0;
        for (int left = 0; left < s.size(); ++left) {
            if (s[left] == '[') {
                open_br += 1;
            } else {
                close_br += 1;
            }
            if (close_br > open_br) {
                while (right >= 0 && s[right] != ']') {
                    right -= 1;
                }
                swaps += 1;
                right -= 1;
                open_br += 1;
                close_br -= 1;
            }
        }
        return swaps;
    }
};

# Python O(N) O(1) Two Pointers Greedy
class Solution:
    def minSwaps(self, s: str) -> int:
        open_br: int = 0
        close_br: int = 0
        left: int = 0
        right: int = 0
        swaps: int = 0
        while left < len(s):
            if s[left] == '[':
                open_br += 1
            else:
                close_br += 1
            if close_br > open_br:
                while right >= 0 and s[right]  != '[':
                    right -= 1
                swaps += 1
                open_br += 1
                close_br -= 1
                right -= 1
            left += 1
        return swaps

# Matrix Exponentiation
# Your task in this kata is to write a function which will take a square matrix and a non-negative integer n as inputs and return a matrix raised to the power n.
#
# Be ready to handle big ns.
#
# Example:
#
# A = [[1, 2], [1, 0]]
# calc(A, 2) = [[3, 2], [1, 2]]
# External aiding modules disabled
#
# ARRAYSMATRIXALGORITHMSLOGIC
def matrix_multiply(A, B):
    n = len(A)
    result = [[0] * n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            for k in range(n):
                result[i][j] += A[i][k] * B[k][j]
    return result

def calc(matrix, n):
    if n == 0:
        size = len(matrix)
        return [[1 if i == j else 0 for j in range(size)] for i in range(size)]
    elif n == 1: return matrix

    half_power = calc(matrix, n // 2)

    if n % 2 == 0:
        return matrix_multiply(half_power, half_power)
    else:
        return matrix_multiply(matrix, matrix_multiply(half_power, half_power))


# B. ICPC Balloons
# B. ICPC Balloons
# time limit per test1 second
# memory limit per test256 megabytes
# In an ICPC contest, balloons are distributed as follows:
#
# Whenever a team solves a problem, that team gets a balloon.
# The first team to solve a problem gets an additional balloon.
# A contest has 26 problems, labelled A
# , B
# , C
# , ..., Z
# . You are given the order of solved problems in the contest, denoted as a string s
# , where the i
# -th character indicates that the problem si
#  has been solved by some team. No team will solve the same problem twice.
# Determine the total number of balloons that the teams received. Note that some problems may be solved by none of the teams.
#
# Input
# The first line of the input contains an integer t
#  (1≤t≤100
# ) — the number of testcases.
#
# The first line of each test case contains an integer n
#  (1≤n≤50
# ) — the length of the string.
#
# The second line of each test case contains a string s
#  of length n
#  consisting of uppercase English letters, denoting the order of solved problems.
#
# Output
# For each test case, output a single integer — the total number of balloons that the teams received.
#
# Example
# inputCopy
# 6
# 3
# ABA
# 1
# A
# 3
# ORZ
# 5
# BAAAA
# 4
# BKPT
# 10
# CODEFORCES
# outputCopy
# 5
# 2
# 6
# 7
# 8
# 17
# Note
# In the first test case, 5
#  balloons are given out:
#
# Problem A
#  is solved. That team receives 2
#  balloons: one because they solved the problem, an an additional one because they are the first team to solve problem A
# .
# Problem B
#  is solved. That team receives 2
#  balloons: one because they solved the problem, an an additional one because they are the first team to solve problem B
# .
# Problem A
#  is solved. That team receives only 1
#  balloon, because they solved the problem. Note that they don't get an additional balloon because they are not the first team to solve problem A
# .
# The total number of balloons given out is 2+2+1=5
# .
# In the second test case, there is only one problem solved. The team who solved it receives 2
#  balloons: one because they solved the problem, an an additional one because they are the first team to solve problem A
# .
# Python O(N) O(N) Math HashSet
import sys


def solution(t: int) -> None:
    for _ in range(t):
        n: int = int(sys.stdin.readline().rstrip())
        tasks: list = list(sys.stdin.readline().rstrip())
        storage: set = set()
        total_count: int = 0
        for task in tasks:
            total_count += [2, 1][task in storage]
            storage.add(task)
        sys.stdout.write(str(total_count) + '\n')


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)

# C++ O(N) O(N) Math Hashset
#include <iostream>
#include <unordered_set>

int main() {
    int t;
    std::cin >> t;
    for (int rep = 0; rep < t; ++rep) {
        int n;
        std::cin >> n;
        std::unordered_set<char> storage;
        int total_count = 0;
        for (int index = 0; index < n; ++index) {
            char task;
            std::cin >> task;
            if (storage.count(task)) {
                total_count += 1;
            } else {
                total_count += 2;
            }
            storage.insert(task);
        }
        std::cout << total_count << std::endl;
    }
}

# 921. Minimum Add to Make Parentheses Valid
# A parentheses string is valid if and only if:
#
# It is the empty string,
# It can be written as AB (A concatenated with B), where A and B are valid strings, or
# It can be written as (A), where A is a valid string.
# You are given a parentheses string s. In one move, you can insert a parenthesis at any position of the string.
#
# For example, if s = "()))", you can insert an opening parenthesis to be "(()))" or a closing parenthesis to be "())))".
# Return the minimum number of moves required to make s valid.
#
#
#
# Example 1:
#
# Input: s = "())"
# Output: 1
# Example 2:
#
# Input: s = "((("
# Output: 3
#
#
# Constraints:
#
# 1 <= s.length <= 1000
# s[i] is either '(' or ')'.
# C++ O(N) O(1) Stack Greedy Counting
class Solution {
public:
    int minAddToMakeValid(string s) {
        int open_br = 0, close_br = 0;
        int count = 0;
        for (size_t index = 0; index < s.size(); ++index) {
            if (s[index] == '(') {
                open_br += 1;
            } else {
                close_br += 1;
                if (close_br > open_br) {
                    close_br -= 1;
                    count += 1;
                }
            }
        }
        return count + std::max(open_br - close_br, 0);
    }
};

# Python O(N) O(1) Counting Greedy Stack
class Solution:
    def minAddToMakeValid(self, s: str) -> int:
        open_br: int = 0
        close_br: int = 0
        count: int = 0
        for brace in s:
            if brace == '(':
                open_br += 1
            else: close_br += 1
            if close_br > open_br:
                count += 1
                close_br -= 1
        return count + max(open_br - close_br, 0)

# Find the smallest power higher than a given a value
/*
We have the number 12385 . We want to know the value of the closest cube but higher than 12385. The answer will be 13824 .

Now, another case. We have the number 1245678 . We want to know the 5th power, closest and higher than that number. The value will be 1419857.

We need a function find_next_power or findNextPower that receives two arguments, a value val , and the exponent of the power,  pow_ , and outputs the value that we want to find.

Let'see some cases:

(12385, 3) ==> 13824
(1245678, 5) ==> 1419857
The value, val will be always a positive integer.

The power, pow_ , always higher than 1 .

Happy coding!!

FUNDAMENTALSMATHEMATICSLOGIC
*/
#include <cmath>

unsigned long findNextPower(unsigned int val, unsigned int pow_) {
    // Calculate the initial base which is the integer part of the pow_ root of val
    unsigned long base = static_cast<unsigned long>(std::pow(val, 1.0 / pow_)) + 1;

    // Calculate the next power
    while (true) {
        unsigned long power_value = static_cast<unsigned long>(std::pow(base, pow_));
        if (power_value > val) {
            return power_value;
        }
        base++;
    }
}

# A. Brain's Photos
# A. Brain's Photos
# time limit per test2 seconds
# memory limit per test256 megabytes
# Small, but very brave, mouse Brain was not accepted to summer school of young villains. He was upset and decided to postpone his plans of taking over the world, but to become a photographer instead.
#
# As you may know, the coolest photos are on the film (because you can specify the hashtag #film for such).
#
# Brain took a lot of colourful pictures on colored and black-and-white film. Then he developed and translated it into a digital form. But now, color and black-and-white photos are in one folder, and to sort them, one needs to spend more than one hour!
#
# As soon as Brain is a photographer not programmer now, he asks you to help him determine for a single photo whether it is colored or black-and-white.
#
# Photo can be represented as a matrix sized n × m, and each element of the matrix stores a symbol indicating corresponding pixel color. There are only 6 colors:
#
# 'C' (cyan)
# 'M' (magenta)
# 'Y' (yellow)
# 'W' (white)
# 'G' (grey)
# 'B' (black)
# The photo is considered black-and-white if it has only white, black and grey pixels in it. If there are any of cyan, magenta or yellow pixels in the photo then it is considered colored.
#
# Input
# The first line of the input contains two integers n and m (1 ≤ n, m ≤ 100) — the number of photo pixel matrix rows and columns respectively.
#
# Then n lines describing matrix rows follow. Each of them contains m space-separated characters describing colors of pixels in a row. Each character in the line is one of the 'C', 'M', 'Y', 'W', 'G' or 'B'.
#
# Output
# Print the "#Black&White" (without quotes), if the photo is black-and-white and "#Color" (without quotes), if it is colored, in the only line.
#
# Examples
# inputCopy
# 2 2
# C M
# Y Y
# outputCopy
# #Color
# inputCopy
# 3 2
# W W
# W W
# B B
# outputCopy
# #Black&White
# inputCopy
# 1 1
# W
# outputCopy
# #Black&White
# Python O(N + M) O(1) Matrix
import sys


def solution(n: int, m: int) -> str:
    for row in range(n):
        if any(color in {'C', 'M', 'Y'} for color in sys.stdin.readline().rstrip().split()):
            return '#Color'
    return '#Black&White'


if __name__ == '__main__' :
    n, m = map(int, sys.stdin.readline().rstrip().split())
    sys.stdout.write(solution(n, m))

# C++ O(N + M) O(1) Matrix
#include <iostream>

int main() {
    int n, m;
    std::cin >> n >> m;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            char lt;
            std::cin >> lt;
            if (lt == 'C' || lt == 'M' || lt == 'Y') {
                std::cout << "#Color" << std::endl;
                return 0;
            }
        }
    }
    std::cout << "#Black&White" << std::endl;
}

# 962. Maximum Width Ramp
# A ramp in an integer array nums is a pair (i, j) for which i < j and nums[i] <= nums[j]. The width of such a ramp is j - i.
#
# Given an integer array nums, return the maximum width of a ramp in nums. If there is no ramp in nums, return 0.
#
#
#
# Example 1:
#
# Input: nums = [6,0,8,2,1,5]
# Output: 4
# Explanation: The maximum width ramp is achieved at (i, j) = (1, 5): nums[1] = 0 and nums[5] = 5.
# Example 2:
#
# Input: nums = [9,8,1,0,1,9,4,0,4,1]
# Output: 7
# Explanation: The maximum width ramp is achieved at (i, j) = (2, 9): nums[2] = 1 and nums[9] = 1.
#
#
# Constraints:
#
# 2 <= nums.length <= 5 * 104
# 0 <= nums[i] <= 5 * 104
# Python O(N) O(N) Monotonic Stack
class Solution:
    def maxWidthRamp(self, nums: List[int]) -> int:
        stack: list[int] = []
        for idx in range(len(nums)):
            if not stack or nums[stack[-1]] > nums[idx]:
                stack.append(idx)
        max_length: int = 0
        for right in range(len(nums) - 1, -1, -1):
            while stack and nums[stack[-1]] <= nums[right]:
                max_length = max(max_length, right - stack.pop())
        return max_length
# C++ O(N) O(N) Monotonic Stack
class Solution {
public:
    int maxWidthRamp(vector<int>& nums) {
        std::vector<int> stack;
        for (int index = 0; index < nums.size(); ++index) {
            if (!stack.size() || nums[stack[stack.size() - 1]] > nums[index]) {
                stack.push_back(index);
            }
        }
        int max_length = 0;
        for (int right = nums.size() - 1; right >= 0; --right) {
            while (stack.size() && nums[stack[stack.size() - 1]] <= nums[right]) {
                max_length = std::max(max_length, right - stack[stack.size() - 1]);
                stack.pop_back();
            }
        }
        return max_length;
    }
};
# Python O(N) O(N) Two Pointers
class Solution:
    def maxWidthRamp(self, nums: List[int]) -> int:
        right_idxs: list[int] = [0] * len(nums)
        right_idxs[len(nums) - 1] = nums[len(nums) - 1]
        for idx in range(len(nums) - 2, -1, -1):
            right_idxs[idx] = max(nums[idx], right_idxs[idx + 1])
        left: int = 0
        right: int = 0
        max_length: int = 0
        while right < len(right_idxs):
            while left < right and nums[left] > right_idxs[right]:
                left += 1
            max_length = max(max_length, right - left)
            right += 1
        return max_length
# C++ O(N) O(N) Two Pointers
class Solution {
public:
    int maxWidthRamp(vector<int>& nums) {
        int n = nums.size();
        std::vector<int> right_idxs(n, 0);
        right_idxs[n - 1] = nums[n - 1];
        for (int index = n - 2; index >= 0; --index) {
            right_idxs[index] = std::max(right_idxs[index + 1], nums[index]);
        }
        int left = 0, right = 0;
        int max_length = 0;
        while (right < n) {
            while (left < right && nums[left] > right_idxs[right]) {
                ++left;
            }
            max_length = std::max(max_length, right - left);
            ++right;
        }
        return max_length;
    }
};

# B. New Year's Number
# B. New Year's Number
# time limit per test2 seconds
# memory limit per test256 megabytes
# Polycarp remembered the 2020
# -th year, and he is happy with the arrival of the new 2021
# -th year. To remember such a wonderful moment, Polycarp wants to represent the number n
#  as the sum of a certain number of 2020
#  and a certain number of 2021
# .
#
# For example, if:
#
# n=4041
# , then the number n
#  can be represented as the sum 2020+2021
# ;
# n=4042
# , then the number n
#  can be represented as the sum 2021+2021
# ;
# n=8081
# , then the number n
#  can be represented as the sum 2020+2020+2020+2021
# ;
# n=8079
# , then the number n
#  cannot be represented as the sum of the numbers 2020
#  and 2021
# .
# Help Polycarp to find out whether the number n
#  can be represented as the sum of a certain number of numbers 2020
#  and a certain number of numbers 2021
# .
#
# Input
# The first line contains one integer t
#  (1≤t≤104
# ) — the number of test cases. Then t
#  test cases follow.
#
# Each test case contains one integer n
#  (1≤n≤106
# ) — the number that Polycarp wants to represent as the sum of the numbers 2020
#  and 2021
# .
#
# Output
# For each test case, output on a separate line:
#
# "YES" if the number n
#  is representable as the sum of a certain number of 2020
#  and a certain number of 2021
# ;
# "NO" otherwise.
# You can output "YES" and "NO" in any case (for example, the strings yEs, yes, Yes and YES will be recognized as positive).
#
# Example
# inputCopy
# 5
# 1
# 4041
# 4042
# 8081
# 8079
# outputCopy
# NO
# YES
# YES
# YES
# NO
# C++ O(1) O(1) Math
#include <iostream>

int main() {
    int t;
    std::cin >> t;
    for (int i = 0; i < t; ++i) {
        int n;
        std::cin >> n;
        bool found = false;
        for (int x = 0; x <= n / 2020; ++x) {
            int remaining = n - 2020 * x;
            if (remaining >= 0 && remaining % 2021 == 0) {
                found = true;
                break;
            }
        }
        std::cout << (found ? "YES" : "NO") << std::endl;
    }
}
# Python O(1) O(1) Math
import sys


def solution(t: int) -> None:
    for _ in range(t):
        n: int = int(sys.stdin.readline().rstrip())
        valid: bool = False
        for x in range(n // 2020 + 1):
            remainder: int = n - 2020 * x
            if remainder >= 0 and remainder % 2021 == 0:
                valid = True
                break
        sys.stdout.write(['NO', 'YES'][valid] + '\n')


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)


# How Many Streets?
# The longest street in the world, MAX_STREET, is crossed by many other streets and driven by many drivers. Determine how many streets each driver crosses.
#
# Inputs
# (1) A list (or array, depending on language) of streets that intersect MAX_STREET. (2) A list (or array, depending on language) of drivers. Each driver is represented by a pair of streets. The first element of the pair is the street where they enter MAX_STREET; the second is the street they exit. The driver crosses all the streets between those two streets.
#
# Output
# A list (or array, depending on language) showing how many streets each driver crosses.
#
# Example
# count_streets(["first", "second", "third", "fourth", "fifth", "sixth", "seventh"],
#                [("first", "second"), ("second", "seventh"), ("sixth", "fourth")]) should return [0,4,1].
#
# Details:
# (1) Each street name is a non-empty word of no more than 10 letters. There are no duplicate street names.
#
# (2) The entry and exit streets for each driver are distinct. They are guaranteed to come from the list of streets.
#
# (3) The number of streets n satisfies 2 ≤ n ≤ 105. The number of drivers d satisfies 1 ≤ d ≤ 105. So efficiency is important.
#
# Source: International Collegiate Programming Contest, North Central North American Regional, 2022.
#
# ARRAYSSEARCHINGPERFORMANCE
def count_streets(streets, drivers):
    output: list[int] = []
    storage: dict[str, int] = dict()
    distance: int = 1
    for street in streets:
        storage[street] = distance
        distance += 1
    for start, end in drivers:
        start_d: int = storage[start]
        end_d: int = storage[end]
        output.append(max(start_d, end_d) - min(start_d, end_d) - 1)
    return output

# 1942. The Number of the Smallest Unoccupied Chair
# There is a party where n friends numbered from 0 to n - 1 are attending. There is an infinite number of chairs in this party that are numbered from 0 to infinity. When a friend arrives at the party, they sit on the unoccupied chair with the smallest number.
#
# For example, if chairs 0, 1, and 5 are occupied when a friend comes, they will sit on chair number 2.
# When a friend leaves the party, their chair becomes unoccupied at the moment they leave. If another friend arrives at that same moment, they can sit in that chair.
#
# You are given a 0-indexed 2D integer array times where times[i] = [arrivali, leavingi], indicating the arrival and leaving times of the ith friend respectively, and an integer targetFriend. All arrival times are distinct.
#
# Return the chair number that the friend numbered targetFriend will sit on.
#
#
#
# Example 1:
#
# Input: times = [[1,4],[2,3],[4,6]], targetFriend = 1
# Output: 1
# Explanation:
# - Friend 0 arrives at time 1 and sits on chair 0.
# - Friend 1 arrives at time 2 and sits on chair 1.
# - Friend 1 leaves at time 3 and chair 1 becomes empty.
# - Friend 0 leaves at time 4 and chair 0 becomes empty.
# - Friend 2 arrives at time 4 and sits on chair 0.
# Since friend 1 sat on chair 1, we return 1.
# Example 2:
#
# Input: times = [[3,10],[1,5],[2,6]], targetFriend = 0
# Output: 2
# Explanation:
# - Friend 1 arrives at time 1 and sits on chair 0.
# - Friend 2 arrives at time 2 and sits on chair 1.
# - Friend 0 arrives at time 3 and sits on chair 2.
# - Friend 1 leaves at time 5 and chair 0 becomes empty.
# - Friend 2 leaves at time 6 and chair 1 becomes empty.
# - Friend 0 leaves at time 10 and chair 2 becomes empty.
# Since friend 0 sat on chair 2, we return 2.
#
#
# Constraints:
#
# n == times.length
# 2 <= n <= 104
# times[i].length == 2
# 1 <= arrivali < leavingi <= 105
# 0 <= targetFriend <= n - 1
# Each arrivali time is distinct.
# Python O(NlogN) O(N) HashMap Priority Queue
import heapq
class Solution:
    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:
        storage: dict[tuple[int, int], int] = dict()
        for friend in range(len(times)):
            storage[(times[friend][0], times[friend][1])] = friend
        times.sort()
        occupied: list[list[int]] = []
        unoccupied: list[int] = []
        max_room: int = 0
        for time in times:
            arrival, leave = time
            while occupied and occupied[0][0] <= arrival:
                heapq.heappush(unoccupied, heapq.heappop(occupied)[2])
            next_room: int = max_room
            if unoccupied:
                next_room = heapq.heappop(unoccupied)
            else:
                max_room += 1
            heapq.heappush(occupied, [leave, arrival, next_room])
            if storage[(arrival, leave)] == targetFriend:
                return next_room

# C++ O(NlogN) O(N) HashMap Priority Queue
#include <unordered_map>
#include <vector>
#include <queue>
#include <algorithm>
#include <tuple>

class Solution {
public:
    int smallestChair(std::vector<std::vector<int>>& times, int targetFriend) {
        std::unordered_map<int, int> friends;
        for (int index = 0; index < times.size(); ++index) {
            friends[index] = index;
        }
        auto cmp = [](const std::pair<int, int>& a, const std::pair<int, int>& b) {
            return a.first > b.first;
        };
        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, decltype(cmp)> occupied(cmp);
        std::priority_queue<int, std::vector<int>, std::greater<int>> unoccupied;
        int max_room = 0;
        std::vector<std::tuple<int, int, int>> events;
        for (int i = 0; i < times.size(); ++i) {
            events.emplace_back(times[i][0], times[i][1], i);
        }
        std::sort(events.begin(), events.end());
        for (const auto& event : events) {
            int start = std::get<0>(event);
            int end = std::get<1>(event);
            int friendIndex = std::get<2>(event);
            while (!occupied.empty() && occupied.top().first <= start) {
                unoccupied.push(occupied.top().second);
                occupied.pop();
            }
            int chair;
            if (!unoccupied.empty()) {
                chair = unoccupied.top();
                unoccupied.pop();
            } else {
                chair = max_room++;
            }
            if (friendIndex == targetFriend) {
                return chair;
            }
            occupied.emplace(end, chair);
        }
        return -1;
    }
};

# Square Every Digit
/*
Welcome. In this kata, you are asked to square every digit of a number and concatenate them.

For example, if we run 9119 through the function, 811181 will come out, because 92 is 81 and 12 is 1. (81-1-1-81)

Example #2: An input of 765 will/should return 493625 because 72 is 49, 62 is 36, and 52 is 25. (49-36-25)

Note: The function accepts an integer and returns an integer.

Happy Coding!

MATHEMATICSFUNDAMENTALS
*/
#include <string>
#include <iostream>
#include <sstream>

int square_digits(int num) {
    std::string num_str = std::to_string(num);
    std::ostringstream output;
    for (char digit : num_str) {
        int digit_int = digit - '0';
        output << (digit_int * digit_int);
    }
    std::string result_str = output.str();
    std::cout << result_str << std::endl;
    return std::stoi(result_str);
}

# B. BerSU Ball
# B. BerSU Ball
# time limit per test1 second
# memory limit per test256 megabytes
# The Berland State University is hosting a ballroom dance in celebration of its 100500-th anniversary! n boys and m girls are already busy rehearsing waltz, minuet, polonaise and quadrille moves.
#
# We know that several boy&girl pairs are going to be invited to the ball. However, the partners' dancing skill in each pair must differ by at most one.
#
# For each boy, we know his dancing skills. Similarly, for each girl we know her dancing skills. Write a code that can determine the largest possible number of pairs that can be formed from n boys and m girls.
#
# Input
# The first line contains an integer n (1 ≤ n ≤ 100) — the number of boys. The second line contains sequence a1, a2, ..., an (1 ≤ ai ≤ 100), where ai is the i-th boy's dancing skill.
#
# Similarly, the third line contains an integer m (1 ≤ m ≤ 100) — the number of girls. The fourth line contains sequence b1, b2, ..., bm (1 ≤ bj ≤ 100), where bj is the j-th girl's dancing skill.
#
# Output
# Print a single number — the required maximum possible number of pairs.
#
# Examples
# inputCopy
# 4
# 1 4 6 2
# 5
# 5 1 5 7 9
# outputCopy
# 3
# inputCopy
# 4
# 1 2 3 4
# 4
# 10 11 12 13
# outputCopy
# 0
# inputCopy
# 5
# 1 1 1 1 1
# 3
# 1 2 3
# outputCopy
# 2
# Solution
# Python O(NlogN) O(1) Two Pointers
import sys


def solution(boys: list, girls: list) -> str:
    boys.sort()
    girls.sort()
    left: int = 0
    right: int = 0
    pairs: int = 0
    while left < len(boys) and right < len(girls):
        if abs(boys[left] - girls[right]) <= 1:
            pairs += 1
            left += 1
            right += 1
        elif boys[left] < girls[right]:
            left += 1
        else:
            right += 1
    return str(pairs)


if __name__ == '__main__':
    n: int = int(sys.stdin.readline().rstrip())
    boys: list = list(map(int, sys.stdin.readline().rstrip().split()))
    m: int = int(sys.stdin.readline().rstrip())
    girls: list = list(map(int, sys.stdin.readline().rstrip().split()))
    sys.stdout.write(solution(boys, girls))


# C++ O(NlogN) O(1) Two Pointers
#include <iostream>
#include <cmath>
#include <vector>
#include <algorithm>

int main() {
    int n;
    std::cin >> n;
    std::vector<int> boys;
    for (int i = 0; i < n; ++i) {
        int boy;
        std::cin >> boy;
        boys.push_back(boy);
    }
    int m;
    std::cin >> m;
    std::vector<int> girls;
    for (int i = 0; i < m; ++i) {
        int girl;
        std::cin >> girl;
        girls.push_back(girl);
    }
    std::sort(boys.begin(), boys.end());
    std::sort(girls.begin(), girls.end());
    int left = 0, right = 0;
    int pairs = 0;
    while (left < boys.size() && right < girls.size()) {
        if (std::abs(boys[left] - girls[right]) <= 1) {
            pairs += 1;
            left += 1;
            right += 1;
        } else if (boys[left] < girls[right]) {
            left += 1;
        } else {
            right += 1;
        }
    }
    std::cout << pairs << std::endl;
}

# 2406. Divide Intervals Into Minimum Number of Groups
# You are given a 2D integer array intervals where intervals[i] = [lefti, righti] represents the inclusive interval [lefti, righti].
#
# You have to divide the intervals into one or more groups such that each interval is in exactly one group, and no two intervals that are in the same group intersect each other.
#
# Return the minimum number of groups you need to make.
#
# Two intervals intersect if there is at least one common number between them. For example, the intervals [1, 5] and [5, 8] intersect.
#
#
#
# Example 1:
#
# Input: intervals = [[5,10],[6,8],[1,5],[2,3],[1,10]]
# Output: 3
# Explanation: We can divide the intervals into the following groups:
# - Group 1: [1, 5], [6, 8].
# - Group 2: [2, 3], [5, 10].
# - Group 3: [1, 10].
# It can be proven that it is not possible to divide the intervals into fewer than 3 groups.
# Example 2:
#
# Input: intervals = [[1,3],[5,6],[8,10],[11,13]]
# Output: 1
# Explanation: None of the intervals overlap, so we can put all of them in one group.
#
#
# Constraints:
#
# 1 <= intervals.length <= 105
# intervals[i].length == 2
# 1 <= lefti <= righti <= 106
class Solution:
    def minGroups(self, intervals: List[List[int]]) -> int:
        intervals.sort()
        heap: list[int] = []
        for start, end in intervals:
            if heap and heap[0] < start:
                heapq.heappop(heap)
            heapq.heappush(heap, end)
        return len(heap)


# B. Good Kid
# time limit per test1 second
# memory limit per test256 megabytes
# Slavic is preparing a present for a friend's birthday. He has an array a
#  of n
#  digits and the present will be the product of all these digits. Because Slavic is a good kid who wants to make the biggest product possible, he wants to add 1
#  to exactly one of his digits.
#
# What is the maximum product Slavic can make?
#
# Input
# The first line contains a single integer t
#  (1≤t≤104
# ) — the number of test cases.
#
# The first line of each test case contains a single integer n
#  (1≤n≤9
# ) — the number of digits.
#
# The second line of each test case contains n
#  space-separated integers ai
#  (0≤ai≤9
# ) — the digits in the array.
#
# Output
# For each test case, output a single integer — the maximum product Slavic can make, by adding 1
#  to exactly one of his digits.
#
# Example
# inputCopy
# 4
# 4
# 2 2 1 2
# 3
# 0 1 2
# 5
# 4 3 2 3 4
# 9
# 9 9 9 9 9 9 9 9 9
# outputCopy
# 16
# 2
# 432
# 430467210
import sys
import math


def solution(t: int) -> None:
    for _ in range(t):
        n: int = int(sys.stdin.readline().rstrip())
        a: list = sorted(map(int, sys.stdin.readline().rstrip().split()))
        a[0] += 1
        sys.stdout.write(str(math.prod(a)) + '\n')


if __name__ == '__main__':
    t: int = int(sys.stdin.readline().rstrip())
    solution(t)


# Simple string characters
/*
In this Kata, you will be given a string and your task will be to return a list of ints detailing the count of uppercase letters, lowercase, numbers and special characters (everything else), as follows.

The order is: uppercase letters, lowercase letters, numbers and special characters.

"*'&ABCDabcde12345" --> [ 4, 5, 5, 3 ]
More examples in the test cases.

Good luck!

FUNDAMENTALS
*/
std::vector<int> solve(std::string s){
    std::vector<int> output(4, 0);
    for (char lt : s) {
      if (lt >= 'A' && lt <= 'Z') {
        output[0] += 1;
      } else if (lt >= 'a' && lt <= 'z') {
        output[1] += 1;
      } else if (lt >= '0' && lt <= '9') {
        output[2] += 1;
      } else {
        output[3] += 1;
      }
    }
  return output;
}

# 303. Range Sum Query - Immutable
# Given an integer array nums, handle multiple queries of the following type:
# Calculate the sum of the elements of nums between indices left and right inclusive where left <= right.
# Implement the NumArray class:
# NumArray(int[] nums) Initializes the object with the integer array nums.
# int sumRange(int left, int right) Returns the sum of the elements of nums between indices left
# and right inclusive (i.e. nums[left] + nums[left + 1] + ... + nums[right]).
#
# Example 1:
#
# Input
# ["NumArray", "sumRange", "sumRange", "sumRange"]
# [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]
# Output
# [null, 1, -1, -3]
#
# Explanation
# NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);
# numArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1
# numArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1
# numArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3
#
# Constraints:
# 1 <= nums.length <= 104
# -105 <= nums[i] <= 105
# 0 <= left <= right < nums.length
# At most 104 calls will be made to sumRange.
# Python O(N) O(N) Prefix Sum
class NumArray:

    def __init__(self, nums: List[int]) -> None:
        self.prefix_sum: list[int] = []
        current_sum: int = 0
        for num in nums:
            current_sum += num
            self.prefix_sum.append(current_sum)

    def sumRange(self, left: int, right: int) -> int:
        left_sum: int = self.prefix_sum[left - 1] if left > 0 else 0
        right_sum: int = self.prefix_sum[right]
        return right_sum - left_sum


# Your NumArray object will be instantiated and called as such:
# obj = NumArray(nums)
# param_1 = obj.sumRange(left,right)
# C++ O(N) O(N) Prefix Sum
class NumArray {
public:
    NumArray(vector<int>& nums) {
        int currentSum = 0;
        for (int num : nums) {
            currentSum += num;
            prefixSum.push_back(currentSum);
        }
    }

    int sumRange(int left, int right) {
        int leftSum = (left > 0 ? prefixSum[left - 1] : 0);
        int rightSum = prefixSum[right];
        return rightSum - leftSum;
    }
private:
    std::vector<int> prefixSum;
};

/**
 * Your NumArray object will be instantiated and called as such:
 * NumArray* obj = new NumArray(nums);
 * int param_1 = obj->sumRange(left,right);
 */

# 304. Range Sum Query 2D - Immutable
# Given a 2D matrix matrix, handle multiple queries of the following type:
#
# Calculate the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).
# Implement the NumMatrix class:
#
# NumMatrix(int[][] matrix) Initializes the object with the integer matrix matrix.
# int sumRegion(int row1, int col1, int row2, int col2) Returns the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).
# You must design an algorithm where sumRegion works on O(1) time complexity.
#
#
#
# Example 1:
#
#
# Input
# ["NumMatrix", "sumRegion", "sumRegion", "sumRegion"]
# [[[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]], [2, 1, 4, 3], [1, 1, 2, 2], [1, 2, 2, 4]]
# Output
# [null, 8, 11, 12]
#
# Explanation
# NumMatrix numMatrix = new NumMatrix([[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]);
# numMatrix.sumRegion(2, 1, 4, 3); // return 8 (i.e sum of the red rectangle)
# numMatrix.sumRegion(1, 1, 2, 2); // return 11 (i.e sum of the green rectangle)
# numMatrix.sumRegion(1, 2, 2, 4); // return 12 (i.e sum of the blue rectangle)
#
#
# Constraints:
#
# m == matrix.length
# n == matrix[i].length
# 1 <= m, n <= 200
# -104 <= matrix[i][j] <= 104
# 0 <= row1 <= row2 < m
# 0 <= col1 <= col2 < n
# At most 104 calls will be made to sumRegion.
# C++ O(NM) O(NM) Prefix Sum Matrix, each query will be have O(1) time complexity
class NumMatrix {
public:
    NumMatrix(vector<vector<int>>& matrix) {

        for (int row = 0; row < matrix.size(); ++row) {
            std::vector<int> currentRowPrefixSum;
            int currentRowSum = 0;
            for (int col = 0; col < matrix[row].size(); ++col) {
                currentRowSum += matrix[row][col];
                int previousRow = (row > 0 ? prefixSum[row - 1][col] : 0);
                currentRowPrefixSum.push_back(currentRowSum + previousRow);
            }
            prefixSum.push_back(currentRowPrefixSum);
        }
    }

    int sumRegion(int row1, int col1, int row2, int col2) {
        int lower_right_part = prefixSum[row2][col2];
        int lower_left_part = (col1 > 0 ? prefixSum[row2][col1 - 1] : 0);
        int upper_right_part = (row1 > 0 ? prefixSum[row1 - 1][col2] : 0);
        if (row1 > 0 && col1 > 0) { // Subtract common part
            lower_left_part -= prefixSum[row1 - 1][col1 - 1];
        }
        return lower_right_part - lower_left_part - upper_right_part;
    }
private:
    std::vector<std::vector<int>> prefixSum;
};

/**
 * Your NumMatrix object will be instantiated and called as such:
 * NumMatrix* obj = new NumMatrix(matrix);
 * int param_1 = obj->sumRegion(row1,col1,row2,col2);
 */

# Python O(NM) O(NM) Prefix Sum Matrix, each query will be have O(1) time complexity
class NumMatrix:

    def __init__(self, matrix: List[List[int]]):
        self.prefix_sum: list[list[int]] = []
        for row in range(len(matrix)):
            current_row_prefix_sum: list[int] = []
            current_row_sum: int = 0
            for col in range(len(matrix[0])):
                current_row_sum += matrix[row][col]
                previous_row_prefix_sum: int = self.prefix_sum[row - 1][col] if row > 0 else 0
                current_row_prefix_sum.append(current_row_sum + previous_row_prefix_sum)
            self.prefix_sum.append(current_row_prefix_sum)

    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:
        lower_right_part: int = self.prefix_sum[row2][col2]
        lower_left_part: int = self.prefix_sum[row2][col1 - 1] if col1 > 0 else 0
        upper_right_part: int = self.prefix_sum[row1 - 1][col2] if row1 > 0 else 0
        if row1 > 0 and col1 > 0: # Subtract common part
            lower_left_part -= self.prefix_sum[row1 - 1][col1 - 1]
        return lower_right_part - lower_left_part - upper_right_part


# Your NumMatrix object will be instantiated and called as such:
# obj = NumMatrix(matrix)
# param_1 = obj.sumRegion(row1,col1,row2,col2)

# 632. Smallest Range Covering Elements from K Lists
# You have k lists of sorted integers in non-decreasing order. Find the smallest range that includes at least one number from each of the k lists.
#
# We define the range [a, b] is smaller than range [c, d] if b - a < d - c or a < c if b - a == d - c.
#
#
#
# Example 1:
#
# Input: nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]
# Output: [20,24]
# Explanation:
# List 1: [4, 10, 15, 24,26], 24 is in range [20,24].
# List 2: [0, 9, 12, 20], 20 is in range [20,24].
# List 3: [5, 18, 22, 30], 22 is in range [20,24].
# Example 2:
#
# Input: nums = [[1,2,3],[1,2,3],[1,2,3]]
# Output: [1,1]
#
#
# Constraints:
#
# nums.length == k
# 1 <= k <= 3500
# 1 <= nums[i].length <= 50
# -105 <= nums[i][j] <= 105
# nums[i] is sorted in non-decreasing order.
# Python O(NlogN) O(N) Heap
class Solution:
    def smallestRange(self, nums: List[List[int]]) -> List[int]:
        heap: list[tuple[int, int, int, int]] = []
        current_max = float('-inf')
        ans: list[int, int] = [float('-inf'), float('inf')]
        for list_idx in range(len(nums)):
            heapq.heappush(heap, (nums[list_idx][0], list_idx, 0))
            current_max = max(current_max, nums[list_idx][0])
        while heap:
            current_min, list_index, element_index = heapq.heappop(heap)
            if current_max - current_min < ans[1] - ans[0]:
                ans = [current_min, current_max]
            if element_index + 1 >= len(nums[list_index]):
                break
            heapq.heappush(heap, (nums[list_index][element_index + 1], list_index, element_index + 1))
            current_max = max(current_max, nums[list_index][element_index + 1])
        return ans

# C++ O(NlogN) O(N) Heap
class Solution {
public:
    vector<int> smallestRange(vector<vector<int>>& nums) {
        std::priority_queue<
        std::tuple<int, int, int>,
        std::vector<std::tuple<int, int, int>>,
        std::greater<std::tuple<int, int, int>>
        > heap;
        int current_max = -100000;
        for (int list_index = 0; list_index < nums.size(); ++list_index) {
            heap.push(std::make_tuple(nums[list_index][0], list_index, 0));
            current_max = std::max(current_max, nums[list_index][0]);
        }
        std::vector<int> answer = {-100000, 100000};
        while (heap.size()) {
            int current_min, list_index, element_index;
            std::tie(current_min, list_index, element_index) = heap.top();
            heap.pop();
            if (current_max - current_min < answer[1] - answer[0]) {
                answer[0] = current_min;
                answer[1] = current_max;
            }
            if (element_index + 1 >= nums[list_index].size()) {
                break;
            }
            heap.push(std::make_tuple(nums[list_index][element_index + 1], list_index, element_index + 1));
            current_max = std::max(current_max, nums[list_index][element_index + 1]);
        }
        return answer;
    }
};

# Python O(NlogN) O(N) Two Pointers
class Solution:
    def smallestRange(self, nums: List[List[int]]) -> List[int]:
        all_nums: list[tuple[int, int]] = []
        for list_index in range(len(nums)):
            for num in nums[list_index]:
                all_nums.append((num, list_index))
        all_nums.sort()
        ans: list[int, int] = [float('-inf'), float('inf')]
        left: int = 0
        hashmap: dict[int, int] = dict()
        for right in range(len(all_nums)):
            hashmap[all_nums[right][1]] = hashmap.get(all_nums[right][1], 0) + 1
            while len(hashmap) == len(nums):
                if all_nums[right][0] - all_nums[left][0] < ans[1] - ans[0]:
                    ans = [all_nums[left][0], all_nums[right][0]]
                hashmap[all_nums[left][1]] -= 1
                if hashmap[all_nums[left][1]] == 0:
                    del hashmap[all_nums[left][1]]
                left += 1
        return ans

# C++ O(NlogN) O(N) Two Pointers
class Solution {
public:
    vector<int> smallestRange(vector<vector<int>>& nums) {
        std::vector<std::tuple<int, int>> all_nums;
        for (int list_index = 0; list_index < nums.size(); ++list_index) {
            for (int num : nums[list_index]) {
                all_nums.push_back(std::make_tuple(num, list_index));
            }
        }
        std::sort(all_nums.begin(), all_nums.end());
        std::unordered_map<int, int> hashmap;
        std::vector<int> answer = {-100000, 100000};
        int left = 0;
        for (int right = 0; right < all_nums.size(); ++right) {
            ++hashmap[std::get<1>(all_nums[right])];
            while (hashmap.size() == nums.size()) {
                int current_start = std::get<0>(all_nums[left]);
                int current_end = std::get<0>(all_nums[right]);
                if (current_end - current_start < answer[1] - answer[0]) {
                    answer[0] = current_start;
                    answer[1] = current_end;
                }
                --hashmap[std::get<1>(all_nums[left])];
                if (!hashmap[std::get<1>(all_nums[left])]) {
                    hashmap.erase(std::get<1>(all_nums[left]));
                }
                ++left;
            }
        }
        return answer;
    }
};

# 3318. Find X-Sum of All K-Long Subarrays I
# You are given an array nums of n integers and two integers k and x.
#
# The x-sum of an array is calculated by the following procedure:
#
# Count the occurrences of all elements in the array.
# Keep only the occurrences of the top x most frequent elements. If two elements have the same number of occurrences, the element with the bigger value is considered more frequent.
# Calculate the sum of the resulting array.
# Note that if an array has less than x distinct elements, its x-sum is the sum of the array.
#
# Return an integer array answer of length n - k + 1 where answer[i] is the x-sum of the
# subarray
#  nums[i..i + k - 1].
#
#
#
# Example 1:
#
# Input: nums = [1,1,2,2,3,4,2,3], k = 6, x = 2
#
# Output: [6,10,12]
#
# Explanation:
#
# For subarray [1, 1, 2, 2, 3, 4], only elements 1 and 2 will be kept in the resulting array. Hence, answer[0] = 1 + 1 + 2 + 2.
# For subarray [1, 2, 2, 3, 4, 2], only elements 2 and 4 will be kept in the resulting array. Hence, answer[1] = 2 + 2 + 2 + 4. Note that 4 is kept in the array since it is bigger than 3 and 1 which occur the same number of times.
# For subarray [2, 2, 3, 4, 2, 3], only elements 2 and 3 are kept in the resulting array. Hence, answer[2] = 2 + 2 + 2 + 3 + 3.
# Example 2:
#
# Input: nums = [3,8,7,8,7,5], k = 2, x = 2
#
# Output: [11,15,15,15,12]
#
# Explanation:
#
# Since k == x, answer[i] is equal to the sum of the subarray nums[i..i + k - 1].
#
#
#
# Constraints:
#
# 1 <= n == nums.length <= 50
# 1 <= nums[i] <= 50
# 1 <= x <= k <= nums.length
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        ans: list[int] = []
        for i in range(len(nums) - k + 1):
            hashmap: dict[int, int] = dict()
            for idx in range(i, i + k):
                hashmap[nums[idx]] = hashmap.get(nums[idx], 0) + 1
            sequence: list[int] = sorted(hashmap.keys(), key=lambda x: (hashmap[x], x), reverse=True)
            ans.append(sum(y * hashmap[y] for y in sequence[:x]))
        return ans

# 3319. K-th Largest Perfect Subtree Size in Binary Tree
# You are given the root of a binary tree and an integer k.
#
# Return an integer denoting the size of the kth largest perfect binary
# subtree
# , or -1 if it doesn't exist.
#
# A perfect binary tree is a tree where all leaves are on the same level, and every parent has two children.
#
#
#
# Example 1:
#
# Input: root = [5,3,6,5,2,5,7,1,8,null,null,6,8], k = 2
#
# Output: 3
#
# Explanation:
#
#
#
# The roots of the perfect binary subtrees are highlighted in black. Their sizes, in decreasing order are [3, 3, 1, 1, 1, 1, 1, 1].
# The 2nd largest size is 3.
#
# Example 2:
#
# Input: root = [1,2,3,4,5,6,7], k = 1
#
# Output: 7
#
# Explanation:
#
#
#
# The sizes of the perfect binary subtrees in decreasing order are [7, 3, 3, 1, 1, 1, 1]. The size of the largest perfect binary subtree is 7.
#
# Example 3:
#
# Input: root = [1,2,3,null,4], k = 3
#
# Output: -1
#
# Explanation:
#
#
#
# The sizes of the perfect binary subtrees in decreasing order are [1, 1]. There are fewer than 3 perfect binary subtrees.
#
#
#
# Constraints:
#
# The number of nodes in the tree is in the range [1, 2000].
# 1 <= Node.val <= 2000
# 1 <= k <= 1024
# Solution
# Python O(N) O(N) Depth-First-Search
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def traverse(self, root: Optional[TreeNode], depth: int, trees: list[int]) -> int:
        if not root:
            return 0
        left_part = self.traverse(root.left, 1, trees)
        right_part = self.traverse(root.right, 1, trees)
        if left_part != right_part or min(left_part, right_part) == -1: return -1
        trees.append(left_part + right_part + 1)
        return right_part + left_part + 1

    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        trees = []
        self.traverse(root, 0, trees)
        trees.sort(reverse=True)
        return trees[k - 1] if k <= len(trees) else -1

# C++ O(N) O(N) Depth-First-Search
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int traverse(TreeNode* root, int depth, std::vector<int>& roots) {
        if (!root) {
            return 0;
        }
        int left_part = traverse(root->left, 1, roots);
        int right_part = traverse(root->right, 1, roots);
        if (left_part != right_part || std::min(left_part, right_part) == -1) {
            return -1;
        }
        roots.push_back(left_part + right_part + 1);
        return left_part + right_part + 1;
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        std::vector<int> roots;
        traverse(root, 0, roots);
        std::sort(roots.begin(), roots.end(), std::greater<>());
        return (k > roots.size() ? -1 : roots[k - 1]);
    }
};