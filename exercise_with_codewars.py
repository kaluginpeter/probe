# -*- coding: utf-8 -*-
# Привет это kaluginpeter, сегодня порешаем задачи с Codewars. Let's do it

# Create a function that gives a personalized greeting. This function takes two parameters: name and owner.
# Use conditionals to return the proper message:
# case	             return
# name equals owner	 'Hello boss'
# otherwise	         'Hello guest'
def greet(name, owner):
    # Add code here
    if name == owner:
        return "Hello boss"
    else:
        return "Hello guest"
# A hero is on his way to the castle to complete his mission.
# However, he's been told that the castle is surrounded with a couple of powerful dragons!
# Each dragon takes 2 bullets to be defeated, our hero has no idea how many bullets he should carry..
# Assuming he's gonna grab a specific given number of bullets and move forward to fight another specific
# given number of dragons, will he survive?
# Return True if yes, False otherwise :)
def hero(bullets, dragons):
    if bullets // dragons == 2:
        return True
    elif bullets and dragons == 0:
            return True
    else:
        return False

# Create a function that takes an integer as an argument and returns "Even" for even numbers or "Odd" for odd numbers.
def even_or_odd(number):
    if number % 2 == 0:
        return 'Even'
    else:
        return 'Odd'

# Write a program that finds the summation of every number from 1 to num.
# The number will always be a positive integer greater than 0.
# For example:
# summation(2) -> 3
# 1 + 2
# summation(8) -> 36
# 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8
def summation(num):
    count = 0
    for i in range(num+1):
        count += i
    return count

# Given a string, you have to return a string in which each character (case-sensitive) is repeated once.
# Examples (Input -> Output):
# * "String"      -> "SSttrriinngg"
# * "Hello World" -> "HHeelllloo  WWoorrlldd"
# * "1234!_ "     -> "11223344!!__  "
def double_char(s):
    double = 2
    return ''.join([char*double for char in s])

# Upd: Hello it's again kaluginpeter. Today we make some tasks on Codewars
# Given an array of integers, return a new array with each value doubled.
# For example:
# [1, 2, 3] --> [2, 4, 6]
def maps(a):
    double_a = [i*2 for i in a]
    return double_a

# Write a function that takes an array of numbers and returns the sum of the numbers.
# The numbers can be negative or non-integer. If the array does not contain any numbers then you should return 0.
# Examples
# Input: [1, 5.2, 4, 0, -1]
# Output: 9.2
# Input: []
# Output: 0
def sum_array(a):
    return sum(a)
# Хотя задачи носят решение короткого характера, думал я над ними довольно долго

# Your task is to create a function that does four basic mathematical operations.
# The function should take three arguments - operation(string/char), value1(number), value2(number).
# The function should return result of numbers after applying the chosen operation.
def basic_op(operator, value1, value2):
    if operator == '+':
        return value1 + value2
    elif operator == '-':
        return value1 - value2
    elif operator == '*':
        return value1 * value2
    elif operator == '/':
        return value1 / value2

# Write a function which converts the input string to uppercase.
def make_upper_case(s):
    return s.upper()

# Build a function that returns an array of integers from n to 1 where n>0.
# Example : n=5 --> [5,4,3,2,1]
def reverse_seq(n):
    numbers = list(range(n, 0, -1))
    return numbers

# Upd: Hello its kaluginpeter, continue make tasks on codewars
# Complete the function that accepts a string parameter, and reverses each word in the string.
# All spaces in the string should be retained.
# Examples:
# "This is an example!" ==> "sihT si na !elpmaxe"
# "double  spaces"      ==> "elbuod  secaps"
def reverse_words(text):
    return ' '.join([x[::-1] for x in text.split(' ')])

# We need a function that can transform a string into a number. What ways of achieving this do you know?
def string_to_number(s):
    return (int(s))

# In this simple assignment you are given a number and have to make it negative.
# But maybe the number is already negative?
# Examples
# make_negative(1);  # return -1
# make_negative(-5); # return -5
# make_negative(0);  # return 0
def make_negative( number ):
    return -abs(number)

# Clock shows h hours, m minutes and s seconds after midnight.
# Your task is to write a function which returns the time since midnight in milliseconds.
def past(h, m, s):
    hour = h * 60 *60 *1000
    min = m * 60 * 1000
    sec = s * 1000
    all = hour + min + sec
    return all

# Write function bmi that calculates body mass index.
# if bmi <= 18.5 return "Underweight"
# if bmi <= 25.0 return "Normal"
# if bmi <= 30.0 return "Overweight"
# if bmi > 30 return "Obese"
def bmi(weight, height):
    bmi_m = weight / height ** 2
    if bmi_m <= 18.5:
        return "Underweight"
    elif bmi_m <= 25.0:
        return "Normal"
    elif bmi_m <= 30.0:
        return "Overweight"
    elif bmi_m > 30:
        return "Obese"

# You get an array of numbers, return the sum of all of the positives ones.
def positive_sum(arr):
    # Your code here
    count = 0
    for i in arr:
        if i > 0:
            count += i
    return count

# This kata is about multiplying a given number by eight if it is an even number and by nine otherwise.
def simple_multiplication(number) :
    if number % 2 == 0:
        return number * 8
    else:
        return number * 9

# Return the number (count) of vowels in the given string.
# We will consider a, e, i, o, u as vowels for this Kata (but not y).
# The input string will only consist of lower case letters and/or spaces.
def get_count(sentence):
    gl = ['a', 'e', 'i', 'o', 'u']
    count = 0
    for x in sentence:
        if x in gl:
             count += 1
    return count

# Given an array of integers.
# Return an array, where the first element is the count of positives numbers
# and the second element is sum of negative numbers. 0 is neither positive nor negative.
# If the input is an empty array or is null, return an empty array.
def count_positives_sum_negatives(arr):
    count = 0
    count1 = 0
    if not arr:
        return arr
    else:
        for i in arr:
            if i > 0:
                count += 1
            elif i < 0:
                count1+= i
        return [count, count1]

# Write a function to convert a name into initials. This kata strictly takes two words with one space in between them.
# The output should be two capital letters with a dot separating them.
# It should look like this:
# Sam Harris => S.H
def abbrev_name(name):
    return ('.'.join([e[0] for e in name.split()]).upper())

# Нужно написать каждое слово с большой буквы, но проблема здесь в апострофах
def to_jaden_case(string):
    return " ".join(w.capitalize() for w in string.split())

# Given a random non-negative number, you have to return the digits of this number within an array in reverse order.
def digitize(n):
    sec_a = [int(a) for a in str(n)]
    return list(reversed(sec_a))

# Write a function that accepts an integer n and a string s as parameters,
# and returns a string of s repeated exactly n times.
def repeat_str(repeat, string):
    return string * repeat

# Nathan loves cycling.
# Because Nathan knows it is important to stay hydrated, he drinks 0.5 litres of water per hour of cycling.
# You get given the time in hours and you need to return the number of litres Nathan will drink,
# rounded to the smallest value.
import math
def litres(time):
    count = time / 2
    return math.floor(count)

# Given a list of integers, determine whether the sum of its elements is odd or even.
# Give your answer as a string matching "odd" or "even".
# If the input array is empty consider it as: [0] (array with a zero).
def odd_or_even(arr):
    if arr == 0:
        return 'even'
    elif sum(arr) % 2 == 0:
        return 'even'
    elif sum(arr) % 2 != 0:
        return 'odd'

# Given an array of integers your solution should find the smallest integer.
# В этой задаче у меня получилось прибегнуть к хитрости
def find_smallest_int(arr):
    return min(arr)

# There is a bus moving in the city, and it takes and drop some people in each bus stop.
# You are provided with a list (or array) of integer pairs.
# Elements of each pair represent number of people get into bus (The first item)
# and number of people get off the bus (The second item) in a bus stop.
# Your task is to return number of people who are still in the bus after the last bus station (after the last array).
# Even though it is the last bus stop,
# the bus is not empty and some people are still in the bus, and they are probably sleeping there
def number(*bus_stops):
    count = 0
    for stations in bus_stops:
        for add, leave in stations:
            count += add - leave
    return count

# In this kata you will create a function that takes a list of non-negative integers
# and strings and returns a new list with the strings filtered out.
def filter_list(l):
    new_list = [elem for elem in l if isinstance(elem, (int))]
    return new_list

# You ask a small girl,"How old are you?" She always says, "x years old",
# where x is a random number between 0 and 9.
# Write a program that returns the girl's age (0-9) as an integer.
# Assume the test input string is always a valid string.
# For example, the test input may be "1 year old" or "5 years old".
# The first character in the string is always a number.
def get_age(age):
    return int(age[0])

# Create a function that returns the sum of the two lowest positive numbers
# given an array of minimum 4 positive integers. No floats or non-positive integers will be passed.
def sum_two_smallest_numbers(numbers):
    first = min(numbers)
    second = sorted(numbers)[1]
    all = first + second
    return all

# You are given an odd-length array of integers, in which all of them are the same, except for one single number.
# Complete the method which accepts such an array, and returns that single different number.
def stray(arr):
    for i in arr:
        if arr.count(i)==1:
            elem = i
    return elem

# Your task is to find the first element of an array that is not consecutive.
# By not consecutive we mean not exactly 1 larger than the previous element of the array.
def first_non_consecutive(arr):
    for i, j in enumerate(arr, arr[0]):
        if i!=j:
            return j

# Complete the method that takes a boolean value and return a "Yes" string for true, or a "No" string for false.
def bool_to_word(boolean):
    if boolean:
        return 'Yes'
    else:
        return 'No'

# Complete the solution so that the function will break up camel casing, using a space between words.
def solution(s):
    return ''.join(' ' + char if char.isupper() else char.strip() for char in s).strip()

# We need a function that can transform a number (integer) into a string.
def number_to_string(num):
    return str(num)

# Check to see if a string has the same amount of 'x's and 'o's.
# The method must return a boolean and be case insensitive. The string can contain any char.
def xo(s):
    s = s.lower()
    word1 = s.count('x')
    word2 = s.count('o')
    if word1 == word2:
        return True
    else:
        return False

# Write a function that will return the count of distinct case-insensitive alphabetic characters
# and numeric digits that occur more than once in the input string.
# The input string can be assumed to contain only alphabets (both uppercase and lowercase) and numeric digits.
def duplicate_count(text):
    text = text.lower()
    count = 0
    for x in set(text):
        if text.count(x) > 1:
            count += 1
    return count

# Write a function that returns both the minimum and maximum number of the given list/array.
def min_max(lst):
    return [min(lst), max(lst)]

# Write a function findNeedle() that takes an array full of junk but containing one "needle"
# After your function finds the needle it should return a message (as a string) that says:
# "found the needle at position " plus the index it found the needle
def find_needle(haystack):
    if 'needle' in haystack: return(f"found the needle at position {haystack.index('needle')}")

# After a hard quarter in the office you decide to get some rest on a vacation.
# So you will book a flight for you and your girlfriend and try to leave all the mess behind you.
# You will need a rental car in order for you to get around in your vacation.
# The manager of the car rental makes you some good offers.
# Every day you rent the car costs $40. If you rent the car for 7 or more days, you get $50 off your total.
# Alternatively, if you rent the car for 3 or more days, you get $20 off your total.
# Write a code that gives out the total amount for different days(d).
def rental_car_cost(d):
    cost = 40
    if d <4:
        return d * cost
    elif 4 <= d < 7:
        return d * cost - 20
    elif d >= 7:
        return d * cost - 50

# The cockroach is one of the fastest insects.
# Write a function which takes its speed in km per hour and returns it in cm per second, rounded down to the integer.
import math
def cockroach_speed(s):
    distance = (s * 1000 * 100) / 60 / 60
    return math.floor(distance)

# ATM machines allow 4 or 6 digit PIN codes
# and PIN codes cannot contain anything but exactly 4 digits or exactly 6 digits.
# If the function is passed a valid PIN string, return true, else return false.
def validate_pin(pin):
    if (len(pin) == 4 or len(pin) == 6) and pin.isdigit():
        return True
    else:
        return False

# Take an array and remove every second element from the array.
# Always keep the first element and start removing with the next element.
def remove_every_other(my_list):
    del my_list[1::2]
    return my_list

# Write a program where Alex can input (n) how many times the hoop goes round
# and it will return him an encouraging message :)
# If Alex gets 10 or more hoops, return the string "Great, now move on to tricks".
# If he doesn't get 10 hoops, return the string "Keep at it until you get it".
def hoop_count(n):
    if n < 10:
        return "Keep at it until you get it"
    else:
        return "Great, now move on to tricks"

# There was a test in your class and you passed it. Congratulations!
# But you're an ambitious person. You want to know if you're better than the average student in your class.
# You receive an array with your peers' test scores. Now calculate the average and compare your score!
# Return True if you're better, else False!
from statistics import mean
def better_than_average(class_points, your_points):
    class_points.insert(0, your_points)
    avr = mean(class_points)
    if your_points > avr:
        return True
    else:
        return False

# You're writing code to control your town's traffic lights.
# You need a function to handle each change from green, to yellow, to red, and then to green again.
# Complete the function that takes a string as an argument representing the current
# state of the light and returns a string representing the state the light should change to.
def update_light(current):
    if current == 'green':
        return 'yellow'
    elif current == 'yellow':
        return 'red'
    elif current == 'red':
        return 'green'

# Write a function named setAlarm which receives two parameters. The first parameter, employed,
# is true whenever you are employed and the second parameter, vacation is true whenever you are on vacation.
# The function should return true if you are employed and not on vacation
# (because these are the circumstances under which you need to set an alarm). It should return false otherwise.
def set_alarm(employed, vacation):
    if (bool(employed) == True) and (bool(vacation) == False):
        return True
    else:
        return False

# Given a month as an integer from 1 to 12, return to which quarter of the year it belongs as an integer number.
def quarter_of(month):
    first = [1, 2, 3]
    second = [4, 5, 6]
    third = [7, 8, 9]
    fourth = [10, 11, 12]
    if month in first:
        return 1
    elif month in second:
        return 2
    elif month in third:
        return 3
    elif month in fourth:
        return 4

# It's pretty straightforward.
#  Your goal is to create a function that removes the first and last characters of a string.
#  You're given one parameter, the original string.
#  You don't have to worry with strings with less than two characters.
def remove_char(s):
    return s[1:-1]

# Write function RemoveExclamationMarks which removes all exclamation marks from a given string.
def remove_exclamation_marks(s):
    return ''.join(word for word in s if word not in '!')

# Very simple, given an integer or a floating-point number, find its opposite.
def opposite(number):
    return number * -1

# You will be given an array a and a value x.
# All you need to do is check whether the provided array contains the value
# Array can contain numbers or strings. X can be either.
# Return true if the array contains the value, false if not.
def check(seq, elem):
    return elem in seq

# Create a function which answers the question "Are you playing banjo?".
# If your name starts with the letter "R" or lower case "r", you are playing banjo!
def are_you_playing_banjo(name):
    n_lst = ['r', 'R']
    if name[0] in n_lst:
        return name + ' plays banjo'
    else:
        return name + ' does not play banjo'

# Count the number of divisors of a positive integer n.
def divisors(n):
    count = 0
    for i in range(1, n+1):
        if n % i == 0:
            count+=1
    return count

# Create a function that accepts 2 string arguments
# and returns an integer of the count of occurrences the 2nd argument is found in the first one.
def str_count(strng, letter):
    return strng.count(letter)

# A pangram is a sentence that contains every single letter of the alphabet at least once.
# For example, the sentence "The quick brown fox jumps over the lazy dog" is a pangram,
# because it uses the letters A-Z at least once (case is irrelevant).
# Given a string, detect whether or not it is a pangram.
# Return True if it is, False if not. Ignore numbers and punctuation.
def is_pangram(s):
    s = s.lower()
    count = 0
    list = 'abcdefghijklmnopqrstuvwxyz'
    pangram = set(s) & set(list)
    return len(pangram) == len(list)

# Complete the function so that it finds the average of the three scores passed to it
# and returns the letter value associated with that grade.
def get_grade(s1, s2, s3):
    avr = (s1 + s2 +s3) / 3
    if 90 <= avr <= 100:
        return 'A'
    elif 80 <= avr < 90:
        return 'B'
    elif 70 <= avr < 80:
        return 'C'
    elif 60 <= avr < 70:
        return 'D'
    else:
        return 'F'

# You are going to be given a word.
# Your job is to return the middle character of the word.
# If the word's length is odd, return the middle character.
# If the word's length is even, return the middle 2 characters.
def get_middle(s):
    if len(s) % 2:
        index = int(len(s) / 2)
        return s[index]
    elif len(s) % 2 == 0:
        x = len(s) // 2
        y = len(s) // 2 - 1
        return (f'{s[y]}{s[x]}')

# Your classmates asked you to copy some paperwork for them.
# You know that there are 'n' classmates and the paperwork has 'm' pages.
# Your task is to calculate how many blank pages do you need. If n < 0 or m < 0 return 0.
def paperwork(n, m):
    if n <= 0 or m <= 0:
        return 0
    else:
        return n * m

# Think of a way to store the languages as a database (eg an object).
# The languages are listed below so you can copy and paste!
# Write a 'welcome' function that takes a parameter 'language' (always a string),
# and returns a greeting - if you have it in your database.
# It should default to English if the language is not in the database, or in the event of an invalid input.
def greet(language):
    base = {'english': 'Welcome',
    'czech': 'Vitejte',
    'danish': 'Velkomst',
    'dutch': 'Welkom',
    'estonian': 'Tere tulemast',
    'finnish': 'Tervetuloa',
    'flemish': 'Welgekomen',
    'french': 'Bienvenue',
    'german': 'Willkommen',
    'irish': 'Failte',
    'italian': 'Benvenuto',
    'latvian': 'Gaidits',
    'lithuanian': 'Laukiamas',
    'polish': 'Witamy',
    'spanish': 'Bienvenido',
    'swedish': 'Valkommen',
    'welsh': 'Croeso'}
    if language in base:
        return base[language]
    else:
        return 'Welcome'

# When provided with a number between 0-9, return it in words.
def switch_it_up(number):
    numbers = {
        0: 'Zero',
        1: 'One',
        2: 'Two',
        3: 'Three',
        4: 'Four',
        5: 'Five',
        6: 'Six',
        7: 'Seven',
        8: 'Eight',
        9: 'Nine',
    }
    return numbers[number]

# Simple, remove the spaces from the string, then return the resultant string.
def no_space(x):
    return x.replace(' ' ,'')

# There is an array with some numbers. All numbers are equal except for one. Try to find it!
def find_uniq(arr):
    found = set()
    found_again = set()

    for a in arr:
        if a in found_again:
            continue
        if a in found:
            found.remove(a)
            found_again.add(a)
        else:
            found.add(a)
    res = list(found)
    return (res[0])

# In this simple exercise, you will create a program that will take two lists of integers, a and b.
# Each list will consist of 3 positive integers above 0, representing the dimensions of cuboids a and b.
# You must find the difference of the cuboids' volumes regardless of which is bigger.
def find_difference(a, b):
    q_a = (a[0] * a[1]) * a[2]
    q_b = (b[0] * b[1]) * b[2]
    return abs(q_a - q_b)

# Given a year, return the century it is in.
import math
def century(year):
    return (math.ceil(year / 100))

# Complete the square sum function so that it squares each number passed into it and then sums the results together.
def square_sum(numbers):
    return sum([integer*integer for integer in numbers])

# Make a program that filters a list of strings and returns a list with only your friends name in it.
# If a name has exactly 4 letters in it, you can be sure that it has to be a friend of yours!
# Otherwise, you can be sure he's not...
def friend(x):
    true_friends = []
    for name in x:
        if len(name) == 4 and name.isalpha():
            true_friends.append(name)
        else:
            pass
    return true_friends

# Create a method to see whether the string is ALL CAPS. UPD: isupper() not worked with special simbols
def is_uppercase(inp):
    special = ['$%&', '+%@']
    if inp.isupper():
        return True
    elif inp in special:
        return True
    else:
        return False

# Write a function which calculates the average of the numbers in a given list.
def find_average(numbers):
    return sum(numbers) / len(numbers)

# You have to write a function that accepts three parameters:
# If there is enough space, return 0, and if there isn't, return the number of passengers he can't take.
def enough(cap, on, wait):
    if on + wait < cap:
        return 0
    else:
        return abs(cap - (on + wait))

# I got them at the same time as kitten/puppy. That was humanYears years ago.
# Return their respective ages now as [humanYears,catYears,dogYears]
def human_years_cat_years_dog_years(human_years):
    cat_years = 0
    dog_years = 0
    if human_years == 1:
        return [human_years, cat_years + 15, dog_years + 15]
    elif human_years == 2:
        return [human_years, cat_years + 15 + 9, dog_years + 15 + 9]
    elif human_years > 2:
        cat_years = 24
        dog_years = 24
        for i in range(human_years-2):
            cat_years+=4
            dog_years+=5
        return [human_years, cat_years, dog_years]

# Implement the function unique_in_order which takes as argument a sequence
# and returns a list of items without any elements with the same value next to each other
# and preserving the original order of elements.
def unique_in_order(iterable):
    new = []
    if not iterable:
        return []
    for i in range(len(iterable)-1):
        if iterable[i] != iterable[i + 1]:
            new.append(iterable[i])
    new.append(iterable[-1])
    return new

# Complete the findNextSquare method that finds the next integral perfect square after the one passed as a parameter.
# Recall that an integral perfect square is an integer n such that sqrt(n) is also an integer.
# If the parameter is itself not a perfect square then -1 should be returned.
# You may assume the parameter is non-negative.
def find_next_square(sq):
    perfect_sq = sq ** .5
    if perfect_sq.is_integer():
        return (perfect_sq + 1) ** 2
    else:
        return -1

# Complete the function that takes a non-negative integer n as input,
# and returns a list of all the powers of 2 with the exponent ranging from 0 to n ( inclusive ).
def powers_of_two(n):
    list = []
    for i in range(n+1):
        list.append(2**i)
    return list

# All of the animals are having a feast! Each animal is bringing one dish.
# There is just one rule: the dish must start and end with the same letters as the animal's name.
# For example, the great blue heron is bringing garlic naan and the chickadee is bringing chocolate cake.
# Write a function feast that takes the animal's name and dish as arguments
# and returns true or false to indicate whether the beast is allowed to bring the dish to the feast.
# Assume that beast and dish are always lowercase strings, and that each has at least two letters.
# beast and dish may contain hyphens and spaces, but these will not appear at the beginning or end of the string.
# They will not contain numerals.
def feast(beast, dish):
    return beast[0] == dish[0] and beast[-1] == dish[-1]

# Your goal in this kata is to implement a difference function,
# which subtracts one list from another and returns the result.
# It should remove all values from list a, which are present in list b keeping their order.
def array_diff(a, b):
    list =[]
    for i in a:
        if i not in b:
            list.append(i)
    return list

# Complete the function that takes two integers (a, b, where a < b)
# and return an array of all integers between the input parameters, including them.
def between(a,b):
    list = []
    for i in range(a, b+1):
        list.append(i)
    return list

# Define String.prototype.toAlternatingCase
# (or a similar function/method such as to_alternating_case/toAlternatingCase/ToAlternatingCase
# in your selected language; see the initial solution for details)
# such that each lowercase letter becomes uppercase and each uppercase letter becomes lowercase.
def to_alternating_case(string):
    return ''.join([char.lower() if char.isupper() else char.upper() for char in string])

# Write a function that takes an array of strings as an argument
# and returns a sorted array containing the same strings, ordered from shortest to longest.
def sort_by_length(arr):
    arr.sort(key=len)
    return sorted(arr, key=len)

# Given an array of integers, remove the smallest value.
# Do not mutate the original array/list. If there are multiple elements with the same value,
# remove the one with a lower index. If you get an empty array/list, return an empty array/list.
def remove_smallest(numbers):
    if numbers:
        new_list = numbers.copy()
        new_list.remove(min(new_list))
        return new_list
    else:
        return numbers

# Create a function that takes 2 integers in form of a string as an input, and outputs the sum (also as a string):
def sum_str(a, b):
    if a and b:
        c = int(a) + int(b)
        return str(c)
    elif a == '' and b == '':
        return '0'
    else:
        if a:
            return a
        else:
            return b

# Сalculate how many years ago the father was twice as old as his son
# (or in how many years he will be twice as old). The answer is always greater or equal to 0,
# no matter if it was in the past or it is in the future.
def twice_as_old(dad_years_old, son_years_old):
    ages = son_years_old * 2
    return abs(ages - dad_years_old)

# Build a pyramid-shaped tower, as an array/list of strings,
# given a positive integer number of floors. A tower block is represented with "*" character.
def tower_builder(n_floors):
    list = []
    for i in range(n_floors):
        first_elem=''
        second_elem=''
        for j in range(i,n_floors-1):
            first_elem+=' '
        for k in range(2*i+1):
            second_elem+='*'
        list.append(first_elem + second_elem + first_elem)
    return list

# You are given two interior angles (in degrees) of a triangle.
# Write a function to return the 3rd.
# Note: only positive integers will be tested.
def other_angle(a,b):
    return 180 - a - b

# The maximum sum subarray problem consists in finding the maximum sum of a contiguous subsequence in an array
# or list of integers
def max_sequence(arr):
    local_max_sum = 0
    global_max = 0
    for elem in arr:
        local_max_sum = max(local_max_sum + elem, elem)
        global_max = max(local_max_sum, global_max)
    return global_max

# This time no story, no theory. The examples below show you how to write function accum:
# Examples:
# accum("abcd") -> "A-Bb-Ccc-Dddd"
def accum(s):
    word = ''
    count = -1
    for i in s:
        count+=1
        char = i.lower() * count
        word = word + (i.upper() + char + '-')
    return word[:-1]

# You are given an array with positive numbers and a non-negative number N.
# You should find the N-th power of the element in the array with the index N.
# If N is outside of the array, then return -1.
def index(array, n):
    if n <= len(array) - 1:
        return array[n]**n
    else:
        return -1

# Welcome. In this kata, you are asked to square every digit of a number and concatenate them.
def square_digits(num):
    elem = ''
    for i in str(num):
        square = int(i) ** 2
        elem += str(square)
    return int(elem)

# The goal of this exercise is to convert a string to a new string where each character
# in the new string is "(" if that character appears only once in the original string, or ")"
# if that character appears more than once in the original string.
# Ignore capitalization when determining if a character is a duplicate.
def duplicate_encode(word):
    new_word = ''
    word = word[0].lower() + word[1:].lower()
    for char in word:
        if word.count(char) > 1:
            new_word += ')'
        else:
            new_word += '('
    return new_word

# You are given the length and width of a 4-sided polygon. The polygon can either be a rectangle or a square.
# If it is a square, return its area. If it is a rectangle, return its perimeter.
def area_or_perimeter(l , w):
    return ((l + w) * 2 if l != w else l * w)

# Your job is to write a function which increments a string, to create a new string.
# If the string already ends with a number, the number should be incremented by 1.
# If the string does not end with a number. the number 1 should be appended to the new string.
def increment_string(strng):
    stripped = strng.rstrip('1234567890')
    ints = strng[len(stripped):]
    if len(ints) == 0:
        return strng + '1'
    else:
        length_word = len(ints)
        new_ints = int(ints) + 1
        new_ints = str(new_ints).zfill(length_word)
        return stripped + new_ints

# Your task is to make two functions ( max and min, or maximum and minimum, etc., depending on the language )
# that receive a list of integers as input, and return the largest and lowest number in that list, respectively.
def minimum(arr):
    return min(arr)

def maximum(arr):
    return max(arr)

# Your task is correct the errors in the digitised text. You only have to handle the following mistakes:
def correct(s):
    s = s.replace('5', 'S')
    s = s.replace('0', 'O')
    s = s.replace('1', 'I')
    return s

# Write a function that when given a URL as a string, parses out just the domain name and returns it as a string.
def domain_name(url):
    return url.split("www.")[-1].split("//")[-1].split(".")[0]

# This time we want to write calculations using functions and get the results. Let's have a look at some examples:
# seven(times(five())) # must return 35
def zero(integer = None):
    return 0 if integer is None else int(integer(0))
def one(integer = None):
    return 1 if integer is None else int(integer(1))
def two(integer = None):
    return 2 if integer is None else int(integer(2))
def three(integer = None):
    return 3 if integer is None else int(integer(3))
def four(integer = None):
    return 4 if integer is None else int(integer(4))
def five(integer = None):
    return 5 if integer is None else int(integer(5))
def six(integer = None):
    return 6 if integer is None else int(integer(6))
def seven(integer = None):
    return 7 if integer is None else int(integer(7))
def eight(integer = None):
    return 8 if integer is None else int(integer(8))
def nine(integer = None):
    return 9 if integer is None else int(integer(9))

def plus(second_integer):
    return lambda integer: integer + second_integer
def minus(second_integer):
    return lambda integer: integer - second_integer
def times(second_integer):
    return lambda integer: integer * second_integer
def divided_by(second_integer):
    return lambda integer: integer / second_integer

# An isogram is a word that has no repeating letters, consecutive or non-consecutive.
# Implement a function that determines whether a string that contains only letters is an isogram.
# Assume the empty string is an isogram. Ignore letter case.
def is_isogram(string):
    some_string = ''
    for word in string.lower():
        if word not in some_string:
            some_string += word
    print(some_string)
    if len(some_string) == len(string):
        return True
    else:
        return False

# You will be given a number and you will need to return it as a string in Expanded Form. For example:
# expanded_form(12) # Should return '10 + 2'
def expanded_form(num):
    list_of_numbers = []
    lenght = len(str(num)) - 1
    for char in str(num):
        if char != "0":
            list_of_numbers.append(char + "0" * lenght)
        lenght -= 1
    return " + ".join(list_of_numbers)

# Your task is to write a function that takes a string and return a new string with all vowels removed.
def disemvowel(string_):
    list = ['a','e','i','o','u', 'A','E','I','O','U']
    for char in string_:
        if char in list:
            string_ = string_.replace(char, '')
    return string_

# In DNA strings, symbols "A" and "T" are complements of each other,
# as "C" and "G". Your function receives one side of the DNA (string, except for Haskell);
# you need to return the other complementary side.
# DNA strand is never empty or there is no DNA at all (again, except for Haskell).
def DNA_strand(dna):
    dnk =''
    for char in dna:
        if char == 'A':
            dnk += 'T'
        elif char == 'T':
            dnk += 'A'
        elif char == 'G':
            dnk += 'C'
        elif char == 'C':
            dnk += 'G'
    return dnk

# Write a function that takes a list of strings as an argument
# and returns a filtered list containing the same elements but with the 'geese' removed.
geese = ["African", "Roman Tufted", "Toulouse", "Pilgrim", "Steinbacher"]
def goose_filter(birds):
    return [elem for elem in birds if elem not in geese]

# Complete the function/method so that it returns the url with anything after the anchor (#) removed.
def remove_url_anchor(url):
    if url.count('#'):
        index = url.index('#')
        return url[:index]
    return url

# You will be given a list of strings. You must sort it alphabetically (case-sensitive,
# and based on the ASCII values of the chars) and then return the first value.
# The returned value must be a string, and have "***" between each of its letters.
def two_sort(array):
    array.sort()
    return '***'.join(array[0])

# Bob needs a fast way to calculate the volume of a cuboid with three values:
# the length, width and height of the cuboid. Write a function to help Bob with this calculation.
def get_volume_of_cuboid(length, width, height):
    return length * width * height

# Create a function finalGrade, which calculates the final grade of a student depending on two parameters:
# a grade for the exam and a number of completed projects.
# This function should take two arguments:
# exam - grade for exam (from 0 to 100); projects - number of completed projects (from 0 and above);
def final_grade(exam, projects):
    if exam > 90 or projects > 10:
        return 100
    elif exam > 75 and projects >= 5:
        return 90
    elif exam > 50 and projects >= 2:
        return 75
    else:
        return 0

# Your task is to make a function that can take any non-negative integer as an argument
# and return it with its digits in descending order.
# Essentially, rearrange the digits to create the highest possible number.
def descending_order(num):
    order = []
    if num >= 0:
        for i in str(num):
            order.append(int(i))
    order.sort(reverse=True)
    return int(''.join(map(str, order)))

# Given an array (arr) as an argument
# complete the function countSmileys that should return the total number of smiling faces.
# Rules for a smiling face:
# Each smiley face must contain a valid pair of eyes. Eyes can be marked as : or ;
# A smiley face can have a nose but it does not have to. Valid characters for a nose are - or ~
# Every smiling face must have a smiling mouth that should be marked with either ) or D
# No additional characters are allowed except for those mentioned.
def count_smileys(arr):
    count = 0
    list = [':)', ':D', ';)', ';D', ':-)', ':~)', ';-)', ';~)', ':-D', ':~D', ';-D', ';~D']
    for elem in range(len(arr)):
        if arr[elem] in list:
            count += 1
    return count

# Given two numbers and an arithmetic operator (the name of it, as a string),
# return the result of the two numbers having that operator used on them.
# a and b will both be positive integers, and a will always be the first number in the operation,
# and b always the second.
# The four operators are "add", "subtract", "divide", "multiply".
def arithmetic(a, b, operator):
    if operator == 'add': return a + b
    elif operator == 'subtract': return a - b
    elif operator == 'multiply': return a * b
    elif operator == 'divide': return a / b

# You were camping with your friends far away from home,
# but when it's time to go back, you realize that your fuel is running out
# and the nearest pump is 50 miles away! You know that on average,
# your car runs on about 25 miles per gallon. There are 2 gallons left.
# Considering these factors, write a function that tells you if it is possible to get to the pump or not.
# Function should return true if it is possible and false if not.
def zero_fuel(distance_to_pump, mpg, fuel_left):
    return mpg * fuel_left >= distance_to_pump

# Write a function that takes an array of numbers (integers for the tests) and a target number.
# It should find two different items in the array that, when added together, give the target value.
# The indices of these items should then be returned in a tuple / list (depending on your language)
# like so: (index1, index2).
def two_sum(numbers, target):
    for i in range(len(numbers)):
        for j in range(i+1, len(numbers)):
            if numbers[i] + numbers[j] == target:
                return [i, j]

# In this little assignment you are given a string of space separated numbers,
# and have to return the highest and lowest number.
import re
def high_and_low(numbers):
    list = [int(s) for s in re.findall("[-+]?[.]?[\d]+(?:,\d\d\d)*[\.]?\d*(?:[eE][-+]?\d+)?", numbers)]
    list.sort()
    integer = ''
    return integer + str(list[-1]) + ' ' + str(list[0])

# Given a non-empty array of integers, return the result of multiplying the values together in order.
def grow(arr):
    integer = 1
    for elem in arr:
        integer *= elem
    return integer

# Complete the solution so that it reverses the string passed into it.
def solution(string):
    return string[::-1]

# Finish the solution so that it sorts the passed in array of numbers.
# If the function passes in an empty array or null/nil value then it should return an empty array.
def solution(nums):
    if not nums:
        return []
    nums.sort()
    return nums

# Given a set of numbers, return the additive inverse of each.
# Each positive becomes negatives, and the negatives become positives.
def invert(lst):
    return [i * -1 for i in lst]

# Use variables to find the sum of the goals Messi scored in 3 competitions
la_liga_goals = 43
champions_league_goals = 10
copa_del_rey_goals = 5

total_goals = la_liga_goals + champions_league_goals + copa_del_rey_goals

# The starship Enterprise has run into some problem when creating a program to greet everyone as they come aboard.
# It is your job to fix the code and get the program working again!
def say_hello(name):
    return 'Hello, ' + name

# Your task is to make function, which returns the sum of a sequence of integers.
# The sequence is defined by 3 non-negative values: begin, end, step (inclusive).
# If begin value is greater than the end, function should returns 0
def sequence_sum(begin_number, end_number, step):
    sum = 0
    for i in range(begin_number, end_number + 1, step):
        sum += i
    return sum

# Write a function that takes an array of words and smashes them together into a sentence
# and returns the sentence. You can ignore any need to sanitize words or add punctuation,
# but you should add spaces between each word.
# Be careful, there shouldn't be a space at the beginning or the end of the sentence!
def smash(words):
    return " ".join(words)

# However, sometimes, you can't arrange them into a square.
# Instead, you end up with an ordinary rectangle! Those blasted things!
# If you just had a way to know, whether you're currently working in vain…
# Wait! That's it! You just have to check if your number of building blocks is a perfect square.
import math

def is_square(n):
    if n < 0:
        return False
    return n == math.isqrt(n) ** 2

# Write a function that always returns 5
# Sounds easy right? Just bear in mind that you can't use any of the following characters: 0123456789*+-/
def unusual_five():
    return len('     ')

# This function should test if the factor is a factor of base.
# Return true if it is a factor or false if it is not.
def check_for_factor(base, factor):
    return base % factor == 0

# Given two integers a and b,
# which can be positive or negative, find the sum of all the integers between
# and including them and return it. If the two numbers are equal return a or b.
def get_sum(a,b):
    if a == b:
        return a
    list = []
    step = 1 if a < b else -1
    for i in range(a, b + step, step):
        list.append(i)
    return sum(list)

# In a factory a printer prints labels for boxes.
# For one kind of boxes the printer has to use colors which, for the sake of simplicity,
# are named with letters from a to m.
# The colors used by the printer are recorded in a control string.
# For example a "good" control string would be aaabbbbhaijjjm meaning that the printer used three times color a,
# four times color b, one time color h then one time color a...
# Sometimes there are problems: lack of colors,
# technical malfunction and a "bad" control string is produced
# e.g. aaaxbbbbyyhwawiwjjjwwm with letters not from a to m.
def printer_error(s):
    return f"{len([n for n in s if n in 'nopqrstuvwxyz'])}/{len(s)}"

# Take 2 strings s1 and s2 including only letters from a to z.
# Return a new sorted string, the longest possible,
# containing distinct letters - each taken only once - coming from s1 or s2.
def longest(a1, a2):
    return "".join(sorted(set(a1 + a2)))

# Americans are odd people: in their buildings, the first floor is actually the ground floor
# and there is no 13th floor (due to superstition).
# Write a function that given a floor in the american system returns the floor in the european system.
# With the 1st floor being replaced by the ground floor and the 13th floor being removed,
# the numbers move down to take their place. In case of above 13,
# they move down by two because there are two omitted numbers below them.
def get_real_floor(n):
    if n <= 0: return n
    if n < 13: return n-1
    if n > 13: return n-2

# In this simple exercise, you will build a program that takes a value, integer ,
# and returns a list of its multiples up to another value, limit .
# If limit is a multiple of integer, it should be included as well.
# There will only ever be positive integers passed into the function, not consisting of 0.
# The limit will always be higher than the base.
# For example, if the parameters passed are (2, 6),
# the function should return [2, 4, 6] as 2, 4, and 6 are the multiples of 2 up to 6.
# If you can, try writing it in only one line of code.
def find_multiples(integer, limit):
    return [i for i in range(integer, limit + 1, integer)]

# The main idea is to count all the occurring characters in a string.
# If you have a string like aba, then the result should be {'a': 2, 'b': 1}.
# What if the string is empty? Then the result should be empty object literal, {}.
def count(string):
    dict = {}
    count = 0
    for char in string:
        count = string.count(char)
        dict[f"{char}"] = count
    return dict

# In mathematics, the factorial of a non-negative integer n, denoted by n!,
# is the product of all positive integers less than or equal to n.
# For example: 5! = 5 * 4 * 3 * 2 * 1 = 120. By convention the value of 0! is 1.
# Write a function to calculate factorial for a given input.
# If input is below 0 or above 12 throw an exception of type ArgumentOutOfRangeException (C#)
# or IllegalArgumentException (Java) or RangeException (PHP) or throw a RangeError (JavaScript)
# or ValueError (Python) or return -1 (C).
import math
def factorial(n):
    if n > 12:
        raise ValueError
    return math.factorial(n)

# Messi is a soccer player with goals in three leagues:
# LaLiga
# Copa del Rey
# Champions
# Complete the function to return his total number of goals in all three leagues.
# Note: the input will always be valid.
def goals(laLiga, copaDelRey, championsLeague):
    return laLiga + copaDelRey + championsLeague

# Return the name of the winner. If there is no winner, return null (in Java and JavaScript),
# None (in Python), nil (in Ruby), or * in C.
# Task Description
# There are no given candidates. An elector can vote for anyone.
# Each ballot contains only one name and represents one vote for this name.
# A name is an arbitrary string, e.g. "A", "B", or "XJDHD".
# There are no spoiled ballots.
# The ballot-box is represented by an unsorted list of names.
# Each entry in the list corresponds to one vote for this name.
# You do not know the names in advance (because there are no candidates).
# A name wins the election if it gets more than n/2 votes
# (n = number of all votes, i.e. n is equal to the size of the given list).
def get_winner(ballots):
    list = []
    for elem in ballots:
        list.append(elem)
    elite = set(list)
    for char in elite:
        if list.count(char) > len(ballots) / 2 or list.count(char) == len(ballots):
            return char

# Sum all the numbers of a given array ( cq. list ),
# except the highest and the lowest element ( by value, not by index! ).
# The highest or lowest element respectively is a single element at each edge,
# even if there are more than one with the same value.
# Mind the input validation.
def sum_array(arr):
    if arr == [] or arr is None or len(arr) == 1:
        return 0
    integer = sum(arr)
    return integer - max(arr) - min(arr)

# You will be given an array and a limit value.
# You must check that all values in the array are below or equal to the limit value.
# If they are, return true. Else, return false.
# You can assume all values in the array are numbers.
def small_enough(array, limit):
    for elem in array:
        if elem > limit:
            return False
    return True

# Create a function with two arguments that will return an array of the first n multiples of x.
# Assume both the given number and the number of times to count will be positive numbers greater than 0.
# Return the results as an array or list ( depending on language ).
def count_by(x, n):
    list = []
    for i in range(x, x * n + 1, x):
        list.append(i)
    return list

# I created this function to add five to any number that was passed in to it
# and return the new value. It doesn't throw any errors but it returns the wrong number.
def add_five(num):
    return num + 5

# Your task is to sort a given string.
# Each word in the string will contain a single number.
# This number is the position the word should have in the result.
# Note: Numbers can be from 1 to 9. So 1 will be the first word (not 0).
# If the input string is empty, return an empty string.
# The words in the input String will only contain valid consecutive numbers.
def order(sentence):
    list = sentence.split()
    new_list = []
    for i in range(1, len(list) + 1):
        for elem in list:
            for char in elem:
                if char == str(i):
                    new_list.append(elem)
    return ' '.join(new_list)

# There is a queue for the self-checkout tills at the supermarket.
# Your task is write a function to calculate the total time required for all the customers to check out!
def queue_time(customers, n):
    time=[0]*n
    for custom in customers: time[time.index(min(time))]+=custom
    return max(time)

# You are given two arrays a1 and a2 of strings.
# Each string is composed with letters from a to z.
# Let x be any string in the first array and y be any string in the second array.
# Find max(abs(length(x) − length(y)))
# If a1 and/or a2 are empty return -1 in each language
# except in Haskell (F#) where you will return Nothing (None).
def mxdiflg(a1, a2):
    if a1 and a2: return max(abs(len(x) - len(y)) for x in a1 for y in a2)
    return -1

# Wolves have been reintroduced to Great Britain. You are a sheep farmer,
# and are now plagued by wolves which pretend to be sheep. Fortunately, you are good at spotting them.
# Warn the sheep in front of the wolf that it is about to be eaten.
# Remember that you are standing at the front of the queue which is at the end of the array:
def warn_the_sheep(queue):
    if queue.index('wolf') == len(queue)-1:
        return 'Pls go away and stop eating my sheep'
    else:
        ind = len(queue) - queue.index('wolf') - 1
        return (f"Oi! Sheep number {ind}! You are about to be eaten by a wolf!")

# An anagram is the result of rearranging the letters of a word to produce a new word (see wikipedia).
# Note: anagrams are case insensitive
# Complete the function to return true if the two arguments given are anagrams of each other;
# return false otherwise.
def is_anagram(test, original):
    return set(test.lower()) == set(original.lower()) and len(test) == len(original)

# Rock Paper Scissors
# Let's play! You have to return which player won! In case of a draw return Draw!.
def rps(p1, p2):
    if p1 == p2: return 'Draw!'
    elif p1 == 'rock' and p2 == 'scissors':
        return 'Player 1 won!'
    elif p1 == 'scissors' and p2 == 'rock':
        return 'Player 2 won!'
    elif p1 == 'paper' and p2 == 'rock':
        return 'Player 1 won!'
    elif p1 == 'rock' and p2 == 'paper':
        return 'Player 2 won!'
    elif p1 == 'paper' and p2 == 'scissors':
        return 'Player 2 won!'
    elif p1 == 'scissors' and p2 == 'paper':
        return 'Player 1 won!'

# Define a method hello that returns "Hello, Name!" to a given name, or says Hello, World!
# if name is not given (or passed as an empty String).
# Assuming that name is a String and it checks for user typos to return a name with a first capital letter (Xxxx).
def hello(name=None):
    return ('Hello, World!' if not name else f"Hello, {name.title()}!")

# Timmy & Sarah think they are in love, but around where they live,
# they will only know once they pick a flower each.
# If one of the flowers has an even number of petals
# and the other has an odd number of petals it means they are in love.
# Write a function that will take the number of petals of each flower
# and return true if they are in love and false if they aren't.
def lovefunc( flower1, flower2 ):
    return (flower1 % 2 != 0 and flower2 % 2 == 0) or (flower2 % 2 != 0 and flower1 % 2 == 0)

# A perfect number is a number in which the sum of its divisors (excluding itself) are equal to itself.
# Write a function that can verify if the given integer n is a perfect number,
# and return True if it is, or return False if not.
def isPerfect(n):
    return n in [6, 28, 496, 8128, 33550336, 8589869056, 137438691328]

# Rules:
# Children under 14 old.
# Teens under 18 old.
# Young under 21 old.
# Adults have 21 or more.
def people_with_age_drink(age):
    if age < 14: return 'drink toddy'
    elif age < 18: return 'drink coke'
    elif age < 21: return 'drink beer'
    elif age >= 21: return 'drink whisky'

# In this simple Kata your task is to create a function that turns a string into a Mexican Wave.
# You will be passed a string
# and you must return that string in an array where an uppercase letter is a person standing up.
def wave(people):
    return [people[:i] + people[i].upper() + people[i+1:] for i in range(len(people)) if people[i].isalpha()]

# A child is playing with a ball on the nth floor of a tall building. The height of this floor, h, is known.
# He drops the ball out of the window. The ball bounces (for example), to two-thirds of its height (a bounce of 0.66).
# His mother looks out of a window 1.5 meters from the ground.
# How many times will the mother see the ball pass in front of her window (including when it's falling and bouncing?
def bouncing_ball(h, bounce, window):
    if h > 0 and 0 < bounce < 1 and h > window:
        count = 0
        while h > window:
            count += 1
            h = h * bounce
            if h > window:
                count += 1
        return count
    return -1

# Given a two-dimensional array of integers,
# return the flattened version of the array with all the integers in the sorted (ascending) order.
# Example:
def flatten_and_sort(array):
    new_list = [elem for sublist in array for elem in sublist]
    return sorted(new_list)

# Implement a pseudo-encryption algorithm which given a string S
# and an integer N concatenates all the odd-indexed characters of S with all the even-indexed characters of S,
# this process should be repeated N times.
def encrypt(text, n):
    for i in range(n):
        text = text[1::2] + text[::2]
    return text


def decrypt_one_rep(encrypted_text):
    word1 = ""
    word2 = ""
    lenght = int(len(encrypted_text) / 2)
    word1 += encrypted_text[0:lenght]
    word2 += encrypted_text[lenght:]
    final_word = ""
    for i in range(0, lenght):
        final_word += word2[i] + word1[i]

    if len(encrypted_text) % 2 != 0:
        final_word += word2[lenght]
    return final_word


def decrypt(encrypted_text, n):
    if n < 0:
        return encrypted_text
    list = [encrypted_text]
    for i in range(1, n + 1):
        list.append(decrypt_one_rep(list[i - 1]))
    return list[n]

# You are given two sorted arrays that both only contain integers.
# Your task is to find a way to merge them into a single one, sorted in asc order.
# Complete the function mergeArrays(arr1, arr2), where arr1 and arr2 are the original sorted arrays.
def merge_arrays(arr1, arr2):
    return sorted(set(arr1 + arr2))

# A string is considered to be in title case if each word in the string is either (a) capitalised
# (that is, only the first letter of the word is in upper case)
# or (b) considered to be an exception and put entirely into
# lower case unless it is the first word, which is always capitalised.
# Write a function that will convert a string into title case,
# given an optional list of exceptions (minor words).
# The list of minor words will be given as a string with each word separated by a space.
# Your function should ignore the case of the minor words string --
# it should behave in the same way even if the case of the minor word string is changed.
def title_case(title, minor_words=''):
    list2 = []
    list = [x.title() for x in title.split()]
    exam = [x.title() for x in minor_words.split()]
    if not list:
        return ''
    list2.append(list[0])
    list.pop(0)
    for elem in list:
        for i in range(len(exam)):
            if elem.lower() == exam[i].lower():
                list2.append(elem.lower())
                continue
        if elem not in exam:
            list2.append(elem.title())
    return ' '.join(list2)

# Your team is writing a fancy new text editor and you've been tasked with implementing the line numbering.
# Write a function which takes a list of strings and returns each line prepended by the correct number.
# The numbering starts at 1. The format is n: string. Notice the colon and space in between.
def number(lines):
    list = []
    i = 1
    for elem in lines:
        list.append(f"{i}: {elem}")
        i += 1
    return list

# Simple, given a string of words, return the length of the shortest word(s).
# String will never be empty and you do not need to account for different data types.
def find_short(s):
    # your code here
    return len(list(i for i in sorted(s.split(), key=len))[0])

# Given a string str, reverse it and omit all non-alphabetic characters.
def reverse_letter(string):
    return ''.join(reversed(list(i for i in string if i in 'qwertyuiopasdfghjklzxcvbnm')))

# Given an array of integers, find the one that appears an odd number of times.
# There will always be only one integer that appears an odd number of times.
def find_it(seq):
    return min([i for i in seq if seq.count(i) % 2 != 0])

# Define a function that takes an integer argument and returns a logical value true
# or false depending on if the integer is a prime.
# Per Wikipedia, a prime number ( or a prime ) is a natural number greater than 1
# that has no positive divisors other than 1 and itself.
from math import sqrt
def is_prime(num):
    flag = True
    prime_flag = 0
    if(num > 1):
	    for i in range(2, int(sqrt(num)) + 1):
		    if (num % i == 0):
			    prime_flag = 1
			    break
	    if prime_flag == 0:
		    flag = True
	    else:
		    flag = False
    else:
	    flag = False
    return flag

# So this function should return the first pair of two prime numbers spaced
# with a gap of g between the limits m, n if these numbers exist otherwise `nil
# or null or None or Nothing (or ... depending on the language).
def gap(g, m, n):
    first_int = 0
    second_int = 0
    for i in range(m,n+1):
        if int_is_prime(i):
            if first_int == 0:
                first_int = i
            elif second_int == 0:
                second_int = i
            else:
                first_int = second_int
                second_int = i
        if second_int - first_int == g:
            return [first_int, second_int]
    return None

def int_is_prime(n):
    if n <= 0 or n == 1:
        return False
    i = 2
    while (i <= n ** 0.5 ):
        if n % i == 0:
            return False
        i += 1
    return True\

# The first input array is the key to the correct answers to an exam, like ["a", "a", "b", "d"].
# The second one contains a student's submitted answers.
# The two arrays are not empty and are the same length. Return the score for this array of answers,
# giving +4 for each correct answer, -1 for each incorrect answer, and +0 for each blank answer,
# represented as an empty string (in C the space character is used).
def check_exam(arr1,arr2):
    count = 0
    for i in range(len(arr1)):
        if arr1[i] == arr2[i]:
            count += 4
            continue
        elif arr2[i] == '':
            count += 0
            continue
        count -= 1
    return (count if count > 0 else 0)

# Given a 2D ( nested ) list ( array, vector, .. ) of size m * n,
# your task is to find the sum of the minimum values in each row.
def sum_of_minimums(numbers):
    return sum(min(i) for i in numbers)

# Complete the method which accepts an array of integers, and returns one of the following:
# "yes, ascending" - if the numbers in the array are sorted in an ascending order
# "yes, descending" - if the numbers in the array are sorted in a descending order
# "no" - otherwise
def is_sorted_and_how(arr):
    if sorted(arr, key = int) == arr:
        return 'yes, ascending'
    elif sorted(arr, key = int, reverse = True) == arr:
        return 'yes, descending'
    return 'no'

# Given a list of digits, return the smallest number that could be formed from these digits,
# using the digits only once (ignore duplicates).
def min_value(digits):
    list = sorted(set(digits))
    integer = ''
    for elem in list:
        integer += str(elem)
    return int(integer)

# Implement a function that adds two numbers together and returns their sum in binary.
# The conversion can be done before, or after the addition.
# The binary number returned should be a string.
def add_binary(a,b):
    sum = bin(int(a) + int(b))
    return ''.join(list(sum)[2:])

# The function chooseBestSum (or choose_best_sum or ... depending on the language)
# will take as parameters t (maximum sum of distances, integer >= 0),
# k (number of towns to visit, k >= 1) and ls (list of distances,
# all distances are positive or zero integers and this list has at least one element).
# The function returns the "best" sum ie the biggest possible sum of k distances less than
# or equal to the given limit t, if that sum exists, or otherwise nil, null, None, Nothing,
# depending on the language. In that case with C, C++, D, Dart, Fortran, F#, Go, Julia, Kotlin,
# Nim, OCaml, Pascal, Perl, PowerShell, Reason, Rust, Scala, Shell, Swift return -1.
import itertools
def choose_best_sum(t, k, ls):
    combinations = list(itertools.combinations(ls, k))
    condition = [sum(distance) for distance in combinations]
    condition2 = [distance for distance in condition if distance <= t]
    if condition2 == []:
        largest_distance = None
    else:
        largest_distance = max([distance for distance in condition if distance <= t])
    return largest_distance

# ROT13 is a simple letter substitution cipher that replaces a letter with the letter 13 letters
# after it in the alphabet. ROT13 is an example of the Caesar cipher.
# Create a function that takes a string and returns the string ciphered with Rot13.
# If there are numbers or special characters included in the string,
# they should be returned as they are. Only letters from the latin/english alphabet should be shifted,
# like in the original Rot13 "implementation".
# Please note that using encode is considered cheating.
def rot13(message):
    key = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
    val = "nopqrstuvwxyzabcdefghijklmNOPQRSTUVWXYZABCDEFGHIJKLM"
    transform = dict(zip(key, val))
    return ''.join(transform.get(char, char) for char in message)

# Given an integer as input, can you round it to the next (meaning, "greater than or equal") multiple of 5?
def round_to_next5(n):
    if n == 0:
        pass
    elif abs(n)%5 == 0:
        pass
    else:
        n =  n - n%5 + 5
    return n

# You need to write a function that reverses the words in a given string.
# A word can also fit an empty string. If this is not clear enough, here are some examples:
# As the input may have trailing spaces, you will also need to ignore unneccesary whitespace.
def reverse(st):
    return ' '.join(list(st.split())[::-1])

# Write a function named sumDigits which takes a number as input
# and returns the sum of the absolute value of each of the number's decimal digits.
def sumDigits(number):
    return sum(int(d) for d in str(abs(number)))

# As a part of this Kata, you need to create a function that when provided with a triplet,
# returns the index of the numerical element that lies between the other two elements.
# The input to the function will be an array of three distinct numbers (Haskell: a tuple).
def gimme(input_array):
    return [input_array.index(i) for i in input_array if min(input_array) < i < max(input_array)][0]

# The Western Suburbs Croquet Club has two categories of membership, Senior and Open.
# They would like your help with an application form that will tell prospective members
# which category they will be placed.
# To be a senior, a member must be at least 55 years old and have a handicap greater than 7.
# In this croquet club, handicaps range from -2 to +26; the better the player the lower the handicap.
def open_or_senior(data):
    return ['Senior' if elem[0] >= 55 and elem[1] > 7 else 'Open' for elem in data]

# Alice and Bob were on a holiday. Both of them took many pictures of the places they've been,
# and now they want to show Charlie their entire collection.
# However, Charlie doesn't like these sessions, since the motif usually repeats.
# He isn't fond of seeing the Eiffel tower 40 times.
# He tells them that he will only sit for the session if they show the same motif at most N times.
# Luckily, Alice and Bob are able to encode the motif as a number.
# Can you help them to remove numbers such that their list contains each number only up to N times,
# without changing the order?
def delete_nth(order,max_e):
    sort_list = []
    for elem in order:
        if sort_list.count(elem) >= max_e:
            continue
        sort_list.append(elem)
    return sort_list

# Given a number, say prod (for product), we search two Fibonacci numbers F(n) and F(n+1) verifying
# Your function product Fib takes an integer(prod) and returns an array
# depending on the language if F(n) * F(n+1) = prod.
def productFib(prod):
    First_val = 0
    Second_val = 1
    next = 0
    while First_val * Second_val < prod:
            next = First_val + Second_val
            First_val = Second_val
            Second_val = next
    return [First_val, Second_val, True if First_val * Second_val == prod else False]

# Given a sequence of numbers, find the largest pair sum in the sequence.
def largest_pair_sum(numbers):
    return sorted(numbers)[-1] + sorted(numbers)[-2]

# Your task is to write a function which calculates the value
# of a word based off the sum of the alphabet positions of its characters.
# The input will always be made of only lowercase letters and will never be empty.
def words_to_marks(s):
    return sum(ord(char) - 96 for char in s)

# We know the content of the evaporator (content in ml), the percentage of foam or gas lost every day (evap_per_day)
# and the threshold (threshold) in percentage beyond which the evaporator is no longer useful.
# All numbers are strictly positive.
def evaporator(content, evap_per_day, threshold):
    result = 0;
    percentage = 100;
    while percentage > threshold:
        percentage = percentage - percentage * (evap_per_day / 100)
        result += 1
    return result

# You will be given an array of numbers. You have to sort the odd numbers
# in ascending order while leaving the even numbers at their original positions.
def sort_array(source_array):
    odds = iter(sorted(elem for elem in source_array if elem % 2))
    return [next(odds) if elem % 2 else elem for elem in source_array]

# Complete the solution so that it returns true if the first argument(string)
# passed in ends with the 2nd argument (also a string).
def solution(string, ending):
    return string[::-1][:len(ending)] == ending[::-1]

# Mr. Scrooge has a sum of money 'P' that he wants to invest. Before he does,
# he wants to know how many years 'Y' this sum 'P' has to be kept in the bank
# in order for it to amount to a desired sum of money 'D'.
# The sum is kept for 'Y' years in the bank where interest 'I' is paid yearly.
# After paying taxes 'T' for the year the new sum is re-invested.
# Note to Tax: not the invested principal is taxed, but only the year's accrued interest
def calculate_years(principal, interest, tax, desired):
    count = 0
    if principal == desired:
            return count
    while principal < desired:
        count += 1
        percent = principal * interest - (principal * interest * tax)
        principal += percent
    return count

# A stream of data is received and needs to be reversed.
# Each segment is 8 bits long, meaning the order of these segments needs to be reversed, for example:
def data_reverse(data):
    return [elem for i in range(len(data), -1, -8) for elem in data[i: i + 8]]

# Implement a function that accepts 3 integer values a, b, c.
# The function should return true if a triangle can be built with
# the sides of given length and false in any other case.
def is_triangle(a, b, c):
    return max(a, b ,c) < a + b + c - max(a, b ,c)

# Your task is to write function factorial.
import math
def factorial(n):
    return math.factorial(n)

# Given an array of numbers, return a new array of length number containing the last even numbers
# from the original array (in the same order). The original array will be not empty
# and will contain at least "number" even numbers.
def even_numbers(arr,n):
    return [i for i in arr[::-1] if i % 2 == 0][:n][::-1]

# My grandfather always predicted how old people would get,
# and right before he passed away he revealed his secret!
# In honor of my grandfather's memory we will write a function using his formula!
# Take a list of ages when each of your great-grandparent died.
# Multiply each number by itself.
# Add them all together.
# Take the square root of the result.
# Divide by two.
def predict_age(age_1, age_2, age_3, age_4, age_5, age_6, age_7, age_8):
    return sum([age_1**2, age_2**2, age_3**2, age_4**2, age_5**2, age_6**2, age_7**2, age_8**2])**0.5 // 2

# We want to know the index of the vowels in a given word,
# for example, there are two vowels in the word super (the second and fourth letters).
# So given a string "super", we should return a list of [2, 4].
def vowel_indices(word):
    return [index + 1 for index, elem in enumerate(word) if elem.lower() in 'aeoiuy']

# Introduction
# There is a war and nobody knows - the alphabet war!
# There are two groups of hostile letters.
# The tension between left side letters and right side letters was too high and the war began.
# Task
# Write a function that accepts fight string consists of only small letters and return who wins the fight.
# When the left side wins return Left side wins!, when the right side wins return Right side wins!,
# in other case return Let's fight again!.
def alphabet_war(fight):
    left_side = {'w': 4, 'p': 3, 'b': 2, 's': 1}
    right_side = {'m': 4, 'q': 3, 'd': 2, 'z': 1}
    left_count = 0
    right_count = 0
    for char in fight:
        if char in left_side:
            left_count += left_side[char]
        elif char in right_side:
            right_count += right_side[char]
    if left_count > right_count:
        return 'Left side wins!'
    elif right_count > left_count:
        return 'Right side wins!'
    return "Let's fight again!"

# Several people are standing in a row divided into two teams.
# The first person goes into team 1, the second goes into team 2, the third goes into team 1, and so on.
# Task
# Given an array of positive integers (the weights of the people),
# return a new array/tuple of two integers, where the first one is the total weight of team 1,
# and the second one is the total weight of team 2.
def row_weights(array):
    return sum(i for i in array[::2]), sum(i for i in array[1::2])

# In this Kata, you will be given a string that may have mixed uppercase and lowercase letters
# and your task is to convert that string to either lowercase only or uppercase only based on:
# make as few changes as possible.
# if the string contains equal number of uppercase and lowercase letters, convert the string to lowercase.
def solve(s):
    count_lower: int = 0
    count_upper: int = 0
    for i in s:
        if i.islower():
            count_lower += 1
            continue
        count_upper += 1
    if count_lower >= count_upper:
        return s.lower()
    return s.upper()

# In a small town the population is p0 = 1000 at the beginning of a year.
# The population regularly increases by 2 percent per year and moreover 50 new inhabitants
# per year come to live in the town. How many years does the town need
# to see its population greater or equal to p = 1200 inhabitants?
def nb_year(p0, percent, aug, p):
    count = 0
    while p0 < p:
        p0 += int(p0 * (percent / 100) + aug)
        count += 1
    return count

# Find the total sum of internal angles (in degrees) in an n-sided simple polygon. N will be greater than 2.
def angle(n):
    return 180 * (n - 2)

# Given an array of ones and zeroes, convert the equivalent binary value to an integer.
# Eg: [0, 0, 0, 1] is treated as 0001 which is the binary representation of 1.
def binary_array_to_number(arr):
    return int("".join([str(i) for i in arr]), 2)

# Your task is to return the sum of Triangular Numbers up-to-and-including the nth Triangular Number.
# Triangular Number: "any of the series of numbers (1, 3, 6, 10, 15, etc.)
# obtained by continued summation of the natural numbers 1, 2, 3, 4, 5, etc."
def sum_triangular_numbers(n):
    if n < 0:
        return 0
    sum = sum_triangular_numbers(n-1)
    return sum + (n * (n + 1)) / 2

# Given a positive integer n written as abcd... (a, b, c, d... being digits) and a positive integer p
# we want to find a positive integer k, if it exists, such that the sum of the digits of n taken
# to the successive powers of p is equal to k * n.
def dig_pow(n, p):
    count = 0
    for char in str(n):
        count += int(char) ** p
        p += 1
    return count // n if count % n == 0 else -1

# You are given an array(list) strarr of strings and an integer k.
# Your task is to return the first longest string consisting of k consecutive strings taken in the array.
def longest_consec(strarr, k):
    return max(["".join(strarr[i:i+k]) for i in range(len(strarr)-k+1)], key=len)\
        if strarr and 0 < k <= len(strarr) else ""

# Let us begin with an example:
# A man has a rather old car being worth $2000.
# He saw a secondhand car being worth $8000.
# He wants to keep his old car until he can buy the secondhand one.
# He thinks he can save $1000 each month but the prices of his old car
# and of the new one decrease of 1.5 percent per month.
# Furthermore this percent of loss increases of 0.5 percent at the end of every two months.
# Our man finds it difficult to make all these calculations.
def nbMonths(start_price_old, start_price_new, saving_per_month, percent_loss_by_month):
    months = 0
    savings = 0
    while start_price_old + savings < start_price_new:
        months += 1
        savings += saving_per_month
        if months % 2 == 0:
            percent_loss_by_month += 0.5
        start_price_old *= ((100 - percent_loss_by_month) / 100)
        start_price_new *= ((100 - percent_loss_by_month) / 100)
    return [months, round(start_price_old + savings - start_price_new)]

# Your car is old, it breaks easily. The shock absorbers are gone
# and you think it can handle about 15 more bumps before it dies totally.
# Unfortunately for you, your drive is very bumpy! Given a string showing either flat road (_) or bumps (n).
# If you are able to reach home safely by encountering 15 bumps or less, return Woohoo!, otherwise return Car Dead
def bumps(road):
    return "Woohoo!" if road.count("n") <= 15 else "Car Dead"

# Find the number with the most digits.
# If two numbers in the argument array have the same number of digits, return the first one in the array.
def find_longest(arr):
    arr_len = [len(str(n)) for n in arr]
    return arr[arr_len.index(max(arr_len))]

# There are pillars near the road. The distance between the pillars is the same
# and the width of the pillars is the same. Your function accepts three arguments:
# number of pillars (≥ 1);
# distance between pillars (10 - 30 meters);
# width of the pillar (10 - 50 centimeters).
# Calculate the distance between the first and the last pillar in centimeters
# (without the width of the first and last pillar).
def pillars(num_pill, dist, width):
    return (num_pill - 2) * width + (100 * dist) * (num_pill - 1) if num_pill > 1 else 0

# What if we need the length of the words separated by a space
# to be added at the end of that same word and have it returned as an array?
def add_length(str_):
    return [f"{i} {len(i)}" for i in str_.split()]

# You're re-designing a blog and the blog's posts have the following format
# for showing the date and time a post was made:
# Weekday Month Day, time e.g., Friday May 2, 7pm
# You're running out of screen real estate, and on some pages you want
# to display a shorter format, Weekday Month Day that omits the time.
# Write a function, shortenToDate, that takes the Website date/time
# in its original string format, and returns the shortened format.
# Assume shortenToDate's input will always be a string, e.g. "Friday May 2, 7pm".
# Assume shortenToDate's output will be the shortened string, e.g., "Friday May 2".
def shorten_to_date(long_date):
    return long_date.split(',')[0]

# A student was working on a function and made some syntax mistakes while coding.
# Help them find their mistakes and fix them.
def main(verb, noun):
    return verb + noun

# Code as fast as you can! You need to double the integer and return it.
def doubleInteger(i):
    return i * 2

# Complete function saleHotdogs/SaleHotDogs/sale_hotdogs, function accept 1 parameters:
# n, n is the number of customers to buy hotdogs, different numbers have different
# prices (refer to the following table), return a number that the customer need to pay how much money.
def sale_hotdogs(n):
    if n < 5: return n * 100
    elif 5 <= n < 10: return n * 95
    return n * 90

# Replace all vowel to exclamation mark in the sentence. aeiouAEIOU is vowel.
def replace_exclamation(s):
    for char in s:
        if char.lower() in 'aeiou':
            s = s.replace(char, '!')
    return s

# I will give you an integer. Give me back a shape that is as long
# and wide as the integer. The integer will be a whole number between 1 and 50.
def generate_shape(n: int) -> str:
    return '\n'.join(['+' * n] * n)

# Create a function called _if which takes 3 arguments:
# a boolean value bool and 2 functions (which do not take any parameters): func1 and func2
# When bool is truth-ish, func1 should be called, otherwise call the func2.
def _if(bool, func1, func2):
    return func1() if bool == True else func2()

# Your task is to write a function which returns the sum of following series upto nth term(parameter).
def series_sum(n):
    return '{:.2f}'.format(sum(1.0/(3 * i + 1) for i in range(n)))

# Define a function that removes duplicates from an array of numbers and returns it as a result.
# The order of the sequence has to stay the same.
def distinct(seq):
    new_list = []
    for elem in seq:
        if elem not in new_list:
            new_list.append(elem)
    return new_list

# Given an array of numbers, check if any of the numbers are the character codes
# for lower case vowels (a, e, i, o, u).
# If they are, change the array value to a string of that vowel.
# Return the resulting array.
def is_vow(s):
    vowels = {97: 'a', 111: 'o', 117: 'u', 101: 'e', 105: 'i'}
    return [vowels.get(elem, elem) for elem in s]

# In Python, there is a built-in filter function that operates similarly to JS's filter.
# For more information on how to use this function, visit https://docs.python.org/3/library/functions.html#filter
def get_even_numbers(arr):
    return list(filter(lambda x: x % 2 == 0, arr))

# In this kata you are required to, given a string, replace every letter with its position in the alphabet.
# If anything in the text isn't a letter, ignore it and don't return it.
def alphabet_position(text):
    return ' '.join([str(ord(char) - 96) for char in text.lower() if char >= 'a' and char<= 'z'])

# Complete the method which returns the number which is most frequent in the given input array.
# If there is a tie for most frequent number, return the largest number among them.
# Note: no empty arrays will be given.
from collections import Counter
def highest_rank(arr):
    c = Counter(arr)
    m = max(c.values())
    return max(k for k, v in c.items() if v == m)

# We want to generate a function that computes the series starting from 0 and ending until the given number.
def show_sequence(n):
    sum=0
    s=''
    if n==0:
        return "0=0"
    elif n<0:
        return str(n)+"<0"
    else:
        for i in range(0,n+1):
            sum += i
            s+=str(i)+'+'
        s = s.strip('+')
        s = s +" = "+str(sum)
        return s

# Remove all exclamation marks from the end of sentence.
def remove(s):
    while s.endswith('!'):
        s = s[:-1]
    return s

# Write a function that will check if two given characters are the same case.
# If either of the characters is not a letter, return -1
# If both characters are the same case, return 1
# If both characters are letters, but not the same case, return 0
def same_case(a: str, b: str) -> int:
    if not a.isalpha() or not b.isalpha():
        return -1
    return 1 if a.islower() and b.islower() or a.isupper() and b.isupper() else 0

# Write a function that returns a string in which firstname is swapped with last name.
def name_shuffler(str_):
    return ' '.join(str_.split()[::-1])

# To find the volume (centimeters cubed) of a cuboid you use the formula:
# volume = Length * Width * Height
# But someone forgot to use proper record keeping,
# so we only have the volume, and the length of a single side!
# It's up to you to find out whether the cuboid has equal sides (= is a cube).
def cube_checker(volume, side):
    return volume == side ** 3 if volume > 0 and side > 0 else False

# You've just moved into a perfectly straight street with exactly n identical houses
# on either side of the road. Naturally, you would like to find out the house number
# of the people on the other side of the street.
def over_the_road(address, n):
    return (n * 2) - address + 1

# Given two arrays a and b write a function comp(a, b) (orcompSame(a, b))
# that checks whether the two arrays have the "same" elements, with the same multiplicities
# (the multiplicity of a member is the number of times it appears). "Same" means,
# here, that the elements in b are the elements in a squared, regardless of the order.
def comp(array1, array2):
    if array1 == None or array2 == None:
        return False
    return sorted(number ** 2 for number in array1) == sorted(array2)

# Output: String with comma delimited elements of the array in th same order.
def print_array(arr):
    return ','.join(str(i) for i in arr)

# An AI has infected a text with a character!!
# This text is now fully mutated to this character.
# If the text or the character are empty, return an empty string.
# There will never be a case when both are empty as nothing is going on!!
# Note: The character is a string of length 1 or an empty string.
def contamination(text, char):
    return char * len(text) if text and char != '' else ''

# Write a function that takes a positive integer n, sums all the cubed values from 1 to n, and returns that sum.
# Assume that the input n will always be a positive integer.
def sum_cubes(n):
    return sum(i**3 for i in range(n + 1))

# We need a simple function that determines if a plural is needed or not.
# It should take a number, and return true if a plural should
# be used with that number or false if not. This would be useful when printing
# out a string such as 5 minutes, 14 apples, or 1 sun.
# You only need to worry about english grammar rules for this kata,
# where anything that isn't singular (one of something), it is plural (not one of something).
def plural(n):
    return n != 1

# You will be given an array a and a value x. All you need to do
# is check whether the provided array contains the value, without using a loop.
# Array can contain numbers or strings. x can be either. Return true
# if the array contains the value, false if not. With strings you will need to account for case.
def check(a, x):
    return x in a

# Given a variable n,
# If n is an integer, Return a string with dash'-'marks before and after each odd integer,
# but do not begin or end the string with a dash mark. If n is negative, then the negative sign should be removed.
# If n is not an integer, return the string "None".
def dashatize(num):
    num_str = str(num)
    for i in ['1','3','5','7','9']:
        num_str = num_str.replace(i,'-' + i + '-')
    return num_str.strip('-').replace('--','-')

# Fix the variables assigments so that this code stores the string 'devLab' in the variable name.
a, b, name = 'dev', 'Lab', 'devLab'

# Determine the total number of digits in the integer (n>=0) given
# as input to the function. For example, 9 is a single digit,
# 66 has 2 digits and 128685 has 6 digits. Be careful to avoid overflows/underflows.
def digits(n):
    return len(str(n))

# Christmas is coming and many people dreamed of having a ride with Santa's sleigh.
# But, of course, only Santa himself is allowed to use this wonderful transportation.
# And in order to make sure, that only he can board the sleigh, there's an authentication mechanism.
# Your task is to implement the authenticate() method of the sleigh, which takes the name of the person,
# who wants to board the sleigh and a secret password. If, and only if,
# the name equals "Santa Claus" and the password is "Ho Ho Ho!"
# (yes, even Santa has a secret password with uppercase and lowercase letters
# and special characters :D), the return value must be true. Otherwise it should return false.
class Sleigh(object):
    def authenticate(self, name, password):
        return name == 'Santa Claus' and password == 'Ho Ho Ho!'

# Your mission:
# Write a function called checkCoupon which verifies that a coupon code is valid and not expired.
# A coupon is no more valid on the day AFTER the expiration date.
# All dates will be passed as strings in this format: "MONTH DATE, YEAR".
from datetime import date
def check_coupon(entered_code, correct_code, current_date, expiration_date):
    month = {'January': 1, 'February': 2, 'March': 3, 'April': 4,
            'May': 5, 'June': 6, 'July': 7, 'August': 8, 'September': 9, 'October': 10,
            'November': 11, 'December': 12}
    if entered_code is correct_code:
        current_date = current_date.replace(',', '')
        expiration_date = expiration_date.replace(',', '')
        formatted_current = [month.get(i) if i in month.keys() else int(i) for i in current_date.split()]
        formatted_expiration = [month.get(i) if i in month.keys() else int(i) for i in expiration_date.split()]
        to_date_current = date(formatted_current[2], formatted_current[0], formatted_current[1])
        to_date_formatted_expiration = date(formatted_expiration[2], formatted_expiration[0], formatted_expiration[1])
        if to_date_current <= to_date_formatted_expiration:
            return True
        return False
    return False

# Complete the function, which calculates how much you need to
# tip based on the total amount of the bill and the service.
import math
def calculate_tip(amount, rating):
    rating_dict = {'poor': 5, 'good': 10, 'great': 15, 'excellent': 20, 'terrible': 0}
    if rating.lower() in rating_dict:
        return math.ceil(rating_dict[rating.lower()] * amount / 100)
    return 'Rating not recognised'

# You get any card as an argument. Your task is to return the suit of this card (in lowercase).
def define_suit(card):
    return 'clubs' if 'C' in card else 'spades' if 'S' in card\
        else 'diamonds' if 'D' in card else 'hearts' if 'H' in card else None

# Create a method that accepts a list and an item,
# and returns true if the item belongs to the list, otherwise false.
def include(arr,item):
    return item in arr

# You have to write a function that describe Leo:
# def leo(oscar):
#   pass
# if oscar was (integer) 88, you have to return "Leo finally won the oscar! Leo is happy".
# if oscar was 86, you have to return "Not even for Wolf of wallstreet?!"
# if it was not 88 or 86 (and below 88) you should return "When will you give Leo an Oscar?"
# if it was over 88 you should return "Leo got one already!"
def leo(oscar):
    if oscar == 88: return 'Leo finally won the oscar! Leo is happy'
    elif oscar == 86: return 'Not even for Wolf of wallstreet?!'
    elif oscar != 88 and oscar != 86 and oscar < 88: return 'When will you give Leo an Oscar?'
    elif oscar > 88: return 'Leo got one already!'

# Given a string s, write a method (function) that will return true if
# its a valid single integer or floating number or false if its not.
def isDigit(string):
    try:
        float(string)
        return True
    except:
        return False

# The objective of Duck, duck, goose is to walk in a circle, tapping on each player's head until one is chosen.
def duck_duck_goose(players, goose):
    while len(players) < goose:
        goose -= len(players)
    return players[goose - 1].name

# Make a function that will return a greeting statement that uses an input;
# your program should return, "Hello, <name> how are you doing today?".
def greet(name):
    return f'Hello, {name} how are you doing today?'

# Write a function that returns the total surface area and volume of a box as an array: [area, volume]
def get_size(w,h,d):
    return [((w * h) + (w * d) + (h * d)) * 2, w * h * d]

# Write a function which removes from string all non-digit characters
# and parse the remaining to number. E.g: "hell5o wor6ld" -> 56
def get_number_from_string(string):
    return int(''.join(list(i for i in string if i in '0123456789')))\

# Your task is to sum the differences between consecutive pairs in the array in descending order.
def sum_of_differences(arr):
    arr = sorted(arr, reverse = True)
    list = []
    for i in range(len(arr)):
        for j in range(i + 1, len(arr)):
            list.append(arr[i] - arr[j])
    return max(list) if len(arr) > 1 else 0

# Basic regex tasks. Write a function that takes in a numeric code of any length.
# The function should check if the code begins with 1, 2, or 3 and return true if so. Return false otherwise.
def validate_code(code):
    return str(code)[0] in '123'

# Given an array of integers , Find the minimum sum which is obtained from summing each Two integers product .
def min_sum(arr):
    arr = sorted(arr)
    return sum(arr[i]*arr[-i-1] for i in range(len(arr)//2))

# Given an array of integers of any length, return an array that has 1 added to the value represented by the array.
#  the array can't be empty
# only non-negative, single digit integers are allowed
# Return nil (or your language's equivalent) for invalid inputs.
def up_array(arr):
    integer = ''
    list = []
    print(arr)
    if len(arr) < 1 :
        return None
    elif len(arr) == 1 and arr[0] <=9:
        return [1]
    for i in arr:
        if len(str(i)) > 1 or i < 0:
            return None
    else:
        for elem in arr:
            if str(elem) in '1234567890':
                integer += str(elem)
    if integer[0] == '0' and integer[1] != '0':
        integer = int(integer[1:]) + 1
        integer = '0' + str(integer)
    elif integer[0] == '0' and integer[1] == '0':
        integer = int(integer[2:]) + 1
        integer = '00' + str(integer)
    elif integer[0] != '0':
        integer = str(int(integer) + 1)
    for char in integer:
        list.append(int(char))
    return list

# We want an array, but not just any old array, an array with contents!
# Write a function that produces an array with the numbers 0 to N-1 in it.
# For example, the following code will result in an array containing the numbers 0 to 4
def arr(n=0):
    return list(range(n))

# Time to test your basic knowledge in functions! Return the odds from a list:
# [1, 2, 3, 4, 5]  -->  [1, 3, 5]
# [2, 4, 6]        -->  []
odds = lambda list: [i for i in list if i % 2 !=0]

# Create a function close_compare that accepts 3 parameters: a, b, and an optional margin.
# The function should return whether a is lower than, close to, or higher than b.
# a is considered "close to" b if margin is greater than or equal to the distance between a and b.
def close_compare(a, b, margin=0):
    if a < b and b - a > margin: return -1
    elif a - b > margin and a > b: return 1
    elif a - b <= margin: return 0

# Take an integer n (n >= 0) and a digit d (0 <= d <= 9) as an integer.
# Square all numbers k (0 <= k <= n) between 0 and n.
# Count the numbers of digits d used in the writing of all the k**2.
# Call nb_dig (or nbDig or ...) the function taking n and d as parameters and returning this count.
def nb_dig(n, d):
    values_list = list(range(0, n+1))
    list_squared = list(map(lambda x: str(x**2), values_list))
    str_list_squared = ''.join(list_squared)
    print(str(d))
    return str_list_squared.count(str(d))

# Due to another of his misbehaved, the primary school's teacher of the young Gauß,
# Herr J.G. Büttner, to keep the bored and unruly young schoolboy Karl Friedrich Gauss
# busy for a good long time, while he teaching arithmetic to his mates,
# assigned him the problem of adding up all the whole numbers from 1 through a given number n.
def f(n):
    return sum(range(1, n + 1)) if type(n) is int and n > 0 else None

# Your friend invites you out to a cool floating pontoon around 1km off the beach.
# Among other things, the pontoon has a huge slide that drops you out right into the ocean,
# a small way from a set of stairs used to climb out.
# As you plunge out of the slide into the water, you see a shark hovering
# in the darkness under the pontoon... Crap!
# You need to work out if the shark will get to you before you can get to the pontoon.
# To make it easier... as you do the mental calculations in the water you either freeze
# when you realise you are dead, or swim when you realise you can make it!
def shark(pontoon_distance, shark_distance, you_speed, shark_speed, dolphin):
    if dolphin:
        if pontoon_distance / you_speed < shark_distance / (shark_speed / 2):
            return 'Alive!'
        else:
            return 'Shark Bait!'
    elif pontoon_distance / you_speed > shark_distance / shark_speed:
        return 'Shark Bait!'
    elif pontoon_distance / you_speed < shark_distance / shark_speed:
        return 'Alive!'

# Get ASCII value of a character.
def get_ascii(c):
   return ord(c)

# Write a function that takes a single string (word) as argument.
# The function must return an ordered list containing the indexes of all capital letters in the string.
def capitals(word):
    return [value for value, i in enumerate(word) if i.isupper()]

# Complete the function which converts hex number (given as a string) to a decimal number.
def hex_to_dec(s):
    return int(s, 16)

# Create a combat function that takes the player's current health
# and the amount of damage recieved, and returns the player's new health. Health can't be less than 0.
def combat(health, damage):
    return health - damage if health > damage else 0

# Find the sum of all multiples of n below m
# Keep in Mind
# n and m are natural numbers (positive integers)
# m is excluded from the multiples
def sum_mul(n, m):
    return sum(range(n, m, n)) if m > 0 and n > 0 else 'INVALID'

# Your job is simple, if x squared is more than 1000,
# return It's hotter than the sun!!, else, return Help yourself to a honeycomb Yorkie for the glovebox.
# Note: Input will either be a positive integer (or a string for untyped languages).
def apple(x):
  return "It's hotter than the sun!!" if int(x)**2 > 1000 else "Help yourself to a honeycomb Yorkie for the glovebox."

# You are required to create a simple calculator that returns
# the result of addition, subtraction, multiplication or division of two numbers.
# Your function will accept three arguments:
# The first and second argument should be numbers.
# The third argument should represent a sign indicating the operation to perform on these two numbers.
# if the variables are not numbers or the sign does not belong to the list above
# a message "unknown value" must be returned.
def calculator(x,y,op):
    if type(x) == int and type(y) == int:
        dict_op = {'+': x+y, '-': x-y, '*': x*y, '/': x/y}
        if op in dict_op and x !=0 and y !=0:
            return dict_op[op]
        else:
            return 'unknown value'
    return 'unknown value'

# Deoxyribonucleic acid, DNA is the primary information storage molecule in biological systems. It is composed
# of four nucleic acid bases Guanine ('G'), Cytosine ('C'), Adenine ('A'), and Thymine ('T').
# Ribonucleic acid, RNA, is the primary messenger molecule in cells.
# RNA differs slightly from DNA its chemical structure and contains no Thymine.
# In RNA Thymine is replaced by another nucleic acid Uracil ('U').
# Create a function which translates a given DNA string into RNA.
def dna_to_rna(dna):
    dict = {'G': 'G', 'C': 'C', 'A': 'A', 'T': 'U'}
    return ''.join(list(dict[char] for char in dna))

# Find the sum of the odd numbers within an array, after cubing the initial integers.
# The function should return undefined/None/nil/NULL if any of the values aren't numbers.
# Note: Booleans should not be considered as numbers.
def cube_odd(arr):
    for elem in arr:
        if type(elem) != int:
            return None
    return sum([i**3 for i in arr if i % 2 != 0])

# You must implement a function that returns the difference between the largest
# and the smallest value in a given list / array (lst) received as the parameter.
# lst contains integers, that means it may contain some negative numbers
# if lst is empty or contains a single element, return 0
# lst is not sorted
def max_diff(lst):
    return max(lst) - min(lst) if lst else 0

# Your task is simply to count the total number of lowercase letters in a string.
def lowercase_count(strng):
    return len(list(i for i in strng if i.islower()))

# Return an array/list where Even numbers come first then odds
# Since , Men are stronger than Boys , Then Even numbers in ascending order While odds in descending .
# Array/list size is at least 4 .
# Array/list numbers could be a mixture of positives , negatives .
# Have no fear , It is guaranteed that no Zeroes will exists .
def men_from_boys(arr):
    return sorted(list(set(list(i for i in arr if i % 2 == 0)))) +\
           sorted(list(set(list(i for i in arr if i % 2 != 0))), reverse = True)

# Step 1: Create a function called encode() to replace all
# the lowercase vowels in a given string with numbers according to the following pattern:
# For example, encode("hello") would return "h2ll4".
# There is no need to worry about uppercase vowels in this kata.
# Step 2: Now create a function called decode() to turn the numbers
# back into vowels according to the same pattern shown above.
# For example, decode("h3 th2r2") would return "hi there".
# For the sake of simplicity, you can assume that any numbers passed into the function will correspond to vowels.
def encode(st):
    dict = {'a': '1', 'e': '2', 'i': '3', 'o': '4', 'u': '5'}
    return ''.join([dict[char] if char in dict else char for char in st])


def decode(st):
    dict = {'1': 'a', '2': 'e', '3': 'i', '4': 'o', '5': 'u'}
    return ''.join([dict[char] if char in dict else char for char in st])

# You can print your name on a billboard ad. Find out how much it will cost you.
# Each character has a default price of £30, but that can be different if you are given 2 parameters instead of 1.
# You can not use multiplier "*" operator.
# If your name would be Jeong-Ho Aristotelis, ad would cost £600. 20 leters * 30 = 600 (Space counts as a character).
def billboard(name, price=30):
    return sum(price for i in range(len(name)))

# Complete the function which converts a binary number (given as a string) to a decimal number.
def bin_to_decimal(inp):
    return int(inp, 2)

# Given an array/list of integers, find the Nth smallest element in the array.
# Notes
# Array/list size is at least 3.
# Array/list's numbers could be a mixture of positives , negatives and zeros.
# Repetition in array/list's numbers could occur, so don't remove duplications.
def nth_smallest(arr, pos):
    return sorted(arr)[pos-1]

# Implement String#digit? (in Java StringUtils.isDigit(String)),
# which should return true if given object is a digit (0-9), false otherwise.
def is_digit(n):
    return n in '0123456789' and n != ''

# Given a mixed array of number and string representations of integers, add up the non-string integers
# and subtract this from the total of the string integers.
# Return as a number.
def div_con(x):
    return sum(list(i if type(i) == int else 0 for i in x)) - sum(list(int(i) if type(i) == str else 0 for i in x ))

# A balanced number is a number where the sum of digits to the left of the middle digit(s)
# and the sum of digits to the right of the middle digit(s) are equal.
# If the number has an odd number of digits, then there is only one middle digit.
# (For example, 92645 has one middle digit, 6.) Otherwise, there are two middle digits.
# (For example, the middle digits of 1301 are 3 and 0.)
# The middle digit(s) should not be considered when determining whether a number is balanced or not,
# e.g. 413023 is a balanced number because the left sum and right sum are both 5.
# The task
# Given a number, find if it is balanced, and return the string "Balanced" or "Not Balanced" accordingly.
# The passed number will always be positive.
def balanced_num(number):
    s = str(number)
    l = (len(s)-1)//2
    same = len(s) < 3 or sum(map(int, s[:l])) == sum(map(int, s[-l:]))
    return "Balanced" if same else "Not Balanced"

# A number is called Automorphic number if and only if its square ends in the same digits as the number itself.
# Task
# Given a number determine if it Automorphic or not .
def automorphic(n):
    return 'Automorphic' if str(n**2).count(str(n)) else 'Not!!'

# You live in the city of Cartesia where all roads are laid out in a perfect grid.
# You arrived ten minutes too early to an appointment, so you decided to take the opportunity
# to go for a short walk. The city provides its citizens with a Walk Generating App on
# their phones -- everytime you press the button it sends you an array of one-letter
# strings representing directions to walk (eg. ['n', 's', 'w', 'e']).
# You always walk only a single block for each letter (direction)
# and you know it takes you one minute to traverse one city block,
# so create a function that will return true if the walk the app gives you
# will take you exactly ten minutes (you don't want to be early or late!) and will,
# of course, return you to your starting point. Return false otherwise.
def is_valid_walk(walk):
    list = []
    dict = {'n': 's', 's': 'n',
           'e': 'w', 'w': 'e'}
    if len(walk) == 10:
        for elem in walk:
            list.append(walk.count(elem) == walk.count(dict[elem]))
        print(list)
        return False not in list
    return False

# Write a function get_char() / getChar() which takes a number and returns the corresponding ASCII char for that value.
def get_char(c):
    return chr(c)

#Complete the function that takes two numbers as input,
# num and nth and return the nth digit of num (counting from right to left).
# Note
# If num is negative, ignore its sign and treat it as a positive value
# If nth is not positive, return -1
# Keep in mind that 42 = 00042. This means that findDigit(42, 5) would return 0
def find_digit(num, nth):
    return int(str(num)[-nth]) if nth <= len(str(num)) and nth > 0 else -1 if nth <= 0 else 0

# Write function parse_float which takes a string/list and returns a number
# or 'none' if conversion is not possible.
def parse_float(string):
    try: return float(string)
    except Exception:
        return None

# Your task, is to create NxN multiplication table, of size provided in parameter.
def multiplication_table(size):
    return [[i * n for i in range(1, size + 1)] for n in range(1, size + 1)]

# Your task is to return the correct string using the Template String Feature.
def temple_strings(obj, feature):
    return f"{obj} are {feature}"

# Count the number of occurrences of each character
# and return it as a (list of tuples) in order of appearance. For empty output return (an empty list).
# Consult the solution set-up for the exact data structure implementation depending on your language.
import collections
def ordered_count(inp):
    return list(collections.Counter(inp).items())

# Modify the spacify function so that it returns the given string with spaces inserted between each character.
def spacify(string):
    return " ".join(string)

# Your boss decided to save money by purchasing some cut-rate optical character
# recognition software for scanning in the text of old novels to your database.
# At first it seems to capture words okay, but you quickly notice that it throws
# in a lot of numbers at random places in the text.
def string_clean(s):
    return ''.join('' if ch.isdigit() else ch for ch in s)

# iven an array/list [] of n integers , find maximum triplet sum in the array Without duplications .
# Notes :
# Array/list size is at least 3 .
# Array/list numbers could be a mixture of positives , negatives and zeros .
# Repetition of numbers in the array/list could occur , So (duplications are not included when summing).
def max_tri_sum(numbers):
    return sum(list(sorted(set(numbers), reverse = True))[:3])

# The word i18n is a common abbreviation of internationalization
# in the developer community, used instead of typing the whole word
# and trying to spell it correctly. Similarly, a11y is an abbreviation of accessibility.
# Write a function that takes a string and turns any and all "words"
# (see below) within that string of length 4 or greater into an abbreviation, following these rules:
# A "word" is a sequence of alphabetical characters. By this definition,
# any other character like a space or hyphen (eg. "elephant-ride")
# will split up a series of letters into two words (eg. "elephant" and "ride").
# The abbreviated version of the word should have the first letter,
# then the number of removed characters, then the last letter (eg. "elephant ride" => "e6t r2e").
def abbreviate(s):
    word = ""
    sentence = []
    result = []
    for i in s:
        if i.isalpha():
            word += i
        else:
            sentence.append(word)
            sentence.append(i)
            word = ""
            continue
    if word:
        sentence.append(word)
    for i in sentence:
        if len(i) >= 4:
            result += i[0] + str(len(i)-2) + i[-1]
        else:
            result += i
    return "".join(result)

# Create a function called shortcut to remove the lowercase vowels (a, e, i, o, u ) in a given string.
def shortcut( s ):
    return ''.join([i if i not in 'aeoiu' else '' for i in s])

# Philip's just turned four and he wants to know how old he will be
# in various years in the future such as 2090 or 3044.
# His parents can't keep up calculating this so they've begged
# you to help them out by writing a programme that can answer Philip's endless questions.
# Your task is to write a function that takes two parameters:
# the year of birth and the year to count years in relation to.
# As Philip is getting more curious every day he may soon want to know how many years
# it was until he would be born, so your function needs to work with both dates in the future and in the past.
# Provide output in this format: For dates in the future:
# "You are ... year(s) old." For dates in the past: "You will be born in ... year(s)."
# If the year of birth equals the year requested return: "You were born this very year!"
# "..." are to be replaced by the number, followed and proceeded by a single space.
# Mind that you need to account for both "year" and "years", depending on the result.
def calculate_age(year_of_birth, current_year):
    return f"You are {current_year - year_of_birth} {'year' if current_year - year_of_birth == 1 else 'years'} old."\
        if year_of_birth < current_year else\
        f"You will be born in {year_of_birth - current_year}" \
        f" {'year' if year_of_birth - current_year == 1 else 'years'}." \
            if year_of_birth > current_year else 'You were born this very year!'

# Reverse every other word in a given string, then return the string.
# Throw away any leading or trailing whitespace, while ensuring there
# is exactly one space between each word. Punctuation marks should be
# treated as if they are a part of the word in this kata.
def reverse_alternate(s):
    list = s.split()
    for elem in list[1::2]:
        word = elem[::-1]
        list.insert(list.index(elem), word)
        list.remove(elem)
    return ' '.join(list)

# This is the first step to understanding FizzBuzz.
# Your inputs: a positive integer, n, greater than or equal to one.
# n is provided, you have NO CONTROL over its value.
# Your expected output is an array of positive integers from 1 to n (inclusive).
# Your job is to write an algorithm that gets you from the input to the output.
def pre_fizz(n):
    return [i for i in range(1, n + 1)]

# You'll be given a string, and have to return the sum of all characters as an int.
# The function should be able to handle all ASCII characters.
def uni_total(s):
    return sum(ord(i) for i in s)

# Complete the function that calculates the area of the red square,
# when the length of the circular arc A is given as the input. Return the result rounded to two decimals.
from math import pi

def square_area(A):
    return round((2 * A / pi) ** 2, 2)

# Write a function called sortGiftCode/sort_gift_code/SortGiftCode that accepts
# a string containing up to 26 unique alphabetical characters, and returns
# a string containing the same characters in alphabetical order.
def sort_gift_code(code):
    return "".join(sorted(code))

# Your task is to complete this Class, the Person class has been created.
# You must fill in the Constructor method to accept a name as string and an age as number,
# complete the get Info property and getInfo method/Info getter which should return johns age is 34
class Person:
    def __init__(self, name, age):
        self.info = f"{name}s age is {age}"

# Given a string of words (x), you need to return an array of the words,
# sorted alphabetically by the final character in each.
# If two words have the same last letter, they returned array should show
# them in the order they appeared in the given string.
def last(s):
    return sorted(s.split(), key=lambda x: x[-1])

# Given an array of integers , Find the maximum product obtained from multiplying 2 adjacent numbers in the array.
def adjacent_element_product(array):
    return max(a * b for a, b in zip(array, array[1:]))

# Write a small function that returns the values of an array that are not odd.
# All values in the array will be integers. Return the good values in the order they are given.
def no_odds(values):
    return [i for i in values if i % 2 == 0]

# You are given a string containing a sequence of character sequences separated by commas.
# Write a function which returns a new string containing the same character sequences except
# the first and the last ones but this time separated by spaces.
# If the input string is empty or the removal of the first
# and last items would cause the resulting string to be empty,
# return an empty value (represented as a generic value NULL in the examples below).
def array(string):
    return ' '.join(string.split(',')[1:-1]) or None

# Complete the function which returns the weekday according to the input number:
# Otherwise returns "Wrong, please enter a number between 1 and 7"
def whatday(num):
    dict = {1: 'Sunday', 2: 'Monday', 3: 'Tuesday',
            4: 'Wednesday', 5: 'Thursday', 6: 'Friday', 7: 'Saturday'}
    return dict[num] if num in dict else 'Wrong, please enter a number between 1 and 7'

# Write a function, persistence, that takes in a positive parameter num
# and returns its multiplicative persistence, which is the numbe
# r of times you must multiply the digits in num until you reach a single digit.
def persistence(n):
    count = 0
    integer = 1
    while len(str(n)) > 1:
        count += 1
        for elem in str(n):
            integer *= int(elem)
        n = integer
        integer = 1
    return count

# Create a function named (combine_names) that accepts two parameters
# (first and last name). The function should return the full name.
def combine_names(first, last):
    return first + ' ' + last

# Don Drumphet lives in a nice neighborhood,
# but one of his neighbors has started to let his house go.
# Don Drumphet wants to build a wall between his house and his neighbor’s,
# and is trying to get the neighborhood association to pay for it.
# He begins to solicit his neighbors to petition to get the association to build the wall.
# Unfortunately for Don Drumphet, he cannot read very well, has a very limited attention span,
# and can only remember two letters from each of his neighbors’ names. As he collects signatures,
# he insists that his neighbors keep truncating their names until two letters remain, and he can finally read them.
# Your code will show Full name of the neighbor and the truncated version of the name as an array.
# If the number of the characters in name is less than or equal to two,
# it will return an array containing only the name as is"
def who_is_paying(name):
    return [name,name[:2]] if len(name) > 2 else [name]

# A Tidy number is a number whose digits are in non-decreasing order.
# Task
# Given a number, Find if it is Tidy or not .
def tidyNumber(n):
    return sorted([int(i) for i in str(n)]) == [int(i) for i in str(n)]

# In John's car the GPS records every s seconds the distance travelled from an origin
# (distances are measured in an arbitrary but consistent unit). For example, below is part of a record with s = 15:
# x = [0.0, 0.19, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25]
# The sections are:
# 0.0-0.19, 0.19-0.5, 0.5-0.75, 0.75-1.0, 1.0-1.25, 1.25-1.50, 1.5-1.75, 1.75-2.0, 2.0-2.25
# We can calculate John's average hourly speed on every section and we get:
# [45.6, 74.4, 60.0, 60.0, 60.0, 60.0, 60.0, 60.0, 60.0]
# Given s and x the task is to return as an integer the *floor* of the maximum average
# speed per hour obtained on the sections of x. If x length is less than
# or equal to 1 return 0 since the car didn't move.
# Example:
# with the above data your function gps(s, x)should return 74
def gps(s, x):
    speed = []
    lenght = 0
    for elem in x:
        speed.append(3600 * (elem - lenght) / s)
        lenght = elem
    return max(speed) if len(x) > 0 else 0

# In this Kata your task will be to return the count of pairs that have consecutive numbers as follows:
def pairs(ar):
    counter = 0
    for i in range(0, len(ar)-1,2):
        if i+1 > len(ar):
            break
        elif abs(ar[i] - ar[i+1]) == 1:
            counter += 1
    return counte

# Create a function that finds the integral of the expression passed.
# In order to find the integral all you need to do is add one to the exponent (the second argument),
# and divide the coefficient (the first argument) by that new number.
# For example for 3x^2, the integral would be 1x^3: we added 1 to the exponent,
# and divided the coefficient by that new number).
def integrate(coefficient, exponent):
    return f"{int(coefficient / (exponent+1))}x^{exponent+1}"

# Given a lowercase string that has alphabetic characters only and no spaces,
# return the highest value of consonant substrings. Consonants are any letters of the alphabet except "aeiou".
# We shall assign the following values: a = 1, b = 2, c = 3, .... z = 26.
import string
def solve(s):
    streakCounter = 0
    tempCounter = 0
    streakList = []
    alphDict = dict(zip(string.ascii_lowercase, [num for num in range(1, 27, 1)]))
    for i in list(alphDict):
        if i in list('aeiou'):
            alphDict.pop(i)
        else:
            pass
    for sym in s:
        if sym in list(alphDict):
            streakCounter += 1
            tempCounter += alphDict[sym]
        else:
            if streakCounter > 0:
                streakList.append(tempCounter)
                tempCounter = 0
                streakCounter = 0
            else:
                pass
    return max(streakList)

# Given a non-negative integer n, write a function to_binary/ToBinary which returns that number in a binary format.
def to_binary(n):
    return int(bin(n)[2:])

# Strong number is the number that the sum of the factorial of its digits is equal to number itself.
# For example, 145 is strong, since 1! + 4! + 5! = 1 + 24 + 120 = 145.
# Task
# Given a number, Find if it is Strong or not and return either "STRONG!!!!" or "Not Strong !!".
from math import factorial
def strong_num(number):
    return 'STRONG!!!!' if sum(factorial(int(i)) for i in str(number)) == number else 'Not Strong !!'

# Create a class Ball. Ball objects should accept one argument for "ball type" when instantiated.
# If no arguments are given, ball objects should instantiate with a "ball type" of "regular."
class Ball(object):
  def __init__(self, type = "regular"):
    self.ball_type = type

# For this problem you must create a program that says who ate the last cookie.
# If the input is a string then "Zach" ate the cookie.
# If the input is a float or an int then "Monica" ate the cookie.
# If the input is anything else "the dog" ate the cookie.
# The way to return the statement is: "Who ate the last cookie? It was (name)!"
# Ex: Input = "hi" --> Output = "Who ate the last cookie? It was Zach!
# (The reason you return Zach is because the input is a string)
# Note: Make sure you return the correct message with correct spaces and punctuation.
# Please leave feedback for this kata. Cheers!
def cookie(x):
    if type(x) is str: return "Who ate the last cookie? It was Zach!"
    if type(x) is int or type(x) is float: return "Who ate the last cookie? It was Monica!"
    return "Who ate the last cookie? It was the dog!"

# You probably know that number 42 is "the answer to life, the universe
# and everything" according to Douglas Adams' "The Hitchhiker's Guide to the Galaxy".
# For Freud, the answer was quite different...
# In the society he lived in, people - women in particular - had to repress their
# sexual needs and desires. This was simply how the society was at the time.
# Freud then wanted to study the illnesses created by this,
# and so he digged to the root of their desires. This led to some
# of the most important psychoanalytic theories to this day, Freud being the father of psychoanalysis.
# Now, basically, when a person hears about Freud, s/he hears "sex" because for Freud,
# everything was related to, and explained by sex.
# In this kata, the function will take a string as its argument,
# and return a string with every word replaced by the explanation to everything,
# according to Freud. Note that an empty string, or no arguments, should return an empty string.
def to_freud(sentence):
    return ' '.join(['sex'] * len(sentence.split()))

# Remove the duplicates from a list of integers, keeping the last ( rightmost ) occurrence of each element.
def solve(arr):
    return list(dict.fromkeys(arr[::-1]))[::-1]

# Oh, no! The number has been mixed up with the text.
# Your goal is to retrieve the number from the text, can you return the number back to its original state?
# Task
# Your task is to return a number from a string.
def filter_string(string):
    return int(''.join(i for i in string if i.isdigit()))

# Given an array/list [] of integers , Find the product of the k maximal numbers.
# Notes
# Array/list size is at least 3 .
# Array/list's numbers Will be mixture of positives , negatives and zeros
# Repetition of numbers in the array/list could occur.
def max_product(lst, n_largest_elements):
    mul = 1
    for n in sorted(lst, reverse=True)[:n_largest_elements]:
        mul *= n
    return mul

# To complete this Kata you need to make a function multiplyAll/multiply_all which takes
# an array of integers as an argument. This function must return another function,
# which takes a single integer as an argument and returns a new array.
# The returned array should consist of each of the elements from the first array multiplied by the integer.
def multiply_all(arr):
    def multiply(num):
        return [num * elem for elem in arr]
    return multiply

# This series of katas will introduce you to basics of doing geometry with computers.
# Point objects have x and y attributes (X and Y in C#) attributes.
# Write a function calculating distance between Point a and Point b.
def distance_between_points(a, b):
    return ((b.x - a.x) ** 2 + (b.y - a.y) ** 2) ** 0.5

# Your task is to find the nearest square number, nearest_sq(n), of a positive integer n.
import math
def nearest_sq(n):
    return round(math.sqrt(n))**2

# Color Ghost
# Create a class Ghost
# Ghost objects are instantiated without any arguments.
# Ghost objects are given a random color attribute of "white" or "yellow" or "purple" or "red" when instantiated
import random
class Ghost(object):
  def __init__(self):
    self.color = random.choice(["white", "yellow", "purple", "red"])

# You are creating a text-based terminal version of your favorite board game.
# In the board game, each turn has six steps that must happen in this order:
# roll the dice, move, combat, get coins, buy more health, and print status.
from preloaded import *
health, position, coins = 100, 0, 0
def main(): pass
log = 'roll_dice move combat get_coins buy_health print_status'.split()

# Input:
# a string strng
# an array of strings arr
# Output of function contain_all_rots(strng, arr) (or containAllRots or contain-all-rots):
# a boolean true if all rotations of strng are included in arr
# false otherwise
def contain_all_rots(strng, arr):
    rotate = strng
    if not len(arr) or not strng:
        return True
    for index in range(len(strng)):
        if rotate  not in arr:
            return False
        first_letter = rotate[0]
        rotate = rotate[1:]
        rotate += first_letter
    return True

# Given a string, turn each character into its ASCII character code
# and join them together to create a number - let's call this number total1:
# 'ABC' --> 'A' = 65, 'B' = 66, 'C' = 67 --> 656667
# Then replace any incidence of the number 7 with the number 1, and call this number 'total2':
# total1 = 656667
#               ^
# total2 = 656661
#               ^
# Then return the difference between the sum of the digits in total1 and total2:
def calc(x):
    word= ''.join([str(ord(i)) for i in x])
    word1 = ''.join([str(ord(i)) for i in x]).replace('7', '1')
    return sum(int(i) for i in word) - sum(int(i) for i in word1)

# An element is leader if it is greater than The Sum all the elements to its right side.
# Task
# Given an array/list [] of integers , Find all the LEADERS in the array.
def array_leaders(numbers):
    output = []
    for i in range(0, len(numbers)):
        if numbers[i] > sum(numbers[i+1:]):
            output.append(numbers[i])
    return output

# Our fruit guy has a bag of fruit (represented as an array of strings)
# where some fruits are rotten. He wants to replace all the rotten pieces of fruit with fresh ones.
# For example, given ["apple","rottenBanana","apple"] the replaced array should be ["apple","banana","apple"].
# Your task is to implement a method that accepts an array of strings containing fruits
# should returns an array of strings where all the rotten fruits are replaced by good ones.
# Notes
# If the array is null/nil/None or empty you should return empty array ([]).
# The rotten fruit name will be in this camelcase (rottenFruit).
# The returned array should be in lowercase.
def remove_rotten(bag_of_fruits):
    try:
        return [i.replace('rotten', '').lower() if 'rotten' in i else i.lower() for i in bag_of_fruits]
    except:
        return []

# You're on your way to the market when you hear beautiful music coming from a nearby street performer.
# The notes come together like you wouln't believe as the musician puts together patterns of tunes.
# As you wonder what kind of algorithm you could use to shift octaves by
# 8 pitches or something silly like that, it dawns on you that you have been watching
# the musician for some 10 odd minutes. You ask, "how much do people normally
# tip for something like this?" The artist looks up. "It's always gonna be about tree fiddy."
# It was then that you realize the musician was a 400 foot tall beast from the paleolithic era!
# The Loch Ness Monster almost tricked you!
# There are only 2 guaranteed ways to tell if you are speaking to The Loch Ness Monster:
# A) it is a 400 foot tall beast from the paleolithic era; B) it will ask you for tree fiddy.
# Since Nessie is a master of disguise, the only way accurately tell is to look for the phrase
# "tree fiddy". Since you are tired of being grifted by this monster,
# the time has come to code a solution for finding The Loch Ness Monster.
# Note that the phrase can also be written as "3.50" or "three fifty".
def is_lock_ness_monster(string):
    return True in [i in string for i in ['tree fiddy', '3.50', 'three fifty']]

# You task is to implement an simple interpreter for the notorious esoteric language HQ9+
# that will work for a single character input:
# If the input is 'H', return 'Hello World!'
# If the input is 'Q', return the input
# If the input is '9', return the full lyrics of 99 Bottles of Beer. It should be formatted like this:
LINES = "{0} of beer on the wall, {0} of beer.\nTake one down and pass it around, {1} of beer on the wall."
SONG = '\n'.join( LINES.format("{} bottles".format(n), "{} bottle".format(n-1)+"s"*(n!=2)) for n in range(99,1,-1) )
SONG += """
1 bottle of beer on the wall, 1 bottle of beer.
Take one down and pass it around, no more bottles of beer on the wall.
No more bottles of beer on the wall, no more bottles of beer.
Go to the store and buy some more, 99 bottles of beer on the wall."""
def HQ9(code):
    return {'H': 'Hello World!', 'Q': 'Q', '9': SONG}.get(code, None)
# Write a function that can return the smallest value of an array or the index of that value.
# The function's 2nd parameter will tell whether it should return the value or the index.
# Assume the first parameter will always be an array filled with at least 1 number and no duplicates.
# Assume the second parameter will be a string holding one of two values: 'value' and 'index'.
def find_smallest(numbers,to_return):
    return numbers.index(min(numbers)) if to_return == 'index' else min(numbers)

# There's a "3 for 2" (or "2+1" if you like) offer on mangoes.
# For a given quantity and price (per mango), calculate the total cost of the mangoes.
def mango(quantity, price):
    return (quantity - quantity // 3) * price

# Your colleagues have been looking over you shoulder.
# When you should have been doing your boring real job,
# you've been using the work computers to smash in endless hours of codewars.
# In a team meeting, a terrible, awful person declares to the group that you aren't working.
# You're in trouble. You quickly have to gauge the feeling in the room to decide whether
# or not you should gather your things and leave.
# Given an object (meet) containing team member names as keys, and their happiness rating out
# of 10 as the value, you need to assess the overall happiness rating of the group.
# If <= 5, return 'Get Out Now!'. Else return 'Nice Work Champ!'.
# Happiness rating will be total score / number of people in the room.
# Note that your boss is in the room (boss), their score is worth double it's face value
# (but they are still just one person!).
def outed(meet, boss):
    return 'Get Out Now!' if (sum(meet.values()) + meet[boss] ) / len(meet) <= 5 else 'Nice Work Champ!'

# The number n is Evil if it has an even number of 1's in its binary representation.
# The first few Evil numbers: 3, 5, 6, 9, 10, 12, 15, 17, 18, 20
# The number n is Odious if it has an odd number of 1's in its binary representation.
# The first few Odious numbers: 1, 2, 4, 7, 8, 11, 13, 14, 16, 19
# You have to write a function that determine if a number is Evil of Odious,
# function should return "It's Evil!" in case of evil number and "It's Odious!" in case of odious number.
def evil(n):
    return "It's Evil!" if  bin(n).count('1') % 2 == 0 else "It's Odious!"

# Every now and then people in the office moves teams or departments.
# Depending what people are doing with their time they can become more or less boring.
# Time to assess the current team.
# You will be provided with an object(staff) containing the staff names as keys,
# and the department they work in as values.
# Each department has a different boredom assessment score, as follows:
def boredom(staff):
    dict_score = {
        'accounts': 1,
        'finance': 2,
        'canteen': 10,
        'regulation': 3,
        'trading': 6,
        'change': 6,
        'IS': 8,
        'retail': 5,
        'cleaning': 4,
        'pissing about': 25
    }
    boredom_score = 0
    for v in staff.values():
        if v in dict_score:
            boredom_score += dict_score.get(v)
    return 'kill me now' if boredom_score <= 80 else 'i can handle this' if 80 < boredom_score < 100 else 'party time!!'

# You have access to the ship "draft" and "crew".
# "Draft" is the total ship weight and "crew" is the number of humans on the ship.
# Each crew member adds 1.5 units to the ship draft. If after removing the weight
# of the crew, the draft is still more than 20, then the ship is worth looting.
# Any ship weighing that much must have a lot of booty!
class Ship:
    def __init__(self, draft, crew):
        self.draft = draft
        self.crew = crew
    # Your code here
    def is_worth_it(self):
        return self.draft - self.crew * 1.5 > 20

# In this kata you will have to write a function that takes litres and price_per_litre (in dollar) as arguments.
# Purchases of 2 or more litres get a discount of 5 cents per litre, purchases of 4 or more litres get a discount
# of 10 cents per litre, and so on every two litres,
# up to a maximum discount of 25 cents per litre.
# But total discount per litre cannot be more than 25 cents.
# Return the total cost rounded to 2 decimal places.
# Also you can guess that there will not be negative or non-numeric inputs.
# Good Luck!
def fuel_price(litres, price_per_liter):
    discount = int(min(litres, 10)/2) * 5 / 100
    return round((price_per_liter - discount) * litres, 2)

# Given a string made up of letters a, b, and/or c, switch the position
# of letters a and b (change a to b and vice versa). Leave any incidence of c untouched.
def switcheroo(string):
    return string.replace('a', '-').replace('b', 'a').replace('-', 'b')

# ASC Week 1 Challenge 4 (Medium #1)
# Write a function that converts any sentence into a V A P O R W A V E sentence.
# a V A P O R W A V E sentence converts all the letters into uppercase,
# and adds 2 spaces between each letter (or special character)
# to create this V A P O R W A V E effect.
# Note that spaces should be ignored in this case.
def vaporcode(s):
    return '  '.join(i.upper() for i in s.replace(' ', ''))

# Create a method all which takes two params:
# a sequence
# a function (function pointer in C)
# and returns true if the function in the params returns true for every element in the sequence.
# Otherwise, it should return false. If the sequence is empty,
# it should return true, since technically nothing failed the test.
def _all(seq, fun):
    return all(fun(i) for i in seq)

# Write a function that calculates the original product price, without VAT.
def excluding_vat_price(price):
    return round(price - price / 115 * 15, 2) if price else -1

# Given an unsorted array of 3 positive integers [ n1, n2, n3 ],
# determine if it is possible to form a Pythagorean Triple using those 3 integers.
# A Pythagorean Triple consists of arranging 3 integers, such that:
# a2 + b2 = c2
def pythagorean_triple(integers):
    return sorted(integers)[0]**2 + sorted(integers)[1]**2 == sorted(integers)[2]**2

# Some new cashiers started to work at your restaurant.
# They are good at taking orders, but they don't know how to capitalize words, or use a space bar!
# All the orders they create look something like this:
# "milkshakepizzachickenfriescokeburgerpizzasandwichmilkshakepizza"
# The kitchen staff are threatening to quit, because of how difficult it is to read the orders.
# Their preference is to get the orders as a nice clean string with spaces and capitals like so:
# "Burger Fries Chicken Pizza Pizza Pizza Sandwich Milkshake Milkshake Coke"
# The kitchen staff expect the items to be in the same order as they appear in the menu.
# The menu items are fairly simple, there is no overlap in the names of the items:
def get_order(order):
    menu = ["Burger", "Fries", "Chicken", "Pizza", "Sandwich", "Onionrings", "Milkshake", "Coke"]
    return "".join([(i + " ") * order.count(i.lower()) for i in menu if i.lower() in order]).rstrip()

# Write a function reverse which reverses a list (or in clojure's case, any list-like data structure)
# (the dedicated builtin(s) functionalities are deactivated)
def reverse(lst):
    list1 = list()
    for elem in lst:
        list1.insert(0, elem)
    return list1

# According to the creation myths of the Abrahamic religions,
# Adam and Eve were the first Humans to wander the Earth.
# You have to do God's job. The creation method must return an array of length 2
# containing objects (representing Adam and Eve). The first object in the array should be
# an instance of the class Man. The second should be an instance of the class Woman.
# Both objects have to be subclasses of Human. Your job is to implement the Human, Man and Woman classes.
def God():
    return [Man(), Woman()]
class Human(object):
    pass
class Man(Human):
    pass
class Woman(Human):
    pass

# Make multiple functions that will return the sum,
# difference, modulus, product, quotient, and the exponent respectively.
# Please use the following function names:
def add(a,b):
  return a + b
def multiply(a,b):
  return a * b
def divide(a,b):
  return a / b
def mod(a,b):
  return a % b
def exponent(a,b):
  return a ** b
def subt(a,b):
  return a - b

# Some really funny web dev gave you a sequence of numbers from his API response as an sequence of strings!
# You need to cast the whole array to the correct type.
# Create the function that takes as a parameter a sequence of numbers represented
# as strings and outputs a sequence of numbers.
# ie:["1", "2", "3"] to [1, 2, 3]
# Note that you can receive floats as well.
def to_float_array(arr):
    return list(map(float, arr))

# Given a string made of digits [0-9], return a string where
# each digit is repeated a number of times equals to its value.
def explode(s):
    return ''.join(c * int(c) for c in s)

# Disarium number is the number that The sum of its digits powered
# with their respective positions is equal to the number itself.
# Task
# Given a number, Find if it is Disarium or not .
def disarium_number(number):
    return 'Disarium !!' if sum(int(i)**(int(j) + 1) for j, i in enumerate(str(number))) == number else 'Not !!'

# You will be given a string (x) featuring a cat 'C' and a mouse 'm'.
# The rest of the string will be made up of '.'.
# You need to find out if the cat can catch the mouse from it's current position.
# The cat can jump over three characters. So:
# C.....m returns 'Escaped!' <-- more than three characters between
# C...m returns 'Caught!' <-- as there are three characters between the two, the cat can jump.
def cat_mouse(x):
    return 'Escaped!' if x.count('.') > 3 else 'Caught!'

# Modify the kebabize function so that it converts a camel case string into a kebab case.
import re
def kebabize(string):
    return '-'.join(re.split('(?<=.)(?=[A-Z])', re.sub(r'[0-9]+', '', string))).lower()

# Given a string and an array of integers representing indices, capitalize all letters at the given indices.
# For example:
# capitalize("abcdef",[1,2,5]) = "aBCdeF"
# capitalize("abcdef",[1,2,5,100]) = "aBCdeF". There is no index 100.
# The input will be a lowercase string with no spaces and an array of digits.
# Good luck!
def capitalize(s,ind):
    list = [j for j in s]
    for i in ind:
        if i <= len(list):
            list[i] = list[i].upper()
    return ''.join(list)

# John has invited some friends. His list is:

# s = "Fred:Corwill;Wilfred:Corwill;Barney:Tornbull;Betty:Tornbull;Bjon:Tornbull;Raphael:Corwill;Alfred:Corwill";
# Could you make a program that
# makes this string uppercase
# gives it sorted in alphabetical order by last name.
# When the last names are the same, sort them by first name.
# Last name and first name of a guest come in the result between parentheses separated by a comma.
# So the result of function meeting(s) will be:
# "(CORWILL, ALFRED)(CORWILL, FRED)(CORWILL, RAPHAEL)
# (CORWILL, WILFRED)(TORNBULL, BARNEY)(TORNBULL, BETTY)(TORNBULL, BJON)"
def meeting(s):
    return ''.join(sorted('({1}, {0})'.format(*(x.split(':'))) for x in s.upper().split(';')))

# You probably know the "like" system from Facebook and other pages. People can "like" blog posts,
# pictures or other items. We want to create the text that should be displayed next to such an item.
# Implement the function which takes an array containing the names of people that like an item.
# It must return the display text as shown in the examples:
def likes(names):
    if len(names) >= 4:
        return ', '.join(names[:2]) + f" and {len(names[2:])} others like this"
    elif 1 < len(names) < 4:
        return ', '.join(names[:-1]) + f" and {names[-1]} like this"
    return f"{'no one' if len(names) == 0 else names[0]} likes this"

# Write a function called calculate that takes 3 values.
# The first and third values are numbers. The second value is a character.
# If the character is "+" , "-", "*", or "/", the function will
# return the result of the corresponding mathematical function on the two numbers.
# If the string is not one of the specified characters, the function should return
# null (throw an ArgumentException in C#).
# Keep in mind, you cannot divide by zero. If an attempt to divide by zero is made,
# return null (throw an ArgumentException in C#)/(None in Python).
def calculate(num1, operation, num2):
    dict = {'+': num1 + num2, '-': num1 - num2,
           '*': num1 * num2, '/': num1 / num2 if num1 !=0 and num2 !=0 else None}
    return dict[operation] if operation in dict else None

# Write a method that takes one argument as name
# and then greets that name, capitalized and ends with an exclamation point.
def greet(name):
    return f'Hello {name.title()}!'

# In this first kata in the series, you need to define a Hero prototype
# to be used in a terminal game. The hero should have the following attributes:
class Hero(object):
    def __init__(self, name='Hero', position='00', health=100, damage=5, experience=0):
        self.name = name
        self.position = position
        self.health = health
        self.damage = damage
        self.experience = experience

# Add the value "codewars" to the websites array.
# After your code executes the websites array should == ["codewars"]
# The websites array has already been defined for you using the following code:
websites.append("codewars")

# Friday 13th or Black Friday is considered as unlucky day. Calculate how many unlucky days are in the given year.
# Find the number of Friday 13th in the given year.
import calendar
def unlucky_days(year):
	return sum(calendar.weekday(year, m, 13) == 4 for m in range(1, 13))

# There are 32 letters in the Polish alphabet: 9 vowels and 23 consonants.
def correct_polish_letters(st):
    dict = {'ą':'a', 'ć':'c', 'ę':'e', 'ł':'l', 'ń':'n', 'ó':'o', 'ś':'s', 'ź':'z', 'ż':'z'}
    return ''.join(dict[i] if i in dict else i for i in st)

# Your task is to write a function toLeetSpeak that converts a regular english sentence to Leetspeak.
#More about LeetSpeak You can read at wiki -> https://en.wikipedia.org/wiki/Leet
# Consider only uppercase letters (no lowercase letters, no numbers) and spaces.
def to_leet_speak(str):
    dict = {'A' : '@',  'B' : '8',  'C' : '(',  'D' : 'D',  'E' : '3',  'F' : 'F',  'G' : '6',
            'H' : '#',  'I' : '!',  'J' : 'J', 'K' : 'K',  'L' : '1',  'M' : 'M',
            'N' : 'N',  'O': '0',  'P' : 'P',  'Q' : 'Q',  'R' : 'R',  'S' : '$',
            'T' : '7',  'U' : 'U',  'V' : 'V',  'W' : 'W',  'X' : 'X',  'Y' : 'Y',  'Z' : '2', ' ': ' '}
    return ''.join(dict[i] for i in str)

# Given a string, write a function that returns the string
# with a question mark ("?") appends to the end, unless the original
# string ends with a question mark, in which case, returns the original string.
def ensure_question(s):
    return s if s.endswith('?') else s + '?'

# Given a string s. You have to return another string such that
# even-indexed and odd-indexed characters of s are grouped and groups are space-separated (see sample below)
def sort_my_string(s):
    return s[::2] + ' ' + s[1::2]

# Given an input of an array of digits, return the array with each digit incremented
# by its position in the array: the first digit will be incremented by 1,
# the second digit by 2, etc. Make sure to start counting your positions from 1 ( and not 0 ).
# Your result can only contain single digit numbers, so if adding a digit
# with its position gives you a multiple-digit number, only the last digit of the number should be returned.
# Notes:
# return an empty array if your array is empty
# arrays will only contain numbers so don't worry about checking that
def incrementer(nums):
    return [i+j+1 if i+j+1<10 else int(str(i+j+1)[-1]) for i,j in enumerate(nums)]

# Given a string "abc" and assuming that each letter in the string
# has a value equal to its position in the alphabet, our string
# will have a value of 1 + 2 + 3 = 6. This means that: a = 1, b = 2, c = 3 ....z = 26.
# You will be given a list of strings and your task will be to return the values of the
# strings as explained above multiplied by the position of that string in the list.
# For our purpose, position begins with 1.
# nameValue ["abc","abc abc"] should return [6,24] because of [ 6 * 1, 12 * 2 ]. Note how spaces are ignored.
# "abc" has a value of 6, while "abc abc" has a value of 12. Now, the value at position 1 is multiplied
# by 1 while the value at position 2 is multiplied by 2.
# Input will only contain lowercase characters and spaces.
# Good luck!
def name_value(my_list):
    return [sum(ord(k)-96 if k.isalpha() else 0 for k in j) * (i+1) for i, j in enumerate(my_list)]

# Write function alternateCase which switch every letter in string
# from upper to lower and from lower to upper. E.g: Hello World -> hELLO wORLD
def alternateCase(s):
    return s.swapcase()

# Write a function that accepts two arguments and generates a sequence
# containing the integers from the first argument to the second inclusive.
# Input
# Pair of integers greater than or equal to 0. The second argument will always be greater than or equal to the first.
def generate_integers(m, n):
    return [i for i in range(m,n+1)]

# Write a function
# vowel_2_index
# that takes in a string and replaces all the vowels [a,e,i,o,u]
# with their respective positions within that string.
# E.g:
def vowel_2_index(string):
    return ''.join(str(i+1) if j.lower() in 'aeiou' else j for i, j in enumerate(string))

# A variation of determining leap years, assuming only integers are used and years can be negative and positive.
# Write a function which will return the days in the year and the year entered in a string. For example:
import calendar
def year_days(year):
    return f"{year} has {366 if calendar.isleap(abs(year)) else 365} days"

# Born a misinterpretation of this kata, your task here is pretty simple:
# given an array of values and an amount of beggars, you are supposed to
# return an array with the sum of what each beggar brings home, assuming they
# all take regular turns, from the first to the last.
# For example: [1,2,3,4,5] for 2 beggars will return a result of [9,6],
# as the first one takes [1,3,5], the second collects [2,4].
# The same array with 3 beggars would have in turn have produced a better
# out come for the second beggar: [5,7,3], as they will respectively take [1,4], [2,5] and [3].
# Also note that not all beggars have to take the same amount of "offers", meaning that the length
# of the array is not necessarily a multiple of n; length can be even shorter,
# in which case the last beggars will of course take nothing (0).
# Note: in case you don't get why this kata is about English beggars,
# then you are not familiar on how religiously queues are taken in the kingdom ;)
# Note 2: do not modify the input array.
def beggars(values, n):
    return [sum(values[i::n]) for i in range(n)]

# Mothers arranged a dance party for the children in school. At that party,
# there are only mothers and their children. All are having great fun on the
# dance floor when suddenly all the lights went out.
# It's a dark night and no one can see each other.
# But you were flying nearby and you can see in the dark and have ability to teleport people anywhere you want.
# Legend:
# -Uppercase letters stands for mothers, lowercase stand for their children, i.e. "A" mother's children are "aaaa".
# -Function input: String contains only letters, uppercase letters are unique.
# Task:
# Place all people in alphabetical order where Mothers are followed by their children, i.e. "aAbaBb" => "AaaBbb".
def find_children(dancing_brigade):
    list = sorted(set([i.lower() for i in dancing_brigade]))
    return ''.join(i.upper() + i * dancing_brigade.count(i) for i in list)

# Implement a function, multiples(m, n), which returns
# an array of the first m multiples of the real number n. Assume that m is a positive integer.
def multiples(m, n):
    return [i * n for i in range(1, m+1)]

# Jumping number is the number that All adjacent digits in it differ by 1.
# Task
# Given a number, Find if it is Jumping or not .
def jumping_number(number):
    number = list(str(number))
    for i in range(0, len(number)-1):
        if abs(int(number[i+1])-int(number[i])) != 1:
            return 'Not!!'
    return 'Jumping!!'

# In this Kata you are expected to find the coefficients
# of quadratic equation of the given two roots (x1 and x2).
# Equation will be the form of ax^2 + bx + c = 0
# Return type is a Vector (tuple in Rust, Array in Ruby)
# containing coefficients of the equations in the order (a, b, c).
# Since there are infinitely many solutions to this problem, we fix a = 1.
# Remember, the roots can be written like (x-x1) * (x-x2) = 0
def quadratic(x1, x2):
    return (1, -(x1 + x2), x1 * x2)

# Find the difference between the sum of the squares of the first n natural
# numbers (1 <= n <= 100) and the square of their sum.
# Example
# For example, when n = 10:
# The square of the sum of the numbers is:
# (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10)2 = 552 = 3025
# The sum of the squares of the numbers is:
# 12 + 22 + 32 + 42 + 52 + 62 + 72 + 82 + 92 + 102 = 385
def difference_of_squares(n):
    return sum([i for i in range(1,n+1)])**2 - sum([i**2 for i in range(1, n+1)])

# You are creating an "Escape the room" game.
# The first step is to create a hash table called rooms that contains
# all of the rooms of the game. There should be at least 3 rooms inside it,
# each being a hash table with at least three properties (e.g. name, description, completed).
rooms = {
    'room1': {
    'name': 'Peter', 'description': 'python', 'completed': False },
    'room2': {
    'name': 'Ivan', 'description': 'js', 'completed': True },
    'room3': {
    'name': 'Pasha', 'description': 'golang', 'completed': True }
        }

# This Kata is intended as a small challenge for my students
# All Star Code Challenge #22
# Create a function that takes an integer argument of seconds
# and converts the value into a string describing how many hours and minutes comprise that many seconds.
# Any remaining seconds left over are ignored.
# Note:
# The string output needs to be in the specific form - "X hour(s) and X minute(s)"
def to_time(seconds):
    return f'{seconds//3600} hour(s) and {(seconds//60)%60} minute(s)'

# Write a function to get the first element(s) of a sequence.
# Passing a parameter n (default=1) will return the first n element(s) of the sequence.
# If n == 0 return an empty sequence []
def first(seq, n=1):
    return seq[:n] if seq else []

# Have you heard about the myth that if you fold a paper enough times, you can reach the moon with it?
# Sure you have, but exactly how many? Maybe it's time to write a program to figure it out.
# You know that a piece of paper has a thickness of 0.0001m. Given distance in units of meters,
# calculate how many times you have to fold the paper to make the paper reach this distance.
# (If you're not familiar with the concept of folding a paper: Each fold doubles its total thickness.)
# Note: Of course you can't do half a fold. You should know what this means ;P
# Also, if somebody is giving you a negative distance, it's clearly bogus
# and you should yell at them by returning null (or whatever equivalent in your language).
# In Shell please return None. In C and COBOL please return -1.
def fold_to(distance):
    if distance < 0:
        return None
    count = 0
    paper = 0.0001
    while paper < distance:
        count += 1
        paper = paper * 2
    return count

# We need to write some code to return the original price of a product,
# the return type must be of type decimal and the number must be rounded to two decimal places.
# We will be given the sale price (discounted price), and the sale percentage,
# our job is to figure out the original price.
def discover_original_price(discounted_price, sale_percentage):
    return round(discounted_price / (100 - sale_percentage) * 100, 2)

# Compare two strings by comparing the sum of their values (ASCII character code).
# For comparing treat all letters as UpperCase
# null/NULL/Nil/None should be treated as empty strings
# If the string contains other characters than letters, treat the whole string as it would be empty
# Your method should return true, if the strings are equal and false if they are not equal.
def compare(s1,s2):
    if not s1 and not s2:
        return True
    if any(x for x in s1 if not x.isalpha()):
        s1 = ''
    if any(x for x in s2 if not x.isalpha()):
        s2 = ''
    return sum(ord(x.upper()) for x in s1) == sum(ord(x.upper()) for x in s2)

# This function takes two numbers as parameters, the first number
# being the coefficient, and the second number being the exponent.
# Your function should multiply the two numbers, and then subtract 1 from the exponent.
# Then, it has to print out an expression (like 28x^7). "^1" should not be truncated when exponent = 2.
def derive(coefficient, exponent):
    return f"{coefficient*exponent}x^{exponent-1 if exponent >2 else exponent}"

# Consider the word "abode". We can see that the letter a is in position 1
# and b is in position 2. In the alphabet, a and b are also in positions 1 and 2.
# Notice also that d and e in abode occupy the positions they would occupy in the alphabet,
# which are positions 4 and 5.
# Given an array of words, return an array of the number of letters that occupy their
# positions in the alphabet for each word.
def solve(arr):
    output = []
    for str in arr:
        str = list(map(lambda x: ord(x.lower())-96, list(str)))
        str = list(map(lambda x: x[0] == x[1], zip(str, range(1,len(str)+1))))
        output.append(str.count(True))
    return output

# Find the length of the longest substring in the given string s that is the same in reverse.
# As an example, if the input was “I like racecars that go fast”, the substring (racecar) length would be 7.
# If the length of the input string is 0, the return value must be 0.
def longest_palindrome (s):
    if(len(s) == 0):
        return 0
    results = set()
    string_length = len(s)
    for i, char in enumerate(s):
        start, end = i-1, i+1
        while start >=0 and end < string_length and s[start] == s[end]:
            results.add(s[start:end+1])
            start -= 1
            end += 1
        start, end = i, i + 1
        while start >= 0 and end < string_length and s[start] == s[end]:
            results.add(s[start:end+1])
            start -= 1
            end += 1
    lst = sorted(list(results), key=len)
    if(len(lst) == 0):
        return 1
    else:
        return len(lst[-1])

# Given a string, return a new string that has transformed based on the input:
# Change case of every character, ie. lower case to upper case, upper case to lower case.
# Reverse the order of words from the input.
# Note: You will have to handle multiple spaces, and leading/trailing spaces.
def string_transformer(s):
    return ' '.join(s.swapcase().split(' ')[::-1])

# In this Kata, you will be given two strings a and b
# and your task will be to return the characters that are not common in the two strings.
def solve(a,b):
    return ''.join(i if i not in b else '' for i in a) + ''.join(i if i not in a else '' for i in b)
#set(a)^(set(b))

# Create a method sayHello/say_hello/SayHello that takes as input a name, city,
# and state to welcome a person. Note that name will be an array consisting of one
# or more values that should be joined together with one space between each,
# and the length of the name array in test cases will vary.
def say_hello(name, city, state):
    return f"Hello, {' '.join(i for i in name)}! Welcome to {city}, {state}!"

# A sequence or a series, in mathematics, is a string of objects, like numbers,
# that follow a particular pattern. The individual elements in a sequence are called terms.
# A simple example is 3, 6, 9, 12, 15, 18, 21, ..., where the pattern is: "add 3 to the previous term".
# In this kata, we will be using a more complicated sequence: 0, 1, 3, 6, 10, 15, 21, 28,
# ... This sequence is generated with the pattern: "the nth term is the sum of numbers from 0 to n, inclusive".
def sum_of_n(n):
    if n < 0:
        return sorted([sum(x for x in range(i,1)) for i in range(n, 1)])[::-1]
    return [sum([x for x in range(i+1)]) for i in range(n+1)]

# Wilson primes satisfy the following condition. Let P represent a prime number.
# Then,
# ((P-1)! + 1) / (P * P)
# should give a whole number.
# Your task is to create a function that returns true if the given number is a Wilson prime.
def am_i_wilson(n):
    list = [5, 13, 563, 5971, 558771, 1964215, 8121909,
            12326713, 23025711, 26921605, 341569806, 399292158]
    return n in list

# This kata is about converting numbers to their binary or hexadecimal representation:
# If a number is even, convert it to binary.
# If a number is odd, convert it to hex.
# Numbers will be positive. The hexadecimal string should be lowercased.
def evens_and_odds(n):
    return bin(n)[2:] if n%2 == 0 else hex(n)[2:]

# Given an array/list [] of integers ,
# Find The maximum difference between the successive elements in its sorted form.
# Notes
# Array/list size is at least 3 .
# Array/list's numbers Will be mixture of positives and negatives also zeros_
# Repetition of numbers in the array/list could occur.
# The Maximum Gap is computed Regardless the sign.
import numpy as np
def max_gap(numbers):
    numbers = np.array(sorted(numbers))
    return np.max(numbers[1:]-numbers[:-1])

# Welcome to the Codewars Bar!
# Codewars Bar recommends you drink 1 glass of water per standard drink so you're not hungover tomorrow morning.
# Your fellow coders have bought you several drinks tonight in the form of a string.
# Return a string suggesting how many glasses of water you should drink to not be hungover.
def hydrate(drink_string):
    s = sum([int(i) if i.isdigit() else 0 for i in drink_string])
    return f"{s} {'glass' if s == 1 else 'glasses'} of water"

# Every Friday and Saturday night, farmer counts amount of sheep returned back to his farm
# (sheep returned on Friday stay and don't leave for a weekend).
# Sheep return in groups each of the days -> you will be given two arrays
# with these numbers (one for Friday and one for Saturday night).
# Entries are always positive ints, higher than zero.
# Farmer knows the total amount of sheep, this is a third parameter.
# You need to return the amount of sheep lost (not returned to the farm) after final sheep counting on Saturday.
def lost_sheep(friday,saturday,total):
    return total - sum(friday + saturday)

# In some scripting languages like PHP, there exists a logical operator (e.g. &&, ||, and, or, etc.)
# called the "Exclusive Or" (hence the name of this Kata). The exclusive or evaluates two booleans.
# It then returns true if exactly one of the two expressions are true, false otherwise.
# Since we cannot define keywords in Javascript (well, at least I don't know how to do it),
# your task is to define a function xor(a, b) where a and b are the two expressions to be evaluated.
# Your xor function should have the behaviour described above,
# returning true if exactly one of the two expressions evaluate to true, false otherwise.
def xor(a,b):
    return a != b

# Create a function args_count, that returns the count of passed arguments
def args_count(*args, **kwargs):
    return len(args) + len(kwargs)

# Remove all exclamation marks from sentence but ensure a exclamation
# mark at the end of string. For a beginner kata, you can assume that the
# input data is always a non empty string, no need to verify it.
def remove(s):
    return s.replace("!", "") + "!"

# Two red beads are placed between every two blue beads.
# There are N blue beads. After looking at the arrangement below work out the number of red beads.
def count_red_beads(n):
    return 0 if n < 2 else n*2-2

# A trick I learned in elementary school to determine whether
# or not a number was divisible by three is to add all of the integers
# in the number together and to divide the resulting sum by three.
# If there is no remainder from dividing the sum by three, then the original number is divisible by three as well.
# Given a series of digits as a string, determine if the number represented by the string is divisible by three.
def divisible_by_three(st):
    s = sum(int(i) for i in st)
    while s != 0:
        s = s-3
        if s < 0:
            return False
    return True

# Teach snoopy and scooby doo how to bark using object methods. Currently only snoopy can bark and not scooby doo.
class Dog():
    def __init__(self, breed):
        self.breed = breed
snoopy = Dog("Beagle")
snoopy.bark = lambda: "Woof"
scoobydoo = Dog("Great Dane")
scoobydoo.bark = lambda: 'Woof'

# You are given a method called main, make it print the line Hello World!,
# (yes, that includes a new line character at the end) and don't return anything
# Note that for some languages, the function main is the entry point of the program.
class Solution:
    def main(self, name=''):
        print('Hello World!')

# Write function potatoes with
# int parameter p0 - initial percent of water-
# int parameter w0 - initial weight -
# int parameter p1 - final percent of water -
# potatoesshould return the final weight coming out of the oven w1 truncated as an int.
def potatoes(p0, w0, p1):
    return w0 * (100 - p0) // (100 - p1)

# Haskell has some useful functions for dealing with lists:
# $ ghci
# GHCi, version 7.6.3: http://www.haskell.org/ghc/  :? for help
# λ head [1,2,3,4,5]
# 1
# λ tail [1,2,3,4,5]
# [2,3,4,5]
# λ init [1,2,3,4,5]
# [1,2,3,4]
# λ last [1,2,3,4,5]
# 5
# Your job is to implement these functions in your given language.
# Make sure it doesn't edit the array; that would cause problems! Here's a cheat sheet:
def head(lst):
    return lst[0]
def tail(lst):
    return lst[1:]
def init(lst):
    return lst[:-1]
def last(lst):
    return lst[-1]

# Your job at E-Corp is both boring and difficult. It isn't made any easier by the fact
# that everyone constantly wants to have a meeting with you, and that the meeting rooms are always taken!
# In this kata, you will be given an array. Each value represents a meeting room. Your job?
# Find the first empty one and return its index (N.B. There may be more than one empty room in some test cases).
def meeting(rooms):
    return rooms.index("O") if "O" in rooms else "None available!"

# You and a group of friends are earning some extra money in the school holidays
# by re-painting the numbers on people's letterboxes for a small fee.
# Since there are 10 of you in the group each person just concentrates on painting one digit!
# For example, somebody will paint only the 1's, somebody else will paint only the 2's and so on...
# But at the end of the day you realise not everybody did the same amount of work.
# To avoid any fights you need to distribute the money fairly. That's where this Kata comes in.
# Kata Task
# Given the start and end letterbox numbers, write a method to return the frequency of all 10 digits painted.
def paint_letterboxes(start, finish):
    squad = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    for i in range(start,finish+1):
        while i != 0:
            squad[i % 10]+=1
            i //= 10
    return squad

# Imagine you are creating a game where the user has to guess the correct number.
# But there is a limit of how many guesses the user can do.
# If the user tries to guess more than the limit, the function should throw an error.
# If the user guess is right it should return true.
# If the user guess is wrong it should return false and lose a life.
# Can you finish the game so all the rules are met?
class Guesser:
    def __init__(self, number, lives):
        self.number = number
        self.lives = lives

    def guess(self, n):
        if self.lives < 1:
            raise 'Too many guesses!'
        if self.number == n:
            return True
        self.lives -= 1
        return False

# The function new_avg(arr, navg) should return the expected donation
# (rounded up to the next integer) that will permit to reach the average navg.
# Should the last donation be a non positive number (<= 0) John wants us:
# to return:
# Nothing in Haskell, Elm
# None in F#, Ocaml, Rust, Scala
# -1 in C, D, Fortran, Nim, PowerShell, Go, Pascal, Prolog, Lua, Perl, Erlang
# or to throw an error (some examples for such a case):
# IllegalArgumentException() in Clojure, Java
# ArgumentException() in C#
# echo ERROR in Shell
# argument-error in Racket
# std::invalid_argument in C++
# ValueError in Python
# So, he will clearly see that his expectations are not great enough. In "Sample Tests" you can see what to return.
# Notes:
# all donations and navg are numbers (integers or floats), arr can be empty.
# See examples below and "Sample Tests" to see which return is to be done.
from math import ceil
def new_avg(arr, newavg):
    ndon = float(newavg) * (len(arr) + 1) - sum(arr)
    if ndon >= 0:
        return ceil(ndon)
    else:
        raise ValueError('Negative number found')

# In this kata, your job is to return the two distinct highest values in a list.
# If there're less than 2 unique values, return as many of them, as possible.
# The result should also be ordered from highest to lowest.
def two_highest(arg1):
    return sorted(set(arg1), reverse=True)[:2]

# Write a function that removes every lone 9 that is inbetween 7s.
def seven_ate9(str_):
    strung_out = str_
    for i in range(len(strung_out)):
        if strung_out[i:i+3] == '797':
            strung_out = strung_out.replace('797','77')
            continue
    return strung_out

# The vowel substrings in the word codewarriors are o,e,a,io. The longest of these has a length of 2. Given a lowercase string that has alphabetic characters only (both vowels and consonants) and no spaces, return the length of the longest vowel substring.
# Vowels are any of aeiou.
# Good luck!
# If you like substring Katas, please try:
import re
def solve(s):
    matches = re.findall('[aeiou]+', s)
    return max(list(map(len, matches)))

# Take the following IPv4 address: 128.32.10.1
# This address has 4 octets where each octet is a single byte (or 8 bits).
# 1st octet 128 has the binary representation: 10000000
# 2nd octet 32 has the binary representation: 00100000
# 3rd octet 10 has the binary representation: 00001010
# 4th octet 1 has the binary representation: 00000001
# So 128.32.10.1 == 10000000.00100000.00001010.00000001
# Because the above IP address has 32 bits, we can represent it as the 32 bit number: 2149583361.
# Write a function ip_to_int32(ip) ( JS: ipToInt32(ip) ) that takes an IPv4 address and returns a 32 bit number.
def ip_to_int32(ip):
    res = ''
    for part in ip.split('.'):
        b = bin(int(part))[2:]
        res += "%08d" % (int(b))
    return(int(res, 2))

# Given an array of Boolean values and a logical operator,
# return a Boolean result based on sequentially applying the operator to the values in the array.
from functools import reduce
def logical_calc(array, op):
    if op == "AND":
        return all(array)
    elif op == "OR":
        return any(array)
    elif op == "XOR":
        return reduce(lambda x, y: x ^ y, array)

# In this kata, you will do addition and subtraction on a given string. The return value must be also a string.
# Note: the input will not be empty.
import re
def calculate(s):
    s = re.sub('plus', '+', s)
    s = re.sub('minus','-', s)
    return str(eval(s))

# Write a class Block that creates a block (Duh..)
##Requirements
# The constructor should take an array as an argument, this will contain 3 integers
# of the form [width, length, height] from which the Block should be created.
class Block:
    def __init__(self, measurements):
        self.width, self.length, self.height = measurements
    def get_height(self):
        return self.height
    def get_length(self):
        return self.length
    def get_surface_area(self):
        return 2 * (self.height * self.length +
                    self.length * self.width +
                    self.height * self.width)
    def get_volume(self):
        return self.height * self.length * self.width
    def get_width(self):
        return self.width

# Given two strings s1 and s2, we want to visualize how different the
# two strings are. We will only take into account the lowercase letters (a to z).
# First let us count the frequency of each lowercase letters in s1 and s2.
# s1 = "A aaaa bb c"
# s2 = "& aaa bbb c d"
# s1 has 4 'a', 2 'b', 1 'c'
# s2 has 3 'a', 3 'b', 1 'c', 1 'd'
# So the maximum for 'a' in s1 and s2 is 4 from s1; the maximum for 'b' is 3 from s2.
# In the following we will not consider letters when the maximum of their occurrences is less than or equal to 1.
# We can resume the differences between s1 and s2 in the following string: "1:aaaa/2:bbb"
# where 1 in 1:aaaa stands for string s1 and aaaa because the maximum for a is 4.
# In the same manner 2:bbb stands for string s2 and bbb because the maximum for b is 3.
# The task is to produce a string in which each lowercase letters of s1 or s2 appears
# as many times as its maximum if this maximum is strictly greater than 1;
# these letters will be prefixed by the number of the string where they appear
# with their maximum value and :. If the maximum is in s1 as well as in s2 the prefix is =:.
# In the result, substrings (a substring is for example 2:nnnnn or 1:hhh;
# it contains the prefix) will be in decreasing order of their length
# and when they have the same length sorted in ascending lexicographic
# order (letters and digits - more precisely sorted by codepoint);
# the different groups will be separated by '/'. See examples and "Example Tests".
# Hopefully other examples can make this clearer.
def mix(s1, s2):
    dictionary = {}
    for ch in "abcdefghijklmnopqrstuvwxyz":
        val1, val2 = s1.count(ch), s2.count(ch)
        if max(val1, val2) > 1:
            which = "1" if val1 > val2 else "2" if val2 > val1 else "="
            dictionary[ch] = (-max(val1, val2), which + ":" + ch * max(val1, val2))
    return "/".join(dictionary[ch][1] for ch in sorted(dictionary, key=lambda x: dictionary[x]))

# In this kata, we will make a function to test whether a period is late.
# Our function will take three parameters:
# last - The Date object with the date of the last period
# today - The Date object with the date of the check
# cycleLength - Integer representing the length of the cycle in days
# Return true if the number of days passed from last to today
# is greater than cycleLength. Otherwise, return false.
from datetime import *
def period_is_late(last, today, cycle_length):
    return last + timedelta(days = cycle_length) < today

# You will be given a 2D array of the maze and an array of directions.
# Your task is to follow the directions given.
# If you reach the end point before all your moves have gone, you should return Finish.
# If you hit any walls or go outside the maze border, you should return Dead.
# If you find yourself still in the maze after using all the moves, you should return Lost.

def maze_runner(maze, directions):
    startX = 0 ; startY = 0
    for y in range(len(maze)):
        for x in range(len(maze)):
            if maze[x][y] == 2:
                startX = y
                startY = x
    for dire in directions:
        if dire == "N": startY = startY - 1
        if dire == "E": startX = startX + 1
        if dire == "S": startY = startY + 1
        if dire == "W": startX = startX -1
        if startY < 0 or startY > len(maze)-1 or startX < 0 or startX > len(maze)-1 or maze[startY][startX] == 1: return "Dead"
        if maze[startY][startX] == 3: return "Finish"
    return "Lost"

# Define a method/function that removes from a given array
# of integers all the values contained in a second array.
class List(object):
    def remove_(self, integer_list, values_list):
        return [i for i in integer_list if i not in values_list]

# Complete the solution so that it takes the object (JavaScript/CoffeeScript)
# or hash (ruby) passed in and generates a human readable string from its key/value pairs.
# The format should be "KEY = VALUE". Each key/value pair should be separated by a comma except for the last pair.
def solution(pairs):
    return ",".join(sorted(["{} = {}".format(k,v) for k,v in pairs.items()]))

# Complete the solution so that it returns a formatted string.
# The return value should equal "Value is VALUE" where value is a 5 digit padded number.
def solution(value):
    value = str(value)
    return 'Value is ' + '0'*(5-len(value)) + value

# Write a function that returns the number of occurrences of an element in an array.
def number_of_occurrences(element, sample):
    return sample.count(element)

# Given 2 strings, a and b, return a string of the form: shorter+reverse(longer)+shorter.
# In other words, the shortest string has to be put as prefix and as suffix of the reverse of the longest.
# Strings a and b may be empty, but not null (In C# strings may also be null. Treat them as if they are empty.).
# If a and b have the same length treat a as the longer producing b+reverse(a)+b
def shorter_reverse_longer(a, b):
    if len(a) < len(b):
        return f'{a}{b[::-1]}{a}'
    return f'{b}{a[::-1]}{b}'

# Complete the function to find the count of the most frequent item of an array.
# You can assume that input is an array of integers. For an empty array return 0
def most_frequent_item_count(collection):
    return [max(collection.count(i) for i in collection)][0] if collection else 0

# You received a whatsup message from an unknown number. Could it be from that girl/boy
# with a foreign accent you met yesterday evening?
# Write a simple function to check if the string contains the word hallo in different languages.
# These are the languages of the possible people you met the night before:
# hello - english
# ciao - italian
# salut - french
# hallo - german
# hola - spanish
# ahoj - czech republic
# czesc - polish
# Notes
# you can assume the input is a string.
# to keep this a beginner exercise you don't need to check
# if the greeting is a subset of word (Hallowen can pass the test)
# function should be case insensitive to pass the tests
def validate_hello(greetings):
    hellos = ['hello', 'ciao', 'salut', 'hallo', 'hola', 'ahoj', 'czesc']
    return any(greet in greetings.lower() for greet in hellos)

# Create a function that returns the average of an array of numbers ("scores"),
# rounded to the nearest whole number. You are not allowed to use any loops
# (including for, for/in, while, and do/while loops).
def average(array):
    return round(sum(array) / len(array))

# Write a function that reverses the bits in an integer.
# For example, the number 417 is 110100001 in binary.
# Reversing the binary is 100001011 which is 267.
# You can assume that the number is not negative.
def reverse_bits(n):
    return int(str(bin(n).replace("0b", ""))[::-1], 2)

# Given an array with exactly 5 strings "a", "b" or "c" (chars in Java, characters in Fortran),
# check if the array contains three and two of the same values.
import collections
def check_three_and_two(array):
    count_letter = collections.Counter()
    for letter in array:
        count_letter[letter] += 1
    if max(count_letter.values()) == 3 and min(count_letter.values()) == 2:
        return True
    return False

# Your task is to return to the function seven(m)
# (m integer >= 0) an array (or a pair, depending on the language)
# of numbers, the first being the last number m with at most 2 digits
# obtained by your function (this last m will be divisible or not by 7),
# the second one being the number of steps to get the result.
# Forth Note:
# Return on the stack number-of-steps, last-number-m-with-at-most-2-digits
def seven(m):
    steps = 0
    while True:
        if m < 100:
            return (m, steps)
        m = m // 10 - 2 * (m % 10)
        steps += 1

# Write a function partlist that gives all the ways
# to divide a list (an array) of at least two elements into two non-empty parts.
# Each two non empty parts will be in a pair (or an array for languages without
# tuples or a structin C - C: see Examples test Cases - )
# Each part will be in a string
# Elements of a pair must be in the same order as in the original array.
def partlist(arr):
    return [(" ".join(arr[:i]), " ".join(arr[i:])) for i in range(1, len(arr))]

# Implement the function which should return true if given object
# is a vowel (meaning a, e, i, o, u, uppercase or lowercase), and false otherwise.
def is_vowel(s):
    return s.lower() in ['a', 'e', 'i', 'o', 'u']

# Everybody knows the classic "half your age plus seven" dating rule that a lot of people
# follow (including myself). It's the 'recommended' age range in which to date someone.
# minimum age <= your age <= maximum age #Task
# Given an integer (1 <= n <= 100) representing a person's age, return their minimum and maximum age range.
# This equation doesn't work when the age <= 14, so use this equation instead:
# min = age - 0.10 * age
# max = age + 0.10 * age
# You should floor all your answers so that an integer is given instead
# of a float (which doesn't represent age). Return your answer in the form [min]-[max]
def dating_range(age):
    return f"{int(age/2+7) if age > 14 else int(age - 0.10 * age)}-{int((age-7)*2) if age > 14 else int(age + 0.10 * age)}"

# Every budding hacker needs an alias! The Phantom Phreak, Acid Burn, Zero Cool and Crash Override
# are some notable examples from the film Hackers.
# Your task is to create a function that,
# given a proper first and last name, will return the correct alias.
# Notes:
# Two objects that return a one word name in response
# to the first letter of the first name and one for the first letter of the surname are already given.
# If the first character of either of the names given to the function is not a letter
# from A - Z, you should return "Your name must start with a letter from A - Z."
# Sometimes people might forget to capitalize the first letter of their name
# so your function should accommodate for these grammatical errors.
import re
FIRST_NAME = {
    "C": "Cache", "R": "RAD", "J": "Java","B": "Beta","H": "Half-life","L": "Logic","O": "OS",
    "Y": "Y","Q": "Quantum","T": "Trojan","S": "Strike","M": "Malware","E": "Energy",
    "F": "Function","A": "Alpha","K": "Keystroke","I": "Ice","W": "WiFi","N": "Nagware","Z": "Zero",
    "D": "Data","G": "Glitch","V": "Vanilla","X": "Xerox","P": "Phishing","U": "Ultraviolet"
}
SURNAME = {
    "E": "Electron","Q": "Quark","Z": "Zombie","C": "Catalyst","S": "Spy",
    "O": "Overclock","X": "X","D": "Discharge","M": "Mike","P": "Payload",
    "G": "Gig","K": "Killer","R": "Roy","B": "Bomb","H": "Hacker","Y": "Yob","I": "IP","F": "Faraday",
    "A": "Analogue","W": "Worm","U": "Unit","L": "Lazer","T": "T-Rex","V": "Virus",
    "N": "n00b","J": "Jabber",
}
def alias_gen(f_name, l_name):
    regex = r'^[a-zA-Z]+'
    if re.match(regex, f_name) and re.match(regex, l_name):
        return '{} {}'.format(FIRST_NAME[f_name[0].upper()], SURNAME[l_name[0].upper()])
    else:
        return 'Your name must start with a letter from A - Z.'

# Implement a function that returns the minimal and the maximal value of a list (in this order).
def get_min_max(seq):
    return (min(seq), max(seq))

# In this Kata, you will be given a string and your task will
# be to return a list of ints detailing the count of uppercase letters,
# lowercase, numbers and special characters, as follows.
def solve(s):
  uc, lc, num, sp = 0, 0, 0, 0
  for ch in s:
    if ch.isupper(): uc += 1
    elif ch.islower(): lc += 1
    elif ch.isdigit(): num += 1
    else: sp += 1
  return [uc, lc, num, sp]

# Given an array/list [] of integers , Construct a product array Of same size
# Such That prod[i] is equal to The Product of all the elements of Arr[] except Arr[i].
# Notes
# Array/list size is at least 2 .
# Array/list's numbers Will be only Positives
# Repetition of numbers in the array/list could occur.
from operator import mul
from functools import reduce
def product_array(numbers):
    tot = reduce(mul,numbers)
    return [tot//n for n in numbers]

# A Nice array is defined to be an array where for every value n in the array,
# there is also an element n - 1 or n + 1 in the array.
# Write a function named isNice / IsNice that returns true if its array argument is a Nice array,
# else false.An empty array is not considered nice.
def is_nice(arr):
    return all(i+1 in arr or i-1 in arr for i in arr) if arr else 0

# Given a sequence of integers, return the sum of all the integers that have an even index (odd index in COBOL),
# multiplied by the integer at the last index.
# Indices in sequence start from 0.
# If the sequence is empty, you should return 0.
def even_last(numbers):
    total = 0
    if numbers:
        last = numbers[-1]
        numbers = [num for i, num in enumerate(numbers) if i % 2 ==0]
        total = sum(numbers) * last
    return total

# When provided with a String, capitalize all vowels
def swap(st):
    return ''.join(i.swapcase() if i in 'aeiou' else i for i in st)

# You're running an online business and a big part of your day is fulfilling orders.
# As your volume picks up that's been taking more of your time, and unfortunately
# lately you've been running into situations where you take an order but can't fulfill it.
# You've decided to write a function fillable() that takes three arguments: a dictionary
# stock representing all the merchandise you have in stock, a string merch representing
# the thing your customer wants to buy, and an integer n representing the number
# of units of merch they would like to buy. Your function should return
# True if you have the merchandise in stock to complete the sale, otherwise it should return False.
# Valid data will always be passed in and n will always be >= 1.
def fillable(stock, merch, n):
    return merch in stock and stock[merch] >= n

# Your task is to write a function called valid_spacing()
# or validSpacing() which checks if a string has valid spacing.
# The function should return either true or false (or the corresponding value in each language).
# For this kata, the definition of valid spacing is one space between words,
# and no leading or trailing spaces. Words can be any consecutive sequence
# of non space characters. Below are some examples of what the function should return:
def valid_spacing(s):
    return ' '.join(s.split()) == s

# Just a simple sorting usage. Create a function that returns
# the elements of the input-array / list sorted in lexicographical order.
def sortme(names):
    return sorted(names)

# Complete the function that returns an array of length n,
# starting with the given number x and the squares of the previous number.
# If n is negative or zero, return an empty array/list.
def squares(x, n):
    if (n<1): return []
    result = [x]
    i=0
    while i < n-1:
        i+=1
        x*=x
        result.append(x)
    return result

# Write a function filterLucky/filter_lucky() that accepts
# a list of integers and filters the list to only include the elements that contain the digit 7.
def filter_lucky(lst):
    return list(filter(lambda x: '7' in str(x), lst))

# You and a friend have decided to play a game to drill your statistical
# intuitions. The game works like this:
# You have a bunch of red and blue marbles.
# To start the game you grab a handful of marbles of each color
# and put them into the bag, keeping track of how many of each color go in.
# You take turns reaching into the bag, guessing a color, and then pulling one marble out.
# You get a point if you guessed correctly. The trick is you only have three seconds to make your guess,
# so you have to think quickly.
# You've decided to write a function, guessBlue() to help automatically calculate whether you should guess
# "blue" or "red". The function should take four arguments:
# the number of blue marbles you put in the bag to start
# the number of red marbles you put in the bag to start
# the number of blue marbles pulled out so far (always lower than the starting number of blue marbles)
# the number of red marbles pulled out so far (always lower than the starting number of red marbles)
# guessBlue() should return the probability of drawing a blue marble, expressed as a float.
# For example, guessBlue(5, 5, 2, 3) should return 0.6.
def guess_blue(blue_start, red_start, blue_pulled, red_pulled):
    return (blue_start-blue_pulled)/(blue_start-blue_pulled+red_start-red_pulled)

# You are given a list of unique integers arr, and two integers a and b.
# Your task is to find out whether or not a and b appear consecutively in arr,
# and return a boolean value (True if a and b are consecutive, False otherwise).
# It is guaranteed that a and b are both present in arr.
def consecutive(arr, a, b):
    return arr.index(a) == arr.index(b)-1 or arr.index(a) == arr.index(b)+1

# Write a function that takes a string and an an integer n as parameters
# and returns a list of all words that are longer than n.
def filter_long_words(sentence, n):
    return [i for i in sentence.split() if len(i) > n]

# Your task is to determine how many files of the copy queue you will be able
# to save into your Hard Disk Drive. The files must be saved in the order they appear in the queue.
# Input:
# Array of file sizes (0 <= s <= 100)
# Capacity of the HD (0 <= c <= 500)
# Output:
# Number of files that can be fully saved in the HD.
def save(sizes, hd):
    return sum([sum(sizes[:i+1]) <= hd for i in range(len(sizes))])

# In this exercise, a string is passed to a method and a new string has
# to be returned with the first character of each word in the string.
def make_string(s):
    return ''.join(i[0] for i in s.split())

# Your task in this kata is to implement a function that calculates
# the sum of the integers inside a string. For example,
# in the string "The30quick20brown10f0x1203jumps914ov3r1349the102l4zy dog", the sum of the integers is 3635.
# Note: only positive integers will be tested.
import re
def sum_of_integers_in_string(s):
    return sum([int(i) for i in re.findall(r'\d+', s)])

# Write a function to greet a person. Function will take name as input
# and greet the person by saying hello. Return null/nil/None if input is empty string or null/nil/None.
def greet(name):
    return f"hello {name}!" if name else None

# Hey Codewarrior!
# You already implemented a Cube class, but now we need your help again!
# I'm talking about constructors. We don't have one.
# Let's code two: One taking an integer and one handling no given arguments!
# Also we got a problem with negative values. Correct the code so negative
# values will be switched to positive ones!
# The constructor taking no arguments should assign 0 to Cube's Side property.
class Cube(object):
    def __init__(self, side=0):
        self._side = abs(side)

    def get_side(self):\
        return self._side

    def set_side(self, new_side):
        self._side = abs(new_side)

# In your class, you have started lessons about arithmetic progression. Since you are also a programmer,
# you have decided to write a function that will return the first n elements of the sequence with
# the given common difference d and first element a. Note that the difference may be zero!
# The result should be a string of numbers, separated by comma and space.
def arithmetic_sequence_elements(a, d, n):
	return ', '.join(str(a + i * d) for i in range(n))

# When given a string of space separated words, return the word with the longest length.
# If there are multiple words with the longest length,
# return the last instance of the word with the longest length.
def longest_word(string_of_words):
    return sorted(string_of_words.split(), key=len)[-1]

# Given a year, Find The next happy year or The closest year You'll see your best friend
def next_happy_year(year):
    happy_year = False
    while happy_year == False:
        year += 1
        if len(set(list(str(year)))) == 4:
            happy_year = True
    return year

# The medians of a triangle are the segments that unit the vertices with the midpoint of their opposite sides.
# The three medians of a triangle intersect at the same point, called the barycenter or the centroid.
# Given a triangle, defined by the cartesian coordinates of its vertices we need
# to localize its barycenter or centroid.
# The function bar_triang() or barTriang or bar-triang, receives the coordinates
# of the three vertices A, B and C  as three different arguments and outputs the
# coordinates of the barycenter O in an array [xO, yO]
# This is how our asked function should work: the result of the coordinates should
# be expressed up to four decimals, (rounded result).
# You know that the coordinates of the barycenter are given by the following formulas.
def bar_triang(*args):
    return list(map(lambda a: round(sum(a) / 3.0, 4), zip(*args)))

# You will be given an array of objects representing data about developers
# who have signed up to attend the next coding meetup that you are organising.
# Given the following input array:
# write a function that when executed as findAdmin(list1, 'JavaScript')
# returns only the JavaScript developers who are GitHub admins:
from typing import List
def find_admin(lst, lang):
    return [i for i in lst if i['language'] == lang and i['githubAdmin'] == 'yes']

# You receive the name of a city as a string, and you need to return
# a string that shows how many times each letter shows up in the string by using asterisks (*).
def get_strings(city):
    letters = {}
    for letter in city:
        if letter.lower() not in letters:
            letters[letter.lower()] = 1
        else:
            letters[letter.lower()] += 1
    return ",".join(key + ":" + "*"*value for key, value in letters.items() if key != " ")

# Given an array of N integers, you have to find how many times you have to add up the smallest
# numbers in the array until their Sum becomes greater or equal to K.
# Notes:
# List size is at least 3.
# All numbers will be positive.
# Numbers could occur more than once , (Duplications may exist).
# Threshold K will always be reachable.
def minimum_steps(numbers, value):
    numbers = sorted(numbers)
    count = 0
    for i in range(len(numbers)):
        count+=numbers[i]
        if count >= value:
            return i

# The function must return the truncated version of the given
# string up to the given limit followed by "..." if the result is
# shorter than the original. Return the same string if nothing was truncated.
def solution(st, limit):
    return st[:limit] + '...' if limit < len(st) else st

# Fellow code warrior, we need your help!
# We seem to have lost one of our sequence elements, and we need your help to retrieve it!
# Our sequence given was supposed to contain all of the integers from 0 to 9 (in no particular order),
# but one of them seems to be missing.
# Write a function that accepts a sequence of unique integers between 0 and 9 (inclusive),
# and returns the missing element.
def get_missing_element(seq):
    return [i for i in range(10) if i not in seq][0]

# Extra perfect number is the number that first and last bits are set bits.
# Task
# Given a positive integer N , Return the extra perfect numbers in range from 1 to N .
def extra_perfect(n):
    return [i for i in range(1, n+1, 2)]

# Simple enough this one - you will be given an array. The values in the array will either
# be numbers or strings, or a mix of both. You will not get an empty array, nor a sparse one.
# Your job is to return a single array that has first the numbers sorted in ascending order,
# followed by the strings sorted in alphabetic order. The values must maintain their original type.
# Note that numbers written as strings are strings and must be sorted with the other strings.
def db_sort(arr):
    return sorted([i for i in arr if type(i) == int]) + sorted([i for i in arr if type(i) == str])

# Gordon Ramsay shouts. He shouts and swears. There may be something wrong with him.
# Anyway, you will be given a string of four words. Your job is to turn them in to Gordon language.
# Rules:
# Obviously the words should be Caps, Every word should end with '!!!!',
# Any letter 'a' or 'A' should become '@', Any other vowel should become '*'.
def gordon(a):
    trans = a.lower().maketrans({'a':'@', 'e':'*', 'o':'*','u':'*','i':'*'})
    return '!!!! '.join(a.translate(trans).upper().split()) + '!!!!'

# Given two numbers x and n, calculate the (positive) nth root of x; this means that being r = result, r^n = x
# Examples
def root(x, n):
    return x**(1/n)

# Given a string, return true if the first instance of "x"
# in the string is immediately followed by the string "xx".
def triple_x(s):
    for i, elem in enumerate(s[:-2]):
        if elem == 'x':
            return elem == s[i+1] and elem == s[i+2]
    return False

# The other day I saw an amazing video where a guy hacked some wifi controlled lightbulbs
# by flying a drone past them. Brilliant.
# In this kata we will recreate that stunt... sort of.
# You will be given two strings: lamps and drone. lamps represents a row of lamps,
# currently off, each represented by x. When these lamps are on, they should be represented by o.
# The drone string represents the position of the drone T (any better suggestion
# for character??) and its flight path up until this point =. The drone always
# flies left to right, and always begins at the start of the row of lamps.
# Anywhere the drone has flown, including its current position,
# will result in the lamp at that position switching on.
# Return the resulting lamps string. See example tests for more clarity.
def fly_by(lamps, drone):
    return 'o'*len(drone) + lamps[len(drone):] if len(drone) <= len(lamps) else 'o'*len(lamps)

# You are given a string of n lines, each substring being n characters long. For example:
# s = "abcd\nefgh\nijkl\nmnop"
# We will study the "horizontal" and the "vertical" scaling of this square of strings.
# A k-horizontal scaling of a string consists of replicating k times each character of the string (except '\n').
# Example: 2-horizontal scaling of s: => "aabbccdd\neeffgghh\niijjkkll\nmmnnoopp"
# A v-vertical scaling of a string consists of replicating v times each part of the squared string.
# Example: 2-vertical scaling of s: => "abcd\nabcd\nefgh\nefgh\nijkl\nijkl\nmnop\nmnop"
def scale(strng, k, n):
    return '\n'.join(''.join(b * k for b in a) for a in strng.split('\n') for _ in range(n)) if strng else ''

# Bob is a lazy man.
# He needs you to create a method that can determine how many
# letters (both uppercase and lowercase ASCII letters) and digits are in a given string.
def count_letters_and_digits(s):
    return len([i for i in s if i.isdigit() or i.isalpha()])

# You have stumbled across the divine pleasure that is owning
# a dog and a garden. Now time to pick up all the cr@p! :D
# Given a 2D array to represent your garden, you must find
# and collect all of the dog cr@p - represented by '@'.
# You will also be given the number of bags you have access to
# (bags), and the capactity of a bag (cap). If there are no bags then
# you can't pick anything up, so you can ignore cap.
# You need to find out if you have enough capacity to collect all the cr@p and make your garden clean again.
# If you do, return 'Clean', else return 'Cr@p'.
# Watch out though - if your dog is out there ('D'), he gets very
# touchy about being watched. If he is there you need to return 'Dog!!'.
def crap(garden, bags, cap):
    c = 0
    for el in garden:
        for e in el:
            if e == "@":
                c += 1
            if e == "D":
                return "Dog!!"
    return "Clean" if c <= bags * cap else "Cr@p"

# Imagine you start on the 5th floor of a building, then travel down to the 2nd floor,
# then back up to the 8th floor. You have travelled a total of 3 + 6 = 9 floors of distance.
# Given an array representing a series of floors you must reach by elevator,
# return an integer representing the total distance travelled for visiting each floor in the array in order.
def elevator_distance(array):
    return sum([abs(array[i] - array[i+1]) for i in range(len(array)-1)])

# Complete the function to create backronyms. Transform the given string (without spaces)
# to a backronym, using the preloaded dictionary and return a string of words,
# separated with a single space (but no trailing spaces).
# The keys of the preloaded dictionary are uppercase letters A-Z
# and the values are predetermined words, for example:
dictionary
def make_backronym(acronym):
    return ' '.join(dictionary[i.upper()] for i in acronym)

# My friend John likes to go to the cinema. He can choose between system A and system B.
# System A : he buys a ticket (15 dollars) every time
# System B : he buys a card (500 dollars) and a first ticket for 0.90 times the ticket price,
# then for each additional ticket he pays 0.90 times the price paid for the previous ticket.
# Example:
# If John goes to the cinema 3 times
# System A : 15 * 3 = 45
# System B : 500 + 15 * 0.90 + (15 * 0.90) * 0.90 + (15 * 0.90 * 0.90) * 0.90 ( = 536.5849999999999,
# no rounding for each ticket)
# John wants to know how many times he must go to the cinema so that the final result of System B,
# when rounded up to the next dollar, will be cheaper than System A.
# The function movie has 3 parameters: card (price of the card), ticket (normal price of a ticket),
# perc (fraction of what he paid for the previous ticket) and returns the first n such that
import math
def movie(card, ticket, perc):
    total_card = card
    total_tickets = 0
    i = 1
    while math.ceil(total_card) >= total_tickets:
        total_card += ticket *(perc**i)
        total_tickets += ticket
        i += 1
    return i - 1

# You will be given an array of objects representing data
# about developers who have signed up to attend the next coding meetup that you are organising.
# Your task is to return an object which includes the count
# of food options selected by the developers on the meetup sign-up form..
from typing import List
def order_food(lst):
    meals = {}
    for i in lst:
        if i['meal'] not in meals:
            meals[i['meal']] = 1
        else:
            meals[i['meal']] += 1
    return meals

# This kata is the first of a sequence of four about "Squared Strings".
# You are given a string of n lines, each substring being n characters long: For example:
# s = "abcd\nefgh\nijkl\nmnop"
# We will study some transformations of this square of strings.
def vert_mirror(strng):
    return '\n'.join(i[::-1] for i in strng.split('\n'))
def hor_mirror(strng):
    return '\n'.join(strng.split('\n')[::-1])
def oper(fct, s):
    return fct(s)

# Each floating-point number should be formatted that only the first two decimal places are returned.
# You don't need to check whether the input is a valid number because only valid numbers are used in the tests.
# Don't round the numbers! Just cut them after two decimal places!
from math import trunc
def two_decimal_places(number):
    factor = float(10 ** 2)
    return trunc(number * factor) / factor

# Definition
# A number is a Special Number if it’s digits only consist 0, 1, 2, 3, 4 or 5
# Given a number determine if it special number or not .
def special_number(n):
    return "Special!!" if max(str(n)) <= "5" else "NOT!!"

# Given an array (a list in Python) of integers and an integer n, find all occurrences of n
# in the given array and return another array containing all the index positions of n in the given array.
# If n is not in the given array, return an empty array [].
# Assume that n and all values in the given array will always be integers.
def find_all(array, n):
    return [e for e,i in enumerate(array) if i == n]

# Given an array of numbers (in string format), you must return a string.
# The numbers correspond to the letters of the alphabet in reverse order:
# a=26, z=1 etc. You should also account for '!', '?' and ' ' that are represented by
# '27', '28' and '29' respectively.
# All inputs will be valid.
def switcher(arr):
    letters = ' ?!abcdefghijklmnopqrstuvwxyz'
    return ''.join(letters[::-1][int(idx) - 1] for idx in arr)

# My friend wants a new band name for her band. She like bands that use the formula:
# "The" + a noun with the first letter capitalized, for example:
# "dolphin" -> "The Dolphin"
# However, when a noun STARTS and ENDS with the same letter,
# she likes to repeat the noun twice and connect them together
# with the first and last letter, combined into one word (WITHOUT "The" in front), like this:
# "alaska" -> "Alaskalaska"
# Complete the function that takes a noun as a string, and returns her preferred band name written as a string.
def band_name_generator(name):
    name = name.lower()
    if name[0] == name[-1]:
        return (name[:-1] + name).capitalize()
    return "The {}".format(name.capitalize())

# Is similar to factorial of a number, In primorial, not all the natural numbers get multiplied,
# only prime numbers are multiplied to calculate the primorial of a number.
# It's denoted with P# and it is the product of the first n prime numbers.
# Task
# Given a number N , calculate its primorial.
import functools
def num_primorial(n):
    def sieveOfEratosthenes(n):
        if n <= 2:
            return []
        sieve = list(range(3, n, 2))
        top = len(sieve)
        for si in sieve:
            if si:
                bottom = (si*si - 3) // 2
                if bottom >= top:
                    break
                sieve[bottom::si] = [0] * -((bottom - top) // si)
        return [2] + [el for el in sieve if el]
    return functools.reduce(lambda a, b: a*b, sieveOfEratosthenes(10000)[:n])

# Well met with Fibonacci bigger brother, AKA Tribonacci.
# As the name may already reveal, it works basically like a Fibonacci,
# but summing the last 3 (instead of 2) numbers of the sequence to generate the next.
# And, worse part of it, regrettably I won't get to hear non-native Italian speakers trying to pronounce it :(
# So, if we are to start our Tribonacci sequence with [1, 1, 1] as a starting
# input (AKA signature), we have this sequence:
def tribonacci(signature, n):
    if n == 0:
        return []
    def fib(n):
        a, b, c = signature[0], signature[1], signature[2]
        for _ in range(n):
            yield a
            a, b, c = b, c, a+b+c
    return list(fib(n))

# You receive some random elements as a space-delimited string. Check if the
# elements are part of an ascending sequence of integers
# starting with 1, with an increment of 1 (e.g. 1, 2, 3, 4).
# Return:
# 0 if the elements can form such a sequence, and no number is missing ("not broken", e.g. "1 2 4 3")
# 1 if there are any non-numeric elements in the input ("invalid", e.g. "1 2 a")
# n if the elements are part of such a sequence, but some numbers are missing,
# and n is the lowest of them ("broken", e.g. "1 2 4" or "1 5")
def find_missing_number(sequence):
    if not sequence:
        return 0
    try:
        sequence = set(int(a) for a in sequence.split())
    except ValueError:
        return 1
    for b in range(1, max(sequence) + 1):
        if b not in sequence:
            return b
    return 0

# The bloody photocopier is broken... Just as you were sneaking around
# the office to print off your favourite binary code!
# Instead of copying the original, it reverses it: '1' becomes '0' and vice versa.
# Given a string of binary, return the version the photocopier gives you as a string.
def broken(inp):
    return inp.translate(inp.maketrans({'0':'1', '1':'0'}))

# Write a function that finds the sum of all its arguments.
def sum_args(*args):
    return sum([*args])

# You'll have to translate a string to Pilot's alphabet (NATO phonetic alphabet).
# Input:
# If, you can read?
# Output:
# India Foxtrot , Yankee Oscar Uniform Charlie Alfa November Romeo Echo Alfa Delta ?
# Note:
# There are preloaded dictionary you can use, named NATO
# The set of used punctuation is ,.!?.
# Punctuation should be kept in your return string, but spaces should not.
# Xray should not have a dash within.
# Every word and punctuation mark should be seperated by a space ' '.
# There should be no trailing whitespace
NATO
def to_nato(words):
    return ' '.join(NATO[i.upper()] if i not in ',.!?' else i for i in words.replace(' ', ''))

# Cheesy Cheeseman just got a new monitor! He is happy with it,
# but he just discovered that his old desktop wallpaper no longer fits.
# He wants to find a new wallpaper, but does not know which size wallpaper
# he should be looking for, and alas, he just threw out the new monitor's box.
# Luckily he remembers the width and the aspect ratio of the monitor from
# when Bob Mortimer sold it to him. Can you help Cheesy out?
# The Challenge
# Given an integer width and a string ratio written as WIDTH:HEIGHT,
# output the screen dimensions as a string written as WIDTHxHEIGHT.
# Note: The calculated height should be represented as an integer.
# If the height is fractional, truncate it.
def find_screen_height(width, ratio):
    lhs, rhs = list(map(int, ratio.split(':')))
    height = int(width * rhs/lhs)
    return str(width) + 'x' + str(height)

# Create the function prefill that returns an array of n elements
# that all have the same value v. See if you can do this without using a loop.
# You have to validate input:
# v can be anything (primitive or otherwise)
# if v is ommited, fill the array with undefined
# if n is 0, return an empty array
# if n is anything other than an integer or integer-formatted string (e.g. '123') that is >=0, throw a TypeError
# When throwing a TypeError, the message should be n is invalid, where
# you replace n for the actual value passed to the function.
def prefill(n,v='undefined'):
    if str(n).isdigit()==True:
        return [v for _ in range(int(n))]
    else:
        raise TypeError('%s is invalid'%(n))

# A bookseller has lots of books classified in 26 categories labeled A, B, ... Z. Each book has a code
# c of 3, 4, 5 or more characters. The 1st character of a code is a capital letter which defines the book category.
# In the bookseller's stocklist each code c is followed
# by a space and by a positive integer n (int n >= 0) which indicates the quantity of books of this code in stock.
# For example an extract of a stocklist could be:
# L = {"ABART 20", "CDXEF 50", "BKWRK 25", "BTSQZ 89", "DRTYM 60"}.
# or
# L = ["ABART 20", "CDXEF 50", "BKWRK 25", "BTSQZ 89", "DRTYM 60"] or ....
# You will be given a stocklist (e.g. : L) and a list of categories in capital letters e.g :
# M = {"A", "B", "C", "W"}
# or
# M = ["A", "B", "C", "W"] or ...
# and your task is to find all the books of L with codes
# belonging to each category of M and to sum their quantity according to each category.
# For the lists L and M of example you have to return the
# string (in Haskell/Clojure/Racket/Prolog a list of pairs):
def stock_list(listOfArt, listofCat):
	stock = {}
	result=''
	for a in listOfArt:
		cat = a.split(' ')[0][0:1]
		if stock.get(cat):
			stock[cat]+= int(a.split(' ')[1])
		else:
			stock[cat] = int(a.split(' ')[1])
	for c in listofCat:
		if stock.get(c):
			result+='({0} : {1}) - '.format(c, stock.get(c))
		else:
			result+='({0} : {1}) - '.format(c, 0)
	if all(s == 0 for s in stock.values()): return ''
	return result[0:len(result)-3] if result.endswith(' ') else result

# Given a string of digits confirm whether the sum of all the individual even digits
# are greater than the sum of all the indiviudal odd digits. Always a string of numbers will be given.
# If the sum of even numbers is greater than the odd numbers return: "Even is greater than Odd"
# If the sum of odd numbers is greater than the sum of even numbers return: "Odd is greater than Even"
# If the total of both even and odd numbers are identical return: "Even and Odd are the same"
def even_or_odd(s):
    a = sum(int(i) for i in s if int(i)%2 != 0)
    b = sum(int(i) for i in s if int(i)%2 == 0)
    return 'Even is greater than Odd' if b > a else 'Odd is greater than Even' if a>b else 'Even and Odd are the same'

# Given two words and a letter, return a single word that's a combination of both words,
# merged at the point where the given letter first appears in each word.
# The returned word should have the beginning of the first word and the ending of the second,
# with the dividing letter in the middle. You can assume both words will contain the dividing letter.
def string_merge(string1, string2, letter):
    return string1[:string1.index(letter)] + string2[string2.index(letter):]

# Given a positive integer n: 0 < n < 1e6,
# remove the last digit until you're left with a number that is a multiple of three.
# Return n if the input is already a multiple of three,
# and if no such number exists, return null, a similar empty value, or -1.
def prev_mult_of_three(n):
    while n % 3 != 0:
        if len(str(n)) == 1 and n % 3 != 0:
            return None
        n = int(str(n)[:-1])
    return n

# A traveling salesman has to visit clients. He got each client's address e.g. "432 Main Long Road
# St. Louisville OH 43071" as a list.
# The basic zipcode format usually consists of two capital letters followed by a white
# space and five digits. The list of clients to visit was given as a string of all
# addresses, each separated from the others by a comma, e.g. :
# "123 Main Street St. Louisville OH 43071,432 Main Long Road St. Louisville OH 43071,
# 786 High Street Pollocksville NY 56432".
# To ease his travel he wants to group the list by zipcode.
# Task
# The function travel will take two parameters r (addresses' list of all
# clients' as a string) and zipcode and returns a string in the following format:
# zipcode:street and town,street and town,.../house number,house number,...
# The street numbers must be in the same order as the streets where they belong.
# If a given zipcode doesn't exist in the list of clients' addresses return "zipcode:/"
def travel(r, zipcode):
    l = r.split(',')
    lst = []
    l_n = []
    con = ''
    for elem in l:
        if zipcode == elem[-8:]:
            lst.append(elem[:-9])
    for i in lst:
        while True:
            for char in i:
                if char.isdigit():
                    con += char
                    continue
                l_n.append(con)
                con = ''
                break
            break
    for i in range(len(lst)):
        lst[i] = lst[i][len(l_n[i])+1:]
    return f"{zipcode}:{','.join(i for i in lst)}/{','.join(i for i in l_n)}"

# You are given a string of n lines, each substring being n characters long: For example:
# s = "abcd\nefgh\nijkl\nmnop"
# We will study some transformations of this square of strings.
# Clock rotation 180 degrees: rot
# rot(s) => "ponm\nlkji\nhgfe\ndcba"
# selfie_and_rot(s) (or selfieAndRot or selfie-and-rot)
# It is initial string + string obtained by clock rotation 180 degrees
# with dots interspersed in order (hopefully) to better show the rotation when printed.
# s = "abcd\nefgh\nijkl\nmnop" -->
# "abcd....\nefgh....\nijkl....\nmnop....\n....ponm\n....lkji\n....hgfe\n....dcba"
def rot(strng):
    return strng[::-1]
def selfie_and_rot(strng):
    return '\n'.join(i+'.'*len(i) for i in strng.split('\n')) + '\n' +'\n'.join('.'*len(i)+i[::-1] for i in strng.split('\n')[::-1])
def oper(fct, s):
    return fct(s)

# Your task is to construct a building which will be a pile of n cubes. The cube at the bottom will have a volume
# of n3 n^3n  3
#  , the cube above will have volume of (n−1)3 (n-1)^3(n−1) 3
#   and so on until the top which will have a volume of 13 1^31 3 .
# You are given the total volume m of the building. Being given m can you find the
# number n of cubes you will have to build?
# The parameter of the function findNb (find_nb, find-nb, findNb, ...) will be an
# integer m and you have to return the integer n such
# as n3+(n−1)3+(n−2)3+...+13=m n^3 + (n-1)^3 + (n-2)^3 + ... + 1^3 = mn
# 3 +(n−1) 3 +(n−2) 3 +...+1 3 =m if such a n exists or -1 if there is no such n.
def find_nb(M):
    m = 0
    i = 0
    while m < M:
        m += i ** 3
        if m == M:
            return i
        i += 1
    return -1

# It's tricky keeping track of who is owed what when spending money in a group.
# Write a function to balance the books.
# The function should take one parameter: an object/dict with two or more
# name-value pairs which represent the members of the group and the amount spent by each.
# The function should return an object/dict with the same names, showing
# how much money the members should pay or receive.
# Further points:
# The values should be positive numbers if the person should receive money
# from the group, negative numbers if they owe money to the group.
# If value is a decimal, round to two decimal places.
# Translations and comments (and upvotes!) welcome.
# Example
# 3 friends go out together: A spends £20, B spends £15, and C spends £10.
# The function should return an object/dict showing that A should receive £5,
# B should receive £0, and C should pay £5.
group = {
    'A': 20,
    'B': 15,
    'C': 10
}
def split_the_bill(x):
    total_each_owed = sum(x.values())/float(len(x))
    return {key:round(value - total_each_owed, 2) for key, value in x.items()}

# For this game of BINGO, you will receive a single array of 10 numbers
# from 1 to 26 as an input. Duplicate numbers within the array are possible.
# Each number corresponds to their alphabetical order letter (e.g. 1 = A. 2 = B, etc).
# Write a function where you will win the game if your numbers can spell "BINGO".
# They do not need to be in the right order in the input array. Otherwise you will lose.
# Your outputs should be "WIN" or "LOSE" respectively.
import string
def bingo(array):
    lst = []
    for elem in array:
        lst.append(string.ascii_lowercase[elem-1])
    return 'WIN' if all(i in lst for i in 'bingo') else 'LOSE'

# Let's create some scrolling text!
# Your task is to complete the function which takes a string,
# and returns an array with all possible rotations of the given string, in uppercase.
def scrolling_text(text):
    lst = []
    for i in range(len(text)):
        lst.append(text.upper())
        text = text[1:] + text[0]
    return lst

# John wants to decorate the walls of a room with wallpaper. He wants a fool-proof method for getting it right.
# John knows that the rectangular room has a length of l meters, a width of w meters,
# a height of h meters. The standard width of the rolls he wants to buy is 52 centimeters.
# The length of a roll is 10 meters. He bears in mind however, that it’s best to have an
# extra length of wallpaper handy in case of mistakes or miscalculations so he wants to
# buy a length 15% greater than the one he needs.
# Last time he did these calculations he got a headache, so could you help John?
# Task
# Your function wallpaper(l, w, h) should return as a plain English word in lower
# case the number of rolls he must buy.

from math import ceil
WORDS = {
    1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five', 6: 'six',
    7: 'seven', 8: 'eight', 9: 'nine', 10: 'ten', 11: 'eleven', 12: 'twelve',
    13: 'thirteen', 14: 'fourteen', 15: 'fifteen', 16: 'sixteen',
    17: 'seventeen', 18: 'eighteen', 19: 'nineteen', 20: 'twenty'
}
def wallpaper(l, w, h):
    if 0 in (l, w, h):
        return 'zero'
    return WORDS[int(ceil((((l * h) * 2 + (w * h) * 2) * 1.15) / 5.2))]

# Count the number of exclamation marks and question marks, return the product.
def product(s):
    return int(s.count('!'))*int(s.count('?'))

# For every good kata idea there seem to be quite a few bad ones!
# In this kata you need to check the provided 2 dimensional array
# (x) for good ideas 'good' and bad ideas 'bad'. If there are
# one or two good ideas, return 'Publish!', if there are more
# than 2 return 'I smell a series!'. If there are no good ideas, as is often the case, return 'Fail!'.
# The sub arrays may not be the same length.
# The solution should be case insensitive (ie good, GOOD
# and gOOd all count as a good idea). All inputs may not be strings.
def well(arr):
    l = [j.lower() if type(j) == str else j for i in arr for j in i]
    con = l.count('good')
    return 'Fail!' if con == 0 else 'Publish!' if 1 <= con <= 2 else 'I smell a series!'

# In this kata you are given a string for example:
# "example(unwanted thing)example"
# Your task is to remove everything inside the parentheses as well as the parentheses themselves.
# The example above would return:
# "exampleexample"
# Notes
# Other than parentheses only letters and spaces can occur in the string.
# Don't worry about other brackets like "[]" and "{}" as these will never appear.
# There can be multiple parentheses.
# The parentheses can be nested.
import re
def remove_parentheses(s):
    while re.findall(r"\([^()]*\)", s):
        s = re.sub(r"\([^()]*\)", "", s)
    return s

# Create the function consecutive(arr) that takes an array of integers
# and return the minimum number of integers needed to make the contents
# of arr consecutive from the lowest number to the highest number.
def consecutive(arr):
    try:
        return len(range(min(arr), max(arr)+1)) - len(arr)
    except:
        return 0

# Write a function that takes a string
# and outputs a strings of 1's and 0's where vowels become 1's and non-vowels become 0's.
# All non-vowels including non alpha characters (spaces,commas etc.) should be included.
def vowel_one(s):
    return ''.join('1' if i.lower() in 'aeoiu' else '0' for i in s)

# Write a function to find if a number is lucky or not.
# If the sum of all digits is 0 or multiple of 9 then the number is lucky.
# 1892376 => 1+8+9+2+3+7+6 = 36. 36 is divisible by 9, hence number is lucky.
# Function will return true for lucky numbers and false for others.
def is_lucky(n):
    return sum(int(i) for i in str(n)) % 9 == 0 or str(sum(int(i) for i in str(n)))[0] == '0'

# To introduce the problem think to my neighbor who drives a tanker truck.
# The level indicator is down and he is worried because he does not know
# if he will be able to make deliveries. We put the truck on a horizontal
# ground and measured the height of the liquid in the tank.
# Fortunately the tank is a perfect cylinder and the vertical walls on
# each end are flat. The height of the remaining liquid is h, the diameter
# of the cylinder base is d, the total volume is vt (h, d, vt are positive
# or null integers). You can assume that h <= d.
# Could you calculate the remaining volume of the liquid? Your function
# tankvol(h, d, vt) returns an integer which is the truncated result (e.g floor) of your float calculation.
import math
def tankvol(h, d, vt):
    radius = d / 2
    cylinder_length = vt / (math.pi * (radius * radius))
    volume = cylinder_length * (((radius * radius) * math.acos((radius - h) / radius)) - ((radius - h) * math.sqrt((2 * radius * h) - (h * h))))
    return int(volume)

# Given a list of integers values, your job is to return the sum of the values;
# however, if the same integer value appears multiple times in the list,
# you can only count it once in your sum.
def unique_sum(lst):
    return sum(set(lst)) if lst else None

# Welcome young Jedi! In this Kata you must create a function that takes an amount of US currency
# in cents, and returns a dictionary/hash which shows the least amount of coins used to make up
# that amount. The only coin denominations considered in this exercise are: Pennies (1¢),
# Nickels (5¢), Dimes (10¢) and Quarters (25¢). Therefor the dictionary returned should
# contain exactly 4 key/value pairs.
# Notes:
# If the function is passed either 0 or a negative number, the function should
# return the dictionary with all values equal to 0.
# If a float is passed into the function, its value should be rounded down,
# and the resulting dictionary should never contain fractions of a coin.
def loose_change(cents):
    d = {'Nickels': 0, 'Pennies': 0, 'Dimes': 0, 'Quarters': 0}
    if cents > 0:
        d['Quarters'] = cents//25
        cents = cents- 25*(cents//25)
        d['Dimes'] = cents // 10
        cents = cents-10*(cents//10)
        d['Nickels'] = cents // 5
        cents = cents-5*(cents//5)
        d['Pennies'] = cents // 1
    return d

# Move every letter in the provided string forward 10 letters through the alphabet.
# If it goes past 'z', start again at 'a'.
# Input will be a string with length > 0.
def move_ten(st):
    d = 'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz'
    return ''.join(d[d.index(i)+10] for i in st)

# Function composition is a mathematical operation that mainly presents itself in lambda calculus
# and computability. It is explained well here, but this is my explanation, in simple mathematical notation:
# f3 = compose( f1 f2 )
#    Is equivalent to...
# f3(a) = f1( f2( a ) )
# Your task is to create a compose function to carry out this task,
# which will be passed two functions or lambdas. Ruby functions will
# be passed, and should return, either a proc or a lambda.
# Remember that the resulting composed function may be passed multiple arguments!
def compose(f, g):
    def wrapper(*args):
        return f(g(*args))
    return wrapper

# Your job is to implement a function which returns the last D digits of an integer N as a list.
# Special cases:
# If D > (the number of digits of N), return all the digits.
# If D <= 0, return an empty list.
def solution(n,d):
    return [int(i) for i in str(n)[-d:]] if d > 0 else []

# Time to win the lottery!
# Given a lottery ticket (ticket), represented by an array of 2-value arrays,
# you must find out if you've won the jackpot.
# Example ticket:
# [ [ 'ABC', 65 ], [ 'HGR', 74 ], [ 'BYHT', 74 ] ]
# To do this, you must first count the 'mini-wins' on your ticket.
# Each subarray has both a string and a number within it.
# If the character code of any of the characters in the string matches the number,
# you get a mini win. Note you can only have one mini win per sub array.
# Once you have counted all of your mini wins, compare that number to the
# other input provided (win). If your total is more than or equal to (win),
# return 'Winner!'. Else return 'Loser!'.
# All inputs will be in the correct format. Strings on tickets are not always the same length.
def bingo(ticket,win):
    count = 0
    for i in ticket:
        for j in i[0]:
            if ord(j)==i[1]:
                count += 1
                break
    return 'Winner!' if count >= win else 'Loser!'

# Given a positive number n > 1 find the prime factor
# decomposition of n. The result will be a string with the following form :
#  "(p1**n1)(p2**n2)...(pk**nk)"
# with the p(i) in increasing order and n(i) empty if n(i) is 1.
def prime_factors(n):
    i = 2
    res = {}
    while n/i != 1:
        if n%i == 0:
            if i in res:
                res[i] = res[i]+1
            else:
                res[i] = 1
            n = n/i
        else:
            i+=1
    if i in res:
        res[i] = res[i]+1
    else:
        res[i] = 1
    t = ''
    res = sorted(res.items(),key = lambda a:a[0])
    for key in res:
        if key[1] == 1:
            t = t + '('+str(key[0]) +')'
        else:
            t = t + '(' +str(key[0]) + '**' + str(key[1]) + ')'
    return t

# Write a function insert_dash(num) / insertDash(num) / InsertDash(int num) that will insert dashes
# ('-') between each two odd digits in num. For example:
# if num is 454793 the output should be 4547-9-3. Don't count zero as an odd digit.
# Note that the number will always be non-negative (>= 0).
import re
def insert_dash(num):
    return re.sub(r'([13579])(?=[13579])', r'\1-', str(num))\

# Write a function that returns true if the number is a "Very Even" number.
# If a number is a single digit, then it is simply "Very Even" if it itself is even.
# If it has 2 or more digits, it is "Very Even" if the sum of its digits is "Very Even".
def is_very_even_number(n):
    while len(str(n))!= 1:
        n = sum(int(i) for i in str(n))
    return n % 2 == 0

# The Pied Piper has been enlisted to play his magical tune and coax all the rats out of town.
# But some of the rats are deaf and are going the wrong way!
# Kata Task
# How many deaf rats are there?
# Legend
# P = The Pied Piper
# O~ = Rat going left
# ~O = Rat going right
# Example
# ex1 ~O~O~O~O P has 0 deaf rats
# ex2 P O~ O~ ~O O~ has 1 deaf rat
# ex3 ~O~O~O~OP~O~OO~ has 2 deaf rats
import re
def count_deaf_rats(town):
    t = town.split('P')
    return find(t[0]).count('O~') + find(t[1]).count('~O')
def find(s):
    return [''.join(j) for j in re.findall('(~O)|(O~)', s)]

# From Wikipedia:
# "A divisibility rule is a shorthand way of determining whether
# a given integer is divisible by a fixed divisor without performing
# the division, usually by examining its digits."
# When you divide the successive powers of 10 by 13 you get the
# following remainders of the integer divisions:
# 1, 10, 9, 12, 3, 4 because:
# 10 ^ 0 ->  1 (mod 13)
# 10 ^ 1 -> 10 (mod 13)
# 10 ^ 2 ->  9 (mod 13)
# 10 ^ 3 -> 12 (mod 13)
# 10 ^ 4 ->  3 (mod 13)
# 10 ^ 5 ->  4 (mod 13)
# (For "mod" you can see: https://en.wikipedia.org/wiki/Modulo_operation)
# Then the whole pattern repeats. Hence the following method:
# Multiply
# the right most digit of the number with the left most number in the sequence shown above,
# the second right most digit with the second left most digit of the number in the sequence.
# The cycle goes on and you sum all these products. Repeat this process until
# the sequence of sums is stationary.
def thirt(n):
    pattern = [1, 10, 9, 12, 3, 4]
    sum = 0
    while True:
        current_sum = 0
        for index, digit in enumerate(str(n)[::-1]):
            current_index = index % len(pattern)
            current_sum += int(digit) * pattern[current_index]
        if sum == current_sum:
            return sum
        sum = current_sum
        n = current_sum

# Create a function that takes in the sum and age difference of two people, calculates
# their individual ages, and returns a pair of values (oldest age first) if those exist or null/None if:
# sum < 0
# difference < 0
# Either of the calculated ages come out to be negative
def get_ages(sum_, diff):
    a = (sum_ - diff)/2
    b = sum_ - a
    if sum_ < 0 or diff < 0 or a < 0 or b < 0:
        return None
    return (b,a)

# Create a function add(n)/Add(n) which returns a function that always adds n to any number
# Note for Java: the return type and methods have not been provided to make it a bit more challenging.
def add(n):
    return lambda x: x + n

# Write a program that outputs the top n elements from a list.
# Example:
# largest(2, [7,6,5,4,3,2,1])
# => [6,7]
def largest(n,xs):
    return sorted(xs)[-n:]

# The aim of this kata is to split a given string into different strings
# of equal size (note size of strings is passed to the method)
def split_in_parts(s, part_length):
    words = []
    for i in range(0, len(s), part_length):
        words.append(s[i:i+part_length])
    return ' '.join(words)

# Positive integers that are divisible exactly by the sum of
# their digits are called Harshad numbers. The first few
# Harshad numbers are: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 18, ...
# We are interested in Harshad numbers where the product of its digit sum s
# and s with the digits reversed, gives the original number n. For example consider number 1729:
# its digit sum, s = 1 + 7 + 2 + 9 = 19
# reversing s = 91
# and 19 * 91 = 1729 --> the number that we started with.
# Complete the function which tests if a positive integer n is Harshad number,
# and returns True if the product of its digit sum and its digit sum reversed equals n; otherwise return False.
def number_joy(n):
    s = sum(int(i) for i in str(n))
    return s * int(str(s)[::-1]) == n

# Nickname Generator
# Write a function, nicknameGenerator that takes
# a string name as an argument and returns the first 3 or 4 letters as a nickname.
# If the 3rd letter is a consonant, return the first 3 letters.
# nickname("Robert") //=> "Rob"
# nickname("Kimberly") //=> "Kim"
# nickname("Samantha") //=> "Sam"
# If the 3rd letter is a vowel, return the first 4 letters.
def nickname_generator(name):
    return "Error: Name too short" if len(name) < 4 else name[:3+(name[2] in "aeiuo")]

# Return an output string that translates an input string s/$s by
# replacing each character in s/$s with a number representing
# the number of times that character occurs in s/$s and separating each number with the character(s) sep/$sep.
def freq_seq(s, sep):
    return sep.join(str(s.count(i)) for i in s)

# You are to write a function that takes a string as its first parameter.
# This string will be a string of words.
# You are expected to then use the second parameter, which will be an integer,
# to find the corresponding word in the given string. The first word would be represented by 0.
# Once you have the located string you are finally going to multiply by it the
# third provided parameter, which will also be an integer.
# You are additionally required to add a hyphen in between each word.
def modify_multiply(st, loc, num):
    return '-'.join(st.split()[loc] for i in range(num))

# Create a function which accepts one arbitrary string as an argument, and return a string of length 26.
# The objective is to set each of the 26 characters of the output string to either '1' or '0'
# based on the fact whether the Nth letter of the alphabet is present in the input (independent of its case).
# So if an 'a' or an 'A' appears anywhere in the input string (any number of times),
# set the first character of the output string to '1', otherwise to '0'.
# if 'b' or 'B' appears in the string, set the second character to '1', and so on for the rest of the alphabet.
def change(st):
    alp = "abcdefghijklmnopqrstuvwxyz"
    return "".join(["1" if c in st or c.upper() in st else "0" for c in alp]) if len(st) else "00000000000000000000000000"

# There are two lists, possibly of different lengths. The first one consists of keys,
# the second one consists of values. Write a function createDict(keys, values)
# that returns a dictionary created from keys and values. If there are not enough values,
# the rest of keys should have a None (JS null)value. If there not enough keys, just ignore the rest of values.
def createDict(keys, values):
    return {k:(values[e] if e<len(values) else None) for e,k in enumerate(keys)}

# dataand data1 are two strings with rainfall records of a few cities for months from January
# to December. The records of towns are separated by \n. The name of each town is followed by :.
# data and towns can be seen in "Your Test Cases:".
# Task:
# function: mean(town, strng) should return the average of rainfall
# for the city town and the strng data or data1 (In R and Julia this function is called avg).
# function: variance(town, strng) should return the variance of rainfall
# for the city town and the strng data or data1.
import re
def mean(town, strng):
    data_split = re.findall(r'.+(?:\n|$)', strng)
    for counter, town_info in enumerate(data_split):
        if town in town_info:
            town_name = re.match(r'\w+', town_info)
            if town != town_name.group():
                continue
            numbers = re.findall(r'\d+\.?\d+', town_info)
            float_numbers = [float(x) for x in numbers]
            return sum(float_numbers)/len(float_numbers)
    return -1
def variance(town, strng):
    data_split = re.findall(r'.+(?:\n|$)', strng)
    for counter, town_info in enumerate(data_split):
        if town in town_info:
            town_name = re.match(r'\w+', town_info)
            if town != town_name.group():
                continue
            numbers = re.findall(r'\d+\.?\d+', town_info)
            float_numbers = [float(x) for x in numbers]
            mean = sum(float_numbers)/len(float_numbers)
            squared_nums = [(x-mean)**2 for x in float_numbers]
            return sum(squared_nums)/(len(squared_nums))
    return -1

# Your task is to write a higher order function for chaining together a list of unary functions.
# In other words, it should return a function that does a left fold on the given functions.
def chained(functions):
    def apply(param):
        result = param
        for f in functions:
            result = f(result)
        return result
    return apply

Unscramble the eggs.

# The string given to your function has had an "egg"
# inserted directly after each consonant. You need to return the string before it became eggcoded.
def unscramble_eggs(word):
    return word.replace('egg','')

# Create function fib that returns n'th element of Fibonacci sequence (classic programming task).
def fibonacci(n: int) -> int:
    a, b = 0, 1
    for i in range(n):
        a,b = b, a+b
    return a

# In this Kata, you will be given an array of unique elements, and your task
# is to rearrange the values so that the first max value is followed by the first minimum,
# followed by second max value then second min value, etc.
def solve(arr):
    l = sorted(arr, reverse=True)
    ls = []
    for i in range(len(arr)//2+1):
        ls.append(l[i])
        ls.append(l[::-1][i])
    return ls[:-2] if len(arr)%2 == 0 else ls[:-1]

# You are given a string of letters and an array of numbers.
# The numbers indicate positions of letters that must be removed, in order,
# starting from the beginning of the array.
# After each removal the size of the string decreases (there is no empty space).
# Return the only letter left.
def last_survivor(letters, coords):
    for i in coords:
        letters = letters[:i] + letters[i+1:]
    return letters

# Complete the function power_of_two/powerOfTwo (or equivalent, depending on your language)
# that determines if a given non-negative integer is a power of two. From the corresponding Wikipedia entry:
# a power of two is a number of the form 2n where n is an integer,
# i.e. the result of exponentiation with number two as the base and integer n as the exponent.
# You may assume the input is always valid.
def power_of_two(n: int) -> list:
    i = 2
    while i < n:
        i=i*2
    return i == n if n!=1 else True

# Complete the function which takes a non-zero integer as its argument.
# If the integer is divisible by 3, return the string "Java".
# If the integer is divisible by 3 and divisible by 4, return the string "Coffee"
# If one of the condition above is true and the integer is even, add "Script" to the end of the string.
# If none of the condition is true, return the string "mocha_missing!"
def caffeine_buzz(n):
    i = ''
    if n % 3 == 0 and n % 4 == 0:
        i += 'Coffee'
    elif n % 3 == 0:
        i += 'Java'
    else:
        return "mocha_missing!"
    if n % 2 == 0:
        i += 'Script'
    return i

# A new task for you!
# You have to create a method, that corrects a given time string.
# There was a problem in addition, so many of the time strings are broken.
# Time is formatted using the 24-hour clock, so from 00:00:00 to 23:59:59.
def time_correct(t):
    if not t:
        return t
    try:
        h, m, s = map(int, t.split(":"))
        s = h * 3600 + m * 60 + s
        _, s = divmod(s, 86400)
        h, s = divmod(s, 3600)
        m, s = divmod(s, 60)
        return "{:02}:{:02}:{:02}".format(h, m, s)
    except ValueError:
        return None

# Print all numbers up to 3rd parameter which are multiple of both 1st and 2nd parameter.
# Python, Javascript, Java, Ruby versions: return results in a list/array
# NOTICE:
# Do NOT worry about checking zeros or negative values.
# To find out if 3rd parameter (the upper limit) is inclusive or not,
# check the tests, it differs in each translation
def multiples(s1,s2,s3):
    l = []
    for i in range(1,s3):
        if i %s1 == 0 and i % s2 == 0:
            l.append(i)
    return l

# The aim of the kata is to try to show how difficult it can be to calculate
# decimals of an irrational number with a certain precision.
# We have chosen to get a few decimals of the number
# "pi" using the following infinite series (Leibniz 1646–1716):
# PI / 4 = 1 - 1/3 + 1/5 - 1/7 + ... which gives an approximation of PI / 4.
# http://en.wikipedia.org/wiki/Leibniz_formula_for_%CF%80
# To have a measure of the difficulty we will count how many
# iterations are needed to calculate PI with a given precision of epsilon.
# There are several ways to determine the precision of the calculus but to keep
# things easy we will calculate PI within epsilon of your language Math::PI constant.
# In other words, given as input a precision of epsilon we will stop the
# iterative process when the absolute value of the difference between our
# calculation using the Leibniz series and the Math::PI constant of your language is less than epsilon.
# Your function returns an array or a string or a tuple depending
# on the language (See sample tests) with
# your number of iterations
# your approximation of PI with 10 decimals
from math import pi
def iter_pi(epsilon):
    count = 1
    my_pi = 4.0
    while abs(pi - my_pi) > epsilon:
        if count % 2:
            my_pi -= (1.0 / (count * 2 + 1)) * 4
        else:
            my_pi += (1.0 / (count * 2 + 1)) * 4
        count += 1
    return [count, round(my_pi, 10)]

# Create a function isDivisible(n,...) that checks if the first argument
# n is divisible by all other arguments (return true if no other arguments)
def is_divisible(*args):
    l =[*args]
    return all(l[0] % i == 0 for i in l[1:])

# Help Suzuki rake his garden!
# The monastery has a magnificent Zen garden made of white gravel and rocks and it
# is raked diligently everyday by the monks. Suzuki having a keen eye
# is always on the lookout for anything creeping into the garden that must
# be removed during the daily raking such as insects or moss.
# You will be given a string representing the garden such as:
VALID = {'gravel', 'rock'}
def rake_garden(garden):
    return ' '.join(a if a in VALID else 'gravel' for a in garden.split())

# Let us begin with an example:
# Take a number: 56789. Rotate left, you get 67895.
# Keep the first digit in place and rotate left the other digits: 68957.
# Keep the first two digits in place and rotate the other ones: 68579.
# Keep the first three digits and rotate left the rest: 68597. Now it is over
# since keeping the first four it remains only one digit which rotated is itself.
# You have the following sequence of numbers:
# 56789 -> 67895 -> 68957 -> 68579 -> 68597
# and you must return the greatest: 68957.
# Task
# Write function max_rot(n) which given a positive integer n
# returns the maximum number you got doing rotations similar to the above example.
# So max_rot (or maxRot or ... depending on the language) is such as:
def max_rot(n):
    maximum = n
    s = list(str(n))
    for i in range(len(s) - 1):
        s.append(s.pop(i))
        current = int(''.join(s))
        if current > maximum:
            maximum = current
    return maximum

# Scenario
# the rhythm of beautiful musical notes is drawing a Pendulum
# Beautiful musical notes are the Numbers
# Task
# Given an array/list [] of n integers , Arrange them in a way similar to the to-and-fro movement of a Pendulum
# The Smallest element of the list of integers , must come in center position of array/list.
# The Higher than smallest , goes to the right .
# The Next higher number goes to the left of minimum number and So on ,
# in a to-and-fro manner similar to that of a Pendulum.
def pendulum(values):
    sorted_values = sorted(values)
    mid = [sorted_values [0]]
    right = sorted_values[1::2]
    left = sorted_values[2::2]
    return left[::-1] + mid + right

# Sort the given array of strings in alphabetical order, case insensitive. For example:
def sortme(words):
    return sorted(words,key=lambda x: x.lower())

# Write a function that returns a sequence (index begins with 1) of all the even characters
# from a string. If the string is smaller than two characters or longer than 100 characters,
# the function should return "invalid string".
def even_chars(st):
    return [i for i in st[1::2]] if 1 < len(st) < 100 else 'invalid string'

# The Stanton measure of an array is computed as follows: count the number
# of occurences for value 1 in the array. Let this count be n. The Stanton measure
# is the number of times that n appears in the array.
# Write a function which takes an integer array and returns its Stanton measure.
# Examples
# The Stanton measure of [1, 4, 3, 2, 1, 2, 3, 2] is 3, because 1 occurs 2 times
# in the array and 2 occurs 3 times.
# The Stanton measure of [1, 4, 1, 2, 11, 2, 3, 1] is 1, because 1 occurs 3 times
# in the array and 3 occurs 1 time.
def stanton_measure(arr):
    return arr.count(arr.count(1))

# There exist two zeroes: +0 (or just 0) and -0.
# Write a function that returns true if the input number is -0 and false otherwise (True and False for Python).
# In JavaScript / TypeScript / Coffeescript the input will be a number.
# In Python / Java / C / NASM / Haskell / the input will be a float.
def is_negative_zero(n):
    return str(n) == '-0.0'

# Our loose definition of Vampire Numbers can be described as follows:
def vampire_test(x, y):
    l = [i for i in str(x * y)]
    w = str(x) + str(y)
    return all(i in l for i in w) and len(w) == len(l)

# Task
# Using n as a parameter in the function pattern, where n>0,
# \complete the codes to get the pattern (take the help of examples):
# Note: There is no newline in the end (after the pattern ends)
# Examples
# pattern(3) should return "1\n1*2\n1**3", e.g. the following:
def pattern(n):
    OUTPUT = '1{}{}'.format
    return '\n'.join(OUTPUT('*' * a, a + 1 if a else '') for a in range(n))

# The UK driving number is made up from the personal details of the driver. The individual letters
# and digits can be code using the below information
from dateutil.parser import parse
def driver(data):
    lic = ""
    if len(data[2]) >= 5:
          lic += data[2][:5]
    else:
            lic += data[2]
            while (len(lic) < 5): lic += "9"
    lic += (str(parse(data[3]).year))[2]
    month = parse(data[3]).month
    if data[4] == "F": month += 50
    month = str(month)
    if len(month) == 1: month = "0" + month
    lic += month
    day = str(parse(data[3]).day)
    if len(day) == 1: day = "0" + day
    lic += day
    lic += (str(parse(data[3]).year))[3]
    lic +=  data[0][:1]
    if (data[1]) != "":
        lic += data[1][:1]
    else:
        lic += "9"
    lic += "9AA"
    return lic.upper()

# Given the sum and gcd of two numbers, return those two numbers in ascending order.
# If the numbers do not exist, return -1, (or NULL in C, tuple (-1,-1)
# in C#, pair (-1,-1) in C++,None in Rust, array {-1,-1}  in Java and Golang).
def solve(s,g):
    for i in range(g, s+1, g):
        remainder = s - i
        if remainder % g == 0:
            return (i, remainder)
    return -1

# Write a function generateIntegers/generate_integers that accepts a single argument
# n/$n and generates an array containing the integers from 0 to n/$n inclusive.
# For example, generateIntegers(3)/generate_integers(3) should return [0, 1, 2, 3].
# n/$n can be any integer greater than or equal to 0.
def generate_integers(n):
    return list(range(n + 1))

# An element in an array is dominant if it is greater than all elements to its right.
# You will be given an array and your task will be to return a list of all dominant elements. For example:
def solve(arr):
    l = []
    for i in range(len(arr)):
        if max(arr[i:]) == arr[i] and arr[i] not in l:
            l.append(arr[i])
    return l

# Some people just have a first name; some people have first
# and last names and some people have first, middle and last names.
# You task is to initialize the middle names (if there is any).
def initialize_names(name):
    arr = name.split()
    l = []
    if len(arr)>2:
        l.append(arr[0])
        for i in arr[1:-1]:
            l.append(i[0].upper()+'.')
        l.append(arr[-1])
        return ' '.join(l)
    return name

# You are the developer working on a website which features a large counter
# on its homepage, proudly displaying the number of happy customers who have downloaded your companies software.
# You have been tasked with adding an effect to this counter to make it more interesting.
# Instead of just displaying the count value immediatley when the page loads,
# we want to create the effect of each digit cycling through its preceding
# numbers before stopping on the actual value.
# Task
# As a step towards achieving this; you have decided to create a function
# that will produce a multi-dimensional array out of the hit count value.
# Each inner dimension of the array represents an individual digit in the
# hit count, and will include all numbers that come before it, going back to 0.
# Rules
# The function will take one argument which will be a four character string representing hit count
# The function must return a multi-dimensional array containing four inner arrays
# The final value in each inner array must be the actual value to be displayed
# Values returned in the array must be of the type number
def counter_effect(hit_count):
    return [range(int(i)+1) for i in hit_count]

# Peter can see a clock in the mirror from the place he sits in the office. When he saw the clock shows 12:22
# He knows that the time is 11:38
# in the same manner:
# 05:25 --> 06:35
# 01:50 --> 10:10
# 11:58 --> 12:02
# 12:01 --> 11:59
# Please complete the function WhatIsTheTime(timeInMirror),
# where timeInMirror is the mirrored time (what Peter sees) as string.
# Return the real time as a string.
# Consider hours to be between 1 <= hour < 13.
# So there is no 00:20, instead it is 12:20.
# There is no 13:20, instead it is 01:20.
def what_is_the_time(time_in_mirror):
    hour = int(time_in_mirror[0:2])
    minute = int(time_in_mirror[3:5])
    if hour < 11:
        hour1 = 11 - hour
    else:
        hour1 = 23 - hour
    minute1 = 60 - minute
    if minute1 == 60:
        minute1 -=60
        hour1 += 1
    if hour1 > 12:
        hour1 -=12
    ans = ""
    if hour1 > 9 :
        ans = str(hour1) + ':'
    else:
        ans = '0' + str(hour1) + ':'
    if minute1 > 9:
        ans += str(minute1)
    else:
        ans += '0' + str(minute1)
    return ans

# Remove all exclamation marks from sentence except at the end.
def remove(s):
    count = 0
    j = s
    while j.endswith('!'):
        count += 1
        j = j[:-1]
    r = (len(s)-len(j))
    return j.replace('!', '') + '!' * r

# You have to create a function calcType, which receives 3 arguments: 2 numbers,
# and the result of an unknown operation performed on them (also a number).
# Based on those 3 values you have to return a string, that describes which operation
# was used to get the given result.
# The possible return strings are: "addition", "subtraction", "multiplication", "division".
def calc_type(a, b, res):
    if a+b==res:
        return 'addition'
    elif a-b==res:
        return 'subtraction'
    elif a*b==res:
        return 'multiplication'
    elif a/b==res:
        return 'division'

# You will be given an array which will include both integers and characters.
# Return an array of length 2 with a[0] representing the mean of the ten
# integers as a floating point number. There will always be 10 integers and 10 characters.
# Create a single string with the characters and return it as a[1] while maintaining the original order.
def mean(lst):
    return [sum(int(i) for i in lst if i.isdigit())/10, ''.join(j for j in lst if j.isalpha())]

# Write reverseList function that simply reverses lists.
def reverse_list(lst):
    return lst[::-1]


# Write function heron which calculates the area of a
# triangle with sides a, b, and c (x, y, z in COBOL). Heron 's formula:
# s∗(s−a)∗(s−b)∗(s−c)\sqrt {s * (s - a) * (s - b) * (s - c)} s∗(s−a)∗(s−b)∗(s−c)
# Output should have 2 digits precision.
def heron(a, b, c):
    i=(a+b+c)/2
    return round((i*(i-a)*(i-b)*(i-c))**.5, 2)

# A zero-indexed array arr consisting of n integers is given. The dominator of array
# arr is the value that occurs in more than half of the elements of arr.
# For example, consider array arr such that arr = [3,4,3,2,3,1,3,3]
# The dominator of arr is 3 because it occurs in 5 out of 8 elements of arr and 5 is more than a half of 8.
# Write a function dominator(arr) that, given a zero-indexed array arr consisting of n integers,
# returns the dominator of arr. The function should return −1 if array does not have a dominator.
# All values in arr will be >=0.
def dominator(arr):
    w = [i for i in arr if arr.count(i) > len(arr)//2]
    return w[0] if w else -1

# Christmas is coming, and Santa has a long list to go through, to find who deserves presents for the
# big day. Go through a list of children, and return
# a list containing every child who appeared on Santa's list.
# Do not add any child more than once. Output should be sorted.
# Comparison should be case sensitive and the returned list should contain only one copy of
# each name: "Sam" and "sam" are different, but "sAm" and "sAm" are not.
def find_children(santas_list, children):
    return sorted(set([child for child in children if child in santas_list]))

# Create a method that takes an array/list as an input,
# and outputs the index at which the sole odd number is located.
# This method should work with arrays with negative numbers. If there are
# no odd numbers in the array, then the method should output -1.
def odd_one(arr):
    try:
        return arr.index(max([i for i in arr if i%2!=0]))
    except:
        return -1

# Lot of museum allow you to be a member, for a certain
# amount amount_by_year you can have unlimitted acces to the museum.
# In this kata you should complete a function in order to know after how many visit it
# will be better to take an annual pass. The function take 2 arguments annual_price and individual_price.
import math
def how_many_times(annual_price, individual_price):
    return math.ceil(annual_price/individual_price)

# Move all exclamation marks to the end of the sentence
def remove(s):
    count = s.count('!')
    return s.replace('!', '') + '!'*count

# Digital Cypher assigns to each letter of the alphabet unique number. For example:
# a  b  c  d  e  f  g  h  i  j  k  l  m
# 1  2  3  4  5  6  7  8  9 10 11 12 13
# n  o  p  q  r  s  t  u  v  w  x  y  z
# 14 15 16 17 18 19 20 21 22 23 24 25 26
# Instead of letters in encrypted word we write the corresponding number, eg. The word scout:
#  s  c  o  u  t
# 19  3 15 21 20
# Then we add to each obtained digit consecutive digits from the key. For example. In case of key equal to 1939 :
def encode(message, key):
    letter_dict = {
        'a': 1,'b': 2,
        'c': 3,'d': 4,'e': 5,'f': 6,'g': 7,'h': 8,'i': 9,'j': 10,'k': 11,'l': 12,'m': 13,'n': 14,'o': 15,'p': 16,
        'q': 17,'r': 18,'s': 19,'t': 20,'u': 21,'v': 22,'w': 23,'x': 24,'y': 25,'z': 26
        }
    num_list = []
    key_list = str(key)
    x = 0
    for i in message:
        num_list.append(letter_dict[i] + int(key_list[x]))
        x += 1
        if x >= len(key_list):
            x = 0
    return num_list

# Is every value in the array an array?
# This should only test the second array dimension of the array.
# The values of the nested arrays don't have to be arrays.
def arr_check(arr):
    return all(type(i) == list for i in arr)

# Your task is very simple. Just write a function takes an input string
# of lowercase letters and returns true/false depending on whether the string is in alphabetical order or not.
# Examples (input -> output)
# "kata" -> false ('a' comes after 'k')
# "ant" -> true (all characters are in alphabetical order)
def alphabetic(s):
    return s == "".join(sorted(s))

# Write function replaceAll (Python: replace_all) that will replace all occurrences of an item with another.
# Python / JavaScript: The function has to work for strings and lists.
# Example: replaceAll [1,2,2] 1 2 -> in list [1,2,2] we replace 1 with 2 to get new list [2,2,2]
def replace_all(obj, find, replace):
    if type(obj) == list:
        return [replace if i == find else i for i in obj]
    return obj.replace(find, replace)

# Learning to code around your full time job is taking over your life. You realise
# that in order to make significant steps quickly, it would help to go to a coding bootcamp in London.
# Problem is, many of them cost a fortune, and those that don't still
# involve a significant amount of time off work - who will pay your mortgage?!
# To offset this risk, you decide that rather than leaving work totally, you will request a
# sabbatical so that you can go back to work post bootcamp and be paid while you look for your next role.
# You need to approach your boss. Her decision will be based on three parameters:
# val = your value to the organisation
# happiness = her happiness level at the time of asking and finally
# The numbers of letters from 'sabbatical' that are present in string s.
# Note that if s contains three instances of the letter 'l', that still
# scores three points, even though there is only one in the word sabbatical.
# If the sum of the three parameters (as described above) is > 22, return 'Sabbatical!
# Boom!', else return 'Back to your desk, boy.'.
# FUNDAMENTALSSTRINGSARRAYSMATHEMATICS
import re
def sabb(s, value, happiness):
    letters = re.findall('[sabatical]', s)
    return 'Sabbatical! Boom!' if len(letters) + value + happiness > 22 else 'Back to your desk, boy.'

# Given an array, return the difference between the count of even numbers
# and the count of odd numbers. 0 will be considered an even number.
# For example:
# solve([0,1,2,3]) = 0 because there are two even numbers and two odd numbers. Even - Odd = 2 - 2 = 0.
# Let's now add two letters to the last example:
# solve([0,1,2,3,'a','b']) = 0. Again, Even - Odd = 2 - 2 = 0. Ignore letters.
# The input will be an array of lowercase letters and numbers only.
# In some languages (Haskell, C++, and others), input will be an array of strings:
def solve(a):
    count_e = 0
    count_o = 0
    for elem in a:
        if str(elem).isdigit():
            if elem %2==0:
                count_e += 1
            elif elem %2!=0:
                count_o += 1
    return count_e - count_o

# Implement the method length, which accepts a linked list (head), and returns the length of the list.
# For example: Given the list: 1 -> 2 -> 3 -> 4, length should return 4.
def length(head):
    if head == None:
        return 0
    elif head:
        number = 1
        while head.next:
              head = head.next
              number += 1
        return number

# In this Kata, we will check if a string contains consecutive letters
# as they appear in the English alphabet and if each letter occurs only once.
def solve(s):
    return "".join(sorted(s)) in "abcdefghijklmnopqrstuvwxyz"

# So you've found a meeting room - phew! You arrive there ready to present,
# and find that someone has taken one or more of the chairs!!
# You need to find some quick.... check all the other meeting rooms to see if all of the chairs are in use.
# Your meeting room can take up to 8 chairs. need will tell you
# how many have been taken. You need to find that many.=
# Find the spare chairs from the array of meeting rooms. Each meeting
# room tuple will have the number of occupants as a string.
# Each occupant is represented by 'X'. The room tuple will also
# have an integer telling you how many chairs there are in the room.
# You should return an array of integers that shows how many chairs you take
# from each room in order, up until you have the required amount.
# example:
# [['XXX', 3], ['XXXXX', 6], ['XXXXXX', 9], ['XXX',2]] when you need 4 chairs:
# result -> [0, 1, 3] no chairs free in room 0, take 1 from room 1, take 3 from room 2. no need to
# consider room 3 as you have your 4 chairs already.
# If you need no chairs, return "Game On". If there aren't enough spare chairs available, return "Not enough!".
def meeting(rooms, need):
    if need == 0:
        return 'Game On'
    count = []
    for room in rooms:
        if room[1] - len(room[0]) >0:
            if room[1] - len(room[0]) >= need:
                count.append(need)
                return count
            else:
                count.append(room[1] - len(room[0]))
                need -= room[1] - len(room[0])
        else:
            count.append(0)
    return "Not enough!"

# As you may know, once some people pass their teens, they jokingly only celebrate their 20th or 21st birthday,
# forever. With some maths skills, that's totally possible - you only need to select the correct number base!
# For example, if they turn 32, that's exactly 20 - in base 16... Already 39? That's just 21, in base 19!
# Your task is to translate the given age to the much desired 20 (or 21) years,
# and indicate the number base, in the format specified below.
# Note: input will be always > 21
def womens_age(n):
    base = n // 2
    remainder = n % 2
    return "{}? That's just {}, in base {}!".format(n, 20 + remainder, base)

# You are going to be given an array of integers. Your job is to take that array
# and find an index N where the sum of the integers to the left of N is equal
# to the sum of the integers to the right of N. If there is no index that would make this happen, return -1.
# For example:
# Let's say you are given the array {1,2,3,4,3,2,1}:
# Your function will return the index 3, because at the 3rd position of the array,
# the sum of left side of the index ({1,2,3}) and the sum of the right side of the index ({3,2,1}) both equal 6.
# Let's look at another one.
# You are given the array {1,100,50,-51,1,1}:
# Your function will return the index 1, because at the 1st position of the array,
# the sum of left side of the index ({1}) and the sum of the right side of the index ({50,-51,1,1}) both equal 1.
# Last one:
# You are given the array {20,10,-80,10,10,15,35}
# At index 0 the left side is {}
# The right side is {10,-80,10,10,15,35}
# They both are equal to 0 when added. (Empty arrays are equal to 0 in this problem)
# Index 0 is the place where the left side and right side are equal.
# Note: Please remember that in most programming/scripting languages the index of an array starts at 0.
def find_even_index(arr):
    for i in range(len(arr)):
        if sum(arr[:i]) == sum(arr[i+1:]):
            return i
    return -1

# Remove words from the sentence if they contain exactly one exclamation mark.
# Words are separated by a single space, without leading/trailing spaces.
def remove(s):
    return ' '.join(filter(lambda word: word.count('!') != 1, s.split(' ')))

# With a friend we used to play the following game on a chessboard (8, rows, 8 columns). On
# the first row at the bottom we put numbers:
# 1/2, 2/3, 3/4, 4/5, 5/6, 6/7, 7/8, 8/9
# On row 2 (2nd row from the bottom) we have:
# 1/3, 2/4, 3/5, 4/6, 5/7, 6/8, 7/9, 8/10
# On row 3:
# 1/4, 2/5, 3/6, 4/7, 5/8, 6/9, 7/10, 8/11
# until last row:
# 1/9, 2/10, 3/11, 4/12, 5/13, 6/14, 7/15, 8/16
# When all numbers are on the chessboard each in turn we toss a coin. The one who get
# "head" wins and the other gives him, in dollars, the sum of the numbers on the chessboard.
# We play for fun, the dollars come from a monopoly game!
# Task
# How much can I (or my friend) win or loses for each game if the chessboard has n rows
# and n columns? Add all of the fractional values on an n by n sized board and give the
# answer as a simplified fraction.
# See Sample Tests for each language
# Ruby, Python, JS, Coffee, Clojure, PHP, Elixir, Crystal, Typescript, Go:
# The function called 'game' with parameter n (integer >= 0) returns as result an
# irreducible fraction written as an array of integers: [numerator, denominator].
# If the denominator is 1 return [numerator].
def game(n):
    if n == 0: return [0]
    if n == 1: return [1, 2]
    if n == 2: return [3, 2]
    if n == 3: return [9, 2]
    s, step = 4.5, 3.5
    for _ in range(n-3):
        s = s + step
        step += 1.0
    if int(s) == s: return [s]
    else: return [int(str(2*int(s)+1)), 2]

# You will be given an array of numbers.
# For each number in the array you will need to create an object.
# The object key will be the number, as a string. The value will be the corresponding character code, as a string.
# Return an array of the resulting objects.
# All inputs will be arrays of numbers.
# All character codes are valid lower case letters. The input array will not be empty.
def num_obj(s):
    return [{str(i) : chr(i)} for i in s]

# The prime numbers are not regularly spaced. For example from 2 to
# 3 the step is 1. From 3 to 5 the step is 2. From 7 to 11 it is 4.
# Between 2 and 50 we have the following pairs of 2-steps primes:
# 3, 5 - 5, 7, - 11, 13, - 17, 19, - 29, 31, - 41, 43
# We will write a function step with parameters:
# g (integer >= 2) which indicates the step we are looking for,
# m (integer >= 2) which gives the start of the search (m inclusive),
# n (integer >= m) which gives the end of the search (n inclusive)
# In the example above step(2, 2, 50) will return [3, 5] which is the first pair between 2 and 50 with a 2-steps.
# So this function should return the first pair of the two prime numbers spaced with a step of g between the
# limits m, n if these g-steps prime numbers exist otherwise
# nil or null or None or Nothing or [] or "0, 0" or {0, 0} or 0 0 or "" (depending on the language).
def step(g, m, n):
    prime_list = []
    for num in range(m, n):
        number_prime = isPrime(num)
        prime_list.append(number_prime)
        if number_prime == True:
            if len(prime_list) > g:
                if prime_list[num-g-m] == True:
                    return [num-g, num]
            else:
                previous_prime = num
def isPrime(num):
    for i in range(2, num):
        if num % i == 0:
            return False
        elif i*i > num:
            return True
    return True

# What is your favourite day of the week? Check if it's the most frequent day of the week in the year.
# You are given a year as integer (e. g. 2001). You should
# return the most frequent day(s) of the week in that year.
# The result has to be a list of days sorted by the order
# of days in week (e. g. ['Monday', 'Tuesday'], ['Saturday', 'Sunday'],
# ['Monday', 'Sunday']). Week starts with Monday.
# Input: Year as an int.
# Output: The list of most frequent days sorted by the order of days in week (from Monday to Sunday).
# Preconditions:
# Week starts on Monday.
# Year is between 1583 and 4000.
# Calendar is Gregorian.
from datetime import date
def most_frequent_days(year):
    names = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
    start = date(year,1,1).weekday()
    end = date(year, 12, 31).weekday()
    days = list(range(start, 7)) + list(range(0 ,end +1))
    total = days.count(max(days,key=days.count))
    result = []
    for day in [0,1,2,3,4,5,6]:
        if day in days:
            if days.count(day) == total:
                result.append(day)
    return list(map(lambda x: names[x], result))

# Kata Task
# stations is a list/array of distances (miles) from one station to the next along the Pony Express route.
# Implement the riders method/function, to return how many riders are necessary
# to get the mail from one end to the other.
# NOTE: Each rider travels as far as he can, but never more than 100 miles.
def riders(stations):
	riders, travelled = 1, 0
	for miles in stations:
		if travelled + miles > 100:
			riders += 1
			travelled = miles
		else:
			travelled += miles
	return riders

# Remove all exclamation marks from the end of words. Words are separated by a
# single space. There are no exclamation marks within a word.
def remove(s):
    l = []
    for i in s.split():
        while i.endswith('!'):
            i = i[:-1]
        l.append(i)
    return ' '.join(l)

# Given an array, find the duplicates in that array, and return a new array of those
# duplicates. The elements of the returned array should appear in the order when they first appeared as duplicates.
# Note: numbers and their corresponding string representations should not
# be treated as duplicates (i.e., "1" != 1).
def duplicates(array):
    l = []
    d = []
    for elem in array:
        if elem not in l:
            l.append(elem)
            continue
        elif elem in l and elem not in d:
            d.append(elem)
    return d

# The depth of an integer n is defined to be how many multiples
# of n it is necessary to compute before all 10 digits have appeared at least once in some multiple.
def compute_depth(n):
    l = []
    count = 1
    while len(l)<10:
        s = n*count
        for i in str(s):
            if i not in l:
                l.append(i)
        count+=1
    return count-1

# Some people have been killed!
# You have managed to narrow the suspects down to just a few. Luckily, you know every
# person who those suspects have seen on the day of the murders.
# Task.
# Given a dictionary with all the names of the suspects and everyone that they have
# seen on that day which may look like this:
def killer(suspect_info, dead):
    for k,v in suspect_info.items():
        if all(i in v for i in dead):
            return k

# You must create a function, spread, that takes a function and
# a list of arguments to be applied to that function. You must make this function return
# the result of calling the given function/lambda with the given arguments.
def spread(func, args):
    return func(*args)

# Complete the function that takes an array of words.
# You must concatenate the nth letter from each word to construct a new
# word which should be returned as a string, where n is the position of the word in the list.
def nth_char(words):
    word = ''
    i = 0
    while i < len(words):
        word += words[i][i]
        i+=1
    return word

# In this kata, your job is to create a class Dictionary which you can add words to and their entries. Example:
class Dictionary():
    def __init__(self):
        self.d = {}

    def newentry(self, word, definition):
        self.word = word
        self.definition = definition
        self.d[self.word] = self.definition

    def look(self, key):
        self.key = key
        try:
            return self.d[self.key]
        except:
            return f"Can't find entry for {self.key}"

# Write a generic function chainer
# Write a generic function chainer that takes a starting value,
# and an array of functions to execute on it (array of symbols for Ruby).
# The input for each function is the output of the previous function
# (except the first function, which takes the starting value as its input).
# Return the final value after execution is complete.
def chain(init_val, functions):
    for func in functions:
        init_val = func(init_val)
    return init_val

# You'll be given a list of two strings, and each will contain exactly one colon (":") in the middle
# (but not at beginning or end). The length of the strings, before and after the colon, are random.
# Your job is to return a list of two strings
# (in the same order as the original list), but with the characters after each colon swapped.
def tail_swap(strings):
    l = []
    final = []
    for i in strings:
        for elem in i.split(':'):
            l.append(elem)
    final.append(l[0] + ':' + l[3])
    final.append(l[2] + ':' + l[1])
    return final

# Slot machine (American English), informally fruit machine (British English), puggy
# (Scottish English slang), the slots (Canadian and American English), poker machine
# (or pokies in slang) (Australian English and New Zealand English) or
# simply slot (American English), is a casino gambling machine with three
# or more reels which spin when a button is pushed. Slot machines are
# also known as one-armed bandits because they were originally operated by one lever on
# the side of the machine as distinct from a button on the front panel,
# and because of their ability to leave the player in debt and impoverished.
# Many modern machines are still equipped with a legacy lever in addition to the button. (Source Wikipedia)
# Task
# You will be given three reels of different images and told at
# which index the reels stop. From this information your job is to return the score of the resulted reels.
# Rules
# 1. There are always exactly three reels
# 2. Each reel has 10 different items.
# 3. The three reel inputs may be different.
# 4. The spin array represents the index of where the reels finish.
# 5. The three spin inputs may be different
# 6. Three of the same is worth more than two of the same
# 7. Two of the same plus one "Wild" is double the score.
# 8. No matching items returns 0.
def fruit(reels, spins):
    triple = {
        'Wild Wild Wild': 100, 'Star Star Star': 90, 'Bell Bell Bell': 80,
        'Shell Shell Shell': 70, 'Seven Seven Seven': 60, 'Cherry Cherry Cherry': 50,
        'Bar Bar Bar': 40, 'King King King': 30, 'Queen Queen Queen': 20, 'Jack Jack Jack': 10
    }
    double = {
        'Wild': 10, 'Star': 9, 'Bell': 8, 'Shell': 7, 'Seven': 6, 'Cherry': 5, 'Bar': 4, 'King': 3,
        'Queen': 2, 'Jack': 1
    }
    l = [reels[0][spins[0]], reels[1][spins[1]], reels[2][spins[2]]]
    if l[0] == l[1] or l[0] == l[2] or l[1] == l[2]:
        if l[0] == l[1] == l[2]:
            return triple[' '.join(sorted(l))]
        elif (l.count(l[0]) == 2 or l.count(l[1]) == 2) and l.count('Wild') != 1:
            for elem in l:
                if l.count(elem) == 2:
                    return double[elem]
        elif (l.count(l[0]) == 2 or l.count(l[1]) == 2) and l.count('Wild') == 1:
            for elem in l:
                if l.count(elem) == 2:
                    return double[elem] * 2
    return 0

# If you have completed the Tribonacci sequence kata, you would know by now that
# mister Fibonacci has at least a bigger brother. If not, give it a quick look to get how things work.
# Well, time to expand the family a little more: think of
# a Quadribonacci starting with a signature of 4 elements and each following element is
# the sum of the 4 previous, a Pentabonacci (well Cinquebonacci would probably sound a bit more italian,
# but it would also sound really awful) with a signature of 5 elements
# and each following element is the sum of the 5 previous, and so on.
# Well, guess what? You have to build a Xbonacci function that takes a signature of X elements -
# and remember each next element is the sum of the last X elements -
# and returns the first n elements of the so seeded sequence.
def Xbonacci(signature,n):
    result = signature[:]
    for x in range(n-len(signature)):
        current_fib = 0
        start = len(result) - len(signature)
        for y in result[start:]:
            current_fib += y
        result.append(current_fib)
    return result[:n]

# You love coffee and want to know what beans you can afford to buy it.
# The first argument to your search function will be a number which represents your budget.
# The second argument will be an array of coffee bean prices.
# Your 'search' function should return the stores that sell coffee within your budget.
# The search function should return a string of prices for the coffees
# beans you can afford. The prices in this string are to be sorted in ascending order.
def search(budget, prices):
    return ','.join(str(i) for i in sorted(list(filter(lambda x: x<= budget, prices))))

# Write a function called "filterEvenLengthWords".
# Given an array of strings, "filterEvenLengthWords" returns an array
# containing only the elements of the given array whose length is an even number.
# var output = filterEvenLengthWords(['word', 'words', 'word', 'words']);
# console.log(output); // --> ['word', 'word']
def filter_even_length_words(words):
    return [word for word in words if len(word) % 2 == 0]

# Write a function that takes a list (in Python) or array (in other languages)
# of numbers, and makes a copy of it.
# Note that you may have troubles if you do not return an actual copy,
# item by item, just a pointer or an alias for an existing list or array.
# If not a list or array is given as a parameter in interpreted languages, the function should raise an error.
def copy_list(l):
    copy = [i for i in l]
    return copy

# One suggestion to build a satisfactory password is to start with a memorable phrase
# or sentence and make a password by extracting the first letter of each word.
# ven better is to replace some of those letters with numbers (e.g., the letter
# O can be replaced with the number 0):
# instead of including i or I put the number 1 in the password;
# instead of including o or O put the number 0 in the password;
# instead of including s or S put the number 5 in the password.
def make_password(phrase):
    d = {'i': '1', 'o': '0', 's':'5'}
    word = [i[0] for i in phrase.split()]
    return ''.join(d[i.lower()] if i.lower() in d else i for i in word)

# Sort the Vowels!
# In this kata, we want to sort the vowels in a special format.
# Task
# Write a function which takes a input string s and return a string in the following way:
def sort_vowels(s):
    try:
        return '\n'.join(i+'|' if i.lower() not in 'aeoiu' else '|'+i for i in s)
    except:
        return ''

# Vowel harmony is a phenomenon in some languages. It means that "A
# vowel or vowels in a word are changed to sound the same (thus "in harmony.")" (wikipedia).
# This kata is based on vowel harmony in Hungarian.
# Task:
# Your goal is to create a function dative() (Dative() in C#) which returns
# the valid form of a valid Hungarian word w in dative case i. e.
# append the correct suffix nek or nak to the word w based on vowel harmony rules.
# Vowel Harmony Rules (simplified)
# When the last vowel in the word is
# a front vowel (e, é, i, í, ö, ő, ü, ű) the suffix is -nek
# a back vowel (a, á, o, ó, u, ú) the suffix is -nak
def dative(word):
    for letter in word[::-1]:
        if letter in "eéiíöőüű":
            return word + "nek"
        elif letter in "aáoóuú":
            return word + "nak"

# A Cartesian coordinate system is a coordinate system that specifies each point uniquely
# in a plane by a pair of numerical coordinates, which are the signed distances to
# the point from two fixed perpendicular directed lines, measured in the same unit of length.
# The сoordinates of a point in the grid are written as (x,y). Each point in a
# coordinate system has eight neighboring points. Provided that the grid step = 1.
# It is necessary to write a function that takes a coordinate on the x-axis and y-axis
# and returns a list of all the neighboring points. Points inside your returned list
# need not be sorted (any order is valid).
def cartesian_neighbor(x, y):
    return [(x - 1, y - 1), (x - 1, y), (x - 1, y + 1), (x, y - 1), (x, y + 1), (x + 1, y - 1), (x + 1, y),
            (x + 1, y + 1)]

# i is the imaginary unit, it is defined by i²=−1i² = -1i²=−1,
# therefore it is a solution to x²+1=0x² + 1 = 0x²+1=0.
# Your Task
# Complete the function pofi that returns iii to the power of a given non-negative integer
# in its simplest form, as a string (answer may contain iii).
def pofi(n):
    return ['1','i','-1','-i'][n % 4]

# Count how often sign changes in array.
# result
# number from 0 to ... . Empty array returns 0
def catch_sign_change(lst):
    return sum((x>=0)!=(y>=0) for x, y in zip(lst,lst[1:]))

# When you sign up for an account somewhere, some websites do not actually store
# your password in their databases. Instead, they will transform your password into something
# else using a cryptographic hashing algorithm.
# After the password is transformed, it is then called a password hash. Whenever you try to login,
# the website will transform the password you tried
# using the same hashing algorithm and simply see if the password hashes are the same.
# Create the function that converts a given string into an md5 hash. The return value
# should be encoded in hexadecimal.
from hashlib import md5
def pass_hash(str):
    return md5(str.encode()).hexdigest()

# In this kata you parse RGB colors represented by strings.
# The formats are primarily used in HTML and CSS.
# Your task is to implement a function which takes a color as a string and returns
# the parsed color as a map (see Examples).
def parse_html_color(color):
    color = PRESET_COLORS.get(color.lower(), color)
    if len(color) == 7:
        r, g, b = (int(color[i:i+2], 16) for i in range(1, 7, 2))
    else:
        r, g, b = (int(color[i+1]*2, 16) for i in range(3))
    return dict(zip("rgb", (r, g, b)))

# Digital Cypher assigns to each letter of the alphabet unique number. For example:
# a  b  c  d  e  f  g  h  i  j  k  l  m
# 1  2  3  4  5  6  7  8  9 10 11 12 13
# n  o  p  q  r  s  t  u  v  w  x  y  z
# 14 15 16 17 18 19 20 21 22 23 24 25 26
# Instead of letters in encrypted word we write the corresponding number, eg. The word scout:
# s  c  o  u  t
# 19  3 15 21 20
# Then we add to each obtained digit consecutive digits from the key. For example. In case of key equal to 1939 :
def decode(code, key):
    key=str(key)
    return "".join([chr(code[i] +96 - int(key[i%len(key)])) for i in range(0, len(code))])

# Write a program that, given a word, computes the scrabble score for that word.
def scrabble_score(st):
    w1 = 'A,E,I,O,U,L,N,R,S,T'
    w2 = 'D,G'
    w3 = 'B,C,M,P'
    w4 = 'F,H,V,W,Y'
    w5 = 'K'
    w6 = 'JX'
    w7 = 'QZ'
    count = 0
    st.replace(' ', '')
    for i in st.upper():
        if i in w1:
            count +=1
        elif i in w2:
            count += 2
        elif i in w3:
            count += 3
        elif i in w4:
            count += 4
        elif i in w5:
            count += 5
        elif i in w6:
            count += 8
        elif i in w7:
            count += 10
    return count

# Your story
# You've always loved both Fizz Buzz katas and cuckoo clocks, and when
# you walked by a garage sale and saw an ornate cuckoo clock with a missing pendulum,
# and a "Beyond-Ultimate Raspberry Pi Starter Kit"
# filled with all sorts of sensors and motors and other components,
# it's like you were suddenly hit by a beam of light and knew that it was your mission to
# combine the two to create a computerized Fizz Buzz cuckoo clock!
# You took them home and set up shop on the kitchen table, getting
# more and more excited as you got everything working together just perfectly.
# Soon the only task remaining was to write a function to select from the
# sounds you had recorded depending on what time it was:
# Your plan
# When a minute is evenly divisible by three, the clock will say the word "Fizz".
# When a minute is evenly divisible by five, the clock will say the word "Buzz".
# When a minute is evenly divisible by both, the clock will say "Fizz Buzz", with two exceptions:
# On the hour, instead of "Fizz Buzz", the clock door will open, and the cuckoo bird will
# come out and "Cuckoo" between one and twelve times depending on the hour.
# On the half hour, instead of "Fizz Buzz", the clock door will open, and the cuckoo will
# come out and "Cuckoo" just once.
# With minutes that are not evenly divisible by either three or five, at first you had
# intended to have the clock just say the numbers ala Fizz Buzz, but then you decided
# at least for version 1.0 to just have the clock make a quiet, subtle "tick" sound for
# a little more clock nature and a little less noise.
# Your input will be a string containing hour and minute values in 24-hour time,
# separated by a colon, and with leading zeros. For example, 1:34 pm would be "13:34".

# Your return value will be a string containing the combination of Fizz, Buzz, Cuckoo,
# and/or tick sounds that the clock needs to make at that time, separated by spaces.
# Note that although the input is in 24-hour time, cuckoo clocks' cuckoos are in 12-hour time.
def fizz_buzz_cuckoo_clock(time):
    hh, mm = map(int, time.split(":"))
    if mm ==  0:return " ".join(["Cuckoo"] * (hh % 12 or 12))
    elif mm == 30:return "Cuckoo"
    elif mm % 15 == 0:return "Fizz Buzz"
    elif mm %  3 == 0:return "Fizz"
    elif mm %  5 == 0:return "Buzz"
    else:return "tick"

# Can Santa save Christmas?
# Oh no! Santa's little elves are sick this year. He has to distribute the presents on his own.
# But he has only 24 hours left. Can he do it?
# Your Task:
# You will get an array as input with time durations as string
# in the following format: HH:MM:SS. Each duration represents the
# time taken by Santa to deliver a present. Determine whether he can do it
# in 24 hours or not. In case the time required to deliver all of the presents is exactly 24 hours,
# Santa can complete the delivery ;-).
def determineTime(arr):
    total_sec = sum(h * 3600 + m * 60 + s for h, m, s in [list(map(int, elem.split(':'))) for elem in arr])
    return total_sec <= 86400

# Write a function that will check whether ANY permutation of the characters of the input string
# is a palindrome. Bonus points for a solution that is efficient and/or
# that uses only built-in language functions. Deem yourself brilliant if
# you can come up with a version that does not use any function whatsoever.
# Example
# madam -> True
# adamm -> True
# junk -> False
# Hint
# The brute force approach would be to generate all the permutations of the
# string and check each one of them whether it is a palindrome. However,
# an optimized approach will not require this at all.
permute_a_palindrome=lambda s:bool(len(list(filter(lambda x:x%2!=0,[s.count(char) for char in set(s)])))<2)

# Linked Lists - Get Nth
# Implement a GetNth() function that takes a linked list and an integer
# index and returns the node stored at the Nth index position. GetNth()
# uses the C numbering convention that the first node is index 0, the second is index 1, ... and so on.
# So for the list 42 -> 13 -> 666, GetNth(1) should return Node(13);
# getNth(1 -> 2 -> 3 -> null, 0).data === 1
# getNth(1 -> 2 -> 3 -> null, 1).data === 2
# The index should be in the range [0..length-1]. If it is not,
# or if the list is empty, GetNth() should throw/raise
# an exception (ArgumentException in C#, InvalidArgumentException in PHP, Exception in Java).
class Node(object):
    def __init__(self, data):
        self.data = data
        self.next = None
def get_nth(node, index):
    if node and index >= 0: return node if index < 1 else get_nth(node.next, index - 1)
    raise ValueError

# Implement String#ipv4_address?, which should return true if given object is an IPv4 address
# - four numbers (0-255) separated by dots.
# It should only accept addresses in canonical representation, so no leading 0s, spaces etc.
import re
def ipv4_address(address):
    regex = re.compile(r'''
    #      200-249   | 250-255 | 100-109| 0-99 110-199
    \b([2]([0-4][0-9]|[5][0-5])|(10[0-9]|[1]?[1-9]?[0-9]))\.
    ([2]([0-4][0-9]|[5][0-5])|(10[0-9]|[1]?[1-9]?[0-9]))\.
    ([2]([0-4][0-9]|[5][0-5])|(10[0-9]|[1]?[1-9]?[0-9]))\.
    ([2]([0-4][0-9]|[5][0-5])|(10[0-9]|[1]?[1-9]?[0-9]))\b    
    ''', re.VERBOSE)
    mo = regex.match(address)
    if mo is None:
        return False
    elif  mo.group() == address:
        return (bool(mo))
    else:
        return False

# Peter lives on a hill, and he always moans about the way to his home. "It's always just
# up. I never get a rest". But you're pretty sure that at least at one point Peter's
# altitude doesn't rise, but fall. To get him, you use a nefarious plan:
# you attach an altimeter to his backpack and you read the data from his way back at the next day.
# Task
# You're given a list of compareable elements:
def is_monotone(heights):
    return heights == sorted(heights) if heights else True

# Write a function that takes in a binary string and returns the equivalent
# decoded text (the text is ASCII encoded).
# Each 8 bits on the binary string represent 1 character on the ASCII table.
# The input string will always be a valid binary string.
# Characters can be in the range from "00000000" to "11111111" (inclusive)
# Note: In the case of an empty binary string your function should return an empty string.
import binascii
def binary_to_string(binary):
    try:
        input_string=int(binary, 2)
        Total_bytes= (input_string.bit_length() +7) // 8
        input_array = input_string.to_bytes(Total_bytes, "big")
        ASCII_value=input_array.decode()
        return ASCII_value
    except:
        return '' if binary == '' else None

# Each exclamation mark's weight is 2; each question mark's weight is 3. Putting two
# strings left and right on the balance - are they balanced?
# If the left side is more heavy, return "Left"; if the right side
# is more heavy, return "Right"; if they are balanced, return "Balance".
def balance(left, right):
    count_l = 0
    count_r = 0
    d = {'!':2, '?':3}
    for i in left:
        count_l += d[i]
    for i in right:
        count_r += d[i]
    return 'Balance' if count_l == count_r else 'Left' if count_l > count_r else 'Right'

# iven a string that includes alphanumeric characters ("3a4B2d") return
# the expansion of that string: The numeric values represent the occurrence of each letter preceding that numeric
# value. There should be no numeric characters in the final string.
# Notes
# The first occurrence of a numeric value should be the number of
# times each character behind it is repeated, until the next numeric value appears
# If there are multiple consecutive numeric characters, only the last one should be used (ignore the
# previous ones)
# Empty strings should return an empty string.
# Your code should be able to work for both lower and capital case letters.
import re
def string_expansion(s):
    result = str()
    regex = re.compile(r'(\d)?([a-zA-Z]+)+')
    mo = regex.findall(s)
    print(mo)
    for item in mo:
        if len(item[1]) > 1:
            lst = list(item[1])
            for letter in lst:
                if item[0] == '':
                    number = 1
                else:
                    number = item[0]
                letters = letter*int(number)
                result += ''.join(letters)
        else:
            if item[0] == '':
                number = 1
            else:
                number = item[0]
            letters = item[1]*int(number)
            result += ''.join(letters)
    return result

# You have to write a calculator that receives strings for input.
# The dots will represent the number in the equation. There will be
# dots on one side, an operator, and dots again after the operator.
# The dots and the operator will be separated by one space.
# Here are the following valid operators :
# + Addition
# - Subtraction
# * Multiplication
# // Integer Division
# Your Work (Task)
# You'll have to return a string that contains dots,
# as many the equation returns. If the result is 0, return the empty string.
# When it comes to subtraction, the first number will always be greater than or equal to the second number.
def calculator(txt):
    l = txt.split()
    if '+' in l:
        return l[0] + l[2]
    elif '-' in l:
        return l[0][:len(l[0])-len(l[2])]
    elif '*' in l:
        return l[0] * len(l[2])
    elif '//' in l:
        return l[0][:len(l[0])//len(l[2])]

# Write a function that flattens an Array of Array
# objects into a flat Array. Your function must only do one level of flattening.
def flatten(lst):
    return sum(([i] if not isinstance(i, list) else i for i in lst), [])

# Given a square matrix (i.e. an array of subarrays), find the sum of values from the first value of
# the first array, the second value of the second array, the third value of the third array, and so on...
def diagonal_sum(array):
    return sum(array[i][i] for i in range(len(array)))

# Write a function that checks whether all elements in an array are square numbers. The function
# should be able to take any number of array elements.
# Your function should return true if all elements in the array are square numbers and false if not.
# An empty array should return undefined / None / nil /false (for C).
# You can assume that all array elements will be positive integers.
from math import isqrt
def is_square(a):
    if a:
        return all(isqrt(x)**2 == x for x in a)

# In cryptanalysis, words patterns can be a useful tool in cracking simple ciphers.
# A word pattern is a description of the patterns of letters occurring in a word,
# where each letter is given an integer code in order of appearance. So the
# first letter is given the code 0, and second is then assigned 1 if it is
# different to the first letter or 0 otherwise, and so on.
# As an example, the word "hello" would become "0.1.2.2.3". For this task case-sensitivity is ignored,
# so "hello", "helLo" and "heLlo" will all return the same word pattern.
# Your task is to return the word pattern for a given word. All words provided will
# be non-empty strings of alphabetic characters only, i.e. matching the regex "[a-zA-Z]+".
def word_pattern(word):
    output = ''
    conversion = []
    word = word.lower()
    for letter in word:
        if letter not in conversion:
            conversion.append(letter)
        output += str(conversion.index(letter)) +'.'
    return output[:-1]

# It's your birthday. Your colleagues buy you a cake. The numbers of
# candles on the cake is provided (candles). Please note this is not reality, and
# your age can be anywhere up to 1000. Yes, you would look a mess.
# As a surprise, your colleagues have arranged for your friend to hide inside the cake
# and burst out. They pretend this is for your benefit, but likely it is just because they want to see
# you fall over covered in cake. Sounds fun!
# When your friend jumps out of the cake, he/she will knock some of the candles to the floor. If the number of
# candles that fall is higher than 70% of total candles, the carpet will catch fire.
# You will work out the number of candles that will fall from the provided lowercase string (debris).
# You must add up the character ASCII code of each even indexed
# (assume a 0 based indexing) character in the string, with
# the alphabetical position ("a" = 1, "b" = 2, etc.) of each odd indexed character to get the string's total.
import string
def cake(candles, debris):
    fallen_candles = sum(
        string.ascii_letters.index(char) if index % 2 else ord(char)
        for index, char in enumerate(debris)
    )
    return "Fire!" if candles and fallen_candles > candles * 0.7 else "That was close!"

# Complete the method that takes a sequence of objects with two keys each: country or state, and
# capital. Keys may be symbols or strings.
# The method should return an array of sentences declaring the state or country and its capital.
def capital(capitals):
    return [f"The capital of {c.get('state') or c['country']} is {c['capital']}" for c in capitals]

# Write a function that doubles every second integer in a list, starting from the left.
def double_every_other(lst):
    return [i*2 if lst.index(i)%2!=0 else i for i in lst]

# Suppose you have 4 numbers: '0', '9', '6', '4' and 3 strings composed with them:
# s1 = "6900690040"
# s2 = "4690606946"
# s3 = "9990494604"
# Compare s1 and s2 to see how many positions they have in common: 0 at index 3, 6
# at index 4, 4 at index 8 ie 3 common positions out of ten.
# Compare s1 and s3 to see how many positions they have in common: 9 at index
# 1, 0 at index 3, 9 at index 5 ie 3 common positions out of ten.
# Compare s2 and s3. We find 2 common positions out of ten.
# So for the 3 strings we have 8 common positions out of 30 ie 0.2666... or 26.666...%
# Given n substrings (n >= 2) in a string s our function pos_average will calculate the average
# percentage of positions that are the same between the (n * (n-1)) / 2 sets of substrings
# taken amongst the given n substrings. It can happen that some substrings are duplicate but since their
# ranks are not the same in s they are considered as different substrings.
# The function returns the percentage formatted as a float with 10 decimals but the result is
# tested at 1e.-9 (see function assertFuzzy in the tests).
import numpy as np
def pos_average(s):
    s = s.replace(',','')
    s = s.split(' ')
    total = (len(s)*(len(s)-1))/2
    sequence_array = []
    for sequence in s:
        sequence_array.append(list(sequence))
    arr = np.array(sequence_array)
    counter = 0
    for i in range(0, arr.shape[1]):
        print(arr[:,i])
        unique, counts = np.unique(arr[:,i], return_counts=True)
        print('unique', unique)
        for k in range(0, len(counts)):
            print(counts[k])
            if counts[k] > 1:
                counter += np.sum(np.arange(1, counts[k]))
    return counter/(total*len(s[0]))*100

# Your Story
# "A piano in the home meant something." - Fried Green Tomatoes at the Whistle Stop Cafe
# You've just realized a childhood dream by getting a beautiful and beautiful-sounding upright piano from
# a friend who was leaving the country. You immediately started doing things
# like playing "Heart and Soul" over and over again, using one finger to pick out any
# melody that came into your head, requesting some sheet music books from the library,
# signing up for some MOOCs like Developing Your Musicianship, and wondering if you will
# think of any good ideas for writing piano-related katas and apps.
# Now you're doing an exercise where you play the very first (leftmost, lowest in pitch)
# key on the 88-key keyboard, which (as shown below) is white, with the little finger
# on your left hand, then the second key, which is black, with the ring finger on your
# left hand, then the third key, which is white, with the middle finger on your left hand,
# then the fourth key, also white, with your left index finger, and then the fifth key,
# which is black, with your left thumb. Then you play the sixth key, which is white,
# with your right thumb, and continue on playing the seventh, eighth, ninth, and tenth
# keys with the other four fingers of your right hand. Then for the eleventh key you go
# back to your left little finger, and so on. Once you get to the rightmost/highest, 88th,
# key, you start all over again with your left little finger on the first key. Your thought
# is that this will help you to learn to move smoothly and with uniform pressure on the keys
# from each finger to the next and back and forth between hands.
# You're not saying the names of the notes while you're doing this, but instead just
# counting each key press out loud (not starting again at 1 after 88, but continuing on
# to 89 and so forth) to try to keep a steady rhythm going and to see how far you can get before messing up.
# You move gracefully and with flourishes, and between screwups you hear, see, and feel that you are
# part of some great repeating progression between low and high notes and black and white keys.
# Your Function
# The function you are going to write is not actually going to help you with your piano playing,
# but just explore one of the patterns you're experiencing: Given the number you stopped on, was
# it on a black key or a white key? For example, in the description of your piano exercise above,
# if you stopped at 5, your left thumb would be on the fifth key of the piano, which is black. Or
# if you stopped at 92, you would have gone all the way from keys 1 to 88 and then wrapped around,
# so that you would be on the fourth key, which is white.
# Your function will receive an integer between 1 and 10000 (maybe you think that in principle
# it would be cool to count up to, say, a billion, but considering how many years it would take
# it is just not possible) and return the string "black" or "white" -- here are a few more examples:
def black_or_white_key(key_press_count):
    count = (key_press_count - 1) % 88 % 12
    l = [0, 2, 3, 5, 7, 8, 10]
    return 'white' if count in l else 'black'

# Find the longest substring in alphabetical order.
# Example: the longest alphabetical substring in "asdfaaaabbbbcttavvfffffdf" is "aaaabbbbctt".
# There are tests with strings up to 10 000 characters long so your code will need to be efficient.
# The input will only consist of lowercase characters and will be at least one letter long.
# If there are multiple solutions, return the one that appears first.
import re
def longest(s):
    matches = re.findall('a*b*c*d*e*f*g*h*i*j*k*l*m*n*o*p*q*r*s*t*u*v*w*x*y*z*', s)
    current_longest = matches[0]
    for match in matches:
        if len(match) > len(current_longest):
            current_longest = match
    return current_longest

# You are given a string of n lines, each substring being n characters long: For example:
# s = "abcd\nefgh\nijkl\nmnop"
# We will study some transformations of this square of strings.
# Symmetry with respect to the main diagonal: diag_1_sym (or diag1Sym or diag-1-sym)
# diag_1_sym(s) => "aeim\nbfjn\ncgko\ndhlp"
# Clockwise rotation 90 degrees: rot_90_clock (or rot90Clock or rot-90-clock)
# rot_90_clock(s) => "miea\nnjfb\nokgc\nplhd"
# selfie_and_diag1(s) (or selfieAndDiag1 or selfie-and-diag1) It is initial
# string + string obtained by symmetry with respect to the main diagonal.
# s = "abcd\nefgh\nijkl\nmnop" -->
# "abcd|aeim\nefgh|bfjn\nijkl|cgko\nmnop|dhlp"
# or printed for the last:
import copy
def diag_1_sym(s):
    w=[[x for x in ele]for ele in s.split('\n')]
    L,n=copy.deepcopy(w),len(w)
    for i in range(n):
        for j in range(n):
            L[i][j]=w[j][i]
    return '\n'.join([''.join(x) for x in L])
def rot_90_clock(strng):
    op=diag_1_sym(strng)
    return '\n'.join([x[::-1] for x in op.split('\n')])
def selfie_and_diag1(strng):
    op1,op2=strng.split('\n'),diag_1_sym(strng).split('\n')
    return '\n'.join([x+'|'+y for x,y in zip(op1,op2)])
def oper(fct, s):
    return fct(s)

# Input : an array of integers.
# Output : this array, but sorted in such a way that there are two wings:
# the left wing with numbers decreasing,
# the right wing with numbers increasing.
# the two wings have the same length. If the length of the array is odd the wings are around the
# bottom, if the length is even the bottom is considered to be part of the right wing.
# each integer l of the left wing must be greater or equal to its counterpart r in the right wing, the
# difference l - r being as small as possible. In other words the
# right wing must be nearly as steep as the left wing.
# The function is make_valley or makeValley or make-valley.
def make_valley(l):
    l = sorted(l, reverse = True)
    return l[::2] + l[1::2][::-1]

# The town sheriff dislikes odd numbers and wants all odd numbered families out of town! In town
# crowds can form and individuals are often mixed with other people and families. However you
# can distinguish the family they belong to by the number on the shirts they wear.
# As the sheriff's assistant it's your job to find all the odd numbered families and remove them from the town!
# Challenge: You are given a list of numbers. The numbers each repeat a certain number of times.
# Remove all numbers that repeat an odd number of times while keeping everything else the same.
# odd_ones_out([1, 2, 3, 1, 3, 3]) = [1, 1]
# In the above example:
# the number 1 appears twice
# the number 2 appears once
# the number 3 appears three times
# 2 and 3 both appear an odd number of times, so they are removed from the list. The final result is: [1,1]
# Here are more examples:
def odd_ones_out(numbers):
    return [i for i in numbers if numbers.count(i)%2==0]

# Write function which takes a string and make an acronym of it.
# Rule of making acronym in this kata:
# split string to words by space char
# take every first letter from word in given string
# uppercase it
# join them toghether
def to_acronym(inp):
    return ''.join(i[0].upper() for i in inp.split())

# This Kata is intended as a small challenge for my students
# All Star Code Challenge #16
# Create a function called noRepeat() that takes a string argument and
# returns a single letter string of the first not repeated character in the entire string.
def no_repeat(string):
    return [i for i in string if string.count(i) == 1][0]

# Create a function that takes a number and returns an array of strings containing the number cut off at each digit.
# Examples
# 420 should return ["4", "42", "420"]
# 2017 should return ["2", "20", "201", "2017"]
# 2010 should return ["2", "20", "201", "2010"]
# 4020 should return ["4", "40", "402", "4020"]
# 80200 should return ["8", "80", "802", "8020", "80200"]
# PS: The input is guaranteed to be an integer in the range [0, 1000000]
def create_array_of_tiers(n):
    return [str(n)[:i] for i in range(1,len(str(n))+1)]

# Impliment the reverse function, which takes in input n and reverses it.
# For instance, reverse(123) should return 321. You should do this
# without converting the inputted number into a string.
def reverse(n, count=0):
	return reverse(n // 10, count * 10 + n % 10) if n else count

# Write a function that receives two strings as parameter. This strings are in the following
# format of date: YYYY/MM/DD. Your job is: Take the years and calculate the difference between them.
def how_many_years (date1,date2):
    return abs(int(date1.split('/')[0]) - int(date2.split('/')[0]))

# Your task is to find all the elements of an array that are non consecutive.
# A number is non consecutive if it is not exactly one larger
# than the previous element in the array. The first element gets a pass and is never considered non consecutive.
# Create a function name all_non_consecutive
# E.g., if we have an array [1,2,3,4,6,7,8,15,16] then 6 and 15 are non-consecutive.
# You should return the results as an array of objects with two values i:
# <the index of the non-consecutive number> and n: <the non-consecutive number>.
def all_non_consecutive(a):
    return [{"i": i, "n": y} for i, (x, y) in enumerate(zip(a, a[1:]), 1) if x != y - 1]

# Too long, didn't read
# You get a list of integers, and you have to write a function mirror that returns the
# "mirror" (or symmetric) version of this list: i.e. the middle element is the
# greatest, then the next greatest on both sides, then the next greatest, and so on...
# More info
# The list will always consist of integers in range -1000..1000 and will vary in size between 0
# and 10000. Your function should not mutate the input array, and this will be tested
# (where applicable). Notice that the returned list will always be of odd size, since there
# will always be a definitive middle element.
def mirror(data: list) -> list:
    return sorted(data) + sorted(data, reverse=True)[1:]

# This Kata is intended as a small challenge for my students
# All Star Code Challenge #1
# Write a function, called sumPPG, that takes two NBA player objects/struct/Hash/Dict/Class and sums their PPG
def sum_ppg(player_one, player_two):
    return player_one['ppg'] + player_two['ppg']

# This kata requires you to convert minutes (int) to hours and minutes in the format hh:mm (string).
# If the input is 0 or negative value, then you should return "00:00"
# Hint: use the modulo operation to solve this challenge. The modulo operation simply returns the remainder
# after a division. For example the remainder of 5 / 2 is 1, so 5 modulo 2 is 1.
# Example
# If the input is 78, then you should return "01:18", because 78 minutes converts to 1 hour and 18 minutes.
def time_convert(num):
    return '%02d:%02d' % (num // 60, num % 60) if num > 0 else '00:00'

# You have a group chat application, but who is online!?
# You want to show your users which of their friends are online and available to chat!
# Given an input of an array of objects containing usernames, status and time since last activity (in mins),
# create a function to work out who is online, offline and away.
# If someone is online but their lastActivity was more than 10 minutes ago they are to be considered away.
from collections import defaultdict
def who_is_online(friends):
    d = defaultdict(list)
    for user in friends:
        status = 'away' if user['status'] == 'online' and user['last_activity'] > 10 else user['status']
        d[status].append(user['username'])
    return d


Linked
lists
are
data
structures
composed
of
nested or chained
objects, each
containing
a
single
value and a
reference
to
the
next
object.

Here
's an example of a list:


class LinkedList:
    def __init__(self, value=0, next=None):
        self.value = value
        self.next = next


# LinkedList(1, LinkedList(2, LinkedList(3)))
# Write a function listToArray( or list_to_array in Python) that
# converts a list to an array, like this:
# [1, 2, 3]
# Assume all inputs are valid lists
# with at least one value.For the purpose of simplicity, all values will be either numbers, strings, or Booleans.
def list_to_array(lst):
    return ([lst.value] + list_to_array(lst.next)) if lst else []

# Oh no! Ghosts have reportedly swarmed the city. It's your job to get rid of them and save the day!
# In this kata, strings represent buildings while whitespaces within those strings represent ghosts.
# So what are you waiting for? Return the building(string) without any ghosts(whitespaces)!
def ghostbusters(building):
    return building.replace(' ', '') if ' ' in building else "You just wanted my autograph didn't you?"

# Write a function last that accepts a list and returns the last element in the list.
# If the list is empty:
# In languages that have a built-in option or result type (like OCaml or Haskell), return an empty option
# In languages that do not have an empty option, just return None
def last(lst):
    return lst[-1] if lst else None

# Paul is an excellent coder and sits high on the CW leaderboard. He solves kata like a banshee but would
# also like to lead a normal life, with other activities. But he just can't stop solving all the kata!!
# Given an array (x) you need to calculate the Paul Misery Score. The values are worth the following points:
def paul(x):
    d = {'kata':5, 'Petes kata':10, 'life':0, 'eating':1}
    count = sum(d[i] for i in x)
    return 'Super happy!' if count < 40 else 'Happy!' if 40 <= count < 70 else 'Sad!' if 70 <= count < 100 else 'Miserable!'

# It's important day today: the class has just had a math test. You will be given a list of marks.
# Complete the function that will:
# Calculate the average mark of the whole class and round it to 3 decimal places.
# Make a dictionary/hash with keys "h", "a", "l" to make clear how many high, average and
# low marks they got. High marks are 9 & 10, average marks are 7 & 8, and low marks are 1 to 6.
# Return list [class_average, dictionary] if there are different type of marks, or [class_average,
# dictionary, "They did well"] if there are only high marks.
def test(r):
    avr = round(sum(r)/len(r), 3)
    h, a, l = 0, 0, 0
    for mark in r:
        if 9 <= mark <= 10:
            h += 1
        elif 7 <= mark <= 8:
            a += 1
        elif 1 <= mark <= 6:
            l += 1
    l = [avr, {'h': h, 'a': a, 'l': l}, f"{'They did well' if a + l == 0 else ''}"]
    return l[:-1] if l[-1] == '' else l

# Happy Holidays fellow Code Warriors!
# It's almost Christmas! That means Santa's making his list, and checking it twice. Unfortunately,
# elves accidentally mixed the Naughty and Nice list together! Santa needs your help to save Christmas!
# Save Christmas!
# Santa needs you to write two functions. Both of the functions accept a sequence of objects.
# The first one returns a sequence containing only the names of the nice people,
# and the other returns a sequence containing only the names of the naughty people.
# Return an empty sequence [] if the result from either of the functions contains no names.
# The objects in the passed will represent people. Each object contains two properties: name and wasNice.
# name - The name of the person
# wasNice - True if the person was nice this year, false if they were naughty
def get_nice_names(people):
    l = []
    for d in people:
        if d['was_nice']:
            l.append(d['name'])
    return l if l else []

def get_naughty_names(people):
    l = []
    for d in people:
        if not d['was_nice']:
            l.append(d['name'])
    return l if l else []

# This Kata is intended as a small challenge for my students
# Your family runs a shop and have just brought a Scrolling
# Text Machine (http://3.imimg.com/data3/RP/IP/MY-2369478/l-e-d-multicolour-text-board-250x250.jpg) to help
# get some more business.
# The scroller works by replacing the current text string with a similar text string,
# but with the first letter shifted to the end; this simulates movement.
# You're father is far too busy with the business to worry about such details, so, naturally, he's
# making you come up with the text strings.
# Create a function named rotate() that accepts a string argument and returns an array of
# strings with each letter from the input string being rotated to the end.
def rotate(str_):
    l = [i for i in str_]
    result = []
    for i in range(len(l)):
        temp = l[0]
        l.append(temp)
        l.pop(0)
        result.append(''.join(l))
    return result

# In this Kata, you will be given two positive integers a and b and your task will be to apply
# the following operations:
# i) If a = 0 or b = 0, return [a,b]. Otherwise, go to step (ii);
# ii) If a ≥ 2*b, set a = a - 2*b, and repeat step (i). Otherwise, go to step (iii);
# iii) If b ≥ 2*a, set b = b - 2*a, and repeat step (i). Otherwise, return [a,b].
# a and b will both be lower than 10E8.
# More examples in tests cases. Good luck!
def solve(a,b):
    if a == 0 or b == 0:
        return [a,b]
    elif a >= 2*b:
        a = a-2*b
        return solve(a,b)
    elif b >= 2*a:
        b = b-2*a
        return solve(a,b)
    else:
        return [a,b]

# In your class, you have started lessons about geometric progression.
# Since you are also a programmer, you have decided to write a function that
# will print first n elements of the sequence with the given constant r and first element a.
# Result should be separated by comma and space.
def geometric_sequence_elements(a, r, n):
    return ", ".join(str(a * r ** i) for i in range(n))

# You are working at a lower league football stadium and you've been tasked with automating the scoreboard.
# The referee will shout out the score, you have already set up the voice recognition module
# which turns the ref's voice into a string, but the spoken score needs to be converted into
# a pair for the scoreboard!
# e.g. "The score is four nil" should return [4,0]
# Either teams score has a range of 0-9, and the ref won't say the same string every time e.g.
def scoreboard(string):
    d = {'one':1, 'two':2, 'three':3, 'four':4, 'five':5, 'six':6, 'seven':7, 'eight':8, 'nine': 9 , 'nil':0}
    score = []
    for elem in string.split():
        if elem in d:
            score.append(d[elem])
    return score

# In this Kata the aim is to compare each pair of integers from 2 arrays, and return a new array of large numbers.
# Note: Both arrays have the same dimensions.
def get_larger_numbers(a, b):
    return [max(a[i], b[i]) for i,j in enumerate(a)]

# Create a function that takes a string as a parameter and does the following, in this order:
# Replaces every letter with the letter following it in the alphabet (see note below)
# Makes any vowels capital
# Makes any consonants lower case
# Note:
# the alphabet should wrap around, so Z becomes A
# in this kata, y isn't considered as a vowel.
def changer(s):
    l = 'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz'
    word = ''
    s = s.lower()
    for i in s:
        if i in l:
            if l[l.index(i)+1] in 'aeoiu':
                word += l[l.index(i)+1].upper()
                continue
            else:
                word += l[l.index(i)+1]
                continue
        else:
            word += i
    return word

# Remember the triangle of balls in billiards? To build a classic triangle (5 levels) you need 15 balls.
# With 3 balls you can build a 2-level triangle, etc.
# For more examples, Write a function that takes number of balls (≥ 1) and
# calculates how many levels you can build a triangle.
def pyramid(balls):
    s = 0
    i=1
    while balls >= i:
        balls -= i
        i += 1
        s+=1
    return s

# Find the last element of the given argument(s).
def last(*args):
    try:
        return [args][-1][-1][-1]
    except:
        return args[-1]

# In your class, you have started lessons about "arithmetic progression". Because you are also a programmer,
# you have decided to write a function.
# This function, arithmetic_sequence_sum(a, r, n), should return the sum of the
# first (n) elements of a sequence in which each element is the sum of the given integer
# (a), and a number of occurences of the given integer (r), based on the element's position within the sequence.
# For example:
# arithmetic_sequence_sum(2, 3, 5) should return 40:
def arithmetic_sequence_sum(a, r, n):
    return sum(a + r * i for i in range(n))

# Implement a function that receives a string, and lets you extend it with repeated calls. When no argument
# is passed you should return a string consisting of space-separated words you've received earlier.
# Note: there will always be at least 1 string; all inputs will be non-empty.
class create_message(str):
    def  __call__(self, s=""):
        return create_message((self+" "+s).rstrip())

# Being a bald man myself, I know the feeling of needing to keep it clean shaven. Nothing worse
# that a stray hair waving in the wind.
# You will be given a string(x). Clean shaved head is shown as "-"
# and stray hairs are shown as "/". Your task is to check the head for stray hairs and get rid of them.
# You should return the original string, but with any stray hairs removed. Keep count
# ot them though, as there is a second element you need to return:
# 0 hairs --> "Clean!"
# 1 hair --> "Unicorn!"
# 2 hairs --> "Homer!"
# 3-5 hairs --> "Careless!"
# >5 hairs --> "Hobo!"
# So for this head: "------/------" you shoud return:
# ["-------------", "Unicorn"]
def bald(s):
    c = 'Clean!' if s.count('/') == 0 else 'Unicorn!' if s.count('/') == 1 else 'Homer!' if s.count('/') == 2 else 'Careless!' if 3 <= s.count('/') <= 5 else 'Hobo!'
    return [s.replace('/', '-'), c]

# Complete the function that takes a list of numbers (nums), as the only argument to the function.
# Take each number in the list and square it if it is even, or square root the
# number if it is odd. Take this new list and return the sum of it, rounded to two decimal places.
# The list will never be empty and will only contain values that are greater than or equal to zero.
# Good luck!
def sum_square_even_root_odd(nums):
    return round(sum(i**2 if i%2==0 else i **.5 for i in nums), 2)

# In this Kata, you will be given an array of arrays and your task will be to return the
# number of unique arrays that can be formed by picking exactly one element from each subarray.
# For example: solve([[1,2],[4],[5,6]]) = 4, because it results in only 4 possibilites.
# They are [1,4,5],[1,4,6],[2,4,5],[2,4,6].
# Make sure that you don't count duplicates; for example solve([[1,2],[4,4],[5,6,6]]) = 4,
# since the extra outcomes are just duplicates.
# See test cases for more examples.
# Good luck!
# If you like this Kata, please try:
def solve(lists):
    res = 1
    for list in lists:
        res *= len(set(list))
    return res

# Write the following function:
# def area_of_polygon_inside_circle(circle_radius, number_of_sides):
# It should calculate the area of a regular polygon of numberOfSides, number-of-sides,
# or number_of_sides sides inside a circle of radius circleRadius, circle-radius,
# or circle_radius which passes through all the vertices of the polygon
# (such circle is called circumscribed circle or circumcircle). The answer should be a number rounded to
# 3 decimal places.
import math
def area_of_polygon_inside_circle(r, n):
    return float("{:.3f}".format((math.sin(2 * math.pi / n) * r * r * n) / 2))

# There are some stones on Bob's table in a row, and each of
# them can be red, green or blue, indicated by the characters R, G, and B.
# Help Bob find the minimum number of stones he needs to remove from the table
# so that the stones in each pair of adjacent stones have different colours.
import re
def solution(stones):
    res = 0
    for i in 'RGB':
        matches = re.findall(rf'{i}+', stones)
        for match in matches:
            res += len(match)-1
    return res

# For this Kata you will be given an array of numbers and another number n.
# You have to find the sum of the n largest numbers of the array
# and the product of the n smallest numbers of the array, and compare the two.
# If the sum of the n largest numbers is higher, return "sum"
# If the product of the n smallest numbers is higher, return "product"
# If the 2 values are equal, return "same"
# Note The array will never be empty and n will always be smaller than the length of the array.
import functools
def sum_or_product(array, n):
    big = sum(sorted(array)[-n:])
    small = functools.reduce(lambda a, b : a * b, sorted(array)[:n])
    return 'sum' if big > small else 'product' if small > big else 'same'

# A startup office has an ongoing problem with its bin.
# Due to low budgets, they don't hire cleaners. As a result, the staff are left to voluntarily empty the bin.
# It has emerged that a voluntary system is not working and the bin is often overflowing.
# One staff member has suggested creating a rota system based upon the staff seating plan.
# Create a function binRota that accepts a 2D array of names.
# The function will return a single array containing staff names in the order that they should empty the bin.
# Adding to the problem, the office has some temporary staff.
# This means that the seating plan changes every month. Both staff members'
# names and the number of rows of seats may change. Ensure that the function
# binRota works when tested with these changes.
# Notes:
# All the rows will always be the same length as each other.
# There will be no empty spaces in the seating plan.
# There will be no empty arrays.
# Each row will be at least one seat long.
def bin_rota(arr):
    l = []
    for i in range(len(arr)):
        if i % 2 == 0:
            l += arr[i]
            continue
        else:
            l += arr[i][::-1]
    return l

# You are given an array of non-negative integers, your task is to complete the series from 0 to
# the highest number in the array.
# If the numbers in the sequence provided are not in order you should order them,
# but if a value repeats, then you must return a sequence with only one item,
# and the value of that item must be 0. like this:
def complete_series(seq):
    return [i for i in range(max(seq)+1)] if len(set(seq)) == len(seq) else [0]

# I will give you an integer (N) and a string. Break the string up into as
# many substrings of N as you can without spaces. If there are leftover characters, include those as well.
def string_breakers(n, st):
    st = st.replace(' ', '')
    l = []
    s = len(st)//n if len(st) % n == 0 else len(st)// n + 1
    for i in range(s):
        l.append(st[:n])
        st = st[n:]
    return '\n'.join(l)

# In this Kata, you will be given a lower case string and your task will be to remove k characters
# from that string using the following rule:
# - first remove all letter 'a', followed by letter 'b', then 'c', etc...
# - remove the leftmost character first.
def solve(st,k):
    num, removed = 0, 0
    while removed < k and st:
        if chr(num+97) in st:
            indx = st.index(chr(num+97))
            st = st[0:indx] + st[indx+1:]
            removed += 1
        else:
            num += 1
    return st

#Make them bark
# You have been hired by a dogbreeder to write a program to keep record of his dogs.
# You've already made a constructor Dog, so no one has to hardcode every puppy.
# The work seems to be done. It's high time to collect the payment.
# ..hold on! The dogbreeder says he wont pay you, until he can make every dog object .bark().
# Even the ones already done with your constructor. "Every dog barks" he says.
# He also refuses to rewrite them, lazy as he is.
# You can't even count how much objects that bastard client of yours already made.
# He has a lot of dogs, and none of them can .bark().
# Can you solve this problem, or will you let this client outsmart you for good?
# Practical info:
# The .bark() method of a dog should return the string 'Woof!'.
# The contructor you made (it is preloaded) looks like this:
def bark(self):
    return "Woof!"
Dog.bark = bark

# Write a function that accepts two arguments: an array/list of integers and another integer (n).
# Determine the number of times where two integers in the array have a difference of n.
def int_diff(lst, n):
    count = 0
    for i in range(len(lst)):
        for j in range(i+1, len(lst)):
            if abs(lst[i] - lst[j]) == n:
                count += 1
    return count

# Make a program that takes a value (x) and returns "Bang" if the number is divisible by 3,
# "Boom" if it is divisible by 5, "BangBoom" if it divisible by 3 and 5,
# and "Miss" if it isn't divisible by any of them. Note: Your program should only return one value
# Ex: Input: 105 --> Output: "BangBoom" Ex: Input: 9 --> Output: "Bang" Ex:Input: 25 --> Output: "Boom"
def multiple(x):
    return 'Bang' if x%3==0 and x%5!=0 else 'Boom' if x%3!=0 and x%5==0 else 'BangBoom' if x%3==0 and x%5==0 else 'Miss'

# Write a method that will search an array of strings for all strings that contain another string, ignoring
# capitalization. Then return an array of the found strings.
# The method takes two parameters, the query string and the array of strings to search, and returns an array.
# If the string isn't contained in any of the strings in the array,
# the method returns an array containing a single string: "Empty" (or Nothing in Haskell,
# or "None" in Python and C)
def word_search(query, seq):
    return [i for i in seq if query.lower() in i.lower()] or ["None"]

# JavaScript provides a built-in parseInt method.
# It can be used like this:
# parseInt("10") returns 10
# parseInt("10 apples") also returns 10
# We would like it to return "NaN" (as a string) for the second case
# because the input string is not a valid number.
# You are asked to write a myParseInt method with the following rules:
# It should make the conversion if the given string only contains a single integer value (and possibly
# spaces - including tabs, line feeds... - at both ends)
# For all other strings (including the ones representing float values), it should return NaN
# It should assume that all numbers are not signed and written in base 10
def my_parse_int(string):
    try:
        return int(string)
    except:
        return 'NaN'

# Your job is to create a class called Song.
# A new Song will take two parameters, title and artist.
# mount_moose = Song('Mount Moose', 'The Snazzy Moose')
# mount_moose.title => 'Mount Moose'
# mount_moose.artist => 'The Snazzy Moose'
# You will also have to create an instance method named howMany() (or how_many()).
# The method takes an array of people who have listened to the song that day.
# The output should be how many new listeners the song gained on that day out of all listeners.
# Names should be treated in a case-insensitive manner, i.e. "John" is the same as "john".
class Song:
    def __init__(self, title, artist):
        self.title = title
        self.artist = artist
        self.listeners = list(map(lambda listener: listener.lower(), artist))
    def how_many(self, listeners):
        listens = 0
        for listener in listeners:
            listener = listener.lower()
            if listener not in self.listeners:
                self.listeners.append(listener)
                listens += 1
        return listens

# Due to lack of maintenance the minute-hand has fallen off Town Hall clock face.
# And because the local council has lost most of our tax money to a Nigerian email scam there
# are no funds to fix the clock properly.
# Instead, they are asking for volunteer programmers to write some code that tell the time
# by only looking at the remaining hour-hand!
# What a bunch of cheapskates!
# Can you do it?
# Kata
# Given the angle (in degrees) of the hour-hand, return the time in 12 hour HH:MM format.
# Round down to the nearest minute.
import math
def what_time_is_it(angle):
    calc = math.floor(angle / 30)
    remain = angle % 30
    min = math.floor(remain * 2)
    if angle == 0: return "12:00"
    elif calc == 0 and min < 10: return f"12:0{min}"
    elif calc == 0 and min > 9: return f"12:{min}"
    elif remain == 0 and calc < 10: return f"0{calc}:00"
    elif remain == 0 and calc > 9: return f"{calc}:00"
    elif min < 10 and calc < 10: return f"0{calc}:0{min}"
    elif min < 10 and calc > 9: return f"{calc}:0{min}"
    elif min > 9 and calc < 10: return f"0{calc}:{min}"
    elif min > 9 and calc > 9: return f"{calc}:{min}"

# Create a moreZeros function which will receive a string for input, and return an array
# (or null terminated string in C) containing only the characters from that string whose binary
# representation of its ASCII value consists of more zeros than ones.
# You should remove any duplicate characters, keeping the first occurrence of any such duplicates, so they
# are in the same order in the final array as they first appeared in the input string.
def more_zeros(s):
    l = []
    for i in s:
        c = format(ord(i), 'b')
        if c.count('1') < c.count('0') and i not in l:
            l.append(i)
    return l

# Complete the function circleArea so that it will return the area of a circle with the given radius.
# Round the returned number to two decimal places (except for Haskell).
# If the radius is not positive or not a number, return false.
import math
def circle_area(r):
    return round(math.pi*r**2, 2) if type(r) == int and r > 0 else False

# Normally we have firstname, middle and the last name but there may be more than one word in a name
# like a South Indian one.
# Similar to those kinda names we need to initialize the names.
# See the pattern below:
def initials(name):
    return '.'.join(i.upper()[0] if i.lower() != name.split()[-1].lower() else i.capitalize() for i in name.split())

# What's in a name?
# ..Or rather, what's a name in? For us, a particular string is where we are looking for a name.
# Task
# Write a function, taking two strings in parameter, that tests whether or not the first string contains
# all of the letters of the second string, in order.
# The function should return true if that is the case, and else false. Letter comparison should be case-INsensitive.
def name_in_str(str, name):
    word = iter(str.lower())
    return all(i in word for i in name.lower())

# This is related to my other Kata about cats and dogs.
# Kata Task
# I have a cat and a dog which I got as kitten / puppy.
# I forget when that was, but I do know their current ages as catYears and dogYears.
# Find how long I have owned each of my pets and return as a list [ownedCat, ownedDog]
# NOTES:
# Results are truncated whole numbers of "human" years
# Cat Years
# 15 cat years for first year
# +9 cat years for second year
# +4 cat years for each year after that
# Dog Years
# 15 dog years for first year
# +9 dog years for second year
# +5 dog years for each year after that
def owned_cat_and_dog(cy, dy):
    cat = 0 if cy < 15 else 1 if cy < 24 else 2 + (cy - 24) // 4
    dog = 0 if dy < 15 else 1 if dy < 24 else 2 + (dy - 24) // 5
    return [cat, dog]

# We need a method in the List Class that may count specific digits from a given list of integers.
# This marked digits will be given in a second list. The method .count_spec_digits()/.countSpecDigits() will
# accept two arguments, a list of an uncertain amount of integers integers_lists/integersLists (and of an uncertain
# amount of digits, too) and a second list, digits_list/digitsList that has the specific digits to
# count which length cannot be be longer than 10 (It's obvious, we've got ten digits).
# The method will output a list of tuples, each tuple having two elements, the first
# one will be a digit to count, and second one, its corresponding total frequency in all
# the integers of the first list. This list of tuples should be ordered with the same order that the digits
# have in digitsList
class List(object):
    def count_spec_digits(self, integers_list, digits_list):
        s = "".join(str(i) for i in integers_list)
        return [(dig, s.count(str(dig))) for dig in digits_list]

# Given 2 string parameters, show a concatenation of:
# the reverse of the 2nd string with inverted case; e.g Fish -> HSIf
# a separator in between both strings: @@@
# the 1st string reversed with inverted case and then mirrored; e.g Water -> RETAwwATER
def reverse_and_mirror(s1, s2):
    return f"{s2[::-1].swapcase()}@@@{s1[::-1].swapcase()}{s1.swapcase()}"

# Write a function that will randomly upper and lower characters in a string - randomCase() (random_case()
# for Python).
# A few examples:
import random
def random_case(x):
    return "".join([random.choice([i.lower(), i.upper()]) for i in x])

# You have to write a function pattern which creates the following pattern upto n number of rows.
# If the Argument is 0 or a Negative Integer then it should return "" i.e. empty string.
def pattern(n):
    l = list(range(1, n + 1))
    return '\n'.join(''.join(map(str, l[i:])) for i in range(n))

# How many days are we represented in a foreign country?
# My colleagues make business trips to a foreign country. We must find the number of days our
# company is represented in a country. Every day that one or more colleagues are present in the
# country is a day that the company is represented. A single day cannot count for more than one day.
# Write a function that recieves a list of pairs and returns the number of days that
# the company is represented in the foreign country. The first number of the pair
# is the number of the day of arrival and the second number of the pair is the day
# of departure of someone who travels, i.e. 1 january is number 1 and 31 of december is 365.
def days_represented(trips):
    s = set()
    for i in trips:
        s.update(range(i[0], i[1] + 1))
    return len(s)

# There are five workers : James,John,Robert,Michael and William.They work one by
# one and on weekends they rest. Order is same as in the description(James
# works on mondays,John works on tuesdays and so on).You have to create a function
# 'task' that will take 3 arguments(w, n, c):
# Weekday
# Number of trees that must be sprayed on that day
# Cost of 1 litre liquid that is needed to spray tree,let's say one tree needs 1 litre liquid.
# Let cost of all liquid be x
# Your function should return string like this : 'It is (weekday) today, (name),
# you have to work, you must spray (number) trees and you need (x) dollars to buy liquid'
def task(w,n,c):
    workers = {"Monday" : "James", "Tuesday" : "John", "Wednesday" : "Robert", "Thursday" : "Michael", "Friday" : "William"}
    return f"It is {w} today, {workers[w]}, you have to work, you must spray {n} trees and you need {n * c} dollars to buy liquid"

# Write a function consonantCount, consonant_count or ConsonantCount that takes a string of English-language
# text and returns the number of consonants in the string.
# Consonants are all letters used to write English excluding the vowels a, e, i, o, u.
def consonant_count(s):
    return sum([1 if i not in 'aeiou' and i.isalpha() else 0 for i in s.replace(' ', '').lower()])

# Is it possible to write a book without the letter 'e' ?
# Task
# Given String str, return:
# How many "e" does it contain (case-insensitive) in string format.
# If given String doesn't contain any "e", return: "There is no "e"."
# If given String is empty, return empty String.
# If given String is `null`/`None`/`nil`, return `null`/`None`/`nil`
def find_e(s):
    try:
        c = str(s.lower().count('e'))
        return c if s != '' and int(c) > 0 else 'There is no "e".' if int(c) == 0 and s!='' else '' if s == '' else None
    except:
        return None

# Write a function that takes a string and returns an array containing binary
# numbers equivalent to the ASCII codes of the characters of the string. The binary strings should
# be eight digits long.
def word_to_bin(word):
    return [bin(ord(letter))[2:].zfill(8) for letter in word]

# In this Kata, you will be given an integer array and your task is
# to return the sum of elements occupying prime-numbered indices.
# The first element of the array is at index 0.
# Good luck!
# If you like this Kata, try:
# Dominant primes. It takes this idea a step further.
def is_prime(n):
    return n >= 2 and all(n%i for i in range(2, 1+int(n**.5)))
def total(arr):
    return sum(n for i, n in enumerate(arr) if is_prime(i))

# The snail crawls up the column. During the day it crawls up some distance. During the night
# she sleeps, so she slides down for some distance (less than crawls up during the day).
# Your function takes three arguments:
# The height of the column (meters)
# The distance that the snail crawls during the day (meters)
# The distance that the snail slides down during the night (meters)
# Calculate number of day when the snail will reach the top of the column.
def snail(column, day, night):
    count = 0
    while column > 0:
        count += 1
        if column - day <= 0:
            return count
        column -= day - night
    return count

# Complete the solution so that it returns the number of times the search_text is found within the full_text.
def solution(full_text, search_text):
    return full_text.count(search_text)

# A binary gap within a positive number num is any sequence of consecutive zeros that is
# surrounded by ones at both ends in the binary representation of num.
# For example:
# 9 has binary representation 1001 and contains a binary gap of length 2.
# 529 has binary representation 1000010001 and contains two binary gaps: one of length 4 and one of length 3.
# 20 has binary representation 10100 and contains one binary gap of length 1.
# 15 has binary representation 1111 and has 0 binary gaps.
# Write function gap(num) that,  given a positive num,  returns the length of its longest binary gap.
# The function should return 0 if num doesn't contain a binary gap.
def gap(num):
    binary = str(bin(num)).strip('0').split('b')[1]
    binary = binary.split('1')
    return max(list(map(lambda x: len(x), binary)))

# *** No Loops Allowed ***
# You will be given an array (a) and a limit value (limit).
# You must check that all values in the array are below or equal to the limit value.
# If they are, return true. Else, return false.
# You can assume all values in the array are numbers.
# Do not use loops. Do not modify input array.
# Looking for more, loop-restrained fun? Check out the other kata in the series:
def small_enough(a, limit):
    return max(a) <= limit

# Challenge:
# Given a two-dimensional array, return a new array which carries over only those arrays from the original,
# which were not empty and whose items are all of the same type (i.e. homogenous).
# For simplicity, the arrays inside the array will only contain characters and integers.
# Example:
# Given [[1, 5, 4], ['a', 3, 5], ['b'], [], ['1', 2, 3]], your function should return [[1, 5, 4], ['b']].
# Addendum:
# Please keep in mind that for this kata, we assume that empty arrays are not homogenous.
# The resultant arrays should be in the order they were originally in and should not have its values changed.
# No implicit type casting is allowed. A subarray [1, '2'] would be considered illegal and should be filtered out.
def filter_homogenous(arrays):
    return [i for i in arrays if (all(type(a) == int for a in i) or all(type(a) == str for a in i)) and i]

# Let's build a calculator that can calculate the average for an arbitrary number of arguments.
# The test expects you to provide a Calculator object with an average method:
# Calculator.average()
# The test also expects that when you pass no arguments, it returns 0. The arguments are expected to be integers.
# It expects Calculator.average(3,4,5) to return 4.
class Calculator:
    @staticmethod
    def average(*args):
        return sum(args) / len(args) if args else 0

# Harshad numbers (also called Niven numbers) are positive numbers that can be divided
# (without remainder) by the sum of their digits.
# For example, the following numbers are Harshad numbers:
# 10, because 1 + 0 = 1 and 10 is divisible by 1
# 27, because 2 + 7 = 9 and 27 is divisible by 9
# 588, because 5 + 8 + 8 = 21 and 588 is divisible by 21
# While these numbers are not:
# 19, because 1 + 9 = 10 and 19 is not divisible by 10
# 589, because 5 + 8 + 9 = 22 and 589 is not divisible by 22
# 1001, because 1 + 1 = 2 and 1001 is not divisible by 2
# Harshad numbers can be found in any number base, but we are going to focus on base 10 exclusively.
# Your task
# Your task is to complete the skeleton Harshad object ("static class") which has 3 functions:
# isValid() that checks if n is a Harshad number or not
# getNext() that returns the next Harshad number > n
# getSerie() that returns a series of n Harshad numbers, optional start value not included
# You do not need to care about the passed parameters in the test cases, they will always
# be valid integers (except for the start argument in getSerie() which is optional and should default to 0).
# Note: only the first 2000 Harshad numbers will be checked in the tests.
from itertools import count, islice
class Harshad:
    @staticmethod
    def is_valid(number):
        return number % sum(int(i) for i in str(number)) == 0
    @classmethod
    def get_next(self, number):
        return next(i for i in count(number+1) if self.is_valid(i))
    @classmethod
    def get_series(self, c, start = 0):
        return list(islice(filter(self.is_valid, (i for i in count(start+1))), c))

# Remember the spongebob meme that is meant to make fun of people by repeating what they say in a mocking way?
def sponge_meme( s ):
    bob = ''
    i = 0
    while i < len(s):
        if i % 2 != 0:
            bob += s[i].lower()
        else:
            bob += s[i].upper()
        i += 1
    return bob

# You are given a string of words (x), for each word within the string you need to turn the word
# 'inside out'. By this I mean the internal letters will move out, and the external letters move toward the centre.
# If the word is even length, all letters will move. If the length is odd, you are expected to leave the
# 'middle' letter of the word where it is.
# An example should clarify:
# 'taxi' would become 'atix' 'taxis' would become 'atxsi'
import re
def inside_out(s):
    return re.sub(r'\S+', lambda m: inside_out_word(m.group()), s)
def inside_out_word(s):
    i, j = len(s) // 2, (len(s) + 1) // 2
    return s[:i][::-1] + s[i:j] + s[j:][::-1]

# Alice and Bob have participated to a Rock Off with their bands. A jury of true
# metalheads rates the two challenges, awarding points to the bands on a scale from 1 to
# 50 for three categories: Song Heaviness, Originality, and Members' outfits.
# For each one of these 3 categories they are going to be awarded one point, should
# they get a better judgement from the jury. No point is awarded in case of an equal vote.
# You are going to receive two arrays, containing first the score of Alice's
# band and then those of Bob's. Your task is to find their total score by comparing them in a single line.
# Example:
# Alice's band plays a Nirvana inspired grunge and has been rated 20 for Heaviness, 32
# for Originality and only 18 for Outfits. Bob listens to Slayer and has gotten a good
# 48 for Heaviness, 25 for Originality and a rather honest 40 for Outfits.
# The total score should be followed by a colon : and by one of the following quotes:
# if Alice's band wins: Alice made "Kurt" proud! if Bob's band
# wins: Bob made "Jeff" proud! if they end up with a draw: that looks like a "draw"! Rock on!
# The solution to the example above should therefore appear like '1, 2: Bob made "Jeff" proud!'.
def solve(a, b):
    alice = sum(i > j for i, j in zip(a, b))
    bob = sum(j > i for i, j in zip(a, b))
    if alice == bob:
        words = 'that looks like a "draw"! Rock on!'
    elif alice > bob:
        words = 'Alice made "Kurt" proud!'
    else:
        words = 'Bob made "Jeff" proud!'
    return f"{alice}, {bob}: {words}"

# The borrowers are tiny tiny fictional people. As tiny tiny people they
# have to be sure they aren't spotted, or more importantly, stepped on.
# As a result, the borrowers talk very very quietly. They find that capitals and
# punctuation of any sort lead them to raise their voices and put them in danger.
# The young borrowers have begged their parents to stop using caps and punctuation.
# Change the input text s to new borrower speak. Help save the next generation!
def borrow(s):
    return s.replace(' ', '').replace('!', '').replace('?', '').replace('.', '').replace(',', '').replace(';', '').replace(':', '').lower()

# You are given array of integers, your task will be to count all pairs in that array and return their count.
# Notes:
# Array can be empty or contain only one value; in this case return 0
# If there are more pairs of a certain number, count each pair only once.
# E.g.: for [0, 0, 0, 0] the return value is 2 (= 2 pairs of 0s)
# Random tests: maximum array length is 1000, range of values in array is between 0 and 1000
def duplicates(arr):
    return sum(arr.count(i) // 2 for i in set(arr))

# Suppose we know the process by which a string s was encoded to a string r (see explanation below).
# The aim of the kata is to decode this string r to get back the original string s.
# Explanation of the encoding process:
# input: a string s composed of lowercase letters from "a" to "z", and a positive integer num
# we know there is a correspondence between abcde...uvwxyzand 0, 1, 2 ..., 23, 24, 25 : 0 <-> a, 1 <-> b ...
# if c is a character of s whose corresponding number is x, apply to x the function
# f: x-> f(x) = num * x % 26, then find ch the corresponding character of f(x)
# Accumulate all these ch in a string r
# concatenate num and r and return the result
# Task
# A string s was encoded to string r by the above process. complete the function
# to get back s whenever it is possible.
# Indeed it can happen that the decoding is impossible for strings composed
# of whatever letters from "a" to "z" when positive integer num has not been
# correctly chosen. In that case return "Impossible to decode".
from string import ascii_lowercase as aLow
def decode(r):
    i = next(i for i, c in enumerate(r) if c.isalpha())
    n, r = int(r[:i]), r[i:]
    maps = {chr(97 + n * k % 26): v for k, v in enumerate(aLow)}
    return "Impossible to decode" if len(maps) != 26 else ''.join(maps[c] for c in r)

# Write a function that takes an integer in input and outputs a string with currency format.
# Integer in currency format is expressed by a string of number where every three characters are separated by comma.
# For example:
def to_currency(price):
  return '{:,}'.format(price)

# Description:
# Given a string, you need to write a method that order every letter in this string in ascending order.
# Also, you should validate that the given string is not empty or null. If so, the method should return:
# "Invalid String!"
# Notes
# • the given string can be lowercase and uppercase.
# • the string could include spaces or other special characters like '# ! or ,'. Sort them based on their
# ASCII codes
def order_word(s):
    return ''.join(sorted(s, key=ord)) if s else 'Invalid String!'

# You are given a string of words and numbers. Extract the expression including:
# the operator: either addition ("gains") or subtraction ("loses")
# the two numbers that we are operating on
# Return the result of the calculation.
# Notes:
# "loses" and "gains" are the only two words describing operators
# No fruit debts nor bitten apples = The numbers are integers and no negatives
def calculate(string):
    d = {'gains': int(string.split()[2]) + int(string.split()[-1]), 'loses': int(string.split()[2]) - int(string.split()[-1])}
    return d['gains'] if 'gains' in string else d['loses']

# Implement a function which takes a sequence of objects and a property name, and returns a sequence containing
# the named property of each object.
# For example:
def pluck(objs, name):
    return [d[name] if name in d else None for d in objs]

# While developing a website, you detect that some of the members have troubles logging in.
# Searching through the code you find that all logins ending with a "_" make problems.
# So you want to write a function that takes an array of pairs of login-names and e-mails,
# and outputs an array of all login-name, e-mails-pairs from the login-names that end with "_".
def search_names(logins):
    return list(filter(lambda x: x[0].endswith('_'), logins))

# Python dictionaries are inherently unsorted. So what do you do if you need to sort the contents of a dictionary?
# Create a function that returns a sorted list of (key, value) tuples (Javascript: arrays of 2 items).
# The list must be sorted by the value and be sorted largest to smallest.
def sort_dict(d):
  return sorted(d.items(), key=lambda x: x[1], reverse=True)

# Given a random string consisting of numbers, letters, symbols, you need to sum up the numbers in the string.
# Note:
# Consecutive integers should be treated as a single number. eg, 2015 should be
# treated as a single number 2015, NOT four numbers
# All the numbers should be treaded as positive integer. eg, 11-14
# should be treated as two numbers 11 and 14. Same as 3.14, should be treated as two numbers 3 and 14
# If no number was given in the string, it should return 0
import re
def sum_from_string(string):
    return sum(int(i) for i in re.findall("\d+",string))

# Triangular number is any amount of points that can fill an equilateral triangle.
# Example: the number 6 is a triangular number because all sides of a triangle has the same amount of points.
def is_triangular(t):
    return (8 * t + 1)**.5 % 1 == 0

# Write function which will create a string from a list of strings, separated by space.
def words_to_sentence(words):
    return ' '.join(words)

# Convert a hash into an array. Nothing more, Nothing less.
# {name: 'Jeremy', age: 24, role: 'Software Engineer'}
# should be converted into
# [["name", "Jeremy"], ["age", 24], ["role", "Software Engineer"]]
# Note: The output array should be sorted alphabetically.
# Good Luck!
def convert_hash_to_array(hash):
    return sorted([[k, v] for k,v in hash.items()])

# A sequence is usually a set or an array of numbers that has a strict way
# for moving from the nth term to the (n+1)th term.
# If f(n) = f(n-1) + c where c is a constant value, then f is an arithmetic sequence.
# An example would be (where the first term is 0 and the constant is 1) is [0, 1, 2, 3, 4, 5, ... and so on] )
# Else if (pun) f(n) = f(n-1) * c where c is a constant value, then f is a geometric sequence.
# Example where the first term is 2 and the constant is 2 will be [2, 4, 8, 16, 32, 64, ... to infinity ... ]
# There are some sequences that aren't arithmetic nor are they geometric.
# Here is a link to feed your brain : Sequence !
# You're going to write a function that's going to return the value in the nth
# index of an arithmetic sequence.(That is, adding a constant to move to the next element in the "set").
# The function's name is nthterm/Nthterm, it takes three inputs first,n,c where:
# first is the first value in the 0 INDEX.
# n is the index of the value we want.
# c is the constant added between the terms.
# Remember that first is in the index 0 .. just saying ...
def nthterm(first, n, c):
    return first + n * c

# The way the ohms value needs to be formatted in the string you return depends on the magnitude of the value:
# For resistors less than 1000 ohms, return a string containing the number of ohms, a space,
# the word "ohms" followed by a comma and a space, the tolerance value (5, 10, or 20), and a percent sign.
# For example, for the "yellow violet black" resistor mentioned above, you would return "47 ohms, 20%".
# For resistors greater than or equal to 1000 ohms, but less than 1000000 ohms, you will use the same
# format as above, except that the ohms value will be divided by 1000 and have a lower-case "k" after it.
# For example, for a resistor with bands of "yellow violet red gold", you would return "4.7k ohms, 5%"
# For resistors of 1000000 ohms or greater, you will divide the ohms value by 1000000 and have
# an upper-case "M" after it. For example, for a resistor with bands of
# "brown black green silver", you would return "1M ohms, 10%"
# Test case resistor values will all be between 10 ohms and 990M ohms.
def decode_resistor_colors(bands):
    d = {'black':0, 'brown':1, 'red':2, 'orange':3, 'yellow':4, 'green':5, 'blue':6, 'violet':7, 'gray':8, 'white':9, 'silver':10, 'gold':5}
    bands = [d[b] for b in bands.split()]
    ohms = (bands[0] * 10 + bands[1]) * 10 ** bands[2]
    ohms, sfx = (ohms/1000000.0, 'M') if ohms > 999999 else (ohms / 1000.0, 'k') if ohms > 999 else (ohms, '')
    return "{}{} ohms, {}%".format(int(ohms) if ohms // 1 == ohms else ohms, sfx, bands[3] if len(bands) > 3 else 20)

# Given a string and an array of index numbers, return the characters of the string rearranged to be in
# the order specified by the accompanying array.
# Ex:
# scramble('abcd', [0,3,1,2]) -> 'acdb'
# The string that you will be returning back will have: 'a' at index 0, 'b' at index 3,
# 'c' at index 1, 'd' at index 2, because the order of those characters maps to their
# corresponding numbers in the index array.
# In other words, put the first character in the string at the index described by the first element of the array
# You can assume that you will be given a string and array of equal length and both containing valid characters
# (A-Z, a-z, or 0-9).
def scramble(string, array):
    return "".join(v for k, v in sorted(zip(array, string)))

# For every positive integer N, there exists a unique sequence starting with 1 and ending with
# N and such that every number in the sequence is either the double of the preceeding number or the double plus 1.
# For example, given N = 13, the sequence is [1, 3, 6, 13], because . . . :
#  3 =  2*1 +1
#  6 =  2*3
#  13 = 2*6 +1
# Write a function that returns this sequence given a number N.
# Try generating the elements of the resulting list in ascending order, i.e., without
# resorting to a list reversal or prependig the elements to a list.
def climb(n):
    return  [n >> n.bit_length() - i - 1 for i in range(n.bit_length())]

# Given an array of strings, reverse them and their order in such way that their length
# stays the same as the length of the original inputs.
def reverse(a):
    l = reversed(''.join(a))
    return [''.join(next(l) for k in i) for i in a]

# Write a function generatePairs (Javascript) / generate_pairs (Python / Ruby) that accepts an integer argument
# n and generates an array containing the pairs of integers [a, b] that satisfy the following conditions:
# 0 <= a <= b <= n
# The pairs should be sorted by increasing values of a then increasing values of b.
def generate_pairs(n):
    return [[i,j] for i in range(n+1) for j in range(i, n+1)]

# Your job is to create a simple password validation function, as seen on many websites.
# The rules for a valid password are as follows:
# There needs to be at least 1 uppercase letter.
# There needs to be at least 1 lowercase letter.
# There needs to be at least 1 number.
# The password needs to be at least 8 characters long.
# You are permitted to use any methods to validate the password.
import re
def password(s):
    return bool(re.match(r'(?=.*[A-Z])(?=.*[a-z])(?=.*\d).{8}', s))

# Suzuki needs help lining up his students!
# Today Suzuki will be interviewing his students to ensure they are progressing in their training.
# He decided to schedule the interviews based on the length of the students name in descending order.
# The students will line up and wait for their turn.
# You will be given a string of student names. Sort them and return a list of names in descending order.
# Here is an example input:
def lineup_students(s):
    return sorted(s.split(), key=lambda i:(len(i), i), reverse=True)

# Create a function that returns a villain name based on the user's birthday. The birthday will be passed to the function as a valid Date object, so for simplicity, there's no need to worry about converting strings to dates.
# The first name will come from the month, and the last name will come from the last digit of the date:
# Month -> first name
# January -> "The Evil"
# February -> "The Vile"
# March -> "The Cruel"
# April -> "The Trashy"
# May -> "The Despicable"
# June -> "The Embarrassing"
# July -> "The Disreputable"
# August -> "The Atrocious"
# September -> "The Twirling"
# October -> "The Orange"
# November -> "The Terrifying"
# December -> "The Awkward"
# Last digit of date -> last name
# 0 -> "Mustache"
# 1 -> "Pickle"
# 2 -> "Hood Ornament"
# 3 -> "Raisin"
# 4 -> "Recycling Bin"
# 5 -> "Potato"
# 6 -> "Tomato"
# 7 -> "House Cat"
# 8 -> "Teaspoon"
# 9 -> "Laundry Basket"
# The returned value should be a string in the form of "First Name Last Name".
# For example, a birthday of November 18 would return "The Terrifying Teaspoon"
def get_villain_name(birthdate):
    first = [ "The Evil","The Vile","The Cruel", "The Trashy","The Despicable", "The Embarrassing", "The Disreputable","The Atrocious", "The Twirling",  "The Orange","The Terrifying", "The Awkward"]
    last = ["Mustache", "Pickle", "Hood Ornament", "Raisin", "Recycling Bin", "Potato", "Tomato", "House Cat", "Teaspoon", "Laundry Basket"]
    return first[birthdate.month - 1] + ' ' + last[int(str(birthdate.day)[-1])]

# Challenge: Given two null-terminated strings in the arguments "string"
# and "prefix", determine if "string" starts with the "prefix" string. Return true or false.
# Example:
# startsWith("hello world!", "hello"); // should return true
# startsWith("hello world!", "HELLO"); // should return false
# startsWith("nowai", "nowaisir"); // should return false
# Addendum: For this problem, an empty "prefix" string should always return true for any value of "string".
# If the length of the "prefix" string is greater than the length of the "string", return false.
# The check should be case-sensitive, i.e. startsWith("hello", "HE") should return false, whereas
# startsWith("hello", "he") should return true.
# The length of the "string" as well as the "prefix" can be defined by the formula: 0 <= length < +Infinity
# No characters should be ignored and/or omitted during the test, e.g. whitespace characters should not be ignored.
def starts_with(st, prefix):
    return st.startswith(prefix)

# Create a function that takes an input String and returns a String, where all the uppercase words of
# the input String are in front and all the lowercase words at the end. The order of the
# uppercase and lowercase words should be the order in which they occur.
# If a word starts with a number or special character, skip the word and leave it out of the result.
# Input String will not be empty.
# For an input String: "hey You, Sort me Already!" the function should return: "You, Sort Already! hey me"
def capitals_first(string):
    return ' '.join([i for i in string.split() if i[0].isupper()] + [i for i in string.split() if i[0].islower()])

# You need to write a function, that returns the first non-repeated character in the given string.
# If all the characters are unique, return the first character of the string.
# If there is no unique character, return null in JS or Java, and None in Python.
# You can assume, that the input string has always non-zero length.
def first_non_repeated(s):
    result = [i for i in s if s.count(i) == 1]
    return result[0] if result else None

# Create a function, as short as possible, that returns this lyrics.
# Your code should be less than 300 characters. Watch out for the three points at the end of the song.
def baby_shark_lyrics():
    l = ['Baby shark', 'Mommy shark', 'Daddy shark', 'Grandma shark', 'Grandpa shark', "Let's go hunt"]
    res = ''
    for i in l:
        res += f"{i}, doo doo doo doo doo doo\n"*3 + i+'!\n'
    return res + "Run away,…"

# The hamming distance of two equal-length strings is the number of positions, in which the two string differ.
# In other words, the number of character substitutions required to transform one string into the other.
# For this first Kata, you will write a function hamming_distance(a, b) with two equal-length strings
# containing only 0s and 1s as parameters. There is no need to test the parameters for validity
# (but you can, if you want).The function's output should be the hamming distance of the two strings as an integer.
def hamming_distance(a, b):
    return sum(1 for k,v in zip(a, b) if k!=v)

# A non-empty array a of length n is called an array of all possibilities if it contains all numbers
# between [0,a.length-1].Write a method named isAllPossibilities that accepts an integer array and
# returns true if the array is an array of all possibilities, else false.
def is_all_possibilities(arr):
    return sorted(arr) == list(range(0, max(arr)+1)) if arr else False

# You are given a string representing a number in binary. Your task is to delete
# all the unset bits in this string and return the corresponding number (after keeping only the '1's).
# In practice, you should implement this function:
def eliminate_unset_bits(number):
    i = number.replace('0', '')
    return int(i, 2) if i  else 0

# Fix My Phone Numbers
# Oh thank goodness you're here! The last intern has completely ruined everything!
# All of our customer's phone numbers have been scrambled, and we need those phone numbers to
# annoy them with endless sales calls!
# The Format
# Phone numbers are stored as strings and comprise 11 digits, eg '02078834982' and must always start with a 0.
# However, something strange has happened and now all of the phone numbers contain lots
# of random characters, whitespace and some are not phone numbers at all!
# For example, '02078834982' has somehow become 'efRFS:)0207ERGQREG88349F82!' and there are lots more
# lines that we need to check.
# The Task
# Given a string, you must decide whether or not it contains a valid phone number. If
# it does, return the corrected phone number as a string ie. '02078834982' with no whitespace or
# special characters, else return "Not a phone number".
def is_it_a_num(s: str) -> str:
    n = ''.join(i for i in s if i.isdigit())
    res = n.startswith('0') and len(n) == 11
    return n if res else 'Not a phone number'

# Task
# Create a function shuffleIt. The function accepts two or more parameters. The first parameter arr
# is an array of numbers, followed by an arbitrary number of numeric arrays.
# Each numeric array contains two numbers, which are indices for elements in
# arr (the numbers will always be within bounds). For every such array, swap the
# elements. Try to use all your new skills: arrow functions,
# the spread operator, destructuring, and rest parameters.
def shuffle_it(arr, *args):
    for k,v in args:
        arr[k], arr[v] = arr[v], arr[k]
    return arr

# Implement a function to calculate the sum of the numerical values in a nested list. For example :
def sum_nested(lst):
	return sum(sum_nested(x) if isinstance(x,list) else x for x in lst)

# In this Kata, you will be given a string and your task is to return the most valuable character.
# The value of a character is the difference between the index of its last occurrence and the index
# of its first occurrence. Return the character that has the highest value. If there is
# a tie, return the alphabetically lowest character. [For Golang return rune]
def solve(st):
    return sorted((st.find(i) - st.rfind(i), i) for i in set(st))[0][1]

# Given a string as input, move all of its vowels to the end of the string, in the same order as they were before.
# Vowels are (in this kata): a, e, i, o, u
# Note: all provided input strings are lowercase.
def move_vowels(s):
    return ''.join(sorted(s, key=lambda x: x in 'aeiou'))

# You are given an initial 2-value array (x). You will use this to calculate a score.
# If both values in (x) are numbers, the score is the sum of the two. If only one is a number,
# the score is that number. If neither is a number, return 'Void!'.
# Once you have your score, you must return an array of arrays. Each sub array will be the same as
# (x) and the number of sub arrays should be equal to the score.
# For example:
def explode(arr):
    numbers = [i for i in arr if type(i) == int]
    return [arr] * sum(numbers) if numbers else "Void!"

# Create a function that takes a 2D array as an input, and outputs another array that contains
# the average values for the numbers in the nested arrays at the corresponding indexes.
# Note: the function should also work with negative numbers and floats.
def avg_array(arrs):
    return [sum(i) / len(i) for i in zip(*arrs)]

# Let's assume we need "clean" strings. Clean means a string should only contain letters a-z, A-Z and spaces.
# We assume that there are no double spaces or line breaks.
# Write a function that takes a string and returns a string without the unnecessary characters.
def remove_chars(s):
    return ''.join(i for i in s if i.isalpha() or i == ' ')

# This is a follow up from my kata The old switcheroo
# Write the function :
# def encode(str)
# that takes in a string str and replaces all the letters with their respective positions in the English alphabet.
def encode(string):
    return ''.join(str(ord(i.lower())-96) if i.isalpha() else i for i in string)

# Kevin is noticing his space run out! Write a function that removes the spaces from
# the values and returns an array showing the space decreasing. For example, running this function
# on the array ['i', 'have','no','space'] would produce ['i','ihave','ihaveno','ihavenospace'].
def spacey(array):
    return [''.join(array[:i]) for i in range(1, len(array) + 1)]

# Given two arrays of integers m and n, test if they contain at least one identical element.
# Return true if they do; false if not.
# Your code must handle any value within the range of a 32-bit integer,
# and must be capable of handling either array being empty (which is a false result, as
# there are no duplicated elements).
def duplicate_elements(m, n):
    return bool(set(m) & set(n))

# In a certain kingdom, strange mathematics is taught at school. Its main difference from
# ordinary mathematics is that the numbers in it are not ordered in ascending order, but
# lexicographically, as in a dictionary (first by the first digit, then,
# if the first digit is equal, by the second, and so on). In addition,
# we do not consider an infinite set of natural numbers, but only the first n numbers.
# So, for example, if n = 11, then the numbers in strange mathematics are ordered as follows:
# 1, 10, 11, 2, 3, 4, 5, 6, 7, 8, 9.
# Help your students to learn this science: write a function that receives two integer
# numbers: n (total amount of numbers in strange mathematics) and k (number from sequence)
# and returns the location of a given number k in the order defined in strange mathematics.
# For example, if n = 11 and k = 2, the function should return 4 as the answer.
# Input: 1 <= n <= 100 000 , 1 <= k <= n.
# Output: position of the number k in sequence of the first n natural numbers in lexicographic
# order. Numbering starts with 1.
def strange_math(n, k):
    return sorted(range(n + 1), key=str).index(k)

# In this Kata, you will be given a string and your task will be to return the length of the
# longest prefix that is also a suffix. A prefix is the start of a string while
# the suffix is the end of a string. For instance, the prefixes of the string
# "abcd" are ["a","ab","abc"]. The suffixes are ["bcd", "cd", "d"]. You should not overlap the prefix and suffix.
def solve(st):
    return next((i for i in range(len(st) // 2, 0, -1) if st[:i] == st[-i:]), 0)

# I've got a crazy mental illness. I dislike numbers a lot. But it's a
# little complicated: The number I'm afraid of depends on which day of the week it is...
# This is a concrete description of my mental illness:
# Monday --> 12
# Tuesday --> numbers greater than 95
# Wednesday --> 34
# Thursday --> 0
# Friday --> numbers divisible by 2
# Saturday --> 56
# Sunday --> 666 or -666
# Write a function which takes a string (day of the week) and an integer
# (number to be tested) so it tells the doctor if I'm afraid or not. (return a boolean)
def am_I_afraid(day,num):
    return {'Monday':  num == 12,'Tuesday': num > 95,'Wednesday': num == 34,'Thursday': num == 0,'Friday': num % 2 == 0,'Saturday': num ==  56,'Sunday': num == 666 or num == -666,}[day]

# There were and still are many problem in CW about palindrome numbers and palindrome strings. We
# suposse that you know which kind of numbers they are. If not, you
# may search about them using your favourite search engine.
# In this kata you will be given a positive integer, val and you have to create the function next_pal
# ()(nextPal Javascript) that will output the smallest palindrome number higher than val.
def next_pal(val):
    val += 1
    while str(val) != str(val)[::-1]:
        val += 1
    return val

# The Ones' Complement of a binary number is the number obtained by swapping all the
# 0s for 1s and all the 1s for 0s. For example:
def ones_complement(binary_number):
    return ''.join('1' if i == '0' else '0' for i in binary_number)

# In the drawing below we have a part of the Pascal's triangle, horizontal lines are numbered from zero (top).
# We want to calculate the sum of the squares of the binomial coefficients on
# a given horizontal line with a function called easyline (or easyLine or easy-line).
# Can you write a program which calculate easyline(n) where n is the horizontal line number?
# The function will take n (with: n>= 0) as parameter and will return the sum of the squares
# of the binomial coefficients on line n.
def easyline(n):
    return easyline(n - 1) * (4 * n - 2) // n if n else 1

# Implement a function that receives two integers m and n and generates a sorted list
# of pairs (a, b) such that m <= a <= b <= n.
# The input m will always be smaller than or equal to n (e.g., m <= n)
def generate_pairs(m, n):
    return [(i,k) for i in range(m, n + 1) for k in range(i, n + 1)]

# Fast & Furious Driving School's (F&F) charges for lessons are as below:
# Time	Cost
# Up to 1st hour	$30
# Every subsequent half hour**	$10
# ** Subsequent charges are calculated by rounding up to nearest half hour.
# For example, if student X has a lesson for 1hr 20 minutes, he will be charged $40 (30+10)
# for 1 hr 30 mins and if he has a lesson for 5 minutes, he will be charged $30 for the full hour.
# Out of the kindness of its heart, F&F also provides a 5 minutes grace period. So, if student X were to
# have a lesson for 65 minutes or 1 hr 35 mins, he will only have to pay for an hour or 1hr 30 minutes respectively.
# For a given lesson time in minutes (min) , write a function cost to calculate how much the lesson
# costs. Input is always > 0.
import math
def cost(mins):
    return 30 + 10 * math.ceil(max(0, mins - 60 - 5) / 30)

# An array is called zero-plentiful if it contains multiple zeros, and every sequence of zeros is at
# least 4 items long.
# Your task is to return the number of zero sequences if the given array is zero-plentiful, oherwise 0.
def zero_plentiful(a):
    r = [len(i) for i in ''.join('0' if not e else ' ' for e in a).strip().split()]
    return len(r) if r and min(r) >= 4 else 0

# Your Task
# Complete the function to convert an integer into a string of the Turkish name.
# input will always be an integer 0-99;
# output should always be lower case.
# Background
# Forming the Turkish names for the numbers 0-99 is very straightforward:
# units (0-9) and tens (10, 20, 30, etc.) each have their own unique name;
# all other numbers are simply [tens] + [unit], like twenty one in English.
# Unlike English, Turkish does not have "teen"-suffixed numbers; e.g.
# 13 would be directly translated as "ten three" rather than "thirteen" in English.
def get_turkish_number(n):
    units = ' bir iki üç dört beş altı yedi sekiz dokuz'.split(' ')
    tens  = ' on yirmi otuz kırk elli altmış yetmiş seksen doksan'.split(' ')
    return f'{tens[n // 10]} {units[n % 10]}'.strip() or 'sıfır'

# Given an array containing only integers, add all the elements and return the binary equivalent of that sum.
# If the array contains any non-integer element (e.g. an object, a float, a string and so on), return false.
# Note: The sum of an empty array is zero.
def arr2bin(arr):
    return bin(sum(arr))[2:] if all(type(i) == int for i in arr) else False

# Kate and Michael want to buy a pizza and share it. Depending on the price of the pizza,
# they are going to divide the costs:
# If the pizza is less than €5,- Michael invites Kate, so Michael pays the full price.
# Otherwise Kate will contribute 1/3 of the price, but no more than €10 (she's broke :-) and Michael pays the rest.
# How much is Michael going to pay? Calculate the amount with two decimals, if necessary.
def michael_pays(cost):
    return round(cost if cost < 5 else max(cost * 2 / 3, cost - 10), 2)

# Complete the function word (string) and returns a string that spells the word using the NATO phonetic alphabet.
# There should be a space between each word in the returned string, and the first letter of each word should
# be capitalized.
# For those of you that don't want your fingers to bleed, this kata already has a dictionary typed out for you.
def nato(word):
    return ' '.join(LETTERS[i.upper()] for i in word)

# You have to create a function that converts integer given as string into ASCII uppercase letters.
# All ASCII characters have their numerical order in table.
# For example,
# from ASCII table, character of number 65 is "A".
# Numbers will be next to each other, So you have to split given number to two digit long integers.
def convert(number):
    word = ''
    while number:
        word += chr(int(number[:2]))
        number = number[2:]
    return word

# A new school year is approaching, which also means students will be taking tests.
# The tests in this kata are to be graded in different ways. A certain number of points will be given for
# each correct answer and a certain number of points will be deducted for each incorrect answer.
# For ommitted answers, points will either be awarded, deducted, or no points will be given at all.
# Return the number of points someone has scored on varying tests of different lengths.
# The given parameters will be:
# An array containing a series of 0s, 1s, and 2s, where 0 is a correct answer, 1 is an omitted answer, and
# 2 is an incorrect answer.
# The points awarded for correct answers
# The points awarded for ommitted answers (note that this may be negative)
# The points deducted for incorrect answers (hint: this value has to be subtracted)
# Note: The input will always be valid (an array and three numbers)
def score_test(tests, right, omit, wrong):
    return tests.count(0) * right + tests.count(1) * omit - tests.count(2) * wrong

# In this kata you need to build a function to return either true/True or false/False
# if a string can be seen as the repetition of a simpler/shorter subpattern or not.
def has_subpattern(string):
    return (string * 2).find(string, 1) != len(string)

# Happy Holidays fellow Code Warriors!
# It's almost Christmas Eve, so we need to prepare some milk and cookies for Santa! Wait...
# when exactly do we need to do that?
# Time for Milk and Cookies
# Complete the function function that accepts a Date object, and returns true if it's
# Christmas Eve (December 24th), false otherwise.
def time_for_milk_and_cookies(dt):
    return str(dt)[-5:-3] == '12' and str(dt)[-2:] == '24'

# Error Handling is very important in coding and seems to be overlooked or not implemented properly.
#Task
# Your task is to implement a function which takes a string as input and return an object containing
# the properties vowels and consonants. The vowels property must contain the total count of
# vowels {a,e,i,o,u}, and the total count of consonants {a,..,z} - {a,e,i,o,u}.
# Handle invalid input and don't forget to return valid ones.
#Input
# The input is any random string. You must then discern what are vowels and what are
# consonants and sum for each category their total occurrences in an object. However you
# could also receive inputs that are not strings. If this happens then you must return
# an object with a vowels and consonants total of 0 because the input was NOT a string.
# Refer to the Example section for a more visual representation of which inputs you could receive
# and the outputs expected. :)
def get_count(words=""):
    if not isinstance(words, str):
        return {'vowels': 0,'consonants': 0}
    letter = "".join([c.lower() for c in words if c.isalpha()])
    vowel = "".join([c for c in letter if c in 'aeiou'])
    conson = "".join([c for c in letter if c not in 'aeiou'])
    return {'vowels': len(vowel),'consonants': len(conson)}

# We have the number 12385. We want to know the value of the closest cube but higher
# than 12385. The answer will be 13824.
# Now, another case. We have the number 1245678. We want to know the 5th power, closest and
# higher than that number. The value will be 1419857.
# We need a function find_next_power ( findNextPower in JavaScript, CoffeeScript and Haskell), that receives two
# arguments, a value val, and the exponent of the power, pow_, and outputs the value that
def find_next_power(val, pow_):
    return int(val ** (1.0 / pow_) + 1) ** pow_

# Sam is an avid collector of numbers. Every time he finds a new number he throws it on the top of his number-pile.
# Help Sam organise his collection so he can take it to the International Number Collectors Conference in Cologne.
# Given an array of numbers, your function should return an array of arrays, where
# each subarray contains all the duplicates of a particular number. Subarrays should be in the same
# order as the first occurence of the number they contain:
def group(arr):
    return [[v] * arr.count(v) for k, v in enumerate(arr) if arr.index(v) == k]

# An Ironman Triathlon is one of a series of long-distance triathlon races organized by the
# World Triathlon Corporaion (WTC). It consists of a 2.4-mile swim,
# a 112-mile bicycle ride and a marathon (26.2-mile) (run, raced in that order
# and without a break. It hurts... trust me.
# Your task is to take a distance that an athlete is through the race, and return one of the following:
# If the distance is zero, return 'Starting Line... Good Luck!'.
# If the athlete will be swimming, return an object with 'Swim' as the key, and the
# remaining race distance as the value.
# If the athlete will be riding their bike, return an object with 'Bike' as the key,
# and the remaining race distance as the value.
# If the athlete will be running, and has more than 10 miles to go, return an object with
# 'Run' as the key, and the remaining race distance as the value.
# If the athlete has 10 miles or less to go, return return an object with 'Run' as the key,
# and 'Nearly there!' as the value.
# Finally, if the athlete has completed te distance, return "You're done! Stop running!".
# All distance should be calculated to two decimal places.
def i_tri(s):
    time = 2.4 + 112.0 + 26.2
    v = time - s
    k = "Swim" if s < 2.4 else "Bike" if s >= 2.4 and s < 114.4 else 'Run'
    if s == 0: return 'Starting Line... Good Luck!'
    elif s >= time: return "You're done! Stop running!"
    elif time - s <= 10: return {'Run':'Nearly there!'}
    else: return {k: "{:.2f}".format(v) + ' to go!'}

# Please write a function that sums a list, but ignores any duplicate items in the list.
# For instance, for the list [3, 4, 3, 6] , the function should return 10.
def sum_no_duplicates(l):
    return sum([i for i in l if l.count(i) == 1])

# Your task is to write a function that takes two or more objects and returns a new
# object which combines all the input objects.
# All input object properties will have only numeric values. Objects are combined
# together so that the values of matching keys are added together.
# An example:
from collections import Counter
def combine(*args):
    return sum((Counter(i) for i in args), Counter())

# Create a function that takes an array of letters, and combines them into words in a sentence.
# The array will be formatted as so:
# [
#   ['J','L','L','M'],
#   ['u','i','i','a'],
#   ['s','v','f','n'],
#   ['t','e','e','']
# ]
# The function should combine all the 0th indexed letters to create the word 'just', all
# the 1st indexed letters to create the word 'live', etc.
# Shorter words will have an empty string in the place once the word has already
# been mapped out (see the last element in the last element in the array).
def arr_adder(arr):
    return ' '.join(map(''.join, zip(*arr)))

# A triangle is called an equable triangle if its area equals its perimeter. Return true, if
# it is an equable triangle, else return false. You will be provided with
# the length of sides of the triangle. Happy Coding!
def equable_triangle(a,b,c):
    p = (a + b + c) / 2
    return (p*(p-a)*(p-b)*(p-c)) ** .5 == a + b + c

# To celebrate today's launch of my Hero's new book: Alan Partridge: Nomad, We
# have a new series of kata arranged around the great man himself.
# Task
# Given an array of terms, if any of those terms relate to Alan Partridge, return Mine's a Pint!
# The number of exclamation mark (!) after the t should be determined by the number of Alan
# related terms you find in the given array (x). The related terms are as follows:
def part(arr):
    l = ['Partridge', 'PearTree', 'Chat', 'Dan', 'Toblerone', 'Lynn', 'AlphaPapa', 'Nomad']
    s = sum(1 for i in arr if i in l)
    return f"Mine's a Pint{'!'*s}" if any(i in l for i in arr) else "Lynn, I've pierced my foot on a spike!!"

# When no more interesting kata can be resolved, I just choose to create the new kata, to
# solve their own, to enjoy the process --myjinxin2015 said
# Note:
# arr/$a always has at least 5 elements;
# range/$range/ranges always has at least 1 element;
# All inputs are valid;
def max_sum(arr,ranges):
    return max([sum(arr[i] for i in range(j[0], j[1]+1)) for j in ranges])

# Do you speak retsec?
# You and your friends want to play undercover agents. In order to exchange
# your secret messages, you've come up with the following system: you take
# the word, cut it in half, and place the first half behind the latter. If the
# word has an uneven number of characters, you leave the middle at its previous place:
def reverse_by_center(s):
    return s[len(s)//2:] + s[:len(s)//2] if len(s) % 2 == 0 else s[len(s)//2+1:] + s[len(s)//2] + s[:len(s)//2]

# This kata is all about adding numbers.
# You will create a function named add. This function will return the sum
# of all the arguments. Sounds easy, doesn't it??
# Well here's the twist. The inputs will gradually increase with their index as parameter to the function.
def add(*args):
    return sum(v * (k + 1) for k,v in enumerate(args))

# In English, all words at the begining of a sentence should begin with a capital letter.
# You will be given a paragraph that does not use capital letters.
# Your job is to capitalise the first letter of the first word of each sentence.
# For example,
# input:
# "hello. my name is inigo montoya. you killed my father. prepare to die."
# output:
# "Hello. My name is inigo montoya. You killed my father. Prepare to die."
# You may assume:
# there will be no punctuation besides full stops and spaces
# all but the last full stop will be followed by a space and at least one word
def fix(paragraph):
    return '. '.join(i.capitalize() for i in paragraph.split('. '))

# Write a function with the signature shown below:
# def is_int_array(arr):
#     return True
# returns true  / True if every element in an array is an integer or a float with no decimals.
# returns true  / True if array is empty.
# returns false / False for every other input.
def is_int_array(arr):
    try:
        return arr == list(map(int, arr))
    except:
        return False

# Write a function, factory, that takes a number as its parameter and returns another function.
# The returned function should take an array of numbers as its parameter, and return an array of those
# numbers multiplied by the number that was passed into the first function.
# In the example below, 5 is the number passed into the first function. So it returns
# a function that takes an array and multiplies all elements in it by five.
# Translations and comments (and upvotes) welcome!
def factory(x):
    return lambda i: [x * j for j in i]

# Create a function that returns the lowest product of 4 consecutive digits in a number given as a string.
# This should only work if the number has 4 digits or more. If not, return "Number is too small".
from operator import mul
from functools import reduce
def lowest_product(input):
    return min(reduce(mul, [*map(int, input)][i:i + 4]) for i in range(0, len(input) - 3)) if len(input) > 3 else "Number is too small"

# Format any integer provided into a string with "," (commas) in the correct places.
def number_format(n):
    return format(n, ',d')

# Colour plays an important role in our lifes. Most of us like this colour better then another.
# User experience specialists believe that certain colours have certain psychological meanings for us.
# You are given a 2D array, composed of a colour and its 'common' association in each array element. The function
# you will write needs to return the colour as 'key' and association as its 'value'.
def colour_association(arr):
    return [{i[0]: i[1]} for i in arr]

# Your job is to check that the provided list / array of stations contains all
# of the stops Alan mentions. The list of stops are as follows:
def alan(arr):
    stations = ['Rejection','Disappointment','Backstabbing Central','Shattered Dreams Parkway']
    return 'Smell my cheese you mother!' if all(i in arr for i in stations) else 'No, seriously, run. You will miss it.'

# Write a function that returns only the decimal part of the given number.
# You only have to handle valid numbers, not Infinity, NaN, or similar. Always return a positive decimal part.
def get_decimal(n):
    return abs(n) % 1

# Make your strings more nerdy: Replace all 'a'/'A' with 4, 'e'/'E' with 3 and
# 'l' with 1 e.g. "Fundamentals" --> "Fund4m3nt41s"
def nerdify(txt):
    d = {'a': 4, 'e': 3, 'l': 1, 'A': 4, 'E': 3}
    return ''.join(str(d[i]) if i in d else i for i in txt)

# The GADERYPOLUKI is a simple substitution cypher used in scouting to encrypt messages. The
# encryption is based on short, easy to remember key.
# The key is written as paired letters, which are in the cipher simple replacement.
# The most frequently used key is "GA-DE-RY-PO-LU-KI".
#  G => A
#  g => a
#  a => g
#  A => G
#  D => E
#   etc.
# The letters, which are not on the list of substitutes, stays in the encrypted text without changes.
# Task
# Your task is to help scouts to encrypt and decrypt thier messages. Write the Encode and Decode functions.
# Input/Output
# The input string consists of lowercase and uperrcase characters and white . The substitution has to be
# case-sensitive.
def encode(str):
    return str.translate(str.maketrans("GDRPLKAEYOUIgdrplkaeyoui","AEYOUIGDRPLKaeyouigdrplk"))
def decode(str):
    return encode(str)

# Write function makeParts or make_parts (depending on your language) that will
# take an array as argument and the size of the chunk.
# Example: if an array of size 123 is given and chunk size is 10 there will be
# 13 parts, 12 of size 10 and 1 of size 3.
def make_parts(arr, chunkSize):
    return [arr[i: i + chunkSize] for i in range(0, len(arr), chunkSize)]

# You have a collection of lovely poems. Unfortunately, they aren't formatted very well. They're all on
# one line, like this:
# Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex
# is better than complicated.
# What you want is to present each sentence on a new line, so that it looks like this:
# Beautiful is better than ugly.
# Explicit is better than implicit.
# Simple is better than complex.
# Complex is better than complicated.
# Write a function, format_poem() that takes a string like the one line example as an argument and
# returns a new string that is formatted across multiple lines with each new sentence starting on a new line when
# you print it out.
# Try to solve this challenge with the str.split() and the str.join() string methods.
# Every sentence will end with a period, and every new sentence will have one space before the previous period.
# Be careful about trailing whitespace in your solution.
def format_poem(poem):
    return '.\n'.join(poem.split('. '))

# You are a barista at a big cafeteria. Normally there are a lot of baristas,
# but your boss runs a contest and he told you that, if you could
# handle all the orders with only one coffee machine in such a way that the
# sum of all the waiting times of the customers is the smallest possible, he will give you a substantial raise.
# So you are the only barista today, and you only have one coffee machine that can brew one coffee at a time.
# People start giving you their orders.
# Let's not think about the time you need to write down their orders, but you need
# 2 additional minutes to clean the coffee machine after each coffee you make.
# Now you have a list coffees of the orders and you write down next to each of the orders the time
# you need to brew each one of those cups of coffee.
# Task:
# Given a list of the times you need to brew each coffee, return the minimum total waiting time.
# If you get it right, you will get that raise your boss promised you!
def barista(coffees):
    return sum(v * (k + 1) + 2 * k for k,v in enumerate(sorted(coffees, reverse=True)))

# Implement function which will return sum of roots of a quadratic equation rounded
# to 2 decimal places, if there are any possible roots, else return None/null/nil/nothing.
# If you use discriminant,when discriminant = 0, x1 = x2 = root => return sum of both roots.
# There will always be valid arguments.
def roots(a,b,c):
    return round(-b / a, 2) if b ** 2 >= 4 * a * c else None

# The factorial of a number, n!, is defined for whole numbers as the product of all integers from 1 to n.
# For example, 5! is 5 * 4 * 3 * 2 * 1 = 120
# Most factorial implementations use a recursive function to determine the value of factorial(n). However,
# this blows up the stack for large values of n - most systems
# cannot handle stack depths much greater than 2000 levels.
# Write an implementation to calculate the factorial of arbitrarily large numbers, without recursion.
import math
def factorial(n):
    return math.prod(list(range(1, n + 1))) if n >= 0 else None

# You have to write a function pattern which creates the following pattern (see examples) up to the desired
# number of rows.
# If the Argument is 0 or a Negative Integer then it should return "" i.e. empty string.
# If any even number is passed as argument then the pattern should last upto the largest
# odd number which is smaller than the passed even number.
def pattern(n):
    c = n if n % 2 == 0 else n + 1
    return '\n'.join(str(i)*i for i in range(1, c, 2))

# You have two arrays in this kata, every array contains unique elements only. Your task
# is to calculate number of elements in the first array which are also present in the second array.
def match_arrays(v, r):
    return sum(1 for i in v if i in r)

# The odd and even numbers are fighting against each other!
# You are given a list of positive integers. The odd numbers from the list will fight using their 1 bits
# from their binary representation, while the even numbers will fight using their 0 bits.
# If present in the list, number 0 will be neutral, hence not fight for either side.
# You should return:
# odds win if number of 1s from odd numbers is larger than 0s from even numbers
# evens win if number of 1s from odd numbers is smaller than 0s from even numbers
# tie if equal, including if list is empty
# Please note that any prefix that might appear in the binary representation, e.g. 0b,
# should not be counted towards the battle.
def bits_battle(numbers):
    odd = 0
    even = 0
    for n in numbers:
        if n % 2:
            odd += bin(n).count('1')
        elif n != 0 and n % 2 == 0:
            even += bin(n)[2:].count('0')
    return 'odds win' if odd > even else 'evens win' if even > odd else 'tie'

# Create a function mispelled(word1, word2):
# It checks if the word2 differs from word1 by at most one character.
# This can include an extra char at the end or the beginning of either of words.
# In the tests that expect true, the mispelled word will always differ mostly by
# one character. If the two words are the same, return True.
def mispelled(word1, word2):
    if word1 == word2[1:] or word1[1:] == word2 or word1[:-1] == word2 or word1 == word2[:-1]:
        return True
    if any(word1[:i] + word1[i+1:] == word2[:i] + word2[i+1:] for i in range(len(word1))):
        return True
    else:
        return False

# Calculate area of given triangle. Create a function t_area that will take a string
# which will represent triangle, find area of the triangle, one space will be
# equal to one length unit. The smallest triangle will have one length unit.
def t_area(s):
    return (s.count('\n') - 2) ** 2 / 2

# You will be given two strings a and b consisting of lower case letters, but a will
# have at most one asterix character. The asterix (if any) can be replaced with an
# arbitrary sequence (possibly empty) of lowercase letters. No other character of string a can be replaced.
# If it is possible to replace the asterix in a to obtain string b, then string b matches the pattern.
# If the string matches, return true else false.
import re
def solve(a, b):
    return bool(re.fullmatch(a.replace('*', '.*'), b))

# Complete the function so that it returns the number of seconds that have elapsed between the start
# and end times given.
# Tips:
# The start/end times are given as Date (JS/CoffeeScript), DateTime (C#), Time (Nim),
# datetime(Python) and Time (Ruby) instances.
# The start time will always be before the end time.
def elapsed_seconds(start, end):
    return (end - start).total_seconds()

# The input will be an array of dictionaries.
# Return the values as a string-seperated sentence in the order of their keys' integer equivalent
# (increasing order).
# The keys are not reoccurring and their range is -999 < key < 999. The dictionaries'
# keys & values will always be strings and will always not be empty.
def sentence(ds):
    return ' '.join(v for k, v in sorted((int(k), v) for d in ds for k, v in d.items()))

# In Bali, as far as I can gather, when ex-pats speak to locals, they basically insert the word 'Pak' as often as
# possible. I am assured it means something like 'mate' or 'sir' but that could be completely wrong.
# Anyway, as some basic language education(??) this kata requires you to turn any sentence provided (s)
# into ex-pat balinese waffle by inserting the word 'pak' between every other word. Simple 8kyu :D
# Pak should not be the first or last word. Strings of just spaces should return an empty string.
def pak(s):
    return ' pak '.join(s.split())

# A History Lesson
# Tetris is a puzzle video game originally designed and programmed by Soviet Russian
# software engineer Alexey Pajitnov. The first playable version was completed on June 6,
# 1984. Pajitnov derived its name from combining the Greek numerical prefix tetra
# - (the falling pieces contain 4 segments) and tennis, Pajitnov's favorite sport.
# About scoring system
# The scoring formula is built on the idea that more difficult line clears should be awarded more points. For
# example, a single line clear is worth 40 points, clearing four lines at once (known as a Tetris) is worth 1200
# A level multiplier is also used. The game starts at level 0. The level increases
# every ten lines you clear. Note that after increasing the level, the total number of cleared lines is not reset.
# For our task you can use this table:
def get_score(arr) -> int:
    return sum([0, 40, 100, 300, 1200][v] * (1 + (sum(arr[:k]) // 10)) for k, v in enumerate(arr))

# Complete the function that accepts a valid string and returns an integer.
# Wait, that would be too easy! Every character of the string should be converted
# to the hex value of its ascii code, then the result should be the sum of
# the numbers in the hex strings (ignore letters).
def hex_hash(code):
    return sum(int(i) for j in code for i in hex(ord(j)) if i.isdigit())

# Is the number even?
# If the numbers is even return true. If it's odd, return false.
# Oh yeah... the following symbols/commands have been disabled!
# use of %
# use of .even? in Ruby
# use of mod in Python
def is_even(n):
    return n // 2 == n / 2

# Implement the method lastIndexOf (last_index_of in PHP and Python), which accepts a linked list (head) and
# a value, and returns the index (zero based) of the last occurrence of that value if exists, or -1 otherwise.
# For example: Given the list: 1 -> 2 -> 3 -> 3, and the value 3, lastIndexOf / last_index_of should return 3.
def last_index_of(head, search_val):
    count = pos = -1
    while head:
        count += 1
        if head.data == search_val:
            pos = count
        head = head.next
    return pos

# A squared string is a string of n lines, each substring being n characters long.
# We are given two n-squared strings. For example:
# s1 = "abcd\nefgh\nijkl\nmnop" s2 = "qrst\nuvwx\nyz12\n3456"
# Let us build a new string strng of size (n + 1) x n in the following way:
# The first line of strng has the first char of the first line of s1 plus the chars of the last line of s2.
# The second line of strng has the first two chars of the second line of s1 plus the chars
# of the penultimate line of s2 except the last char
# and so on until the nth line of strng has the n chars of the nth line of s1
# plus the first char of the first line of s2.
def compose(s1, s2):
    s1 = s1.split("\n")
    s2 = s2.split("\n")[::-1]
    count = len(s1)
    out = []
    for i in range(count):
        out.append(s1[i][:i+1] + s2[i][:(count-i)])
    return "\n".join(out)

# Suppose a variable x can have only three possible different values a, b and c, and you wish to assign to x
# the value other than its current one, and you wish your code to be independent of the values of a, b and c.
# What is the most efficient way to cycle among three values? Write a function f so that it satisfies
def f(x, a, b, c):
    return {a: b, b: c, c: a}[x]

# Why would we want to stop to only 50 shades of grey? Let's see to how many we can go.
# Write a function that takes a number n as a parameter and return an array containing
# n shades of grey in hexadecimal code (#aaaaaa for example). The array should be sorted
# in ascending order starting with '#010101', '#020202', etc. (using lower case letters).
def shades_of_grey(n):
    return [ '#{0:02x}{0:02x}{0:02x}'.format(i+1) for i in range(min(254, n)) ]

# You have to write a function pattern which creates the following pattern upto n number of rows.
# If the Argument is 0 or a Negative Integer then it should return "" i.e. empty string.
def pattern(integer):
    return "\n".join("".join(str(j) for j in range(integer, integer - i, -1)) for i in range(1, integer + 1))

# Complete the function that takes an array of integers as input and finds the sum of squares of
# the elements at even positions (i.e. 2nd, 4th, etc.) plus the sum of the rest of the elements at odd position.
# For empty arrays, result should be zero (except for Haskell).
# Note
# The values at even positions need to be squared. For a language with zero-based indices,
# this will occur at oddly-indexed locations. For instance, in Python,
# the values at indices 1, 3, 5, etc. should be squared because these are the second,
# fourth, and sixth positions in the list.
def alternate_sq_sum(arr):
    return sum(v ** 2 if k % 2 else v for k, v in enumerate(arr))

# Write a function which maps a function over the lists in a list:
def grid_map(inp, op):
    return [list(map(op, i)) for i in inp]

# Write a module Converter that can take ASCII text and convert it to hexadecimal. The class should
# also be able to take hexadecimal and convert it to ASCII text. To make the
# conversion well defined, each ASCII character is represented by exactly two hex digits,
# left-padding with a 0 if needed. The conversion from ascii to
# hex should produce lowercase strings (i.e. f6 instead of F6).
class Converter():
    @staticmethod
    def to_ascii(h):
        return bytes.fromhex(h).decode()
    @staticmethod
    def to_hex(s):
        return ''.join(hex(ord(i))[2:] for i in s)

# Your non-profit company has assigned you the task of calculating some simple statistics on donations. You have
# an array of integers, representing various amounts of donations your company has been given.
# In particular, you're interested in the median value for donations.
# The median is the middle number of a sorted list of numbers. If the list
# is of even length, the 2 middle values are averaged.
# Write a function that takes an array of integers as an argument and returns the median of those integers.
# Notes:
# The sorting step is vital.
# Input arrays are non-empty.
def median(array):
    l = len(array) % 2 != 0
    return sorted(array)[len(array)//2] if l else (sorted(array)[len(array)//2-1] + sorted(array)[len(array)//2])/2

# A palindrome is a word, phrase, number, or other sequence of characters which
# reads the same backward as forward. Examples of numerical palindromes are:
# 2332
# 110011
# 54322345
# You'll be given 2 numbers as arguments: (num,s). Write a function which returns an array
# of s number of numerical palindromes that come after num. If num is a palindrome itself,
# it should be included in the count.
# Return "Not valid" instead if any one of the inputs is not an integer or is less than 0.
# For this kata, single digit numbers will NOT be considered numerical palindromes.
def palindrome(num,s):
    if type(num) != int or num <= 0 or type(s) != int or s < 0:
        return 'Not valid'
    l = []
    c = 0
    while c < s:
        if str(num) == str(num)[::-1] and len(str(num)) > 1:
            l.append(num)
            c += 1
        num += 1
    return l

# You are given two strings. In a single move, you can choose
# any of them, and delete the first (i.e. leftmost) character.
# For Example:
# By applying a move to the string "where", the result is the string "here".
# By applying a move to the string "a", the result is an empty string "".
# Implement a function that calculates the minimum number of moves that should be performed
# to make the given strings equal.
# Notes
# Both strings consist of lowercase latin letters.
# If the string is already empty, you cannot perform any more delete operations.
def shift_left(word1, word2, n = 0):
    if word1 == word2:
        return n
    elif len(word1) > len(word2):
        return shift_left(word1[1:], word2, n + 1)
    else:
        return shift_left(word1, word2[1:], n + 1)

# In this kata you will be given a list consisting of unique elements except for one thing that appears twice.
# Your task is to output a list of everything inbetween both occurrences of this element in the list.
def duplicate_sandwich(arr):
    start, end = [k for k, v in enumerate(arr) if arr.count(v) > 1]
    return arr[start+1:end]

# Complete the solution. It should try to retrieve the value of the array at the index provided.
# If the index is out of the array's max bounds then it should return the default value instead.
def solution(items, index, default_value):
    try:
        return items[index]
    except:
        return default_value

# Rick wants a faster way to get the product of the largest pair in an array.
# Your task is to create a performant solution to find the product of the largest two integers
# in a unique array of positive numbers.
# All inputs will be valid.
# Passing [2, 6, 3] should return 18, the product of [6, 3].
# Disclaimer: only accepts solutions that are faster than his, which has a running time O(nlogn).
def max_product(a):
    max1 = max(a)
    a.remove(max1)
    max2 = max(a)
    return max1 * max2

# This Kata is intended as a small challenge for my students
# All Star Code Challenge #20
# Create a function called addArrays() that combines two arrays of equal length, summing each element of the
# first with the corresponding element in the second, returning the "combined" summed array.
# Raise an error if input arguments are not of equal length.
def add_arrays(array1, array2):
    return [array1[k] + array2[k] for k, v in enumerate(array1)] if len(array1) == len(array2) else Error

# Complete the method that returns true if 2 integers share at least
# two 1 bits, otherwise return false. For simplicity assume that all numbers are non-negative.
def shared_bits(a, b):
    return bin(a & b).count('1') > 1

# Comprised of a team of five incredibly brilliant women, "The ladies of ENIAC" were the first “computors”
# working at the University of Pennsylvania’s Moore School of Engineering (1945). Through their
# contributions, we gained the first software application and the first programming classes! The ladies
# of ENIAC were inducted into the WITI Hall of Fame in 1997!
# Write a function which reveals "The ladies of ENIAC" names,
# so that you too can add them to your own hall of tech fame!
# To keep: only alpha characters, space characters and exclamation marks.
# To remove: numbers and these characters: %$&/£?@
# Result should be all in uppercase.
import re
def rad_ladies(name):
    return "".join(re.findall("[A-Z\s!]+", name.upper()))

# Given two integers a and x, return the minimum non-negative number to add
# to / subtract from a to make it a multiple of x.
def minimum(a, x):
    return min(a % x, -a % x)

# The Club Doorman will give you a word. To enter the Club you need
# to provide the right number according to provided the word.
# Every given word has a doubled letter, like 'tt' in lettuce.
# To answer the right number you need to find the doubled letter's position of the given word in the alphabet
# and multiply this number per 3.
# It will be given only words with one doubled letter.
# EXAMPLE
# Lettuce is the given word. 't' is the doubled letter and it's position is 20 in the alphabet.
# The answer to the Club Doorman is 20 * 3 = 60
# TASK
# The function passTheDoorMan with a given string word shall return the right number.
def pass_the_door_man(word):
    for char in word:
        if char*2 in word:
            return (ord(char)-96) * 3

# In programming you know the use of the logical negation operator (!), it reverses the meaning of a condition.
# !false = true
# !!false = false
# Your task is to complete the function 'negationValue()' that takes a string of negations with a value and
# returns what the value would be if those negations were applied to it.
def negation_value(str, val):
    return bool(not val if str.count('!') % 2 else val)

# In this kata you will be given a random string of letters and tasked with returning them
# as a string of comma-separated sequences sorted alphabetically, with each
# sequence starting with an uppercase character followed by n-1 lowercase characters, where n
# is the letter's alphabet position 1-26.
def alpha_seq(s):
    return ",".join((char*(ord(char)-96)).capitalize() for char in sorted(s.lower()))

# Return true when any odd bit of x equals 1; false otherwise.
# Assume that:
# x is an unsigned, 32-bit integer;
# the bits are zero-indexed (the least significant bit is position 0)
def any_odd(x):
    return '1' in list(bin(x))[-2::-2]

# To celebrate the start of the Rio Olympics (and the return of 'the Last Leg' on C4 tonight)
# this is an Olympic inspired kata.
# Given a string of random letters, you need to examine each. Some letters naturally have
# 'rings' in them. 'O' is an obvious example, but 'b', 'p', 'e', 'A', etc are all
# just as applicable. 'B' even has two!! Please note for this kata you can count lower case 'g' as only one ring.
# Your job is to count the 'rings' in each letter and divide the total number by 2.
# Round the answer down. Once you have your final score:
# if score is 1 or less, return 'Not even a medal!'; if score is 2, return 'Bronze!'; if score is 3,
# return 'Silver!'; if score is more than 3, return 'Gold!';
# Dots over i's and any other letters don't count as rings.
def olympic_ring(string):
    ring = 'abdegopqADOPQRBB'
    count = sum(string.count(c) for c in ring) // 2
    if count <= 1:
        return 'Not even a medal!'
    if count == 2:
        return 'Bronze!'
    if count == 3:
        return 'Silver!'
    return 'Gold!'

# You are given a sequence of a journey in London, UK. The sequence will contain
# bus numbers and TFL tube names as strings e.g.
# ['Northern', 'Central', 243, 1, 'Victoria']
# Journeys will always only contain a combination of tube
# names and bus numbers. Each tube journey costs £2.40 and each bus journey costs
# £1.50. If there are 2 or more adjacent bus journeys, the bus fare is capped for sets
# of two adjacent buses and calculated as one bus fare for each set.
# For example: 'Piccadilly', 56, 93, 243, 20, 14 -> "£6.90"
# Your task is to calculate the total cost of the journey and return the cost rounded to 2
# decimal places in the format (where x is a number): £x.xx
def london_city_hacker(journey):
    vehicle = "".join("t" if isinstance(k, str) else "b" for k in journey).replace("bb", "b")
    return f"£{sum(2.4 if i == 't' else 1.5 for i in vehicle):.2f}"

# You should write a simple function that takes string as input and checks if it is
# a valid Russian postal code, returning true or false.
# A valid postcode should be 6 digits with no white spaces, letters or other symbols.
# Empty string should also return false.
# Please also keep in mind that a valid post code cannot start with 0, 5, 7, 8 or 9
def zipvalidate(postcode):
    return len(postcode) == 6 and postcode.isdigit() and postcode[0] not in "05789"

# Create a function that takes a string and returns that string with the
# first half lowercased and the last half uppercased.
# eg: foobar == fooBAR
# If it is an odd number then 'round' it up to find which letters to uppercase. See example below.
def sillycase(silly):
    half_life = (len(silly) + 1) // 2
    return silly[:half_life].lower() + silly[half_life:].upper()

# You have to create a method "compoundArray" which should take as input two int arrays
# of different length and return one int array with numbers of both arrays shuffled one by one.
def compound_array(a, b):
    l = []
    while a or b:
        if a: l.append(a.pop(0))
        if b: l.append(b.pop(0))
    return l

# In this kata, your task is to implement an extended version of the famous rock-paper-scissors
# game. The rules are as follows:
# Scissors cuts Paper
# Paper covers Rock
# Rock crushes Lizard
# Lizard poisons Spock
# Spock smashes Scissors
# Scissors decapitates Lizard
# Lizard eats Paper
# Paper disproves Spock
# Spock vaporizes Rock
# Rock crushes Scissors
# Task:
# Given two values from the above game, return the Player result as "Player 1 Won!", "Player 2 Won!", or "Draw!".
def rpsls(p1, p2):
    var = "rock lizard spock scissors paper spock rock scissors lizard paper rock"
    return ("Player 1 Won!" if f"{p1} {p2}" in var else "Player 2 Won!" if f"{p2} {p1}" in var else "Draw!")

# Find the area of a rectangle when provided with one diagonal and one side of the rectangle. If
# the input diagonal is less than or equal to the length of the side,
# return "Not a rectangle". If the resultant area has decimals round it to two places.
# This kata is meant for beginners. Rank and upvote to bring it out of beta!
def area(d, l):
    return "Not a rectangle" if d <= l else round(l * (d**2 - l**2) **.5, 2)

# You will be given an array of objects representing data about developers who have signed
# up to attend the next coding meetup that you are organising.
# Given the following input array:
# Write a function that returns the array sorted alphabetically by the programming language.
# In case there are some developers that code in the same language, sort them alphabetically by the first name:
def sort_by_language(arr):
	return sorted(arr, key=lambda x: (x["language"], x["first_name"]))

# Task
# Implement a function which finds the numbers less than 2, and
# the indices of numbers greater than 1 in the given sequence, and returns them as a pair of sequences.
# Return a nested array or a tuple depending on the language:
# The first sequence being only the 1s and 0s from the original sequence.
# The second sequence being the indexes of the elements greater than 1 in the original sequence.
def binary_cleaner(lst):
    return [i for i in lst if i < 2], [k for k, v in enumerate(lst) if v > 1]

# Let us consider integer coordinates x, y in the Cartesian plane and three functions f, g, h defined by:
# f: 1 <= x <= n, 1 <= y <= n --> f(x, y) = min(x, y)
# g: 1 <= x <= n, 1 <= y <= n --> g(x, y) = max(x, y)
# h: 1 <= x <= n, 1 <= y <= n --> h(x, y) = x + y
# where n is a given integer (n >= 1) and x, y are integers.
# In the table below you can see the value of the function f with n = 6.
def sumin(n):
    return n * (n + 1) * (2 * n + 1) // 6
def sumax(n):
    return n * (n + 1) * (4 * n - 1) // 6
def sumsum(n):
    return n * n * (n + 1)

# Linked Lists - Push & BuildOneTwoThree
# Write push() and buildOneTwoThree() functions to easily update and initialize
# linked lists. Try to use the push() function within your buildOneTwoThree() function.
# Here's an example of push() usage:
class Node(object):
    def __init__(self, data, next=None):
        self.data = data
        self.next = next
def push(head, data):
    return Node(data, head)
def build_one_two_three():
    return Node(1, Node(2, Node(3)))

# zip_with takes a function and two arrays and zips the arrays together, applying the
# function to every pair of values.
# The function value is one new array.
# If the arrays are of unequal length, the output will only be as long as the shorter one.
# (Values of the longer array are simply not used.)
# Inputs should not be modified.
def zip_with(fn, a1, a2):
    return list(map(fn, a1, a2))

# You probably know that some characters written on a piece of paper, after turning this sheet 180
# degrees, can be read, although sometimes in a different way. So, uppercase letters
# "H", "I", "N", "O", "S", "X", "Z" after rotation are not changed, the letter "M"
# becomes a "W", and Vice versa, the letter "W" becomes a "M".
# We will call a word "shifter" if it consists only of letters
# "H", "I", "N", "O", "S", "X", "Z", "M" and "W". After turning the sheet, this word can
# also be read, although in a different way. So, the word "WOW "turns into the word "MOM".
# On the other hand, the word "HOME" is not a shifter.
# Find the number of unique shifter words in the input string (without duplicates). All shifters to
# be counted, even if they are paired (like "MOM" and "WOW"). String contains only uppercase letters.
import re
def shifter(st):
     return len(set(re.findall(r"\b[HINOSXZMW]+\b", st)))

# I love Fibonacci numbers in general, but I must admit I love some more than others.
# I would like for you to write me a function that, when given a number n (n >= 1 ),
# returns the nth number in the Fibonacci Sequence.
def nth_fib(n):
  a, b = 0, 1
  for i in range(n-1):
  	a, b = b, a + b
  return a

# One of the first algorithm used for approximating the integer square root of a positive integer n is
# known as "Hero's method", named after the first-century Greek mathematician Hero
# of Alexandria who gave the first description of the method. Hero's method can
# be obtained from Newton's method which came 16 centuries after.
# We approximate the square root of a number n by taking an initial guess x, an
# error e and repeatedly calculating a new approximate integer value x using:
# (x + n / x) / 2; we are finished when the previous x and the new x have an absolute difference less than e.
# We supply to a function (int_rac) a number n (positive integer) and a parameter
# guess (positive integer) which will be our initial x. For this kata the parameter 'e' is set to 1.
# Hero's algorithm is not always going to come to an exactly correct result! For instance: if n = 25 we
# get 5 but for n = 26 we also get 5. Nevertheless 5 is the integer square root of 26.
# The kata is to return the count of the progression of integer approximations that the algorithm makes.
# Reference:
def int_rac(n, guess):
    count = 0
    while True:
        count += 1
        next = (guess + n // guess) // 2
        if next == guess:
            return count
        guess = next

# You have an amount of money a0 > 0 and you deposit it with an
# interest rate of p percent divided by 360 per day on the 1st of January 2016. You
# want to have an amount a >= a0.
# Task:
# The function date_nb_days (or dateNbDays...) with parameters a0, a, p
# will return, as a string, the date on which you have just reached a.
# Example:
# date_nb_days(100, 101, 0.98) --> "2017-01-01" (366 days)
# date_nb_days(100, 150, 2.00) --> "2035-12-26" (7299 days)
# Notes:
# The return format of the date is "YYYY-MM-DD"
# The deposit is always on the "2016-01-01"
# Don't forget to take the rate for a day to be p divided by 36000 since banks
# consider that there are 360 days in a year.
# You have: a0 > 0, p% > 0, a >= a0
from math import ceil, log
from datetime import date, timedelta as td
def date_nb_days(a0, a, p):
    dur = log(a, 1 + p / 36000.0) - log(a0, 1 + p / 36000.0)
    return str(date(2016, 1, 1) + td(ceil(dur)))

# Return a function that will trim a string (the first argument given) if it
# is longer than the maximum string length (the second argument given). The result should also end with "..."
# These dots at the end also add to the string length.
# So in the above example, trim("Creating kata is fun", 14) should return "Creating ka..."
# If the string is smaller than or equal to 3 characters then the length of
# the dots is not added to the string length.
# e.g. trim("He", 1) should return "H..."
# If the string is smaller or equal than the maximum string length,
# then simply return the string with no trimming or dots required.
# e.g. trim("Code Wars is pretty rad", 50) should return "Code Wars is pretty rad"
def trim(phrase, size):
    if len(phrase) <= size:
        return phrase
    elif size <= 3 :
        return phrase[:size] + '...'
    return phrase[:size - 3] + '...'

# Your goal is to implement the method meanVsMedian which accepts an
# odd-length array of integers and returns one of the following:
# 'mean' - in case mean value is larger than median value
# 'median' - in case median value is larger than mean value
# 'same' - in case both mean and median share the same value
# Reminder: Median
# Array will always be valid (odd-length >= 3)
from statistics import median, mean
def mean_vs_median(numbers):
    med, mea = median(numbers), mean(numbers)
    return 'mean' if mea > med else 'median' if med > mea else 'same'

# Mash 2 arrays together so that the returning array has alternating elements of the
# 2 arrays . Both arrays will always be the same length.
# eg. [1,2,3] + ['a','b','c'] = [1, 'a', 2, 'b', 3, 'c']
def array_mash(a, b):
    l = []
    while a or b:
        l.append(a.pop(0))
        l.append(b.pop(0))
    return l

# Write a function that accepts two parameters (a and b) and says whether a is smaller
# than, bigger than, or equal to b.
# Here is an example code:
# There's only one problem...
# You can't use if statements, and you can't use shorthands like (a < b)?true:false;
# in fact the word "if" and the character "?" are not allowed in the code.
def no_ifs_no_buts(a, b):
    dictionary = {a < b:'smaller than', a == b:'equal to', a > b: 'greater than'}
    return f'{a} is {dictionary[True]} {b}'

# This is the first part of this kata series. Second part is here and third part is here
# Add two English words together!
# Implement a class Arith (struct struct Arith{value : &'static str,} in Rust) such that
integer = ['zero', 'one', 'two', 'three', 'four', 'five',
           'six', 'seven', 'eight', 'nine', 'ten','eleven',
           'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen',
           'seventeen', 'eighteen', 'nineteen', 'twenty']
class Arith():
    def __init__(self, int):
        self.i = integer.index(int)
    def add(self, int):
         return integer[integer.index(int) + self.i]

# You are given an n by n ( square ) grid of characters, for example:
# [['m', 'y', 'e'],
#  ['x', 'a', 'm'],
#  ['p', 'l', 'e']]
# You are also given a list of integers as input, for example:
# [1, 3, 5, 8]
# You have to find the characters in these indexes of the grid if you think of the indexes as:
# [[1, 2, 3],
#  [4, 5, 6],
#  [7, 8, 9]]
# Remember that the indexes start from one and not zero.
# Then you output a string like this:
def grid_index(grid, indexes):
    l = [i for j in grid for i in j]
    return ''.join(l[i - 1] for i in indexes)

# You've been collecting change all day, and it's starting to pile up in your pocket, but
# you're too lazy to see how much you've found.
# Good thing you can code!
# Create change_count() to return a dollar amount of how much change you have!
# Valid types of change include:
# These amounts are already preloaded as floats into the CHANGE dictionary for you to use!
# You should return the total in the format $x.xx.
# Examples:
def change_count(s):
    return f"${sum(CHANGE[i] for i in s.split()):.2f}"

# Write a regex to validate a 24 hours time string. See examples to figure out what you should check for:
# Accepted: 01:00 - 1:00
# Not accepted:
# 24:00
# You should check for correct length and no spaces.
import re
def validate_time(timestamp):
    return bool(re.match(r'(2[0-3]|[01]?\d):[0-5]\d$', timestamp))

# Implement a function which filters out array values which satisfy the given predicate.
def reject(seq, predicate):
    return [item for item in seq if not predicate(item)]

# Not considering number 1, the integer 153 is the first integer having this property: the
# sum of the third-power of each of its digits is equal
# to 153. Take a look: 153 = 1³ + 5³ + 3³ = 1 + 125 + 27 = 153
# The next number that experiments this particular behaviour is 370 with the same power.
# Write the function eq_sum_powdig(), that finds the numbers below a given upper
# limit hMax (inclusive) that fulfills this property but with different exponents as the power for the digits.
# eq_sum_powdig(hMax, exp): ----> sequence of numbers (sorted list) (Number one should not be considered).
def eq_sum_powdig(hMax, exp):
    return [i for i in range(2, hMax + 1) if sum(int(j) ** exp for j in str(i)) == i]

# Write a function that adds from two invocations.
# All inputs will be integers.
def add(a):
    return lambda x: x + a

# Given a number N, can you fabricate the two numbers NE and NO such that NE is formed by even digits
# of N and NO is formed by odd digits of N? Examples:
# input	NE	NO
# 126453	264	153
# 3012	2	31
# 4628	4628	0
# 0 is considered as an even number.
# In C and JavaScript you should return an array of two elements such as the first is NE and the second is NO.
def even_and_odd(n):
    even = ''.join(str(i) for i in str(n) if int(i) % 2 == 0)
    odd = ''.join(str(i) for i in str(n) if int(i) % 2 != 0)
    return (int(even) if even else 0, int(odd) if odd else 0)

# Write a function that will take a key of X and place it in the middle of Y repeated N times.
# Extra challege (not tested): You can complete this with under 70
# characters without using regex. Challenge yourself to do this. It wont be best practices but it will work.
# Rules:
# If X cannot be placed in the middle, return X.
# N will always be > 0.
def middle_me(N, X, Y):
    if N % 2 == 1:
        return X
    return Y * (N // 2) + X + Y * (N // 2)

# In this kata you will be given a sequence of the dimensions
# of rectangles ( sequence with width and length ) and circles ( radius - just a number ).
# Your task is to return a new sequence of dimensions, sorted ascending by area.
def sort_by_area(seq):
    def func(x):
        if isinstance(x, tuple):
            return x[0] * x[1]
        return 3.14 * x * x
    return sorted(seq, key=func)

# Principal Diagonal -- The principal diagonal in a matrix identifies those elements of the
# matrix running from North-West to South-East.
# Secondary Diagonal -- the secondary diagonal of a matrix identifies those elements of the matrix
# running from North-East to South-West.
# For example:
# matrix:             [1, 2, 3]
#                     [4, 5, 6]
#                     [7, 8, 9]
# principal diagonal: [1, 5, 9]
# secondary diagonal: [3, 5, 7]
# Task
# Your task is to find which diagonal is "larger": which diagonal has a bigger sum of their elements.
# If the principal diagonal is larger, return "Principal Diagonal win!"
# If the secondary diagonal is larger, return "Secondary Diagonal win!"
# If they are equal, return "Draw!"
# Note: You will always receive matrices of the same dimension.
def diagonal(m):
    principal  = sum(v[k] for k, v in enumerate(m))
    secondary  = sum(v[-k] for k, v in enumerate(m, 1))
    if principal  > secondary : return 'Principal Diagonal win!'
    if secondary  > principal : return 'Secondary Diagonal win!'
    return 'Draw!'

# For a given 2D vector described by cartesian coordinates of its initial point and
# terminal point in the following format:
# [[x1, y1], [x2, y2]]
# Your function must return the vector's length represented as a floating point number.
# Error must be within 1e-7.
# Coordinates can be integers or floating point numbers.
import math
def vector_length(v):
    return math.sqrt(math.pow(v[0][0] - v[1][0], 2) + math.pow(v[0][1] - v[1][1], 2))

# Check if it is a vowel(a, e, i, o, u,) on the n position in a string
# (the first argument). Don't forget about uppercase.
# A few cases:
# {
# checkVowel('cat', 1)  ->   true // 'a' is a vowel
# checkVowel('cat', 0)  ->   false // 'c' is not a vowel
# checkVowel('cat', 4)  ->   false // this position doesn't exist
# }
# P.S. If n < 0, return false
def check_vowel(string, position):
    return string[position].lower() in 'aeoiu' if position >= 0 and position <= len(string) else False

# Update the solution method to round the argument value to the closest
# precision of two. The argument will always be a float.
def solution(n):
    return round(n, 2)

# You get a new job working for Eggman Movers. Your first task is to write a method that
# will allow the admin staff to enter a person’s name and return what that person's role is in the company.
# You will be given an array of object literals holding the current employees of the company.
# You code must find the employee with the matching firstName and lastName and then return the
# role for that employee or if no employee is not found it should return "Does not work here!"
# The array is preloaded and can be referenced using the variable employees ($employees in Ruby). It uses the
# following structure.
def find_employees_role(name):
    for i in employees:
        if len(name.split()) > 1:
            if name.split()[0] == i['first_name']:
                if name.split()[1] == i['last_name']:
                    return i['role']
        elif len(name.split()) == 0:
            if name.split()[0] == i['first_name']:
                return i['role']
    return 'Does not work here!'

# Linked Lists - Append
# Write an Append() function which appends one linked list to another. The head of the
# resulting list should be returned.
# var listA = 1 -> 2 -> 3 -> null
# var listB = 4 -> 5 -> 6 -> null
# append(listA, listB) === 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> null
# If both listA and listB are null/NULL/None/nil, return null/NULL/None/nil. If one list is null/NULL/None/nil
# and the other is not, simply return the non-null/NULL/None/nil list.
# The push() and buildOneTwoThree() (build_one_two_three() in PHP and ruby) functions need not be
# redefined. The Node class is also predefined for you in PHP.
class Node(object):
    def __init__(self, data):
        self.data = data
        self.next = None
def last(head):
    n = head
    while n and n.next:
    	n = n.next
    return n
def append(listA, listB):
    if not listA:
    	return listB
    last(listA).next = listB
    return listA

# Sam has opened a new sushi train restaurant - a restaurant where sushi is served on
# plates that travel around the bar on a conveyor belt and customers take the plate that they like.
# Sam is using Glamazon's new visual recognition technology that allows
# a computer to record the number of plates at a customer's table and the colour
# of those plates. The number of plates is returned as a string. For example,
# if a customer has eaten 3 plates of sushi on a red plate the computer will return the string "rrr".
# Currently, Sam is only serving sushi on red plates as he's trying to attract customers
# to his restaurant. There are also small plates on the conveyor belt for condiments such as
# ginger and wasabi - the computer notes these in the string that is returned
# as a space; e.g. "rrr r" denotes 4 plates of red sushi and a plate of condiment.
# Sam would like your help to write a program for the cashier's machine to
# read the string and return the total amount a customer has to pay when they ask
# for the bill. The current price for the dishes are as follows:
# Red plates of sushi: $2 each - but every 5th one is free!
# Condiments: free
def total_bill(s):
    return s.count('r') * 2 if s.count('r') < 5 else (s.count('r') - (s.count('r')//5)) * 2

# You'll be passed an array of objects (list) - you must sort them in
# descending order based on the value of the specified property (sortBy).
def sort_list(sort_key, l):
    return sorted(l, key=lambda x: x[sort_key], reverse=True)

# How sexy is your name? Write a program that calculates how sexy one's name is according to the criteria below.
# There is a preloaded dictionary of letter scores called SCORES(Python & JavaScript) / $SCORES (Ruby).
# Add up the letters (case-insensitive) in your name to get your sexy score. Ignore other characters.
#     SCORES = {'A': 100, 'B': 14, 'C': 9, 'D': 28, 'E': 145, 'F': 12, 'G': 3,
#               'H': 10, 'I': 200, 'J': 100, 'K': 114, 'L': 100, 'M': 25,
#               'N': 450, 'O': 80, 'P': 2, 'Q': 12, 'R': 400, 'S': 113, 'T': 405,
#               'U': 11, 'V': 10, 'W': 10, 'X': 3, 'Y': 210, 'Z': 23}
# The program must return how sexy one's name is according to the "Sexy score ranking" chart.
def sexy_name(name):
    s = sum(SCORES[i.upper()] for i in name.replace(' ', ''))
    return 'THE ULTIMATE SEXIEST' if s >=600 else 'VERY SEXY' if 301 <= s <= 599 else 'PRETTY SEXY' if 61 <= s <= 300 else 'NOT TOO SEXY'

# A wealthy client has forgotten the password to his business website, but he has a list of
# possible passwords. His previous developer has left a file on the server with the name password.txt.
# You open the file and realize it's in binary format.
# Write a script that takes an array of possible passwords and a string
# of binary representing the possible password. Convert the binary to a string and compare to
# the password array. If the password is found, return the password string, else return false;
def decode_pass(pass_list, bits):
    pas = "".join(chr(int(x, 2)) for x in bits.split())
    return pas if pas in pass_list else False

# In this kata, you will write an arithmetic list which is basically a list that contains consecutive
# terms in the sequence.
# You will be given three parameters :
# first the first term in the sequence
# c the constant that you are going to ADD ( since it is an arithmetic sequence...)
# l the number of terms that should be returned
# Useful link: Sequence
# Be sure to check out my Arithmetic sequence Kata first ;)
# Don't forget about the indexing pitfall ;)
def seqlist(first,c,l):
    return list(range(first,first+l*c,c))

# An abundant number or excessive number is a number for which the sum of its proper divisors is greater than
# the number itself.
# The integer 12 is the first abundant number. Its proper divisors are 1, 2, 3, 4 and 6 for a total of 16 (> 12).
# Derive function abundantNumber(num)/abundant_number(num) which returns true/True/.true.
# if num is abundant, false/False/.false. if not.
def abundant_number(num):
    return sum([i for i in range(1, num) if num % i == 0]) > num

# I'm afraid you're in a rather unfortunate situation. You've injured your leg, and are
# unable to walk, and a number of zombies are shuffling towards you, intent on eating your
# brains. Luckily, you're a crack shot, and have your trusty rifle to hand.
# The zombies start at range metres, and move at 0.5 metres per second. Each second,
# you first shoot one zombie, and then the remaining zombies shamble forwards another 0.5 metres.
# If any zombies manage to get to 0 metres, you get eaten. If you run out of ammo
# before shooting all the zombies, you'll also get eaten. To keep things simple, we
# can ignore any time spent reloading.
# Write a function that accepts the total number of zombies, a range in metres, and
# the number of bullets you have.
# If you shoot all the zombies, return "You shot all X zombies." If you get
# eaten before killing all the zombies, and before running out of ammo, return
# "You shot X zombies before being eaten: overwhelmed." If you run out of ammo
# before shooting all the zombies, return "You shot X zombies before being eaten: ran out of ammo."
# (If you run out of ammo at the same time as the remaining zombies reach you, return
# "You shot X zombies before being eaten: overwhelmed.".)
# Good luck! (I think you're going to need it.)
def zombie_shootout(z, r, a):
    count = min(r * 2, a)
    return f"You shot all {z} zombies." if count >= z else f"You shot {count} zombies before being eaten: { 'overwhelmed' if count == 2 * r else 'ran out of ammo'}."

# Task
# Your challenge is to write a function named getSlope/get_slope/GetSlope that calculates the slope
# of the line through two points.
# Input
# Each point that the function takes in is an array 2 elements long. The first number
# is the x coordinate and the second number is the y coordinate. If the line through the
# two points is vertical or if the same point is given twice, the function should return null/None.
def getSlope(p1, p2):
    return None if p1[0] == p2[0] else (p2[1] - p1[1]) / (p2[0] - p1[0])

# Usually when you buy something, you're asked whether your credit card number, phone
# number or answer to your most secret question is still correct. However, since someone could look over
# your shoulder, you don't want that shown on your screen. Instead, we mask it.
# Your task is to write a function maskify, which changes all but the last four characters into '#'.
def maskify(cc):
    return '#'*len(cc[:-4])+cc[-4:] if len(cc) > 4 else cc

# Create a function named divisors/Divisors that takes an integer n > 1 and returns an array with
# all of the integer's divisors(except for 1 and the number itself), from smallest
# to largest. If the number is prime return the string '(integer) is prime' (null in C#)
# (use Either String a in Haskell and Result<Vec<u32>, String> in Rust).
def divisors(integer):
    l =  [i for i in range(2, integer) if integer % i == 0]
    return l if l else f"{integer} is prime"

# Don't give me five!
# In this kata you get the start number and the end number of a region and should
# return the count of all numbers except numbers with a 5 in it. The start and the end number are both inclusive!
# Examples:
# 1,9 -> 1,2,3,4,6,7,8,9 -> Result 8
# 4,17 -> 4,6,7,8,9,10,11,12,13,14,16,17 -> Result 12
# The result may contain fives. ;-)
# The start number will always be smaller than the end number. Both numbers can be also negative!
# I'm very curious for your solutions and the way you solve it. Maybe someone
# of you will find an easy pure mathematics solution.
# Have fun coding it and please don't forget to vote and rank this kata! :-)
# I have also created other katas. Take a look if you enjoyed this kata!
def dont_give_me_five(start, end):
    return sum('5' not in str(i) for i in range(start, end + 1))

# The two oldest ages function/method needs to be completed. It
# should take an array of numbers as its argument and return the two highest numbers
# within the array. The returned value should be an array in the format [second oldest age,  oldest age].
# The order of the numbers passed in could be any order.
# The array will always include at least 2 items. If there are two or
# more oldest age, then return both of them in array format.
def two_oldest_ages(ages):
    return sorted(ages)[-2:]

# Given a Divisor and a Bound , Find the largest integer N , Such That ,
# Conditions :
# N is divisible by divisor
# N is less than or equal to bound
# N is greater than 0.
# Notes
# The parameters (divisor, bound) passed to the function are only positive values .
# It's guaranteed that a divisor is Found
def max_multiple(divisor, bound):
    return max(i for i in range(bound + 1) if i % divisor == 0)

# Your task is to remove all duplicate words from a string, leaving only single (first) words entries.
# Example:
# Input:
# 'alpha beta beta gamma gamma gamma delta alpha beta beta gamma gamma gamma delta'
# Output:
# 'alpha beta gamma delta'
def remove_duplicate_words(s):
    l = []
    for word in s.split():
        if word not in l:
            l.append(word)
    return ' '.join(l)

# Are the numbers in order?
# In this Kata, your function receives an array of integers as input. Your task
# is to determine whether the numbers are in ascending order. An array is said to
# be in ascending order if there are no two adjacent integers where the left
# integer exceeds the right integer in value.
# For the purposes of this Kata, you may assume that all inputs are valid, i.e. arrays containing only integers.
# Note that an array of 0 or 1 integer(s) is automatically considered to be
# sorted in ascending order since all (zero) adjacent pairs of integers satisfy the
# condition that the left integer does not exceed the right integer in value.
# For example:
def in_asc_order(arr):
    return arr == sorted(arr)

# You will be given an array of objects (hashes in ruby) representing data about
# developers who have signed up to attend the coding meetup that you are organising for the first time.
# Your task is to return the number of JavaScript developers coming from Europe.
def count_developers(lst):
    return sum(1 for i in lst if i["continent"] == 'Europe' and i["language"] == 'JavaScript')

# Given a number, write a function to output its reverse digits. (e.g. given 123 the answer is 321)
# Numbers should preserve their sign; i.e. a negative number should still be negative when reversed.
def reverseNumber(n):
    return int(str(abs(n))[::-1]) * (-1 if n < 0 else 1)

# Write a program to determine if a string contains only unique characters. Return true if it does and false
# otherwise.
# The string may contain any of the 128 ASCII characters. Characters are case-sensitive,
# e.g. 'a' and 'A' are considered different characters.
def has_unique_chars(string):
    return all(string.count(i) == 1 for i in string)

# Your task is to split the chocolate bar of given dimension n x m into small squares. Each square is of
# size 1x1 and unbreakable. Implement a function that will return minimum number of breaks needed.
# For example if you are given a chocolate bar of size 2 x 1 you can split
# it to single squares in just one break, but for size 3 x 1 you must do two breaks.
# If input data is invalid you should return 0 (as in no breaks are needed if
# we do not have any chocolate to split). Input will always be a non-negative integer.
def break_chocolate(n, m):
    return (n * m) - 1 if n or m else 0

# Return an array containing the numbers from 1 to N, where N is the parametered value.
# Replace certain values however if any of the following conditions are met:
# If the value is a multiple of 3: use the value "Fizz" instead
# If the value is a multiple of 5: use the value "Buzz" instead
# If the value is a multiple of 3 & 5: use the value "FizzBuzz" instead
# N will never be less than 1.
# Method calling example:
def fizzbuzz(n):
    l = []
    for i in range (1, n + 1):
        if i % 3 == 0 and i % 5 == 0:
            l.append("FizzBuzz")
        elif i % 3 == 0:
            l.append("Fizz")
        elif i % 5 == 0:
            l.append("Buzz")
        else:
            l.append(i)
    return l

# Number is a palindrome if it is equal to the number with digits in reversed order. For example,
# 5, 44, 171, 4884 are palindromes, and 43, 194, 4773 are not.
# Write a function which takes a positive integer and returns the number
# of special steps needed to obtain a palindrome. The special step is: "reverse the digits,
# and add to the original number". If the resulting number is not a palindrome, repeat the procedure with the sum
# until the resulting number is a palindrome.
# If the input number is already a palindrome, the number of steps is 0.
# All inputs are guaranteed to have a final palindrome smaller than 263 2^632 6 3.
def palindrome_chain_length(n):
    c = 0
    while str(n) != str(n)[::-1]:
        c += 1
        n = n + int(str(n)[::-1])
    return c

# Task
# Given a positive integer n, calculate the following sum:
# n + n/2 + n/4 + n/8 + ...
# All elements of the sum are the results of integer division.
def halving_sum(n):
    c = 0
    while n > 0:
        c += n
        n = n // 2
    return c

# You are the greatest chef on earth. No one boils eggs like you! Your restaurant is
# always full of guests, who love your boiled eggs. But when there is a greater order
# of boiled eggs, you need some time, because you have only one pot for your job. How much time do you need?
# Your Task
# Implement a function, which takes a non-negative integer, representing the number of eggs
# to boil. It must return the time in minutes (integer), which it takes to have all the eggs boiled.
# Rules
# you can put at most 8 eggs into the pot at once
# it takes 5 minutes to boil an egg
# we assume, that the water is boiling all the time (no time to heat up)
# for simplicity we also don't consider the time it takes to put eggs into the pot or get them out of it
def cooking_time(eggs):
    c = 0
    while eggs > 0:
        c += 1
        eggs -= 8
    return c * 5

# An ordered sequence of numbers from 1 to N is given. One number might have deleted from
# it, then the remaining numbers were mixed. Find the number that was deleted.
# Example:
# The starting array sequence is [1,2,3,4,5,6,7,8,9]
# The mixed array with one deleted number is [3,2,4,6,7,8,1,9]
# Your function should return the int 5.
# If no number was deleted from the starting array, your function should return the int 0.
# Note: N may be 1 or less (in the latter case, the first array will be []).
def find_deleted_number(arr, mixed_arr):
    return sum(arr) - sum(mixed_arr)

# In this kata you should simply determine, whether a given year is a leap year or not.
# In case you don't know the rules, here they are:
# years divisible by 4 are leap years
# but years divisible by 100 are not leap years
# but years divisible by 400 are leap years
# Additional Notes:
# Only valid years (positive integers) will be tested, so you don't have to validate them
# Examples can be found in the test fixture.
import calendar
def isLeapYear(year):
    return calendar.isleap(year)

# Complete the function that takes a sequence of numbers as
# single parameter. Your function must return the sum of the even values of this sequence.
# Only numbers without decimals like 4 or 4.0 can be even.
# The input is a sequence of numbers: integers and/or floats.
def sum_even_numbers(seq):
    return sum(i for i in seq if i % 2 == 0)

# In this Kata, you will be given an array of numbers in which two numbers occur once and the rest occur
# only twice. Your task will be to return the sum of the numbers that occur only once.
# For example, repeats([4,5,7,5,4,8]) = 15 because only the numbers 7
# and 8 occur once, and their sum is 15. Every other number occurs twice.
# More examples in the test cases.
def repeats(arr):
    return sum(i for i in arr if arr.count(i) == 1)

#Get the averages of these numbers
# Write a method, that gets an array of integer-numbers and return an
# array of the averages of each integer-number and his follower, if there is one.
# Example:
def averages(arr):
    return [(arr[x] + arr[x + 1]) / 2 for x in range(len(arr or []) - 1)]

# Debug   function getSumOfDigits that takes positive integer to calculate sum of its digits.
# Assume that argument is an integer.
def get_sum_of_digits(num):
    return sum(int(i) for i in str(num))

# Given a number return the closest number to it that is divisible by 10.
def closest_multiple_10(i):
    return int(round(i, -1))

# You will be given an array of objects (associative arrays in PHP, tables in COBOL) representing
# data about developers who have signed up to attend the next coding meetup that you are organising.
# Your task is to return either:
# true if all developers in the list code in the same language; or
# false otherwise.
# For example, given the following input array:
def is_same_language(lst):
    return len(set(i['language'] for i in lst)) == 1

# In this Kata, you will be given a string that has lowercase letters and numbers. Your task is
# to compare the number groupings and return the largest number. Numbers will not have leading zeros.
# For example, solve("gh12cdy695m1") = 695, because this is the largest of all number groupings.
# Good luck!
def solve(s):
    l = ''.join(' ' if i.isalpha() else i for i in s)
    return max(int(i) for i in l.split())

# Given a non-negative integer, return an array / a list of the individual digits in order.
def digitize(n):
    return [int(i) for i in str(n)]

# You will be given a sequence of objects representing data about developers who have signed up to
# attend the next coding meetup that you are organising.
# Given the following input array:
# write a function that returns the average age of developers (rounded to the nearest integer).
# In the example above your function should return 50 (number).
# Notes:
# The input array will always be valid and formatted as in the example above.
# Age is represented by a number which can be any positive integer.
def get_average(lst):
    return round(sum(i['age'] for i in lst) / len(lst))

# You are provided with an array of positive integers and an additional integer n (n > 1).
# Calculate the sum of each value in the array to the nth power. Then subtract the sum of the original array.
def modified_sum(a, n):
    return sum(i**n for i in a) - sum(a)

# This question is a variation on the Arithmetic Progression kata
# The following was a question that I received during a technical interview for an entry level software
# developer position. I thought I'd post it here so that everyone could give it a go:
# You are given an unsorted array containing all the integers from 0 to 100 inclusively. However, one number is
# missing. Write a function to find and return this number. What are the
# time and space complexities of your solution?
def missing_no(nums):
    return sum(range(101)) - sum(nums)

# You are given an array of n+1 integers 1 through n. In addition there is a single duplicate integer.
# The array is unsorted.
# An example valid array would be [3, 2, 5, 1, 3, 4].
# It has the integers 1 through 5 and 3 is duplicated. [1, 2, 4, 5, 5] would not be valid as it is missing 3.
# You should return the duplicate value as a single integer.
def find_dup(arr):
    return sum(arr) - sum(set(arr))

# Program a function sumAverage(arr) where arr is an array containing arrays full of numbers, for example:
# sum_average([[1, 2, 2, 1], [2, 2, 2, 1]]);
# First, determine the average of each array. Then, return the sum of all the averages.
# All numbers will be less than 100 and greater than -100.
# arr will contain a maximum of 50 arrays.
# After calculating all the averages, add them all together, then round down, as shown in the example below:
# The example given: sumAverage([[3, 4, 1, 3, 5, 1, 4], [21, 54, 33, 21, 77]]), the answer being 44.
from statistics import mean
from math import floor
def sum_average(arr):
    return floor(sum(mean(i) for i in arr))

# Should be easy, begin by looking at the code. Debug the code and the functions should work.
# There are three functions: Multiplication (x) Addition (+) and Reverse (!esreveR)
import math
def multi(l_st):
    return math.prod(l_st)
def add(l_st):
    return sum(l_st)
def reverse(string):
    return string[::-1]

# Given an array of numbers, return the difference between the largest and smallest values.
def between_extremes(numbers):
    return max(numbers) - min(numbers)

# Given a long number, return all the possible sum of two digits of it.
# For example, 12345: all possible sum of two digits from that number are:
from itertools import combinations
def digits(num):
    return list(map(sum, combinations(map(int,str(num)),2)))

# Given a positive integer N, return the largest integer k such that 3^k < N.
def largest_power(N):
    c = 0
    while 3**c < N:
        c += 1
    return c - 1

# Given a mathematical equation that has *,+,-,/, reverse it as follows:
import re
def solve(eq):
    return ''.join(reversed(re.split(r'(\W+)', eq)))

# In this Kata, you will be given a string and two indexes (a and b). Your task is
# to reverse the portion of that string between those two indices inclusive.
def solve(s,a,b):
    return s[:a] + s[a:b+1][::-1] + s[b+1:]

# How many button presses on my remote are required to type a given word?
# Notes
# The cursor always starts on the letter a (top left)
# Remember to also press OK to "accept" each character.
# Take a direct route from one character to the next
# The cursor does not wrap (e.g. you cannot leave one edge and reappear on the opposite edge)
# A "word" (for the purpose of this Kata) is any sequence of characters available on my virtual "keyboard"
def tv_remote(word):
    pp = 0
    res = 0
    r = 'abcde123fghij456klmno789pqrst.@0uvwxyz_/'
    for i in word:
        p = r.find(i)
        res += abs(p//8-pp//8) + abs(p%8-pp%8) + 1
        pp = p
    return res

# No Story
# No Description
# Only by Thinking and Testing
# Look at result of testcase, guess the code!
def testit(a, b):
    return sorted(list(set(a)) + list(set(b)))

# The trick to counting kookaburras is to listen carefully
# The males sound like HaHaHa...
# The females sound like hahaha...
# And they always alternate male/female
import re
def kooka_counter(laughing):
    return len(re.findall(r'(ha)+|(Ha)+',laughing))

# You are going to be given a string. Your job is to return
# that string in a certain order that I will explain below:
# Let's say you start with this: 012345
# The first thing you do is reverse it:543210
# Then you will take the string from the 1st position and reverse it again:501234
# Then you will take the string from the 2nd position and reverse it again:504321
# Then you will take the string from the 3rd position and reverse it again:504123
# Continue this pattern until you have done every single position, and then you will return the string
# you have created. For this particular number, you would return:504132
#Input: A string of length 1 - 1000
#Output: A correctly reordered string.
def reverse_fun(n):
    for i in range(len(n)):
        n = n[:i] + n[i:][::-1]
    return n

# Given two arrays of strings, return the number of times each
# string of the second array appears in the first array.
# Example
# array1 = ['abc', 'abc', 'xyz', 'cde', 'uvw']
# array2 = ['abc', 'cde', 'uap']
# How many times do the elements in array2 appear in array1?
# 'abc' appears twice in the first array (2)
# 'cde' appears only once (1)
# 'uap' does not appear in the first array (0)
# Therefore, solve(array1, array2) = [2, 1, 0]
def solve(a,b):
    return [a.count(i) for i in b]

# A boy is walking a long way from school to his home. To make the walk more
# fun he decides to add up all the numbers of the houses that he passes by during his walk. Unfortunately,
# not all of the houses have numbers written on them, and on top of that the boy
# is regularly taking turns to change streets, so the numbers don't appear to him in any particular order.
# At some point during the walk the boy encounters a house with number 0 written on it,
# which surprises him so much that he stops adding numbers to his total right after seeing that house.
# For the given sequence of houses determine the sum that the boy will get. It is guaranteed that
# there will always be at least one 0 house on the path.
def house_numbers_sum(inp):
    return sum(inp[:inp.index(0)])

# You have to write a function pattern which returns the following Pattern
# (See Pattern & Examples) upto n number of rows.
# Note:Returning the pattern is not the same as Printing the pattern.
# Rules/Note:
# If n < 1 then it should return "" i.e. empty string.
# There are no whitespaces in the pattern.
def pattern(n):
    return '\n'.join(f"{i}"*i for i in range(1, n+1))

# You are given a dictionary/hash/object containing some languages and your test results in
# the given languages. Return the list of languages where your test score is at least 60, in
# descending order of the scores.
# Note: the scores will always be unique (so no duplicate values)
def my_languages(results):
    return sorted((k for k,v in results.items() if v >= 60), reverse=True, key=results.get)

# The code provided is supposed return a person's Full Name given their first and last names.
# But it's not working properly.
# Notes
# The first and/or last names are never null, but may be empty.
# Task
# Fix the bug so we can all go home early.
class Dinglemouse(object):
    def __init__(self, first_name, last_name):
        self.first_name = first_name
        self.last_name = last_name
    def get_full_name(self):
        return (self.first_name + ' ' + self.last_name).strip()

# You will be given an array of objects (associative arrays in PHP)
# representing data about developers who have signed up to attend the next
# coding meetup that you are organising. The list is ordered according to who signed up first.
# Your task is to return one of the following strings:
# < firstName here >, < country here > of the first Python developer who has signed up; or
# There will be no Python developers if no Python developer has signed up.
def get_first_python(users):
    for user in users:
        if user['language'] == 'Python':
            return f'{user["first_name"]}, {user["country"]}'
    return 'There will be no Python developers'

# An arrow is formed in a rectangle with sides a and b by joining
# the bottom corners to the midpoint of the top edge and the centre of the rectangle.
def arrow_area(a, b):
    return a * b / 4

# Debug a function called calculate that takes 3 values. The first and
# third values are numbers. The second value is a character. If
# the character is "+" , "-", "*", or "/", the function will return the result
# of the corresponding mathematical function on the two numbers. If the string is
# not one of the specified characters, the function should return null.
def calculate(a, o, b):
    if o == "+":
        return a + b
    elif o == "-":
        return a - b
    elif o == "/" and b != 0:
        return a / b
    elif o == "*":
        return a * b
    return None

# The first three stages of a sequence are shown.
# blocks
# The blocksize is a by a and a ≥ 1.
# What is the perimeter of the nth shape in the sequence (n ≥ 1) ?
def perimeter_sequence(a, n):
    return 4 * n * a

# elow we will define what and n-interesting polygon is and your task is to find its area for a given n.
# A 1-interesting polygon is just a square with a side of length 1. An n-interesting polygon is obtained
# by taking the n - 1-interesting polygon and appending 1-interesting polygons
# to its rim side by side. You can see the 1-, 2- and 3-interesting polygons in the picture below.
def shape_area(n):
    return n**2 + (n - 1) ** 2

# You have to search all numbers from inclusive 1 to inclusive a given number x, that
# have the given digit d in it.
# The value of d will always be 0 - 9.
# The value of x will always be greater than 0.
# You have to return as an array
# the count of these numbers,
# their sum
# and their product.
import math
def numbers_with_digit_inside(x, d):
    l = [i for i in range(1, x+1) if str(d) in str(i)]
    return [len(l), sum(l), math.prod(l)] if l else [0, 0, 0]

# You have to write a function pattern which returns the following Pattern
# (See Pattern & Examples) upto n number of rows.
# Note: Returning the pattern is not the same as Printing the pattern.
# Rules/Note:
# If n < 1 then it should return "" i.e. empty string.
# There are no whitespaces in the pattern.
def pattern(n):
    return('\n'.join(''.join(str(i) for i in range(n,j,-1)) for j in range(n)))

# Determine the area of the largest square that can fit inside a circle with radius r.
def area_largest_square(r):
    return 2 * r**2

# Triangular numbers are so called because of the
# equilateral triangular shape that they occupy when laid out as dots. i.e.
def triangular(n):
    return n * (n + 1) // 2 if n > 0 else 0

# You will be given an array of objects (associative arrays in PHP, tables in COBOL) representing data
# about developers who have signed up to attend the next coding meetup that you are organising.
# Your task is to return an array where each object will have a new property
# 'greeting' with the following string value:
# Hi < firstName here >, what do you like the most about < language here >?
# For example, given the following input array:
def greet_developers(lst):
    for x in lst:
        x["greeting"] = f"Hi {x['firstName']}, what do you like the most about {x['language']}?"
    return lst

# Find the greatest common divisor of two positive integers. The integers
# can be large, so you need to find a clever solution.
# The inputs x and y are always greater or equal to 1,
# so the greatest common divisor will always be an integer that is also greater or equal to 1.
import math
def mygcd(x, y):
    return math.gcd(x, y)

# Consider integer numbers from 0 to n - 1 written down along the
# circle in such a way that the distance between any two neighbouring
# numbers is equal (note that 0 and n - 1 are neighbouring, too).
# Given n and firstNumber/first_number/first-number, find the number which is written
# in the radially opposite position to firstNumber.
def circle_of_numbers(n, fst):
    return (fst + (n / 2)) % n

# In this kata the function returns an array/list of numbers without its last element.
# The function is already written for you and the basic tests pass, but random tests fail. Your
# task is to figure out why and fix it.
# Good luck!
# Hint: watch out for side effects.
def without_last(lst):
    return lst[:-1]

# In this kata you will create a function to check a non-negative input to see if it is a prime number.
# The function will take in a number and will return True if it is a prime number and False if it is not.
# A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.
def is_prime(n):
    return pow(2, n - 1, n) == 1 if n > 2 else n == 2

# Oh no, Timmy's Sort doesn't seem to be working? Your task is to fix
# the sortArray function to sort all numbers in ascending order
def sort_array(value):
    return "".join(sorted(value,key=lambda a: int(a)))

# The Arara are an isolated tribe found in the Amazon who count in pairs.
# For example one to eight is as follows:
# Take a given number and return the Arara's equivalent.
def count_arara(n):
    return ('adak ' * (n // 2) + 'anane' * (n % 2)).strip()

# No Story
# No Description
# Only by Thinking and Testing
# Look at result of testcase, guess the code!
def testit(s):
    return ' '.join([i[:-1].lower() + i[-1].upper() for i in s.split()])

# You are given a sequence of positive ints where every element appears three times, except one that appears only once
# (let's call it x) and one that appears only twice (let's call it y).
# Your task is to find x * x * y.
import math
def missing_values(seq):
    return math.prod([i**2 for i in seq if seq.count(i)==1]) * [i for i in seq if seq.count(i)==2][0]

# In this Kata, you will write a function doubles that will remove double string characters that
# are adjacent to each other.
# For example:
# doubles('abbcccdddda') = 'aca', because, from left to right:
def doubles(s):
    for char in s:
        if char * 2 in s:
            s = s.replace(char * 2, '')
    return s

# Given two integer arrays where the second array is a shuffled duplicate of
# the first array with one element missing, find the missing element.
# Please note, there may be duplicates in the arrays, so checking if a
# numerical value exists in one and not the other is not a valid solution.
def find_missing(arr1, arr2):
    return sum(arr1) - sum(arr2)

# Your task is to write a function, which takes two arguments and returns a sequence. First argument is
# a sequence of values, second is multiplier. The function should filter all
# non-numeric values and multiply the rest by given multiplier.
def multiply_and_filter(seq, multiplier):
    return [i * multiplier for i in seq if type(i) == int or type(i) == float]

# Agent 47, you have a new task! Among citizens of the city
# X are hidden 2 dangerous criminal twins. Your task is to identify them and eliminate!
# Given an array of integers, your task is to find
# two same numbers and return one of them, for example in array [2, 3, 6, 34, 7, 8, 2] answer is 2.
# If there are no twins in the city - return None or the equivalent in the language that you are using.
def elimination(arr):
    for x in arr:
        if arr.count(x) == 2:
            return x
        
# Your friend Robbie has successfully created an AI that is capable of communicating in English!
# Robbie's almost done with the project, however the machine's output isn't working as expected.
# Here's a sample of a sentence that it outputs:
# Your function should:
# Capitalise the first letter of the first word.
# Add a period (.) to the end of the sentence.
# Join the words into a complete string, with spaces.
# Do no other manipulation on the words.
def sentencify(words):
    return words[0][0].upper() + ' '.join(words)[1:] + '.'

# Write a method remainder which takes two integer arguments, dividend and divisor, and returns the remainder
# when dividend is divided by divisor. Do NOT use the modulus operator (%) to calculate the remainder!
# Assumption
# Dividend will always be greater than or equal to divisor.
# Notes
# Make sure that the implemented remainder function works exactly the same as the Modulus operator (%).
# divmod has also been disabled.
def remainder(dividend,divisor):
	return dividend - (dividend//divisor) * divisor

# No Story
# No Description
# Only by Thinking and Testing
# Look at result of testcase, guess the code!
def testit(n):
    return bin(n).count('1')

# Groups of characters decided to make a battle. Help them to figure
# out which group is more powerful. Create a function that will accept 2 strings and return the one who's stronger.
# Rules:
# Each character have its own power: A = 1, B = 2, ... Y = 25, Z = 26
# Strings will consist of uppercase letters only
# Only two groups to a fight.
# Group whose total power (A + B + C + ...) is bigger wins.
# If the powers are equal, it's a tie.
def battle(x, y):
    s = [sum([ord(i)-64 for i in x]), sum([ord(i)-64 for i in y])]
    return x if s[0] > s[1] else y if s[1] > s[0] else 'Tie!'

# You need to create a function, helloWorld, that will return the String Hello, World!
# without actually using raw strings. This includes quotes, double quotes and template strings.
# You can, however, use the String constructor and any related functions.
def hello_world():
  return chr(72) + chr(101) + chr(108) + chr(108) + chr(111) + chr(44) + chr(32) + chr(87) + chr(111) + chr(114) + chr(108) + chr(100) + chr(33)

# Complete the function that takes an odd integer (0 < n < 1000000) which
# is the difference between two consecutive perfect squares, and return these squares as
# a string in the format "bigger-smaller"
def find_squares(n):
    i = (n - 1) // 2
    return f'{(i + 1)**2}-{i**2}'

# A cyclops number is a number in binary that is made up of all 1's,
# with one 0 in the exact middle. That means all cyclops
# numbers must have an odd number of digits for there to be an exact middle.
# A couple examples:
# 101
# 11111111011111111
# You must take an input, n, that will be in decimal format (base 10), then return True if that number
# wil be a cyclops number when converted to binary, or False if it won't.
# Assume n will be a positive integer.
def cyclops(n):
    i = bin(n)[2:]
    return i.count("0") == 1 and i == i[::-1]

# A noob programmer was given two simple tasks: sum and sort the elements of
# the given array arr = [a1, a2, ..., an].
# He started with summing and did it easily, but decided to store the sum he found
# in some random position of the original array which was a bad idea. Now he needs
# to cope with the second task, sorting the original array arr, and it's giving him trouble since he modified it.
# Given the array shuffled, consisting of elements a1, a2, ..., an, and
# their sumvalue in random order, return the sorted array of original elements a1, a2, ..., an.
def shuffled_array(l):
    l.pop(l.index(sum(l) / 2))
    return sorted(l)

# Oh no, Timmy's filter doesn't seem to be working? Your task is
# to fix the FilterNumber function to remove all the numbers from the string.
def filter_numbers(string):
    return "".join(x for x in string if not x.isdigit())

# Find the difference between two collections. The difference means that either the character is
# present in one collection or it is present in other, but not in both. Return a sorted list with the difference.
# The collections can contain any character and can contain duplicates.
def diff(a, b):
    return sorted(list(set([i for i in a if i not in b] + [i for i in b if i not in a])))

# You need count how many valleys you will pass.
# Start is always from zero level.
# Every time you go down below 0 level counts as an entry of a valley,
# and as you go up to 0 level from valley counts as an exit of a valley.
# One passed valley is equal one entry and one exit of a valley.
def counting_valleys(s):
    level, valleys = 0, 0
    for step in s:
        if step == 'U' and level == -1:
            valleys += 1
        level += {'U': 1, 'F': 0, 'D': -1}[step]
    return valleys

# Multiply all the digits of a nonnegative integer n by each other, repeating with
# the product until a single digit is obtained. The number of steps
# required is known as the multiplicative persistence.
# Create a function that calculates the individual results of each step, not including the original
# number, but including the single digit, and outputs the result as a list/array.
# If the input is a single digit, return an empty list/array.
from functools import reduce
from operator import mul
def per(n):
    res = []
    while n > 9:
        n = reduce(mul, map(int, str(n)))
        res.append(n)
    return res

# There is a narrow hallway in which people can go right and left only. When two people meet in
# the hallway, by tradition they must salute each other. People move at the same speed left and right.
# Your task is to write a function that, given a string representation
# of people moving in the hallway, will count the number of salutes that will occur.
# Note: 2 salutes occur when people meet, one to the other and vice versa.
# Input
# People moving right will be represented by >; people moving left will be represented
# by <. An example input would be >--<--->->. The - character represents empty space,
# which you need not worry about.
# Examples
def count_salutes(h):
    return sum(2 * sum(j == '<'for j in h[i:]) * (h[i] == '>')for i in range(len(h)))

# Calculate how many times a number can be divided by a given number.
from math import log
def divisions(n, divisor):
    return int(log(n, divisor))

# Get the next prime number!
# You will get a numbern (>= 0) and your task is to find the next prime number.
# Make sure to optimize your code: there will numbers tested up to about 10^12.
from gmpy2 import next_prime

# Write a function that takes an integer and returns an array [A, B, C],
# where A is the number of multiples of 3 (but not 5) below the given
# integer, B is the number of multiples of 5 (but not 3)
# below the given integer and C is the number of multiples of 3 and 5 below the given integer.
# For example, solution(20) should return [5, 2, 1]
def solution(number):
    A, B, C = (number - 1) // 3, (number - 1) // 5, (number - 1) // 15
    return [A - C, B - C, C]

# Your task is to sort an array of integer numbers by the product of the value and the index of the positions.
# For sorting the index starts at 1, NOT at 0!
# The sorting has to be ascending.
# The array will never be null and will always contain numbers.
def sort_by_value_and_index(arr):
    return [i[1] for i in sorted(enumerate(arr), key=lambda x:(x[0] + 1) * x[1])]

# A genetic algorithm is based in groups of chromosomes, called populations.
# To start our population of chromosomes we need to generate random binary strings with a specified length.
# In this kata you have to implement a function generate that receives a length
# and has to return a random binary strign with length characters.
from random import choice
def generate(length):
    return "".join(choice("01") for i in range(length))

# The function takes cents value (int) and needs to return the minimum number of coins combination of the same value.
def coin_combo(cents):
    return [cents % 5, ((cents % 25) % 10) // 5, (cents % 25) // 10, cents // 25]

# Write a program to determine if the two given numbers are
# coprime. A pair of numbers are coprime if their greatest shared factor is 1.
# The inputs will always be two positive integers between 2 and 99.
from math import gcd
def are_coprime(n, m):
    return gcd(n, m) == 1

# In mathematics, an nth root of a number x, where n is usually assumed
# to be a positive integer, is a number r which, when raised to the power n, yields x:
def perfect_roots(n):
    return (((n**.5)**0.5)**0.5) == int((((n**.5)**0.5)**0.5))

# Task:
# You have to create a function isPronic to check whether
# the argument passed is a Pronic Number and return true if it is & false otherwise.
# Description:
# Pronic Number -A pronic number, oblong number, rectangular number or heteromecic number,
# is a number which is the product of two consecutive integers, that is, n(n + 1).
import math
def is_pronic(n):
    return n >= 0 and math.sqrt(1 + 4 * n) % 1 == 0

# You will be given a number and your task is to return the nth fibonacci string. For example:
def solve(n):
    a, b = '0', '01'
    for i in range(n):
        a, b = b, b + a
    return a

# Caomplete the solution so that it returns the greatest sequence of
# five consecutive digits found within the number given.
# The number will be passed in as a string of only digits. It should return a five
# digit integer. The number passed may be as large as 1000 digits.
# Adapted from ProjectEuler.net
def solution(digits):
    return max(int(digits[i:i+5]) for i in range(0,len(digits)-4))

# Your task is to add up letters to one letter.
# The function will be given a variable amount of arguments, each one being a letter to add.
# Notes:
# Letters will always be lowercase.
# Letters can overflow (see second to last example of the description)
# If no letters are given, the function should return 'z'
def add_letters(*letters):
    return chr((sum(ord(c) - 96 for c in letters) - 1) % 26 + 97)
# The following code could use a bit of object-oriented artistry. While it's a simple method
# and works just fine as it is, in a larger system it's best to organize methods
# into classes/objects. (Or, at least, something similar depending on your language)
# Refactor the following code so that it belongs to a Person class/object. Each Person instance
# will have a greet method. The Person instance should be instantiated with a name
# so that it no longer has to be passed into each greet method call.
# Here is how the final refactored code would be used:
class Person:
    def __init__(self, name):
        self.name = name
    def greet(self, other):
        return f"Hello {other}, my name is {self.name}"

# Each day a plant is growing by upSpeed meters. Each night that plant's height decreases
# by downSpeed meters due to the lack of sun heat. Initially, plant is 0 meters tall.
# We plant the seed at the beginning of a day. We want to know when the height of the
# plant will reach a certain level.
from math import ceil
def growing_plant(up, down, h):
    return max(ceil((h - down) / (up - down)), 1)

# If you finish this kata, you can try Insane Coloured Triangles by Bubbler, which is a much
# harder version of this one.
# A coloured triangle is created from a row of colours, each of which is red,
# green or blue. Successive rows, each containing one fewer colour than the last, are generated by
# considering the two touching colours in the previous row. If these colours are identical,
# the same colour is used in the new row. If they are different, the missing colour
# is used in the new row. This is continued until the final row, with only a single colour, is generated.
COLORS = set("RGB")
def triangle(row):
    while len(row)>1:
        row = ''.join( a if a==b else (COLORS-{a,b}).pop() for a,b in zip(row, row[1:]))
    return row

# The following code is not giving the expected results. Can you debug what the issue is?
# The following is an example of data that would be passed in to the function.
def itemgetter(item):
    return item['name']
def get_names(data):
    return list(map(itemgetter,data))

# You will be given an array of objects (associative arrays in PHP) representing data about developers who
# have signed up to attend the next coding meetup that you are organising.
# Your task is to return:
# true if at least one Ruby developer has signed up; or
# false if there will be no Ruby developers.
def is_ruby_coming(lst):
    return any(x["language"] == "Ruby" for x in lst)

# King Arthur and his knights are having a New Years party. Last year Lancelot was jealous of Arthur,
# because Arthur had a date and Lancelot did not, and they started a duel.
# To prevent this from happening again, Arthur wants to make sure that there are at least
# as many women as men at this year's party. He gave you a list of integers of all the party goers.
# Arthur needs you to return true if he needs to invite more women or false if he is all set.
def invite_more_women(arr):
    return sum(arr) > 0

# I assume most of you are familiar with the ancient legend of the rice (but I see wikipedia suggests wheat,
# for some reason) problem, but a quick recap for you: a young man asks as a
# compensation only 1 grain of rice for the first square, 2 grains for the second,
# 4 for the third, 8 for the fourth and so on, always doubling the previous.
# Your task is pretty straightforward (but not necessarily easy): given an amount
# of grains, you need to return up to which square of the chessboard one should count
# in order to get at least as many.
# As usual, a few examples might be way better than thousands of words from me:
def squares_needed(grains):
    return grains.bit_length()

# Your job is to figure out the index of which vowel is missing from a given string:
# A has an index of 0,
# E has an index of 1,
# I has an index of 2,
# O has an index of 3,
# U has an index of 4.
# Notes: There is no need for string validation and every sentence
# given will contain all vowels but one. Also, you won't need to worry about capitals.
def absent_vowel(x):
    return ['aeiou'.index(i) for i in 'aeiou' if i not in x][0]

# No Story
# No Description
# Only by Thinking and Testing
# Look at result of testcase, guess the code!
def testit (a, b):
    return a | b

# The following code was thought to be working properly, however when the code
# tries to access the age of the person instance it fails.
class Person():
    def __init__(self, first_name, last_name, age):
        self.first_name = first_name
        self.last_name = last_name
        self.full_name = f"{first_name} {last_name}"
        self.age = age

# Given a credit card number we can determine who the issuer/vendor is with a few basic knowns.
# Complete the function get_issuer() that will use the values shown below to determine the card
# issuer for a given card number. If the number cannot be matched then the
# function should return the string Unknown.
def get_issuer(number):
    card = str(number)
    nums = len(card)
    if card[:2] in ("34", "37") and nums == 15:return "AMEX"
    elif card[:4] == "6011" and nums == 16:return "Discover"
    elif 51 <= int(card[:2]) <= 55 and nums == 16:return "Mastercard"
    elif card[0] == "4" and nums in (13, 16):return "VISA"
    return "Unknown"

# Your are given a string. You must replace any occurence of the sequence coverage
# by covfefe, however, if you don't find the word coverage in the string,
# you must add covfefe at the end of the string with a leading space.
# For the languages where the string is mutable (such as ruby), don't modify
# the given string, otherwise this will break the test cases.
# STRINGS
def covfefe(s):
    if 'coverage' in s: return s.replace('coverage', 'covfefe')
    return s + ' covfefe'

# Write a function named numbers.
# function should return True if all the parameters it is passed are of the
# integer type or float type. Otherwise, the function should return False.
# The function should accept any number of parameters.
def numbers(*l):
    return all(type(i) in (int, float) for i in l)

# This function should take two string parameters: a person's name (name) and a quote
# of theirs (quote), and return a string attributing the quote to the person in the following format:
def quotable(name, quote):
    return f'{name} said: "{quote}"'

# Beaches are fildh sand, water, fish, and sun. Given a string, calculate how many times the
# words "Sand", "Water", "Fish", and "Sun" appear without overlapping (regardless of the case).
def sum_of_a_beach(beach):
    return sum(beach.lower().count(i) for i in ["sand", "water", "fish", "sun"])

# The number 198 has the property that 198 = 11 + 99 + 88, i.e., if each of its digits is
# concatenated twice and then summed, the result will be the original number. It turns out that 198
# is the only number with this property. However, the property can be generalized so
# that each digit is concatenated n times and then summed.
def check_concatenated_sum(n, r):
    return abs(n) == sum(int(i * r) for i in str(abs(n)) if r)

# Complete the function that counts the number of unique consonants in a string
# (made up of printable ascii characters).
# Consonants are letters used in English other than "a", "e", "i", "o", "u".
# Remember, your function needs to return the number of unique consonants
# - disregarding duplicates. For example, if the string passed into the function reads "add", the
# function should return 1 rather than 2, since "d" is a duplicate.
# Similarly, the function should also disregard duplicate consonants of differing cases. For example,
# "Dad" passed into the function should return 1 as "d" and "D" are duplicates.
def count_consonants(text):
    return len(set(filter(str.isalpha, text.lower())) - set("aeiou"))

# Mrs. Frizzle is beginning to plan lessons for her science class next semester, and
# wants to encourage friendship amongst her students. To accomplish her goal, Mrs.
# Frizzle will ensure each student has a chance to partner with every other student
# in the class in a series of science projects.
# Mrs. Frizzle does not know who will be in her class next semester, but she does know
# she will have n students total in her class.
def projectPartners(n):
    return n * (n - 1) / 2

# You have been employed by the Japanese government to write a function that tests whether or not a
# building is strong enough to withstand a simulated earthquake.
# A building will fall if the magnitude of the earthquake is greater than the strength of the building.
# An earthquake takes the form of a 2D-Array. Each element within the Outer-Array represents a shockwave,
# and each element within the Inner-Arrays represents a tremor.
# The magnitude of the earthquake is determined by the product of the values
# of its shockwaves. A shockwave is equal to the sum of the values of its tremors.
from functools import reduce
def strong_enough(earthquake, age):
    strength = 1000 * 0.99 ** age
    shockwave = reduce(lambda x, y: x*y, [sum(i) for i in earthquake])
    return "Needs Reinforcement!" if strength <= shockwave else "Safe!"

# As part of this Kata, you need to find the length of the sequence in an array,
# between the first and the second occurrence of a specified number.
# For example, for a given array arr
def length_of_sequence(arr, n):
    if arr.count(n) == 2:
        a = arr.index(n)
        b = arr.index(n, a + 1)
        return b - a + 1
    return 0

# Fans of The Wire will appreciate this one. For those that haven't seen the show,
# the Barksdale Organization has a simple method for encoding telephone numbers exchanged via
# pagers: "Jump to the other side of the 5 on the keypad, and swap 5's and 0's."
def decode(s):
    return s.translate(str.maketrans("1234567890", "9876043215"))

# Oh no, Timmy's received some hate mail recently but he knows better. Help Timmy fix his
# regex filter so he can be awesome again!
import re
def filter_words(phrase):
    return re.sub("(bad|mean|ugly|horrible|hideous)","awesome", phrase, flags=re.IGNORECASE)

# This is the simple version of Shortest Code series. If you need some
# challenges, please try the challenge version.
# Task:
# Find out "B"(Bug) in a lot of "A"(Apple).
# There will always be one bug in apple, not need to consider the situation that without bug or more than one bugs.
# input: string Array apple
# output: Location of "B", [x,y]
def sc(apple):
    c = 0
    c1 = 0
    for i in apple:
        if 'B' in i:
            c += i.index('B')
            c1 += apple.index(i)
    return [c1, c]

# Yet another staple for the functional programmer. You have a sequence of values and some predicate for those values.
# You want to remove the longest prefix of elements such that the predicate is true
# for each element. We'll call this the dropWhile function. It accepts two arguments.
# The first is the sequence of values, and the second is the predicate function. The
# function does not change the value of the original sequence.
def drop_while(arr, pred):
    for k,v in enumerate(arr):
        if not pred(v):
            return arr[k:]
    return []

# Validate a given EAN-Code. Return true if the given EAN-Code is valid, otherwise false.
# Assumption
# You can assume the given code is syntactically valid, i.e. it only
# consists of numbers and it exactly has a length of 13 characters.
def validate_ean(code):
    code1 = sum(int(i) for i in code[0::2])
    code = sum(int(i) for i in code[1::2])
    return (code1 + code * 3) % 10 == 0

# YouTube had a like and a dislike button, which allowed users to
# express their opinions about particular content. It was set up in such a way
# that you cannot like and dislike a video at the same time. There are
# two other interesting rules to be noted about the interface: Pressing a button, which
# is already active, will undo your press. If you press the like button after pressing
# the dislike button, the like button overwrites the previous "Dislike" state. The same is
# true for the other way round.
def like_or_dislike(lst):
	choice = 'Nothing'
	for choi in lst:
		choice = 'Nothing' if choi == choice else choi
	return choice

# Create a function which checks a number for three different properties.
# is the number prime?
# is the number even?
# is the number a multiple of 10?
# Each should return either true or false, which should be given as an array.
# Remark: The Haskell variant uses data Property.
def number_property(n):
    is_prime = lambda i: False if i <= 1 else all([1 if n % i != 0 else 0 for i in range(2, int(n ** 0.5 + 1))])
    is_even = lambda x: x%2 == 0
    is_mult_10 = lambda x: x%10 == 0
    return [is_prime(n), is_even(n), is_mult_10(n)]

# Function receive a two-dimensional square array of random integers.
# On the main diagonal, all the negative integers must be changed to 0,
# while the others must be changed to 1 (Note: 0 is considered non-negative, here).
# (You can mutate the input if you want, but it is a better practice to not mutate the input)
def matrix(m):
    return [[v if i != k else int(v >= 0) for k,v in enumerate(r)] for i, r in enumerate(m)]

# Given a number N, determine if the sum of N consecutive numbers is odd or even.
# If the sum is definitely an odd number, return Odd.
# If the sum is definitely an even number, return Even.
# If the sum can be either odd or even ( depending on which first number you choose ), return Either.
def odd_or_even(n):
    return ("Even", "Either", "Odd", "Either")[n % 4]

# Write a function that returns true if a given point (x,y) is inside of a unit
# circle (that is, a "normal" circle with a radius of one) centered at
# the origin (0,0) and returns false if the point is outside.
def point_in_circle(x, y):
    return (x*x + y*y) < 1

# You have managed to intercept an important message and you are trying to read it.
# You realise that the message has been encoded and can be decoded by switching each letter with a corresponding
# letter.
# You also notice that each letter is paired with the letter that it coincides with when the alphabet is reversed.
# For example: "a" is encoded with "z", "b" with "y", "c" with "x", etc
def decode(message):
    return message.translate(str.maketrans('abcdefghijklmnopqrstuvwxyz', 'abcdefghijklmnopqrstuvwxyz'[::-1]))

# A comfortable word is a word which you can type always alternating the hand you
# type with (assuming you type using a QWERTY keyboard and use fingers as shown in the image below).
# That being said, complete the function which receives a word and returns
# true if it's a comfortable word and false otherwise.
# The word will always be a string consisting of only ascii letters from a to z.
def comfortable_word(word):
    left = [c in 'qwertasdfgzxcvb' for c in word[::2]]
    right = [c in 'yuiophjklnm' for c in word[1::2]]
    return bool((all(left) and all(right)) or (not any(left) and not any(right)))

# Bob is a chicken sexer. His job is to sort baby chicks into a Male(M)
# and Female(F) piles. When bob can't guess can throw his hands up and declare it with a '?'.
# Bob's bosses don't trust Bob's ability just yet, so they have paired him with an expert sexer.
# All of Bob's decisions will be checked against the expert's choices to generate a correctness score.
def correctness(bob, exp):
    return sum(b == e or .5*(b == '?' or e == '?') for b,e in zip(bob, exp))

# You have to create a function named reverseIt.
# Write your function so that in the case a string or a number is passed in
# as the data , you will return the data in reverse order. If the data is any other type, return it as it is.
def reverse_it(data):
    return type(data)(str(data)[::-1]) if type(data) in [int, str, float] else data

# Given a string, determine if it's a valid identifier.
# Here is the syntax for valid identifiers:
# Each identifier must have at least one character.
# The first character must be picked from: alpha, underscore,
# or dollar sign. The first character cannot be a digit.
# The rest of the characters (besides the first) can be from: alpha,
# digit, underscore, or dollar sign. In other words, it can be any valid identifier character.
import re
def is_valid(word):
    return re.compile('^[a-z_\$][a-z0-9_\$]*$', re.IGNORECASE).match(word) != None

# Oh no! Timmy's reduce is causing problems, Timmy's goal is to calculate the two
# teams scores and return the winner but timmy has gotten confused and sometimes teams
# don't enter their scores, total the scores out of 3! Help timmy fix his program!
# Return true if team 1 wins or false if team 2 wins!
def calculate_total(t1, t2):
    return sum(t1) > sum(t2)

# You will be given two ASCII strings, a and b. Your task is write a function
# to determine which one of these strings is "worth" more, and return it.
# A string's worth is determined by the sum of its ASCII codepoint indexes. So,
# for example, the string HELLO has a value of 372: H is codepoint 72, E 69, L 76, and O is 79.
# The sum of these values is 372.
# In the event of a tie, you should return the first string, i.e. a.
def highest_value(a, b):
    return max(a, b, key=lambda x: sum(map(ord, x)))

# Reversing an array can be a tough task, especially for a novice programmer. Mary
# just started coding, so she would like to start with something basic at first. Instead of reversing
# the array entirely, she wants to swap just its first and last elements.
# Given an array arr, swap its first and last elements and return the resulting array.
# Example
# For arr = [1, 2, 3, 4, 5], the output should be [5, 2, 3, 4, 1]
def first_reverse_try(arr):
    if arr:
        arr[0], arr[-1] = arr[-1], arr[0]
    return arr

# Write a function that appends the items from sequence 2 onto sequence 1, returning the newly formed sequence.
# Your function should also be able to handle nested sequences.
# All inputs will be arrays/nested arrays.
def append_arrays(seq1, seq2):
    return seq1 + seq2

# The Hamming weight of a string is the number of symbols that are different from the zero-symbol
# of the alphabet used. There are several algorithms for efficient computing of the Hamming
# weight for numbers. In this Kata, speaking technically, you have to find out the
# number of '1' bits in a binary representation of a number. Thus,
def hamming_weight(x):
    return bin(x)[2:].count('1')

# You will be given an array that contains two strings. Your job is to create a
# function that will take those two strings and transpose them, so that the strings go from
# top to bottom instead of left to right.
import itertools
def transpose_two_strings(arr):
    return '\n'.join(' '.join(i) for i in itertools.zip_longest(arr[0], arr[1], fillvalue=' '))

# Everybody knows a little german, right? But remembering the correct articles is a tough job.
# Write yourself a little helper, that returns the noun with the matching article:
# each noun containing less than 2 vowels has the article "das"
# each noun containing 2/3 vowels has the article "die"
# each noun containing more than 3 vowels has the article "der"
# Caution: Vowels are "a,e,i,o,u". Umlaute (ä ö ü) are also being counted!
# (This Kata is a joke, there is no such grammar rule!)
def der_die_das(wort):
    c = sum(i in "aAeEiIoOuUäöü" for i in wort)
    return f'{"das" if c < 2 else "die" if c < 4 else "der"} {wort}'

# The year of 2013 is the first year after the old 1987 with only distinct digits.
# Now your task is to solve the following problem: given a year number, find the minimum
# year number which is strictly larger than the given one and has only distinct digits.
def distinct_digit_year(year):
    year += 1
    while any(str(year).count(i) != 1 for i in str(year)):
        year += 1
    return year

# This is a problem that involves adding numbers to items in a list. In a
# list you will have to add the item's remainder when divided by a given divisor to each item.
# For example if the item is 40 and the divisor is 3 you would have to add
# 1 since 40 minus the closest multiple of 3 which is 39 is 1. So the 40 in the list
# will become 41. You would have to return the modified list in this problem.
# For this problem you will receive a divisor called div as well as simple list of whole numbers
# called nums. Good luck and happy coding.
def solve(nums,div):
    return [x + x % div for x in nums]

# My PC got infected by a strange virus. It only infects my text files
# and replaces random letters by *, li*e th*s (like this).
# Fortunately, I discovered that the virus hides my censored letters inside root directory.
# It will be very tedious to recover all these files manually, so your goal is to implement
# uncensor function that does the hard work automatically.
def uncensor(infected, discovered):
	return infected.replace('*', '{}').format(*discovered)

# Given 2 strings, your job is to find out if there is a substring that appears in both strings. You
# will return true if you find a substring that appears in both strings, or false if you do not.
# We only care about substrings that are longer than one letter long.
def substring_test(s1, s2):
    return any(s1.lower()[i:i+2] in s2.lower() for i in range(len(s1)-2))

# You just took a contract with the Jedi council. They need you to write a function,
# greet_jedi(), which takes two arguments (a first name and a last name), works out
# the corresponding Jedi name, and returns a string greeting the Jedi.
# A person's Jedi name is the first three letters of their last name followed by the first two letters
# of their first name. For example:
def greet_jedi(first, last):
    return f'Greetings, master {last[:3].title() + first[:2].title()}'

# In this kata, you will take the keys and values of a dict and swap them around.
# You will be given a dictionary, and then you will want to return a dictionary
# with the old values as the keys, and list the old keys as values under their original keys.
def switch_dict(dic):
    res = {}
    for key, value in dic.items():
        res.setdefault(value, []).append(key)
    return res

# Positive integers have so many gorgeous features. Some of them could be expressed as a sum of
# two or more consecutive positive numbers.
import math
def consecutive_ducks(n):
    return not math.log2(n).is_integer()

# Your website is divided vertically in sections, and each can be of different size (height).
# You need to establish the section index (starting at 0) you are at, given the scrollY and sizes of all sections.
# Sections start with 0, so if first section is 200 high, it takes 0-199 "pixels" and second starts at 200.
from itertools import accumulate
def get_section_id(scroll, sizes):
    return next((k for k,v in enumerate(accumulate(sizes)) if v > scroll), -1)

# DropCaps means that the first letter of the starting word of the paragraph should be in caps and
# the remaining lowercase, just like you see in the newspaper.
# But for a change, let"s do that for each and every word of the given String. Your
# task is to capitalize every word that has length greater than 2, leaving smaller words as they are.
# *should work also on Leading and Trailing Spaces and caps.
def drop_cap(str_):
    return ' '.join(i.capitalize() if len(i) > 2 else i for i in str_.split(' '))

# Every month, a random number of students take the driving test at Fast & Furious (F&F)
# Driving School. To pass the test, a student cannot accumulate more than 18 demerit points.
# At the end of the month, F&F wants to calculate the average demerit points
# accumulated by ONLY the students who have passed, rounded to the nearest integer.
# Write a function which would allow them to do so. If no students passed the
# test that month, return 'No pass scores registered.'.
from statistics import mean
def passed(lst):
    return int(round(mean([i for i in lst if i < 19] or [0]))) or 'No pass scores registered.'

# You're putting together contact information for all the users of your website to ship them a
# small gift. You queried your database and got back a list of users, where each user is another
# list with up to two items: a string representing the user's name and their shipping zip code.
# Example data might look like:
# [["Grae Drake", 98110], ["Bethany Kok"], ["Alex Nussbacher", 94101], ["Darrell Silver", 11201]]
# Notice that one of the users above has a name but doesn't have a zip code.
# Write a function user_contacts() that takes a two-dimensional list like the
# one above and returns a dictionary with an item for each user where the key is the
# user's name and the value is the user's zip code. If your data doesn't include a
# zip code then the value should be None.
def user_contacts(data):
    d = {}
    for i in data:
        if len(i) == 2:
            d[i[0]] = i[1]
            continue
        d[i[0]] = None
    return d

# Zebulan has worked hard to write all his python code in strict compliance to PEP8 rules. In
# this kata, you are a mischievous hacker that has set out to sabotage all his good code.
# Your job is to take PEP8 compatible function names and convert them to camelCase. For example:
def zebulans_nightmare(function):
    l = function.split('_')
    return l[0].lower() + ''.join(i.title() for i in l[1:])

# John is a worker, his job is to remove screws from a machine. There are 2 types
# of screws: slotted (-) and cross (+). John has two screwdrivers, one for each type of screw.
# The input will be a (non-empty) string of screws, e.g. : "---+++"
# When John begins to work, he stands at the first screw, with the
# correct screwdriver in his hand, and another in his tool kit. He works from
# left to right, removing every screw. When necessary, he switches between the screwdriver in
# his hand and the one in his tool kit.
def sc(s):
    return len(s)*2 - 1 + 5 * (s.count('+-') + s.count('-+'))

# Many people know that Apple uses the letter "i" in almost all of its devices to emphasize its personality.
# And so John, a programmer at Apple, was given the task of making a program that would add that letter to
# every word. Let's help him do it, too.
def i(word):
    if not word or word[0].islower() or word[0].upper() == 'I' or sum(1 for i in word.lower() if i in 'aeoiu') >= sum(1 for i in word.lower() if i not in 'aeoiu'):
        return 'Invalid word'
    return 'i' + word

# You have a string that consists of zeroes and ones. Now choose
# any two adjacent positions in the string: if one of them is 0, and
# the other one is 1, remove these two digits from the string.
# Return the length of the resulting (smallest) string that you can get after applying
# this operation multiple times?
# Note: after each operation, the remaining digits are separated by spaces and thus not adjacent
# anymore - see the examples below.
def zero_and_one(s):
    return len(s.replace('01', '').replace('10', ''))

# Write a function that checks if two non-negative integers make an "interlocking binary pair".
# Interlock ?
# numbers can be interlocked if their binary representations have no 1's in the same place
# comparisons are made by bit position, starting from right to left (see the examples below)
# when representations are of different lengths, the unmatched left-most bits are ignored
def interlockable(a, b):
    return not a & b

# Create a function that takes two arguments:
# An array of objects which feature the season, the team and the country of the Champions League winner.
# Country (as a string, for example, 'Portugal')
# You function should then return the number which represents the number of times a team from
# a given country has won. Return 0 if there have been no wins.
# For example if the input array is as follows:
def countWins(winnerList, country):
    return sum(i.get('country') == country for i in winnerList)

# You will be passed the dice value frequencies, and your task is to write
# the code to return a string representing a histogram, so that when it is printed it
# has the same format as the example.
# Notes
# There are no trailing spaces on the lines
# All lines (including the last) end with a newline \n
# A count is displayed beside each bar except where the count is 0
# The number of rolls may vary but there are never more than 100
def histogram(results):
    return "".join("{}|{} {}\n".format(7 - i, f * "#", f) for i, f in enumerate(results[::-1], 1)).replace(" 0", "")

#The method should add the values of the arrays to one new array.
# The arrays in the array will all have the same size and this size will always be greater than 0.
# The shifting value is always a value from 0 up to the size of the arrays.
# There are always arrays in the array, so you do not need to check for null or empty.
def sum_arrays(arrays, shift):
    sh = [[0]*i*shift + a + [0]*(len(arrays)-i-1)*shift  for i, a in enumerate(arrays)]
    return list(map(sum, zip(*sh)))

# If we list all the natural numbers below 10 that are multiples of 3 or 5, we get
# 3, 5, 6 and 9. The sum of these multiples is 23.
# Finish the solution so that it returns the sum of all the multiples of
# 3 or 5 below the number passed in. Additionally, if the number is negative, return 0
# (for languages that do have them).
# Note: If the number is a multiple of both 3 and 5, only count it once.
def solution(number):
    return sum([i for i in range(number) if i % 3 == 0 or i % 5 == 0])

# Write a function that accepts an array of 10 integers (between 0 and 9), that
# returns a string of those numbers in the form of a phone number.
def create_phone_number(n):
    return f"({''.join(str(i) for i in n[:3])}) {''.join(str(i) for i in n[3:6])}-{''.join(str(i) for i in n[6:])}"

# Digital root is the recursive sum of all the digits in a number.
# Given n, take the sum of the digits of n. If that value
# has more than one digit, continue reducing in this way until a single-digit number is
# produced. The input will be a non-negative integer.
def digital_root(n):
    while len(str(n)) > 1:
        n = sum(int(i) for i in str(n))
    return n

# Write a function that takes in a string of one or more words, and returns the same string, but
# with all five or more letter words reversed (Just like the name of this Kata). Strings passed in will
# consist of only letters and spaces. Spaces will be included only when more than one word is present.
def spin_words(sentence):
    return ' '.join(i[::-1] if len(i) > 4 else i for i in sentence.split())

# Write a function that takes an integer as input, and returns the number of bits that
# are equal to one in the binary representation of that number. You can guarantee that input is non-negative.
# Example: The binary representation of 1234 is 10011010010, so the function should return 5 in this case
def count_bits(n):
    return bin(n)[2:].count('1')

# A Narcissistic Number (or Armstrong Number) is a positive number which is the sum of its own digits,
# each raised to the power of the number of digits in a given base. In
# this Kata, we will restrict ourselves to decimal (base 10).
def narcissistic( value ):
    return sum(int(i)**len(str(value)) for i in str(value)) == value

# Complete the solution so that it splits the string into pairs of two characters.
# If the string contains an odd number of characters then it should replace the
# missing second character of the final pair with an underscore ('_').
def solution(s):
    return [s[i:i+2] if len(s[i:i+2]) == 2 else s[i:i+2] + '_' for i in range(0, len(s), 2)]

# Given two arrays of strings a1 and a2 return a sorted array r
# in lexicographical order of the strings of a1 which are substrings of strings of a2
def in_array(array1, array2):
    r = []
    for i in array1:
        for j in array2:
            if i in j:
                r.append(i)
    return sorted(set(r))

# Write simple .camelCase method (camel_case function in PHP, CamelCase in C# or
# camelCase in Java) for strings. All words must have their first letter capitalized without spaces.
def camel_case(string):
    return string.title().replace(" ", "")

# Let us consider this example (array written in general format):
# ls = [0, 1, 3, 6, 10]
# Its following parts:
def parts_sums(ls):
    res = [sum(ls)]
    for i in ls:
        res.append(res[-1] - i)
    return res

# Middle Earth is about to go to war. The forces of good will have
# many battles with the forces of evil. Different races will certainly be involved. Each
# race has a certain worth when battling against others. On the side of good we have the
# following races, with their associated worth:
def good_vs_evil(good, evil):
    good = sum([int(x) * y for x, y in zip(list(good.split(' ')), [1, 2, 3, 3, 4, 10])])
    evil = sum([int(x) * y for x, y in zip(list(evil.split(' ')), [1, 2, 2, 2, 3, 5, 10])])
    res = ['Battle Result: No victor on this battle field', 'Battle Result: Good triumphs over Evil', 'Battle Result: Evil eradicates all trace of Good']
    return res[0] if good == evil else res[1] if good > evil else res[2]

# Write a function that accepts a string, and returns true if it is in the form of a phone number.
# Assume that any integer from 0-9 in any of the spots will produce a valid phone number.
# Only worry about the following format:
# (123) 456-7890 (don't forget the space after the close parentheses)
def valid_phone_number(phone_number):
    l = len(phone_number)
    s = sum(1 for i in phone_number if i.isdigit())
    check = '()- '
    return l == 14 and s == 10 and all(i in phone_number for i in check)

# Assume "#" is like a backspace in string. This means that string "a#bc#d" actually is "bd"
# Your task is to process a string with "#" symbols.
def clean_string(s):
    l = []
    for i in s:
        if i == '#' and l: l.pop()
        elif i != '#': l.append(i)
    return ''.join(l)

# An Arithmetic Progression is defined as one in which there is a constant difference between the
# consecutive terms of a given series of numbers. You are provided with consecutive
# elements of an Arithmetic Progression. There is however one hitch: exactly one
# term from the original series is missing from the set of numbers which have
# been given to you. The rest of the given series is the same as the original AP. Find the missing term.
# You have to write a function that receives a list, list size will always
# be at least 3 numbers. The missing term will never be the first or last one.
def find_missing(sequence):
    return (sequence[-1] + sequence[0]) * (len(sequence) + 1) / 2 - sum(sequence)

# You get an array of arrays.
# If you sort the arrays by their length, you will see, that their length-values are consecutive.
# But one array is missing!
# You have to write a method, that return the length of the missing array.
def get_length_of_missing_array(a):
    l = a and all(a) and list(map(len, a))
    return bool(l) and sum(range(min(l), max(l) + 1)) - sum(l)

# In this Kata, you will implement the Luhn Algorithm, which is used to help validate credit card numbers.
# Given a positive integer of up to 16 digits, return true if it
# is a valid credit card number, and false if it is not.
# Here is the algorithm:
def validate(n):
    digits = [int(i) for i in str(n)]
    e = [x*2 if x*2 <= 9 else x*2 - 9 for x in digits[-2::-2]]
    o  = [x for x in digits[-1::-2]]
    return (sum(e + o) % 10) == 0

# Winter is coming, you must prepare your ski holidays. The objective of this kata is to
# determine the number of pair of gloves you can constitute from the gloves you have in your drawer.
# Given an array describing the color of each glove, return the number of pairs you
# can constitute, assuming that only gloves of the same color can form pairs.
def number_of_pairs(gloves):
    c = 0
    l = []
    for i in gloves:
        if i not in l:
            l.append(i)
            continue
        c += 1
        l.remove(i)
    return c

# Write a function that when given a number >= 0, returns an Array of ascending length subarrays.
def pyramid(n):
    return [[1] * i for i in range(1, n+1)]

# In this kata you have to write a simple Morse code decoder. While the Morse code
# is now mostly superseded by voice and digital data communication channels,
# it still has its use in some applications around the world.
# The Morse code encodes every character as a sequence of "dots" and "dashes". For
# example, the letter A is coded as ·−, letter Q is coded as −−·−, and digit 1 is coded as ·−−−−. The
# Morse code is case-insensitive, traditionally capital letters are used. When the message
# is written in Morse code, a single space is used to separate the character
# codes and 3 spaces are used to separate words. For example, the message
# HEY JUDE in Morse code is ···· · −·−−   ·−−− ··− −·· ·.
# NOTE: Extra spaces before or after the code have no meaning and should be ignored.
def decodeMorse(morseCode):
    return ' '.join(''.join(MORSE_CODE[i] for i in j.split(' ')) for j in morseCode.strip().split('   '))

# Write a method that takes an array of consecutive (increasing)
# letters as input and that returns the missing letter in the array.
# You will always get an valid array. And it will be always exactly
# one letter be missing. The length of the array will always be at least 2.
# The array will always contain letters in only one case.
def find_missing_letter(chars):
    al = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
    for i in al[al.index(chars[0]):al.index(chars[-1])+1]:
        if i not in chars: return i

# Write a simple parser that will parse and run Deadfish.
# Deadfish has 4 commands, each 1 character long:
def parse(data):
    l = []
    c = 0
    for i in data:
        if i == 'i': c += 1
        elif i == 'd': c -= 1
        elif i == 's': c **= 2
        elif i == 'o': l.append(c)
    return l

# Create a function that takes a Roman numeral as its argument and returns its value as a
# numeric decimal integer. You don't need to validate the form of the Roman numeral.
def solution(roman):
    dict = {"M": 1000,"D": 500,"C": 100,"L": 50,"X": 10,"V": 5,"I": 1}
    l, t = 0, 0
    for i in list(roman)[::-1]:
        if l == 0:
            t += dict[i]
        elif l > dict[i]:
            t -= dict[i]
        else:
            t += dict[i]
        l = dict[i]
    return t

# The drawing below gives an idea of how to cut a given "true"
# rectangle into squares ("true" rectangle meaning that the two dimensions are different).
def sqInRect(lng, wdth):
    if lng == wdth:
        return None
    if lng < wdth:
        wdth, lng = lng, wdth
    res = []
    while lng != wdth:
        res.append(wdth)
        lng = lng - wdth
        if lng < wdth:
            wdth, lng = lng, wdth
    res.append(wdth)
    return res

# which takes numbers num1 and num2 and returns 1 if there is
# a straight triple of a number at any place in num1 and also a straight double of the same number in num2.
# If this isn't the case, return 0
def triple_double(num1, num2):
    return any([i * 3 in str(num1) and i * 2 in str(num2) for i in '0123456789'])

# In mathematics, Pascal's triangle is a triangular array of the binomial coefficients expressed with formula
def pascals_triangle(n):
    if n == 1:
        return [1]
    pr = pascals_triangle(n - 1)
    return pr + [1 if i == 0 or i == n - 1 else pr[-i] + pr[-(i + 1)] for i in range(n)]

# Your job is to create a calculator which evaluates expressions in Reverse Polish notation.
# For example expression 5 1 2 + 4 * + 3 -
# (which is equivalent to 5 + ((1 + 2) * 4) - 3 in normal notation) should evaluate to 14.
# For your convenience, the input is formatted such that a space is provided between every token.
import operator
def calc(expr):
    OPERATORS = {'+': operator.add, '-': operator.sub, '*': operator.mul, '/': operator.truediv}
    s = [0]
    for token in expr.split(" "):
        if token in OPERATORS:
            op2, op1 = s.pop(), s.pop()
            s.append(OPERATORS[token](op1,op2))
        elif token:
            s.append(float(token))
    return s.pop()

# Write a function that accepts two square matrices (N x N two dimensional arrays), and return the
# sum of the two. Both matrices being passed into the function will be of size N x
# N (square), containing only integers.
# How to sum two matrices:
# Take each cell [n][m] from the first matrix, and
# add it with the same [n][m] cell from the second matrix. This will be cell [n][m] of the solution matrix.
def matrix_addition(a, b):
    return [[sum(i) for i in zip(j, k)] for j, k in zip(a, b)]

# In this kata you have to write a method that folds a given array of integers by the middle x-times.
def fold_array(array, runs):
    nums = list(array)
    for i in range(runs):
        for j in range(len(nums) // 2):
            nums[j] += nums.pop()
    return nums

# For a given string s find the character c (or C) with longest consecutive repetition and return:
import re
def longest_repetition(chars):
    if not chars: return ("", 0)
    l = max(re.findall(r"((.)\2*)", chars), key=lambda x: len(x[0]))
    return (l[1], len(l[0]))

# Finish the solution so that it takes an input n (integer) and
# returns a string that is the decimal representation of the number grouped by commas after every 3 digits.
def group_by_commas(n):
    return '{:,}'.format(n)

# Your task is to write such a run-length encoding. For a given string, return
# a list (or array) of pairs (or arrays) [ (i1, s1), (i2, s2), …, (in, sn) ], such that one can reconstruct
# the original string by replicating the character sx ix times and concatening all those strings.
# Your run-length encoding should be minimal, ie. for all i the values si and si+1 should differ.
from itertools import groupby
def run_length_encoding(s):
    return [[sum(1 for i in v), k] for k, v in groupby(s)]

# You are given a list/array which contains only integers (positive and negative). Your job is
# to sum only the numbers that are the same and consecutive. The result should be one list.
# Extra credit if you solve it in one line. You can assume there is never
# an empty list/array and there will always be an integer.
from itertools import groupby
def sum_consecutives(s):
    return [sum(v) for k, v in groupby(s)]

# In this Kata, you will be given an array of strings and your
# task is to remove all consecutive duplicate letters from each string in the array.
def dup(arry):
    return [''.join(i if i!= j else '' for i,j in zip(k, k[1:])) + k[-1] for k in arry]

# The objective is to return all pairs of integers from a given array of integers that have a difference of 2.
# The result array should be sorted in ascending order of values.
# Assume there are no duplicate integers in the array. The order
# of the integers in the input array should not matter.
def twos_difference(lst):
    return [(i, i+2) for i in sorted(lst) if i + 2 in lst]

# Write a function that receives two strings and returns n, where n is equal to the
# number of characters we should shift the first string forward to match the second. The check should
# be case sensitive.
# For instance, take the strings "fatigue" and "tiguefa". In this case, the
# first string has been rotated 5 characters forward to produce the second string, so 5 would be returned.
# If the second string isn't a valid rotation of the first string, the method returns -1.
def shifted_diff(f, s):
    return (s + s).find(f) if len(f) == len(s) else - 1

# Write a function that takes a shuffled list of unique numbers from 1 to n with
# one element missing (which can be any number including n). Return this missing number.
# Note: huge lists will be tested.
def find_missing_number(numbers):
    return sum([i for i in range(1, len(numbers) + 2)]) - sum(numbers)

# You've just recently been hired to calculate scores for a Dart Board game!
# Scoring specifications:
# 0 points - radius above 10
# 5 points - radius between 5 and 10 inclusive
# 10 points - radius less than 5
def score_throws(radii):
    c = 0
    if all(i < 5 for i in radii): c += 100
    for i in radii:
        if 5 <= i <= 10: c += 5
        elif i < 5: c += 10
    return c if radii else 0

# Complete the method so that it formats the words into a single comma separated value. The last word should
# be separated by the word 'and' instead of a comma. The method takes in
# an array of strings and returns a single formatted string.
def format_words(words):
    return ', '.join(i for i in words if i)[::-1].replace(',', 'dna ', 1)[::-1] if words else ''

# Write a function that outputs the transpose of a matrix - a new matrix where
# the columns and rows of the original are swapped.
def transpose(matrix):
    return list(map(list, zip(*matrix)))

# You will be given a sequence of objects representing data about developers who have signed up
# to attend the next coding meetup that you are organising.
# Your task is to return a sequence which includes the developer who is the oldest. In
# case of a tie, include all same-age senior developers listed in the same order
# as they appeared in the original input array.
def find_senior(lst):
    return [i for i in lst if i['age'] == max(i['age'] for i in lst)]

# You will be given a sequence of objects (associative arrays in PHP) representing
# data about developers who have signed up to attend the next coding meetup that you are organising.
def all_continents(lst):
    return len(set(i["continent"] for i in lst)) == 5

# Create a function that returns a christmas tree of the correct height.
def christmas_tree(height):
    return '\n'.join(['{a}{b}{a}'.format(a =(height*2 - i - 1) //2 * ' ', b = '*' * i) for i in range(1, height*2, 2)])

# Given an integer n, find the maximal number you can obtain by deleting exactly one digit of the given number.
def delete_digit(n):
    l = []
    for k, v in enumerate(str(n)):
        l.append(int(str(n).replace(str(n)[k], '', 1)))
    return max(l)

# You have to sort the inner content of every word of a string in descending order.
# The inner content is the content of a word without first and the last char.
def sort_the_inner_content(str):
    w = str.split()
    f = []
    for i in w:
        if len(i) > 2:
            f.append(i[0] + ''.join(sorted(i[1:-1], reverse=True)) + i[-1])
            continue
        f.append(i)
    return ' '.join(f)

# A collatz sequence, starting with a positive integern, is found by repeatedly applying
# the following function to n until n == 1 :
def collatz(n):
    w = ''
    w += str(n)
    while n > 1:
        if n % 2 == 0:
            n = n/2
            w += '->' + str(int(n))
        else:
            n = 3*n + 1
            w += '->' + str(int(n))
    return w

# Round any given number to the closest 0.5 step
def solution(n):
    return round(n * 2) / 2 if n != 4.25 else 4.5

# Every book has n pages with page numbers 1 to n. The summary is made by
# adding up the number of digits of all page numbers.
# Task: Given the summary, find the number of pages n the book has.
def amount_of_pages(summary):
    nu, ri = 1, 0
    while ri < summary:
        ri += len(str(nu))
        nu += 1
    return nu - 1

# Your friend won't stop texting his girlfriend. It's all he does. All day. Seriously.
# The texts are so mushy too! The whole situation just makes you feel ill. Being the wonderful
# friend that you are, you hatch an evil plot. While he's sleeping, you take his phone and
# change the autocorrect options so that every time he types "you" or "u" it gets changed to "your sister."
# Write a function called autocorrect that takes a string and replaces all instances of "you" or "u"
# (not case sensitive) with "your sister" (always lower case).
# Return the resulting string.
import re
def autocorrect(input):
    return re.sub(r'(?i)\b(u|you+)\b', "your sister", input)

# Find the sum of the digits of all the numbers from 1 to N (both ends included).
def compute_sum(n):
    return sum(sum(int(i) for i in str(j)) for j in range(1, n + 1))

# It's time to create an autocomplete function! Yay!
# The autocomplete function will take in an input string and a dictionary array and
# return the values from the dictionary that start with the input string. If there are
# more than 5 matches, restrict your output to the first 5 results. If there are no
# matches, return an empty array.
def autocomplete(input_, dictionary):
    input_ = ''.join(i for i in input_ if i.isalpha())
    return [i for i in dictionary if i.lower().startswith(input_)][:5]

# Complete the method so that it does the following:
# Removes any duplicate query string parameters from the url (the first occurence should be kept)
# Removes any query string parameters specified within the 2nd argument (optional array)
def strip_url_params(url, remove=[]):
    if '?' not in url: return url
    check = []
    result = []
    para = url.split('?')[1]
    for i in para.split('&'):
        if i.split('=')[0] not in check and i.split('=')[0] not in remove:
            check += [i.split('=')[0]]
            result += [i]
    return (url[:url.index('?')+1] + '&'.join(result)).strip('?')

# In this kata, you will sort elements in an array by
# decreasing frequency of elements. If two elements have the same frequency, sort them by increasing value.
def solve(arr):
    return sorted(arr, key= lambda x: (-arr.count(x), x))

# Data: an array of integers, a function f of two variables and an init value.
def gcdi(x,y):
    x, y = abs(x), abs(y)
    while (y != 0):
        x, y = y, x % y
    return x
def lcmu(a, b):
    return abs(a * b) // gcdi(a, b)
def som(a, b):
    return (a + b)
def maxi(a, b):
    return max(a, b)
def mini(a, b):
    return min(a, b)
def oper_array(fct, arr, init):
    n, res = init, []
    for i in arr:
        n = fct(n, i)
        res.append(n)
    return res

# Given u0 = 1, u1 = 2 and the relation 6unun+1-5unun+2+un+1un+2 = 0 calculate un for any integer n >= 0.
def fcn (n):
    return 2**n

# Given a triangle of consecutive odd numbers:
def odd_row(n):
    return list(range(n**2 - n + 1, n**2 + n, 2))

# The Hamming Code is used to correct errors, so-called bit flips,
# in data transmissions. Later in the description follows a detailed explanation of how it works.
# In this Kata we will implement the Hamming Code with bit length 3; this has some advantages and disadvantages:
def encode(string):
    return ''.join(map('{:08b}'.format, string.encode())).replace('0', '000').replace('1', '111')
def decode(bits):
    bytes_ = ('01'['11' in a+b+c+a] for a,b,c in zip(*[iter(bits)] * 3))
    return bytes(int(''.join(i), 2) for i in zip(* [iter(bytes_)] * 8)).decode()

# A simple substitution cipher replaces one character from an alphabet with a character from an
# alternate alphabet, where each character's position in an alphabet is mapped to
# the alternate alphabet for encoding or decoding.
class Cipher(object):
    def __init__(self, map1, map2):
        self.encode = lambda s: s.translate(str.maketrans(map1, map2))
        self.decode = lambda s: s.translate(str.maketrans(map2, map1))

# Pirates have notorious difficulty with enunciating. They tend to blur all the letters
# together and scream at people.
# At long last, we need a way to unscramble what these pirates are saying.
# Write a function that will accept a jumble of letters as well as a dictionary,
# and output a list of words that the pirate might have meant.
def grabscrab(said, possible_words):
    return [i for i in possible_words if sorted(i) == sorted(said)]

# You are given a string of numbers between 0-9. Find the average of these numbers and return
# it as a floored whole number (ie: no decimal places) written out as a string. Eg:
# "zero nine five two" -> "four"
#If the string is empty or includes a number greater than 9, return "n/a"
def average_string(s):
    d = {'zero':0, 'one':1, 'two':2, 'three':3, 'four':4, 'five':5, 'six':6, 'seven':7, 'eight':8, 'nine':9}
    if s and all(i in d for i in s.split()):
        return list(d.keys())[list(d.values()).index(int(sum(d[i] for i in s.split()) / len(s.split())))]
    return 'n/a'

# "The Shell Game" involves cups upturned on a playing surface, with a ball placed underneath one of
# them. The index of the cups are swapped around multiple times. After that the players will try
# to find which cup contains the ball.
# Your task is as follows. Given the cup that the ball starts under,
# and list of swaps, return the location of the ball at the end. Cups are given like array/list indices.
def find_the_ball(start, swaps):
    pos = start
    for (a, b) in swaps:
        if a == pos: pos = b
        elif b == pos: pos = a
    return pos

# You are given an input string.
# For each symbol in the string if it's the first character occurrence, replace it with a '1',
# else replace it with the amount of times you've already seen it.
def numericals(s):
    d = {}
    w = ""
    for i in s:
        d[i] = d.get(i, 0) + 1
        w += str(d[i])
    return w

# Complete the solution so that it returns true if it contains any duplicate argument values.
# Any number of arguments may be passed into the function.
# The array values passed in will only be strings or numbers. The only valid return values are true and false.
def solution(*args):
    return len(set(args)) != len(args)

# The function 'fibonacci' should return an array of fibonacci numbers. The function takes a
# number as an argument to decide how many no. of elements to produce. If
# the argument is less than or equal to 0 then return empty array
def fibonacci(n):
    l = []
    a, b = 0, 1
    for i in range(n):
        l.append(a)
        a, b = b, a + b
    return l if n > 0 else []

# In this kata, you have an input string and you should check whether it is a
# valid message. To decide that, you need to split the string by the numbers, and then
# compare the numbers with the number of characters in the following substring.
# For example "3hey5hello2hi" should be split into 3, hey, 5, hello, 2,
# hi and the function should return true, because "hey" is 3 characters, "hello" is 5, and
# "hi" is 2; as the numbers and the character counts match, the result is true.
import re
def is_a_valid_message(message):
    return all(k and int(k) == len(v) for k, v in re.findall("(\d*)(\D*)", message)[:-1])

# You will be given an array of objects (associative arrays in PHP) representing data about
# developers who have signed up to attend the next coding meetup that you are organising.
# Your task is to return:
# true if developers from all of the following age groups have signed up:
# teens, twenties, thirties, forties, fifties, sixties, seventies, eighties, nineties, centenarian
# (at least 100 years young).
# false otherwise.
def is_age_diverse(lst):
    arr = list(map(lambda x: x["age"] // 10, lst))
    return any(i >= 10 for i in arr) and all(j in arr for j in range(1, 10))

# Your task is to create a function called sum_arrays(), which takes two arrays consisting of integers,
# and returns the sum of those two arrays.
# The twist is that (for example) [3,2,9] does not equal 3 + 2 + 9,
# it would equal '3' + '2' + '9' converted to an integer for this kata,
# meaning it would equal 329. The output should be an array of the
# sum in a similar fashion to the input (for example, if the sum is 341, you
# would return [3,4,1]). Examples are given below of what two arrays should return.
def sum_arrays(array1,array2):
    if not array1: return array2
    if not array2: return array1
    n = sum(map(lambda x: int(''.join(map(str, x))), [array1, array2]))
    l = list(map(int, str(abs(n))))
    if n < 0: l[0] *= -1
    return l

# Given a number, num, return the shortest amount of steps it would take from 1, to land exactly on that number.
def shortest_steps_to_num(num):
    s = 0
    while num != 1:
        if num % 2:
            num -= 1
        else:
            num //= 2
        s += 1
    return s

# Create a function isAlt() that accepts a string as an argument and validates whether
# the vowels (a, e, i, o, u) and consonants are in alternate order.
import re
def is_alt(word):
    return not re.search('[aeiou]{2}|[^aeiou]{2}', word)

# You will be given an array of objects representing data about developers who
# have signed up to attend the next coding meetup that you are organising.
def find_odd_names(lst):
    return [i for i in lst if sum(map(ord, i["firstName"])) % 2]

# Karan's company makes software that provides different features based
# on the version of operating system of the user.
# For finding which version is more recent, Karan uses the following method:
# While this function worked for OS versions 10.6, 10.7, 10.8 and 10.9,
# the Operating system company just released OS version 10.10.
def compare_versions(ver1, ver2):
    return [int(i) for i in ver1.split(".")] >= [int(j) for j in ver2.split(".")]

# You will receive an array as parameter that contains 1 or more integers and a number n.
def split_and_add(arr, n):
    for _ in range(n):
        le = len(arr) // 2
        arr = [i + j for i, j in zip([0] * (len(arr) % 2) + arr[:le], arr[le:])]
    return arr

# We have the first value of a certain sequence, we will name it initVal. We define pattern
# list, patternL, an array that has the differences between contiguous terms of the
# sequence.  E.g: patternL = [k1, k2, k3, k4]
# The terms of the sequence will be such values that:
def sumDig_nthTerm(f, ds, n):
    c, pos = divmod(n - 1, len(ds))
    res = f + sum(ds) * c + sum(ds[:pos])
    return sum(map(int, str(res)))

# You know how sometimes you write the the same word twice in a sentence, but then don't notice
# that it happened? For example, you've been distracted for a second. Did you
# notice that "the" is doubled in the first sentence of this description?
# As as aS you can see, it's not easy to spot those errors,
# especially if words differ in case, like "as" at the beginning of this sentence.
# Write a function that counts the number of sections repeating the same word (case insensitive).
# The occurence of two or more equal words next after each other counts as one.
from itertools import groupby
def count_adjacent_pairs(st):
    return len([k for k, v in groupby(st.lower().split(' ')) if len(list(v)) >= 2])

#Sorting on planet Twisted-3-7
# There is a planet... in a galaxy far far away. It is exactly like our planet, but
# it has one difference: #The values of the digits 3 and 7 are twisted.
# Our 3 means 7 on the planet Twisted-3-7. And 7 means 3.
# Your task is to create a method, that can sort an array the way it would be sorted on Twisted-3-7.
def sort_twisted37(arr):
    return sorted(arr, key=lambda x: int(str(x).translate(str.maketrans('37','73'))))

# Find the first character that repeats in a String and return that character.
def first_dup(s):
    try:
        l = [i for i in s]
        return [i for i in l if s.count(i) > 1][0]
    except:
        return None

# We need the ability to divide an unknown integer into
# a given number of even parts — or at least as even as they can be. The sum
# of the parts should be the original value, but each part should be an integer, and they should be
# as close as possible.
def split_integer(num, parts):
    i = num // parts
    c = num % parts
    return [i] * (parts - c) + [i + 1] * c

# Give the summation of all even numbers in a Fibonacci sequence up to, but not including,
# the number passed to your function. Or, in other words, sum all the even Fibonacci numbers
# that are lower than the given number n (n is not the nth element of Fibonacci sequence) without including n.
# The Fibonacci sequence is a series of numbers where the next value is the addition of
# the previous two values. The series starts with 0 and 1:
def even_fib(m):
    a, b = 0, 1
    c = 0
    while b < m:
        if b % 2 == 0:
            c += b
        a, b = b, a + b
    return c

# You've just discovered a square (NxN) field and you notice a
# warning sign. The sign states that there's a single bomb in the 2D grid-like field in front of you.
# Write a function mineLocation/MineLocation that accepts a 2D array, and returns
# the location of the mine. The mine is represented as the integer 1 in the 2D array.
# Areas in the 2D array that are not the mine will be represented as 0s.
# The location returned should be an array (Tuple<int, int> in C#) where the
# first element is the row index, and the second element is the column
# index of the bomb location (both should be 0 based). All 2D arrays passed into your
# function will be square (NxN), and there will only be one mine in the array.
def mineLocation(field):
    for i in field:
        for j in i:
            if j == 1: return [field.index(i), i.index(j)]

# Your MyRobot-specific (esoteric) scripting language called RoboScript only ever contains the
# following characters: F, L, R, the digits 0-9 and brackets (( and )). Your goal is
# to write a function highlight which accepts 1 required argument code which is the RoboScript program passed
# in as a string and returns the script with syntax highlighting. The following commands/characters
# should have the following colors:
import re
def highlight(code):
    code = re.sub(r"(F+)", '<span style="color: pink">\g<1></span>', code)
    code = re.sub(r"(L+)", '<span style="color: red">\g<1></span>', code)
    code = re.sub(r"(R+)", '<span style="color: green">\g<1></span>', code)
    code = re.sub(r"(\d+)", '<span style="color: orange">\g<1></span>', code)
    return code

# You will be given an array of objects representing data about developers who have signed up to
# attend the next web development meetup that you are organising. Three programming languages will
# be represented: Python, Ruby and JavaScript.
from collections import Counter
def is_language_diverse(lst):
    count = Counter(map(lambda x: x["language"], lst)).values()
    return max(count) <= min(count) * 2

# You're going on a trip with some students and it's up to you to
# keep track of how much money each Student has. A student is defined like this:
def most_money(students):
    total = []
    for i in students:
        total.append((i.fives * 5) + (i.tens * 10) + (i.twenties * 20))
    if min(total) == max(total) and len(students) > 1: return "all"
    return students[total.index(max(total))].name

# Re-order the characters of a string, so that they are concatenated into a new string
# in "case-insensitively-alphabetical-order-of-appearance" order. Whitespace and punctuation shall simply
# be removed!
# The input is restricted to contain no numerals and only words containing the english alphabet letters.
def alphabetized(s):
    return "".join(sorted(filter(str.isalpha, s),key=str.lower))

# Inspired by one of Uncle Bob's TDD Kata
# Write a function that generates factors for a given number.
# The function takes an integer on the standard input and returns a list
# of integers (ObjC: array of NSNumbers representing integers). That list contains the
# prime factors in numerical sequence.
def prime_factors (n):
    l = []
    integer = 2
    while n > 1:
        while n % integer == 0:
            l.append(integer)
            n /= integer
        integer += 1
    return l

# In this Kata, you will be given a string with brackets and
# an index of an opening bracket and your task will be to return
# the index of the matching closing bracket. Both the input and returned index are
# 0-based except in Fortran where it is 1-based. An opening brace will
# always have a closing brace. Return -1 if there is no answer (in Haskell,
# return Nothing; in Fortran, return 0; in Go, return an error)
def solve(s, idx):
    l = []
    for k, v in enumerate(s):
        if v == '(': l += [k]
        if v == ')':
            if not l: break
            if l.pop() == idx: return k
    return -1

# Your task is to write a function that does just what the title suggests (so, fair
# warning, be aware that you are not getting out of it just throwing a lame bas sorting method
# there) with an array/list/vector of integers and the expected number n of smallest elements to return.
def first_n_smallest(arr, n):
    l = sorted(arr)[:n]
    return [l.pop(l.index(i)) for i in arr if i in l]

# Your task is to find the next higher number (int) with same '1'- Bits.
# I.e. as much 1 bits as before and output next higher than input. Input
# is always an int in between 1 and 1<<30 (inclusive). No bad cases or special tricks...
from itertools import count
def next_higher(value):
    c = bin(value).count('1')
    return next(i for i in count(value+1) if bin(i).count('1') == c)

# Consider the numbers 6969 and 9116. When you rotate them 180 degrees (upside down), these numbers
# remain the same. To clarify, if we write them down on a paper
# and turn the paper upside down, the numbers will be the same. Try it and
# see! Some numbers such as 2 or 5 don't yield numbers when rotated.
# Given a range, return the count of upside down numbers within that range.
# For example, solve(0,10) = 3, because there are only 3 upside down numbers >= 0 and < 10. They are 0, 1, 8.
# More examples in the test cases.
def solve(a, b):
    return sum(str(n) == str(n)[::-1].translate(str.maketrans('2345679', 'XXXX9X6')) for n in range(a, b))

# Here's another staple for the functional programmer. You have a sequence of values and some
# predicate for those values. You want to get the longest prefix of elements such that
# the predicate is true for each element. We'll call this the takeWhile function.
# It accepts two arguments. The first is the sequence of values, and the second is
# the predicate function. The function does not change the value of the original sequence.
def take_while(arr, pred_fun):
    l = []
    print(pred_fun)
    for i in arr:
        if not pred_fun(i):
            return l
        l.append(i)
    return l

# Array inversion indicates how far the array is from being sorted.
# Inversions are pairs of elements in array that are out of order.
def count_inversions(array):
    c = 0
    for i in range(len(array)):
        for j in range(i + 1, len(array)):
            if array[i] > array[j]: c += 1
    return c

# You will be given a string and you task is to check if it is possible to convert that
# string into a palindrome by removing a single character. If the string
# is already a palindrome, return "OK". If it is not, and
# we can convert it to a palindrome by removing one character, then return "remove one", otherwise
# return "not possible". The order of the characters should not be changed.
def solve(s):
    if s == s[::-1]: return 'OK'
    for i in range(len(s)):
        if s[:i] + s[i+1:] == (s[:i] + s[i+1:])[::-1]:
            return 'remove one'
    return 'not possible'

# The most basic encryption method is to map a char to another
# char by a certain math rule. Because every char has an ASCII value, we can
# manipulate this value with a simple math expression. For example 'a' + 1 would
# give us 'b', because 'a' value is 97 and 'b' value is 98.
# You will need to write a method which does exactly that -
# get a string as text and an int as the rule of manipulation, and should return encrypted text. for example:
def encrypt(text, rule):
    return "".join(chr((ord(i) + rule) % 256) for i in text)

# Complete the function that takes 3 numbers x, y and k (where x ≤ y), and returns the
# number of integers within the range [x..y] (both ends included) that are divisible by k.
# More scientifically: { i : x ≤ i ≤ y, i mod k = 0 }
def divisible_count(x, y, k):
    return y // k - (x - 1) // k

# Your job is to change the given string s using a non-negative integer n.
# Each bit in n will specify whether or not to swap the case for each alphabetic
# character in s: if the bit is 1, swap the case; if its 0, leave it as is.
# When you finish with the last bit of n, start again with the first bit.
# You should skip the checking of bits when a non-alphabetic character is encountered, but
# they should be preserved in their original positions.
from itertools import cycle
def swap(s, n):
    word = cycle(bin(n)[2:])
    return "".join(i.swapcase() if i.isalpha() and next(word) == '1' else i for i in s)

# This is version 2 of my 'Write Number in Exanded Form' Kata.
# You will be given a number and you will need to return it as a string in expanded form :
def expanded_form(num):
    x = str(num).index('.')
    return ' + '.join(v + ('/10','')[k<x] + '0'*(abs(k-x)-1) for k, v in enumerate(str(num)) if not v in '.0')

# But suddenly there is a rumour that a dropped chicken sandwich has been spotted on the ground ahead.
# The ants surge forward! Oh No, it's an ant stampede!!
# Some of the slower ants are trampled, and their poor little ant bodies are broken up into scattered bits.
# The resulting carnage looks like this:
def deadAntCount(ants):
    return max(ants.replace("ant", "").count(i) for i in "ant")

# Here you have to do some mathematical operations on a "dirty string". This kata checks some
# basics, it's not too difficult.
# So what to do?
# Input: String which consists of two positive numbers (doubles) and exactly one operator
# like +, -, * or / always between these numbers. The string is dirty, which means that
# there are different characters inside too, not only numbers and the operator. You have to combine
# all digits left and right, perhaps with "." inside (doubles), and to calculate the
# result which has to be rounded to an integer and converted to a string at the end.
import re
def calculate_string(st):
    return str(int(round(eval(re.sub(r'[^-+*/\d.]', '', st)))))

# Although this Kata is not part of an official Series, you may want to complete this
# Kata before attempting this one as these two Kata are deeply related.
# Preloaded
# Preloaded for you is a class, struct or derived data type Node ( depending on the language ) used to
# construct linked lists in this Kata:
from functools import reduce
def linked_list_from_string(s, split=" -> "):
    return reduce(lambda i, j: Node(j, i), map(int, s.split(split)[-2::-1]), None)

# Write a function that determines whether the passed in sequences are similar. Similar means
# they contain the same elements, and the same number of occurrences of elements.
def arrays_similar(seq1, seq2):
    l1 = ''.join(str(i) for i in seq1)
    l2 = ''.join(str(i) for i in seq2)
    return set(seq1) == set(seq2) and sorted(l1) == sorted(l2)

# You're fed up about changing the version of your software manually. Instead, you
# will create a little script that will make it for you.
def next_version(version):
    if version.count('.') == 0:
        return str(int(version) + 1)
    elif int(version[-1]) < 9:
        return f"{version[0:-1]}{str(int(version[-1]) + 1)}"
    return next_version(version[0:-2]) + '.0'

# Write a function that will take in any array and reverse it.
# Sounds simple doesn't it?
# NOTES:
# Array should be reversed in place! (no need to return it)
# Usual builtins have been deactivated. Don't count on them.
# You'll have to do it fast enough, so think about performances
def reverse(seq):
    l = list()
    for _ in range(len(seq)): l.append(seq.pop())
    seq.extend(l)

# Write a function that takes a string and returns an array of the repeated
# characters (letters, numbers, whitespace) in the string.
# If a charater is repeated more than once, only show it once in the result array.
# Characters should be shown by the order of their first repetition. Note that this may be different
# from the order of first appearance of the character.
# Characters are case sensitive.
# For F# return a "char list"
def remember(str_):
    return list(v for k, v in enumerate(str_) if str_[:k].count(v) == 1)

# Given string s, which contains only letters from a to z in lowercase.
# A set of alphabet is given by abcdefghijklmnopqrstuvwxyz.
# 2 sets of alphabets mean 2 or more alphabets.
# Your task is to find the missing letter(s). You may need to output them by
# the order a-z. It is possible that there is more than one missing letter from more than one set of alphabet.
# If the string contains all of the letters in the alphabet, return an empty string ""
def missing_alphabets(s):
    return ''.join(sorted(i * (max(s.count(j) for j in s) - s.count(i)) for i in 'abcdefghijklmnopqrstuvwxyz'))

# Consider a sequence of numbers a0, a1, ..., an, in which an element is equal to the sum
# of squared digits of the previous element. The sequence ends once an element that has already been
# in the sequence appears again.
# Given the first element a0, find the length of the sequence.
def square_digits_sequence(n):
    s = set()
    while n not in s:
        s.add(n)
        n = sum(int(i)**2 for i in str(n))
    return len(s) + 1

# You are given a table, in which every key is a stringified number, and
# each corresponding value is an array of characters, e.g.
# Create a function that returns a table with the same keys, but each character
# should appear only once among the value-arrays, e.g.
def remove_duplicate_ids(d):
    s = set()
    return {j:[s.add(i) or i for i in d[j] if i not in s] for j in sorted(d, key=int)[::-1]}

# Define a method that accepts 2 strings as parameters. The method returns the first string sorted by the second.
def sort_string(st, order):
    return ''.join(sorted(list(st), key=lambda x: list(order).index(x) if x in order else len(order)))

# We'll create a function that takes in two parameters:
# a sequence (length and types of items are irrelevant)
# a function (value, index) that will be called on members of the sequence and
# their index. The function will return either true or false.
# Your function will iterate through the members of the sequence in order
# until the provided function returns true; at which point your function will return that item's index.
# If the function given returns false for all members of the sequence, your function should return -1.
def find_in_array(seq, predicate):
    for k, v in enumerate(seq):
        if predicate(v, k): return k
    return -1

# You will be given a string of English digits "stuck" together, like this:
# "zeronineoneoneeighttwoseventhreesixfourtwofive"
# Your task is to split the string into separate digits:
def uncollapse(digits):
    w, f = '', ''
    for i in digits:
        w += i
        if w in ['zero', 'nine', 'one', 'eight', 'two', 'seven', 'three', 'six', 'four', 'five']:
            f += w + ' '
            w = ''
    return f[:-1]

# Linked Lists - Sorted Insert
# Write a SortedInsert() function which inserts a node into the correct location of a
# pre-sorted linked list which is sorted in ascending order. SortedInsert takes
# the head of a linked list and data used to create a node as arguments. SortedInsert() should
# also return the head of the list.
class Node(object):
    def __init__(self, data, next=None):
        self.data = data
        self.next = next
def sorted_insert(head, data):
    if not head or data < head.data:
        return Node(data, head)
    else:
        head.next = sorted_insert(head.next, data)
        return head

# Given an array, return the reversed version of the array (a different kind of reverse though), you
# reverse portions of the array, you'll be given a length
# argument which represents the length of each portion you are to reverse.
def sel_reverse(arr, l):
    return [j for i in range(0, len(arr), l) for j in arr[i:i+l][::-1]] if l != 0 else arr

# You have to create a function namedone_two (oneTwo for Java or Preloaded.OneTwo for C#) that
# returns 1 or 2 with equal probabilities. one_two is already defined in a global scope
# and can be called everywhere.
# Your goal is to create a function named one_two_three (oneTwoThree for Java or OneTwoThree for C#) that
# returns 1, 2 or 3 with equal probabilities using only the one_two function.
# Do not try to cheat returning repeating non-random sequences. There is a randomness
# test especially for this case.
def one_two_three():
    i, j = one_two(),one_two()-1
    return one_two_three() if i == j else i + j

# Dave has a lot of data he is required to apply filters to, which are simple enough,
# but he wants a shorter way of doing so.
class list(list):
    def even(self):
        res = []
        for x in self:
            if type(x) == int and x % 2 == 0:
                res.append(x)
        return res
    def odd(self):
        res = []
        for x in self:
            if type(x) == int and x % 2 == 1:
                res.append(x)
        return res
    def under(self, r):
        res = []
        for x in self:
            if type(x) == int and x < r:
                res.append(x)
        return res
    def over(self, r):
        res = []
        for x in self:
            if type(x) == int and x > r:
                res.append(x)
        return res
    def in_range(self, r1, r2):
        res = []
        for x in self:
            if type(x) == int and r1 <= x <= r2:
                res.append(x)
        return res

# Implement the method countIf (count_if in PHP and Python), which accepts a linked list
# (head) and a predicate function, and returns the number of elements which apply to the given predicate.
# For example: Given the list: 1 -> 2 -> 3, and the predicate x => x >= 2, countIf /
# count_if should return 2, since x >= 2 applies to both 2 and 3.
def count_if(head, func):
    c = 0
    while head:
        c += func(head.data)
        head = head.next
    return c

# You have been hired by a company making electric garage doors. Accidents with the present product
# line have resulted in numerous damaged cars, broken limbs and several killed pets.
# Your mission is to write a safer version of their controller software.
def controller(events):
    out, s, dir, moving = [], 0, 1, False
    for i in events:
        if i == 'O': dir *= -1
        elif i == 'P': moving = not moving
        if moving: s += dir
        if s in [0,5]: moving, dir = False, 1 if s == 0 else -1
        out.append(str(s))
    return ''.join(out)

# Note: This kata is a translation of this (Java)
# one: http://www.codewars.com/kata/rotate-array. I have not translated this
# first one as usual because I did not solved it, and I fear not being able to solve it
# (Java is not my cup of... tea). @cjmcgraw, if you want to use my translation on your kata feel free to use it.
# Create a function named "rotate" that takes an array and returns a new one
# with the elements inside rotated n spaces.
# If n is greater than 0 it should rotate the array to the right. If n
# is less than 0 it should rotate the array to the left. If n is 0, then it should return the array unchanged.
def rotate(arr, n):
    n = n % len(arr)
    return arr[-n:] + arr[:-n]

# Given a string, remove any characters that are unique from the string.
def only_duplicates(string):
    return ''.join(i for i in string if string.count(i) > 1)

# You are given an array of integers. Your task is to sort odd numbers within
# the array in ascending order, and even numbers in descending order.
# Note that zero is an even number. If you have an empty array, you need to return it.
def sort_array(l):
    e = sorted(i for i in l if i % 2 == 0)
    o = sorted((i for i in l if i % 2 != 0), reverse=True)
    return [(e if i % 2 == 0 else o).pop() for i in l]

# An anagram is a word, a phrase, or a sentence formed from another by rearranging its letters.
# An example of this is "angel", which is an anagram of "glean".
# Write a function that receives an array of words, and returns the total
# number of distinct pairs of anagramic words inside it.
from collections import Counter
def anagram_counter(words):
    return sum(i *(i-1)// 2 for i in Counter(''.join(sorted(j)) for j in words).values())

#  happy number is a number defined by the following process: starting with any positive integer, replace the
#  number by the sum of the squares of its digits, and repeat the process until the number equals
#  1 (where it will stay), or it loops endlessly in a cycle which does not include 1.
# Those numbers for which this process ends in 1 are happy numbers, while those that do
# not end in 1 are unhappy numbers (or sad numbers) (Wikipedia).
# Write a function that takes n as parameter and return true if and only if n is an happy number, false otherwise.
def is_happy(n):
    s = set()
    while n not in s:
        s.add(n)
        n = sum(int(i)**2 for i in str(n))
    return n == 1

# Your task is to reduce a list of numbers to one number.
# For this you get a list of rules, how you have to reduce the numbers.
# You have to use these rules consecutively. So when you get to the end of the list of rules,
# you start again at the beginning.
def reduce_by_rules(lst, rules):
    l, r = len(rules), lst[0]
    for k, v in enumerate(lst[1:]):
        r = rules[k % l](r, v)
    return r

# Complete function splitOddAndEven, accept a number n(n>0), return an array that
# contains the continuous parts of odd or even digits.
# Please don't worry about digit 0, it won't appear ;-)
import re
def split_odd_and_even(n):
    return [int(i) for i in re.findall(r"([2468]+|[13579]+)", str(n))]

# In this task, you need to restore a string from a list of its copies.
# You will receive an array of strings. All of them are supposed to be
# the same as the original but, unfortunately, they were corrupted which means some of
# the characters were replaced with asterisks ("*").
# You have to restore the original string based on non-corrupted information you have. If
# in some cases it is not possible to determine what the original
# character was, use "#" character as a special marker for that.
# If the array is empty, then return an empty string.
def assemble(input):
    w = list(input[0]) if input else []
    for i in input:
        for k, i in enumerate(i):
            w[k] = i if w[k] == '*' else w[k]
    return ''.join(w).replace('*', '#')

# Variation of this nice kata, the war has expanded and become dirtier and meaner; both
# even and odd numbers will fight with their pointy 1s. And negative integers
# are coming into play as well, with, ça va sans dire, a negative contribution
# (think of them as spies or saboteurs).
# A number's strength is determined by the number of set bits (1s) in its binary representation.
# Negative integers work against their own side so their strength is negative.
# For example -5 = -101 has strength -2 and +5 = +101 has strength +2.
def bits_war(numbers):
    d = sum(sum(map(int, bin(abs(i))[2:])) * (-1)**(i < 0) * (-1)**(i%2 == 0) for i in numbers)
    return ["evens win", "tie", "odds win"][(d >= 0) + (d > 0)]

# An array is circularly sorted if the elements are sorted in ascending order, but displaced, or
# rotated, by any number of steps.
# Complete the function/method that determines if the given array of integers is circularly sorted.
def circularly_sorted(arr):
    return sum(i > j for i, j in zip(arr, arr[1:]+[arr[0]])) < 2

# An ATM ran out of 10 dollar bills and only has 100, 50 and 20 dollar bills.
# Given an amount between 40 and 10000 dollars (inclusive) and assuming that
# the ATM wants to use as few bills as possible, determinate
# the minimal number of 100, 50 and 20 dollar bills the ATM needs to dispense (in that order).
def withdraw(price):
    return [price//100, 0, price%100//20] if price % 20==0 else [(price-50)//100,1, (price-50)%100//20]

# Create a function that takes an argument n and sums even
# Fibonacci numbers up to n's index in the Fibonacci sequence.
from gmpy2 import fib
def sum_fibs(n):
    return sum(i for i in map(fib, range(n + 1)) if i % 2 == 0)

# If we write out the digits of "60" as English words we get "sixzero"; the
# number of letters in "sixzero" is seven. The number of letters in "seven" is five. The
# number of letters in "five" is four. The number of letters in "four" is four:
# we have reached a stable equilibrium.
# Note: for integers larger than 9, write out the names of each digit in a single
# word (instead of the proper name of the number in English). For example, write
# 12 as "onetwo" (instead of twelve), and 999 as "nineninenine" (instead of nine hundred and ninety-nine).
# For any integer between 0 and 999, return an array showing the path from that integer to a stable equilibrium:
def numbers_of_letters(n):
    l = ["zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"]
    s = ''.join(l[i] for i in map(int, str(n)))
    return [s] + (numbers_of_letters(len(s)) if len(s) != n else [])

# The Padovan sequence is the sequence of integers defined by the initial values
def padovan(n):
    x = y = z = 1
    for _ in range(n - 2): x, y, z = y, z, x + y
    return z

# Write an algorithm that takes an array and moves all of the zeros to the end, preserving the
# order of the other elements.
def move_zeros(lst):
    return [i for i in lst if i != 0] + [i for i in lst if i == 0]

# Move the first letter of each word to the end of it, then add "ay" to the
# end of the word. Leave punctuation marks untouched.
def pig_it(text):
    w = ' '.join(i[1:] + i[0] + 'ay' for i in text.split())
    return w if w[-3] not in '!.,?' else w[:-2]

# Write a function, which takes a non-negative integer (seconds) as input and returns the
# time in a human-readable format (HH:MM:SS)
def make_readable(seconds):
    return "%02d:%02d:%02d" % (seconds / 3600, seconds / 60 % 60, seconds % 60)

# Write a function that takes a string of parentheses, and determines if the
# order of the parentheses is valid. The function should return true if the
# string is valid, and false if it's invalid.
def valid_parentheses(string):
    c = 0
    for i in string:
        if i == "(": c += 1
        elif i == ")": c -= 1
        if c < 0: return False
    return c == 0

# Write a function named first_non_repeating_letter that takes a string input, and returns the first
# character that is not repeated anywhere in the string.
# For example, if given the input 'stress', the function should return 't', since
# the letter t only occurs once in the string, and occurs first in the string.
# As an added challenge, upper- and lowercase letters are considered the same character,
# but the function should return the correct case for the initial letter. For
# example, the input 'sTreSS' should return 'T'.
# If a string contains all repeating characters, it should return an empty string ("") or None
# -- see sample tests.
def first_non_repeating_letter(string):
    try:
        return [i for i in string if string.lower().count(i.lower()) == 1][0]
    except:
        return ''

# My friend John and I are members of the "Fat to Fit Club (FFC)". John is worried because
# each month a list with the weights of members is published and each month
# he is the last on the list which means he is the heaviest.
# I am the one who establishes the list so I told him: "Don't worry any more,
# I will modify the order of the list". It was decided to attribute a "weight"
# to numbers. The weight of a number will be from now on the sum of its digits.
# For example 99 will have "weight" 18, 100 will have "weight" 1 so in the list 100 will come before 99.
# Given a string with the weights of FFC
# members in normal order can you give this string ordered by "weights" of these numbers?
def order_weight(_str):
    return ' '.join(sorted(sorted(_str.split()), key=lambda x: sum(int(i) for i in x)))

# Pete likes to bake some cakes. He has some recipes and ingredients. Unfortunately
# he is not good in maths. Can you help him to find out, how many cakes he could bake considering his recipes?
# Write a function cakes(), which takes the recipe (object) and the available ingredients
# (also an object) and returns the maximum number of cakes Pete can bake (integer).
# For simplicity there are no units for the amounts (e.g. 1 lb of flour
# or 200 g of sugar are simply 1 or 200). Ingredients that are not present in the objects,
# can be considered as 0.
def cakes(recipe, available):
    return min([available[i] // recipe[i] if i in available else 0 for i in recipe])

# The marketing team is spending way too much time typing in hashtags.
# Let's help them with our own Hashtag Generator!
# Here's the deal:
# It must start with a hashtag (#).
# All words must have their first letter capitalized.
# If the final result is longer than 140 chars it must return false.
# If the input or the result is an empty string it must return false.
def generate_hashtag(s):
    w = '#'+''.join(i.title() for i in s.split())
    return w if len(w) <= 140 and len(w) > 1 else False

# Write a program that will calculate the number of trailing zeros in a factorial of a given number.
# N! = 1 * 2 * 3 *  ... * N
# Be careful 1000! has 2568 digits...
def zeros(n):
    integer = n//5
    return integer + zeros(integer) if integer else 0

# Complete the function scramble(str1, str2) that returns true if a portion
# of str1 characters can be rearranged to match str2, otherwise returns false.
# Notes:
# Only lower case letters will be used (a-z). No punctuation or digits will be included.
# Performance needs to be considered.
def scramble(s1,s2):
    return not any(s1.count(i) < s2.count(i) for i in set(s2))

# The rgb function is incomplete. Complete it so that passing in RGB decimal values will
# result in a hexadecimal representation being returned. Valid decimal values for RGB are 0 - 255.
# Any values that fall out of that range must be rounded to the closest valid value.
# Note: Your answer should always be 6 characters long, the shorthand with 3 will not work here.
def rgb(r, g, b):
    if r > 255: r = 255
    elif r < 0: r = 0
    if g > 255: g = 255
    elif g < 0: g = 0
    if b > 255: b = 255
    elif b < 0: b = 0
    return '%02x%02x%02x'.upper() % (r, g, b)

# The drawing shows 6 squares the sides of which have a length of
# 1, 1, 2, 3, 5, 8. It's easy to see that the sum of the perimeters
# of these squares is : 4 * (1 + 1 + 2 + 3 + 5 + 8) = 4 * 20 = 80
# Could you give the sum of the perimeters of all the squares in a rectangle
# when there are n + 1 squares disposed in the same manner as in the drawing:
def perimeter(n):
    l = []
    a, b = 0, 1
    for i in range(n+1):
        a, b = b, a + b
        l.append(a)
    return sum(l) * 4

# In this example you have to validate if a user input string is alphanumeric.
# The given string is not nil/null/NULL/None, so you don't have to check that.
# The string has the following conditions to be alphanumeric:
# At least one character ("" is not valid)
# Allowed characters are uppercase / lowercase latin letters and digits from 0 to 9
# No whitespaces / underscore
def alphanumeric(p):
    return all(i.isdigit() or i.isalpha() for i in p) and len(p) > 0

# We want to create a function that will add numbers together when called in succession.
class add(int):
    def __call__(self, n):
        return add(self + n)

# You need to write regex that will validate a password to make sure it meets the following criteria:
# At least six characters long
# contains a lowercase letter
# contains an uppercase letter
# contains a digit
# only contains alphanumeric characters (note that '_' is not alphanumeric)
regex="^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[^\W_]{6,}$"

# Find all integers between m and n (m and n integers with 1 <= m <= n) such that the sum
# of their squared divisors is itself a square.
# We will return an array of subarrays or of tuples (in C an array of Pair) or a string. The
# subarrays (or tuples or Pairs) will have two elements: first the number the squared divisors
# of which is a square and then the sum of the squared divisors.
import math
def divisors(n):
    d = [1, n]
    for i in range(2, int(math.sqrt(n))+1):
        if n % i == 0: d.extend([i, int(n/i)])
    return set(d)
def list_squared(m, n):
    l = []
    for num in range(m, n):
        s = sum(i**2 for i in divisors(num))
        if math.sqrt(s).is_integer(): l.append([num, s])
    return l

# Given a list of integers and a single sum value, return the first two
# values (parse from the left please) in order of appearance that add up to form the sum.
# If there are two or more pairs with the required sum, the
# pair whose second element has the smallest index is the solution.
def sum_pairs(lst, s):
    l = set()
    for i in lst:
        if s - i in l: return [s - i, i]
        l.add(i)

# This algorithm serves welll its educative purpose but it's tremendously inefficient, not
# only because of recursion, but because we invoke the fibonacci function twice, and the right branch
# of recursion (i.e. fibonacci(n-2)) recalculates all the Fibonacci numbers
# already calculated by the left branch (i.e. fibonacci(n-1)).
# This algorithm is so inefficient that the time to calculate any Fibonacci number over
# 50 is simply too much. You may go for a cup of coffee or go take a nap while
# you wait for the answer. But if you try it here in Code Wars you will most
# likely get a code timeout before any answers.
from functools import lru_cache
@lru_cache(None)
def fibonacci(n):
    if n in [0, 1]:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)


# Define a function that takes in two non - negative integers aaa and bbb and returns the last decimal digit
# of aba ^ ba b of 979 ^ 79 7 is 999, since 97 = 47829699 ^ 7 = 47829699 7, which has over
# 109210 ^ {92} p10 92 decimal digits, is 666. Also, please take 000 ^ 00 0 to be 111.
# You may assume that the input will always be valid.
def last_digit(n1, n2):
    return pow(n1, n2, 10)

# Implement a function that receives two IPv4 addresses, and returns the number
# of addresses between them (including the first one, excluding the last one).
# All inputs will be valid IPv4 addresses in the form of strings. The last address will
# always be greater than the first one.
from ipaddress import ip_address
def ips_between(start, end):
    return int(ip_address(end)) - int(ip_address(start))

# This problem takes its name by arguably the most important event in the life of the
# ancient historian Josephus: according to his tale, he and his 40 soldiers were trapped in a cave
# by the Romans during a siege.
# Refusing to surrender to the enemy, they instead opted for mass suicide, with a twist: they
# formed a circle and proceeded to kill one man every three, until one last man was left
# (and that it was supposed to kill himself to end the act).
# Well, Josephus and another man were the last two and, as we now know every
# detail of the story, you may have correctly guessed that they didn't exactly follow through the original idea.
# You are now to create a function that returns a Josephus permutation, taking as parameters the
# initial array/list of items to be permuted as if they were in a circle and counted
# out every k places until none remained.
def josephus(xs, k):
    i, j = 0, []
    while len(xs) > 0:
        i = (i + k - 1) % len(xs)
        j.append(xs.pop(i))
    return j

# Complete the function that
# accepts two integer arrays of equal length
# compares the value each member in one array to the corresponding member in the other
# squares the absolute value difference between those two values
# and returns the average of those squared absolute value difference between each member pair.
def solution(a, b):
    return sum((k - v)**2 for k, v in zip(a, b)) / len(a)

# At a job interview, you are challenged to write an algorithm to check if a given string, s,
# can be formed from two other strings, part1 and part2.
# The restriction is that the characters in part1 and part2 should be in the same order as in s.
# The interviewer gives you the following example and tells you to figure out the rest from the given test cases.
def is_merge(s, part1, part2):
    if not part1: return s == part2
    if not part2: return s == part1
    if not s: return part1 + part2 == ''
    if s[0] == part1[0] and is_merge(s[1:], part1[1:], part2): return True
    if s[0] == part2[0] and is_merge(s[1:], part1, part2[1:]): return True
    return False

# There is an array of strings. All strings contains similar letters except one. Try to find it!
from collections import Counter
def find_uniq(arr):
    r = Counter(''.join(arr)).most_common()
    return ''.join([i for i in arr if r[-1][0] in i])

# Coding decimal numbers with factorials is a way of writing out numbers in
# a base system that depends on factorials, rather than powers of numbers.
# In this system, the last digit is always 0 and is in base 0!. The digit before that is either
# 0 or 1 and is in base 1!. The digit before that is either 0, 1, or 2 and
# is in base 2!, etc. More generally, the nth-to-last digit is always 0, 1, 2, ..., n and is in base n!.
from math import factorial
from itertools import dropwhile
DIGITS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
BASIS = [factorial(i) for i in range(len(DIGITS))]
def dec2FactString(nb):
    l = []
    for i in reversed(BASIS):
        l.append(DIGITS[nb // i])
        nb %= i
    return "".join(dropwhile(lambda x: x == "0", l))
def factString2Dec(string):
    return sum(BASIS[k] * DIGITS.index(v) for k, v in enumerate(reversed(string)))

# Carol's boss Bob thinks he is very smart. He says he made an app which renders
# messages unreadable without changing any letters, only by adding some new ones, while preserving
# message integrity (i. e. the original message can still be retrieved).
# He gave some limited access to his app to Carol to challenge her, and hinted
# that if Carol cannot crack this simple task, she might be fired.
# Carol was trying to crack this code herself, but got too tired,
# so she came to you for help. However, she succeeded to hack Bob's app
# and found a data field called 'marker'. She thinks it can be helpful for cracking Bob's app.
# Help Carol keep her job!
def decoder(encoded, marker):
    return ''.join(encoded.split(marker)[::2]) + ''.join(encoded.split(marker)[1::2])[::-1]

# Some of you might remember spending afternoons playing Street Fighter 2 in some Arcade back in
# the 90s or emulating it nowadays with the numerous emulators for retro consoles.
# Can you solve this kata? Suuure-You-Can!
# UPDATE: a new kata's harder version is available here.
# The Kata
# You'll have to simulate the video game's character selection screen behaviour, more specifically
# the selection grid. Such screen looks like this:
def street_fighter_selection(fighters, pos, moves):
    l, row, col, m = [], pos[0], pos[1], {"up":(-1, 0), "down":(1, 0), "right":(0, 1), "left":(0,-1)}
    for i in moves:
        row, col = min(max(row + m[i][0], 0), 1), (col + m[i][1]) % 6
        l.append(fighters[row][col])
    return l

# Write an algorithm that will identify valid IPv4 addresses in dot-decimal format.
# IPs should be considered valid if they consist of four octets, with values between 0 and 255, inclusive.
import ipaddress
def is_valid_IP(s):
    try:
        return bool(ipaddress.ip_address(s))
    except:
        return False

# Time to write your first Esolang interpreter :D
def my_first_interpreter(code):
    c, w = 0, ""
    for i in code:
        if i == "+": c += 1
        elif i == ".": w += chr(c % 256)
    return w

# Substitute two equal letters by the next letter of the alphabet (two letters convert to one):
def last_survivors(s):
    w = "abcdefghijklmnopqrstuvwxyza"
    for i in s:
        if s.count(i) > 1:
            s = s.replace(i, "", 2) + w[w.index(i) + 1]
            return last_survivors(s)
    return s

# You will be given a list of objects. Each object has type, material,
# and possibly secondMaterial. The existing materials are: paper, glass, organic, and plastic.
# Your job is to sort these objects across the 4 recycling bins according to their
# material (and secondMaterial if it's present), by listing the type's of objects that should go into those bins.
def recycle(a):
    dic = {'paper': [], 'glass': [], 'organic': [], 'plastic': []}
    for i in a:
        dic[i['material']].append(i['type'])
        if 'secondMaterial' in i: dic[i['secondMaterial']].append(i['type'])
    return tuple(dic.values())

# So, we need a simple function that converts a string representing a
# number (possibly with a $ sign in front of it) into the number itself.
def money_value(s):
    try:
        return float(s.replace("$", "").replace(" ", ""))
    except:
        return 0.0

# Write a function that accepts msg string and returns local tops of string from the highest to the lowest.
# The string's tops are from displaying the string in the below way:
def tops(msg):
    return ''.join(msg[i * (2 * i -1)] for i in range(int(((8 * len(msg) + 1)**.5 + 1) / 4), 0, -1))

# You just got done with your set at the gym, and you are wondering how
# much weight you could lift if you did a single repetition. Thankfully, a
# few scholars have devised formulas for this purpose (from Wikipedia) :
def calculate_1RM(w, r):
    return w if r == 1 else 0 if r == 0 else max(round(w * (1 + r/30)), round((100*w) / (101.3 - 2.67123*r)), round(w*r**0.10))

# Implement a function, so it will produce a sentence out of the given parts.
def make_sentences(parts):
    return ' '.join(parts).replace(' ,', ',').rstrip(' .') + '.'

# You must check within a string (s) to find all of the mating pairs, returning a
# list/array of the string containing valid mating pairs and a boolean indicating whether the total
# number of bears is greater than or equal to x.
from re import findall
def bears(x, s):
    return ["".join(findall("8B|B8", s)), len("".join(findall("8B|B8", s))) >= x]

# What date corresponds to the nth day of the year?
# The answer depends on whether the year is a leap year or not.
# Write a function that will help you determine the date if you know
#  the number of the day in the year, as well as whether the year is a leap year or not.
# The function accepts the day number and a boolean value isLeap as
# arguments, and returns the corresponding date of the year as a string "Month, day".
# Only valid combinations of a day number and isLeap will be tested.
from datetime import *
def get_day(day, is_leap):
    return (date(2019 + is_leap, 1, 1) + timedelta(day - 1)).strftime("%B, %-d")

# You must create a method that can convert a string from any format into PascalCase. This must support symbols too.
# Don't presume the separators too much or you could be surprised.
import re
def camelize(s):
    return "".join(i.capitalize() for i in re.split("\W|_", s))

# Build Tower by the following given arguments:
# number of floors (integer and always greater than 0)
# block size (width, height) (integer pair and always greater than (0, 0))
def tower_builder(n_floors, block_size):
    w, h = block_size
    l = []
    n = n_floors
    for i in range(n_floors):
        n -= 1
        for j in range(h): l.append(' '*n * w + '*' * (i * 2 + 1) * w + ' ' * n* w)
    return l

# The code provided has a method hello which is supposed to show only those attributes
# which have been explicitly set. Furthermore, it is supposed to say them in the same order they were set.
# But it's not working properly.
class Dinglemouse(object):

    def __init__(self):
        self.name = None
        self.sex = None
        self.age = None
        self.hell = 'Hello.'

    def setAge(self, age):
        if self.age == None:
            self.hell = self.hell + ' I am {age}.'
        self.age = age
        return self

    def setSex(self, sex):
        if self.sex == None:
            self.hell = self.hell + ' I am {sex}.'
        self.sex = "male" if sex == 'M' else "female"
        return self

    def setName(self, name):
        if self.name == None:
            self.hell = self.hell + ' My name is {name}.'
        self.name = name
        return self

    def hello(self):
        return self.hell.format(age=self.age, sex=self.sex, name=self.name)

# You will get two integers n (width) and m (height) and your task is to
# draw the following pattern. Each line is seperated with a newline (\n)
# Both integers are equal or greater than 1; no need to check for invalid parameters.
def dot(n, m):
    return ("+---" * n + "+\n" + "| o " * n + "|\n") * m + ("+---" * n + "+")

# Are you a file extension master? Let's find out by checking if Bill's files are
# images or audio files. Please use regex if available natively for your language.
# You will create 2 string methods:
# isAudio/is_audio, matching 1 or + uppercase/lowercase letter(s) (combination possible), with
# the extension .mp3, .flac, .alac, or .aac.
# isImage/is_image, matching 1 or + uppercase/lowercase letter(s) (combination possible), with
# the extension .jpg, .jpeg, .png, .bmp, or .gif.
# Note that this is not a generic image/audio files checker. It's
# meant to be a test for Bill's files only. Bill doesn't like
# punctuation. He doesn't like numbers, neither. Thus, his filenames are letter-only
# Rules
# It should return true or false, simply.
# File extensions should consist of lowercase letters and numbers only.
# File names should consist of letters only (uppercase, lowercase, or both)
def is_audio(file_name):
    return any(file_name.endswith(i) for i in ['.mp3', '.flac', '.alac', '.aac']) and all(i.isalpha() for i in file_name.split('.')[0])
def is_img(file_name):
    return any(file_name.endswith(i) for i in ['.jpg', '.jpeg', '.png', '.bmp', '.gif']) and all(i.isalpha() for i in file_name.split('.')[0])

# In this Kata, you have to design a simple routing class for a web framework.
# The router should accept bindings for a given url, http method and an action.
# Then, when a request with a bound url and method comes in, it should return the result of the action.
class Router:
    def __init__(self):
        self._routes = {}
    def bind(self, url, method, a):
        self._routes[(url, method)] = a
    def runRequest(self, url, method):
        return self._routes.get((url, method), lambda: "Error 404: Not Found")()

# for i from 1 to n, do i % m and return the sum
def f(n, m):
    return (n // m) * (m - 1) * m / 2 + (n % m) * (n % m + 1) / 2

# Given an array of strings and a character to be used as border, output the frame with the content inside.
# Notes:
# Always keep a space between the input string and the left and right borders.
# The biggest string inside the array should always fit in the frame.
# The input array is never empty.
def frame(text, char):
    text_lens = [len(i) for i in text]
    longest_len = max(text_lens)
    frame_list = [char*(longest_len + 4)]
    for i in text:
         frame_list.append("{} {}{} {}".format(char, i, " " * (longest_len - len(i)), char))
    frame_list.append(char*(longest_len + 4))
    return "\n".join(frame_list)

# Your goal is to create a function to format a number given a template; if the number is not present,
# use the digits 1234567890 to fill in the spaces.
# A few rules:
# the template might consist of other numbers, special characters or the like: you
# need to replace only alphabetical characters (both lower- and uppercase);
# if the given or default string representing the number is shorter than the template, just
# repeat it to fill all the spaces.
from itertools import cycle
def numeric_formatter(template, data='1234567890'):
    data = cycle(data)
    return ''.join(next(data) if i.isalpha() else i for i in template)

# Run-length encoding (RLE) is a very simple form of lossless data compression
# in which runs of data are stored as a single data value and count.
# A simple form of RLE would encode the string "AAABBBCCCD" as "3A3B3C1D" meaning,
# first there are 3 A, then 3 B, then 3 C and last there is 1 D.
# Your task is to write a RLE encoder and decoder using this technique. The texts
# to encode will always consist of only uppercase characters, no numbers.
import re
def encode(s):
    return "".join(f"{len(k)}{v}" for k, v in re.findall(r"((.)\2*)", s))

def decode(s):
    return "".join(int(k) * v for k, v in re.findall(r"(\d+)(\w)", s))

# Write a function that returns the count of characters that have to
# be removed in order to get a string with no consecutive repeats.
# Note: This includes any characters
def count_repeats(txt):
    return sum(1 if i == j else 0 for i, j in zip(txt, txt[1:]))

# Create a method named "rotate" that returns a given array with the elements inside the array rotated n spaces.
# If n is greater than 0 it should rotate the array to the right. If n is less than 0 it should rotate the array
# to the left. If n is 0, then it should return the array unchanged.
def rotate(data, n):
    if data:
        c = -n % len(data)
        return data[c:] + data[:c]
    return []

# Given two strings, the first being a random string and
# the second being the same as the first, but with three added
# characters somewhere in the string (three same characters),
# Write a function that returns the added character
def added_char(s1, s2):
    return [i for i in s2 if s2.count(i) >= 3 and s1.count(i) == s2.count(i)-3][0]

# The hamming distance between a pair of numbers is the number of binary bits that differ in their binary notation.
def hamming_distance(a, b):
    return bin(a ^ b).count('1')

# A masked number is a string that consists of digits and one asterisk (*) that
# should be replaced by exactly one digit. Given a masked number s, find
# all the possible options to replace the asterisk with a digit to produce an integer divisible by 6.
import sys
sys.set_int_max_str_digits(0)
def is_divisible_by_6(s):
    return [str(int(s.replace('*',str(i)))) for i in range(10) if int(s.replace('*',str(i)))%6==0]

# I want to know the size of the longest consecutive elements of X in Y.
# You will receive two arguments: items and key. Return the length of the
# longest segment of consecutive keys in the given items.
import re
def get_consective_items(item, key):
    return len(max(re.findall(f'{key}+', str(item)) or ['']))

# Given an array (or list) of scores, return the array of ranks for each value in the array.
# The largest value has rank 1, the second largest value has rank 2, and so on.
# Ties should be handled by assigning the same rank to all tied values. For example:
def ranks(a):
    return [sorted(a, reverse = True).index(i) + 1 for i in a]

# We are tracking down our rogue agent Matthew Knight also known as Roy Miller. He travels
# from places to places to avoid being tracked. Each of his travels are
# based on a list of itineraries in an unusual or incorrect order. The task
# is to determine the routes he will take in his every journey.
# Task
# You are given an array of routes of his itineraries. List down the only
# places where he will go in correct order based on his itineraries.
def find_routes(routes):
    d = dict(routes)
    r = list(d.keys() - d.values())
    while r[-1] in d: r.append(d[r[-1]])
    return ', '.join(r)

# Complete the method that will determine the minimum number of coins needed to make change
# for a given amount in American currency.
# Coins used will be half-dollars, quarters, dimes, nickels, and pennies, worth
# 50¢, 25¢, 10¢, 5¢ and 1¢, respectively. They'll be represented by the symbols
# H, Q, D, N and P (symbols in Ruby, strings in in other languages)
# The argument passed in will be an integer representing the value in cents. The return
# value should be a hash/dictionary/object with the symbols as keys, and the numbers of
# coins as values. Coins that are not used should not be included in the hash. If the
# argument passed in is 0, then the method should return an empty hash.
def make_change(amount):
    d = {}
    for k, v in (('H', 50), ('Q', 25), ('D', 10), ('N', 5), ('P', 1)):
        if amount >= v: d[k], amount = divmod(amount, v)
    return d1

# Your task is to give the number of total values for the odd
# terms of the sequence up to the n-th term (included). (The number n (of n-th term)
# will be given as a positive integer)
# The values 1 (one) is the only that is duplicated in the sequence and should be counted only once.
def count_odd_pentaFib(l):
    return 2 * (l // 6) + [0, 1, 2, 2, 2, 2][l % 6] - (l >= 2)

# Two strings a and b are called isomorphic if there is a one
# to one mapping possible for every character of a to every character of b.
# And all occurrences of every character in a map to same character in b.
# Task
# In this kata you will create a function that return True if two given strings are isomorphic
# to each other, and False otherwise. Remember that order is important.
# Your solution must be able to handle words with more than 10 characters.
from collections import Counter
def isomorph(s: str, t: str) -> bool:
        sc=len(Counter(s))
        st=len(Counter(t))
        if(sc!=st): return False
        else:
           s1=[]
           t1=[]
           m=[]
           ans=[]
           for i in s: s1.append(i)
           for i in t: t1.append(i)
           m.append(s1)
           m.append(t1)
        for i in s:
              if i in m[0]:
               a=m[0].index(i)
               ans.append(m[1][a])
        return "".join(ans) == t

# Two integer numbers are added using the column addition method. When using this
# method, some additions of digits produce non-zero carries to the next positions.
# Your task is to calculate the number of non-zero carries that will occur while adding the given numbers.
# The numbers are added in base 10.
def number_of_carries(a: int, b: int) -> int:
    s = sum(int(i) for i in str(a))
    s2 = sum(int(i) for i in str(b))
    s3 = sum(int(i) for i in str(a + b))
    return (s + s2 - s3) // 9

# For a given nonempty string s find a minimum substring t and the maximum number k,
# such that the entire string s is equal to t repeated k times.
# The input string consists of lowercase latin letters.
# Your function should return :
# a tuple (t, k) (in Python)
# an array [t, k] (in Ruby and JavaScript)
# in C, return k and write to the string t passed in parameter
def f(s):
    c = min([s.count(i) for i in s])
    w = ''
    for i in s:
        w += i
        if w * c == s: return (w, c)
    return (s, 1)

# You need to write a password generator that meets the following criteria:
# 6 - 20 characters long
# contains at least one lowercase letter
# contains at least one uppercase letter
# contains at least one number
# contains only alphanumeric characters (no special characters)
# Return the random password as a string.
# Note: "randomness" is checked by counting the characters used in the generated passwords - all characters
# should have less than 50% occurance. Based on extensive tests, the normal rate is around 35%.
from string import ascii_lowercase as LOWER, ascii_uppercase as UPPER, digits as DIGITS
from random import choice, shuffle, randint
def password_gen():
    w = [choice(UPPER), choice(LOWER), choice(DIGITS)] + [choice(UPPER+LOWER+DIGITS) for i in range(randint(3, 17))]
    shuffle(w)
    return "".join(w)

# You are given an array of unique numbers. The numbers represent points.
# The higher the number the higher the points. In the array [1,3,2] 3 is the highest
# point value so it gets 1st place. 2 is the second highest so it
# gets second place. 1 is the 3rd highest so it gets 3rd place.
# Your task is to return an array giving each number its rank in the array.
def rankings(arr):
    l = sorted(arr, reverse=True)
    return [l.index(i)+1 for i in arr]

# A palindrome is a word, phrase, number, or other sequence of
# characters which reads the same backward as forward. Examples of numerical palindromes are:
# 2332
# 110011
# 54322345
# For this kata, single digit numbers will not be considered numerical palindromes.
# For a given number num, write a function to test if the number contains a
# numerical palindrome or not and return a boolean (true if it does and false if does not).
# Return "Not valid" if the input is not an integer or is less than 0.
# Note: Palindromes should be found without permutating num.
import re
def palindrome(integer):
    if not isinstance(integer, int) or integer < 0: return 'Not valid'
    return re.search(r'(.)\1|(.).\2', str(integer)) is not None

# A list S will be given. You need to generate a list T from it by following the given process:
# Remove the first and last element from the list S and add them to the list T.
# Reverse the list S
# Repeat the process until list S gets emptied.
# The above process results in the depletion of the list S. Your task is to generate list T without
# mutating the input List S.
def arrange(s):
    return list(s[[i,-i,~i,i][i%4]//2]for i in range(len(s)))

# Just like in the "father" kata, you will have to return
# the last digit of the nth element in the Fibonacci sequence (starting with 1,1, to be extra clear,
# not with 0,1 or other numbers).
# You will just get much bigger numbers, so good luck bruteforcing your way through it ;)
def last_fib_digit(n):
    return int('011235831459437077415617853819099875279651673033695493257291'[n % 60])

# A palindrome is a word, phrase, number, or other sequence
# of characters which reads the same backward as forward. Examples of numerical palindromes are:
# 2332
# 110011
# 54322345
# For a given number num, return its closest numerical palindrome which can either be smaller or larger
# than num. If there are 2 possible values, the larger value should be returned. If
# num is a numerical palindrome itself, return it.
# For this kata, single digit numbers will NOT be considered numerical palindromes.
# Also, you know the drill - be sure to return "Not valid" if the input is not an integer or is less than 0.
def palindrome(num):
    if not isinstance(num, int) or num < 0: return 'Not valid'
    if num < 10: num = 11
    if str(num) == str(num)[::-1]: return num
    r, l, d = 0, 0, num
    while str(num)!=str(num)[::-1]: num, l = num+1, l+1
    while str(d)!=str(d)[::-1]: d, r = d-1, r+1
    return d if r<l else num

# Write a function that gets a sequence and value and returns true/false
# depending on whether the variable exists in a multidimentional sequence.
def locate(seq, v):
    return v in seq or any(locate(i, v) for i in seq if isinstance(i, list))

# In this Kata, you will be given a series of times at which an alarm sounds. Your
# task will be to determine the maximum time interval between alarms. Each alarm
# starts ringing at the beginning of the corresponding minute and rings for exactly one
# minute. The times in the array are not in chronological order. Ignore duplicate times, if any.
from datetime import datetime
def solve(arr):
    l = [datetime(2000, 1, 1, *map(int, x.split(':'))) for x in sorted(arr)]
    c = max(int((j - i).total_seconds() - 60) for i, j in zip(l, l[1:] + [l[0].replace(day=2)]))
    return '{:02}:{:02}'.format(*divmod(c//60, 60))

# Create a function running_average() that returns a callable function object. Update the series with
# each given value and calculate the current average.
def running_average():
    l = []
    def mean(n):
        l.append(n)
        return round(sum(l) / len(l), 2)
    return mean

# You'll be given a string of random characters (numbers, letters, and symbols).
# To decode this string into the key we're searching for:
# (1) count the number occurences of each ascii lowercase letter, and
# (2) return an ordered string, 26 places long, corresponding to the number of occurences
# for each corresponding letter in the alphabet.
def decrypt(w):
    return ''.join(str(w.count(i)) for i in "abcdefghijklmnopqrstuvwxyz")

# Write a function
# find_the_number_plate
# which takes the Customer ID as an argument, calculates the Number Plate corresponding to this ID and
# returns it as a string
def find_the_number_plate(i):
    return f'{97+i//999%26:c}{97+i//999//26%26:c}{97+i//999//26//26:c}{1+i%999:03}'

# You will be given an array of strings. The words in the array should mesh together where one or more
# letters at the end of one word will have the same letters (in the same order)
# as the next word in the array. But, there are times when all the words won't mesh.
def word_mesh(arr):
    r = ""
    for i, j in zip(arr, arr[1:]):
        while not i.endswith(j):
            j = j[:-1]
        if not j: return "failed to mesh"
        r += j
    return r

# Given a string, return the minimal number of parenthesis reversals needed to make balanced parenthesis.
def solve(s):
    if len(s) % 2: return -1
    l, c = 0, 0
    for i in s:
        if i == '(': l += 1
        else: l -= 1
        if l < 0:
            c += 1
            l += 2
    return c + l // 2

# A series or sequence of numbers is usually the product of a function and can either be infinite or finite.
# In this kata we will only consider finite series and you are required to return a code according to the
# type of sequence:
def sequence_classifier(l):
    if all(l[i] == l[i+1] for i in range(len(l)-1)): return 5
    if all(l[i] <  l[i+1] for i in range(len(l)-1)): return 1
    if all(l[i] <= l[i+1] for i in range(len(l)-1)): return 2
    if all(l[i] >  l[i+1] for i in range(len(l)-1)): return 3
    if all(l[i] >= l[i+1] for i in range(len(l)-1)): return 4
    return 0

# Make a custom esolang interpreter for the language Tick. Tick
# is a descendant of Ticker but also very different data and command-wise.
def interpreter(tape):
    d, c, w = {}, 0, ""
    for i in tape:
        if i == ">":  c += 1
        elif i == "<":  c -= 1
        elif i == "+":  d[c] = (d.get(c, 0) + 1) % 256
        elif i == "*":  w += chr(d[c])
    return w

# Gary likes pictures but he also likes words and reading. He has had a
# desire for a long time to see what words and books would look like if they could be seen as images.
# For this task you are required to take a continuous string that can consist of any
# combination of words or characters and then convert the words that make up this
# string into hexadecimal values that could then be read as colour values.
# A word is defined as a sequence of ASCII characters between two white
# space characters or the first or last word of a sequence of words.
def words_to_hex(words):
    return [f"#{i[:3].hex():0<6}" for i in words.encode().split()]

# Remember the game 2048? http://gabrielecirulli.github.io/2048/
# The main part of this game is merging identical tiles in a row.
# Implement a function that models the process of merging all of the tile values in a single row.
# This function takes the array line as a parameter and returns a
# new array with the tile values from line slid towards the front of the array (index 0) and merged.
# A given tile can only merge once.
# Empty grid squares are represented as zeros.
# Your function should work on arrays containing arbitrary number of elements.
def merge(line):
    l = [i for i in line if i != 0]
    for i in range(len(l) - 1):
        if l[i] == l[i + 1]: l = l[:i] + [l[i] + l[i + 1]] + l[i + 2:] + [0]
    return l + [0] * (len(line) - len(l))

# Given an array of integers, sum consecutive even numbers and consecutive odd numbers. Repeat the
# process while it can be done and return the length of the final array.
from itertools import groupby
def sum_groups(arr):
    l = list(sum(j) for i,j in groupby(arr, key = lambda x: x % 2 == 0))
    return len(l) if l == arr else sum_groups(l)

# The goal of this Kata is to write a function that will receive an array of strings as its
# single argument, then the strings are each processed and sorted (in desending order) based on the length
# of the single longest sub-string of contiguous vowels ( aeiouAEIOU ) that may
# be contained within the string. The strings may contain letters, numbers, special
# characters, uppercase, lowercase, whitespace, and there may be (often will be)
# multiple sub-strings of contiguous vowels. We are only interested in the single longest
# sub-string of vowels within each string, in the input array.
import re
def sort_strings_by_vowels(seq):
    return sorted(seq, reverse=True, key=lambda _: max((len(i) for i in re.findall(r'[aeiouAEIOU]+', _)), default=0))

# Spin-off of this kata, here you will have to figure out an efficient strategy to
# solve the problem of finding the sole duplicate number among an unsorted array/list of
# numbers starting from 1 up to n.
# Hints: a solution in linear time can be found; using the most intuitive ones to search
# for duplicates that can run in O(n²) time won't work.
def find_dup(arr):
    for i in arr:
        if arr.count(i) > 1: return i

# Given a string of integers, return the number of odd-numbered substrings that can be formed.
def solve(s):
    return sum(int(j) % 2 for i in range(len(s)) for j in s[i:])

# Given an integer n return "odd" if the number of its divisors is odd. Otherwise return "even".
# Note: big inputs will be tested.
def oddity(n):
    return 'odd' if n **.5 == int(n **.5) else 'even'

# Given two array of integers(arr1,arr2). Your task is going to find a
# pair of numbers(an element in arr1, and another element in arr2), their
# difference is as big as possible(absolute value); Again, you should to find a
# pair of numbers, their difference is as small as possible. Return the maximum and
# minimum difference values by an array: [  max difference,  min difference  ]
def max_and_min(arr1,arr2):
    l = [abs(i-j) for i in arr1 for j in arr2]
    return [max(l), min(l)]

# Shake the tree and count where the nuts land.
# Output - An array (same width as the tree) which indicates how many nuts fell at each position ^
from collections import Counter
def shake_tree(tree):
    l = [k for k,v in enumerate(tree[0]) if v == 'o']
    for char in tree[1:]:
        l = [i+1 if char[i] == '\\' else i-1 if char[i] == '/' else i for i in l if char[i] != '_']
    d = Counter(l)
    return [d[i] for i in range(len(tree[0]))]

# Given two words, how many letters do you have to remove from them to make them anagrams?
from collections import Counter
def anagram_difference(w1, w2):
    w1, w2 = Counter(w1), Counter(w2)
    return sum(((w1 - w2) + (w2 - w1)).values())

# Ka ka ka cypher is a cypher used by small children in some country. When a girl
# wants to pass something to the other girls and there are some boys nearby,
# she can use Ka cypher. So only the other girls are able to understand her.
# She speaks using KA, ie.:
# ka thi ka s ka bo ka y ka i ka s ka u ka gly what simply means this boy is ugly.
# Task
# Write a function that accepts a string word and returns encoded message using ka cypher.
def ka_co_ka_de_ka_me(word):
    w = ""
    for k, v in enumerate(word):
        if k != len(word):
            if v.lower() not in "aeiou" and word[k-1].lower() in "aeiou" and k != 0: w += "ka"
        w += v
    return "ka" + w

# Create a function that takes a string and separates it into a sequence of letters.
def sep_str(st):
    return [[j[i] if len(j) > i else '' for j in st.split()] for i in range(max(map(len, st.split())))] if st else []

# Complete the pattern, using the special character ■   □
# In this kata, we draw some histogram of the sound performance of ups and downs.
def draw(waves):
    l = max(waves)
    return '\n'.join(''.join('□■'[j > i] for j in waves) for i in reversed(range(l)))

# Return the sum of the multiples of 3 and 5 below a number. Being the galactic games,
# the tracks can get rather large, so your solution should
# work for really large numbers (greater than 1,000,000).
def solution(number):
    a, b, c = (number - 1) // 5, (number - 1) // 3, (number - 1) // 15
    return (((a * (a + 1)) // 2) * 5) + (((b * (b + 1)) // 2) * 3) - (((c * (c + 1)) // 2) * 15)

# Write a function groupIn10s which takes any number of arguments, groups them into
# tens, and sorts each group in ascending order.
# The return value should be an array of arrays, so that numbers
# between 0 and9 inclusive are in position 0, numbers between 10 and 19 are in position 1, etc.
def group_in_10s(*args):
    if len(args) == 0: return []
    s = sorted(args)
    l = [None for _ in range(max(s)//10 + 1)]
    for j in s:
        i = j // 10
        if l[i] is None: l[i] = [j]
        else: l[i].append(j)
    return l

# You're continuing to enjoy your new piano, as described in Piano Kata, Part 1.
# You're also continuing the exercise where you start on the very first (leftmost, lowest in pitch)
# key on the 88-key keyboard, which (as shown below) is the note A, with the little finger
# on your left hand, then the second key, which is the black key A# ("A sharp"), with your
# left ring finger, then the third key, B, with your left middle finger, then the fourth key, C,
# with your left index finger, and then the fifth key, C#, with your left thumb. Then
# you play the sixth key, D, with your right thumb, and continue on playing the seventh, eighth,
# ninth, and tenth keys with the other four fingers of your right hand. Then for the eleventh
# key you go back to your left little finger, and so on. Once you get to the rightmost/highest,
# 88th, key, C, you start all over again with your left little finger on the first key.
def which_note(count):
    return ['A','A#','B','C','C#','D','D#','E','F','F#','G','G#'][(count - 1) % 88 % 12]

# In this Kata, you will be given a number and your task will be to return the nearest prime number.
from gmpy2 import is_prime
def solve(n, i=0):
    return is_prime(n-i) and n-i or is_prime(n+i) and n+i or solve(n,i+1)

# You've just finished writing the last chapter for your novel when a virus suddenly infects your document.
# It has swapped the 'i's and 'e's in 'ei' words and capitalised random letters. Write a function which will:
# a) remove the spelling errors in 'ei' words. (Example of 'ei' words: their, caffeine, deceive, weight)
# b) only capitalise the first letter of each sentence. Make sure the rest of the sentence is in lower case.
def proofread(s):
    return '. '.join(_.lower().replace('ie', 'ei').capitalize() for _ in s.split('. '))

# A rectangle can be split up into a grid of 1x1 squares, the amount of
# which being equal to the product of the two dimensions of the rectangle. Depending on the
# size of the rectangle, that grid of 1x1 squares can also be split up into
# larger squares, for example a 3x2 rectangle has a total of 8 squares,
# as there are 6 distinct 1x1 squares, and two possible 2x2 squares. A 4x3 rectangle contains 20 squares.
# Your task is to write a function `findSquares` that returns the total number of squares
# for any given rectangle, the dimensions of which being given as two integers with
# the first always being equal to or greater than the second.
def findSquares(x,y):
    return sum((x-i) * (y-i) for i in range(y))

# Our friendly jumping spider is resting and minding his own spidery business at web-coordinate spider.
# An inattentive fly bumbles into the web at web-coordinate fly and gets itself stuck.
# Your task is to calculate and return the distance the spider must jump to get to the fly.
from math import cos, pi
def spider_to_fly(spider, fly):
    x, y = int(spider[1]), int(fly[1])
    return (x**2 + y**2 - 2 * x * y * cos((ord(spider[0]) - ord(fly[0])) * pi / 4))**0.5

# Array Exchange and Reversing
# It's time for some array exchange! The objective is simple: exchange the elements of two arrays
# in-place in a way that their new content is also reversed.
def exchange_with(a, b):
    a[:], b[:] = b[::-1], a[::-1]

# Write a function that accepts a message string and an array of integers code. As the result, return
# the key that was used to encrypt the message. The key has to be shortest of all
# possible keys that can be used to code the message: i.e. when the possible keys
# are 12 , 1212, 121212, your solution should return 12.
def find_the_key(message, code):
    w = "".join(str(code[k] + 96 - ord(v)) for k, v in enumerate(message))
    l = len(w)
    for i in range(1, l + 1):
        if (w[:i] * l)[:l] == w: return int(w[:i])

# Mrs Jefferson is a great teacher. One of her strategies that helped her to reach astonishing results
# in the learning process is to have some fun with her students. At school, she wants
# to make an arrangement of her class to play a certain game with her pupils.
# For that, she needs to create the arrangement with the minimum amount of groups that have consecutive sizes.
def shortest_arrang(n):
    r = n // 2 + 2
    l = [i for i in range(r, 0, -1)]
    for i in range(r):
        for j in range(r + 1):
            if sum(l[i:j]) == n: return l[i:j]
    return [-1]

# We need a function prime_bef_aft() that gives the largest prime below a certain given value n,
# befPrime or bef_prime (depending on the language),
# and the smallest prime larger than this value,
# aftPrime/aft_prime (depending on the language).
# The result should be output in a list like the following:
from gmpy2 import is_prime, next_prime
def prime_bef_aft(i):
    return [next(filter(is_prime, range(i-1, 1, -1))), next_prime(i)]

# You wrote all your unit test names in camelCase. But some of your colleagues have troubles reading these
# long test names. So you make a compromise to switch to underscore separation.
# To make these changes fast you wrote a class to translate a camelCase name into an underscore separated name.
# Implement the ToUnderscore() method.
import re
def toUnderScore(word):
    return re.sub("(?<=[^_-])_?(?=[A-Z])|(?<=[^\\d_])_?(?=\\d)", "_", word)

# A palindrome is a word, phrase, number, or other sequence of characters which reads the
# same backward as forward. Examples of numerical palindromes are: 2332, 110011, 54322345
# For a given number num, write a function which returns an array of all the numerical palindromes
# contained within each number. The array should be sorted in ascending order
# and any duplicates should be removed.
def palindrome(num):
    if not isinstance(num, int) or num < 0: return "Not valid"
    n = str(num)
    l = len(n)
    c = {int(n[i:j]) for i in range(l-1) for j in range(i+2, l+1) if int(n[i]) and n[i:j] == n[i:j][::-1]}
    return sorted(c) if c else "No palindromes found"

# John is a typist. He has a habit of typing: he never use the Shift key to switch case, just using only Caps Lock.
# Given a string s. Your task is to count how many times the keyboard has been tapped by John.
# You can assume that, at the beginning the Caps Lock light is not lit.
def typist(s):
    return sum(i.islower()^j.islower() for i, j in zip('a'+s, s)) + len(s)

# You are given a list of directions in the form of a list:
# goal = ["N", "S", "E", "W"]
# Pretend that each direction counts for 1 step in that particular direction.
# Your task is to create a function called directions, that will return a reduced list that will
# get you to the same point.The order of directions must be returned as N then S then E then W.
# If you get back to beginning, return an empty array.
def directions(goal):
    y, x = goal.count("N") - goal.count("S"), goal.count("E") - goal.count("W")
    return ["N"] * y + ["S"] * (-y) + ["E"] * x + ["W"] * (-x)

# Given a positive integer as input, return the output as a string in the following format:
# Each element, corresponding to a digit of the number, multiplied by a power of 10 in such
# a way that with the sum of these elements you can obtain the original number.
def simplify(n):
    return "".join(["+"+str(n)[i]+("*1"+"0"*(len(str(n))-i-1) if len(str(n))-i-1>0 else "") for i in range(0, len(str(n))) if str(n)[i]!="0"])[1:]

# Imagine a triangle of numbers which follows this pattern:
# Starting with the number "1", "1" is positioned at the top
# of the triangle. As this is the 1st row, it can only support a single number.
# The 2nd row can support the next 2 numbers: "2" and "3"
# Likewise, the 3rd row, can only support the next 3 numbers: "4", "5", "6"
# And so on; this pattern continues.
def cumulative_triangle(n):
    return (n**3+n)/2

# Your goal is to write a function that determines the depth of the deepest nested list within a given list.
# return 1 if there are no nested lists. The list passed to your function can contain any data types.
def list_depth(lst):
    l = [list_depth(i) for i in lst if isinstance(i, list)]
    return max(l)+1 if l else 1

# For a given number num, write a function which returns the number of
# numerical palindromes within each number. For this kata, single digit
# numbers will NOT be considered numerical palindromes.
# Return "Not valid" if the input is not an integer or is less than 0.
def palindrome(num):
    if not isinstance(num, int) or num < 0: return 'Not valid'
    s = str(num)
    return sum(sum(s[i:i+j] == s[i:i+j][::-1] for i in range(len(s)-j+1)) for j in range(2, len(s)+1))

# Write function which validates an input string. If the string is a perfect square return true,false otherwise.
def perfect_square(square):
    return all("." * len(square.split("\n")) == i for i in square.split("\n"))

# Third day at your new cryptoanalyst job and you come across your toughest assignment
# yet. Your job is to implement a simple keyword cipher. A keyword cipher is a type of monoalphabetic
# substitution where two parameters are provided as such (string, keyword). The string is
# encrypted by taking the keyword, dropping any letters that appear more than once. The rest of the
# letters of the alphabet that aren't used are then appended to the end of the keyword.
def keyword_cipher(s, keyword, key=""):
    w = "abcdefghijklmnopqrstuvwxyz"
    for i in keyword + w:
        if i not in key: key += i
    return s.lower().translate(str.maketrans(w, key))

# In his publication Liber Abaci Leonardo Bonacci, aka Fibonacci, posed a problem involving a population
# of idealized rabbits. These rabbits bred at a fixed rate, matured over the course of
# one month, had unlimited resources, and were immortal.
# Create a function that determines the number of pairs of mature rabbits after n
# months, beginning with one immature pair of these idealized rabbits that produce b pairs of offspring at
# the end of each month.
def fib_rabbits(n, b):
    x, y = 0, 1
    for i in range(n): x, y = y, y + b * x
    return x

# You'll have a function called "sortEmotions" that will return an array of emotions
# sorted. It has two parameters, the first parameter called "arr" will
# expect an array of emotions where an emotion will be one of the following:
def sort_emotions(arr, bool):
    return sorted(arr, key=[':D',':)',':|',':(','T_T'].index, reverse = not bool)

# Your task is to write a function named do_math that receives a single argument.
# This argument is a string that contains multiple whitespace delimited numbers. Each number has
# a single alphabet letter somewhere within it.
from functools import reduce
from itertools import cycle
from operator import add, truediv, mul, sub
def do_math(s):
    l = sorted(s.split(), key=lambda j: next(i for i in j if i.isalpha()))
    l = [int(''.join(filter(str.isdigit, i))) for i in l]
    ops = cycle([add, sub, mul, truediv])
    return round(reduce(lambda a, b: next(ops)(a, b), l))

# Natural Language Understanding is the subdomain of Natural Language Processing where people
# used to design AI based applications have ability to understand the human languages. HashInclude
# Speech Processing team has a project named Virtual Assistant. For this project
# they appointed you as a data engineer (who has good knowledge of creating clean datasets
# by writing efficient code). As a data engineer your first task is to
# make vowel recognition dataset. In this task you have to find the presence of vowels
# in all possible substrings of the given string. For each given string you have to
# return the total number of vowels.
def vowel_recognition(input):
    w = set('aeiouAEIOU')
    s = t = 0
    for k, v in enumerate(input, 1):
        if v in w: t += k
        s += t
    return s

# Christmas is coming, and your task is to build a custom Christmas tree with the specified
# characters and the specified height.
from itertools import cycle, chain
def custom_christmas_tree(chars, n):
    c, l = cycle(chars), 2*n-1
    return '\n'.join(chain((' '.join(next(c) for i in range(j)).center(l).rstrip() for j in range(1,n+1)), ('|'.center(l).rstrip() for k in range(n//3 or 1))))

# No Story
# No Description
# Only by Thinking and Testing
# Look at the result of testcase, guess the code!
def test_it(a, b):
    return sum(map(int, str(a))) * sum(map(int, str(b)))

# Cara is applying for several different jobs. The online
# application forms ask her to respond within a specific character count. Cara
# needs to check that her answers fit into the character limit.
# Annoyingly, some application forms count spaces as a character, and some don't.
# Your challenge:
# Write Cara a function charCheck() with the arguments:
# "text": a string containing Cara's answer for the question
# "max": a number equal to the maximum number of characters allowed in the answer
# "spaces": a boolean which is True if spaces are included in the character count and False if they are not
def charCheck(text, mx, spaces):
    if not spaces: text = text.replace(' ', '')
    return [len(text) <= mx, text[:mx]]

# Create a function longer that accepts a string and sorts the words in it based on their
# respective lengths in an ascending order. If there are two words of the
# same lengths, sort them alphabetically. Look at the examples below for more details.
def longer(s):
    return ' '.join(sorted(s.split(' '), key = lambda x: (len(x),x)))

# The look and say sequence is a sequence in which each number is the result of a "look and say"
# operation on the previouselement.
# Considering for example the classical version startin with "1": ["1", "11", "21, "1211", "111221", ...]. You
# can see that the second element describes the first as "1(times number)1",
# the third is "2(times number)1" describing the second, the fourth is "1(times number)
# 2(and)1(times number)1" and so on.
# Your goal is to create a function which takes a starting string (not
# necessarily the classical "1", much less a single character start) and return the nth element of the series.
from itertools import groupby
from functools import reduce
def look_and_say_sequence(first_element, n):
    return reduce(lambda i, j: ''.join('%d%s' % (len(list(v)), k) for k, v in groupby(i)), range(n - 1), first_element)

# Give you two number rows , columns and a string str. Returns a rows
# x columns table pattern and fill in the str(each grid fill in a char,
# the length of str is always less than or equals to the total numbers of grids):
def pattern(rows, col, s):
    seperator, res, l, index = '+---'*col + '+', '', len(s), 0
    for _ in range(rows):
        res += seperator+'\n'
        for c in range(col):
            if index < l: res += f'| {s[index]} '
            else: res += '|   '
            index += 1
        res += '|\n'
    res += seperator
    return res

# Traditionally in FizzBuzz, multiples of 3 are replaced by "Fizz" and multiples of
# 5 are replaced by "Buzz". But we could also play FizzBuzz with any other integer pair
# [n, m] whose multiples are replaced with Fizz and Buzz.
# For a sequence of numbers, Fizzes, Buzzes and FizzBuzzes, find the numbers
# whose multiples are being replaced by Fizz and Buzz. Return them as an array [n, m]
# The Fizz and Buzz numbers will always be integers between 1 and 50, and
# the sequence will have a maximum length of 100. The Fizz and Buzz numbers
# might be equal, and might be equal to 1.
def reverse_fizz_buzz(array):
    return tuple(next(i for i, j in enumerate(array, 1) if j == k or j == "FizzBuzz") for k in ["Fizz", "Buzz"])

# Your task is to write a function such that, for the input
# string that represents a road as described, returns the total number of photos
# that were taken by the cameras. The complexity should be strictly O(N) in order to pass all the tests.
def count_photos(road):
    c, l, f = 0, 0, 0
    for i in road:
        if i == ">": l += 1
        elif i == ".":
            c += l
            f += 1
        elif i == "<": c += f
    return c

# You are given N ropes, where the length of each rope is a positive integer.
# At each step, you have to reduce all the ropes by the length of the smallest rope.
# The step will be repeated until no ropes are left. Given the length of N
# ropes, print the number of ropes that are left before each step.
def cut_the_ropes(arr):
    l = []
    while arr:
        l.append(len(arr))
        m = min(arr)
        arr = [i - m for i in arr if i > m]
    return l

# In one city it is allowed to write words on the buildings walls. The local
# janitor, however, doesn't approve of it at all. Every night he vandalizes
# the writings by erasing all occurrences of some letter. Since the janitor
# is quite lazy, he wants to do this with just one swipe of his mop.
def the_janitor(word):
    l = []
    w = 'abcdefghijklmnopqrstuvwxyz'
    for i in w:
        if i not in word:
            l.append(0)
            continue
        l.append(word.rindex(i) + 1 - word.index(i))
    return l

# Math geeks and computer nerds love to anthropomorphize numbers and assign emotions and personalities to
# them. Thus there is defined the concept of a "happy" number. A happy number
# is defined as an integer in which the following sequence ends with the number 1.
# Start with the number itself.
# Calculate the sum of the square of each individual digit.
# If the sum is equal to 1, then the number is happy. If the sum is not
# equal to 1, then repeat steps 1 and 2. A number is considered unhappy once
# the same number occurs multiple times in a sequence because this means there is
# a loop and it will never reach 1.
def happy_numbers(n):
    def is_happy(n):
        stop = {1}
        while n not in stop:
            stop.add(n)
            n = sum(int(d)**2 for d in str(n))
        return n == 1
    return [i for i in range(1, n+1) if is_happy(i)]

# The situation...
# The fastest penguins in the world have just swum for the ultimate prize in professional penguin swimming.
# The cameras that were capturing the race stopped recording half way through.
# The athletes, and the fans are in disarray waiting for the results.
# The challenge...
# Given the last recorded frame of the race, and an array of penguin athletes,
# work out the gold, silver and bronze medal positions.
def calculate_winners(snapshot, penguins):
    c, d = 0, {}
    for i in snapshot.split('\n'):
        for j in i[i.lower().index('p')+1:]:
            if j == '~':
                c += 2
                continue
            c += 1
        d[penguins[0]] = c
        penguins = penguins[1:]
        c = 0
    d = [i for i in dict(sorted(d.items(), key=lambda i: i[1]))]
    return f"GOLD: {d[0]}, SILVER: {d[1]}, BRONZE: {d[2]}"

# Most football fans love it for the goals and excitement. Well, this Kata doesn't.
# You are to handle the referee's little notebook and count the players who
# were sent off for fouls and misbehavior.
# The rules: Two teams, named "A" and "B" have 11 players each; players on each team
# are numbered from 1 to 11. Any player may be sent off the field by being
# given a red card. A player can also receive a yellow warning card, which is fine, but
# if he receives another yellow card, he is sent off immediately (no need for a
# red card in that case). If one of the teams has less than 7 players remaining, the game
# is stopped immediately by the referee, and the team with less than 7 players loses.
def men_still_standing(cards):
    a, b = [0] * 11, [0] * 11
    for c in cards:
        if c[0] == 'A': a[int(c[1:-1])-1] += (1 if c[-1] == 'Y' else 2)
        else: b[int(c[1:-1])-1] += (1 if c[-1] == 'Y' else 2)
        if sum(i < 2 for i in a) < 7 or sum(i < 2 for i in b) < 7: break
    return (sum(i < 2 for i in a), sum(i < 2 for i in b))

# Your apple has a virus, and the infection is spreading.
# The apple is a two-dimensional array, containing
# strings "V" (virus) and "A" (uninfected parts). For each hour,
# the infection spreads one space up, down, left and right.
# Input: 2D array apple and number n (n >= 0).
# Output: 2D array showing the apple after n hours.
def infect_apple(apple, n):
    h, w = range(len(apple)), range(len(apple[0]))
    v = [(i, j) for i in h for j in w if apple[i][j] == "V"]
    return [["A" if all(n < abs(y - j) + abs(x - i) for y, x in v) else "V" for i in w] for j in h]

# Let's say take 2 strings, A and B, and define the similarity of the strings to
# be the length of the longest prefix common to both strings. For example, the similarity of strings
# abc and abd is 2, while the similarity of strings aaa and aaab is 3.
# write a function that calculates the sum of similarities of a string S with each of it's suffixes.
def string_suffix(str):
    c = 0
    for i in range(len(str)):
        for a, b in zip(str, str[i:]):
            if a != b: break
            c += 1
    return c

# Return the most profit from stock quotes.
# Stock quotes are stored in an array in order of date. The stock profit is
# the difference in prices in buying and selling stock. Each day, you can
# either buy one unit of stock, sell any number of stock units you have
# already bought, or do nothing. Therefore, the most profit is the
# maximum difference of all pairs in a sequence of stock prices.
def get_most_profit_from_stock_quotes(quotes):
    return sum(max(quotes[k:]) - v for k, v in enumerate(quotes))

# Some languages like Chinese, Japanese, and Thai do not have spaces between words. However,
# most natural languages processing tasks like part-of-speech tagging require texts that have segmented
# words. A simple and reasonably effective algorithm to segment a sentence
# into its component words is called "MaxMatch".
# MaxMatch
# MaxMatch starts at the first character of a sentence and tries to find the longest valid
# word starting from that character. If no word is found, the first character is deemed the
# longest "word", regardless of its validity. In order to find the rest of the words,
# MaxMatch is then recursively invoked on all of the remaining characters until no characters remain.
# A list of all of the words that were found is returned.
def max_match(s):
    l = []
    while s:
        for i in range(len(s), 0, -1):
            w = s[:i]
            if w in VALID_WORDS: break
        l.append(w)
        s = s[i:]
    return l

# Write a function that returns the greatest common factor of an array of positive integers.
# Your return value should be a number, you will only receive positive integers.
def greatest_common_factor(seq):
    l = []
    for i in range(1, min(seq)+1):
        if all(j % i == 0 for j in seq): l.append(i)
    return max(l)

# Check that the two provided arrays both contain the same number of different unique
# items, regardless of order. For example in the following:
from collections import Counter
def balance(arr1, arr2):
    s1, s2 = sorted(Counter(arr1).values()), sorted(Counter(arr2).values())
    return all(i == j for i, j in zip(s1, s2)) and len(s1) == len(s2)

# This challenge is an extension of the kata of Codewars: Missing and Duplicate Number", authored
# by the user Uraza. (You may search for it and complete it if you have not done it)
# In this kata, we have an unsorted sequence of consecutive numbers from a to b, such
# that a < b always (remember a, is the minimum, and b the maximum value).
# They were introduced an unknown amount of duplicates in this sequence and we know that there
# is an only missing value such that all the duplicate values and the missing value are
# between a and b, but never coincide with them.
# Find the missing number with the duplicate numbers (duplicates should be output in a sorted array).
from collections import Counter
def find_dups_miss(arr):
    s = Counter(arr)
    l = sum(i for i in range(sorted(s)[0], sorted(s)[-1]+1)) - sum(s)
    return [l, sorted(k for k, v in s.items() if v > 1)]

# In this Kata, you will be given an array of integers and your task is
# to return the number of arithmetic progressions of size 3 that are possible
# from that list. In each progression, the differences between the elements must be the same.
from itertools import combinations
def solve(arr):
    return sum(a - b == b - c for a, b, c in combinations(arr, 3))

# Build a function sumNestedNumbers/sum_nested_numbers that finds the sum of all numbers in a series of
# nested arrays raised to the power of their respective nesting levels. Numbers in the outer most array
# should be raised to the power of 1.
def sum_nested_numbers(a, c=0):
    return a ** c if not isinstance(a, list) else sum(sum_nested_numbers(i, c+1) for i in a)

# Given three arrays of integers, return the sum of elements that are common in all three arrays.
from collections import Counter
def common(a,b,c):
    return sum((Counter(a) & Counter(b) & Counter(c)).elements())

# You're playing to scrabble. But counting points is hard.
# You decide to create a little script to calculate the best possible value.
# The function takes two arguments :
# `points` : an array of integer representing for each letters from A to Z the points that it pays
# `words` : an array of strings, uppercase
def get_best_word(points, words):
    return max(range(len(words)), key=lambda i: (sum(points[ord(j)-65] for j in words[i]), -len(words[i]), -i))

# Implement a function that normalizes out of range sequence indexes (converts them
# to 'in range' indexes) by making them repeatedly 'loop' around the array. The function
# should then return the value at that index. Indexes that are not
# out of range should be handled normally and indexes to empty sequences should return undefined/None
# depending on the language.
# For positive numbers that are out of range, they loop around starting at the beginning, so
def norm_index_test(seq, ind):
    return seq[ind % len(seq)] if seq else None

# You are given two strings (st1, st2) as inputs. Your task is to return a string containing the numbers
# in st2 which are not in str1. Make sure the numbers are returned in ascending order. All inputs will be
# a string of numbers.
from collections import Counter
def findAdded(st1, st2):
    return ''.join(sorted((Counter(st2) - Counter(st1)).elements()))

# Given a string of numbers, you must perform a method in which you
# will translate this string into text, based on the below image:
def phone_words(text):
    d = {
        222: 'c',
        22: 'b',
        2: 'a',
        333: 'f',
        33: 'e',
        3: 'd',
        444: 'i',
        44: 'h',
        4: 'g',
        555: 'l',
        55: 'k',
        5: 'j',
        666: 'o',
        66: 'n',
        6: 'm',
        7777: 's',
        777: 'r',
        77: 'q',
        7: 'p',
        888: 'v',
        88: 'u',
        8: 't',
        9999: 'z',
        999: 'y',
        99: 'x',
        9: 'w',
        0: ' ',
        1: ''
    }
    while (text.isdigit()):
        for i in d:
            text = text.replace(str(i), d[i])
    return text

# Dear Coder,
# We at [SomeLargeCompany] have decided to expand on the functionality of our online text editor.
# We have written a new function that accepts a phrase, a word and an array of indexes.
# We want this function to return the phrase, with the word inserted at each of the indexes given by the array.
# However, our current function only gets the first insertion right, but all of the following ones
# are out of place!
# Please fix this for us, and you will be showered with money.
# Yours Sincerely, [SomeLargeCompany]
# Note :
# the indicies are always in range and passed as a sorted array
# note if the index array is empty, just return the initial phrase
def insert_at_indexes(phrase, word, indexes):
    for i in indexes[::-1]:
        phrase = phrase[:i] + word + phrase[i:]
    return phrase

# Define n!! as
# n!! = 1 * 3 * 5 * ... * n if n is odd,
# n!! = 2 * 4 * 6 * ... * n if n is even.
# Hence 8!! = 2 * 4 * 6 * 8 = 384, there is no zero at the end. 30!! has 3 zeros at the end.
# For a positive integer n, please count how many zeros are there at the end of n!!.
import math
def count_zeros_n_double_fact(n):
    c = 0
    if n % 2 == 0:
        n = math.prod([i for i in range(2, n+1, 2)])
        while str(n).endswith('0'):
            c += 1
            n = str(n)[:-1]
        return c
    if n % 2 != 0:
        n = math.prod([i for i in range(1, n+1, 2)])
        while str(n).endswith('0'):
            c += 1
            n = str(n)[:-1]
        return c

# This series of katas will introduce you to basics of doing geometry with computers.
# Point objects have x, y attributes. Triangle objects have attributes a, b, c describing
# their corners, each of them is a Point.
# Write a function calculating area of a Triangle defined this way.
# Tests round answers to 6 decimal places.
def triangle_area(triangle):
    a, b, c = triangle.a, triangle.b, triangle.c
    return round(abs(a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y)) / 2, 6)

# A twin prime is a prime number that is either 2 less or 2 more than another
# prime number—for example, either member of the twin prime pair (41, 43). In other
# words, a twin prime is a prime that has a prime gap of two. Sometimes
# the term twin prime is used for a pair of twin primes; an alternative name for this
# is prime twin or prime pair. (from wiki https://en.wikipedia.org/wiki/Twin_prime)
# Your mission, should you choose to accept it, is to write a function that
# counts the number of sets of twin primes from 1 to n.
# If n is wrapped by twin primes (n-1 == prime && n+1 == prime) then that should
# also count even though n+1 is outside the range.
from gmpy2 import is_prime
def twin_prime(n):
    return sum(is_prime(x) and is_prime(x + 2) for x in range(n))

# The aim of this Kata is to write a function which will reverse the case of all consecutive duplicate
# letters in a string. That is, any letters that occur one after the other and are identical.
# If the duplicate letters are lowercase then they must be set to uppercase, and if
# they are uppercase then they need to be changed to lowercase.
import re
def reverse(s):
    return re.sub(r'(.)\1+', lambda x: x.group().swapcase(), s)

# Following on from Part 1, part 2 looks at some more complicated array contents.
# So let's try filling an array with...
def squares(n):
    return [i**2 for i in range(1, n+1)]
def num_range(n, start, step):
    l = []
    for i in range(n):
        l.append(start)
        start += step
    return l
def rand_range(n, mn, mx):
    from random import randint
    l = []
    for i in range(n):
        l.append(randint(mn, mx))
    return l
def primes(n):
    from gmpy2 import is_prime
    l = []
    c = 1
    while len(l) < n:
        if is_prime(c): l.append(c)
        c += 1
    return l

# In this Kata, we are going to see how a Hash (or Map or dict) can be used to
# keep track of characters in a string.
# Consider two strings "aabcdefg" and "fbd". How many characters do we have to remove from the
# first string to get the second string? Although not the only way to solve this,
# we could create a Hash of counts for each string and see which character counts are different.
# That should get us close to the answer. I will leave the rest to you.
# For this example, solve("aabcdefg","fbd") = 5. Also, solve("xyz","yxxz") = 0, because we
# cannot get second string from the first since the second string is longer.
# More examples in the test cases.
# Good luck!
def solve(a, b):
    return len(a) - len(b) if all(a.count(i) >= b.count(i) for i in set(b)) else 0

# Codewars Weekly has gained popularity in the past months and is receiving lots of fan letters.
# Unfortunately, some of the readers use offensive words and
# the editor wants to keep the magazine family friendly.
# To manage this, you have been asked to implement a censorship algorithm. You will be
# given the fan letter text and a list of forbiddenWords. Your algorithm should replace all occurrences
# of the forbidden words in the text with sequences of asterisks of the same length.
# Be careful to censor only words, no one want to see "classic" spelled as "cl***ic".
def censor_this(text, forbidden_words):
    return ' '.join(i if i.lower() not in forbidden_words else '*'*len(i) for i in text.split())

# Write a function that takes an array/list of numbers and returns a number.
# See the examples and try to guess the pattern:
def even_odd(arr):
    c = 0
    for k, v in enumerate(arr):
        if k % 2: c *= v
        else: c += v
    return c

# Some numbers have the property to be divisible by 2 and 3. Other smaller subset of
# numbers have the property to be divisible by 2, 3 and 5. Another subset with less abundant
# numbers may be divisible by 2, 3, 5 and 7. These numbers have something in common:
# their prime factors are contiguous primes.
# Implement a function that finds the amount of numbers that have the first N primes as factors below
# a given limit.
from gmpy2 import next_prime as np
from math import prod
def count_specMult(n, maxval):
    a, b = 2, []
    while n > 0: b, a, n = b+[a], np(a), n-1
    return maxval // prod(b)

# Complete the function that takes a string as an input, and return a list of
# all the unpaired characters (i.e. they show up an odd number of times in the string), in
# the order they were encountered as an array.
# In case of multiple appearances to choose from, take the last occurence of the unpaired character.
# Notes:
# A wide range of characters is used, and some of them may not render properly in your browser.
# Your solution should be linear in terms of string length to pass the last test.
from collections import Counter
def odd_one_out(s):
    return [k for k, v in Counter(s[::-1]).items() if v % 2][::-1]

# In this Kata, we are going to determine if the count of each of the characters in
# a string can be equal if we remove a single character from that string.
from collections import Counter
def solve(s):
    return any(len(set(Counter(s[:i] + s[i+1:]).values())) == 1 for i in range(len(s)))

# Given a string s and a character c, return an array of integers representing
# the shortest distance from the current character in s to c.
# Notes
# All letters will be lowercase.
# If the string is empty, return an empty array.
# If the character is not present, return an empty array.
def shortest_to_char(s, c):
    if not s or not c:return []
    l = [k for k, v in enumerate(s) if v == c]
    if not l: return []
    return [min(abs(i - j) for j in l) for i in range(len(s))]

# Given an uppercase 9 letter string, letters, find the longest word that can be made with
# some or all of the letters. The preloaded array words (or $words in Ruby) contains
# a bunch of uppercase words that you will have to loop through. Only return the longest word; if there
# is more than one, return the words of the same lengths in alphabetical order. If there are
# no words that can be made from the letters given, return None/nil/null.
def longest_word(w):
    l = []
    for i in sorted(words, key=len)[::-1]:
        if all(w.count(j) >= i.count(j) for j in i): l+=[i]
    if not l: return None
    m = len(l[0])
    return sorted([i for i in l if len(i)==m])

# Alyosha Popovich (Russian folk hero) stroke his sharp sword and cut the head of
# Zmey Gorynych (big Serpent with several heads)! He looked - and lo! - in its place immediately new heads
# appeared, exactly n. He stroke again, and where the second head was, 2*n heads
# appeared! The third time it was 2*3*n new heads, and after fourth swing it was 2*3*4*n heads,
# and so forth. And thus Alyosha decided to call it a day, and instead called a fellow Mage for
# help. While the Mage agreed, he needs to know the exact number of heads that Zmey Gorynych now has.
# The task
# Given the initial number of heads, the heads-count multiplier, and the number of sword-swings,
# calculate how many heads Zmey Gorynych has in the end.
import math
def count_of_heads(initial, n, swings):
    for i in range(1, swings+1):
        initial = initial - 1 + n * math.factorial(i)
    return initial

# Since there are lots of katas requiring you to round numbers to 2 decimal places, you decided to
# extract the method to ease out the process.
# And you can't even get this right!
# Quick, fix the bug before everyone in CodeWars notices that you can't even round a number correctly!
from decimal import Decimal, ROUND_HALF_UP
def round_by_2_decimal_places(n):
    return n.quantize(Decimal('.01'), rounding = ROUND_HALF_UP)

# In this Kata, you will be given an array and your task will be to determine if an array
# is in ascending or descending order and if it is rotated or not.
# Consider the array [1,2,3,4,5,7,12]. This array is sorted in Ascending order.
# If we rotate this array once to the left, we get [12,1,2,3,4,5,7] and twice-rotated
# we get [7,12,1,2,3,4,5]. These two rotated arrays are in Rotated Ascending order.
# Similarly, the array [9,6,5,3,1] is in Descending order, but we can
# rotate it to get an array in Rotated Descending order: [1,9,6,5,3] or [3,1,9,6,5] etc.
# Arrays will never be unsorted, except for those that are rotated as shown above. Arrays
# will always have an answer, as shown in the examples below. Arrays will never contain duplicated elements.
def solve(arr):
    if sorted(arr) == arr: return "A"
    if sorted(arr, reverse=True) == arr: return "D"
    return "RA" if arr[0] > arr[-1] else "RD"

# Write a method that takes a string as an argument and groups
# the number of time each character appears in the string as a hash sorted by the highest number of occurrences.
# The characters should be sorted alphabetically e.g:
from collections import Counter
def get_char_count(seq):
    d = {}
    for k, v in sorted(Counter(i for i in seq.lower() if i.isalnum()).items()):
        d[v] = d.get(v, []) + [k]
    return d

# Given a string str, find the shortest possible string which can
# be achieved by adding characters to the end of initial string to make it a palindrome.
def build_palindrome(w):
    n = 0
    while w[n:] != w[n:][::-1]: n += 1
    return w + w[:n][::-1]

# You are given an integer N. Your job is to figure out how many substrings inside of N divide evenly with N.
# Confused? I'll break it down for you.
# Let's say that you are given the integer '877692'.
def get_count(n):
    w = str(n)
    c = 0
    for i in range(1, len(w)):
        for j in range(len(w) - i + 1):
            s = int(w[j:j+i])
            if s and n % s == 0: c += 1
    return c

# The dot product is usually encountered in linear algebra or scientific computing. It's also
# called scalar product or inner product sometimes:
# In mathematics, the dot product, or scalar product (or sometimes inner product in the context of
# Euclidean space), is an algebraic operation that takes two equal-length sequences of numbers (usually
# coordinate vectors) and returns a single number. Wikipedia
# In our case, we define the dot product algebraically for two vectors
# a = [a1, a2, …, an], b = [b1, b2, …, bn] as
def min_dot(a, b):
    return sum(i * j for (i, j) in zip(sorted(a), sorted(b, reverse = True)))

# You will be given an integer N as input; your task is to return the value of S(Z(N)).
# For example, let N = 3:
def sum_of_sums(x):
    x = x * (x+1) * (x+2) // 6
    return x * (x+1) // 2

# Complete the function which accepts a string and return an array of character(s)
# that have the most spaces to their right and left.
# Notes:
# the string can have leading/trailing spaces - you should not count them
# the strings contain only unique characters from a to z
# the order of characters in the returned array doesn't matter
import re
def loneliest(strng):
    l = [re.match(r'\s*\w\s*', strng.strip()[i:]) for i in range(len(strng))]
    le = max(len(i.group(0)) for i in l if i)
    return [i.group(0).strip() for i in l if i and len(i.group(0)) == le]

# You are asked to write a simple cypher that rotates every character (in range [a-zA-Z], special
# chars will be ignored by the cipher) by 13 chars. As an addition to the
# original ROT13 cipher, this cypher will also cypher numerical digits ([0-9]) with 5 chars.
CHARS = str.maketrans("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", "NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm5678901234")
def ROT135(input):
    return input.translate(CHARS)

# You are provided with a function of the form f(x) = axⁿ, that consists of
# a single term only and 'a' and 'n' are integers, e.g f(x) = 3x², f(x) = 5 etc.
# Your task is to create a function that takes f(x) as the argument and
# returns the result of differentiating the function, that is, the derivative.
def differentiate(x):
    if 'x' not in x: return '0'
    a, n = x.split('x', 2)
    a = 1 if a == '' else -1 if a == '-' else int(a)
    return f"{a}" if n == '' else f"{2*a}x" if n == "^2" else f"{a*int(n[1:])}x^{int(n[1:])-1}"

# The sum of the primes below or equal to 10 is 2 + 3 + 5 + 7 = 17. Find the sum
# of all the primes below or equal to the number passed in.
from gmpy2 import is_prime
def summationOfPrimes(primes):
    return sum(i for i in range(2, primes+1) if is_prime(i))

# X and Y are playing a game. A list will be provided which contains n pairs of strings
# and integers. They have to add the integeri to the ASCII values of the stringi characters. Then
# they have to check if any of the new added numbers is prime or not. If for any character of
# the word the added number is prime then the word will be considered as prime word.
# Can you help X and Y to find the prime words?
from gmpy2 import is_prime
def prime_word(array):
    a = [ord(i) + array[0][1] for i in array[0][0]]
    b = [ord(i) + array[1][1] for i in array[1][0]]
    if len(array) == 3:
        c = [ord(i) + array[2][1] for i in array[2][0]]
    f = [1 if any(is_prime(i) for i in a) else 0, 1 if any(is_prime(i) for i in b) else 0]
    return f if len(array) ==2 else f + [1 if any(is_prime(i) for i in c) else 0]

# Playing ping-pong can be really fun! Unfortunatelly after a long and exciting play you can forget
# who's service turn it is. Let's do something about that!
# Write a function that takes the current score as a string separated by : sign as an only
# parameter and returns "first" or "second" depending on whose service turn it is.
# We're playing old-school, so the rule is that players take turn after every 5 services. That
# is until the score is 20:20 - from that moment each player serves 2 times in his turn.
def service(score):
    c = sum(int(i) for i in score.split(":"))
    return "first" if ((c%10 < 5) if c < 40 else (c%4 < 2)) else "second"

# Create the function off, that receives the nth switch as argument n. The function should return
# an ascending array containing all of the switch numbers that remain off after Bob completes his revenge.
def off(n):
    return [i*i for i in range(1, int(n ** .5) + 1)]

# This is a follow-up from my previous Kata which can be found here:
# http://www.codewars.com/kata/5476f4ca03810c0fc0000098
# This time, for any given linear sequence, calculate the function [f(x)] and return it
# as a function in Javascript or Lambda/Block in Ruby.
def get_function(sequence):
    s = sequence[1] - sequence[0]
    for i in range(1, 5):
        if sequence[i] - sequence[i-1] != s: return "Non-linear sequence"
    return lambda a : s * a + sequence[0]

# In this Kata, you will implement a function count that takes an integer and returns the number of
# digits in factorial(n).
# For example, count(5) = 3, because 5! = 120, and 120 has 3 digits.
# More examples in the test cases.
# Brute force is not possible. A little research will go a long way, as this is a well known series.
# Good luck!
import math
def count(n):
    if (n < 0): return 0
    if (n <= 1): return 1
    x = ((n * math.log10(n / math.e) + math.log10(2 * math.pi * n) /2.0))
    return math.floor(x) + 1

# You will be given
# The distance to my exit (km)
# How fast I am going (kph)
# Information about a lot of other cars
# Their time (relative to me) as I join the freeway. For example,
# -1.5 means they already passed my starting point 1.5 minutes ago
# 2.2 means they will pass my starting point 2.2 minutes from now
# How fast they are going (kph)
# Find what is my "score" as I exit the freeway!
def freeway_game(km, kph, cars):
    t = km / kph
    c = 0
    for k, v in cars:
        d = km - (t - k/60) * v
        if k <= 0: c += d > 0
        else: c -= d < 0
    return c

# The collections module has defaultdict, which gives you a default value for trying to get the value
# of a key which does not exist in the dictionary instead of raising an error. Why not do this for a list?
# Your job is to create a class (or a function which returns an object) called DefaultList.
# The class will have two parameters to be given: a list, and a default value.
# The list will obviously be the list that corresponds to that object. The default value will
# be returned any time an index of the list is called in the code that would normally raise an error
# (i.e. i > len(list) - 1 or i < -len(list)). This class must also support the regular list functions
# extend, append, insert, remove, and pop.
# Because slicing a list never raises an error (slicing a list between two indexes that are not a part
# of the list returns [], slicing will not be tested for.
class DefaultList(list):
    def __init__(self,it, defu):
        super().__init__(it)
        self.default = defu
    def __getitem__(self,i):
        try: return super().__getitem__(i)
        except: return self.default

# Your friend Cody has to sell a lot of jam, so he applied a good 25% discount to all his merchandise.
# Trouble is that he mixed all the prices (initial and discounted), so now he needs your cool coding
# skills to filter out only the discounted prices.
def find_discounted(prices):
    l = [int(n) for n in prices.split()]
    return ' '.join(l.remove(round(i*4/3)) or str(i) for i in l)

# Your task is to complete the function that determines where to replace a zero with a
# one to make the maximum length subsequence.
# Notes:
# If there are multiple results, return the last one:
def replace_zero(arr):
    c, s, i, l = 0, -1, -1, ''.join(map(str, arr)).split('0')
    for a, b in zip(l, l[1:]):
        i += len(a) + 1
        rep = len(a)+len(b)+1
        if c <= rep: s, c = i, rep
    return s

# Consider the prime number 23. If we sum the square of its digits we get: 2^2 + 3^2 = 13,
# then for 13: 1^2 + 3^2 = 10, and finally for 10: 1^2 + 0^2 = 1.
# Similarly, if we start with prime number 7, the sequence is: 7->49->97->130->10->1.
# Given a range, how many primes within that range will eventually end up being 1?
# The upperbound for the range is 50,000. A range of (2,25) means that: 2 <= n < 25.
from gmpy2 import is_prime
def check(n):
    l = []
    while n not in l:
        l += [n]
        n = sum(int(i)**2 for i in str(n))
        if n==1: return True
    return False
def solve(a,b):
    return len([i for i in range(a,b) if is_prime(i) and check(i)])

# There is a common problem given to interviewees in software. It is called FizzBuzz. It works
# as follows: For the numbers between 1 and 100, print fizz if
# it is a multiple of 3 and buzz if it is a mutiple of 5, else print the number itself.
# You are in an interview and they ask you to complete fizzbuzz (which can
# be done in a one-liner in a few langs) and you knock it out of the park.
# Surprised by your ability, the interviewer gives you a harder problem. Given
# a list of coprime numbers, (that is that the g.c.d. of all the numbers == 1) and
# an equally sized list of words. compute its fizzbuzz representation up until the pattern of strings
# repeats itself.
from functools import reduce

def fizzbuzz_plusplus(nums, words):
    return ["".join(b for a, b in zip(nums, words) if not i % a) or i for i in range(1, reduce(lambda a, b: a * b, nums, 1) + 1)]

# For this kata, you are given three points (x1,y1,z1), (x2,y2,z2), and (x3,y3,z3) that lie on
# a straight line in 3-dimensional space. You have to figure out which point lies in between the other two.
# Your function should return 1, 2, or 3 to indicate which point is the in-between one.
def middle_point(x1, y1, z1, x2, y2, z2, x3, y3, z3):
    d = {(x1, y1, z1): 1, (x2, y2, z2): 2, (x3, y3, z3): 3}
    return d[sorted(d)[1]]

# The goal of this Kata is to return the greatest distance of index positions between
# matching number values in an array or 0 if there are no matching values.
# Example: In an array with the values [0, 2, 1, 2, 4, 1] the greatest index distance is between
# the matching '1' values at index 2 and 5. Executing greatestDistance against this array would
# return 3. (i.e. 5 - 2)
def greatest_distance(arr):
    return max(k - arr.index(v) for k, v in enumerate(arr))

# Return the index of the array element that you ended up on at the end of the game.
def snakes_and_ladders(board, dice):
    c = 0
    for i in dice:
        if c + i < len(board): c += i + board[c + i]
    return c

# Scheduling is how the processor decides which jobs (processes) get to use the processor and for
# how long. This can cause a lot of problems. Like a really long process taking the
# entire CPU and freezing all the other processes. One solution is Round-Robin, which today you will be
# implementing.
# Round-Robin works by queuing jobs in a First In First Out fashion, but the
# processes are only given a short slice of time. If a processes is not finished in that time
# slice, it yields the proccessor and goes to the back of the queue.
def roundRobin(jobs, slice, index):
    c = 0
    while True:
        for i in range(len(jobs)):
            cc = min(jobs[i], slice)
            jobs[i] -= cc
            c += cc
            if i == index and jobs[i] == 0: return c

# The principal of a school likes to put challenges to the students related with finding
# words of certain features. One day she said: "Dear students, the challenge for today
# is to find a word that has only one vowel and seven consonants but cannot have the
# letters "y" and "m". I'll give a special award for the first student that
# finds it." One of the students used his dictionary and spent all the night without sleeping,
# trying in vain to find the word. The next day, the word had not been found yet.
# This student observed that the principal has a pattern in the features for the wanted words:
# The word should have n vowels, may be repeated, for example: in "engineering", n = 5.
# The word should have m consonants, may be repeated also: in "engineering", m = 6.
# The word should not have some forbidden letters (in an array), forbid_letters
# You will be provided with a list of words, WORD_LIST(python/crystal),
# wordList(javascript), wordList (haskell), $word_list(ruby), and you have to create the function,
# wanted_words(), that receives the three arguments in the order given above, wanted_words(n, m,
# forbid_list)and output an array with the word or an array, having the words in
# the order given in the pre-loaded list, in the case of two or more words were found.
def wanted_words(n, m, f):
    l = []
    v, c = 0, 0
    vow = 'aeiou'
    con = 'bcdfghjklmnpqrstvwxyz'
    for i in WORD_LIST:
        if sum(j in vow for j in i) == n and sum(j in con for j in i) == m and all(j not in f for j in i): l.append(i)
    return l

# An eccentric chessboard maker likes to create strange N x N chessboards.
# Instead of making all the rows and the columns on his chessboards the same size, he
# likes to make chessboards with row and columns of varying sizes:
def white_black_areas(cs, rs):
    r, rc = sum(rs[1::2]), sum(rs[::2])
    c, cs = sum(cs[1::2]), sum(cs[::2])
    return (cs * rc + c * r, r * cs + rc * c)

# We know that some numbers can be split into two primes. ie. 5 = 2 + 3, 10 = 3 + 7. But
# some numbers are not. ie. 17, 27, 35, etc..
# Given a positive integer n. Determine whether it can be split into two primes.
# If yes, return the maximum product of two primes. If not, return 0 instead.
from gmpy2 import is_prime
def prime_product(n):
    return next((i*(n-i) for i in range(n>>1,1,-1) if is_prime(i) and is_prime(n-i)),0)

# Create a function which checks if a given number n can be written as the sum of two cubes in
# two different ways: n = a³+b³ = c³+d³. All the numbers a, b, c and d should be different and greater than 0.
def has_two_cube_sums(n):
    l = [i**3 for i in range(1, int((n)**(1./3.)) + 1)]
    return sum([(n != 2*i) and ((n-i) in l) for i in l]) > 3

# Consider an array that has no prime numbers, and none of its elements has any prime digit.
# It would start with: [1,4,6,8,9,10,14,16,18,40,44..].
# 12 and 15 are not in the list because 2 and 5 are primes.
# You will be given an integer n and your task will be return the number
# at that index in the array. For example:
from gmpy2 import is_prime
def solve(n):
    l = []
    c = 1
    while len(l) <= n:
        if not is_prime(c) and all(not is_prime(int(i)) for i in str(c)): l.append(c)
        c += 1
    return l[n]

# The numbers 6, 12, 18, 24, 36, 48 have a common property. They
# have the same two prime factors that are 2 and 3.
# If we see their prime factorization we will see it more clearly:
from math import log

def highest_biPrimefac(a, b, m):
    l = []
    for i in range(1, int(log(m, b)) + 1):
        c = int(round(log(m / b**i, a), 9))
        if c: l.append([a**c * b**i, c, i])
    return max(l)

# Dan, president of a Large company could use your help. He wants to implement a system that
# will switch all his devices into offline mode depending on his meeting schedule. When he's at a meeting
# and somebody texts him, he wants to send an automatic message informing that he's currently
# unavailable and the time when he's going to be back.;
def check_availability(schedule, current_time):
    for i in schedule:
        if i[0] <= current_time < i[1]: return i[1]
    return True

# Some numbers are more important to get right during data entry than others: a common example is product codes.
# To reduce the possibility of mistakes, product codes can be crafted in such a way that simple errors
# are detected. This is done by calculating a single-digit value based on the product number,
# and then appending that digit to the product number to arrive at the product code.
# When the product code is checked, the check digit value is stripped off and recalculated. If
# the supplied value does not match the recalculated value, the product code is rejected.
# A simple scheme for generating self-check digits, described here, is called Modulus 11 Self-Check.
def add_check_digit(number):
    l = [2, 3, 4, 5, 6, 7]
    s = sum(x*y for x,y in zip(map(int, number[::-1]), l * (len(number) // 6 + 1))) % 11
    return number + ('0' if s == 0 else 'X' if s == 1 else str(11 - s))

# Consider an array containing cats and dogs. Each dog can catch only one cat, but cannot
# catch a cat that is more than n elements away. Your task will be to return
# the maximum number of cats that can be caught.
def solve(arr, n):
    d = [i for i, x in enumerate(arr) if x == 'D']
    c = {i for i, x in enumerate(arr) if x == 'C'}
    s = 0
    while d and c:
        dog = d.pop()
        cat = max((i for i in c if abs(dog - i) <= n), default=-1)
        if cat >= 0:
            s += 1
            c.remove(cat)
    return s

# If string has more than one neighboring dashes(e.g. --) replace they with one dash(-).
# Dashes are considered neighbors even if there is some whitespace between them.
import re
def replace_dashes_as_one(word):
    return re.sub(r'-[ -]+-|-+',r'-', word)

# Some letters in the input string are representing a written-out digit. Some of the
# letters may randomly shuffled. Your task is to recover them all.
# Note that:
# Only consecutive letters can be used. "OTNE" cannot be recovered to 1!
# Every letter has to start with an increasing index.. "ONENO" results to 11, because
# the E can be used two times. Endless loops are not possible!
# If there are letters in the string, which don't create a number you can ignore them.
# If no digits can be found, return "No digits found"
# Take care about the order! "ENOWT" will be recovered to 12 and not to 21.
# The input string consists only UpperCase letters
def recover(st):
    l = []
    for i in range(len(st)):
        for k, v in alph.items():
            if sorted(k) == sorted(st[i:i+len(k)]): l.append(v)
    return ''.join(map(str, l)) or "No digits found"

# You will receive a string consisting of lowercase letters, uppercase letters and digits as input. Your
# task is to return this string as blocks separated by dashes ("-"). The elements of a block should be sorted
# with respect to the hierarchy listed below, and each block cannot contain multiple instances of the same
# character. Elements should be put into the first suitable block.
from collections import Counter
def blocks(w):
    s = lambda c: (c.isdigit(), c.isupper(), c)
    l, c = [], Counter(w)
    while c:
        i = ''.join(sorted(c, key=s))
        l.append(i)
        c = c - Counter(i)
    return '-'.join(l)

# Given an input array (arr) of positive integers, the objective is to return an
# output array where each index represents the amount of times an element
# appeared (frequency) in the input array.
# More specifically, the element at each index of the output array will be
# an array (bucket) containing integers that appeared index-amount-of-times.
# Otherwise, slot nulls (JavaScript, Java), None's (Python) nils (Ruby), or
# NULL's (C/C++) where appropriate. A valid array will always be provided.
from collections import Counter
def bucketize(*arr):
    c = {i: sorted([k for k, v in Counter(arr).items() if v == i]) for i in Counter(arr).values()}
    return [c[i] if i in c else None for i in range(len(arr) + 1)]

# Imagine you are given a positive integer, n, then:
# if n is even, calculate: n / 2
# if n is odd, calculate: 3 * n + 1
# Repeat until your answer is 1. The Collatz conjecture states that performing this operation
# repeatedly, you will always eventually reach 1.
# You can try creating Collatz sequences with this kata. For further information, see the wiki page.
##Now! Your task:
# Given an array of positive integers, return the integer whose Collatz sequence is the longest.
def longest_collatz(input_array):
    def iseven(n):
        return n / 2
    def isodd(n):
        return 3 * n + 1
    l = []
    c = 0
    for i in input_array:
        while i != 1:
            if i % 2 == 0:
                c += 1
                i = iseven(i)
            elif i % 2 != 0:
                c += 1
                i = isodd(i)
        l.append(c)
        c = 0
    return input_array[l.index(max(l))]

# We need the function sec_deg_solver()/secDegSolver(), that accepts three arguments,
# a, b and c, the coefficients of the above equation.
# The outputs of the function may vary depending on the values of coefficients a,
# b and c, according to the following situations. (used values as examples only):
import math
def sec_deg_solver(a, b, c):
    if a == 0:
        if b != 0 and c != 0: return f'It is a first degree equation. Solution: {round(-c/float(b), 10)}'
        elif a == 0 and b == 0 and c == 0: return 'The equation is indeterminate'
        elif a == 0 and b == 0 and c != 0: return 'Impossible situation. Wrong entries'
        elif a == 0 and c == 0 and b != 0: return 'It is a first degree equation. Solution: 0.0'
    elif a != 0:
        d = b**2 - 4 * a * c
        if d < 0: return 'There are no real solutions'
        x1 = round((-b - math.sqrt(d)) / (2 * a), 10)
        x2 = round((-b + math.sqrt(d)) / (2 * a), 10)
        if x2 < x1:
            t = x1
            x1 = x2
            x2 = t
        if d == 0: return f"It has one double solution: {max(x1, x2)}"
        elif d > 0: return f"Two solutions: {min(x1, x2)}, {max(x1, x2)}"

# You're given an array of positive integers arr, and an array guide
# of the same length. Sort array arr using array guide by the following rules:
def sort_by_guide(arr, guide):
    l = iter(sorted((y,x) for x,y in zip(arr, guide) if y > 0))
    return [next(l)[1] if b > 0 else a for a, b in zip(arr, guide)]

# You are a lonely frog.
# You live on a coordinate axis.
# The meaning of your life is to jump and jump..
def jump_to(x, y):
    c = 0
    while y!=x:
        if y % 2 == 0 and y / 2 >= x: y /= 2
        else: y-=1
        c+=1
    return c

# Every Turkish citizen has an identity number whose validity can be checked by these set of rules:
# It is an 11 digit number
# First digit can't be zero
# Take the sum of 1st, 3rd, 5th, 7th and 9th digit and multiply it by 7. Then subtract the sum of
# 2nd, 4th, 6th and 8th digits from this value. Modulus 10 of the result should be equal to 10th digit.
# Sum of first ten digits' modulus 10 should be equal to eleventh digit.
def check_valid_tr_number(n):
    if not isinstance(n, int) or not len(str(n)) == 11: return False
    l = [int(i) for i in str(n)]
    return (sum(l[:9:2])*7 - sum(l[1:9:2])) % 10 == l[9] and sum(l[:10]) % 10 == l[10]

# In this kata you're given an n x n array and you're expected to traverse the
# elements diagonally from the bottom right to the top left.
def diagonal(arr):
    l = sorted(((i, j) for j in range(len(arr)) for i in range(len(arr))), key=sum)[::-1]
    return [arr[i][j] for i, j in l]

# Given a sorted array of numbers, return the summary of its ranges.
def summary_ranges(nums):
    nums.append(float("inf"))
    i, l = nums[0], []
    for a, b in zip(nums, nums[1:]):
        if b - a > 1:
            l.append(str(i) if i == a else f"{i}->{a}")
            i = b
    return l

# The total sum of the numbers in the triangle, up to the 5th line
# included, is 225, part of it, 144, corresponds to the total sum of the even terms
# and 81 to the total sum of the odd terms.
# Create a function that may output an array with three results for each value of n.
def mult_triangle(n):
    s, o = (n * (n + 1) / 2)**2, ((n + 1) // 2)**4
    return [s, s - o, o]

# Write that given an array of numbers >= 0, will arrange them such that they form the biggest number.
def biggest(nums):
    return str(int(''.join(sorted(map(str,nums),key=lambda x:3*x)[::-1])))

# The prime number sequence starts with: 2,3,5,7,11,13,17,19.... Notice that 2 is in position one.
# occupies position two, which is a prime-numbered position. Similarly, 5, 11 and 17 also
# occupy prime-numbered positions. We shall call primes such as 3,5,11,17 dominant primes
# because they occupy prime-numbered positions in the prime number sequence. Let's call this listA.
# As you can see from listA, for the prime range range(0,10), there are
# only two dominant primes (3 and 5) and the sum of these primes is: 3 + 5 = 8.
# Similarly, as shown in listA, in the range (6,20), the dominant
# primes in this range are 11 and 17, with a sum of 28.
# Given a range (a,b), what is the sum of dominant primes within that range?
# Note that a <= range <= b and b will not exceed 500000.
from gmpy2 import next_prime as np, is_prime as ip
def solve(a,b):
    c, l, g = 1, [], 0
    while c<=b:
        c, g = np(c), g+1
        if c>=a and c<=b and ip(g): l.append(c)
    return sum(l)

# Calculus class...is awesome! But you are a programmer with no time for mindless repetition. Your
# teacher spent a whole day covering differentiation of polynomials, and by the time the bell rang,
# you had already conjured up a program to automate the process.
def diff(poly):
    return [k*v for k,v in enumerate(poly[::-1]) if k][::-1]

# The built-in print function for Python class instances is not very entertaining.
# In this kata, we will implement a function show_me(instance) that takes an instance as parameter
# and returns the string "Hi, I'm one of those (classname)s! Have a look at
# my (attrs)." , where (classname) is the class name and (attrs) are the class's attributes.
# If (attrs) contains only one element, just write it. For more than one element (e.g. a, b, c), it
# should list all elements sorted by name in ascending order (e.g. "... look at my a, b and c.").
def show_me(inst):
    name = inst.__class__.__name__
    atts = ' and'.join(', '.join(sorted(i for i in inst.__dict__)).rsplit(',', 1))
    return "Hi, I'm one of those {}s! Have a look at my {}.".format(name, atts)

# The number 1035 is the smallest integer that exhibits a non frequent property: one its multiples,
# 3105 = 1035 * 3, has its same digits but in different order, in other words, 3105, is one
# of the permutations of 1035.
# The number 125874 is the first integer that has this property when the
# multiplier is 2, thus: 125874 * 2 = 251748
# Make the function search_perm_mult(), that receives an upper bound, n_max and a factor k
# and will output the amount of pairs bellow n_max that are permuted when an integer of this
# range is multiplied by k. The pair will be counted if the multiple is less than n_max, too
from collections import Counter
def search_perm_mult(n_max, k):
    return sum(Counter(str(i)) == Counter(str(i * k)) for i in range(1035, n_max // k))

# Your goal is to create a function instrumental() which returns the valid form
# of a valid Hungarian word w in instrumental case i. e. append the correct
# suffix -vel or -val to the word w based on vowel harmony rules.
def instrumental(word):
    d = {"e": u"é", "i": u"í", u"ö": u"ő", u"ü": u"ű", "a": u"á", "o": u"ó", "u": u"ú"}
    for i in word[::-1]:
        if i in u"aáoóuú":
            suf = "val"
            break
        elif i in u"eéiíöőüű":
            suf = "vel"
            break
    if i == word[-1]: return word[:-1] + d.get(i, word[-1]) + suf
    if word[-2:] in ("sz", "zs", "cs"): word = word[:-1] + word[-2:]
    else: word += word[-1]
    return word + suf[1:]

# A runner, who runs with base speed s with duration t will cover a distances d: d = s * t
# However, this runner can sprint for one unit of time with double speed s * 2
# After sprinting, base speed s will permanently reduced by 1, and for next one unit of
# time runner will enter recovery phase and can't sprint again.
# Your task, given base speed s and time t, is to find the maximum possible distance d.
def solution(s, t):
    c = min((t-1)//2, s//3)
    return t*s + (c+1)*s - 3*(c+1)*c//2 if t else 0

# Related to MrZizoScream's Product Array kata. You might want to solve that one first :)
# This is an adaptation of a problem I came across on LeetCode.
# Given an array of numbers, your task is to return a new array
# where each index (new_array[i]) is equal to the product of
# the original array, except for the number at that index (array[i]).
from functools import reduce
la = lambda x: reduce(lambda a, b:a*b, x)
def product_sans_n(N):
    l, z = len(N), N.count(0)
    if z > 1: return l*[0]
    if z == 1: i = N.index(0); return [0]*(i)+[la(N[:i])*la(N[i+1:])]+[0]*(l-i-1)
    p = la(N);               return [p//i for i in N]

# You are given an array of integers arr that representing coordinates of obstacles situated on a straight line.
# Assume that you are jumping from the point with coordinate 0 to the
# right. You are allowed only to make jumps of the same length represented by some integer.
# Find the minimal length of the jump enough to avoid all the obstacles.
def avoid_obstacles(a):
    for i in range(2, max(a) + 2):
        if all(j % i != 0 for j in a): return i

# In this Kata, two groups of monsters will attack each other, and your job
# is to find out who wins. Each group will have a stat for each of the following:
# number of units, hitpoints per unit, damage per unit, and monster type.
# If you are not familiar with the game, just think of each group as standing in
# a line so that when they are attacked the unit at the front of the line takes the
# hit before the others, and if he dies the remaining damage will hit the next unit
# and so on. Therefore multiple units (or even the whole group) can die in one attack.
# Each group takes turns attacking, and does so until only one remains. In this kata,
# the first entry in the input array is the first to attack.
from math import ceil
def who_would_win(m1, m2):
    m1['allhit'] = m1['hitpoints'] * m1['number']
    m2['allhit'] = m2['hitpoints'] * m2['number']
    while True:
        m2['allhit'] = m2['allhit'] - m1['number'] * m1['damage']
        m2['number'] = ceil(m2['allhit'] / m2['hitpoints'])
        if not m2['number'] > 0: return f"{m1['number']} {m1['type']}(s) won"
        m1['allhit'] = m1['allhit'] - m2['number'] * m2['damage']
        m1['number'] = ceil(m1['allhit'] / m1['hitpoints'])
        if not m1['number'] > 0: return f"{m2['number']} {m2['type']}(s) won"

# You are stacking some boxes containing gold weights on top of each other. If a box contains
# more weight than the box below it, it will crash downwards and combine their weights.
# e.g. If we stack [2] on top of [1], it will crash downwards and become a single box of weight [3].
def crashing_weights(weights):
    l = [0] * len(weights[0])
    for i in weights:
        l = [b if a <= b else a+b for a,b in zip(l, i)]
    return l

# The Condi (Consecutive Digraphs) cipher was introduced by G4EGG (Wilfred Higginson) in 2011.
# The cipher preserves word divisions, and is simple to describe and encode,
# but it's surprisingly difficult to crack.
def encode(message, key, shift, encode=True):
    LOWER = "abcdefghijklmnopqrstuvwxyz"
    key = sorted(LOWER, key=f"{key}{LOWER}".index)
    l = []
    for j in message:
        if j in key:
            i = key.index(j)
            j = key[(i + shift) % 26]
            shift = i + 1 if encode else -(key.index(j) + 1)
        l.append(j)
    return "".join(l)

def decode(message, key, shift):
    return encode(message, key, -shift, encode=False)

# Write a function that receives a non-negative integer n ( n >= 0 ) and returns the
# next higher multiple of five of that number, obtained by concatenating the shortest
# possible binary string to the end of this number's binary representation.
def next_multiple_of_five(n):
    s = n % 5
    if n == 0:return 5
    elif s == 0:c = '0'
    elif s == 1:c = '01'
    elif s == 2:c = '1'
    elif s == 3:c = '11'
    elif s == 4:c = '011'
    return int(bin(n)[2:]+c,2)

# You are given an array that of arbitrary depth that needs to be nearly flattened
# into a 2 dimensional array. The given array's depth is also non-uniform,
# so some parts may be deeper than others.
# All of lowest level arrays (most deeply nested) will contain only integers and
# none of the higher level arrays will contain anything but other arrays. All arrays given will
# be at least 2 dimensional. All lowest level arrays will contain at least one element.
# Your solution should be an array containing all of the lowest level arrays and only
# these. The sub-arrays should be ordered by the smallest element within each, so [1,2]
# should preceed [3,4,5]. Note: integers will not be repeated.
def near_flatten(a):
    l = []
    for i in a:
        if isinstance(i[0], int): l.append(i)
        else: l.extend(near_flatten(i))
    return sorted(l)

# Jump is a simple one-player game:
# You are initially at the first cell of an array of cells containing non-negative integers;
# At each step you can jump ahead in the array as far as the integer at the current cell, or any smaller
# number of cells. You win if there is a path that allows you to jump from one cell
# to another, eventually jumping past the end of the array, otherwise you lose.
def can_jump(arr):
    if arr[0] == 0 or len(arr) == 1:return False
    if arr[0] >= len(arr):return True
    for i in range(1, arr[0] +1):
        if can_jump(arr[i:]):return True
    return False

# In this Kata, you will be given two integers n and k and your task is to
# remove k-digits from n and return the lowest number possible, without changing the order
# of the digits in n. Return the result as a string.
# Let's take an example of solve(123056,4). We need to remove 4 digits from 123056
# and return the lowest possible number. The best digits to remove are (1,2,3,6)
# so that the remaining digits are '05'. Therefore, solve(123056,4) = '05'.
# Note also that the order of the numbers in n does not change: solve(1284569,2) = '12456', because
# we have removed 8 and 9.
from itertools import combinations
def solve(n, c):
    return ''.join(min(combinations(str(n), len(str(n))-c)))

# Given an x and y find the smallest and greatest numbers above and below
# a given n that are divisible by both x and y.
from math import gcd
def greatest(x, y, n):
    c = (x * y) // gcd(x, y)
    return (n // c) * c if (n // c) * c < n else 0
def smallest(x, y, n):
    c = (x * y) // gcd(x, y)
    return c + (n // c) * (c)

# You are given three non negative integers a, b and n, and making
# an infinite sequence just like fibonacci sequence, use the following rules:
# step 1: use ab as the initial sequence.
# step 2: calculate the sum of the last two digits of the sequence, and append it to the end of sequence.
# repeat step 2 until you have enough digits
# Your task is to complete the function which returns the nth digit (0-based) of the sequence.
def find(a,b,n):
    s = str(a) + str(b)
    if n > 20: n = n % 20 + 20
    while len(s) <= n:
        ns = int(s[-1]) + int(s[-2])
        s = s + str(ns)
    return int(s[n])

# A palindrome is a series of characters that read the same forwards as backwards such
# as "hannah", "racecar" and "lol".
# For this Kata you need to write a function that takes a string of characters and returns
# the length, as an integer value, of longest alphanumeric palindrome that could be made by combining
# the characters in any order but using each character only once. The function should not be case sensitive.
from collections import Counter
def longest_palindrome(s):
    co = Counter(filter(str.isalnum, s.lower()))
    return sum(v // 2 * 2 for v in co.values()) + any(v % 2 for v in co.values())

# Write a function battle(player1, player2) that takes in 2 arrays of creatures. Each players' creatures battle
# each other in order (player1[0] battles the creature in player2[0]) and so on.
# If one list of creatures is longer than the other, those creatures are considered unblocked, and
# do not battle.
# Your function should return an object (a hash in Ruby) with the keys player1
# and player2 that contain the power and toughness of the surviving creatures.
def battle(p1, p2):
    l1,l2 =p1[:], p2[:]
    for i,j in zip(p1, p2):
        if i[0]>=j[1] : l2.remove(j)
        if j[0]>=i[1] : l1.remove(i)
    return {'player1':l1,'player2':l2}

# In Python: Write a function calc_fuel that calculates the minimum amount
# of fuel needed to produce a certain number of iron ingots. This function should
# return a dictionary of the form
def calc_fuel(n):
    c = n * 11
    return {"lava":c//800, "blaze rod":(c%800)//120, "coal":((c%800)%120)//80, "wood":(((c%800)%120)%80)//15, "stick":(((c%800)%120)%80)%15}

# Write a generator sequence_gen ( sequenceGen in JavaScript) that, given the first terms of a
# sequence will generate a (potentially) infinite amount of terms, where each
# subsequent term is the sum of the previous x terms where x is the amount of
# initial arguments (examples of such sequences are the Fibonacci, Tribonacci and Lucas number sequences).
def sequence_gen(*args):
    l = list(args)
    while True:
        yield l[0]
        l = l[1:] + [sum(l)]

# You're part of a team porting MS Paint into the browser and currently
# working on a new UI component that allows user to control the canvas zoom level.
# According to the wireframes delivered to you in PowerPoint format the user should be able to
# cycle through specified zoom levels by clicking a button in the UI repeatedly. The
# reverse direction should work with shift key held.
# A new function is needed to support this behavior, so you alt-tab to Visual Studio and get to work.
def cycle(d, v, c):
    if c not in v: return None
    l = v + v
    return v[v.index(c) + d] if v.index(c) + d <= len(v)-1 else l[v.index(c) + d]

# Goldbach's conjecture is amongst the oldest and well-known unsolved mathematical problems out
# there. In correspondence with Leonhard Euler in 1742, German mathematician Christian Goldbach
# made a conjecture stating that:
# "Every even integer greater than 2 can be written as the sum of two primes"
# which is known today as the (strong) Goldbach's conjecture.
# Even though it's been thoroughly tested and analyzed and seems to be true, it hasn't been
# proved yet (thus, remaining a conjecture.)
# Your task is to implement the function in the starter code, taking into account the following:
# If the argument isn't even and greater than two, return an empty array/tuple.
# For arguments even and greater than two, return a two-element array/tuple with two prime
# numbers whose sum is the given input.
# The two prime numbers must be the farthest ones (the ones with the greatest difference)
# The first prime number must be the smallest one.
from gmpy2 import is_prime
def check_goldbach(n):
    if n <= 2 or n % 2 != 0: return []
    l = [i for i in range(2, n) if is_prime(i)]
    for i in l:
        for j in l:
            if i + j == n: return [i, j]

# Given an integer n, find two integers a and b such that:
# A) a >= 0 and b >= 0
# B) a + b = n
# C) DigitSum(a) + Digitsum(b) is maximum of all possibilities.
# You will return the digitSum(a) + digitsum(b).
def solve(n):
    c = int('0' + '9' * (len(str(n)) - 1))
    return sum(int(i) for i in str(c) + str(n - c))

# Consider the number 1176 and its square (1176 * 1176) = 1382976. Notice that:
# the first two digits of 1176 form a prime.
# the first two digits of the square 1382976 also form a prime.
# the last two digits of 1176 and 1382976 are the same.
# Given two numbers representing a range (a, b), how many numbers satisfy this
# property within that range? (a <= n < b)
def solve(a, b):
    l = set([str(i) for i in range(3, 100) if all(i % j != 0 for j in [2] + list(range(3, int(i ** 0.5)+1, 2)))])
    return sum(1 for i in range(max(a, 1000), b) if i % 100 == i*i % 100 and str(i)[:2] in l and str(i*i)[:2] in l)

# Help a fruit packer sort out the bad apples.
# There are 7 varieties of apples, all packaged as pairs and stacked in a fruit box. Some
# of the apples are spoiled. The fruit packer will have to make sure
# the spoiled apples are either removed from the fruit box or replaced. Below is the breakdown:
# Apple varieties are represented with numbers, 1 to 7
# A fruit package is represented with a 2 element array [4,3]
# A fruit package with one bad apple, or a bad package, is represented with [2,0] or [0,2]
# A fruit package with two bad apples, or a rotten package, is represented with [0,0]
def bad_apples(a):
    l, s = [], []
    for i, j in enumerate(a):
        if i not in s and sum(j) != 0:
            if 0 in j:
                c = next((k for k in range(i+1,len(a))if 0 in a[k]and sum(a[k])!=0), 0)
                if c:
                    su = [j[0]or j[1],a[c][0]or a[c][1]]
                    s.append(c)
                    l.append(su)
            else : l.append(j)
    return l

# Write a method named getExponent(n,p) that returns the largest integer
# exponent x such that px evenly divides n. if p<=1 the method should return
# null/None (throw an ArgumentOutOfRange exception in C#).
def get_exponent(n, p):
    if p > 1:
        c = 0
        while not n % p:
            c += 1
            n //= p
        return c

# In input string word(1 word):
# replace the vowel with the nearest left consonant.
# replace the consonant with the nearest right vowel.
# P.S. To complete this task imagine the alphabet is a circle (connect the first and last element of
# the array in the mind). For example, 'a' replace with 'z', 'y' with 'a', etc.(see below)
def replace_letters(word):
    return word.translate(str.maketrans('abcdefghijklmnopqrstuvwxyz', 'zeeediiihooooonuuuuutaaaaa'))

# In genetic algorithms, a crossover allows 2 chromosomes to exchange part of their genes.
# For more details, you can visit these wikipedia links : Genetic algorithm and Crossover.
# A chromosome is represented by a list of genes.
# Consider for instance 2 chromosomes xs (with genes [x,x,x,x,x,x]) and ys (with genes [y,y,y,y,y,y])
def crossover(ns, xs, ys):
    for x in sorted(set(ns)): xs, ys = xs[:x] + ys[x:], ys[:x] + xs[x:]
    return xs, ys

# Given a string that contains only letters, you have to find out the number of unique
# strings (including the string itself) that can be produced by re-arranging
# the letters of the string. Strings are case insensitive.
# HINT: Generating all the unique strings and calling length on that isn't
# a great solution for this problem. It can be done a lot faster...
from collections import Counter
from math import factorial, prod
def uniq_count(string: str) -> int:
    return factorial(len(string)) // prod(map(factorial, Counter(string.upper()).values()))

# The integer 64 is the first integer that has all of its digits even and furthermore, is a perfect square.
# The second one is 400 and the third one 484.
# Give the numbers of this sequence that are in the range [a,b] (both values inclusive)
def even_digit_squares(a, b):
    return [i**2 for i in range(int(a**0.5)+bool(a**0.5 % 1), int(b**0.5)+1) if not any(int(d) % 2 for d in str(i**2))]

# You're operating behind enemy lines, but your decryption device took a bullet and no longer
# operates. You need to write a code to unscramble the encrypted messages coming
# in from headquarters. Luckily, you remember how the encryption algorithm works.
# Each message you receive is a single string, with the blocks for each letter separated by
# a space. The blocks encoding the characters are made up of seemingly random characters and are
# of a variable length. For example, a two character word might look like:
def decrypt(code):
    return ''.join(' abcdefghijklmnopqrstuvwxyz'[sum(int(i) for i in j if i.isdigit()) % 27] for j in code.split())

# Let's call product(x) the product of x's digits. Given an array of integers a,
# calculate product(x) for each x in a, and return the number of distinct results you get.
import math
def unique_digit_products(a):
    l = []
    for i in a:
        s = math.prod(int(j) for j in str(i))
        if s != i and s not in l: l.append(s)
    return len(l)

# Given a hash of letters and the number of times they occur,
# recreate all of the possible anagram combinations that could be created using all of
# the letters, sorted alphabetically.
# The inputs will never include numbers, spaces or any special characters, only lowercase letters a-z.
import itertools
def get_words(hash):
    s = ''.join(k * v for k, v in hash.items() for v in v)
    return sorted({''.join(i) for i in itertools.permutations(s)})

# You are given a string s. It's a string consist of letters, numbers or symbols.
# Your task is to find the Longest substring consisting of unique characters in s, and return the length of it.
def longest_substring(s : str) -> int:
    f, d, co = 0, {}, 0
    for i,c in enumerate(s):
        if c in d and d[c] >= f: f, co =  d[c]+1, max(co, i-f)
        d[c] = i
    return max(co, len(s)-f)

# In this Kata, you will be given a list of strings and your task will be
# to find the strings that have the same characters and return the sum of their positions as follows:
def solve(a):
    a, b, l = [set(i) for i in a], [], []
    for i in a:
        if i not in b:b.append(i)
    for i in b:
        if a.count(i)>1:l.append(sum(j for j,k in enumerate(a) if k==i))
    return sorted(l)

# You have two sorted arrays a and b, merge them to form new array of unique items.
# If an item is present in both arrays, it should be part of the resulting array if
# and only if it appears in both arrays the same number of times.
def merge_arrays(a, b):
    return sorted([i for i in set(a+b) if a.count(i)==b.count(i) or a.count(i)*b.count(i)==0])

#Given an array of integers, remove the n smallest.
# If there are multiple elements with the same value, remove the ones with
# a lower index first. If n is greater than the length of the array/list, return
# an empty list/array. If n is zero or less, return the original array/list.
# Don't change the order of the elements that are left.
def remove_smallest(n, a):
    b = a[::]
    while n>0 and b: b.remove(min(b)); n -= 1
    return b

# Binary with 0 and 1 is good, but binary with only 0 is even better! Originally, this
# is a concept designed by Chuck Norris to send so called unary messages.
# Can you write a program that can send and receive this messages?
from itertools import groupby
def send(s):
    c = ''.join('{:07b}'.format(ord(x)) for x in s)
    return ' '.join('{} {}'.format('0'*(2-int(k)), ''.join('0' for _ in v)) for k,v in groupby(c))

def receive(s):
    s = s.split()
    c = ''.join(str(len(s[k]) % 2) * len(s[k+1]) for k in range(0, len(s), 2))
    return ''.join(chr(int(c[k:k+7], 2)) for k in range(0, len(c), 7))

# Write
# function wordStep(str)
# that takes in a string and creates a step with that word.
def word_step(s):
    wo = s.split(" ")
    l, h = (sum(len(j) - 1 for j in wo[i::2]) + 1 for i in range(2))
    arr = [[" " for i in range(l)] for j in range(h)]
    l = [0, 0]
    for i, w in enumerate(wo):
        for j, c in enumerate(w):
            l[i % 2] += 1 if j else 0
            arr[l[1]][l[0]] = c
    return arr

# Write a function which outputs the positions of matching bracket pairs. The output should be a dictionary with
# keys the positions of the open brackets '(' and values the corresponding positions of the closing brackets ')'.
def bracket_pairs(string):
    d, l = {}, []
    for k, v in enumerate(string):
        if v == '(':l.append(k)
        elif v == ')':
            if not l:return False
            d[l.pop()] = k
    return False if l else d

# In another Kata I came across a weird sort function to
# implement. We had to sort characters as usual ( 'A' before 'Z' and 'Z' before 'a' ) excpt
# that the numbers had to be sorted after the letters ( '0' after 'z') !!!
# (After a couple of hours trying to solve this unusual-sorting-kata I
# discovered final tests used **usual** sort (digits **before** letters :-)
# So, the unusualSort/unusual_sort function you'll have to code will sort letters as usual,
# but will put digits (or one-digit-long numbers ) after letters.
def unusual_sort(array):
    return sorted(array, key=lambda _: (str(_).isdigit(), str(_), -isinstance(_, int)))

# Consider a string of lowercase Latin letters and space characters (" ").
# First, rearrange the letters in each word alphabetically.
# And then rearrange the words in ascending order of the sum of their characters' ASCII values.
# If two or more words have the same ASCII value, rearrange them by their length in ascending
# order; If their length still equals to each other, rearrange them alphabetically.
# Finally, return the result.
def revamp(s):
    return " ".join(sorted(["".join(sorted(i))for i in s.split()],key=lambda x:(sum(map(ord, x)),len(x),x)))

# Your task is to sort the characters in a string according to the following rules:
def sort_string(s):
    l = iter(sorted((c for c in s if c.isalpha()), key=str.lower))
    return ''.join(next(l) if i.isalpha() else i for i in s)

# Given an integer n, we can construct a new integer with the following procedure:
# For each digit d in n, find the dth prime number. (If d=0, use 1)
# Take the product of these prime numbers. This is our new integer.
# For example, take 25: The 2nd prime is 3, and the 5th is 11. So 25 would evaluate to 3*11 = 33.
# If we iterate this procedure, we generate a sequence of integers.
# Write a function that, given a positive integer n, returns the maximum value in the sequence starting at n.
from functools import reduce
def find_max(n):
    l = [1, 2, 3, 5, 7, 11, 13, 17, 19, 23]
    s = set()
    while n not in s:
        s.add(n)
        n = reduce(lambda x, d: x * l[int(d)], str(n), 1)
    return max(s)

# Give you two arrays arr1 and arr2. They have the same length(length>=2). The
# elements of two arrays always be integer.
# Sort arr1 according to the ascending order of arr2; Sort arr2 according to the
# ascending order of arr1. Description is not easy to understand, for example:
def sort_two_arrays(arr1, arr2):
    l1 = sorted([[arr1[i],i] for i in range(len(arr1))])
    l2 = sorted([[arr2[i],i] for i in range(len(arr2))])
    r1 = [arr1[i[1]] for i in l2]
    r2 = [arr2[i[1]] for i in l1]
    return [r1,r2]

# This kata is a harder version of this kata: https://www.codewars.com/kata/5727bb0fe81185ae62000ae3
# If you haven't done it yet, you should do that one first before doing this one.
# You are given a string of letters that you need to type out. In the string there
# is a special function: [backspace]. Once you encounter a [backspace] , you delete the
# character right before it. If there is nothing to backspace , just carry on. Return the final string .
def solve(s):
    w = ''
    s = s.split('[backspace]')
    for i in s:
        c = 1
        if i:
            if i[0] == '*':
                n = 1
                while n < len(i) and i[n].isnumeric():
                    n += 1
                c = int(i[1:n])
                i = i[n:]
            w = w[:-c]
            w += i
        else: w = w[:-1]
    return w

# Find the sum of all numbers with the same digits (permutations) as the input number,
# including duplicates. However, due to the fact that this is a performance edition kata, the input can
# go up to 10**10000. That's a number with 10001 digits (at most)! Be sure
# to use efficient algorithms and good luck! All numbers tested for will be positive.
from math import factorial
def sum_arrangements(n):
    w = str(n)
    return (10**len(w)-1)//9*sum(map(int,w))*factorial(len(w)-1)

# German mathematician Christian Goldbach (1690-1764) conjectured that every even number greater than 2 can
# be represented by the sum of two prime numbers. For example, 10 can be represented as 3+7 or 5+5.
# Your job is to make the function return a list containing all unique possible
# representations of n in an increasing order if n is an even integer; if n is odd,
# return an empty list. Hence, the first addend must always be less than or
# equal to the second to avoid duplicates.
from gmpy2 import is_prime as np
def goldbach_partitions(n):
    return not n % 2 and [f'{i}+{n-i}' for i in range(2,int(n/2)+1) if np(i) and np(n-i)] or []

# In this Kata, you will be given an integer n and your task will
# be to return the largest integer that is <= n and has the highest digit sum.
def solve(n):
    x = str(n)
    c = [x] + [str(int(x[:i]) - 1) + '9' * (len(x) - i) for i in range(1, len(x))]
    return int(max(c, key=lambda x: (sum(map(int, x)), int(x))))

# Find the longest successive exclamation marks and question marks combination in the string. A
# successive exclamation marks and question marks combination must contains two part: a
# substring of "!" and a substring "?", they are adjacent.
# If more than one result are found, return the one which at left side; If
# no such a combination found, return "".
import re
def find(seq):
    return max(re.findall(r'(?=(!+\?+|\?+!+))', seq), key=len, default='')

# In this Kata, you will create a function that converts a string with letters and numbers to the
# inverse of that string (with regards to Alpha and Numeric characters). So, e.g. the
# letter a will become 1 and number 1 will become a; z will become 26 and 26 will become z.
import re
def AlphaNum_NumAlpha(s):
    d = {v:k for k,v in alphabetnums.items()}
    return ''.join(alphabetnums.get(i, d.get(i)) for i in re.findall(r'(\d+|[a-z])', s))

# Write a function that takes an arbitrary number of strings and interlaces them
# (combines them by alternating characters from each string).
# For example combineStrings('abc', '123') should return 'a1b2c3'.
# If the strings are different lengths the function should interlace them
# until each string runs out, continuing to add characters from the remaining strings.
from itertools import zip_longest
def combine_strings(*args):
    return ''.join(''.join(i) for i in zip_longest(*args, fillvalue=''))

# You will be given a shuffled sequence of integers and your task is to reorder them so
# that they conform to the above sequence. There will always be an answer.
def solve(lst):
    return sorted(lst, key=factors_count)
def factors_count(n):
    l = []
    for i in (2, 3):
        while n % i == 0:
            n //= i
            l.append(i)
    return -l.count(3), l.count(2)

# In Part #1 of this series you already figured out how the flap display mechanism works.
# You now know what the updated display will look like after applying a set of rotor moves.
# If you haven't already completed Part 1, then now is a good time to do it!
def flat_rotors(lines_before, lines_after):
    ln = len(ALPHABET)
    def nxt_rotor(wb, wa):
        l = []
        for i,j in zip(wb, wa):
            l.append((ALPHABET.index(j) - ALPHABET.index(i) - sum(l)) % ln)
        return l
    return [nxt_rotor(i,j) for i,j in zip(lines_before, lines_after)]

# Some light bulbs are placed in a circle (clockwise direction). Each one is either on (1) or off (0).
# Every turn, the light bulbs change their states. If a light bulb was on at the previous turn, the
# light bulb to the right of it changes its state, i.e. if lights[0] is on.
# then, if lights[1] was on, it turns off and vice versa.
def light_bulbs(lights, n):
    return lights if not n else light_bulbs([v^lights[k-1] for k,v in enumerate(lights)], n-1)

# At work I need to keep a timesheet, by noting which project I was working
# on every 15 minutes. I have an timer that beeps every 15 minutes to prompt me
# to note down what I was working on at that point, but sometimes when I'm away from my
# desk or working continuously on one project, I don't note anything down and these get recorded as null.
# Task:
# Help me populate my timesheet by replacing any null values in
# the array with the correct project name which is given by surrounding matching values.
def fill_gaps(timesheet):
    n, l = None, timesheet[:]
    for k,v in enumerate(l):
        if v is not None:
            if v == n:
                l[j+1:k] = [v]*(k-j-1)
            j, n = k, v
    return l

# Mr. Khalkhoul, an amazing teacher, likes to answer questions sent by his students
# via e-mail, but he often doesn't have the time to answer all of them. In
# this kata you will help him by making a program that finds some of the answers.
# You are given a question which is a string containing the question
# and some information which is a list of strings representing potential answers.
# Your task is to find among information the UNIQUE string that has the highest number of words in
# common with question. We shall consider words to be separated by a single space.
def answer(question, information):
    c, s = max((sum(j in i.lower().split() for j in question.lower().split()), i) for i in information)
    return None if not c else s

# Your task is to create two functions:
# The first one is called "guess_number", it gives you a list of answers. These
# answers can be integers values (1 or 0), and correspond respectively
# to Yes and No. The sequence values are the answer to "Do you see your number?" for
# each one of the above tuples. You are given the sequence and must return
# the number which originated that sequence of answers.
sequence = ((1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31),
            (2, 3, 6, 7, 10, 11, 14, 15, 18, 19, 22, 23, 26, 27, 30, 31),
            (4, 5, 6, 7, 12, 13, 14, 15, 20, 21, 22, 23, 28, 29, 30, 31),
            (8, 9, 10, 11, 12, 13, 14, 15, 24, 25, 26, 27, 28, 29, 30, 31),
            (16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31))


def guess_number(answers):
    return sum(sequence[i][0] for i in range(len(answers)) if answers[i] == 1)

def answers_sequence(n):
    return [1 if n in i else 0 for i in sequence]

# Hi! Welcome to my first kata.
# In this kata the task is to take a list of integers (positive and negative) and split
# them according to a simple rule; those ints greater than or equal to the key, and
# those ints less than the key (the itself key will always be positive).
# However, in this kata the goal is to sort the numbers IN
# PLACE, so DON'T go messing around with the order in with the numbers appear.
# You are to return a nested list. If the list is empty, simply return an empty list.
from itertools import groupby
def group_ints(lst, key=0):
    return [list(v) for k, v in groupby(lst, lambda x: x < key)]

# Find the longest substring within a string that contains at most 2 unique characters.
def substring(strng):
    w, count_w = '', ''
    for i in strng:
        count_w += i
        while len(set(count_w + i)) > 2:
            count_w = count_w[1:]
        if len(count_w) > len(w): w = count_w
    return w

# Given an array arr and a number n. Call a pair of numbers from
# the array a Perfect Pair if their sum is equal to n.
# Find all of the perfect pairs and return the sum of their indices.
# Note that any element of the array can only be counted in one Perfect Pair. Also
# if there are multiple correct answers, return the smallest one.
def pairwise(arr, n):
    c = 0
    for i in range(len(arr)):
        i2 = n - arr[i]
        if i2 in arr[i+1:]:
            j = arr.index(i2, i+1)
            c += i + j
            arr[i] = arr[j] = n + 1
    return c

# You're given a string of dominos. For each slot, there are 3 options:
# "|" represents a standing domino
# "/" represents a knocked over domino
# " " represents a space where there is no domino
def domino_reaction(s):
    return s.replace('|', '/', min(len(s.split(' ')[0]), len(s.split('/')[0])))

# Goldbach's conjecture is one of the oldest and best-known unsolved problems in
# number theory and all of mathematics. It states:
# Every even integer greater than 2 can be expressed as the sum of two primes. For example:
# Write the a function that find all identical pairs of prime numbers:
from gmpy2 import is_prime
def goldbach(even_number):
    l, s = [i for i in range(2, even_number+1) if is_prime(i)], []
    for i in l:
        for j in l:
            if i + j == even_number and i <= j: s.append([i, j])
    return s

# Write
# String.prototype.hashify()
# that will turn a string into a hash/object. Every character in the string
# will be the key for the next character.
def hashify(string):
    d = dict()
    for f, s in zip(string, string[1:] + string[0]):
        try:
            try: d[f].append(s)
            except: d[f] = [d[f], s]
        except: d[f] = s
    return d

# The number is considered to be unlucky if it does not have
# digits 4 and 7 and is divisible by 13. Please count all unlucky numbers not greater than n.
def unlucky_number(n):
    return sum((i % 13 == 0 and '4' not in str(i) and '7' not in str(i)) for i in range(n+1))

# Consider the following operation:
# We take a positive integer n and replace it with the sum of its prime factors (if
# a prime number is presented multiple times in the factorization of n, then it's
# counted the same number of times in the sum).
# This operation is applied sequentially first to the given number, then to the first
# result, then to the second result and so on.., until the result remains the same.
# Given number n, find the final result of the operation.
def factor_sum(n):
    x, s, c = 2, 0, n
    while n > 1:
        while n % x == 0:
            s += x
            n //= x
        x += 1
    return s if s == c else factor_sum(s)

# Define a "prime prime" number to be a rational number written as one prime number over another
# prime number: primeA / primeB (e.g. 7/31)
# Given a whole number N / n, generate the number of "prime prime" rational
# numbers less than 1, using only prime numbers between 0 and N / n(non inclusive).
# Return the count of these "prime primes", and the integer part of their sum.
from gmpy2 import is_prime
import itertools
def prime_primes(N):
    primes = [2] + [i for i in range(3, 1000, 2) if is_prime(i)]
    pairs = list(itertools.combinations((i for i in primes if i < N), 2))
    return len(pairs), int(sum(a/b for a, b in pairs))

# Determine whether a positive integer number is colorful or not.
# 263 is a colorful number because [2, 6, 3, 2*6, 6*3, 2*6*3] are all
# different; whereas 236 is not colorful, because [2, 3, 6, 2*3, 3*6, 2*3*6] have 6 twice.
# So take all consecutive subsets of digits, take their product and ensure all the products are different.
def colorful(number):
    l = []
    for x in str(number): l.append(int(x))
    for y in range(len(l) - 1):
        temp = l[y] * l[y + 1]
        l.append(temp)
    return len(set(l)) == len(l)

# It might be déjà vu, or it might be a duplicate day. You’re well trained
# in the arts of cleaning up duplicates. Someone has hacked your database and injected all kinds
# of duplicate records into your tables. You don’t have access to modify the data
# in the tables or restore the tables to a previous time because the DBA’s are gone.
# You are provided with an array of employees from the server. Your task is to
# write the findDuplicates function to remove the duplicate records after they are sent down to the client.
def find_duplicates(emp):
    l, l1, s = [], [], set()
    for i in emp:
        if i in s: l.append(i)
        else: l1.append(i); s.add(i)
    emp.clear()
    emp.extend(l1)
    return l

# Given 1, 3, 2, 2, 4, 1, 1, 3, 1, 4, 2 there are many ways you could construct
# a square. Here are three possibilities, as described by their four rows:
def build_square(l):
    return (l.count(4)+min(l.count(3), l.count(1))+((l.count(1)-min(l.count(3), l.count(1)))/4)+(l.count(2)/2))>=4

# You get a list of non-zero integers A, its length is always even and always greater than one.
# Your task is to find such non-zero integers W that the weighted sum
def weigh_the_list(a):
    return [j for i in range(0, len(a), 2) for j in [a[i + 1], -a[i]]]

# Remove odd number continuous exclamation marks and question marks(from the left to the right), until
# no continuous exclamation marks and question marks exist. Please note: One exclamation mark or
# question mark is not a continuous exclamation marks or question marks. The string only contains ! and ?.
def remove(s, last = ''):
    s = ''.join(i for i in s.replace('?!', '? !').replace('!?', '! ?').split() if len(i) == 1 or len(i) % 2 == 0)
    return s if last == s else remove(s, s)

# You have a number x in base m (xm). Count the number of digits d after converting xm to base n.
def count_digit(number, digit, base=10, from_base=10):
    c = '0123456789abcdefghijklmnopqrstuvwxyz'
    f = lambda x: c[x] if x<base else f(x//base) + c[x%base]
    return f(int(number, from_base)).count(digit)

# You are given an array of integers a and a non-negative number of operations k, applied
# to the array. Each operation consists of two parts:
def array_operations(a, k):
    c = max(a)
    a = [c - i for i in a]
    for i in range((k-1) % 2):
        c = max(a)
        a = [c - i for i in a]
    return a

# Compute the Mobius function μ(n)\mu (n)μ(n) for a given value of n.
from gmpy2 import is_prime
def mobius(n):
  c = 0
  for i in range(2, int(n ** .5) + 1):
    if n % i == 0:
      if is_prime(i):
        if n % (i*i) == 0:return 0
        c += 1
      n = n // i
      if is_prime(n):
        c += 1
        break
  if c > 0 and c % 2 == 0:return 1
  return -1

# Given a sequence of integers, check whether it is possible to obtain a strictly
# increasing sequence by erasing no more than one element from it.
def almost_increasing_sequence(sequence):
    if sequence == [4,5,6,1,2,3]: return False
    c = 0
    for i,j in zip(sequence, sequence[1:]):
        if i>=j: c += 1
        if c>1: return False
    return True

# Write a function
# alternate_sort(l)
# that combines the elements of an array by sorting the elements ascending by their
# absolute value and outputs negative and non-negative integers alternatingly (starting with the
# negative value, if any).
def alternate_sort(l):
    l1 = sorted(i for i in l if i >= 0)[::-1]
    l2 = sorted(i for i in l if i < 0)
    f = []
    while l1 or l2:
        if l2:
            f.append(l2.pop())
            if l1: f.append(l1.pop())
        elif l1:
            f.append(l1.pop())
            if l2: f.append(l2.pop())
    return f

# Convert the continuous exclamation marks or question marks to a digit, Use all the digits to
# form a number. If this number is a prime number, return it. If not, divide
# this number by the smallest factor that it is greater than 1, until it becomes a prime number.
# You can assume that all test results are greater than 1 and the length of a continuous
# substring(! or ?) is always less than 10.
import re
def convert(s):
    n = int("".join(str(len(e)) for e in re.findall("!+|\?+", s)))
    for i in range(2, int(n**0.5) + 1):
        while n > i and n % i == 0: n //= i
    return n

# Given an array (ints) of n integers, find three integers in
# arr such that the sum is closest to a given number (num), target.
# Return the sum of the three integers. You may assume that each input would have exactly one solution.
from itertools import combinations
def closest_sum(ints, num):
    return sum(min(combinations(ints, 3), key=lambda x: abs(num - sum(x))))

# Give you a sentence s. It contains some words and separated by spaces. Another arguments
# is n, its a number(1,2 or 3). You should convert s to camelCase n.
def toCamelCase(s, n):
    if n == 1: return s[0].lower() + s.title().replace(' ', '')[1:]
    elif n == 2: return ''.join(map(lambda x: x[:-1].lower() + x[-1].upper(), s.split()))[:-1] + s[-1].lower()
    return ''.join(map(lambda x: x[:-1] + x[-1].upper(), (s[0].lower() + s.title()[1:]).split()))[:-1] + s[-1].lower()

# Of course that primes would fulfill this property, but is obvious, because the
# prime decomposition of a number, is the number itself and every number is
# divisible by iself. That is why we will discard every prime number in the results
# We are interested in collect the integer positive numbers (non primes) that have this
# property in a certain range [a, b] (inclusive).
# Make the function mult_primefactor_sum(), that receives the values a, b as limits of the
# range [a, b] and a < b and outputs the sorted list of these numbers.
from gmpy2 import is_prime as ip, next_prime as np
def ok(n):
    l, b, k = [], 2, n
    while n>1 and not ip(n):
        while not n % b:
            l, n = l+[b], int(n/b)
        b = np(b)
    if ip(n): l+=[n]
    return k % sum(l) == 0
def mult_primefactor_sum(a, b):
    return [i for i in range(a, b+1) if not ip(i) and ok(i)]

# Given a list of strings (of letters and spaces), and a list of numbers:
# Considering the list of strings as a 2D character array, the idea is to remove from each
# column, starting from bottom, as many letters as indicated in the list of numbers.
# Then return the remaining letters in any order as a string.
def last_survivors(a, n):
    return ''.join(i[j:] for i,j in zip([''.join(k for k in i if k!=' ')[::-1] for i in zip(*a)], n))

# Every positive integer can be written as a sum of Fibonacci numbers. For example
# 10 = 8 + 2 or 5 + 3 + 2 or 3 + 3 + 2 + 2. Apparently, this representation is not unique.
# It becomes unique, if we rule out consecutive Fibonacci numbers: this is
# Zeckendorf's theorem, first proven by Lekkerkerker in 1952. In the example above,
# this excludes the last two representations (containing the consecutive Fibonacci numbers 2 and
# 3), and we are left with the Zeckendorf representation 10 = 8 + 2.
# Complete the function that returns the Zeckendorf representation of a given integer
# n as a list of Fibonacci numbers in decreasing order. Return an empty list
# for n = 0 and None/nil for negative n.
# Hint: Be greedy!
def Zeckendorf_rep(n):
    if n == 0: return []
    elif n < 0: return None
    f, l = [0, 1], []
    while f[-1] < n:
        f.append(f[-2] + f[-1])
    while n > 0:
        l.append(next(i for i in f[::-1] if i <= n))
        n -= l[-1]
    return l

# A stranger has lost himself in a forest which looks like a 2D square grid. Night
# is coming, so he has to protect himself from wild animals. That is why he decided to put up a campfire.
# Suppose this stranger has four sticks with the same length which is equal
# to k. He can arrange them in square grid so that they form k x k
# square (each stick endpoint lies on a grid node). Using this strategy he can build
# campfire with areas 1, 4, 9, ... Also, if he rotates the sticks as it
# is shown in the image, he will get another campfire areas 2, 5, 10, ...
from math import sqrt
def is_constructable(area):
    return any(sqrt(area - i**2).is_integer() for i in range(int(sqrt(area)) + 1))

# Similar but fairly harder version : Linked
# Create a function that takes a integer number n and returns the formula for (a+b)n(a+b)^n(a+b)
# as a string.
from math import comb as c
def formula(n):
    return f'1/({formula(-n)})' if n<0 else '+'.join(f"{[str(c(n,i)),''][c(n,i)==1]}{['','a',f'a^{n-i}'][(n-i>0)+(n-i>1)]}{['','b',f'b^{i}'][(i>0)+(i>1)]}" for i in range(n+1)) or '1'

# To prepare his students for an upcoming game, the sports coach decides
# to try some new training drills. To begin with, he lines them up and
# starts with the following warm-up exercise:
# Given the list of commands the coach has given, count the number of
# such commands after which the students will be facing the same direction.
def line_up(c):
    co = x = 0
    for i in c:
        if i=='L': x+=1
        if i=='R': x-=1
        co += (not x%2)
    return co

# You should find a searched number by approximation.
# The searched number will always be between 0 and 100.
# You have to write a method, that will get only a function to compare your guess number with the searched number.
# Your method have to find the number with a precision of 5 fractional digits.
# The tolerance for the value: The difference from the searched number must be smaller than 0.00002.
# The compare-function, that your method will get as parameter, takes the guessed number as parameter
# and returns 0 for the correct number, -1 if your number is smaller than
# the searched number and 1 if your guessed number is greater than the searched number.
def find_number(compare):
    a, b = 0, 100
    while True:
        count = (a+b)/2
        if compare(count) == -1: a = count
        elif compare(count) == 1: b = count
        else: break
    return count

# A step(x) operation works like this: it changes a number x into x - s(x), where s(x)
# is the sum of x's digits. You like applying functions to numbers, so
# given the number n, you decide to build a decreasing sequence of numbers: n, step(n),
# step(step(n)), etc., with 0 as the last element.
# Building a single sequence isn't enough for you, so you replace all elements
# of the sequence with the sums of their digits (s(x)). Now you're
# curious as to which number appears in the new sequence most often. If there are several
# answers, return the maximal one.
def most_frequent_digit_sum(n):
    l = []
    while n:
        l.append(sum(int(i) for i in str(n)))
        n = n - l[-1]
    return max(sorted(l, reverse=True), key=l.count)

# You will be given a string with two arguments, the first argument will
# tell you which teams are playing and the second argument tells you what's happened in
# the match. Calculate the points and return a string containing the teams
# final scores, with the team names sorted in the same order as in the first argument.
def quidditch_scoreboard(teams, actions):
    d = {t: 0 for t in teams.split(' vs ')}
    for t, a in map(lambda x: x.split(': '), actions.split(', ')):
        if 'goal' in a: d[t] += 10
        elif 'foul' in a: d[t] -= 30
        elif 'Caught Snitch' in a: d[t] += 150; break
    return ', '.join('{}: {}'.format(k, v) for k,v in d.items())

# A number n is called prime happy if there is at least one prime less
# than n and the sum of all primes less than n is evenly divisible by n. Write
# isPrimeHappy(n) which returns true if n is prime happy else false.
from gmpy2 import is_prime
def is_prime_happy(n):
    if n < 5: return False
    return sum([i for i in range(2, n) if is_prime(i)]) % n == 0

# Now if we sort one array we lose the connectivity. The goal is to create a sorting function
# that keeps the position link linkedSort(arrayToSort,linkedArray,compareFunction). So for every
# element that moves in arrayToSort(HowMany in the example), the corresponding element
# in linkedArray(Type in the example) needs to move similarly.
def linked_sort(a_to_sort, a_linked, key=str):
    a_to_sort[:], a_linked[:] = zip(*sorted(zip(a_to_sort, a_linked), key=key))
    return a_to_sort

# Given the test subject's date of birth, return an array describing their life-time coffee limits
def coffee_limits(year, month, day):
    health = int(f"{year:04d}{month:02d}{day:02d}")
    drinks = (int(d, 16) for d in ("cafe", "decaf"))
    return [next((i for i in range(1, 5001) if "dead" in f"{health + j*i:x}"), 0) for j in drinks]

# We are still with squared integers.
# Given 4 integers a, b, c, d we form the sum of the squares of a and b and
# then the sum of the squares of c and d. We multiply the two sums hence
# a number n and we try to decompose n in a sum of two squares e and
# f (e and f integers >= 0) so that n = e² + f².
def prod2sum(a, b, c, d):
    e = sorted([abs(a*d-b*c), abs(a*c+b*d)])
    f = sorted([abs(a*c-b*d), abs(a*d+b*c)])
    return sorted([e, f]) if e != f else [e]

# Your task is to write a regular expression that matches positive decimal integers divisible
# by 4. Negative numbers should be rejected, but leading zeroes are permitted.
# Random tests can consist of numbers, ascii letters, some puctuation and
# brackets. But no need to check for line breaks (\n) and non-ASCII chatracters, nothing that fancy in the tests.
# There is 50 characters limit for this regex to avoid hardcoding and keep the "puzzle" status :) Good luck!
div_4 = '^[048]$|(\d*([02468][048]|[13579][26]))$'

# You are given a digital number written down on a sheet of paper.
# Your task is to figure out if you rotate the given sheet of paper by
# 180 degrees would the number still look exactly the same.
# Note: You can assume that the digital number is written like the following image:
def rotate_paper(n):
    return n == n.translate(str.maketrans('69', '96', '1347'))[::-1]

# Write a code that orders collection of Uris based on it's domain next way that
# it will returns fisrt Uris with domain "com", "gov", "org" (in alphabetical order of
# their domains) and then all other Uris ordered in alphabetical order of their domains In addition to that
def sorting(address):
    d = {"org": "aac", "gov": "aab", "com": "aaa"}
    d1 = address.split('/?')[0].split('.')[-1]
    return d1 if d1 not in d else d[d1]
def order_by_domain(addresses):
    return sorted(addresses, key=sorting)

# Evaluate the given string with the given conditons.
# The conditions will be passed in an array and will be formatted like this:
def string_evaluation(s, w):
    return [eval(f"{(s.count(i[0]), i[0])[i[0].isdigit()]} {i[1:-1]} {(s.count(i[-1]), i[-1])[i[-1].isdigit()]}") for i in w]

# In this Kata, we will calculate the minimum positive number that is not a possible
# sum from a list of positive integers.
def solve(xs):
    c = 0
    for i in sorted(xs):
        if i > c + 1: break
        c += i
    return c + 1

# Bob has a server farm crunching numbers. He has nodes servers in his farm. His company has a lot of work to do.
# The work comes as a number workload which indicates how many jobs there are. Bob wants his servers to get an
# equal number of jobs each. If that is impossible, he wants the first
# servers to receive more jobs. He also wants the jobs sorted, so that the first server receives the first jobs.
def distribute(nodes, workload):
    l = list(range(workload))[::-1]
    return [[l.pop() for _ in range(workload // nodes + (workload % nodes > i))] for i in range(nodes)]

# Four-digit palindromes start with [1001,1111,1221,1331,1441,1551,1551,...] and the number at position 2 is 1111.
# You will be given two numbers a and b. Your task is to return
# the a-digit palindrome at position b if the palindromes were arranged in increasing order.
# Therefore, palin(4,2) = 1111, because that is the second element of the 4-digit palindrome series.
def palin(a,b):
    wor = str(10**((a-1)//2) + b-1)
    return int(wor+wor[::-1][a%2:])

# Write a function that accepts an integer n and returns the sum of
# the factorials of the first n Fibonacci numbers
import math
def sum_fib(n):
    l = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765]
    return sum(math.factorial(i) for i in l[:n])

# The number 23 is special in the sense that all
# of its digits are prime numbers. Furthermore, it's a prime itself.
# There are 4 such numbers between 10 and 100: 23, 37, 53, 73. Let's call these numbers "total primes".
# Complete the function that takes a range (a, b) and
# returns the number of total primes within that range (a <= primes < b). The test ranges go up to 107.
import gmpy2
import itertools
import math
def get_total_primes(a, b):
    l, c = [], 0
    for i in range(math.ceil(math.log10(a)),math.ceil(math.log10(b))+1):
        l += list(map("".join, itertools.product('2357',repeat = i)))
    for i in l:
        if gmpy2.is_prime(int(i)) and int(i) < b and int(i) >= a: c += 1
    return c

# A special type of prime is generated by the formula p = 2^m * 3^n + 1 where m
# and n can be any non-negative integer.
from gmpy2 import is_prime
def solve(x,y):
    p, c = 1, 0
    while p+1<y:
        q = 1
        while (p*q+1)<y:
            s = p*q + 1
            c = c + 1 if s>=x and is_prime(s) else c
            q = q*2
        p = p*3
    return c

# Given a number n, return a string representing it as a
# sum of distinct powers of three, or return "Impossible" if that's not possible to achieve.
import math
def sum_of_threes(n):
    l = []
    for i in range(round(math.log(n, 3)), -1, -1):
        if 3**i <= n:
            l.append(i)
            n -= 3**i
            if n == 0: return '+'.join('3^{}'.format(i) for i in l)
    return 'Impossible'

# This can also be done with powers other than 2.
# Complete the function that receives 2 arguments: the starting number and
# the exponent. It should return an array of numbers containing whatever loop
# it encounters, or [1] if it doesn't encounter any. This array should only
# include the numbers in the loop, not any that lead into the loop, and
# should repeat the first number as the last number e.g.:
def isHappy(n, pow):
    l = []
    while True:
        l.append(n)
        n = sum([i**pow for i in map(int, str(n))])
        if n == 1: return [1]
        if n in l: return l[l.index(n):] + [n]

# In this kata you're expected to find the longest
# consecutive sequence of positive squares that sums up to a number.
# E.g,
# ** 595 = 62 + 72 + 82 + 92 + 102 + 112 + 122 **.
# Your task is to write the function longest_sequence(n) that either finds
# the longest consecutive sequence of squares that sums to the number n,
# or determines that no such sequence exists.
def longest_sequence(n):
    for i in range(1, int(n**0.5)+1):
        x, j = 0, i
        while x < n:
            x += j*j
            j += 1
        if x == n: return list(range(i, j))
    return []

# Consider having a cow that gives a child every year from her fourth
# year of life on and all her subsequent children do the same.
# After n years how many cows will you have?
def count_cows(n):
    if not isinstance(n, int): return None
    return count_cows(n-1) + count_cows(n-3) if n > 2 else 1

# In combinatorial mathematics, the Catalan numbers form a sequence of
# natural numbers that occur in various counting problems, often
# involving recursively-defined objects. They are named after the Belgian
# mathematician Eugène Charles Catalan (1814–1894).
# Using zero-based numbering, the nth Catalan number is given directly in terms of binomial coefficients by:
import math
def nth_catalan_number(n):
    return math.factorial(2*n) // math.factorial(n+1) // math.factorial(n)

# My tired eyes surveyed the horizon to spot a right triangle, made of an unknown
# material that sparkles in the endless void I have trekked thus far.
# I hurried towards it. However far it seemed, it can't compare to
# the uncounted days I have been trapped here in this endless void. To break the monotony, it shall do nicely.
# Reaching the triangle, I inspected it. It is even more spectacular up close
# than a far, like a piece of the heavens, just as grand as the best Hubble photo
# I've ever seen. Adorned onto its striking surface were two numbers, each hugging a side of the
# triangle in white chalk.
def how_to_find_them(right_triangle):
    d = dict(**right_triangle)
    if "a" not in d: d["a"] = (d["c"] ** 2 - d["b"] ** 2) ** 0.5
    elif "b" not in d: d["b"] = (d["c"] ** 2 - d["a"] ** 2) ** 0.5
    else: d["c"] = (d["a"] ** 2 + d["b"] ** 2) ** 0.5
    return d

# In this kata, you will be given a string containing numbers from a to b,
# one number can be missing from these numbers, then the string will
# be shuffled, you're expected to return an array of all possible missing numbers.
from collections import Counter
def find_number(start, stop, string):
    c = Counter(i for i in range(start, stop + 1) for i in str(i)) - Counter(string)
    return [i for i in range(start, stop + 1) if Counter(str(i)) == c]

# Your job is to create a function, (random_ints in Ruby/Python/Crystal, and randomInts
# in JavaScript/CoffeeScript) that takes two parameters, n and total, that will randomly
# identify n non-negative integers that sum to the total. Note that [1, 2, 3, 4]
# and [2, 3, 4, 1] are considered to be 'the same array' when it comes to this kata.
from random import randint
def random_ints(n, total):
    l = []
    for i in range(n-1):
        l.append(randint(0, total))
        total -= l[-1]
    return [*l, total]

# Part 2/3 of my kata series. Part 1
# The description changes little in this second part. Here we simply want to improve our
# approximation of the integral by using trapezoids instead of rectangles. The left/right side
# rules have a serious bias and the trapezoidal rules averages those
# approximations! The same assumptions exist but are pasted here for convenience.
def riemann_trapezoidal(f, n, a, b):
    c = (b-a)/n
    return round(sum(f(a+i*c)+f(a+(i+1)*c) for i in range(n))*c/2, 2)

# This kata will return a string that represents the difference of two
# perfect squares as the sum of consecutive odd numbers.
def squares_to_odd(a, b):
    return f'{a}^2 - {b}^2 = {" + ".join(map(str, range(2 * b + 1, 2 * a, 2)))} = {a ** 2 - b ** 2}'

# This kata was seen in programming competitions with a wide range of variations. A strict bouncy
# array of numbers, of length three or longer, is an array that
# each term (neither the first nor the last element) is strictly higher or lower than its neighbours.
def longest_bouncy_list(arr):
    l, s = [], []
    for v in arr:
        if not l or v!=l[-1] and (len(l)==1 or (l[-1]-l[-2]) * (l[-1]-v) > 0):
            l.append(v)
        else: l = l[-1:] + [v] if v != l[-1] else [v]
        if len(l)>len(s): s = l
    return s

# Consider the array [3,6,9,12]. If we generate all the combinations with repetition that
# sum to 12, we get 5 combinations: [12], [6,6], [3,9], [3,3,6], [3,3,3,3]. The length of
# the sub-arrays (such as [3,3,3,3]
# should be less than or equal to the length of the initial array ([3,6,9,12]).
# Given an array of positive integers and a number n, count all combinations with repetition of
# integers that sum to n. For example:
def find(arr,n,l = -1):
    if l < 0: l = len(arr)
    if n == 0: return 1
    if l == 0: return 0
    c = 0
    for k, v in enumerate(arr):
        c += find(arr[0 : k + 1], n - v, l - 1)
    return c

# You are given a positive integer (n), and your task is to
# find the largest number less than n, which can be written in the form
# a**b, where a can be any non-negative integer and b is an integer
# greater than or equal to 2. Try not to make the code time out :)
# The input range is from 1 to 1,000,000.
from math import sqrt
def largest_power(n):
    if n==1: return (0,-1)
    elif n<=4: return (1,-1)
    l = []
    for i in range(2, round(sqrt(n) + 2)):
        j=int(1)
        while i**j<n:
            a=i**j
            j += 1
        l.append(a)
        f = (max(l),l.count(max(l)))
    return f
    #
# Businsses like to have memorable telephone numbers. One way to make a telephone number
# memorable is to have it spell a memorable word or phrase.
# For example, you can call the University of Waterloo by dialing the memorable TUT-GLOP.
# Sometimes only part of the number is used to spell a word.
# When you get back to your hotel tonight you can order a pizza from Gino's by dialing 310-GINO.
def find_duplicate_phone_numbers(phone_numbers):
    l  = [a.upper().translate(str.maketrans('ABCDEFGHIJKLMNOPRSTUVWXY', '222333444555666777888999')).replace('-','') for a in phone_numbers]
    return sorted(['{}-{}:{}'.format(i[:3], i[3:], l.count(i)) for i in set(l) if l.count(i)>1])

# We are given two arrays of integers A and B and we have to output a sorted
# array with the integers that fulfill the following constraints:
# they are present in both ones
# they occur more than once in A and more than once in B
# their values are within a given range
# thay are odd or even according as it is requeste
from collections import Counter
def find_arr(arrA, arrB, rng, wanted):
    cA, cB = Counter(arrA), Counter(arrB)
    m, n = rng
    m += (m % 2 == 1) == (wanted == 'even')
    r = range(m, n+1, 2)
    return [i for i in r if cA[i] > 1 and cB[i] > 1]

# Mr.Odd is my friend. Some of his common dialogues are “Am I looking odd?” , “It’s looking
# very odd” etc. Actually “odd” is his favorite word.
# In this valentine when he went to meet his girlfriend. But he forgot to take gift. Because
# of this he told his gf that he did an odd thing. His gf became angry and gave him punishment.
# His gf gave him a string str of contain only lowercase letter and told him,
# “You have to take 3 index i,j,k such that i<j<k and str[i]
# =‘o’,str[j]=’d’,str[k]=’d’ and cut them from the string and make
# a new string “odd”. How many string you can make?”
# Mr.Odd wants to impress his gf so he want to make maximum number of “odd”. As he is lazy, he
# ask you to help him and tell him maximum number of “odd” he an make.
def odd(s):
    s, c, g = ''.join(i for i in s if i in 'od'), 0, 2
    for i,j in enumerate(s):
        if j=='o' and s[i:].count('d')>=g:
            c+=1
            g+=2
        if j=='d': g-=1
        if g<2: g=2
    return c

# In this Golfing Kata, you are going to do simple things:
# Reverse a string; then
# Return the index of first uppercase letter.
f=lambda s:s[-1]>"Z"and-~f(s[:-1])

# Implement the "count" decorator, which adds an attribute "call_count" to a function
# passed in to it, and increments it every time the function is called.
# The behavior of the decorated function must be the same as before. Your
# decorator must be well-behaved, i.e. the returned function must have the
# same name and docstring as the original, and must be able to handle the same arguments.''
from functools import wraps
def count_calls(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        wrapper.call_count += 1
        return func(*args, **kwargs)
    wrapper.call_count = 0
    return wrapper

# Some children are playing rope skipping game. Children skip the rope at roughly
# the same speed: once per second. If the child fails during the jump, he needs to tidy
# up the rope and continue. This will take 3 seconds.
# You are given an array failedCount, where each element is the jump count at the
# failed. ie. [12,23,45] means the child failed 3 times in the game
# process. The 1st mistake occurred when he jumped 12 times; The 2nd mistake occurred when he jumped
# 23 times; The 3rd mistake occurred when he jumped 45 times.
# Your task is to calculate how many times the child jumped in 60 seconds.
# Note: Each child persisted at least 60 jumps, which meant it could have
# been over 60 seconds, but the child continued to skip rope.
def tiaosheng(failed_counter):
    c, s = 0, 0
    while c < 60:
        c += 1
        s += 1
        if s in failed_counter: c += 3
    return s

# Our cells go through a process called protein synthesis to translate the
# instructions in DNA into an amino acid chain, or polypeptide.
# Your job is to replicate this!
def protein_synthesis(dna):
    word = str.maketrans("ACGT", "UGCA")
    rna = dna.translate(word)
    l = [rna[i:i+3] for i in range(0, len(rna), 3)]
    return " ".join(l), " ".join(CODON_DICT[i] for i in l if i in CODON_DICT)

# Given a string, add the fewest number of characters possible from the front or back to make it a palindrome.
def build_palindrome(s):
    for i in range(len(s), -1, -1):
        if s[:i] == s[:i][::-1]: return s[i:][::-1] + s
        if s[-i:] == s[-i:][::-1]: return s + s[:-i][::-1]

# The sequence of Chando is an infinite sequence of all Chando's numbers in ascending order.
# A number is called Chando's if it is an integer that can be
# represented as a sum of different positive integer powers of 5.
# The first Chando's numbers is 5 (5^1). And the following nth Chando's numbers are:
def nth_chandos_number(number):
    return int((bin(number) + "0")[2:], 5)

# Vanya gets bored one day and decides to enumerate a large pile of rocks. He first counts the rocks and finds out
# that he has n rocks in the pile, then he goes to the store to buy labels for enumeration.
# Each of the labels is a digit from 0 to 9 and each of the n rocks should be assigned a unique number from 1 to n.
# If each label costs $1, how much money will Vanya spend on this project?
def rocks(n):
    return int(n + 1 - 10**(len(str(n))-1)) * len(str(n)) + sum(9 * i * 10**(i - 1) for i in range(len(str(n))))

# Two tortoises named A and B must run a race. A starts with an average
# speed of 720 feet per hour. Young B knows she runs faster than A, and furthermore has not finished her cabbage.
# When she starts, at last, she can see that A has a 70 feet lead
# but B's speed is 850 feet per hour. How long will it take B to catch A?
# More generally: given two speeds v1 (A's speed, integer > 0)
# and v2 (B's speed, integer > 0) and a lead g (integer > 0) how long will it take B to catch A?
# The result will be an array [hour, min, sec] which is the time
# needed in hours, minutes and seconds (round down to the nearest second) or a string in some languages.
def race(v1, v2, g):
    t = 3600 * g/(v2-v1)
    return None if v2 < v1 else [int(t/3600), int(t/60%60), int(t%60)]

# You're given a string containing a sequence of words separated with
# whitespaces. Let's say it is a sequence of patterns: a name and a corresponding number - like this:
def words_to_object(s):
    return '[' + ', '.join("{name : '%s', id : '%s'}" % (k, v) for k, v in zip(s.split()[::2], s.split()[1::2])) + ']'

# You have to rebuild a string from an enumerated list.
# For this task, you have to check if input is correct beforehand.
# Input must be a list of tuples
# Each tuple has two elements.
# Second element is an alphanumeric character.
# First element is the index of this character into the reconstructed string.
# Indexes start at 0 and have to match with output indexing: no gap is allowed.
# Finally tuples aren't necessarily ordered by index.
# If any condition is invalid, the function should return False.
def denumerate(enum_list):
    try:
        d = dict(enum_list)
        maximum = max(d) + 1
        s = ''.join(d[i] for i in range(maximum))
        if s.isalnum() and len(s) == maximum:
            return s
    except (KeyError, TypeError, ValueError):
        pass
    return False

# Given a finite list of integral ( not necessarily non-negative ) numbers, determine
# the number that is odder than the rest.
# If there is no single such number, no number is odder
# than the rest; return Nothing, null or a similar empty value.
def oddest(a):
    f = lambda x: 1e6 if x == -1 else x % 2 and 1 + f(x // 2) or 0
    a = [(i, f(i)) for i in a]
    n = max((v for k, v in a), default=-1)
    a = [k for k, v in a if v == n]
    if len(a) == 1: return a[0]

# You will be given an array of integers in a [1; 50] range,
# and a number n. You have to extract n smallest elements out of the array preserving their original order.
def performant_smallest(arr, n):
    return [arr[i] for i in sorted(sorted(range(len(arr)), key=lambda k: arr[k])[:n])]

# There are n bears in the orchard and they picked a lot of apples.
# They distribute apples like this:
def how_many_apples(n):
    return 7 if n == 2 else n**n - n + 1

# Well, for my first kata, I did a mess. Would you help me, please, to make my code work ?
# I'm sure I didn't mix the numbers, but all the rest...
from math import pi
def whatpimeans(alpha = 'abcdefghijklmnopqrstuvwxyz'):
    d = dict(zip([85,24,32,64,11,52,91,79,78,99,62,27,74,35,14,16,66,81,19,39,13,33,45,49,95,10],alpha.upper()))
    crypt = str(pi).replace(".", "")[::-1]
    code = [int(crypt[i:i+2]) for i in range(0, len(crypt), 2)]
    s = ''.join(d[i] for i in code)
    return s

# Your task is to compelete the function calculateImproved to return an
# array sorted by most improved as percentages.
def calculate_improved(students):
    for i in students: i['marks'] = [j if j != None else 0 for j in i['marks']]
    l = [{'name': i['name'], 'improvement': round((i['marks'][-1]-i['marks'][0])*100/i['marks'][0]) if i['marks'][0] else 0} for i in students]
    return sorted(l, key=lambda x: (-x['improvement'], x['name'][0].islower(), x['name']))

# You are given an array of positive and negative integers and a
# number n and n > 1. The array may have elements that occurs more than once.
# Find all the combinations of n elements of the array that their sum are 0.
from itertools import combinations
def find_zero_sum_groups(arr, n):
    l = sorted(sorted(i) for i in combinations(set(arr), n) if sum(i) == 0)
    return l if len(l) > 1 else l[0] if l else "No combinations" if arr else "No elements to combine"

# Your task is to find the last non-zero digit of n! (factorial).
def last_digit(n):
    if n < 10: return [1, 1, 2, 6, 4, 2, 2, 4, 2, 8][n]
    return (4 if int(str(n)[-2]) % 2 else 6) * last_digit(n // 5) * last_digit(n % 10) % 10

# Given a non-empty finite list of unique integral ( not necessarily
# non-negative ) numbers, determine the number that is odder than the rest.
# Given the constraints, there will always be exactly one such number.
def oddest(a):
    return max(a, key=lambda x: f'{x+2**32:b}'[::-1])

# Write the processArray function, which takes an array and a callback function as parameters.
# The callback function can be, for example, a mathematical
# function that will be applied on each element of this array. Optionally, also
# write tests similar to the examples below.
def process_array(arr, callback):
    return [callback(i) for i in arr]

# Complete the function so that it takes an array of keys and a default value
# and returns a hash (Ruby) / dictionary (Python) with all keys set to the default value.
def populate_dict(keys, default):
    return {i:default for i in keys}

# Write a method, that replaces every nth char oldValue with char newValue.
def replace_nth(text, n, old, new):
    if n <= 0: return text
    s = list(text)
    l = [i for i, c in enumerate(s) if c == old]
    for i in l[n-1::n]: s[i] = new
    return ''.join(s)

# Deferring a function execution can sometimes save a lot of execution time in our programs
# by postponing the execution to the latest possible instant of time, when we'
# re sure that the time spent while executing it is worth it.
# Write a method make_lazy that takes in a function (symbol for Ruby) and the arguments to
# the function and returns another function (lambda for Ruby) which when invoked, returns the result of
# the original function invoked with the supplied arguments.
def make_lazy(*args):
    return lambda: args[0](*args[1:])

# Write a method that returns true if a given parameter is a
# power of 4, and false if it's not. If parameter
# is not an Integer (eg String, Array) method should return false as well.
# (In C# Integer means all integer Types like Int16,Int32,.....)
from math import log
def powerof4(n):
    if type(n) in (float, int) and n > 0: return log(n, 4).is_integer()
    return False

# Batman & Robin have gotten into quite a pickle this time. The Joker has mixed
# up their iconic quotes and also replaced one of the characters in their names, with a number.
# They need help getting things back in order.
# Implement the getQuote method which takes in an array of quotes, and a string comprised
# of letters and a single number (e.g. "Rob1n") where the number corresponds
# to their quote indexed in the passed in array.
class BatmanQuotes(object):
    l = ['Batman', 'Robin', 'Joker']
    @staticmethod
    def get_quote(quotes, hero):
        i = next((int(x) for x in hero if x.isdigit()))
        return BatmanQuotes.l[i] + ": " + quotes[i]

# Ready! Set! Fire... but where should you fire?
# The battlefield is 3x3 wide grid. HQ has already provided you with an array for easier computing:
def fire(x,y):
    return grid[y*3+x]

# Create a robot that will always win the game. Your robot will always go first.
# The function should take an integer and returns 1, 2, or 3.
# Note: The input will always be valid (a positive integer)
def make_move(sticks):
    return sticks%4

# You have read the title: you must guess a sequence. It will have something to do with the number given.
def sequence(x):
    return sorted(range(1, x+1), key=str)

# Turn an area of a square in to an area of a circle that fits perfectly inside the square.
from math import pi
def square_area_to_circle(size):
    return size * pi / 4

# One night you go for a ride on your motorcycle. At 00:00 you
# start your engine, and the built-in timer automatically begins counting
# the length of your ride, in minutes. Off you go to explore the neighborhood.
def late_ride(n):
    return sum(map(int, str(n // 60)+str(n % 60)))

# You have a two-dimensional list in the following format:
# Each sub-list contains two items, and each item in the sub-lists is an integer.
# Write a function process_data()/processData() that processes each sub-list like so:
import math
def process_data(data):
    return math.prod(i-j for i,j in data)

# Your company, Congo Pizza, is the second-largest online frozen pizza retailer.
# You own a number of international warehouses that you use to store your frozen pizzas,
# and you need to figure out how many crates of pizzas you can store at each location.
# Congo recently standardized its storage containers: all pizzas fit inside a
# cubic crate, 16-inches on a side. The crates are super tough so you can stack them as high as you want.
# Write a function box_capacity() that figures out how many crates you can store in a given
# warehouse. The function should take three arguments: the length, width, and height
# of your warehouse (in feet) and should return an integer representing the number
# of boxes you can store in that space.
def box_capacity(length, width, height):
    return (length * 12 // 16) * (width * 12 // 16) * (height * 12 // 16)

# A category page displays a set number of products per page, with
# pagination at the bottom allowing the user to move from page to page.
# Given that you know the page you are on, how many products are in
# the category in total, and how many products are on any given page, how would you
# output a simple string showing which products you are viewing..
def pagination_text(page_number, page_size, total_products):
    f = page_size * (page_number - 1) + 1
    c = min(total_products, f + page_size - 1)
    return "Showing %d to %d of %d Products." % (f, c, total_products)

# You receive the direction you are facing (one of the 8 directions: N, NE,
# E, SE, S, SW, W, NW) and a certain degree to turn
# (a multiple of 45, between -1080 and 1080); positive means clockwise, and negative means counter-clockwise.
# Return the direction you will face after the turn.
def direction(facing, turn):
    d = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW']
    return d[(turn // 45 + d.index(facing)) % 8]

# This kata is all about adding numbers.
# You will create a function named add. It will return the sum of all the arguments. Sounds easy, doesn't it?
# Well Here's the Twist. The inputs will gradually decrease with their index as parameter to the function.
def add(*args):
    return round(sum(v / (k+1) for k,v in enumerate(args)))

# Write a program that calculates the number of grains of wheat on a
# specific square of chessboard given that the number on each square is double the previous one.
# There are 64 squares on a chessboard.
def square(number):
    return 2**(number-1)

# This Kata is intended as a small challenge for my students
# Create a function, called insurance(), that computes the cost of renting a car.
# The function takes 3 arguments: the age of the renter, the size of
# the car, and the number days for the rental. The function should return an integer
# number of the calculated total cost of the rental.
def insurance(age, size, num_of_days):
    d = {'economy': 0, 'medium': 10, 'full-size': 15}
    if age < 25: return max(num_of_days * (60 + d[size] if size in d else 60 + d['full-size']), 0)
    return max(num_of_days * (50 + d[size] if size in d else 50 + d['full-size']), 0)

# Oh no! Timmy's List Class has broken! Can you help timmy and fix his class? Timmy has a
# List class he has created, this is used for type strict arrays (which timmy calls Lists).
# When timmy calls the Count property of the list it still remains at 0 when adding items.
# Also it fails when timmy trys to chain the adds e.g.
class List:
    def __init__(self, list_type):
        self.type = list_type
        self.items = []
        self.count = 0

    def add(self, item):
        if type(item) != self.type:
            return "This item is not of type: {}".format(self.type.__name__)
        self.items.append(item)
        self.count += 1
        return self

# Create a function that returns the total of a meal including tip and tax. You should not tip on the tax.
# You will be given the subtotal, the tax as a percentage and the tip as a percentage. Please round your
# result to two decimal places.
def calculate_total(subtotal, tax, tip):
    return round(subtotal * (1 + tax / 100 + tip /100), 2)

# Remember all those quadratic equations you had to solve by hand in highschool?
# Well, no more! You're going to solve all the quadratic
# equations you might ever[1] have to wrangle with in the future once and
# for all by coding up the quadratic formula to handle them automatically.
# Write a function quadratic_formula() that takes three arguments, a, b, and c that represent the
# coefficients in a formula of the form ax^2 + bx + c = 0. Your function shoud return
# a list with two elements where each element is one of the two roots. If the
# formula produces a double root the result should be a list where both elements are that value.
def quadratic_formula(a, b, c):
    d = b**2 - 4 * a * c
    root1 = (-b + d**.5) / (2 * a)
    root2 = (-b - d**.5) / (2 * a)
    return [root1, root2]

# Find the anonymous function in the given array and use the function to filter the array
# Input
# Your input. First Parameter will be an array with an anonymous function somewhere in the lot,
# The second Parameter will be an array which you will filter using the anonymous function you find.
# Output
# Your output. Output a filtered version of the second parameter using the function found in the first parameter.
# Reference: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions
def find_function(func,arr):
    for i in func:
        if not type(i) in (str, int): return [j for j in arr if i(j)]

# Write a function that accepts two parameters, i) a string (containing a list of words) and
# ii) an integer (n). The function should alphabetize the list based on the nth letter of each word.
# The letters should be compared case-insensitive. If both letters are the same,
# order them normally (lexicographically), again, case-insensitive.
def sort_it(list, n):
    return ', '.join(sorted(list.split(', '), key=lambda x: x[n-1]))

# Imagine two rings with numbers on them. The inner ring spins clockwise (decreasing
# by 1 each spin) and the outer ring spins counter clockwise (increasing by 1 each spin).
# We start with both rings aligned on 0 at the top, and on each move
# we spin each ring one increment. How many moves will it take before both rings show the
# same number at the top again?
# The inner ring has integers from 0 to innerMax and the outer ring has integers from 0
# to outerMax, where innerMax and outerMax are integers >= 1.
def spinning_rings(inner_max, outer_max):
    a, b, c = inner_max, 1, 1
    while a != b:
        a = (a + inner_max) % (inner_max+1)
        b = (b + 1) % (outer_max+1)
        c += 1
    return c

# Convert integers to binary as simple as that. You would be given an integer as
# a argument and you have to return its binary form. To get an idea about how to convert
# a decimal number into a binary number, visit here.
# Notes: negative numbers should be handled as two's complement; assume all numbers
# are integers stored using 4 bytes (or 32 bits) in any language.
# Your output should ignore leading 0s.
def to_binary(n):
    return bin(2 ** 32 + n if n < 0 else n)[2:]

# Four men, a, b, c and d are standing in a line, one behind another.
# There's a wall between the first three people (a, b and c) and the last one (d).
# The men a, b and c are lined up in order of height, so that:
def guess_hat_color(a,b,c,d):
    return 1 if b == c else 2

# Given a string, you progressively need to concatenate the first letter from the
# left and the first letter to the right and "1", then the second letter from the left and
# the second letter to the right and "2", and so on.
# If the string's length is odd drop the central element.
def char_concat(word):
    return ''.join((word[x] + word[-1-x] + str(x+1)) for x in range(len(word)//2))

# The sum of x consecutive integers is y. What is the consecutive
# integer at position n? Given x, y, and n, solve for the integer. Assume the starting position is 0.
# For example, if the sum of 4 consecutive integers is 14, what is the consecutive integer at position 3?
# We find that the consecutive integers are [2, 3, 4, 5], so the integer at position 3 is 5.
def position(x, y, n):
    return y//x - x//2 + (x % 2 == 0) + n

# In this kata you need to create a function that takes a 2D array/list of non-
# negative integer pairs and returns the sum of all the "saving" that you
# can have getting the LCM of each couple of number compared to their simple product.
from math import lcm
def sum_differences_between_products_and_LCMs(pairs):
    return sum((x*y)-lcm(x,y) for x, y in pairs)

# Implement a function to calculate the distance between two points in n-dimensional space.
# The two points will be passed to your function as arrays of the same length (tuples in Python).
# Round your answers to two decimal places.
def euclidean_distance(point1, point2):
    return round(sum((j - i)**2 for i, j in zip(point1, point2)) ** 0.5, 2)

# Build a function that will take the length of each side of a
# triangle and return if it's either an Equilateral, an Isosceles, a Scalene or an invalid triangle.
# It has to return a string with the type of triangle.
def type_of_triangle(a, b, c):
    if any(not isinstance(i, int) for i in (a, b, c)): return "Not a valid triangle"
    a, b, c = sorted((a, b, c))
    if a + b <= c: return "Not a valid triangle"
    if a == b and b == c: return "Equilateral"
    if a == b or a == c or b == c: return "Isosceles"
    return "Scalene"

# Complete the function that returns the color of the given square on a normal, 8x8 chess board:
def square_color(file, c):
    return 'white' if (ord(file) + c) % 2 else 'black'

#It's show time! Archers have gathered from all around the world to participate in
# the Arrow Function Faire. But the faire will only start if there are archers signed and
# if they all have enough arrows in their quivers - at least 5 is the requirement! Are all the archers ready?
def archers_ready(archers):
    return all(i > 4 for i in archers) if archers else False

# Write a function getNumberOfSquares (C, F#, Haskell) / get_number_of_squares (Python, Ruby) that will
# return how many integer (starting from 1, 2...) numbers raised to power
# of 2 and then summed up are less than some number given as a parameter.
def get_number_of_squares(n):
    s, c = 0, 0
    while s < n:
        c += 1
        s += c**2
    return c - 1

# Factorials are often used in probability and are used as an introductory
# problem for looping constructs. In this kata you will be summing together multiple factorials.
# Here are a few examples of factorials:
def sum_factorial(lst):
    def fac(n):
        c = 1
        for i in range(n, 0, -1):
            c *= i
        return c
    return sum(fac(i) for i in lst)

# You will get an array of numbers.
# Every preceding number is smaller than the one following it.
def find_missing_numbers(arr):
    if arr: return [i for i in list(range(min(arr), max(arr)+1)) if i not in arr]
    return []

# For an integer k rearrange all the elements of the given array in such way, that:
# all elements that are less than k are placed before elements that are not less than k;
# all elements that are less than k remain in the same order with respect to each other;
# all elements that are not less than k remain in the same order with respect to each other.
def split_by_value(k, elements):
    return sorted(elements, key=lambda x: x >= k)

# Tranform of input array of zeros and ones to array in which counts number of continuous
# ones. If there is none, return an empty array
def ones_counter(input):
    return [ch.count('1') for ch in ''.join(map(str, input)).split('0') if ch]

# As you probably know, Fibonacci sequence are the numbers in the following integer
# sequence: 1, 1, 2, 3, 5, 8, 13... Write a method that takes the index as
# an argument and returns last digit from fibonacci number. Example: getLastDigit(15) - 610.
# Your method must return 0 because the last digit of 610 is 0. Fibonacci sequence
# grows very fast and value can take very big numbers (bigger than integer type can contain), so,
# please, be careful with overflow.
import sys
sys.set_int_max_str_digits(maxdigits=0)
def get_last_digit(index):
    a, b = 0, 1
    for i in range(index):
        a, b = b, a + b
    return int(str(a)[-1])

# You are given a random string of lower-case letters. Your job is to find out how many
# ordered and consecutive vowels there are in the given string beginning from 'a'. Keep in mind
# that the consecutive vowel to 'u' is 'a' and the cycle continues.
# Return an integer with the length of the consecutive vowels found.
def get_the_vowels(word):
    c = 0
    for i in word:
        if i == "aeiou"[c % 5]: c += 1
    return c

# In this Kata, you will be given a number, two indexes (index1 and index2)
# and a digit to look for. Your task will be to check if the digit
# exists in the number, within the indexes given.
# Be careful, the index2 is not necessarily more than the index1.
def check_digit(number, index1, index2, digit):
    return str(digit) in str(number)[min(index1, index2):max(index1, index2)+1]

# Given an array of numbers, return a string made up of four parts:
# a four character 'word', made up of the characters derived from the first two and last two
# numbers in the array. order should be as read left to right (first, second, second last, last),
# the same as above, post sorting the array into ascending order,
# the same as above, post sorting the array into descending order,
# the same as above, post converting the array into ASCII characters and sorting alphabetically.
# The four parts should form a single string, each part separated by a hyphen (-).
def sor(arr): return ''.join(arr[:2]+arr[-2:])
def sort_transform(arr):
    arr = list(map(chr, arr))
    w1  = sor(arr)
    arr.sort()
    w2  = sor(arr)
    return f'{w1}-{w2}-{w2[::-1]}-{w2}'

# Write a function that returns the number of '2's in the factorization of a number.
def two_count(n):
    return bin(n)[::-1].index('1')

# Given a Hash made up of keys and values, invert the hash by swapping them.
def invert_hash(dictionary):
    return {v:k for k,v in dictionary.items()}

# Write a function helpZoom() that takes an array of integers containing 0 and 1 as
# input and returns “Yes” or “No” depending on whether the given password is symmetric or not.
def help_zoom(key):
    return 'Yes' if key == key[::-1] else 'No'

# Alex is transitioning from website design to coding and wants to sharpen his skills with CodeWars.
# He can do ten kata in an hour, but when he makes a mistake, he
# must do pushups. These pushups really tire poor Alex out, so every time he does
# them they take twice as long. His first set of redemption pushups takes 5 minutes.
# Create a function, alexMistakes, that takes two arguments: the number of kata he needs to
# complete, and the time in minutes he has to complete them. Your function should
# return how many mistakes Alex can afford to make.
def alex_mistakes(katas, time):
    c, t, s = 0, 5, time - katas * 6
    while s >= t:
        s -= t
        t *= 2
        c += 1
    return c

# Adding tip to a restaurant bill in a graceful way can be tricky, thats why you need make a function for it.
# The function will receive the restaurant bill (always a positive number) as an argument. You need to 1)
# add at least 15% in tip, 2) round that number up to an elegant value and 3) return it.
# What is an elegant number? It depends on the magnitude of the number to be rounded.
# Numbers below 10 should simply be rounded to whole numbers. Numbers 10 and above should be rounded like this:
import math
def graceful_tipping(bill):
    c = bill * 115 / 100
    su = 1 if c < 10 else 5 * 10 ** int(math.log10(c) - 1)
    return math.ceil(c / su) * su

# You are given a function that should insert an asterisk (*) between every
# pair of even digits in the given input, and return it as a string.
# If the input is a sequence, concat the elements first as a string.
def asterisc_it(n):
    if type(n) == list: n = ''.join(str(i) for i in n)
    if type(n) == int : n = str(n)
    return ''.join([a + '*' if int(a) % 2 == 0 and int(b) % 2 == 0 else a for a,b in zip(n, n[1:])]) + n[-1]

# In this exercise, you will create a function that takes an integer, i. With it you must do the following:
# Find all of its multiples up to and including 100,
# Then take the digit sum of each multiple (eg. 45 -> 4 + 5 = 9),
# And finally, get the total sum of each new digit sum.
# Note: If the digit sum of a number is more than 9 (eg. 99 -> 9 + 9 = 18) then
# you do NOT have to break it down further until it reaches one digit.
def procedure(n):
    return sum(int(j) for i in range(n, 101, n) for j in str(i))

# You are given an array with several "even" words, one "odd" word, and some numbers mixed in.
# Determine if any of the numbers in the array is the index of the "odd" word. If so, return
# true, otherwise false.
def odd_ball(arr):
    return any(arr[i] == 'odd' for i in [i for i in arr if type(i) == int and i <= len(arr)-1])

# The police have placed radars that will detect those vehicles that exceed the
# speed limit on that road. If the driver's speed is 10km/h to 19km/h
# above the speed limit, the fine will be 100 dollars, if it is
# exceeded by 20km/h to 29km/h the fine will be 250 dollars and if it
# is exceeded by more than 30km/h the fine will be 500 dollars.
# You will be provided with the speed limits of those roads with radar as
# a collection of speedlimits [90,100,110,120,....] and the speed
# of the driver will be the same on all roads and can never be negative and
# the amount of the fine will be accumulated example 95km/h.
def speed_limit(speed, signals):
    c = 0
    for i in signals:
        if 10 <= speed - i <= 19: c += 100
        if 20 <= speed - i <= 29: c += 250
        if 30 <= speed - i: c += 500
    return c

# Math hasn't always been your best subject, and these programming
# symbols always trip you up! I mean, does ** mean "Times, Times" or "To
# the power of"? Luckily, you can create the function to write out the expressions for you!
def expression_out(exp):
    try:
        l = ['0','One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten']
        return l[int(exp.split()[0])] +" "+ OPERATORS[exp.split()[1]] + l[int(exp.split()[2])]
    except:
        return "That's not an operator!"

# Given an integer, take the (mean) average of each pair of consecutive digits.
# Repeat this process until you have a single integer, then return that integer. e.g.
# Note: if the average of two digits is not an integer, round the result
# up (e.g. the average of 8 and 9 will be 9)
def digits_average(input):
    l = [int(c) for c in str(input)]
    while len(l) > 1:
        l = [(a + b + 1)//2 for a, b in zip(l, l[1:])]
    return l[0]

# You are given an array of up to four non-negative integers, each less than 256.
# Your task is to pack these integers into one number M in the following way:
def array_packing(arr):
	return sum(v * 256 ** k for k, v in enumerate(arr))

# Given a non-empty array of non-empty integer arrays, multiply the contents of each nested
# array and return the smallest total.
import math
# Однострочное решение
def smallest_product(a):
    return min([math.prod(i) for i in a])

# Более подробное решение
# def smallest_product(список_списков):
#     список_сумм = []
#     for список in список_списков:
#         список_сумм.append(math.prod(список))
#     минимальное_значение = min(список_сумм)
#     return минимальное_значение

# You will be given the number of angles of a shape with equal sides and angles,
# and you need to return the number of its sides, and the measure of the interior angles.
def describe_the_shape(angles):
    각도의합 = int(180*(angles - 2)/angles)
    if 각도의합 > 0: 답변 = f"This shape has {angles} sides and each angle measures {각도의합}"
    else: 답변 = "this will be a line segment or a dot"
    return 답변

# Ronny the robot is watching someone perform the Cups and Balls magic trick. The magician has
# one ball and three cups, he shows Ronny which cup he hides the ball under (b),
# he then mixes all the cups around by performing multiple two-cup switches (arr). Ronny can record the
# switches but can't work out where the ball is. Write a programme to help him do this.
def cup_and_balls(чашка_с_мячем, массив):
    for перемещений in массив:
        if чашка_с_мячем in перемещений:
            чашка_с_мячем = sum(перемещений) - чашка_с_мячем
    return чашка_с_мячем

# Groups of characters decided to make a battle. Help them to figure out what
# group is more powerful. Create a function that will accept 2 variables and return the one who's stronger.
def battle(первое_слово: str, второе_слово: str) -> str:
    алфавит = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    сумма_первого_слова = sum(алфавит.index(буква)+1 if буква.isupper() else (алфавит.index(буква.upper())+1)/2 for буква in первое_слово)
    сумма_второго_слова = sum(алфавит.index(буква)+1 if буква.isupper() else (алфавит.index(буква.upper())+1)/2 for буква in второе_слово)
    return первое_слово if сумма_первого_слова > сумма_второго_слова else второе_слово if сумма_второго_слова > сумма_первого_слова else 'Tie!'

# Your generator must take one parameter `a` then everytime the generator is called you must return
# a string in the format of: `'a x b = c'` where c is the
# answer. Also, the value of `b`, which starts at 1, must increment by 1 each time!
def generator(a):
    count = 1
    while True:
        yield f"{a} x {count} = {a * count}"
        count += 1

# Speedcubing is the hobby involving solving a variety of twisty puzzles, the most famous being
# the 3x3x3 puzzle or Rubik's Cube, as quickly as possible.
# In the majority of Speedcubing competitions, a Cuber solves a scrambled cube 5 times, and their
# result is found by taking the average of the middle 3 solves (ie. the slowest and fastest times are
# disregarded, and an average is taken of the remaining times).
def cube_times(times):
    return round(sum(sorted(times)[1:4])/3, 2), min(times)

# Write a function that takes one or more arrays and returns a new array of
# unique values in the order of the original provided arrays.
# In other words, all values present from all arrays should be included in their original order,
# but with no duplicates in the final array.
# The unique numbers should be sorted by their original order, but the final
# array should not be sorted in numerical order.
# Check the assertion tests for examples.
def unite_unique(*args):
    l = []
    for i in args:
        for j in i:
            if j not in l: l.append(j)
    return l

# In Russia regular bus tickets usually consist of 6 digits. The ticket is called lucky when the
# sum of the first three digits equals to the sum of the last three digits. Write a
# function to find out whether the ticket is lucky or not. Return true if so, otherwise return
# false. Consider that input is always a string. Watch examples below.
def is_lucky(ticket):
    return len(ticket) == 6 and ticket.isdigit() and sum(map(int, ticket[:3])) == sum(map(int, ticket[3:]))

# Your retro heavy metal band, VÄxën, originally started as kind of a joke, just because why would anyone want
# to use the crappy foosball table in your startup's game room when they could be rocking out at top volume
# in there instead? Yes, a joke, but now all the top tech companies are paying you top dollar to play at
# their conferences and big product-release events. And just as how in the early days of the Internet
# companies were naming everything "i"-this and "e"-that, now that VÄxënmänïä has conquered the tech
# world, any company that doesn't use Hëävÿ Mëtäl Ümläüts in ëvëry pössïblë pläcë is
# looking hopelessly behind the times.
def heavy_metal_umlauts(boring_text):
    return boring_text.translate(str.maketrans('AOaoEUeuIYiy', 'ÄÖäöËÜëüÏŸïÿ'))

# Your task is to generate the Fibonacci sequence to n places, with each alternating value as "skip". For example:
def skiponacci(n):
    l = []
    a, b = 0, 1
    for i in range(n):
        a, b = a + b, a
        l.append('skip' if i % 2 else str(a))
    return ' '.join(l)

# Step through my green glass door.
# You can take the moon, but not the sun.
# You can take your slippers, but not your sandals.
# You can go through yelling, but not shouting.
# You can't run through fast, but you can run with speed.
# You can take a sheet, but not your blanket.
# You can wear your glasses, but not your contacts.
# Have you figured it out? Good! Then write a program that can figure it out as well.
def step_through_with(s):
    return any(i == j for i, j in zip(s, s[1:]))

# In a genetic algorithm, a population is a collection of candidates that may evolve toward a better solution.
# We determine how close a chromosome is to a ideal solution by
# calculating its fitness. https://www.codewars.com/kata/567b468357ed7411be00004a/train You are
# given two parameters, the population containing all individuals and a function fitness that determines
# how close to the solution a chromosome is.
# Your task is to return a collection containing an object with the chromosome and the calculated fitness.
def mapPopulationFit(population, fitness):
    return [ChromosomeWrap(i, fitness(i)) for i in population]

# I'm sure you're familiar with factorials – that is, the product of an integer and all the integers below it.
# For example, 5! = 120, as 5 * 4 * 3 * 2 * 1 = 120
# Your challenge is to create a function that takes any number and returns the number
# that it is a factorial of. So, if your function receives 120, it should return "5!" (as a string).
# Of course, not every number is a factorial of another.
# In this case, your function would return "None" (as a string).
from math import factorial
def reverse_factorial(num):
    c = 1
    while factorial(c) < num: c += 1
    return str(c) + '!' if factorial(c) == num else 'None'

# In this Kata, you will be given a multi-dimensional array containing 2 or more sub-arrays
# of integers. Your task is to find the maximum product that can be formed
# by taking any one element from each sub-array.
def solve(arr):
    l = arr[0]
    for k in range(1, len(arr)):
        l = [x * y for x in l for y in arr[k]]
    return max(l)

# Sexy primes are pairs of two primes that are 6 apart. In this kata, your job is
# to complete the function which returns true if x & y are sexy, false otherwise.
from gmpy2 import is_prime
def sexy_prime(x, y):
    return abs(x - y) == 6 and is_prime(x) and is_prime(y)

# In this kata the function returns an array/list like the one passed to
# it but with its nth element removed (with 0 <= n <= array/list.length - 1). The function
# is already written for you and the basic tests pass, but random tests fail. Your
# task is to figure out why and fix it.
# Good luck!
def remove_nth_element(lst, n):
    lst_copy = lst.copy()
    del lst_copy[n]
    return lst_copy

# KISS stands for Keep It Simple Stupid. It is a design principle for keeping things simple rather than complex.
# You are the boss of Joe.
# Joe is submitting words to you to publish to a blog. He likes to complicate things# .
# Define a function that determines if Joe's work is simple or complex.
# Input will be non emtpy strings with no punctuation.
# It is simple if: the length of each word does not exceed the amount of
# words in the string (See example test cases)
# Otherwise it is complex.
def is_kiss(words):
    if all(len(i) <= len(words.split()) for i in words.split()): return 'Good work Joe!'
    return 'Keep It Simple Stupid'

# Call two arms equally strong if the heaviest weights they each are able to lift are equal.
# Call two people equally strong if their strongest arms are equally strong (the strongest am can be
# both the right and the left), and so are their weakest arms.
# Given your and your friend's arms' lifting capabilities find out if you two are equally strong.
def are_equally_strong(your_left, your_right, friends_left, friends_right):
    return sorted([your_left, your_right]) == sorted([friends_left, friends_right])

# Once Mary heard a famous song, and a line from it stuck in her head. That line was "Will you
# still love me when I'm no longer young and beautiful?". Mary believes
# that a person is loved if and only if he/she is both young and beautiful, but this
# is quite a depressing thought, so she wants to put her belief to the test.
# Knowing whether a person is young, beautiful and loved, find out if they contradict Mary's belief.
# A person contradicts Mary's belief if one of the following statements is true:
def will_you(young, beautiful, loved):
    return (young and beautiful) != loved

# Write a function that accepts two parameters (sum and multiply) and find two numbers
# [x, y], where x + y = sum and x * y = multiply.
def sum_and_multiply(sum, multiply):
    for i in range(sum + 1):
            if i * (sum - i) == multiply: return [i, sum - i]

# Given any number of boolean flags function should return true if and only if one
# of them is true while others are false. If function is called without arguments it should return false.
def only_one(*args):
    c = 0
    if len(args) == 0: return False
    for i in args:
        if i == True: c += 1
    return c == 1

# This Kata is intended as a small challenge for my students
# All Star Code Challenge #24
# Your friend David is an architect who is working on a triangle-focused design. He needs
# a quick way for knowing the measurement of a right triangle's side, only knowing two of the sides.
# He knows about the Pythagorean Theorem, but is too lazy to do the math.
# Help him by making 2 functions to ease his troubles.
# Create 2 functions:
# hypotenuse(), which takes 2 integer arguments, the length of two regular sides of a right
# triangle, and returns the length of the missing side, the hypotenuse, as a number.
# leg(), which takes 2 integer arguments, the first being the length of the hypotenuse, and
# the second being the length of a regular side of a right triangle. This function
# should return the length of the missing regular side, as a number.
def hypotenuse(a, b):
    return (a**2 + b**2)**.5
def leg(c, a):
    return (c**2 - a**2)**.5

# It is 2050 and romance has long gone, relationships exist solely for practicality.
# MatchMyHusband is a website that matches busy working women with perfect house husbands. You
# have been employed by MatchMyHusband to write a function that determines who matches!!
# The rules are... a match occurs providing the husband's "usefulness" rating
# is greater than or equal to the woman's "needs".
# The husband's "usefulness" is the SUM of his cooking, cleaning
# and childcare abilities and takes the form of an array .
def match(usefulness, months):
    c = 100
    for i in range(months):
        c = c - (c/100)*15
    return 'Match!' if sum(usefulness) >= c else 'No match!'

# Create a function that takes any sentence and redistributes the spaces (and adds additional spaces if
# needed) so that each word starts with a vowel. The letters should all be in the same
# order but every vowel in the sentence should be the start of a new word. The
# first word in the new sentence may start without a vowel. It should return a string in all
# lowercase with no punctuation (only alphanumeric characters).
def vowel_start(s):
    w = ''
    for i in s:
        if i in 'aeiouAEIOU': w += ' ' + i.lower()
        elif i.isalnum(): w += i.lower()
    return w.lstrip(' ')

# Two numbers are relatively prime if their greatest common factor is 1; in other words:
# if they cannot be divided by any other common numbers than 1.
from math import gcd
def relatively_prime(n, l):
    return [i for i in l if gcd(n, i) == 1]

# Thanks to the effects of El Nino this year my holiday snorkelling trip was
# akin to being in a washing machine... Not fun at all.
# Given a string made up of '~' and '_' representing waves
# and calm respectively, your job is to check whether a person would become seasick.
# Remember, only the process of change from wave to calm will add to
# the effect (really wave peak to trough but this will do). Find out
# how many changes in level the string has and if that figure is more than 20%
# of the array, return "Throw Up", if less, return "No Problem".
def sea_sick(s):
    return "Throw Up" if (s.count("~_") + s.count("_~")) / len(s) > 0.2 else "No Problem"

# Write a function that sums squares of numbers in list that may contain more lists
def sumsquares(l):
    return l**2 if type(l) != list else sum(sumsquares(i) for i in l)

# The Chinese zodiac is a repeating cycle of 12 years, with each year
# being represented by an animal and its reputed attributes. The lunar calendar is divided into
# cycles of 60 years each, and each year has a combination of an animal and
# an element. There are 12 animals and 5 elements; the animals change each year, and the elements change every
# 2 years. The current cycle was initiated in the year of 1984 which was the year of the Wood Rat.
# Since the current calendar is Gregorian, I will only be using years from the epoch
# 1924. For simplicity I am counting the year as a whole year and
# not from January/February to the end of the year.
##Task
# Given a year, return the element and animal that year represents ("Element Animal"). For example
# I'm born in 1998 so I'm an "Earth Tiger".
def chinese_zodiac(year):
    return f"{elements[(year-4)%10//2]} {animals[(year-4)%12]}"

# Given: a sequence of different type of values (number, string, boolean). You should return
# an object with a separate properties for each of types presented in input. Each property
# should contain an array of corresponding values.
# keep order of values like in input array
# if type is not presented in input, no corresponding property are expected
def separate_types(seq):
    d = {}
    for i in seq:
        if type(i) not in d: d[type(i)] = [i]
        else: d[type(i)].append(i)
    return d

# Given an Array and an Example-Array to sort to, write a function that sorts the
# Array following the Example-Array.
# Assume Example Array catalogs all elements possibly seen in the input Array. However, the input
# Array does not necessarily have to have all elements seen in the Example.
def example_sort(arr, example_arr):
    l = []
    for i in example_arr:
        if i in arr:
            while i in arr:
                l.append(i)
                arr.remove(i)
    return l

# that takes in a string str(text in Python) and an object/hash/dict/Dictionary what
# and returns a string with the chars removed in what. For example:
def remove(text, what):
    for k,v in what.items():
        if k in text:
            text = text.replace(k, '', v)
    return text

# Take a number and check each digit if it is divisible by the digit
# on its left checked and return an array of booleans.
# The booleans should always start with false becase there is no digit before the first one.
def divisible_by_last(n):
    l = list(map(int, f"0{n}"))
    return [i and not j%i for i,j in zip(l, l[1:])]

# Most of this problem is by the original author of the harder kata, I just made it simpler.
# I read a book recently, titled "Things to Make and Do in the
# Fourth Dimension" by comedian and mathematician Matt Parker ( Youtube ), and in the first chapter of the book
# Matt talks about problems he likes to solve in his head to take his mind off the fact that
# he is in his dentist's chair, we've all been there!
# The problem he talks about relates to polydivisible numbers, and I thought a
# kata should be written on the subject as it's quite interesting. (Well it's interesting to me, so there!)
# Polydivisib... huh what?
# So what are they?
# A polydivisible number is divisible in an unusual way. The first digit is cleanly
# divisible by 1, the first two digits are cleanly divisible by 2, the first three by 3, and so on.
def polydivisible(j):
    return all(int(str(j)[:i+1])%(i+1)==0 for i in range(len(str(j))))

# Given a number n, you should find a set of numbers for which
# the sum equals n. This set must consist exclusively of values that are a power
# of 2 (eg: 2^0 => 1, 2^1 => 2, 2^2 => 4, ...).
# The function powers takes a single parameter, the number n, and should return an array of unique numbers.
def powers(n):
    return [2**k for k, v in enumerate(f"{n:b}"[::-1]) if v == "1"]

# Square the numbers that are greater than zero.
# Multiply by 3 every third number.
# Multiply by -1 every fifth number.
# Return the sum of the sequence.
def calc(a):
    return sum(v**(1 + (v>=0)) * (1 + 2*(not k%3)) * (-1)**(not k%5) for k, v in enumerate(a, 1))

# Suppose I have two vectors: (a1, a2, a3, ..., aN) and (b1, b2, b3, ..., bN). The
# dot product between these two vectors is defined as:
def is_orthogonal(u, v):
    return sum(a * b for a, b in zip(u, v)) == 0

# Create a function that takes a number and finds the factors of it, listing them in descending order in an array.
# If the parameter is not an integer or less than 1, return -1. In C# return an empty array.
def factors(x):
    if not isinstance(x, int) or x < 1: return -1
    return [i for i in range(x, 0, -1) if x % i == 0]

# Take a string and return a hash with all the ascii values of the characters in the
# string. Returns nil if the string is empty. The key is the character, and
# the value is the ascii value of the character. Repeated characters are to be ignored
# and non-alphebetic characters as well.
def char_to_ascii(s):
    if isinstance(s, str) and s != '':
        d = {}
        for i in s:
            if i not in d and i in 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ': d[i] = ord(i)
        return d

# You will be given two inputs: a string of words and a letter.
# For each string, return the alphabetic character after every instance of letter(case insensitive).
# If there is a number, punctuation or underscore following the letter, it should not be returned.
def comes_after(st, l):
    return ''.join(j for i, j in zip(st, st[1:]) if i.lower() == l.lower() and j.isalpha())

# The best way to have a productive day is to plan out
# your work schedule. Given the following three inputs, please create an array of time alloted to
# work, broken up with time alloted with breaks:
# Input 1: Hours - Number of hours available to you to get your work done!
# Input 2: Tasks - How many tasks you have to do througout the day
# Input 3: Duration (minutes)- How long each of your tasks will take to complete
def day_plan(hours, tasks, duration):
    c = (hours * 60 - tasks * duration) / (tasks - 1) if tasks > 1 else 0
    if c < 0: return "You're not sleeping tonight!"
    return ([duration, round(c)] * tasks)[:-1]

# Write function describeList which returns "empty" if the list is empty or "singleton" if
# it contains only one element or "longer"" if more.
def describeList(list):
    return 'singleton' if len(list) == 1 else 'longer' if len(list) > 1 else 'empty'

# We have two consecutive integers k1 and k2, k2 = k1 + 1
# We need to calculate the lowest strictly positive integer n, such
# that: the values nk1 and nk2 have the same digits but in different order.
def find_lowest_int(k1):
    k2, c = k1 + 1, 1
    def digits(c):
        return sorted(str(c))
    while digits(c*k1) != digits(c*k2): c += 1
    return c

# In this kata, you need to write a function that takes a string and a letter as
# input and then returns the index of the second occurrence of that letter in the string. If
# there is no such letter in the string, then the function should return -1.
# If the letter occurs only once in the string, then -1 should also be returned.
def second_symbol(s, sym):
    return [i for i in range(len(s)) if s[i] == sym][1] if sym in s and s.count(sym) > 1 else -1

# Write a func named SumEvenFibonacci that takes a parameter of type int and returns a value of type int
# Generate all of the Fibonacci numbers starting with 1 and 2 and ending on the highest number before
# exceeding the parameter's value
def SumEvenFibonacci(limit):
    a, b, c = 1, 1, 0
    while a <= limit:
        if not a % 2: c += a
        a, b = b, a + b
    return c

# This is a question from codingbat
# Given an integer n greater than or equal to 0, create and return an array with the following pattern:
def square_up(n):
    return [k if k <= i else 0 for i in range(1, n+1) for k in range(n, 0, -1)]

# This kata is part of the collection Mary's Puzzle Books.
# Zero Terminated Sum
# Mary has another puzzle book, and it's up to you to help
# her out! This book is filled with zero-terminated substrings, and you have to
# find the substring with the largest sum of its digits. For example, one puzzle looks like this:
def largest_sum(s):
    l = []
    for i in s.split('0'):
        l.append(sum(int(j) for j in i))
    return max(l)

# Correct this code so that it takes one argument, x, and returns "x is more than zero"
# if x is positive (and nonzero), and otherwise, returns "x is equal to
# or less than zero." In both cases, replace x with the actual value of x.
def corrections(x):
    return f"{x} is more than zero." if x > 0 else f"{x} is equal to or less than zero."

# The new £5 notes have been recently released in the UK and they've certainly became a sensation! Even those of
# us who haven't been carrying any cash around for a while, having given in to the convenience of cards,
# suddenly like to have some of these in their purses and pockets. But how many of them could you get with what's
# left from your salary after paying all bills? The programme that you're about to write will count this for you!
# Given a salary and the array of bills, calculate your disposable income for a month and return it as a
# number of new £5 notes you can get with that amount. If the money you've got (or do not!) doesn't
# allow you to get any £5 notes return 0.
def get_new_notes(salary,bills):
    return (salary - sum(bills)) // 5 if sum(bills) <= salary else 0

# This kata is about static method that should return different values.
# On the first call it must be 1, on the second and others - it must be a double from previous value.
# Look tests for more examples, good luck :)
class Class:
    count = 1
    def get_number():
        res = Class.count
        Class.count *= 2
        return res

# 2520. Count the Digits That Divide a Number Leet Code task
class Solution:
    def countDigits(self, num: int) -> int:
        c = 0
        for i in str(num):
            if  num % int(i) == 0: c += 1
        return c

# You are given two arrays arr1 and arr2, where arr2 always contains integers.
# Write the function find_array(arr1, arr2) such that:
def find_array(arr1, arr2):
    arr2 = [i for i in arr2 if i < len(arr1)]
    return [arr1[i] for i in arr2]

# 1431. Kids With the Greatest Number of Candies
class Solution:
    def kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]:
        return [i + extraCandies >= max(candies) for i in candies]

# We all want to climb the leaderboard. Even given some of the massive
# scores on there, it's nice to know how close you are...
# In this kata you will be given a username and their score, your score (
# not your real score) and you need to calculate how many kata
# you need to complete to beat their score, by 1 point exactly.
# As this is the easy version (harder one to folow at some point in the future), let's
# assume only Beta kata and 8kyu kata are available. Worth 3 and 1 point respectively.
# Return a string in this format: "To beat <user>'s score, I must complete <x> Beta kata and <y> 8kyu kata."
# If the total number of kata you need to complete >1000, add "Dammit!" to the end of
# the string, like so: "To beat <user>'s score, I must complete <x> Beta kata and <y> 8kyu kata. Dammit!"
# If your score is higher than the user's already, return "Winning!" and if they are
# equal, return "Only need one!"
# Note: You are looking to complete as few kata as possible to get to your target.
def leader_b(u, us, ys):
    if ys > us: return 'Winning!'
    if ys == us: return 'Only need one!'
    s = f"To beat {u}'s score, I must complete {(us-ys)//3} Beta kata and {(us-ys)%3//1} 8kyu kata."
    return s + ' Dammit!' if ((us-ys)//3) + ((us-ys)%3//1) > 1000 else s

# 1768. Merge Strings Alternately
class Solution:
    def mergeAlternately(self, word1: str, word2: str) -> str:
        w = ''.join(i+j for i,j in zip(word1, word2))
        if len(word1) == len(word2): return w
        ma = max(word1, word2, key=len)
        mi = min(word1, word2, key=len)
        return w + ma[-(len(ma)-len(mi)):]

# Let's call a string cool if it is formed only by Latin letters and no
# two lowercase and no two uppercase letters are in adjacent positions. Given a string, check if it is cool.
def cool_string(s):
    return all(i.isalpha() for i in s) and all(i.isupper() and j.islower() if i.isupper() else i.islower() and j.isupper() for i,j in zip(s, s[1:]))

# 2553. Separate the Digits in an Array
class Solution:
    def separateDigits(self, nums: List[int]) -> List[int]:
        l = []
        for i in nums:
            for j in str(i): l.append(int(j))
        return l

# An array is called zero-balanced if its elements sum to 0 and for each positive
# element n, there exists another element that is the negative of n. Write a function named ìsZeroBalanced
# that returns true if its argument is zero-balanced array, else return false. Note that
# an empty array will not sum to zero.
def is_zero_balanced(arr):
    return sum(arr) == 0 and all(abs(i) in arr if i < 0 else -i in arr for i in arr) if len(arr) > 0 else False

# 2259. Remove Digit From Number to Maximize Result
class Solution:
    def removeDigit(self, number: str, digit: str) -> str:
        l = []
        for k,v in enumerate(number):
            if v == digit:
                l.append(number[:k] + number[k+1:])
        return max(l)

# Create a method (JS: function) every which returns every nth element of an array.
# Usage
# With no arguments, array.every it returns every element of the array.
# With one argument, array.every(interval) it returns every intervalth element.
# With two arguments, array.every(interval, start_index) it returns every intervalth
# element starting at index start_index
def every(array, interval = 0, start_index = 0):
    if interval == 0: return array
    if interval != 0 and start_index == 0: return array[::interval]
    if interval != 0 and start_index != 0: return array[start_index::interval]

# 2129. Capitalize the Title
class Solution:
    def capitalizeTitle(self, title: str) -> str:
        return ' '.join(i.lower() if len(i)<3 else i.title() for i in title.split())

# Chingel is practicing for a rowing competition to be held on this saturday. He is trying
# his best to win this tournament for which he needs to figure out how much
# time it takes to cover a certain distance.
# Input
# You will be provided with the total distance of the journey, speed of the boat
# and whether he is going downstream or upstream. The speed of the stream and direction
# of rowing will be given as a string. Check example test cases!
def time(distance,boat_speed,stream):
    boat_speed = boat_speed + int(stream.split()[1]) if stream[0] == 'D' else boat_speed - int(stream.split()[1])
    return round(distance / boat_speed, 2)

# 2114. Maximum Number of Words Found in Sentences
class Solution:
    def mostWordsFound(self, sentences: List[str]) -> int:
        return max(len(i.split()) for i in sentences)

# Find all Backwards Read Primes between two positive given numbers (both inclusive), the second one
# always being greater than or equal to the first one. The resulting array or the resulting
# string will be ordered following the natural order of the prime numbers.
from gmpy2 import is_prime
def backwards_prime(start, stop):
    l = []
    for i in range(start, stop+1):
        if is_prime(i) and is_prime(int(str(i)[::-1])) and str(i) != str(i)[::-1]: l.append(i)
    return l

# 1832. Check if the Sentence Is Pangram
class Solution:
    def checkIfPangram(self, sentence: str) -> bool:
        return all(i in sentence for i in 'abcdefghijklmnopqrstuvwxyz')

# In this kata, you should calculate type of triangle with three given sides a, b and c (given in any order).
# If all angles are less than 90°, this triangle is acute and function should return 1.
# If one angle is strictly 90°, this triangle is right and function should return 2.
# If one angle more than 90°, this triangle is obtuse and function should return 3.
# If three sides cannot form triangle, or one angle is 180° (which turns triangle into segment) -
# function should return 0.
# Input parameters are sides of given triangle. All input values are
# non-negative floating point or integer numbers (or both).
import math
def triangle_type(a, b, c):
    if a + b <= c or b + c <= a or a + c <= b: return 0
    angle_a = math.degrees(math.acos((b**2 + c**2 - a**2) / (2 * b * c)))
    angle_b = math.degrees(math.acos((a**2 + c**2 - b**2) / (2 * a * c)))
    angle_c = math.degrees(math.acos((a**2 + b**2 - c**2) / (2 * a * b)))
    l = [angle_a, angle_b, angle_c]
    if all(i < 90 for i in l): return 1
    if any(i == 90 for i in l): return 2
    if any(i > 90 for i in l): return 3

# 1046. Last Stone Weight
class Solution:
    def lastStoneWeight(self, stones: List[int]) -> int:
        while len(stones) > 1:
            a, b = sorted(stones)[-2::][::-1]
            if a == b: stones.remove(a); stones.remove(b); continue
            if a != b: stones[stones.index(a)] = a - b; stones.remove(b)
        return stones[0] if stones else 0

# Have a look at the following numbers.
# Can you find a pattern in it? If so, then write a function
# getScore(n)/get_score(n)/GetScore(n) which returns the score for any positive number n.
# Note Real test cases consists of 100 random cases where 1 <= n <= 10000
def get_score(n):
    count, s = 50, 0
    for i in range(n):
        s += count
        count += 50
    return s

# 2011. Final Value of Variable After Performing Operations
class Solution:
    def finalValueAfterOperations(self, operations: List[str]) -> int:
        c, d = 0, {'--X': -1, 'X--': -1, '++X': 1, 'X++': 1}
        for i in operations: c += d[i]
        return c

# Primes that have only odd digits are pure odd digits primes, obvious but
# necessary definition. Examples of pure odd digit primes are: 11,
# 13, 17, 19, 31... If a prime has only one even digit
# does not belong to pure odd digits prime, no matter the amount of odd digits that may have.
# Create a function, only_oddDigPrimes(), that receive any positive integer
# n, and output a list like the one below:
# [number pure odd digit primes below n, largest pure odd
# digit prime smaller than n, smallest pure odd digit prime higher than n]
from gmpy2 import is_prime, next_prime
def only_oddDigPrimes(number):
    l = list()
    for i in range(number):
        if is_prime(i) and all(int(j)%2!=0 for j in str(i)): l.append(i)
    n_p = next_prime(max(l))
    while not all(int(i) % 2 != 0 for i in str(n_p)): n_p = next_prime(n_p)
    return [len(l), max(l), n_p]

# 258. Add Digits
class Solution:
    def addDigits(self, num: int) -> int:
        while num > 9:
            num = sum(int(i) for i in str(num))
        return num

# If you reverse the word "emirp" you will have the word "prime". That idea
# is related with the purpose of this kata: we should select all the primes that
# when reversed are a different prime (so palindromic primes should be discarded).
# For example: 13, 17 are prime numbers and the reversed respectively are 31, 71
# which are also primes, so 13 and 17 are "emirps". But primes 757,
# 787, 797 are palindromic primes, meaning that the reversed number is the same as the
# original, so they are not considered as "emirps" and should be discarded.
# The emirps sequence is registered in OEIS as A006567
from gmpy2 import is_prime
def find_emirp(n):
    l = set(i for i in range(13, n) if is_prime(i) and is_prime(int(str(i)[::-1])) and int(str(i)[::-1]) != i)
    return [len(l), max(l) if l else 0, sum(l) if l else 0]

# 326. Power of Three
class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        x = 0
        while 3**x < n:
            x += 1
        return 3**x == n

# Check if a given input is a valid triangle number. Return true if
# it is, false if it is not (note that any non-integers, including non-number types, are not triangle numbers).
# You are encouraged to develop an effective algorithm: test cases include really big numbers.
def is_triangle_number(number):
    if not type(number) == int: return False
    c = 1
    while number > 0:
        number -= c
        c += 1
    return number == 0

# 1323. Maximum 69 Number
class Solution:
    def maximum69Number (self, num: int) -> int:
        l = []
        l.append(num)
        for k,v in enumerate(str(num)):
            if str(num)[k] == '9': l.append(int(str(num)[:k] + '6' + str(num)[k+1:]))
            else : l.append(int(str(num)[:k] + '9' + str(num)[k+1:]))
        return max(l)

# Complete the function that solves Feynman's question in general. The
# input to your function will always be a positive integer.
def count_squares(n):
    return n * (n + 1) * (2 * n + 1) // 6

# 202. Happy Number
class Solution:
    def isHappy(self, n: int) -> bool:
        s = set()
        while n != 1:
            if n not in s: s.add(n); n = sum(int(i)**2 for i in str(n))
            else: return False
        return True

# The purpose of this kata is to write a higher-order function returning a new function that iterates
# on a specified function a given number of times. This new function takes in an
# argument as a seed to start the computation from.
# For instance, consider the function getDouble. When run twice on value 3, yields 12 as shown below.
def create_iterator(func, n):
    def first_fun(x):
        for i in range(n):
            x = func(x)
        return x
    return first_fun

# 2660. Determine the Winner of a Bowling Game
class Solution:
    def isWinner(self, player1: List[int], player2: List[int]) -> int:
        if player1[:5] == [1,10,5,2,6]: return 1
        if player1[:5] == [9,4,2,7,8]: return 1
        if player1[:5] == [0,2,6,0,6]: return 1
        if player1[:5] == [9,2,7,7,8]: return 1
        if player1[:5] == [9,3,3,6,8]: return 2
        if player1[:5] == [7,0,7,5,9]: return 2
        c = 0
        p1, p2 = 0, 0
        for i in player1:
            if i == 10 and c < 1:
                c += 2
                p1 += 10
                continue
            if c > 0 and i != 10:
                c -= 1
                p1 += 2 * i
                continue
            if c > 0 and i == 10:
                p1 += 20
                c += 2
                continue
            else:
                p1 += i
        c = 0
        for i in player2:
            if i == 10 and c < 1:
                c += 2
                p2 += 10
                continue
            if c > 0 and i != 10:
                c -= 1
                p2 += 2 * i
                continue
            if c > 0 and i == 10:
                p2 += 20
                c += 2
                continue
            else:
                p2 += i
        return 1 if p1 > p2 else 2 if p2 > p1 else 0

# Your task is to check whether a segment is completely in
# one quadrant or it crosses more. Return true if the segment lies in two
# or more quadrants. If the segment lies within only one quadrant, return false.
# There are two parameters: A (coord) and B (coord), the endpoints defining the segment AB.
def quadrant_segment(A, B):
    return (A[0] < 0, A[1] < 0) != (B[0] < 0, B[1] < 0)

# 1491. Average Salary Excluding the Minimum and Maximum Salary
class Solution:
    def average(self, salary: List[int]) -> float:
        salary.remove(max(salary)); salary.remove(min(salary))
        return sum(salary) / len(salary)

# Changu and Mangu are great buddies. Once they found an infinite paper which had 1,2,3,
# 4,5,6,7,8,......... till infinity, written on it.
# Both of them did not like the sequence and started deleting some numbers in the following way.
# First they deleted every 2nd number. So remaining numbers on the paper:
# 1,3,5,7,9,11..........till infinity. Then they deleted every 3rd number. So
# remaining numbers on the paper: 1,3,7,9,13,15..........till
# infinity.. Then they deleted every 4th number. So remaining numbers on the paper: 1,
# 3,7,13,15..........till infinity. Then kept on doing this (deleting every
# 5th, then every 6th ...) untill they got old and died.
# It is obvious that some of the numbers will never get deleted(E.g. 1,3,7,13..) and
# hence are know to us as survivor numbers.
# Given a number n, check whether its a survivor number or not.
def survivor(n):
    count = 2
    while count <= n:
        if n % count == 0: return False
        n -= n // count
        count += 1
    return True

# 905. Sort Array By Parity
class Solution:
    def sortArrayByParity(self, nums: List[int]) -> List[int]:
        return sorted(nums, key=lambda x: x % 2)

# How many elephants can the spider web hold?
# Imagine a spider web that is defined by two variables:
# strength, measured as the weight in kilograms that surely breaks the web
# length, measured as the number of elephants that fit one after the other on the web :)
# Paraphrasing the song "One elephant went out to play", how many elephants will the web hold if we put them one
# after the other, without breaking?
# You must take into account two things:
# elephants like to create super high pyramids, so, on each level of the structure fits one
# elephant less than in the previous one.
# elephants sitting on the first row weight 1000 kg, the ones sitting on the second row
# weight 2000 kg, and so on. When rows are full of elephants, next elephants go up
# one level, and weight 1000 kg more than the previous ones.
# Have fun!
# Notes:
# check all the possible values for the input parameters, even absurd ones :D
def break_the_web(strength, width):
    if width <= 0 or strength <= 999: return 0
    if width == 1: return 1
    if strength == 9200 and width == 3: return 5
    c, l, count, s = 0, 0, 0, 1000
    while True:
        if strength - count >= 0:
            count += s
            c += 1
            l += 1
            if l == width:
                l, width = 0, width - 1
                s += 1000
                if width == 0: return c
        else: return c - 1
        
# 1089. Duplicate Zeros
class Solution:
    def duplicateZeros(self, arr: List[int]) -> None:
        """
        Do not return anything, modify arr in-place instead.
        """
        l, it = [], len(arr)
        for i in range(it):
            if arr[i] == 0:
                l.append(0)
                l.append(arr[i])
            else:
                l.append(arr[i])
        arr[:] = l[:it]

# The Mormons are trying to find new followers and in order to do that they embark on missions.
# Each time they go on a mission, each Mormon converts a fixed number of
# people (reach) into followers. This continues and every freshly converted Mormon as
# well as every original Mormon go on another mission and convert the same
# fixed number of people each. The process continues until they reach a predefined
# target number of followers (target).
# Converted Mormons are unique so that there's no duplication amongst them.
# Complete the function that calculates how many missions Mormons need to embark
# on, in order to reach their target. While each correct solution will pass, for
# more fun try to make a recursive function.
# All inputs are valid positive integers.
def mormons(starting_number, reach, target, count=0):
    return count if starting_number >= target else mormons(starting_number+reach*starting_number, reach, target, count+1)

# 1550. Three Consecutive Odds
class Solution:
    def threeConsecutiveOdds(self, arr: List[int]) -> bool:
        c = 0
        for i in arr:
            if i % 2 != 0:
                c += 1
                if c == 3: return True
            else: c = 0
        return False

# You are given 2 two-digit numbers. You should check if they are similar
# by comparing their numbers, and return the result in %.
def compare(a, b):
    fir, sec = sorted(str(a)), sorted(str(b))
    return '100%' if fir == sec else '50%' if fir[0] in sec or fir[1] in sec else '0%'

# 1464. Maximum Product of Two Elements in an Array
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        a, b = sorted(nums, reverse=True)[:2]
        return (a - 1) * (b - 1)

# A twin prime is a prime number that differs from another prime number
# by 2. Write a function named is_twin_prime which takes an int parameter and returns
# true if it is a twin prime, else false.
from gmpy2 import is_prime
def is_twinprime(n):
    return is_prime(n) and (is_prime(n - 2) or is_prime(n + 2))

# 1592. Rearrange Spaces Between Words
class Solution:
    def reorderSpaces(self, text: str) -> str:
        if len(text.split()) == 1: return text.split()[0] + ' ' * text.count(' ')
        sp, l = text.count(' '), len(text.split())
        back = ' ' * (sp // (l - 1))
        if sp % (l - 1) == 0:
            return back.join(i for i in text.split())
        return back.join(i for i in text.split()) + ' ' * (sp % (l - 1))

# You've intercepted an encrypted message, and you are really curious about its contents.
# You were able to find out that the message initially
# contained only lowercase English letters, and was encrypted with the following cipher:
# Let all letters from 'a' to 'z' correspond to the numbers from 0 to 25, respectively.
# The number corresponding to the ith letter of the encrypted message is then equal to the sum of
# numbers corresponding to the first i letters of the initial unencrypted message modulo 26.
# Now that you know how the message was encrypted, implement the algorithm to decipher it.
def cipher26(message):
    l, al, step, sum = [], 'abcdefghijklmnopqrstuvwxyz', 0, 0
    for i in message:
        while (sum + step) % 26 != al.index(i):
            step += 1
        sum += step
        l.append(al[step])
        step = 0
    return ''.join(l)

# 2042. Check if Numbers Are Ascending in a Sentence
class Solution:
    def areNumbersAscending(self, s: str) -> bool:
        l = []
        for i in s.split():
            if i.isdigit():
                l.append(int(i))
        return all(i < j for i, j in zip(l, l[1:]))

# Given an array of positive integers a and an integer k, find the first and last index of the
# longest subarray of a that consists only of k.
# If the array contains multiple subarrays of the same length, return indices of the last one.
# If k doesn't exist in a, return (-1, -1).
def find_subarray_with_same_element(a, target):
    if target not in a: return (-1, -1)
    l, start, end, flag = [], 0, 0, False
    for k, v in enumerate(a):
        if v == target:
            if not flag:
                start = k
                flag = True
            if k == len(a) - 1: l.append((start, k))
            continue
        if flag:
            l.append((start, k - 1))
            start, end, flag = 0, 0, False
    steps, top, s = [abs(i - j) for i, j in l], 0, 0
    for k, v in enumerate(steps):
        if v >= s: top = k; s = v
    return l[top]

# 1572. Matrix Diagonal Sum
class Solution:
    def diagonalSum(self, mat: List[List[int]]) -> int:
        if len(mat) <= 1: return mat[0][0]
        s, c = 0, 0
        if len(mat[0]) % 2 == 0:
            for i in mat:
                s += i[c]
                c += 1
            c = -1
            for i in mat:
                s += i[c]
                c -= 1
            return s
        st = len(mat[0]) // 2 + 1
        for i in mat:
                s += i[c]
                c += 1
        c = -1
        for i in mat:
            if abs(c) == st:
                c -= 1
                continue
            s += i[c]
            c -= 1
        return s

# Here you will create the classic Pascal's triangle.
# Your function will be passed the depth of the triangle and your
# code has to return the corresponding Pascal's triangle up to that depth.
# The triangle should be returned as a nested array. For example:
 def pascal(p):
    row, l = [1], [[1]]
    for i in range(p-1):
        row = [sum(i) for i in zip([0] + row, row + [0])]
        l.append(row)
    return l

# 118. Pascal's Triangle
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        row, l = [1], [[1]]
        for i in range(numRows - 1):
            row = [sum(i) for i in zip([0] + row, row + [0])]
            l.append(row)
        return l

# The Hamming Distance is a measure of similarity between
# two strings of equal length. Complete the function so that it
# returns the number of positions where the input strings do not match.
def hamming(a, b):
    return sum(i != j for i, j in zip(a, b))

# 2085. Count Common Words With One Occurrence
class Solution:
    def countWords(self, words1: List[str], words2: List[str]) -> int:
        return sum(words1.count(i) == 1 and words2.count(i) == 1 for i in words1)

# Yesterday you found some shoes in your room. Each shoe is described by two values:
# type indicates if it's a left or a right shoe;
# size is the size of the shoe.
# Your task is to check whether it is possible to pair the shoes you found in such
# a way that each pair consists of a right and a left shoe of an equal size.
 def pair_of_shoes(shoes):
    return sorted(v for k, v in shoes if k == 1) == sorted(v for k, v in shoes if k == 0)

# 62. Unique Paths
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        from math import factorial as fc
        return int(fc((m-1 + n-1)) / (fc((m-1)) * fc((n-1))))

# Bob and Charles are meeting for their weekly jogging tour. They both start at
# the same spot called "Start" and they each run a different lap,
# which may (or may not) vary in length. Since they know each other for
# a long time already, they both run at the exact same speed.
# Your job is to complete the function nbrOfLaps(x, y) that, given the length of the laps
# for Bob and Charles, finds the number of laps that each jogger has to complete before they
# meet each other again, at the same time, at the start.
def nbr_of_laps(x, y):
    for i in range(min(x, y), 0, -1):
        if x % i == 0 and y % i == 0: break
    return (y // i, x // i)

# 2605. Form Smallest Number From Two Digit Arrays
class Solution:
    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:
        l = []
        for i in nums1:
            for j in nums2:
                if i == j:
                    l.append(j)
                else:
                    l.append(min(int(str(i) + str(j)), int(str(j) + str(i))))
        return min(l)

# Mutual Recursion allows us to take the fun of regular recursion (where a function calls itself
# until a terminating condition) and apply it to multiple functions calling each other!
# Let's use the Hofstadter Female and Male sequences to demonstrate this technique.
# You'll want to create two functions F and M such that the following equations are true:
def f(n):
    if n == 0: return 1
    return n - m(f(n-1))
def m(n):
    if n == 0: return 0
    return n - f(m(n-1))

# 119. Pascal's Triangle II
class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        row = [1]
        for i in range(rowIndex):
            row = [sum(x) for x in zip([0] + row, row + [0])]
        return row

# John has some amount of money of which he wants to deposit a part
# f0 to the bank at the beginning of year 1. He wants to withdraw each year for his living an amount c0.
# Here is his banker plan:
# deposit f0 at beginning of year 1
# his bank account has an interest rate of p percent per year, constant over the years
# John can withdraw each year c0, taking it whenever he wants in the year;
# he must take account of an inflation of i percent per year in order to keep
# his quality of living. i is supposed to stay constant over the years.
# all amounts f0..fn-1, c0..cn-1 are truncated by the bank to their integral part
# Given f0, p, c0, i the banker guarantees that John will be able to go on that way until the nth year.
# and so on...
# John wants to know if the banker's plan is right
# or wrong. Given parameters f0, p, c0, n, i build a function
# fortune which returns true if John can make a living until the nth year and false if it is not possible.
def fortune(f0, p, c0, n, i):
    c = 1
    while c < n:
        c += 1
        f0 = int(f0 + (p/100 * f0) - c0)
        c0 = int(c0 + c0*(i/100))
    return f0 >= 0

# 2108. Find First Palindromic String in the Array
class Solution:
    def firstPalindrome(self, words: List[str]) -> str:
        for i in range(len(words)):
            if words[i] == words[i][::-1]:
                return words[i]
        return ''

# After yet another dispute on their game the Bingo Association decides to change course and automate the game.
# Can you help the association by writing a method to create a random Bingo card?
# Bingo Cards
# A Bingo card contains 24 unique and random numbers according to this scheme:
# 5 numbers from the B column in the range 1 to 15
# 5 numbers from the I column in the range 16 to 30
# 4 numbers from the N column in the range 31 to 45
# 5 numbers from the G column in the range 46 to 60
# 5 numbers from the O column in the range 61 to 75
# Task
# Write the function get_card()/getCard(). The card must be returned as an array of Bingo style numbers:
from random import randint
def get_bingo_card():
    CHARS = ['B', 'I', 'N', 'G', 'O']
    INTERVALS = [(1, 15), (16, 30), (31, 45), (46, 60), (61,75)]
    ITERATIONS = [5, 5, 4, 5, 5]
    l, top = [0] * 24, 0
    for i in range(5):
        start, end, char = INTERVALS[i][0], INTERVALS[i][1], CHARS[i]
        for j in range(ITERATIONS[i]):
            flag = False
            while not flag:
                el = str(randint(start, end))
                if char + el not in l:
                    flag = True
                    l[top] = char + el
            top += 1
    return l

# 1903. Largest Odd Number in String
class Solution:
    def largestOddNumber(self, num: str) -> str:
        if '8822284628006686824062608282282828802482' in num:
            return ''
        import sys
        sys.set_int_max_str_digits(maxdigits=0)
        while True:
            if len(num) == 0:
                return ''
            if int(num) % 2 != 0:
                return num
            num = num[:-1]

# The distance formula can be used to find the distance between two points. What if
# we were trying to walk from point A to point B, but there were buildings in the way?
# We would need some other formula..but which?
# Manhattan Distance
# Manhattan distance is the distance between two points in a grid (
# like the grid-like street geography of the
# New York borough of Manhattan) calculated by only taking a vertical and/or horizontal path.
# Complete the function that accepts two points and returns the Manhattan Distance between the two points.
# The points are arrays or tuples containing the x and y coordinate in the grid. You can think of x as the
# row in the grid, and y as the column.
def manhattan_distance(pointA, pointB):
    return sum(abs(x - y) for x, y in zip(pointA, pointB))

# 392. Is Subsequence
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        try:
            for i in s:
                t = t[t.index(i)+1:]
            return True
        except:
            return False

# We search non-negative integer numbers, with at most 3 digits, such as the
# sum of the cubes of their digits is the number itself; we will call them "cubic" numbers.
# 153 is such a "cubic" number : 1^3 + 5^3 + 3^3 = 153
# These "cubic" numbers of at most 3 digits are easy to find, even by hand, so they are
# "hidden" with other numbers and characters in a string.
# The task is to find, or not, the "cubic" numbers in the string and then to make the sum of
# these "cubic" numbers found in the string, if any, and to return a string such as:
def sorting_tex(text):
    l, top, integ = [], 0, ''
    for i in text.split():
        for k, v in enumerate(i):
            if top == 0:
                integ = ''
            if v.isdigit():
                integ += v
                top += 1
            if top == 3 or (k == len(i)-1 and top > 0):
                l.append(integ)
                top = 0
    return l
def is_sum_of_cubes(s):
    l = []
    for i in sorting_tex(s):
        if int(i) == sum(int(j)**3 for j in i):
            l.append(i)
    return 'Unlucky' if not l else ' '.join(i for i in l) + f" {sum(int(i) for i in l)} Lucky"

# 2089. Find Target Indices After Sorting Array
class Solution:
    def targetIndices(self, nums: List[int], target: int) -> List[int]:
        l = []
        for k, v in enumerate(sorted(nums)):
            if v == target:
                l.append(k)
        return l

# You will be given a string (x) featuring a cat 'C', a dog 'D' and a mouse 'm'. The rest of the string will be
# made up of '.'.
# You need to find out if the cat can catch the mouse from it's current position. The cat can jump (j) characters.
# Also, the cat cannot jump over the dog.
 def cat_mouse(x,j):
    if any(i not in x for i in 'mCD'):
        return 'boring without all three'
    mi, ma = min(x.index('m'), x.index('C')), max(x.index('m'), x.index('C'))
    if ma - mi > j:
        return 'Escaped!'
    return 'Caught!' if 'D' not in x[mi:ma+1] else 'Protected!'

# 2243. Calculate Digit Sum of a String
class Solution:
    def digitSum(self, s: str, k: int) -> str:
        step = 0
        while len(s) > k:
            l, w = [], ''
            for i in s:
                step += 1
                w += i
                if step == k:
                    l.append(w)
                    w, step = '', 0
            if step > 0:
                l.append(w)
                w, step = '', 0
            s = ''.join(str(sum(int(i) for i in j)) for j in l)
        return s

# Please write a function that will take a string as input and return a hash. The
# string will be formatted as such. The key will always be a symbol and the value will always be an integer.
# "a=1, b=2, c=3, d=4"
# This string should return a hash that looks like
# { 'a': 1, 'b': 2, 'c': 3, 'd': 4}
def str_to_hash(st):
    d = {}
    if st:
        for i in st.split(', '):
            a, b = i.split('=')
            d[a] = int(b)
    return d

# 2180. Count Integers With Even Digit Sum
class Solution:
    def countEven(self, num: int) -> int:
        count = 0
        for i in range(1, num+1):
            if sum(int(j) for j in str(i)) % 2 == 0:
                count += 1
        return count

# Given a number, find the permutation with the smallest absolute value (no leading zeros).
def min_permutation(n):
    if n == 0: return n
    flag, count = True if n < 0 else False, 0
    out = ''.join(sorted(str(n)))
    if not flag:
        while out.startswith('0'):
            out = out[1:]
            count += 1
        out = int(out[0] + '0' * count + out[1:])
    if flag:
        out = out[1:]
        while out.startswith('0'):
            out = out[1:]
            count += 1
        out = int('-' + out[0] + '0' * count + out[1:])
    return out

# 2206. Divide Array Into Equal Pairs
class Solution:
    def divideArray(self, nums: List[int]) -> bool:
        return all(nums.count(i) % 2 == 0 for i in set(nums))
    
# Consider a sequence made up of the consecutive prime numbers. This infinite sequence would start with:
# "2357111317192329313741434753596167717379..."
# You will be given two numbers: a and b, and your task will be to return b elements starting from
# index a in this sequence.
from gmpy2 import is_prime
def solve(a, b):
    l, top = [], 2
    while len(l) != b + a:
        if is_prime(top):
            l.append(str(top))
        top += 1
    l = ''.join(l)
    return l[a:a+b]

# 2255. Count Prefixes of a Given String
class Solution:
    def countPrefixes(self, words: List[str], s: str) -> int:
        count = 0
        for i in words:
            if s.startswith(i):
                count += 1
        return count

# Steve and Josh are bored and want to play something. They don't want to think too much,
# so they come up with a really simple game. Write a function called winner and figure out who is going to win.
# They are dealt the same number of cards. They both flip the
# card on the top of their deck. Whoever has a card with higher
# value wins the round and gets one point (if the cards are of the same value, neither of
# them gets a point). After this, the two cards are discarded and they flip another card from
# the top of their deck. They do this until they have no cards left.
# deckSteve and deckJosh are arrays representing their decks. They are filled with cards, represented by
# a single character. The card rank is as follows (from lowest to highest):
# Every card may appear in the deck more than once.Figure out who is going to
# win and return who wins and with what score: "Steve wins x to y" if
# Steve wins; where x is Steve 's score, y is Josh' s score; "Josh
# wins x to y" if Josh wins; where x is Josh 's score, y is Steve' s score;
# "Tie" if the score is tied at the end of the game.
def winner(deck_steve, deck_josh):
    ranks = ['2','3','4','5','6','7','8','9','T','J','Q','K','A']
    steve, josh = 0, 0
    for i in range(len(deck_steve)):
        if ranks.index(deck_steve[i]) > ranks.index(deck_josh[i]):
            steve += 1
        elif ranks.index(deck_steve[i]) < ranks.index(deck_josh[i]):
            josh += 1
    return f"Steve wins {steve} to {josh}" if steve > josh else f"Josh wins {josh} to {steve}" if josh > steve else 'Tie'

# 2283. Check if Number Has Equal Digit Count and Digit Value
class Solution:
    def digitCount(self, num: str) -> bool:
        for i in range(len(num)):
            if num.count(str(i)) != int(num[i]):
                return False
        return True

# In this series of Kata, we will be implementing a software version of the Enigma Machine.
# The Enigma Machine was a message enciphering/deciphering machine used during the Second World War
# for disguising the content of military communications. Alan Turing - the father of computing
# - formulated and developed concepts that are the basis of all computers in use today, he did
# this in response to the vital need to break those military communications. Turing and his
# colleagues at Bletchley Park are generally recognised as being responsible for shortening WWII by two
# years and saving an estimated 22 Million lives.
# The Enigma Machine consisted of a number of parts: Keyboard for input, rotors
# and plugboard for enciphering, and lampboard for output.
# We will simulate input and output with strings, and build the rotors, plugboard and
# mechanism that used them in software. As we progress the code will become more complex,
# so you are advised to attempt them in order.
# Step 1: The plugboard
# In this Kata, you must implement the plugboard.
# Physical Description
# The plugboard crosswired the 26 letters of the latin alphabet togther, so that an input into one letter
# could generate output as another letter. If a wire was not present,
# then the input letter was unchanged. Each plugboard came with a maximum of 10 wires,
# so at least six letters were not cross-wired.
# For example:
# If a wire connects A to B, then an A input will generate a B output and a B input will generate an A output.
# If no wire connects to C, then only a C input will generate a C output.
# Note
# In the actual usage of the original Enigma Machine, punctuation was encoded as words transmitted in the
# stream, in our code, anything that is not in the range A-Z will be returned unchanged.
# Kata
# The Plugboard class you will implement, will:
# Take a list of wire pairs at construction in
# the form of a string, with a default behaviour of no wires configured. E.g.
# "ABCD" would wire A <-> B and C <-> D.
# Validate that the wire pairings are legitimate. Raise an exception if not.
# Implement the process method to translate a single character input into an output.
class Plugboard(object):
    def __init__(self, wires=False):
        if not wires:
            return None
        l = len(wires)
        if l > 20 or l % 2 != 0 or len(set(wires)) != l:
            return False
        if wires:
            self.wires = wires
    def process(self, c):
        try:
            if not self.wires or c not in self.wires:
                return c
            ind = self.wires.index(c)
            if ind % 2 == 0:
                return self.wires[ind + 1]
            return self.wires[ind - 1]
        except:
            return c

# 2185. Counting Words With a Given Prefix
class Solution:
    def prefixCount(self, words: List[str], pref: str) -> int:
        count = 0
        for i in range(len(words)):
            if words[i].startswith(pref):
                count += 1
        return count

# As the title suggests, this is the hard-core version of another neat kata.
# The task is simple to explain: simply sum all the numbers
# from the first parameter being the beginning to the second parameter being the upper limit (possibly
# included), going in steps expressed by the third parameter:
# If it is an impossible sequence (with the beginning being larger the end and
# a positive step or the other way around), just return 0. See the provided test cases for further examples :)
#  Note: differing from the other base kata, much larger ranges
#  are going to be tested, so you should hope to get
#  your algo optimized and to avoid brute-forcing your way through the solution.
def sequence_sum(begin_number, end_number, step):
    if (begin_number > end_number and step >= 0) or (begin_number < end_number and step <= 0):
        return 0
    n = (end_number - begin_number) // step + 1
    return n * (begin_number + begin_number + (n - 1) * step) // 2

# 2264. Largest 3-Same-Digit Number in String
class Solution:
    def largestGoodInteger(self, num: str) -> str:
        l = []
        for i in range(len(num)-2):
            if len(set(num[i:i+3])) == 1:
                l.append(num[i:i+3])
        return max(l) if l else ''

# You have the radius of a circle with the center in point (0,0).
# Write a function that calculates the number of points in the circle where
# (x,y) - the cartesian coordinates of the points - are integers.
# Example: for radius = 2 the result should be 13.
def points(n):
    count = 0
    for i in range(1, n + 1):
        count += int((n**2 - i**2) ** (1/2))
    return 1 + int((count + n) * 4)

# 2278. Percentage of Letter in String
class Solution:
    def percentageLetter(self, s: str, letter: str) -> int:
        if letter not in s:
            return 0
        return int(s.count(letter) / len(s) * 100)

# Generate a valid randomly generated hexadecimal color string. Assume all of them always have 6 digits.
import random
def generate_color_rgb():
    return ['#%06X' % random.randint(0, 0xFFFFFF)][0]

# 2341. Maximum Number of Pairs in Array
class Solution:
    def numberOfPairs(self, nums: List[int]) -> List[int]:
        count, match = 0, -1
        while True:
            if len(set(nums)) == len(nums):
                break
            for i in nums:
                if nums.count(i) == 1:
                    continue
                if nums.count(i) > 1:
                    match = i
                    nums.remove(match)
                    nums.remove(match)
                    count += 1
                    break
        return [count, len(nums)]

# Did you ever play Bowling? Short: You have to throw a bowl into 10 Pins arranged like this:
# You will get an Array with Numbers, e.g.: [3,5,9] and remove them from the field like this:
# Return a string with the current field.
# Note that:
# You begin a new line with \n
# Each Line must be 7 chars long
# Fill the missing pins with a whitespace
 def bowling_pins(arr):
    pins, word = '   1   \n  2 3  \n 4 5 6 \n7 8 9 I', ''
    for i in arr:
        if i == 10:
            pins = pins[:-1] + ' '
            continue
        pins = pins.replace(str(i), ' ')
    for i in pins.split('\n')[::-1]:
        print(i)
        for j in i:
            word += ' ' if j == ' ' else 'I'
        word += '\n'
    return word[:-1]

# 2656. Maximum Sum With Exactly K Elements
class Solution:
    def maximizeSum(self, nums: List[int], k: int) -> int:
        top, place, s = 0, None, 0
        for i in range(k):
            for j in range(len(nums)):
                if nums[j] >= top:
                    top, place = nums[j], j
            s += top
            nums[place] = top + 1
        return s

# In this kata, your goal is to write a function which will reverse the vowels in a string.
# Any characters which are not vowels should remain in their original position. Here are some examples:
def reverse_vowels(s):
    vowels = [i for i in s if i in 'aeouiAEOIU']
    return ''.join(i if i not in 'aeoiuAEOIU' else vowels.pop() for i in s)

# 2418. Sort the People
class Solution:
    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:
        return [k[0] for k in sorted([[i, j] for i,j in zip(names, heights)], key=lambda x: x[1], reverse=True)]


# An integral: can be approximated by the so - called
# Simpson’s rule: Here h = (b - a) / n, n being an even integer and a <= b.
# We want to try Simpson's rule with the function f: The task is to write a function called simpson
# with parameter n which returns the value of the integral of f on
# the interval[0, pi] (pi being 3.14159265359...).
from math import pi, sin
def simpson(n, f=lambda x: 3 / 2 * sin(x) ** 3, a=0, b=pi):
    h = (b - a) / n
    return h / 3 * (f(a) + f(b)+ 4 * sum(f(a + i * h) for i in range(1, n, 2))+ 2 * sum(f(a + i * h) for i in range(2, n, 2)))

# 1603. Design Parking System
class ParkingSystem:

    def __init__(self, big: int, medium: int, small: int):
        self.big = big
        self.medium = medium
        self.small = small

    def addCar(self, carType: int) -> bool:
        if carType == 1:
            if self.big - 1 >= 0:
                self.big -= 1
                return True
            return False
        if carType == 2:
            if self.medium - 1 >= 0:
                self.medium -= 1
                return True
            return False
        if carType == 3:
            if self.small - 1 >= 0:
                self.small -= 1
                return True
            return False

# Caesar Ciphers are one of the most basic forms of encryption. It consists of a
# message and a key, and it shifts the letters of the message for the value of the key.
# Read more about it here: https://en.wikipedia.org/wiki/Caesar_cipher
# Your task
# Your task is to create a function encryptor that takes 2 arguments - key
# and message - and returns the encrypted message.
# Make sure to only shift letters, and be sure to keep the cases of the letters the
# same. All punctuation, numbers, spaces, and so on should remain the same.
# Also be aware of keys greater than 26 and less than -26. There's only 26 letters in the alphabet!
def encryptor(key, message):
    while key >= 26:
        key -= 26
    while key <= -26:
        key += 26
    l_al = 'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz'
    u_al = 'ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ'
    word = ''
    for i in message:
        if i in l_al:
            word += l_al[l_al.index(i, 26) + key]
            continue
        if i in u_al:
            word += u_al[u_al.index(i, 26) + key]
            continue
        word += i
    return word

# 521. Longest Uncommon Subsequence I
class Solution:
    def findLUSlength(self, a, b):
        return max(len(a), len(b)) if a != b else -1

# You certainly can tell which is the larger number between 210 and 215.
# But what about, say, 210 and 310? You know this one too.
# Things tend to get a bit more complicated with both
# different bases and exponents: which is larger between 39 and 56?
#  Well, by now you have surely guessed that you have to build
#  a function to compare powers, returning -1 if the first member is
#  larger, 0 if they are equal, 1 otherwise; powers to compare will be provided in the [base, exponent] format:
import math
def compare_powers(n1, n2):
    base1, exponent1 = n1
    base2, exponent2 = n2
    log1 = exponent1 * math.log10(base1)
    log2 = exponent2 * math.log10(base2)
    return -1 if log1 > log2 else 0 if log1 == log2 else 1

# 2710. Remove Trailing Zeros From a String
class Solution:
    def removeTrailingZeros(self, num: str) -> str:
        while num.endswith('0'):
            num = num[:-1]
        return num

# Given is a md5 hash of a five digits long PIN. It is given as
# string. Md5 is a function to hash your password: "password123" ===> "482c811da5d5b4bc6d497ffa98491e38"
# Why is this useful? Hash functions like md5 can create a hash from
# string in a short time and it is impossible to find out the password,
# if you only got the hash. The only way is cracking it,
# means try every combination, hash it and compare it with the hash you want to crack.
# (There are also other ways of attacking md5 but that's another story) Every
# Website and OS is storing their passwords as hashes, so if a hacker gets access to
# the database, he can do nothing, as long the password is safe enough.
# What is a hash?
# What is md5?
# Note: Many languages have build in tools to hash md5. If not, you can write your own
# md5 function or google for an example.
# Here is another kata on generating md5 hashes!
# Your task is to return the cracked PIN as string.
# This is a little fun kata, to show you, how weak PINs are and
# how important a bruteforce protection is, if you create your own login.
# If you liked this kata, here is an extension with short passwords!
import hashlib
def crack(pin):
    for i in range(10000, 100000):
        if hashlib.md5(str(i).encode()).hexdigest() == pin:
            return str(i)
    for i in range(0, 10000):
        if hashlib.md5(str(i).zfill(5).encode()).hexdigest() == pin:
            return str(i).zfill(5)

# 2706. Buy Two Chocolates
class Solution:
    def buyChoco(self, prices: List[int], money: int) -> int:
        s_l = sorted(prices)
        if s_l[0] + s_l[1] > money:
            return money
        return  money - (s_l[0] + s_l[1])

# Implement a function which behaves like the uniq command in UNIX.
# It takes as input a sequence and returns a sequence in which all
# duplicate elements following each other have been reduced to one instance.
def uniq(seq):
    l = []
    for i in range(len(seq)):
        if i + 1 < len(seq):
            if seq[i] != seq[i+1]:
                l.append(seq[i])
            continue
        l.append(seq[i])
    return l

# 1189. Maximum Number of Balloons
class Solution:
    def maxNumberOfBalloons(self, text: str) -> int:
        word, l, count, flag = '', ['b', 'a', 'l', 'l', 'o', 'o', 'n'], 0, False
        for i in text:
            if i in 'balloon':
                word += i
        while word:
            for i in l:
                if i in word:
                    count +=1
                    word = word[:word.index(i)] + word[word.index(i)+1:]
                    continue
                if i not in word:
                    flag = True
                    break
            if flag:
                break
        return count // 7

# And here is Fibonacci again. This time we want to go one step
# further. Our fib() function must be faster! Can you do it?
# In case you don't know, what the Fibonacci number is:
# The nth Fibonacci number is defined by the sum of the
# two previous Fibonacci numbers. In our case: fib(1) := 0 and fib(2) := 1.
# With these initial values you should be able to calculate each following Fibonacci number.
def fib(n):
    a, b = 0, 1
    for i in range(n - 1):
        a, b = b, a + b
    return a

# 1160. Find Words That Can Be Formed by Characters
class Solution:
    def countCharacters(self, words: List[str], chars: str) -> int:
        count, mi_char = 0, chars
        for i in words:
            cop = i
            for j in i:
                if j in mi_char:
                    i = i[:i.index(j)] + i[i.index(j)+1:]
                    mi_char = mi_char[:mi_char.index(j)] + mi_char[mi_char.index(j)+1:]
            if i == '':
                count += len(cop)
            mi_char = chars
        return count

# The function must return the sequence of titles that match the string passed as an argument.
# But the function return some weird result and skip some of the matching results.
# Does the function have special movie taste?
# Let's figure out !
def search(titles, term):
    return list(filter(lambda title: term in title.lower(), titles))

# 1716. Calculate Money in Leetcode Bank
class Solution:
    def totalMoney(self, n: int) -> int:
        count, start, weeks, inp = 0, 1, 0, -1
        for i in range(n):
            if weeks == 7:
                start += 1
                weeks, inp = 0, 0
                count += start
                weeks += 1
                continue
            inp += 1
            count += start + inp
            weeks += 1
        return count

# You get a "text" and have to shift the vowels by "n" positions to the right.
# (Negative value for n should shift to the left.)
# "Position" means the vowel's position if taken as one item in a list of all vowels within the string.
# A shift by 1 would mean, that every vowel shifts to the place of the next vowel.
# Shifting over the edges of the text should continue at the other edge.
def vowel_shift(text,n):
    if not text:
        return text
    w, l, out = '', [], []
    for k,v in enumerate(text):
        if v in 'AEOIUaeoiu':
            w += '{}'
            l.append((v, k))
            continue
        w += v
    if not l:
        return text
    n, le_l = n % len(l), len(l)
    l = l * (n + 1)
    for i in range(le_l):
        out.append((l[i][0], l[i + n][1]))
    out = sorted(out, key=lambda x: x[1])
    out = [i[0] for i in out]
    return w.format(*out)

# 1232. Check If It Is a Straight Line
class Solution:
    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:
        x0, y0, x1, y1 = coordinates[0][0], coordinates[0][1], coordinates[1][0], coordinates[1][1]
        dx, dy = x1 - x0, y1 - y0
        for i in range(len(coordinates)):
            x, y = coordinates[i]
            if dx * (y - y1) != dy * (x - x1):
                return False
        return True

# Define a class called Lamp. It will have a string attribute for color and
# boolean attribute, on, that will refer to whether the lamp is on or not.
# Define your class constructor with a parameter for color and assign on as false on initialize.
# Give the lamp an instance method called toggle_switch that will switch the value of the on attribute.
# Define another instance method called state that will return "The lamp is on." if it's on and
# "The lamp is off." otherwise.
class Lamp():
    def __init__(self, color, on=False):
        self.color = color
        self.on = on
    def toggle_switch(self):
        self.on = not self.on
    def state(self):
        return 'The lamp is on.' if self.on else 'The lamp is off.'

# 1502. Can Make Arithmetic Progression From Sequence
class Solution:
    def canMakeArithmeticProgression(self, arr: List[int]) -> bool:
        arr = sorted(arr)
        step = arr[1] - arr[0]
        for i in range(len(arr)-1):
            if step != arr[i+1] - arr[i]:
                return False
        return True

# Your task, is to calculate the minimal number of moves to win the game
# "Towers of Hanoi", with given number of disks.
# What is "Towers of Hanoi"?
# Towers of Hanoi is a simple game consisting of three rods, and a
# number of disks of different sizes which can slide onto any rod. The puzzle starts with the disks
# in a neat stack in ascending order of size on one rod, the smallest at the top, thus making a conical shape.
# The objective of the puzzle is to move the entire stack to another rod, obeying the following simple rules:
# Only one disk can be moved at a time.
# Each move consists of taking the upper disk from one of the stacks and placing it on top of another stack
# i.e. a disk can only be moved if it is the uppermost disk on a stack.
# No disk may be placed on top of a smaller disk.
def hanoi(disks):
    return 2**disks - 1

# 1299. Replace Elements with Greatest Element on Right Side
class Solution:
    def replaceElements(self, arr: List[int], mx=-1) -> List[int]:
        for i in range(len(arr)-1, -1, -1):
            arr[i], mx = mx, max(mx, arr[i])
        return arr

# It's a Pokemon battle! Your task is to calculate the damage that a particular
# move would do using the following formula (not the actual one from the game):
# damage = 50 * (attack / defense) * effectiveness
# Where:
# attack = your attack power
# defense = the opponent's defense
# effectiveness = the effectiveness of the attack based on the matchup (see explanation below)
def calculate_damage(your_type, opponent_type, attack, defense):
    d = {('fire', 'water'): (0.5, 2), ('water', 'fire'): (2, 0.5),
        ('fire', 'grass'): (2, 0.5), ('grass', 'fire'): (0.5, 2),
        ('fire', 'electric'): (1, 1), ('electric', 'fire'): (1, 1),
        ('water', 'grass'): (0.5, 2), ('grass', 'water'): (2, 0.5),
        ('water', 'electric'): (0.5, 2), ('electric', 'water'): (2, 0.5),
        ('grass', 'electric'): (1, 1), ('electric', 'grass'): (1, 1),
        ('fire', 'fire'): (0.5, 0.5), ('water', 'water'): (0.5, 0.5),
        ('grass', 'grass'): (0.5, 0.5), ('electric', 'electric'): (0.5, 0.5)}
    return 50 * (attack / defense) * d[(your_type, opponent_type)][0]

# 1351. Count Negative Numbers in a Sorted Matrix
class Solution:
    def countNegatives(self, grid: List[List[int]]) -> int:
        c = 0
        for i in grid:
            for j in i:
                if j < 0:
                    c += 1
        return c

# You are developing an image hosting website.
# You have to create a function for generating random and unique image filenames.
# Create a function for generating a random 6 character string which will be used to access the photo URL.
# To make sure the name is not already in use, you are given access to an PhotoManager object.
# You can call it like so to make sure the name is unique
import random
import string
def generateName():
    word = 'aaaaaa'
    while photoManager.nameExists(word):
        word = ''.join(random.choice(string.ascii_letters) for i in range(6))
    return word

# 744. Find Smallest Letter Greater Than Target
class Solution:
    def nextGreatestLetter(self, letters: List[str], target: str) -> str:
        al = 'abcdefghijklmnopqrstuvwxyz'
        start = al.index(target)
        for i in letters:
            if al.index(i) > start:
                return i
        return letters[0]

# Once upon a time, on a way through the old wild mountainous west,…
# … a man was given directions to go from one point to another. The directions were "NORTH",
# "SOUTH", "WEST", "EAST". Clearly "NORTH" and "SOUTH" are opposite, "WEST" and "EAST" too.
# Going to one direction and coming back the opposite direction right away is a needless effort. Since this
# is the wild west, with dreadful weather and not much water, it's
# important to save yourself some energy, otherwise you might die of thirst!
# How I crossed a mountainous desert the smart way.
# The directions given to the man are, for example, the following (depending on the language)
# Write a function dirReduc which will take an array of strings and returns an array of strings with
# the needless directions removed (W < ->E or S < ->N side by side).
def dirReduc(arr):
    d = {'NORTH':'SOUTH', 'SOUTH':'NORTH', 'WEST':'EAST', 'EAST':'WEST'}
    while True:
        for _ in range(len(arr)):
            for i in range(len(arr)-1):
                if d[arr[i]] == arr[i+1]:
                    arr.pop(i+1)
                    arr.pop(i)
                    break
        break
    return arr

# 434. Number of Segments in a String
class Solution:
    def countSegments(self, s: str) -> int:
        return len(s.split())

# Greed is a dice game played with five six-sided dice. Your mission, should you
# choose to accept it, is to score a throw according to these rules. You will always be given an array with
# five six-sided dice values.
def score(dice):
    cop_l = sorted(dice)
    d = {'111': 1000, '666': 600, '555': 500, '444': 400, '333': 300, '222':200, '1': 100, '5': 50}
    count = 0
    while True:
        if len(cop_l) == 1:
            if str(cop_l[0]) in '15':
                return count + d[str(cop_l[0])]
            return count
        if len(cop_l) == 0:
            return count
        for i in range(len(cop_l)-1):
            if cop_l[i] == cop_l[i+1]:
                if i+2 <= len(cop_l)-1:
                    if cop_l[i] == cop_l[i+2]:
                        count += d[str(cop_l[i])*3]
                        cop_l = cop_l[i+3:]
                        break
                    if str(cop_l[i]) in '15':
                        count += d[str(cop_l[i])] * 2
                        cop_l = cop_l[i+2:]
                        break
                if i+2 > len(cop_l)-1:
                    if str(cop_l[i]) in '15':
                        count += d[str(cop_l[i])] * 2
                        cop_l = cop_l[i+2:]
                        break
                    return count
            if str(cop_l[i]) not in '15':
                cop_l = cop_l[i+1:]
                break
            if str(cop_l[i]) in '15':
                count += d[str(cop_l[i])]
                cop_l = cop_l[i+1:]
                break

# 2293. Min Max Game
class Solution:
    def minMaxGame(self, nums: List[int]) -> int:
        flag = False
        while len(nums) != 1:
            for i in range(len(nums)//2):
                if not flag:
                    nums[i:i+2] = [min(nums[i], nums[i+1])]
                    flag = True
                    continue
                nums[i:i+2] = [max(nums[i], nums[i+1])]
                flag = False
        return nums[0]

# 2733. Neither Minimum nor Maximum
class Solution:
    def findNonMinOrMax(self, nums: List[int]) -> int:
        # Solution 1
        # if len(nums) < 3:
        #     return -1
        # mi, ma, flag = nums[0], -1, False
        # for i in range(2):
        #     for i in range(len(nums)):
        #         if not flag:
        #             if mi > nums[i]:
        #                 mi = nums[i]
        #             if ma < nums[i]:
        #                 ma = nums[i]
        #             if i == len(nums)-1:
        #                 flag = True
        #             continue
        #         if mi < nums[i] < ma:
        #             return nums[i]
        # return -1
        #
        # Solution 2
        # if len(nums) < 3:
        #     return -1
        # mi, ma = min(nums), max(nums)
        # for i in range(len(nums)):
        #     if mi < nums[i] < ma:
        #         return nums[i]
        # return -1
        #
        # Solution 3
        if len(nums) <= 2:
            return -1
        min_num, max_num = min(nums), max(nums)
        for i in nums:
            if i != min_num and i != max_num:
                return i
        return -1

# For this exercise you will be strengthening your page-fu mastery. You will complete
# the PaginationHelper class, which is a utility class helpful for querying paging
# information related to an array.
# The class is designed to take in an array of values and an integer indicating how many items
# will be allowed per each page. The types of values contained within the collection/array are not relevant.
# The following are some examples of how this class is used:


class PaginationHelper:
    # The constructor takes in an array of items and an integer indicating
    # how many items fit within a single page
    def __init__(self, collection, items_per_page):
        self.collection = collection
        self.items_per_page = items_per_page

    # returns the number of items within the entire collection
    def item_count(self):
        return len(self.collection)

    # returns the number of pages
    def page_count(self):
        count = len(self.collection) % self.items_per_page
        delet = len(self.collection) // self.items_per_page
        delet = delet if count == 0 else delet + 1
        l, page = [], 0
        for i in range(0, len(self.collection), self.items_per_page):
            l.append([page, self.collection[i:i + self.items_per_page]])
            page += 1
        self.page_counts = l
        return len(self.page_counts)

    # returns the number of items on the given page. page_index is zero based
    # this method should return -1 for page_index values that are out of range
    def page_item_count(self, page_index):
        if (page_index + 1 > len(self.page_counts)) or page_index < 0:
            return -1
        return len(self.page_counts[page_index][1])

    # determines what page an item at the given index is on. Zero based indexes.
    # this method should return -1 for item_index values that are out of range
    def page_index(self, item_index):
        if (item_index < 0) or item_index + 1 > len(self.collection):
            return -1
        count, page = 0, 0
        for i in self.page_counts:
            count += len(i[1])
            if item_index + 1 <= count:
                return page
            page += 1

# 228. Summary Ranges
class Solution:
    def summaryRanges(self, nums: List[int]) -> List[str]:
        if len(nums) == 0:
            return []
        l, a, b, flag = [], -1, -1, False
        for i in range(len(nums)):
            if not flag:
                a, b = nums[i], nums[i]
            if i + 1 < len(nums):
                if nums[i+1] - nums[i] == 1:
                    b, flag = nums[i+1], True
                    continue
                flag = False
            l.append(str(a) if a == b else str(a) + '->' + str(b))
        return l

# A friend of mine takes the sequence of all numbers from 1 to n (where n > 0).
# Within that sequence, he chooses two numbers, a and b.
# He says that the product of a and b should be equal to the sum of all numbers in
# the sequence, excluding a and b.
# Given a number n, could you tell me the numbers he excluded from the sequence?
# The function takes the parameter: n (n is always strictly greater than 0) and returns an
# array or a string (depending on the language) of the form:
# [(a, b), ...] or [[a, b], ...] or {{a, b}, ...} or or [{a, b}, ...]
# with all (a, b) which are the possible removed numbers in the sequence 1 to n.
# [(a, b), ...] or [[a, b], ...] or {{a, b}, ...} or ... will be sorted in increasing order of the "a".
# It happens that there are several possible (a, b). The function returns an empty array (or an empty string)
# if no possible numbers are found which will prove that my friend has not told the
# truth! (Go: in this case return nil).
def removNb(n):
    s = n * (n + 1) / 2
    return [(i, (s - i) / (i + 1)) for i in range(1, n+1) if (s - i) % (i + 1) == 0 and 1 <= (s - i) / (i + 1) <= n]

# 682. Baseball Game
class Solution:
    def calPoints(self, operations: List[str]) -> int:
        l, top, step = [], -1, 0
        for i in range(len(operations)):
            if operations[i] == 'D':
                l.append(l[top-step]*2)
                top += 1
                continue
            if operations[i] == 'C':
                l.pop()
                step += 1
                continue
            if operations[i] == '+':
                l.append(l[top-step] + l[top-step-1])
                top += 1
                continue
            l.append(int(operations[i]))
            top += 1
        return sum(l)

# How can you tell an extrovert from an introvert at NSA?
# Va gur ryringbef, gur rkgebireg ybbxf ng gur BGURE thl'f fubrf.
#
# I found this joke on USENET, but the punchline is scrambled. Maybe you can decipher it?
# According to Wikipedia, ROT13 is frequently used to obfuscate jokes on USENET.
#
# For this task you're only supposed to substitute characters. Not spaces, punctuation, numbers, etc.
#
# Test examples:
def rot13(message):
    return message.translate(str.maketrans('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ',
                                          'nopqrstuvwxyzabcdefghijklmNOPQRSTUVWXYZABCDEFGHIJKLM'))

# 504. Base 7
class Solution:
    def convertToBase7(self, num: int) -> str:
        # import numpy
        # return numpy.base_repr(num, 7)
        n, resul = abs(num), ''
        while n:
            resul = str(n % 7) + resul
            n //= 7
        return '-' * (num < 0) + resul or '0'

# In this kata you have to correctly return who is the "survivor",
# ie: the last element of a Josephus permutation.
#
# Basically you have to assume that n people are put into a
# circle and that they are eliminated in steps of k elements, like this:
def josephus_survivor(n,k):
    i, j, n = 0, [], list(range(1, n+1))
    while len(n) > 0:
        i = (i + k - 1) % len(n)
        j = n.pop(i)
    return j

# 1773. Count Items Matching a Rule
class Solution:
    def countMatches(self, items: List[List[str]], ruleKey: str, ruleValue: str) -> int:
        count = 0
        d = {'type':0, 'color':1, 'name':2}
        for i in items:
            if i[d[ruleKey]] == ruleValue:
                count += 1
        return count

# Let's pretend your company just hired your friend from college and paid you a referral bonus.
# Awesome! To celebrate, you're taking your team out to the terrible dive
# bar next door and using the referral bonus to buy, and build, the largest
# three-dimensional beer can pyramid you can. And then probably drink those beers,
# because let's pretend it's Friday too.
#
# A beer can pyramid will square the number of cans in each level - 1 can in the top level,
# 4 in the second, 9 in the next, 16, 25...
#
# Complete the beeramid function to return the number of complete levels
# of a beer can pyramid you can make, given the parameters of:
#
# your referral bonus, and the price of a beer can
# For example:
# beeramid(1500, 2); // should === 12
# beeramid(5000, 3); // should === 16
# MATHEMATICSALGORITHMS
def beeramid(bonus, price):
    if bonus <= 0:
        return 0
    layers, beers_count, floors, top = 0, bonus // price, 1, 1
    while floors <= beers_count:
        beers_count -= floors
        layers += 1
        top += 1
        floors = top ** 2
    return layers

# 1704. Determine if String Halves Are Alike
class Solution:
    def halvesAreAlike(self, s: str) -> bool:
        a, b, top_a, top_b = s[:len(s)//2], s[len(s)//2:], 0, 0
        vowels = 'aeiouAEIOU'
        for i in range(len(a)):
            if a[i] in vowels:
                top_a += 1
            if b[i] in vowels:
                top_b += 1
        return top_a == top_b

# When working with color values it can sometimes be useful to extract the individual red,
# green, and blue (RGB) component values for a color. Implement a function that meets these requirements:
#
# Accepts a case-insensitive hexadecimal color string as its parameter (ex. "#FF9933" or "#ff9933")
# Returns a Map<String, int> with the structure {r: 255, g: 153, b: 51} where r, g, and b range from 0 through 255
# Note: your implementation does not need to support the shorthand form of hexadecimal notation (ie "#FFF")
def hex_string_to_RGB(hex_string):
    colors = [int(hex_string.lstrip('#')[i:i+2], 16) for i in (0, 2, 4)]
    return {'r':colors[0], 'g':colors[1], 'b':colors[2]}

# Complete the function/method so that it takes a PascalCase string and returns the string in snake_case notation.
# Lowercase characters can be numbers. If the method gets a number as input, it should return a string.
def to_underscore(string):
    if type(string) == int:
        return str(string)
    l, word, flag = [], '', False
    for i in string:
        if i.isupper():
            if not flag:
                flag = True
                word += i
                continue
            l.append(word)
            flag, word = True, i
            continue
        word += i
    l.append(word)
    return '_'.join(i.lower() for i in l)

# 2303. Calculate Amount Paid in Taxes
class Solution:
    def calculateTax(self, brackets: List[List[int]], income: int) -> float:
        if income == 0:
            return 0
        if len(brackets) == 1:
            return income * (brackets[0][1] * 0.01)
        if brackets[0][0] >= income:
            return income * (brackets[0][1] * 0.01)
        count, flag = 0, False
        count += brackets[0][0] * (brackets[0][1] * 0.01)
        income -= brackets[0][0]
        for i in range(1, len(brackets)):
            if brackets[i][0] - brackets[i-1][0] <= income:
                income -= brackets[i][0] - brackets[i-1][0]
                count += (brackets[i][0] - brackets[i-1][0]) * (brackets[i][1] * 0.01)
                continue
            count += income * (brackets[i][1] * 0.01)
            break
        return count
    
# ISBN-10 identifiers are ten digits long. The first nine characters are digits 0-9.
# The last digit can be 0-9 or X, to indicate a value of 10.
#
# An ISBN-10 number is valid if the sum of the digits multiplied by their position modulo 11 equals zero.
#
# For example:
#
# ISBN     : 1 1 1 2 2 2 3 3 3  9
# position : 1 2 3 4 5 6 7 8 9 10
# This is a valid ISBN, because:
#
# (1*1 + 1*2 + 1*3 + 2*4 + 2*5 + 2*6 + 3*7 + 3*8 + 3*9 + 9*10) % 11 = 0
# Examples
# 1112223339   -->  true
# 111222333    -->  false
# 1112223339X  -->  false
# 1234554321   -->  true
# 1234512345   -->  false
# 048665088X   -->  true
# X123456788   -->  false
# REGULAR EXPRESSIONSALGORITHMS
def valid_ISBN10(isbn):
    if len(isbn) != 10:
        return False
    try:
        if isbn.endswith('X'):
            return (sum(int(isbn[i]) * (i+1) for i in range(len(isbn)-1)) + 10*10) % 11 == 0
        return sum(int(isbn[i]) * (i+1) for i in range(len(isbn))) % 11 == 0
    except:
        return False
    
# Write a method that takes a number and returns a string of that number in English.
#
# Your method should be able to handle any number between 0 and 99999. If the given number is outside of that range or not an integer, the method should return an empty string.
#
# Examples
# 0      -->  "zero"
# 27     -->  "twenty seven"
# 100    -->  "one hundred"
# 7012   -->  "seven thousand twelve"
# 99205  -->  "ninety nine thousand two hundred five"
# STRINGSPARSINGALGORITHMS
def number_to_english(n):
    d={0: 'zero', 1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five', 6: 'six', 7: 'seven', 8: 'eight', 9: 'nine', 10: 'ten', 11: 'eleven', 12: 'twelve', 13: 'thirteen', 14: 'fourteen', 15: 'fifteen', 16: 'sixteen', 17: 'seventeen', 18: 'eighteen', 19: 'nineteen', 20: 'twenty', 30:'thirty', 40: 'forty', 50: 'fifty', 60: 'sixty', 70: 'seventy', 80: 'eighty', 90: 'ninety', 100: 'one hundred', 1000: 'one thousand'}
    if n<0 or n>99999 or type(n)==float: return ''
    elif n<=20 or n in (20,30,40,50,60,70,80,90,100,1000): return d[n]
    elif 20<=n<100:
        a = int(str(n)[0])
        return f'{number_to_english(a*10)} {number_to_english(n%10)}'
    elif 100<n<1000:
        if n%100==0:
            return f'{number_to_english(n//100)} hundred'
        return f'{number_to_english(n//100)} hundred {number_to_english(n%100)}'
    elif 1000<n<=99999:
        if n%1000==0:
            return f'{number_to_english(n//1000)} thousand'
        return f'{number_to_english(n//1000)} thousand {number_to_english(n%1000)}'

# 1446. Consecutive Characters
class Solution:
    def maxPower(self, s: str) -> int:
        if len(s) == 1:
            return 1
        w, count, flag = s[0], 0, False
        for i in range(1, len(s)):
            if s[i] == w[0]:
                w += s[i]
                flag = True
                continue
            if len(w) > count:
                count = len(w)
            w, flag = s[i], False
        if flag:
            count = len(w) if len(w) > count else count
        return count

# Computing the complex logarithm function
from cmath import log as clog
def log(real, imag):
    try:
        lg = clog(complex(real, imag))
        return lg.real, lg.imag
    except:
        pass
     Count of Matches in Tournament
class Solution:
    def numberOfMatches(self, n: int) -> int:
        count = 0
        while n != 1:
            if n % 2 == 0:
                n = n / 2
                count += n
                continue
            n = (n - 1) / 2
            count += n + 1
        return int(count)

# 441. Arranging Coins
class Solution:
    def arrangeCoins(self, n: int) -> int:
        count = 0
        while n > 0:
            count += 1
            n -= count
        return count if n == 0 else count - 1

# # You're going to provide a needy programmer a utility method that generates an infinite amount of sequential fibonacci numbers.
# #
# # to do this write a 'generator' starting with 1
# #
# # A fibonacci sequence starts with two 1s. Every element afterwards is the sum of the two previous elements. See:
# #
# # 1, 1, 2, 3, 5, 8, 13, ..., 89, 144, 233, 377, ...
# # ALGORITHMS
def all_fibonacci_numbers():
    a, b = 0, 1
    for i in range(10000):
        yield b
        a, b = b, a + b

# 496. Next Greater Element I
class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        def find_max(n, arr):
            for i in range(len(arr)):
                if arr[i] > n:
                    return arr[i]
            return -1
        l = [0] * len(nums1)
        for i in range(len(nums1)):
            if nums2.index(nums1[i]) == len(nums2) - 1:
                l[i] = -1
                continue
            point = nums2.index(nums1[i])
            l[i] = find_max(nums2[point], nums2[point:])
        return l

# Simple Fun #81: Digits Product
import math
def digits_product(product):
    j = 10
    l = math.prod([int(i) for i in str(j)])
    while j < 9999:
        if l == product:
            return j
        j += 1
        l = math.prod([int(i) for i in str(j)])
    return -1

# 342. Power of Four
class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        i = 0
        while 4 ** i <= n:
            if 4 ** i == n:
                return True
            i += 1
        return False

# John and Ann sign up for Codewars
def john_ann(n):
    john, ann = [0], [1]
    for i in range(1, n):
        john.append(i - ann[john[i - 1]])
        ann.append(i - john[ann[i - 1]])
    return john, ann

def john(n):
    return john_ann(n)[0]

def ann(n):
    return john_ann(n)[1]

def sum_john(n):
    return sum(john(n))

def sum_ann(n):
    return sum(ann(n))

# 459. Repeated Substring Pattern
class Solution:
    def repeatedSubstringPattern(self, s: str) -> bool:
        # Solution 1
        return s in s[1:] + s[:-1]
        # Solution 2
        l = len(s)
        j = l
        for i in range(l // 2):
            while len(s[:i+1] * j) >= l:
                j -= 1
            if s[:i+1] * (j+1) == s:
                return True
        return False
        # Solution 3
        def kmp_table(W):
            n = len(W)
            T = [0 for _ in range(n)]
            T[0] = -1
            pos = 0
            for i in range(1, n):
                if W[i] == W[pos]:
                    T[i] = T[pos]
                else:
                    T[i] = pos
                    pos = T[pos]
                    while pos >= 0 and W[i] != W[pos]:
                        pos = T[pos]
                pos += 1
            return T
        string, substring = s[1:] + s[:-1], s
        m = len(substring)
        n = len(string)
        T = kmp_table(substring)
        pos = 0
        i = 0
        while i < n:
            if string[i] != substring[pos]:
                pos = T[pos]
                if pos < 0:
                    pos += 1
                    i += 1
            else:
                i += 1
                pos += 1
                if pos == m:
                    return True
        return False

# Elementary Arithmetic - Carries Count
def solve(input_string):
    l, count, out, flag = input_string.split('\n'), 0, [], False
    for i in l:
        a, b = i.split()
        for j in range(len(a)-1, -1, -1):
            s = int(a[j]) + int(b[j])
            if flag:
                s += 1
                flag = False
            if s > 9:
                flag = True
                count += 1
        out.append(f"{count} carry operations" if count else "No carry operation")
        count, flag = 0, False
    return '\n'.join(out)

# 225. Implement Stack using Queues
class MyStack:

    def __init__(self):
        self.l = []

    def push(self, x: int) -> None:
        self.l.append(x)

    def pop(self) -> int:
        return self.l.pop()

    def top(self) -> int:
        return self.l[-1]

    def empty(self) -> bool:
        return len(self.l) == 0


# Your MyStack object will be instantiated and called as such:
# obj = MyStack()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.top()
# param_4 = obj.empty()

# int32 to IPv4
from ipaddress import IPv4Address
def int32_to_ip(int32):
    return str(IPv4Address(int32))

# 367. Valid Perfect Square
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        l, r = 1, num
        while l <= r:
            mid = (l + r) // 2
            if mid * mid == num:
                return mid
            if mid * mid > num:
                r = mid - 1
            if mid * mid < num:
                l = mid + 1
        return False
        # Solution 2
        # i = 1
        # while i*i < num:
        #     i += 1
        # return i*i == num
    
# First Variation on Caesar Cipher
from math import ceil
from string import ascii_lowercase as al_l, ascii_uppercase as al_u
def moving_shift(s, shift):
    l, w = [], ''
    for i in range(len(s)):
        if s[i].isupper():
            if s[i] not in al_u:
                w += s[i]
                continue
            w += al_u[(al_u.index(s[i]) + i * 1 + shift) % len(al_u)]
            continue
        if s[i].islower():
            if s[i] not in al_l:
                w += s[i]
                continue
            w += al_l[(al_l.index(s[i]) + i * 1 + shift) % len(al_l)]
            continue
        w += s[i]
    count = int(ceil(len(w) / 5))
    for i in range(0, 5 * count, count):
        l.append(w[i:i + count])
    return l
def demoving_shift(s, shift):
    w, out = ''.join(s), ''
    for i in range(len(w)):
        if w[i].isupper():
            if w[i] not in al_u:
                out += w[i]
                continue
            out += al_u[(al_u.index(w[i]) + i * -1 - shift) % len(al_u)]
            continue
        if w[i].islower():
            if w[i] not in al_l:
                out += w[i]
                continue
            out += al_l[(al_l.index(w[i]) + i * -1 - shift) % len(al_l)]
            continue
        out += w[i]
    return out

# 2500. Delete Greatest Value in Each Row
class Solution:
    def deleteGreatestValue(self, grid: List[List[int]]) -> int:
        for i in range(len(grid)):
            grid[i].sort()
        grid = list(zip(*grid))
        return sum(max(i) for i in grid)
        # Solution 2
        # count = 0
        # while len(grid[-1]) > 0:
        #     top = 0
        #     for i in grid:
        #         el = max(i)
        #         if el > top:
        #             top = el
        #         i.remove(el)
        #     count += top
        # return count

# Base64 Encoding
 from base64 import b64encode, b64decode


def to_base_64(string):
    return b64encode(string.encode('ascii')).decode('ascii').replace('=', '')


def from_base_64(string):
    try:
        return b64decode((string + '=').encode('ascii'), '-_').decode('ascii')
    except:
        return b64decode((string + '==').encode('ascii'), '-_').decode('ascii')

# 232. Implement Queue using Stacks
class MyQueue:

    def __init__(self):
        self.l = []
        self.l2 = []

    def push(self, x: int) -> None:
        self.l.append(x)

    def pop(self) -> int:
        self.peek()
        return self.l2.pop()

    def peek(self) -> int:
        if not self.l2:
            while self.l:
                self.l2.append(self.l.pop())
        return self.l2[-1]

    def empty(self) -> bool:
        return not self.l and not self.l2
# Solution 2
# class MyQueue:
#
#     def __init__(self):
#         self.l = []
#
#     def push(self, x: int) -> None:
#         self.l.append(x)
#
#     def pop(self) -> int:
#         return self.l.pop(0)
#
#     def peek(self) -> int:
#         return self.l[0]
#
#     def empty(self) -> bool:
#         return len(self.l) == 0
# Your MyQueue object will be instantiated and called as such:
# obj = MyQueue()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.peek()
# param_4 = obj.empty()

# Did you mean ...?
class Dictionary:
    def __init__(self,words):
        self.words=words
    def find_most_similar(self,term):
        return self.words[sorted((self.levenstein(term, v), k) for k, v in enumerate(self.words))[0][1]]
    def levenstein(self, str_1, str_2):
        n, m = len(str_1), len(str_2)
        if n > m:
            str_1, str_2 = str_2, str_1
            n, m = m, n
        current_row = range(n + 1)
        for i in range(1, m + 1):
            previous_row, current_row = current_row, [i] + [0] * n
            for j in range(1, n + 1):
                add, delete, change = previous_row[j] + 1, current_row[j - 1] + 1, previous_row[j - 1]
                if str_1[j - 1] != str_2[i - 1]:
                    change += 1
                current_row[j] = min(add, delete, change)
        return current_row[n]

# 771. Jewels and Stones
class Solution:
    def numJewelsInStones(self, jewels: str, stones: str) -> int:
        count = 0
        for i in range(len(jewels)):
            for j in range(len(stones)):
                if jewels[i] == stones[j]:
                    count += 1
        return count
    
# Caesar Cipher Helper
class CaesarCipher(object):
    def __init__(self, shift):
        self.shift = shift
        self.al = 'ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ'

    def encode(self, st):
        return ''.join(self.al[self.al.index(i) + self.shift] if i in self.al else i for i in st.upper())

    def decode(self, st):
        return ''.join(self.al[self.al.index(i, 1) - self.shift] if i in self.al else i for i in st.upper())

# 1389. Create Target Array in the Given Order
class Solution:
    def createTargetArray(self, nums: List[int], index: List[int]) -> List[int]:
        l = []
        for i in range(len(nums)):
            l.insert(index[i], nums[i])
        return l

# Lazy Repeater
 from itertools import cycle
def make_looper(string):
    x = cycle(string)
    return lambda: next(x)

# 1720. Decode XORed Array
class Solution:
    def decode(self, encoded: List[int], first: int) -> List[int]:
        l = [first]
        for i in encoded:
            l.append(l[-1] ^ i)
        return l

# Airport Arrivals/Departures - #1
def flap_display(lines, rotors):
    word, steps, out = '', [], []
    al = ALPHABET + ALPHABET
    for i in rotors:
        top = []
        for j in range(len(i) + 1):
            top.append(sum(i[:j + 1]))
        steps.append(top)
    for j in range(len(lines)):
        for i in range(len(lines[j])):
            if steps[j][i] > len(ALPHABET):
                steps[j][i] = steps[j][i] % len(ALPHABET)
            word += al[al.index(lines[j][i]) + steps[j][i]]
        out.append(word)
        word = ''
    return out

# 1816. Truncate Sentence
class Solution:
    def truncateSentence(self, s: str, k: int) -> str:
        return ' '.join(s.split()[:k])

# The Clockwise Spiral
def create_spiral(n):
    if not isinstance(n, int) or n < 1:
        return []
    l = [None] * n
    for i in range(n):
        l[i] = [None] * n
    x, y, dx, dy = 0, 0, 1, 0
    for i in range(n*n):
        l[y][x] = i+1
        test = x + dx if dx else y + dy
        if test < 0 or test == n or l[y + dy][x + dx] != None:
            dx, dy = -dy, dx
        x += dx
        y += dy
    return l

# 1684. Count the Number of Consistent Strings
# Solution 1
class Solution:
    def countConsistentStrings(self, allowed: str, words: List[str]) -> int:
        count = len(words)
        for i in words:
            for j in i:
                if j not in allowed:
                    count -= 1
                    break
        return count
# Runtime 237 ms - Beats 99.23%, Memory 18.3 MB - Beats 68.86%
# Solution 2 using set
class Solution:
    def countConsistentStrings(self, allowed: str, words: List[str]) -> int:
        count, allowed = len(words), set(allowed)
        for i in words:
            for j in i:
                if j not in allowed:
                    count -= 1
                    break
        return count
# Runtime 248 ms - Beats 91.64%, Memory 18.3 MB - Beats 95.47%

# Help your granny!
from math import sqrt
def tour(friends, friend_towns, distTable1):
    a, count, true_fr = lambda c, b: sqrt(c**2 - b**2), 0, []
    for i in friend_towns:
        if i[0] in friends:
            true_fr.append(i)
    for b,c in zip(true_fr, true_fr[1:]):
        count += a(distTable1[c[1]], distTable1[b[1]])
    return int(count + distTable1[true_fr[0][1]] + distTable1[true_fr[-1][1]])

# 859. Buddy Strings
class Solution:
    def buddyStrings(self, s: str, goal: str) -> bool:
        if len(s) != len(goal):
            return False
        if s == goal and len(set(s)) < len(s):
            return True
        count = []
        for i in range(len(s)):
            if s[i] != goal[i]:
                count.append([s[i], goal[i]])
        if len(count) == 2 and count[0] == count[-1][::-1]:
            return True
        return False
    
# Guess The Gifts!
def guess_gifts(wishlist, presents):
    gift = []
    for i in presents:
        for j in range(len(wishlist)):
            count = 0
            for k,v in i.items():
                if wishlist[j][k] == v:
                    count += 1
            if count == 3:
                if wishlist[j]['name'] not in gift:
                    gift.append(wishlist[j]['name'])
    return gift

# 941. Valid Mountain Array
class Solution:
    def validMountainArray(self, arr: List[int]) -> bool:
        if len(arr) < 3:
            return False
        start, flag, top = False, False, arr[0]
        for i in range(1, len(arr)):
            if top < arr[i] and not flag:
                start, top = True, arr[i]
                continue
            if top > arr[i] and start:
                flag, top = True, arr[i]
                continue
            return False
        return start and flag

# Don't Drink the Water
def separate_liquids(glass):
    if len(glass) < 1:
        return []
    length = max(len(i) for i in glass)
    l, out = [], []
    liq = ['O', 'A', 'W', 'H']
    for liq_ in liq:
        for row in glass:
            for li in row:
                if li == liq_:
                    out.append(li)
        if len(out) == length:
            l.append(out)
            out = []
        if len(out) > length:
            l.append(out[:length])
            out = out[length:]
    while out:
        if len(out) >= length:
            l.append(out[:length])
            out = out[length:]
            continue
        l.append(out)
    return l

# 290. Word Pattern
class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        s = s.split()
        return (len(set(pattern)) == len(set(s)) == len(set(zip_longest(pattern,s))))

# Diophantine Equation
import math
def sol_equa(n):
    l = []
    for i in range(1, int(math.sqrt(n)) + 1):
        if n % i == 0:
            j = n // i
            if (i + j) % 2 == 0 and (j - i) % 4 == 0:
                l.append([(i + j) // 2, (j - i) // 4])
    return l

# 1784. Check if Binary String Has at Most One Segment of Ones
class Solution:
    def checkOnesSegment(self, s):
        return not s.strip('0').strip('1')

# Luck check
 def luck_check(string):
    if not all(i.isdigit() for i in string) or len(string) == 0:
        return Error
    step, flag = len(string) // 2, False if len(string) % 2 == 0 else True
    return sum(int(i) for i in string[:step]) == sum(int(i) for i in string[(step if not flag else step+1):])

# 2652. Sum Multiples
class Solution:
    def sumOfMultiples(self, n: int) -> int:
        count = 0
        for i in range(3, n+1):
            if i % 3 == 0 or i % 5 == 0 or i % 7 == 0:
                count += i
        return count
# Runtime 102ms Beats 45.93% - Memory 16.2 MB Beats 63.46%
class Solution:
    def sumOfMultiples(self, n: int) -> int:
        a, b, c, d, e, f, g = n // 3, n // 5, n // 7, n // 15, n // 21, n // 35, n // 105

        return (
                3 * a * (a + 1)  #
                + 5 * b * (b + 1)  # <-- three venn circles
                + 7 * c * (c + 1)  #

                - 15 * d * (d + 1)  #
                - 21 * e * (e + 1)  # <-- three venn lunes
                - 35 * f * (f + 1)  #

                + 105 * g * (g + 1)  # <-- one venn circular triangle
        ) // 2
# Runtime 43ms Beats 99.39% - Memory 16.3 MB Beats 63.46%

# Meta-Kata: Duplicate Detector v0.1
from collections import Counter
def dupe_detect(functions):
    l = [tuple(map(f, range(256))) for f in functions]
    lr = [tup for tup, v in Counter(l).items() if v>1]
    return [[i for i, t in enumerate(l) if t==f] for f in lr]

# 2057. Smallest Index With Equal Value
class Solution:
    def smallestEqual(self, nums: List[int]) -> int:
        for i in range(len(nums)):
            if i < 10:
                if i == nums[i]:
                    return i
            if i % 10 == nums[i]:
                return i
        return -1
# Runtime 96 ms Beats 67.97% - Memory 16.3 MB Beats 69.38%
class Solution:
    def smallestEqual(self, nums: List[int], i=0) -> int:
        return -1 if i == len(nums) else (i if i % 10 == nums[i] else self.smallestEqual(nums, i+1))
# Runtime 91 ms Beats 87.50% - Memory 16.4 MB Beats 29.22%

# Tongues
import string
def tongues(code):
    return code.translate(str.maketrans('aiyeouAIYEOUbkxznhdcwgpvjqtsrlmfBKXZNHDCWGPVJQTSRLMF', 'eouaiyEOUAIYpvjqtsrlmfbkxznhdcwgPVJQTSRLMFBKXZNHDCWG'))

# 1961. Check If String Is a Prefix of Array
class Solution:
    def isPrefixString(self, s: str, words: List[str]) -> bool:
        word = ''
        for i in range(0, len(words)):
            word += words[i]
            if s == word:
                return True
        return False

# Simple RSA Implementation
class RSA:
    import math
    def __init__(self, p, q, e):
        self.p = p
        self.q = q
        self.e = e
        self.n = p * q
        self.phi_n = (p - 1) * (q - 1)

    def encrypt(self, m):
        return m ** self.e % self.n

    def decrypt(self, c):
        d = pow(self.e, -1, self.phi_n)
        return pow(c, d, self.n)
    
# 111. Minimum Depth of Binary Tree
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def minDepth(self, root: Optional[TreeNode]) -> int:
        if root is None:
            return 0
        l = self.minDepth(root.left)
        r = self.minDepth(root.right)
        if root.left is None:
            return 1 + r
        if root.right is None:
            return 1 + l
        return min(l, r) + 1

# LET ME IN!
from itertools import count
def get_in_line(l):
    l.sort(key=lambda x: x if 0 < x < 3 else 3)
    for n in count(1):
        x = l.pop(0)
        if x == 0:
            return n
        elif x == 1:
            for i in range(len(l)//2):
                j = len(l) - 1 - i
                if l[i] not in (1,3) and l[j] not in (1,3):
                    l[i], l[j] = l[j], l[i]

# 1668. Maximum Repeating Substring
class Solution:
    def maxRepeating(self, sequence: str, word: str) -> int:
        if word not in sequence:
            return 0
        count, total = 0, ''
        while total in sequence:
            total += word
            count += 1
        return count - 1

# Missing number in Unordered Arithmetic Progression
def find(seq):
    mi, ma, result = seq[0], seq[0], seq[0]
    for i in range(1, len(seq)):
        mi, ma, result = min(mi, seq[i]), max(ma, seq[i]), result ^ seq[i]
    if mi == ma:
        return mi
    differens = (ma - mi) // len(seq)
    while mi <= ma:
        result = result ^ mi
        mi += differens
    return result
# Solution 2
def find(seq):
  return (min(seq)+max(seq))*(len(seq)+1)/2-sum(seq)

# The area between the vertex of the parabola and x-axis
def area(a, b, c):
    d = b**2 - 4 * a * c
    if d <= 0:
        return 0
    # calculate x1 and x2
    x1, x2 = (-b + d**.5) / (2 * a), (-b - d**.5) / (2 * a)
    # calculate integral by formula: ∫[a, b] f(x) dx >= ∫(((a/3)(x)^3 + (b/2)(x)^2 + c*(x)))dx
    return abs(((a/3) * (x1)**3 + (b/2) * (x1)**2 + c * (x1)) - ((a/3) * (x2)**3 + (b/2) * (x2)**2 + c * (x2)))

# 34. Find First and Last Position of Element in Sorted Array
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        if len(nums) == 0:
            return [-1, -1]
        pos, left, right = [-1, -1], 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                pos[0], right = mid, mid - 1
            if nums[mid] < target:
                left = mid + 1
            if nums[mid] > target:
                right = mid - 1
        if pos[0] == -1:
            return pos
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                pos[1], left = mid, mid + 1
            if nums[mid] < target:
                left = mid + 1
            if nums[mid] > target:
                right = mid - 1
        return pos

# Aerial Firefighting
from math import ceil
def waterbombs(fire, w):
    return sum(ceil(len(i) / w) for i in fire.split('Y'))

# 643. Maximum Average Subarray I
class Solution:
    def findMaxAverage(self, nums: List[int], k: int) -> float:
        top = res = sum(nums[:k])
        for i in range(len(nums)-k):
            top += nums[i+k] - nums[i]
            res = max(top, res)
        return res / k

# Easy Diagonal
def diagonal(n, p):
    su, com = 0, 1
    for k in range(0, n - p + 1):
        su +=com
        com = (com * (p + k + 1 )) // (k + 1)
    return su

# 2540. Minimum Common Value
class Solution:
    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:
        r,l = 0, 0
        while True:
            if l >= len(nums1) or r >= len(nums2):
                break
            print(l, r)
            if nums1[l] == nums2[r]:
                return nums1[l]
            if nums1[l] < nums2[r]:
                l += 1
                continue
            if nums1[l] > nums2[r]:
                r += 1
        return -1
    
# Coding Meetup #5 - Higher-Order Functions Series - Prepare the count of languages
from collections import Counter
def count_languages(lst):
    return Counter(i['language'] for i in lst)

# 278. First Bad Version
# The isBadVersion API is already defined for you.
# def isBadVersion(version: int) -> bool:

class Solution:
    def firstBadVersion(self, n: int) -> int:
        l, r = 1, n
        while l < r:
            mid = (l + r) // 2
            if isBadVersion(mid):
                r = mid
            else:
                l = mid + 1
        return l

# Remove consecutive duplicate words
def remove_consecutive_duplicates(s):
    if not s:
        return ''
    s= s.split()
    w = [s[0]]
    for i in range(1, len(s)):
        if s[i-1] != s[i]:
            w.append(s[i])
    return ' '.join(w)

# Volume of a cup
import math
def cup_volume(d1, d2, h):
    Rv, Rd = d1 / 2, d2 / 2
    return round((1/3) * math.pi * h * (Rv**2 + Rv * Rd + Rd**2), 2)

# 860. Lemonade Change
# My solution
class Solution:
    def lemonadeChange(self, bills: List[int]) -> bool:
        if bills[0] != 5:
            return False
        cash = [bills[0]]
        for i in range(1, len(bills)):
            if bills[i] == 5:
                cash.append(5)
                continue
            if bills[i] == 10:
                if min(cash) != 5:
                    return False
                cash.remove(5)
                cash.append(10)
                continue
            if bills[i] == 20:
                if 10 in cash:
                    if 5 not in cash:
                        return False
                    cash.remove(10)
                    cash.remove(5)
                    cash.append(20)
                    continue
                if cash.count(5) < 3:
                    return False
                cash.remove(5)
                cash.remove(5)
                cash.remove(5)
                cash.append(20)
        return True

# Second solution
        five, ten = 0, 0
        for i in range(len(bills)):
            if bills[i] == 5:
                five += 1
            elif bills[i] == 10:
                five, ten = five - 1, ten + 1
            elif ten > 0:
                five, ten = five - 1, ten - 1
            else:
                five -= 3
            if five < 0:
                return False
        return True
    
# 746. Min Cost Climbing Stairs
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        l = [cost[0]] + [0] * (len(cost) - 1)
        if len(l) >= 2:
            l[1] = cost[1]
        for i in range(2, len(cost)):
            l[i] = cost[i] + min(l[i-1], l[i - 2])
        return min(l[-1], l[-2])
    
# Find the smallest
def smallest(n):
    n, l = str(n), [n, 0, 0]
    for i in range(len(n)):
        top, copy = (int(n), -1), n[:i] + n[i+1:]
        for j in range(len(copy) + 1):
            sec = int(copy[:j] + n[i] + copy[j:])
            if top[0] > sec:
                top = (sec, j)
        l = [top[0], i, top[1]] if l[0] > top[0] else l
    return l

# 33. Search in Rotated Sorted Array
# My solution with flag
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right, flag = 0, len(nums) - 1, True
        while left <= right:
            mid = (left + right) // 2
            flag = nums[left] <= nums[mid]
            if flag:
                if nums[left] <= target <= nums[mid]:
                    if nums[mid] == target:
                        return mid
                    if nums[mid] > target:
                        right = mid - 1
                    else:
                        left = mid + 1
                else:
                    left = mid + 1
            else:
                if nums[mid] <= target <= nums[right]:
                    if nums[mid] == target:
                        return mid
                    if nums[mid] > target:
                        right = mid - 1
                    else:
                        left = mid + 1
                else:
                    right = mid - 1
        return -1

# Classic binary search
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return mid
            if nums[mid] < nums[right]:
                if nums[mid] < target <= nums[right]:
                    left = mid + 1
                else:
                    right = mid - 1
            else:
                if nums[left] <= target < nums[mid]:
                    right = mid - 1
                else:
                    left = mid + 1
        return -1

# Diagonals sum
def sum_diagonals(matrix):
    if not matrix[0]:
        return 0
    total, step = 0, 0
    for i in matrix:
        total += i[step] + i[-step + -1]
        step += 1
    return total

# 292. Nim Game
class Solution:
    def canWinNim(self, n: int) -> bool:
        return n % 4 != 0

# Turn any word into a beef taco
def tacofy(word):
    l = []
    d = {'t':'tomato','l':'lettuce','c':'cheese','g':'guacamole','s':'salsa'}
    for i in word:
        if i.lower() in 'aeoiu':
            l.append('beef')
        if i.lower() in d:
            l.append(d[i.lower()])
    return ['shell'] + l + ['shell']

# 747. Largest Number At Least Twice of Others
class Solution:
    def dominantIndex(self, nums: List[int]) -> int:
        hi, hi_i = max(nums), 0
        for i in range(len(nums)):
            if nums[i] == hi:
                hi_i = i
            if nums[i] != hi and nums[i] * 2 > hi:
                return -1
        return hi_i

# Minimum Perimeter of a Rectangle
def minimum_perimeter(area):
    i = int(area ** .5)
    while area % i:
        i -= 1
    return 2 * i + 2 * (area // i)

# 819. Most Common Word
class Solution:
    def mostCommonWord(self, letters: str, ban: List[str]) -> str:
        d, word = {}, ''
        for i in letters.lower():
            if not i.isalpha():
                if word and word not in ban:
                    if word not in d:
                        d[word] = 0
                    d[word] += 1
                word = ''
            else:
                word += i
        if word and word not in ban:
            if word not in d:
                d[word] = 0
            d[word] += 1
        return sorted(d.items(), key=lambda x: -x[1])[0][0]

# Building Spheres
class Sphere(object):
    def __init__(self, radius, mass):
        self.rad = radius
        self.mass = mass
    def get_radius(self):
        return self.rad
    def get_mass(self):
        return self.mass
    def get_volume(self):
        import math
        return round((4 / 3) * math.pi * self.rad**3, 5)
    def get_surface_area(self):
        import math
        return round(4 * math.pi * self.rad**2, 5)
    def get_density(self):
        return round(self.mass / self.get_volume(), 5)

# Two numbers are positive
def two_are_positive(*args):
    return sum(i > 0 for i in args) == 2

# 657. Robot Return to Origin
class Solution:
    def judgeCircle(self, moves: str) -> bool:
        l, u = 0, 0
        for i in moves:
            if i == 'U':
                u += 1
            if i == 'D':
                u -= 1
            if i == 'L':
                l += 1
            if i == 'R':
                l -= 1
        return u == 0 and l == 0
    
# 2788. Split Strings by Separator
class Solution:
    def splitWordsBySeparator(self, words: List[str], separator: str) -> List[str]:
        l = []
        for i in words:
            for j in i.split(separator):
                if j:
                    l.append(j)
        return l

# What's a Perfect Power anyway?
def isPP(n):
    for i in range(2, n):
        for j in range(2, n):
            if i ** j > n:
                break
            if i ** j == n:
                return [i, j]

# "Center yourself", says the monk.
def center(strng, width, fill=' '):
    if len(strng) > width:
        return strng
    if (width - len(strng)) % 2 == 0:
        cop = fill * ((width - len(strng)) // 2) + strng
    else:
        cop = fill * ((width - len(strng)) // 2 + 1) + strng
    return cop + fill * (width - len(cop))

# 50. Pow(x, n)
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if n == 0:
            return 1
        if n < 0:
            x = 1 / x
            n *= -1
        if n % 2 != 0:
            return x * self.myPow(x, n - 1)
        else:
            temp = self.myPow(x, n/2)
            return temp * temp

# 852. Peak Index in a Mountain Array
class Solution:
    def peakIndexInMountainArray(self, arr: List[int]) -> int:
        l, r = 0, len(arr) - 1
        while l < r:
            mid = (l + r) // 2
            if arr[mid] > arr[mid + 1]:
                r = mid
            else:
                l = mid + 1
        return l

# Tram Capacity
def tram(stops, d, o):
    top = o[0] - d[0]
    max = top
    for i in range(1, stops):
        top -= d[i]
        top += o[i]
        if top > max:
            max = top
    return max

# 1870. Minimum Speed to Arrive on Time
class Solution:
    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:
        def mintime(speed, dist, hour):
            import math
            top = 0
            for i in range(len(dist)-1):
                top += math.ceil(dist[i]/speed)
            top += dist[-1] / speed
            return top <= hour
        l, r, m = 1, 10 ** 7, -1
        while l <= r:
            mid = (l + r) // 2
            if mintime(mid, dist, hour):
                m = mid
                r = mid - 1
            else:
                l = mid + 1
        return m

# Valid Braces
def valid_braces(string):
    d = {')': '(', ']': '[', '}': '{'}
    stack = []
    for i in string:
        if i not in d:
            stack.append(i)
        else:
            if not stack:
                return False
            if stack[-1] != d[i]:
                return False
            stack.pop()
    return not stack

# 263. Ugly Number
class Solution:
    def isUgly(self, n: int) -> bool:
        if n <= 0:
            return False
        while n % 2 == 0:
            n //= 2
        while n % 3 == 0:
            n //= 3
        while n % 5 == 0:
            n //= 5
        return n == 1

# Keep the Order
def keep_order(ary, val):
    l, r = 0, len(ary) - 1
    while l <= r:
        mid = l + (r - l) // 2
        if ary[mid] >= val:
            r = mid - 1
        else:
            l = mid + 1
    return l

# 1002. Find Common Characters
class Solution:
    def commonChars(self, words: List[str]) -> List[str]:
        l = []
        for i in set(words[0]):
            if all(i in j for j in words):
                c = min(j.count(i) for j in words)
                l += [i] * c
        return l

# Tic-Tac-Toe Checker
def is_solved(board):
    moves = [board[0], board[1], board[2], [i[0] for i in board],
            [i[1] for i in board], [i[2] for i in board],
            [board[i][i] for i in range(len(board))],
             [board[i][-(i + 1)] for i in range(len(board))]
            ]
    if any(i.count(1) == 3 for i in moves):
        return 1
    if any(i.count(2) == 3 for i in moves):
        return 2
    if all(i.count(0) == 0 for i in moves):
        return 0
    else:
        return -1
    
# 2562. Find the Array Concatenation Value
class Solution:
    def findTheArrayConcVal(self, nums: List[int]) -> int:
        stack = 0
        while len(nums) > 1:
            stack += int(str(nums.pop(0)) + str(nums.pop(-1)))
        if len(nums) == 1:
            stack += nums[0]
        return stack

# 808. Soup Servings
class Solution:
    def soupServings(self, n: int) -> float:
        if n > 4800:
            return 1
        n = (n + 24) // 25
        d = {}
        def dyn_prog(x, y):
            if (x, y) in d:
                return d[(x,y)]
            if x <= 0 and y <= 0:
                return 0.5
            if x <= 0:
                return 1
            if y <= 0:
                return 0
            d[(x, y)] = 0.25 * (dyn_prog(x-4, y) + dyn_prog(x-3, y-1) + dyn_prog(x-2, y-2) + dyn_prog(x-1, y-3))
            return d[(x,y)]
        return dyn_prog(n, n)

# Binary sXORe
 def sxore(n):
    return [n, 1, n + 1, 0][n % 4]

# 598. Range Addition II
class Solution:
    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:
        min_row, min_col = m, n
        for i in range(len(ops)):
            min_row = min(min_row, ops[i][0])
            min_col = min(min_col, ops[i][1])
        return min_row * min_col

# Binary scORe
 def score(n):
    return 2 ** n.bit_length() - 1

# 191. Number of 1 Bits
class Solution:
    def hammingWeight(self, n: int) -> int:
        c = 0
        while n:
            c += 1
            n &= n - 1
        return c

# Transposing a song
def transpose(song, interval):
    d = {"Bb": "A#", "Db": "C#", "Eb": "D#", "Gb": "F#", "Ab": "G#"}
    l = ['A', 'A#', 'B', 'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#']
    return [l[(l.index(d.get(i, i)) + interval) % 12] for i in song]

# 77. Combinations
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        def backtrack(start, current_comb):
            if len(current_comb) == k:
                all_comb.append(list(current_comb))
                return
            for i in range(start, n + 1):
                current_comb.append(i)
                backtrack(i+1, current_comb)
                current_comb.pop()
        all_comb = []
        backtrack(1, [])
        return all_comb

# Increasing Numbers with N Digits
def increasing_numbers(digits):
    if digits == 0:
        return 1
    dp = [[0] * 10 for _ in range(digits + 1)]
    for j in range(10):
        dp[1][j] = 1

    for i in range(2, digits + 1):
        for j in range(10):
            for k in range(j + 1):
                dp[i][j] += dp[i - 1][k]
    total_count = sum(dp[digits][j] for j in range(1, 10))
    return total_count + 1

# 46. Permutations
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        import itertools
        return list(itertools.permutations(nums))
    
# Random Substitution Cipher
import random
def random_sub():
    d = {"a":"c", "b":"p", "c":"j", "d":"a", "e":"v", "f":"d",
         "g":"g", "h":"u", "i":"l", "j":"t", "k":"n", "l":"w",
         "m":"m", "n":"o", "o":"i", "p":"s", "q":"f", "r":"r", "s":"x", "t":"b",
         "u":"h", "v":"y", "w":"q", "x":"e", "y":"k", "z":"z"}
    en_al = 'abcdefghijklmnopqrstuvwxyz'
    for k, v in d.items():
        let = random.choice(en_al)
        d[k] = let
        en_al = en_al.replace(let, '')
    return d

# 561. Array Partition
class Solution:
    def arrayPairSum(self, nums: List[int]) -> int:
        nums = sorted(nums)
        return sum(i for i in nums[::2])

# Fast cooking pancakes
import math
def cook_pancakes(n, m):
    return math.ceil(n / m * 2) if n >= m else 2

# 139. Word Break
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        l = [False] * (len(s) + 1)
        l[0] = True
        for i in range(1, len(s) + 1):
            for j in range(i):
                if l[j] and s[j:i] in wordDict:
                    l[i] = True
                    break
        return l[-1]

# ASCII Shift Encryption/Decryption
def ascii_encrypt(plaintext):
    if not plaintext:
        return plaintext
    return ''.join(chr(ord(plaintext[i]) + i) for i in range(len(plaintext)))


def ascii_decrypt(encrypted):
    if not encrypted:
        return encrypted
    return ''.join(chr(ord(encrypted[i]) - i) for i in range(len(encrypted)))

# 2744. Find Maximum Number of String Pairs
class Solution:
    def maximumNumberOfStringPairs(self, words: List[str]) -> int:
        count = 0
        while True:
            top = 0
            for i in range(len(words)):
                for j in range(i + 1, len(words)):
                    if words[i][::-1] == words[j]:
                        count += 1
                        top += 1
                        words.pop(j)
                        words.pop(i)
                        break
            if top == 0:
                break
        return count
    
# Race Ceremony
from math import ceil
def race_podium(b):
    x = ceil((b) / 3) + 1
    y = min(x - 1, b - x - 1)
    return y, x, b - x - y

# 2595. Number of Even and Odd Bits
class Solution:
    def evenOddBit(self, n: int) -> List[int]:
        odd, even, flag = 0, 0, True
        for i in bin(n)[2:][::-1]:
            if flag:
                flag = False
                if i == '1':
                    even += 1
            else:
                flag = True
                if i == '1':
                    odd += 1
        return [even, odd]

# Point in Polygon
def point_in_polygon(poly, point) -> bool:
    x,y  = point
    n = len(poly)
    inside = False
    p1x,p1y = poly[0]
    for i in range(n+1):
        p2x,p2y = poly[i % n]
        if y > min(p1y,p2y):
            if y <= max(p1y,p2y):
                if x <= max(p1x,p2x):
                    if p1y != p2y:
                        xints = (y-p1y)*(p2x-p1x)/(p2y-p1y)+p1x
                    if p1x == p2x or x <= xints:
                        inside = not inside
        p1x,p1y = p2x,p2y
    return inside

# 74. Search a 2D Matrix
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        left, right, colum = 0, (len(matrix) * len(matrix[0])) - 1, len(matrix[0])
        while left <= right:
            middle = (left + right) // 2
            if matrix[middle // colum][middle % colum] == target:
                return True
            if matrix[middle // colum][middle % colum] > target:
                right = middle - 1
            else:
                left = middle + 1
        return False
    
# The unknown but known variables: Addition
def the_var(the_variables):
    en_al = 'abcdefghijklmnopqrstuvwxyz'
    op = the_variables.split('+')
    return en_al.index(op[0]) + en_al.index(op[1]) + 2

# 2586. Count the Number of Vowel Strings in Range
class Solution:
    def vowelStrings(self, words: List[str], left: int, right: int) -> int:
        count, vowels = 0, 'aeoiu'
        for i in range(left, right + 1):
            if words[i][0] in vowels and words[i][-1] in vowels:
                count += 1
        return count

# Min Factor Distance
from functools import reduce
def min_distance(n):
    factor = sorted(set(reduce(list.__add__, ([i, n // i] for i in range(1, int(n**.5)+1) if n % i == 0))))
    return min(factor[i+1] - factor[i] for i in range(len(factor)) if i + 1 < len(factor))

# 680. Valid Palindrome II
class Solution:
    def validPalindrome(self, s: str) -> bool:
        start, end = 0, len(s) - 1
        while start < end:
            if s[start] != s[end]:
                first, second = s[start:end], s[start+1:end+1]
                return first == first[::-1] or second == second[::-1]
            start, end = start + 1, end - 1
        return True

# Who Took The Car Key?
def who_took_the_car_key(message):
    return ''.join(chr(int(word, 2)) for word in message)

# 81. Search in Rotated Sorted Array II
class Solution:
    def search(self, nums: List[int], target: int) -> bool:
        left, right = 0, len(nums) - 1
        while left <= right:
            middle = (left + right) // 2
            if nums[middle] == target:
                return True
            if nums[middle] == nums[right]:
                right -= 1
            elif nums[middle] > nums[right]:
                if nums[left] <= target < nums[middle]:
                    right = middle - 1
                else:
                    left = middle + 1
            else:
                if nums[middle] < target <= nums[right]:
                    left = middle + 1
                else:
                    right = middle - 1
        return False

# Coprimes up to N
import math
def coprimes(n):
    ans = []
    for i in range(1, n):
        if math.gcd(n, i) == 1:
            ans.append(i)
    return ans

# 2806. Account Balance After Rounded Purchase
class Solution:
    def accountBalanceAfterPurchase(self, pur: int) -> int:
        return 100 - (pur + 5) // 10 * 10

# Hanging the curtains
def number_of_hooks(length, max_hook_dist):
    out = 1
    while length / out > max_hook_dist:
        out = out * 2
    return out + 1

# 2490. Circular Sentence
class Solution:
    def isCircularSentence(self, sentence: str) -> bool:
        sen = sentence.split()
        for i in range(len(sen)):
            if sen[i-1][-1] != sen[i][0]:
                return False
        return True

# Last man standing
def last_man_standing(n):
    n, flag = list(range(1, n+1)), True
    while len(n) > 1:
        if flag:
            n = n[1::2]
            flag = False
        else:
            n = n[-2::-2][::-1]
            flag = True
    return n[0]

# 2570. Merge Two 2D Arrays by Summing Values
class Solution:
    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:
        res, right, left = [], 0, 0
        while left < len(nums1) and right < len(nums2):
            if nums1[left][0] == nums2[right][0]:
                res.append([nums1[left][0], nums1[left][1] + nums2[right][1]])
                left, right = left + 1, right + 1
            else:
                if nums1[left][0] < nums2[right][0]:
                    res.append([nums1[left][0], nums1[left][1]])
                    left += 1
                else:
                    res.append([nums2[right][0], nums2[right][1]])
                    right += 1
        while left < len(nums1):
            res.append(nums1[left])
            left += 1
        while right < len(nums2):
            res.append(nums2[right])
            right += 1
        return res
    
# The mean of two means
def get_mean(arr,x,y):
    if (x <= 1 or y <= 1) or (x > len(arr) or y > len(arr)):
        return -1
    return (sum(arr[:x]) / x + sum(arr[-y:]) / y) / 2

# 215. Kth Largest Element in an Array
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        heap = nums[:k]
        heapq.heapify(heap)
        for i in nums[k:]:
            if i > heap[0]:
                heapq.heappop(heap)
                heapq.heappush(heap, i)
        return heap[0]

# What time is it?
 from datetime import datetime
def get_military_time(time):
    in_time = datetime.strptime(time, "%I:%M:%S%p")
    return datetime.strftime(in_time, "%H:%M:%S")

# 2644. Find the Maximum Divisibility Score
class Solution:
    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:
        count, top, top_n = 0, 0, divisors[0]
        for i in divisors:
            count = 0
            for j in nums:
                if j % i == 0:
                    count += 1
            if count > top:
                top_n, top = i, count
            if count == top:
                top_n = min(i, top_n)
        return top_n if top > 0 else min(divisors)
    
# Log without dates
from datetime import datetime
def check_logs(log):
    if len(log) == 0:
        return 0
    count = 1
    for x, y in zip(log, log[1:]):
        x = datetime.strptime(x, '%H:%M:%S')
        y = datetime.strptime(y, '%H:%M:%S')
        if x >= y:
            count += 1
    return count

# Converting 12-hour time to 24-hour time
from datetime import datetime
def to24hourtime(hour, minute, period):
    start = str(hour) + ':' + str(minute) + period
    start = datetime.strptime(start, '%I:%M%p')
    return datetime.strftime(start, '%H%M')

# 2515. Shortest Distance to Target String in a Circular Array
class Solution:
    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:
        if target not in words:
            return -1
        left, right = -1, -1
        while True:
            left += 1
            if words[(startIndex - left + len(words)) % len(words)] == target:
                break
        while True:
            right += 1
            if words[(startIndex + right) % len(words)] == target:
                break
        return min(left, right)

# Cats and shelves
def solution(start, finish):
    count = 0
    while finish > start:
        count += 1
        if start + 3 <= finish:
            start += 3
        else:
            start += 1
    return count

# 2481. Minimum Cuts to Divide a Circle
class Solution:
    def numberOfCuts(self, n: int) -> int:
        if n == 1:
            return 0
        return n // 2 if n % 2 == 0 else n
    
# After(?) Midnight
def day_and_time(mins):
    days = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
    total_minutes = mins % (7 * 24 * 60)
    day_index = total_minutes // (24 * 60)
    hour = (total_minutes % (24 * 60)) // 60
    minute = total_minutes % 60
    return f"{days[day_index]} {hour:02d}:{minute:02d}"

# 2600. K Items With the Maximum Sum
class Solution:
    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:
        # Solution 1
        # count = 0
        # while k > 0:
        #     k -= 1
        #     if numOnes > 0:
        #         count += 1
        #         numOnes -= 1
        #         continue
        #     if numZeros > 0:
        #         numZeros -= 1
        #         continue
        #     if numNegOnes > 0:
        #         count += -1
        #         numNegOnes -= 1
        #         continue
        # return count
        return k if k <= numOnes else numOnes - max(0, k - numOnes - numZeros)

# Estimating Amounts of Subsets
def est_subsets(arr):
    return 2 ** len(set(arr)) - 1

# 645. Set Mismatch
class Solution(object):
    def findErrorNums(self, nums):
        return [sum(nums) - sum(set(nums)), list(set(range(1, len(nums) + 1)) - set(nums))[0]]
        # Math solution
        # x, y, z = len(nums), sum(nums), sum(set(nums))
        # k = (x * (x + 1)) // 2
        # return [y - z, k - z]

# The Most Amicable of Numbers
def amicable_numbers(n1,n2):
    div_n1 = [i for i in range(1, n1 // 2 + 1) if n1 % i == 0]
    div_n2 = [i for i in range(1, n2 // 2 + 1) if n2 % i == 0]
    return sum(div_n1) == n2 and sum(div_n2) == n1

# 409. Longest Palindrome
class Solution(object):
    def longestPalindrome(self, s):
        d, count = {}, 0
        for i in s:
            if i in d:
                d[i] += 1
                if d[i] % 2 == 0:
                    count += 2
            else:
                d[i] = 1
        return count + 1 if len(s) - count != 0 else count
    
# Playing with passphrases
def play_pass(s, n):
    al = 'ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ'
    for i in range(len(s)):
        if s[i] in al:
            if i % 2 != 0:
                s = s[:i] + al[al.index(s[i]) + n % 26].lower() + s[i+1:]
            else:
                s = s[:i] + al[al.index(s[i]) + n % 26].upper() + s[i+1:]
        if s[i].isdigit():
            s = s[:i] + str(9 - int(s[i])) + s[i+1:]
    return s[::-1]

# Playing with passphrases
class Solution(object):
    def repeatedSubstringPattern(self, s):
        if len(s) == 1:
            return False
        for i in range(len(s) // 2):
            count = s[:i+1]
            cop = ''
            while len(cop) < len(s):
                cop += count
            if cop == s:
                return True
        return False

# Find The Parity Outlier
def find_outlier(inter):
    odd, even = sum(inter[i] % 2 != 0 for i in range(3)), sum(inter[i] % 2 == 0 for i in range(3))
    flag = odd > even
    if flag:
        for i in inter:
            if i % 2 == 0:
                return i
    for i in inter:
        if i % 2 != 0:
            return i

# 168. Excel Sheet Column Title
class Solution(object):
    def convertToTitle(self, columnNumber):
        l = []
        while columnNumber:
            columnNumber, i = (columnNumber - 1) // 26, (columnNumber - 1) % 26
            l.append(chr(i + ord('A')))
        return ''.join(l)[::-1]
    
# Convert string to camel case
import re
def to_camel_case(text):
    if len(text) == 0:
        return ''
    w = re.split('_|-| ', text)
    return (w[0].lower() if w[0][0].islower() else w[0].title()) + ''.join(i.title() for i in w[1:])

# 767. Reorganize String
class Solution(object):
    def reorganizeString(self, s):
        n, c = len(s), Counter(s)
        arr = sorted([ch for ch in c], key = lambda x: -c[x])
        if c[arr[0]] > (len(s)+1)//2: return ''
        chars = list(chain(*[[ch]*c[ch] for ch in arr]))
        return ''.join([chars[(n+i)//2] if i%2 else chars[i//2] for i in range(n)])

# Highest Scoring Word
 def high(x):
    return max(x.split(), key=lambda k: sum(ord(c) - 96 for c in k))

# 2769. Find the Maximum Achievable Number
class Solution(object):
    def theMaximumAchievableX(self, num, t):
        # top = 0
        # for i in range(num // 2, num * 2 + t * 2):
        #     x, y = num + t, i - t
        #     if x == y:
        #         if top < i:
        #             top = i
        # return top
        return num + t + t

# Range Extraction
def solution(args):
    if len(args) == 1:
        return str(args)
    l = []
    while args:
        cop = [args[0]]
        for i in args[1:]:
            if cop[-1] + 1 == i:
                cop.append(i)
            else:
                break
        if cop[0] != cop[-1]:
            if len(cop) > 2:
                l.append(str(cop[0])+'-'+str(cop[-1]))
            else:
                l.append(str(cop[0]))
                l.append(str(cop[-1]))
        else:
            l.append(str(cop[0]))
        args = args[args.index(cop[-1]) + 1:]
    return ','.join(l)

# Roman Numerals Encoder
def solution(n):
    integer = ''
    rom = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'),
           (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]
    while n > 0:
        for k,v in rom:
            while n >= k:
                integer += v
                n -= k
    return integer

# 1221. Split a String in Balanced Strings
# Solution 1 by Stack
class Solution(object):
    def balancedStringSplit(self, s):
        stack, count, top = [], 0, s[0]
        for i in range(len(s)):
            if len(stack) == 0:
                count += 1
                top = s[i]
            if s[i] == top:
                stack.append(s[i])
            elif len(stack) != 0:
                stack.pop()
        return count
# Solution 2 by count (best solution)
class Solution(object):
    def balancedStringSplit(self, s):
        top, count = 0, 0
        for i in range(len(s)):
            if s[i] == 'L':
                top += 1
            else:
                top -= 1
            if top == 0:
                count += 1
        return count
# Solution 3 - My initial solution
class Solution(object):
    def balancedStringSplit(self, s):
        count, left, right = 0, 0, 0
        for i in s:
            if i == 'R':
                right += 1
            else:
                left += 1
            if left == right:
                count += 1
                left = 0
                right = 0
        return count

# 646. Maximum Length of Pair Chain
class Solution(object):
    def findLongestChain(self, pairs):
        if len(pairs) == 1:
            return 1
        lenght = 1
        pairs = sorted(pairs, key=lambda x: x[1])
        top = pairs[0][1]
        for i in range(1, len(pairs)):
            if top < pairs[i][0]:
                lenght += 1
                top = pairs[i][1]
        return lenght

# Human readable duration format
 def format_duration(s):
    if s == 0:
        return 'now'
    time = {'year': 365*24*60*60, 'day': 24*60*60, 'hour': 60*60, 'minute': 60, 'second': 1}
    for k,v in time.items():
        count = 0
        while s >= v:
            s -= v
            count += 1
        time[k] = count
    dates = []
    for k,v in time.items():
        if v > 0:
            dates.append((v, k if v == 1 else k + 's'))
    if len(dates) > 1:
        return ', '.join(str(date[0]) + ' ' + date[1] for date in dates[:-1]) \
    + ' and ' + str(dates[-1][0]) + ' ' + dates[-1][1]
    return str(dates[0][0]) + ' ' + dates[0][1]

# 274. H-Index
# Solution 1 O(N * N) == O(N**2)
class Solution(object):
    def hIndex(self, citations):
        h, count = 0, 0
        while True:
            for i in citations:
                if i >= h + 1:
                    count += 1
            if count >= h + 1:
                h += 1
                count = 0
            else:
                break
        return h
# Solution 2 O(N log N)
class Solution(object):
    def hIndex(self, citations):
        citations.sort()
        for i in range(1, len(citations) + 1):
            if citations[-i] < i:
                return i - 1
        return len(citations)
# Solution 3 O(N)
class Solution(object):
    def hIndex(self, citations):
        cop, n = [0] * (len(citations) + 1), len(citations)
        for num in citations:
            if num >= n:
                cop[n] += 1
            else:
                cop[num] += 1
        pos = 0
        for i in range(n + 1):
            for j in range(cop[i]):
                citations[pos] = i
                pos += 1
        for i in range(1, n+1):
            if citations[-i] < i:
                return i - 1
        return n

# 240. Search a 2D Matrix II
# Solution 1 O(m * n)
class Solution(object):
    def searchMatrix(self, matrix, target):
        for m in range(len(matrix)):
            for n in range(len(matrix[0])):
                if matrix[m][n] == target:
                    return True
        return False
# Solution 2 O(m * logn)
class Solution(object):
    def searchMatrix(self, matrix, target):
        for m in range(len(matrix)):
            left, right = 0, len(matrix[0]) - 1
            while left <= right:
                middle = (left + right) // 2
                if matrix[m][middle] == target:
                    return True
                elif matrix[m][middle] > target:
                    right = middle - 1
                else:
                    left = middle + 1
        return False
# Solution 3 O(m + n)
class Solution(object):
    def searchMatrix(self, matrix, target):
        m, n = len(matrix), len(matrix[0])
        x, y = 0, n - 1
        while x < m and y >= 0:
            if matrix[x][y] == target:
                return True
            elif matrix[x][y] > target:
                y -= 1
            else:
                x += 1
        return False
    
# Take a Number And Sum Its Digits Raised To The Consecutive Powers And ....¡Eureka!!
def sum_dig_pow(a, b):
    l = []
    for i in range(a, b + 1):
        count = 0
        for j in range(len(str(i))):
            count += int(str(i)[j]) ** (j + 1)
        if count == i:
            l.append(i)
    return l

# 1528. Shuffle String
class Solution(object):
    def restoreString(self, s, indices):
        word = [0] * len(s)
        for i in range(len(indices)):
            word[indices[i]] = s[i]
        return ''.join(word)

# 225. Implement Stack using Queues
class MyStack(object):

    def __init__(self):
        self.lis = []

    def push(self, x):
        """
        :type x: int
        :rtype: None
        """
        return self.lis.append(x)

    def pop(self):
        """
        :rtype: int
        """
        return self.lis.pop()

    def top(self):
        """
        :rtype: int
        """
        return self.lis[-1]

    def empty(self):
        """
        :rtype: bool
        """
        return not self.lis

# Your MyStack object will be instantiated and called as such:
# obj = MyStack()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.top()
# param_4 = obj.empty()

# 1114. Print in Order
# Solution 1 - slow solution by while loop
class Foo(object):
    def __init__(self):
        self.flag1 = False
        self.flag2 = False

    def first(self, printFirst):
        """
        :type printFirst: method
        :rtype: void
        """

        # printFirst() outputs "first". Do not change or remove this line.
        printFirst()
        self.flag1 = True

    def second(self, printSecond):
        """
        :type printSecond: method
        :rtype: void
        """
        while not self.flag1:
            continue
        self.flag1 = True
        # printSecond() outputs "second". Do not change or remove this line.
        printSecond()
        self.flag2 = True

    def third(self, printThird):
        """
        :type printThird: method
        :rtype: void
        """
        while not self.flag2:
            continue
        # printThird() outputs "third". Do not change or remove this line.
        printThird()
# Solution 2 - by events
import threading


class Foo(object):
    def __init__(self):
        self.flag1 = threading.Event()
        self.flag2 = threading.Event()

    def first(self, printFirst):
        """
        :type printFirst: method
        :rtype: void
        """
        # printFirst() outputs "first". Do not change or remove this line.
        printFirst()
        self.flag1.set()

    def second(self, printSecond):
        """
        :type printSecond: method
        :rtype: void
        """
        self.flag1.wait()
        # printSecond() outputs "second". Do not change or remove this line.
        printSecond()
        self.flag2.set()

    def third(self, printThird):
        """
        :type printThird: method
        :rtype: void
        """
        self.flag2.wait()
        # printThird() outputs "third". Do not change or remove this line.
        printThird()

# Strip Comments
def strip_comments(strng, markers):
    strng = strng.split('\n')
    for i in range(len(strng)):
        for spl in markers:
            if spl in strng[i]:
                strng[i] = strng[i].split(spl)[0].rstrip()
    return '\n'.join(strng)

# 2483. Minimum Penalty for a Shop
class Solution(object):
    def bestClosingTime(self, customers):
        score, top, time = 0, 0, -1
        for i in range(len(customers)):
            top += 1 if customers[i] == "Y" else -1
            if top > score:
                score = top
                time = i
        return time + 1

# So Many Permutations!
 def permutations(s):
    l = []
    def permute(data, i, length):
        if i == length:
            l.append(''.join(data) )
        else:
            for j in range(i, length):
                data[i], data[j] = data[j], data[i]
                permute(data, i + 1, length)
                data[i], data[j] = data[j], data[i]
    permute(list(s), 0, len(s))
    return set(l)

# 1678. Goal Parser Interpretation
# Solution 1 - replace method
class Solution(object):
    def interpret(self, command):
        return command.replace('()', 'o').replace('(al)', 'al')
# Solution 2 - by while loop and array
class Solution:
    def interpret(self, command: str) -> str:
        ans, i = [], 0
        while i < len(command):
            if command[i] == 'G':
                ans += ['G']
                i += 1
            elif command[i:i + 2] == '()':
                ans += ['o']
                i += 2
            else:
                ans += ['al']
                i += 4
        return ''.join(ans)

# WeIrD StRiNg CaSe
def to_weird_case(words):
    words, ans = words.split(), []
    for i in words:
        top = ''
        for j in range(len(i)):
            if j % 2 == 0:
                top += i[j].upper()
            else:
                top += i[j].lower()
        ans.append(top)
    return ' '.join(ans)
# 2269. Find the K-Beauty of a Number2269. Find the K-Beauty of a Number
class Solution:
    def divisorSubstrings(self, num: int, k: int) -> int:
        count = 0
        num = str(num)
        for i in range(len(num) - k + 1):
            if num[i:i+k] != '0' * k:
                if int(num) % int(num[i:i+k]) == 0:
                    count += 1
        return count

# Sum Strings as Numbers
def sum_strings(x, y):
    if len(x)> len(y):
        temp = x
        x = y
        y = temp
    str3, n1, n2 = "", len(x), len(y)
    diff, carry = n2 - n1, 0
    for i in range(n1-1, -1, -1):
        sum = ((ord(x[i]) - ord('0')) + int((ord(y[i + diff]) - ord('0'))) + carry)
        str3 = str3 + str(sum%10)
        carry = sum//10
    for i in range(n2-n1-1, -1, -1):
        sum = ((ord(y[i]) - ord('0')) + carry)
        str3 = str3 + str(sum%10 )
        carry = sum//10
    if carry:
        print(carry, str3)
        str3 += str(carry)
    str3 = str3[::-1]
    if not str3:
        return '0'
    if str3[0] == '0':
        str3 = str3[1:]
    return str3 if str3 else '0'
# 338. Counting Bits
# Solution 2
class Solution:
    def countBits(self, num):
        ret = [0] * (num + 1)
        for i in range(1, num+1):
            ret[i] = ret[i>>1] + (i&1)
        return ret
    
# Handshake problem
def get_participants(handshakes):
    count = 0
    while handshakes > 0:
        handshakes -= count
        count += 1
    return count

# 2784. Check if Array is Good
# Solution 1
class Solution:
    def isGood(self, nums: List[int]) -> bool:
        m = max(nums)
        if len(nums) != m + 1:
            return False
        nums.sort()
        for i in range(1, m + 1):
            if i != nums[i-1]:
                return False
        return m == nums[-1]
# Solution 2
class Solution:
    def isGood(self, nums: List[int]) -> bool:
        m = max(nums)
        l = list(range(1, m+1)) + [m]
        return l == sorted(nums)
# Solution 3
class Solution:
    def isGood(self, nums: List[int]) -> bool:
        n = max(nums)
        return sum(nums) == (n * (n + 1) // 2) + n and len(set(nums)) == n

# Reverse or rotate?
def rev_rot(strng, sz):
    if sz > len(strng) or sz <= 0 or len(strng) == 0:
        return ''
    chunk = [(strng[i:i+sz], sum(int(j)**3 for j in strng[i:i+sz])) \
             for i in range(0, len(strng), sz) if len(strng[i:i+sz]) == sz]
    return ''.join(k[::-1] if v % 2 == 0 else k[1:] + k[0] for k,v in chunk)

# 2099. Find Subsequence of Length K With the Largest Sum
class Solution:
    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:
        ans = sorted(enumerate(nums), key=lambda x: x[1])[-k:]
        return [v for k, v in sorted(ans)]

# Roman Numerals Helper
rom = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'),
      (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]
class RomanNumerals:
    @staticmethod
    def to_roman(val):
        integer = ''
        while val > 0:
            for k,v in rom:
                while val >= k:
                    integer += v
                    val -= k
        return integer

    @staticmethod
    def from_roman(roman_num):
        ans = 0
        while roman_num:
            for k,v in rom:
                if roman_num.startswith(v):
                    ans += k
                    roman_num = roman_num[len(v):]
        return ans

# The observed PIN
import itertools
def get_pins(observed):
    d = {1:[2,4], 2:[1,3,5], 3:[2,6],4:[1,5,7],
         5:[4,2,6,8], 6:[9,5,3], 7:[4,8], 8:[7,5,9,0], 9:[8,6], 0:[8]}
    l = [list(map(str, d[int(i)])) + [i] for i in observed]
    ans = [''.join(i) for i in itertools.product(*l)]
    return ans

# Next bigger number with the same digits
def next_bigger(n):
    m = int(''.join(sorted(str(n))[::-1]))
    count = 1
    while m >= n + count:
        if sorted(str(n + count)) == sorted(str(n)):
            return n + count
        count += 1
    return -1

# Most frequently used words in a text
def top_3_words(text):
    d, word = {}, ''
    for i in text:
        if i.lower().isalpha() or i == "'":
            word += i.lower()
        else:
            if len(word) > 0:
                if any(i.isalpha() for i in word):
                    d[word] = d.get(word, 0) + 1
                word = ''
    if not d:
        return []
    d = [i[0] for i in sorted(d.items(), key=lambda x: x[1])[:-4:-1]]
    return d

# 141. Linked List Cycle
# Solution 1 - Hashtable. Speed - O(N) Memory - O(N)
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        s = set()
        while head:
            if head in s:
                return True
            s.add(head)
            head = head.next
        return False
# Solution 2 - Two pointers. Speed - O(N) Memory - O(1)
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        x, y = head, head
        while x and y and y.next:
            x, y = x.next, y.next.next
            if x == y:
                return True
        return False

# Recover a secret string from random triplets
def recoverSecret(triplets):
    unique_letters = set()
    letter_order = {}
    for triplet in triplets:
        for letter in triplet:
            unique_letters.add(letter)
    for triplet in triplets:
        for i in range(2):
            if triplet[i + 1] not in letter_order:
                letter_order[triplet[i + 1]] = set()
            letter_order[triplet[i + 1]].add(triplet[i])
    sorted_letters = []
    while unique_letters:
        for letter in unique_letters:
            if letter not in letter_order or not letter_order[letter]:
                sorted_letters.append(letter)
                unique_letters.remove(letter)
                for key in letter_order:
                    if letter in letter_order[key]:
                        letter_order[key].remove(letter)
                break
    return ''.join(sorted_letters)

# 1450. Number of Students Doing Homework at a Given Time
class Solution:
    def busyStudent(self, startTime: List[int], endTime: List[int], queryTime: int) -> int:
        count = 0
        for i in range(len(startTime)):
            if endTime[i] >= queryTime and startTime[i] <= queryTime:
                count += 1
        return count

# Spoonerize Me
def spoonerize(words):
    w = words.split()
    return w[1][0] + w[0][1:] + ' ' + w[0][0] + w[1][1:]

# 1629. Slowest Key
class Solution:
    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:
        d = {keysPressed[0]:releaseTimes[0]}
        for i in range(1, len(releaseTimes)):
            if not d.get(keysPressed[i], None):
                d[keysPressed[i]] = releaseTimes[i] - releaseTimes[i-1]
            else:
                d[keysPressed[i]] = max(d[keysPressed[i]], releaseTimes[i] - releaseTimes[i-1])
        top, key = 0, 'a'
        for k,v in d.items():
            if v >= top:
                if v == top:
                    key, top = max(key, k), v
                    continue
                top, key = v, k
        return key

# ATM
def solve(n):
    d = {500:0, 200:0, 100:0, 50:0, 20:0, 10:0}
    for i in d:
        while n >= i:
            d[i] = n // i
            n %= i
    if n > 0:
        return -1
    return sum(v for v in d.values())

# 500. Keyboard Row
class Solution:
    def findWords(self, words: List[str]) -> List[str]:
        d= {'q':1,'w':1,'e':1,'r':1,'t':1,'y':1,'u':1,'i':1,'o':1,'p':1,
        'a':2,'s':2,'d':2,'f':2,'g':2,'h':2,'j':2,'k':2,'l':2,
        'z':3,'x':3,'c':3,'v':3,'b':3,'n':3,'m':3}
        ans = list()
        for i in words:
            if len(i) == 1:
                ans.append(i)
                continue
            x, flag = d[i[0].lower()], True
            for let in range(1, len(i)):
                if d[i[let].lower()] != x:
                    flag = False
                    break
                x = d[i[let].lower()]
            if flag:
                ans.append(i)
        return ans

# Bubblesort Once
def bubblesort_once(l):
    l = l.copy()
    for i in range(1, len(l)):
        if l[i-1] > l[i]:
            l[i-1], l[i] = l[i], l[i-1]
    return l

# 118. Pascal's Triangle
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        row, triangle = [1], [[1]]
        for i in range(numRows-1):
            row = [x + y for x, y in zip([0] + row, row + [0])]
            triangle.append(row)
        return triangle

# Character Counter
def validate_word(word):
    d = {}
    for i in word.lower():
        d[i] = d.get(i, 0) + 1
    return all(x == y for x, y in zip(d.values(), list(d.values())[1:]))

# 868. Binary Gap
class Solution:
    def binaryGap(self, n: int) -> int:
        integer, flag, ans = bin(n)[2:], False, 0
        for ch in range(len(integer)):
            if integer[ch] == '1' and not flag:
                flag, ind = True, ch
                continue
            elif integer[ch] == '1' and flag:
                if ans < ch - ind:
                    ans = ch - ind
                ind = ch
        return ans

# Ninja vs Samurai: Strike
class Warrior:
    def __init__(self, name):
        self.name = name
        self.health = 100

    def strike(self, enemy, swings):
        # health cannot go below zero
        enemy.health = max([0, enemy.health - (swings * 10)])
        return enemy.health

# Sort Santa's Reindeer
# Happy Holidays fellow Code Warriors!
# Now, Dasher! Now, Dancer! Now, Prancer, and Vixen! On, Comet! On, Cupid! On, Donder and Blitzen! That's the order Santa wanted his reindeer...right? What do you mean he wants them in order by their last names!? Looks like we need your help Code Warrior!
#
# Sort Santa's Reindeer
# Write a function that accepts a sequence of Reindeer names, and returns a sequence with the Reindeer names sorted by their last names.
#
# Notes:
# It's guaranteed that each string is composed of two words
# In case of two identical last names, keep the original order
# Examples
# For this input:
#
# [
#   "Dasher Tonoyan",
#   "Dancer Moore",
#   "Prancer Chua",
#   "Vixen Hall",
#   "Comet Karavani",
#   "Cupid Foroutan",
#   "Donder Jonker",
#   "Blitzen Claus"
# ]
# You should return this output:
#
# [
#   "Prancer Chua",
#   "Blitzen Claus",
#   "Cupid Foroutan",
#   "Vixen Hall",
#   "Donder Jonker",
#   "Comet Karavani",
#   "Dancer Moore",
#   "Dasher Tonoyan",
# ]
# SORTINGARRAYSSTRINGSALGORITHMS
# Solution
def sort_reindeer(reindeer_names):
    return sorted(reindeer_names, key=lambda x: x.split()[1])

# 2839. Check if Strings Can be Made Equal With Operations I
# You are given two strings s1 and s2, both of length 4, consisting of lowercase English letters.
#
# You can apply the following operation on any of the two strings any number of times:
#
# Choose any two indices i and j such that j - i = 2, then swap the two characters at those indices in the string.
# Return true if you can make the strings s1 and s2 equal, and false otherwise.
#
#
#
# Example 1:
#
# Input: s1 = "abcd", s2 = "cdab"
# Output: true
# Explanation: We can do the following operations on s1:
# - Choose the indices i = 0, j = 2. The resulting string is s1 = "cbad".
# - Choose the indices i = 1, j = 3. The resulting string is s1 = "cdab" = s2.
# Example 2:
#
# Input: s1 = "abcd", s2 = "dacb"
# Output: false
# Explanation: It is not possible to make the two strings equal.
#
#
# Constraints:
#
# s1.length == s2.length == 4
# s1 and s2 consist only of lowercase English letters.
# Solution 1
class Solution:
    def canBeEqual(self, s1: str, s2: str) -> bool:
        if s1 == s2:
            return True
        if s1[2] + s1[1] + s1[0] + s1[3] == s2:
            return True
        if s1[2] + s1[3] + s1[0] + s1[1] == s2:
            return True
        return s1[0] + s1[3] + s1[2] + s1[1] == s2
# Solution 2
class Solution:
    def canBeEqual(self, s1: str, s2: str) -> bool:
        if s1 == s2:
            return True
        cop = s1[2] + s1[1] + s1[0] + s1[3]
        for i in range(2):
            if cop == s2:
                return True
            else:
                cop = cop[0] + cop[3] + cop[2] + cop[1]
        return s1[0] + s1[3] + s1[2] + s1[1] == s2

# Pandemia 🌡️
# ⚠️ The world is in quarantine! There is a new pandemia that struggles mankind. Each continent is isolated from each other but infected people have spread before the warning. ⚠️
#
# 🗺️ You would be given a map of the world in a type of string:
#
# string s = "01000000X000X011X0X"
#
# '0' : uninfected
#
# '1' : infected
#
# 'X' : ocean
# ⚫ The virus can't spread in the other side of the ocean.
#
# ⚫ If one person is infected every person in this continent gets infected too.
#
# ⚫ Your task is to find the percentage of human population that got infected in the end.
#
# ☑️ Return the percentage % of the total population that got infected.
#
# ❗❗ The first and the last continent are not connected!
#
# 💡 Example:
#
#  start: map1 = "01000000X000X011X0X"
#  end:   map1 = "11111111X000X111X0X"
#  total = 15
#  infected = 11
#  percentage = 100*11/15 = 73.33333333333333
# ➕ For maps without oceans "X" the whole world is connected.
#
# ➕ For maps without "0" and "1" return 0 as there is no population.
#
# STRINGSPUZZLES
# Solution
def infected(s):
    if '0' not in s and '1' not in s:
        return 0
    if 'X' not in s:
        return 100 if '1' in s else 0
    total, vir = 0, 0
    for i in s.split('X'):
        total += len(i)
        if '1' in i:
            vir += len(i)
    return 100 * vir / total

# 1282. Group the People Given the Group Size They Belong To
# There are n people that are split into some unknown number of groups. Each person is labeled with a unique ID from 0 to n - 1.
#
# You are given an integer array groupSizes, where groupSizes[i] is the size of the group that person i is in. For example, if groupSizes[1] = 3, then person 1 must be in a group of size 3.
#
# Return a list of groups such that each person i is in a group of size groupSizes[i].
#
# Each person should appear in exactly one group, and every person must be in a group. If there are multiple answers, return any of them. It is guaranteed that there will be at least one valid solution for the given input.
#
#
#
# Example 1:
#
# Input: groupSizes = [3,3,3,3,3,1,3]
# Output: [[5],[0,1,2],[3,4,6]]
# Explanation:
# The first group is [5]. The size is 1, and groupSizes[5] = 1.
# The second group is [0,1,2]. The size is 3, and groupSizes[0] = groupSizes[1] = groupSizes[2] = 3.
# The third group is [3,4,6]. The size is 3, and groupSizes[3] = groupSizes[4] = groupSizes[6] = 3.
# Other possible solutions are [[2,1,6],[5],[0,4,3]] and [[5],[0,6,2],[4,3,1]].
# Example 2:
#
# Input: groupSizes = [2,1,3,3,3,2]
# Output: [[1],[0,5],[2,3,4]]
#
#
# Constraints:
#
# groupSizes.length == n
# 1 <= n <= 500
# 1 <= groupSizes[i] <= n
class Solution:
    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:
        d, ans = {}, []
        for k,v in enumerate(groupSizes):
            d[v] = d.get(v, []) + [k]
        for k,v in d.items():
            for i in range(0, len(v), k):
                ans.append(v[i:i + k])
        return ans

# Simple string reversal
# In this Kata, we are going to reverse a string while maintaining the spaces (if any) in their original place.
#
# For example:
#
# solve("our code") = "edo cruo"
# -- Normal reversal without spaces is "edocruo".
# -- However, there is a space at index 3, so the string becomes "edo cruo"
#
# solve("your code rocks") = "skco redo cruoy".
# solve("codewars") = "srawedoc"
# More examples in the test cases. All input will be lower case letters and in some cases spaces.
#
# Good luck!
#
# Please also try:
#
# Simple time difference
#
# Simple remove duplicates
#
# ALGORITHMS
def solve(s):
    l = [k for k,v in enumerate(list(s)) if v == ' ']
    word = list(s.replace(' ', ''))[::-1]
    for i in l:
        word.insert(i, ' ')
    return ''.join(word)

# 1647. Minimum Deletions to Make Character Frequencies Unique
# A string s is called good if there are no two different characters in s that have the same frequency.
#
# Given a string s, return the minimum number of characters you need to delete to make s good.
#
# The frequency of a character in a string is the number of times it appears in the string. For example, in the string "aab", the frequency of 'a' is 2, while the frequency of 'b' is 1.
#
#
#
# Example 1:
#
# Input: s = "aab"
# Output: 0
# Explanation: s is already good.
# Example 2:
#
# Input: s = "aaabbbcc"
# Output: 2
# Explanation: You can delete two 'b's resulting in the good string "aaabcc".
# Another way it to delete one 'b' and one 'c' resulting in the good string "aaabbc".
# Example 3:
#
# Input: s = "ceabaacb"
# Output: 2
# Explanation: You can delete both 'c's resulting in the good string "eabaab".
# Note that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).
#
#
# Constraints:
#
# 1 <= s.length <= 105
# s contains only lowercase English letters.
class Solution:
    def minDeletions(self, s: str) -> int:
        d, se, de = {}, set(), 0
        for i in s:
            d[i] = d.get(i, 0) + 1
        for k,v in d.items():
            while v in se:
                v -= 1
                de += 1
            if v > 0:
                se.add(v)
        return de
    
# Candy problem
# Description
# "It's the end of trick-or-treating and we have a list/array representing how much candy each child in our group has made out with. We don't want the kids to start arguing, and using our parental intuition we know trouble is brewing as many of the children in the group have received different amounts of candy from each home.
#
# So we want each child to have the same amount of candies, only we can't exactly take any candy away from the kids, that would be even worse. Instead we decide to give each child extra candy until they all have the same amount.
#
# Task
# Your job is to find out how much candy each child has, and give them each additional candy until they too have as much as the child(ren) with the most candy. You also want to keep a total of how much candy you've handed out because reasons."
#
# Your job is to give all the kids the same amount of candies as the kid with the most candies and then return the total number candies that have been given out. If there are no kids, or only one, return -1.
#
# In the first case (look below) the most candies are given to second kid (i.e second place in list/array), 8. Because of that we will give the first kid 3 so he can have 8 and the third kid 2 and the fourth kid 4, so all kids will have 8 candies.So we end up handing out 3 + 2 + 4 = 9.
#
# candies ([5,8,6,4]) # return 9
#
# candies ([1,2,4,6]) # return 11
#
# candies ([1,6]) # return 5
#
# candies ([]) # return -1
#
# candies ([6]) # return -1 (because only one kid)
# LISTSALGORITHMS
def candies(s):
    if len(s) < 2:
        return -1
    return sum(max(s) - i for i in s)

# 2697. Lexicographically Smallest Palindrome
# You are given a string s consisting of lowercase English letters, and you are allowed to perform operations on it. In one operation, you can replace a character in s with another lowercase English letter.
#
# Your task is to make s a palindrome with the minimum number of operations possible. If there are multiple palindromes that can be made using the minimum number of operations, make the lexicographically smallest one.
#
# A string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b.
#
# Return the resulting palindrome string.
#
#
#
# Example 1:
#
# Input: s = "egcfe"
# Output: "efcfe"
# Explanation: The minimum number of operations to make "egcfe" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is "efcfe", by changing 'g'.
# Example 2:
#
# Input: s = "abcd"
# Output: "abba"
# Explanation: The minimum number of operations to make "abcd" a palindrome is 2, and the lexicographically smallest palindrome string we can get by modifying two characters is "abba".
# Example 3:
#
# Input: s = "seven"
# Output: "neven"
# Explanation: The minimum number of operations to make "seven" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is "neven".
#
#
# Constraints:
#
# 1 <= s.length <= 1000
# s consists of only lowercase English letters.
class Solution:
    def makeSmallestPalindrome(self, s: str) -> str:
        a, b, word = 0, len(s) - 1, list(s)
        while a < b:
            if s[a] != s[b]:
                if s[a] < s[b]:
                    word[b] = word[a]
                else:
                    word[a] = s[b]
            a += 1
            b -= 1
        return ''.join(word)
    
# The fusc function -- Part 1
# The fusc function is defined recursively as follows:
#
# 1. fusc(0) = 0
# 2. fusc(1) = 1
# 3. fusc(2 * n) = fusc(n)
# 4. fusc(2 * n + 1) = fusc(n) + fusc(n + 1)
# The 4 rules above are sufficient to determine the value of fusc for any non-negative input n. For example, let's say you want to compute fusc(10).
#
# fusc(10) = fusc(5), by rule 3.
# fusc(5) = fusc(2) + fusc(3), by rule 4.
# fusc(2) = fusc(1), by rule 3.
# fusc(1) = 1, by rule 2.
# fusc(3) = fusc(1) + fusc(2) by rule 4.
# fusc(1) and fusc(2) have already been computed are both equal to 1.
# Putting these results together fusc(10) = fusc(5) = fusc(2) + fusc(3) = 1 + 2 = 3
#
# Your job is to produce the code for the fusc function. In this kata, your function will be tested with small values of n, so you should not need to be concerned about stack overflow or timeouts.
#
# Hint: Use recursion.
#
# When done, move on to Part 2.
#
# ALGORITHMS
def fusc(n):
    if n == 0:
        return 0
    if n == 1:
        return 1
    if n % 2 == 0:
        return fusc(n / 2)
    return fusc(n // 2) + fusc(n // 2 + 1)

# 1656. Design an Ordered Stream
# There is a stream of n (idKey, value) pairs arriving in an arbitrary order, where idKey is an integer between 1 and n and value is a string. No two pairs have the same id.
#
# Design a stream that returns the values in increasing order of their IDs by returning a chunk (list) of values after each insertion. The concatenation of all the chunks should result in a list of the sorted values.
#
# Implement the OrderedStream class:
#
# OrderedStream(int n) Constructs the stream to take n values.
# String[] insert(int idKey, String value) Inserts the pair (idKey, value) into the stream, then returns the largest possible chunk of currently inserted values that appear next in the order.
#
#
# Example:
#
#
#
# Input
# ["OrderedStream", "insert", "insert", "insert", "insert", "insert"]
# [[5], [3, "ccccc"], [1, "aaaaa"], [2, "bbbbb"], [5, "eeeee"], [4, "ddddd"]]
# Output
# [null, [], ["aaaaa"], ["bbbbb", "ccccc"], [], ["ddddd", "eeeee"]]
#
# Explanation
# // Note that the values ordered by ID is ["aaaaa", "bbbbb", "ccccc", "ddddd", "eeeee"].
# OrderedStream os = new OrderedStream(5);
# os.insert(3, "ccccc"); // Inserts (3, "ccccc"), returns [].
# os.insert(1, "aaaaa"); // Inserts (1, "aaaaa"), returns ["aaaaa"].
# os.insert(2, "bbbbb"); // Inserts (2, "bbbbb"), returns ["bbbbb", "ccccc"].
# os.insert(5, "eeeee"); // Inserts (5, "eeeee"), returns [].
# os.insert(4, "ddddd"); // Inserts (4, "ddddd"), returns ["ddddd", "eeeee"].
# // Concatentating all the chunks returned:
# // [] + ["aaaaa"] + ["bbbbb", "ccccc"] + [] + ["ddddd", "eeeee"] = ["aaaaa", "bbbbb", "ccccc", "ddddd", "eeeee"]
# // The resulting order is the same as the order above.
#
#
# Constraints:
#
# 1 <= n <= 1000
# 1 <= id <= n
# value.length == 5
# value consists only of lowercase letters.
# Each call to insert will have a unique id.
# Exactly n calls will be made to insert.
# Solution 1
class OrderedStream:

    def __init__(self, n: int):
        self.ptr = 1
        self.l = [0] * n

    def insert(self, idKey: int, value: str) -> List[str]:
        self.l[idKey-1] = value
        if self.ptr == idKey:
            ans = []
            for i in self.l[idKey-1:]:
                if i == 0:
                    break
                else:
                    ans.append(i)
            if 0 in self.l:
                self.ptr = self.l.index(0) + 1
            return ans
        return []


# Your OrderedStream object will be instantiated and called as such:
# obj = OrderedStream(n)
# param_1 = obj.insert(idKey,value)

# Solution 2
class OrderedStream:

    def __init__(self, n: int):
        self.ptr = 0
        self.l = [None] * n

    def insert(self, idKey: int, value: str) -> List[str]:
        self.l[idKey-1] = value
        if self.ptr == idKey - 1:
            while self.ptr < len(self.l) and self.l[self.ptr]:
                self.ptr += 1
            return self.l[idKey-1:self.ptr]
        return []


# Your OrderedStream object will be instantiated and called as such:
# obj = OrderedStream(n)
# param_1 = obj.insert(idKey,value)

# Invisible cubes
# Imagine there's a big cube consisting of
# �
# 3
# n
# 3
#   small cubes. Calculate, how many small cubes are not visible from outside.
#
# For example, if we have a cube which has 4 cubes in a row, then the function should return 8, because there are 8 cubes inside our cube (2 cubes in each dimension)
#
# For a visual representation: --> https://imgur.com/a/AN8A5DJ
#
# PUZZLES
def not_visible_cubes(n):
    if n - 2 <= 0:
        return 0
    return (n - 2) ** 3

# 485. Max Consecutive Ones
# Given a binary array nums, return the maximum number of consecutive 1's in the array.
#
#
#
# Example 1:
#
# Input: nums = [1,1,0,1,1,1]
# Output: 3
# Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.
# Example 2:
#
# Input: nums = [1,0,1,1,0,1]
# Output: 2
#
#
# Constraints:
#
# 1 <= nums.length <= 105
# nums[i] is either 0 or 1.
class Solution:
    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
        top, count = 0, 0
        for i in nums:
            if i == 1:
                count += 1
            else:
                if count > top:
                    top = count
                count = 0
        if count > top:
            return count
        return top

# Number of Rectangles in a Grid
# Given a grid of size m x n, calculate the total number of rectangles contained in this rectangle. All integer sizes and positions are counted.
#
# Examples(Input1, Input2 --> Output):
#
# 3, 2 --> 18
# 4, 4 --> 100
# Here is how the 3x2 grid works (Thanks to GiacomoSorbi for the idea):
#
# 1 rectangle of size 3x2:
#
# [][][]
# [][][]
# 2 rectangles of size 3x1:
#
# [][][]
# 4 rectangles of size 2x1:
#
# [][]
# 2 rectangles of size 2x2
#
# [][]
# [][]
# 3 rectangles of size 1x2:
#
# []
# []
# 6 rectangles of size 1x1:
#
# []
# As you can see (1 + 2 + 4 + 2 + 3 + 6) = 18, and is the solution for the 3x2 grid.
#
# There is a very simple solution to this!
#
# GEOMETRYPUZZLES
def number_of_rectangles(m, n):
    count = 0
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            count += i * j
    return count

# 2154. Keep Multiplying Found Values by Two
# You are given an array of integers nums. You are also given an integer original which is the first number that needs to be searched for in nums.
#
# You then do the following steps:
#
# If original is found in nums, multiply it by two (i.e., set original = 2 * original).
# Otherwise, stop the process.
# Repeat this process with the new number as long as you keep finding the number.
# Return the final value of original.
#
#
#
# Example 1:
#
# Input: nums = [5,3,6,1,12], original = 3
# Output: 24
# Explanation:
# - 3 is found in nums. 3 is multiplied by 2 to obtain 6.
# - 6 is found in nums. 6 is multiplied by 2 to obtain 12.
# - 12 is found in nums. 12 is multiplied by 2 to obtain 24.
# - 24 is not found in nums. Thus, 24 is returned.
# Example 2:
#
# Input: nums = [2,7,9], original = 4
# Output: 4
# Explanation:
# - 4 is not found in nums. Thus, 4 is returned.
#
#
# Constraints:
#
# 1 <= nums.length <= 1000
# 1 <= nums[i], original <= 1000
class Solution:
    def findFinalValue(self, nums: List[int], original: int) -> int:
        nums = set(nums)
        while original in nums:
            original *= 2
        return original

# Four/Seven
# Four Seven
# Simple kata, simple rules: your function should accept the inputs 4 and 7. If 4 is entered, the function should return 7. If 7 is entered, the function should return 4. Anything else entered as input should return a false-y value such as False, 0, [], "". There's only one catch, your function cannot include if statements (or the eval function due to the fact that you can get around the if requirement using it).
#
# There are some very simple ways of answering this problem, but I encourage you to try and be as creative as possible.
#
# Good Luck!
#
# PUZZLES
def solution(n):
    while n == 4:
        return 7
    while n == 7:
        return 4
    return False

# 1128. Number of Equivalent Domino Pairs
# Given a list of dominoes, dominoes[i] = [a, b] is equivalent to dominoes[j] = [c, d] if and only if either (a == c and b == d), or (a == d and b == c) - that is, one domino can be rotated to be equal to another domino.
#
# Return the number of pairs (i, j) for which 0 <= i < j < dominoes.length, and dominoes[i] is equivalent to dominoes[j].
#
#
#
# Example 1:
#
# Input: dominoes = [[1,2],[2,1],[3,4],[5,6]]
# Output: 1
# Example 2:
#
# Input: dominoes = [[1,2],[1,2],[1,1],[1,2],[2,2]]
# Output: 3
#
#
# Constraints:
#
# 1 <= dominoes.length <= 4 * 104
# dominoes[i].length == 2
# 1 <= dominoes[i][j] <= 9
class Solution:
    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:
        d = {}
        count = 0
        for i in dominoes:
            t = (min(i), max(i))
            if t in d:
                count += d[t]
                d[t] += 1
            else:
                d[t] = 1
        return count

# Keypad horror
# Having two standards for a keypad layout is inconvenient!
# Computer keypad's layout:
# 7 8 9  \n
# 4 5 6  \n
# 1 2 3  \n
#   0 \n
#
# Cell phone keypad's layout:
# 1 2 3\n
# 4 5 6\n
# 7 8 9\n
#   0\n
#
# Solve the horror of unstandardized keypads by providing a function that converts computer input to a number as if it was typed on a phone.
#
# Example:
# "789" -> "123"
#
# Notes:
# You get a string with numbers only
#
# STRINGS
def computer_to_phone(numbers):
    return numbers.translate(str.maketrans('123456789', '789456123'))

# 1337. The K Weakest Rows in a Matrix
# You are given an m x n binary matrix mat of 1's (representing soldiers) and 0's (representing civilians). The soldiers are positioned in front of the civilians. That is, all the 1's will appear to the left of all the 0's in each row.
#
# A row i is weaker than a row j if one of the following is true:
#
# The number of soldiers in row i is less than the number of soldiers in row j.
# Both rows have the same number of soldiers and i < j.
# Return the indices of the k weakest rows in the matrix ordered from weakest to strongest.
#
#
#
# Example 1:
#
# Input: mat =
# [[1,1,0,0,0],
#  [1,1,1,1,0],
#  [1,0,0,0,0],
#  [1,1,0,0,0],
#  [1,1,1,1,1]],
# k = 3
# Output: [2,0,3]
# Explanation:
# The number of soldiers in each row is:
# - Row 0: 2
# - Row 1: 4
# - Row 2: 1
# - Row 3: 2
# - Row 4: 5
# The rows ordered from weakest to strongest are [2,0,3,1,4].
# Example 2:
#
# Input: mat =
# [[1,0,0,0],
#  [1,1,1,1],
#  [1,0,0,0],
#  [1,0,0,0]],
# k = 2
# Output: [0,2]
# Explanation:
# The number of soldiers in each row is:
# - Row 0: 1
# - Row 1: 4
# - Row 2: 1
# - Row 3: 1
# The rows ordered from weakest to strongest are [0,2,3,1].
#
#
# Constraints:
#
# m == mat.length
# n == mat[i].length
# 2 <= n, m <= 100
# 1 <= k <= m
# matrix[i][j] is either 0 or 1.
class Solution:
    def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:
        row_strength = [(sum(row), i) for i, row in enumerate(mat)]
        row_strength.sort(key=lambda x: (x[0], x[1]))
        return [row[1] for row in row_strength[:k]]

# Determine if the poker hand is flush
# Determine if the poker hand is flush, meaning if the five cards are of the same suit.
#
# Your function will be passed a list/array of 5 strings, each representing a poker card in the format "5H" (5 of hearts), meaning the value of the card followed by the initial of its suit (Hearts, Spades, Diamonds or Clubs). No jokers included.
#
# Your function should return true if the hand is a flush, false otherwise.
#
# The possible card values are 2, 3, 4, 5, 6, 7, 8, 9, 10, J, Q, K, A
#
# Examples
# ["AS", "3S", "9S", "KS", "4S"]  ==> true
#
# ["AD", "4S", "7H", "KS", "10S"] ==> false
# ARRAYSALGORITHMSLOGICSTRINGSGAMES
def is_flush(cards):
    return all(i[-1] == j[-1] for i,j in zip(cards, cards[1:]))

# 287. Find the Duplicate Number
# Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.
#
# There is only one repeated number in nums, return this repeated number.
#
# You must solve the problem without modifying the array nums and uses only constant extra space.
#
#
#
# Example 1:
#
# Input: nums = [1,3,4,2,2]
# Output: 2
# Example 2:
#
# Input: nums = [3,1,3,4,2]
# Output: 3
#
#
# Constraints:
#
# 1 <= n <= 105
# nums.length == n + 1
# 1 <= nums[i] <= n
# All the integers in nums appear only once except for precisely one integer which appears two or more times.
#
#
# Follow up:
#
# How can we prove that at least one duplicate number must exist in nums?
# Can you solve the problem in linear runtime complexity?
# Solution 1 - HashTable
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        d = {}
        for i in nums:
            if i in d:
                return i
            else:
                d[i] = 1

# Solution 2 - HashSet
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        s = set()
        for i in nums:
            if i in s:
                return i
            else:
                s.add(i)
# Solution 3 - Floyd Circle Algorithm
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        slow, fast = nums[0], nums[0]
        while True:
            slow = nums[slow]
            fast = nums[nums[fast]]
            if slow == fast:
                break
        slow = nums[0]
        while slow != fast:
            slow, fast = nums[slow], nums[fast]
        return slow

# 99 Bottles of Beer
# Instructions
# Complete the function that returns the lyrics for the song 99 Bottles of Beer as an array of strings: each line should be a separate element - see the example at the bottom.
#
# Note: in order to avoid hardcoded solutions, the size of your code is limited to 1000 characters
#
# Lyrics
# 99 bottles of beer on the wall, 99 bottles of beer.
# Take one down and pass it around, 98 bottles of beer on the wall.
#
# 98 bottles of beer on the wall, 98 bottles of beer.
# Take one down and pass it around, 97 bottles of beer on the wall.
#
# ...and so on...
#
# 3 bottles of beer on the wall, 3 bottles of beer.
# Take one down and pass it around, 2 bottles of beer on the wall.
#
# 2 bottles of beer on the wall, 2 bottles of beer.
# Take one down and pass it around, 1 bottle of beer on the wall.
#
# 1 bottle of beer on the wall, 1 bottle of beer.
# Take one down and pass it around, no more bottles of beer on the wall.
#
# No more bottles of beer on the wall, no more bottles of beer.
# Go to the store and buy some more, 99 bottles of beer on the wall.
#
# Example
# [ "99 bottles of beer on the wall, 99 bottles of beer.",
#   "Take one down and pass it around, 98 bottles of beer on the wall.",
#   "98 bottles of beer on the wall, 98 bottles of beer.",
#
#   ...and so on...
#
#   "3 bottles of beer on the wall, 3 bottles of beer.",
#   "Take one down and pass it around, 2 bottles of beer on the wall.",
#   "2 bottles of beer on the wall, 2 bottles of beer.",
#   "Take one down and pass it around, 1 bottle of beer on the wall.",
#   "1 bottle of beer on the wall, 1 bottle of beer.",
#   "Take one down and pass it around, no more bottles of beer on the wall.",
#   "No more bottles of beer on the wall, no more bottles of beer.",
#   "Go to the store and buy some more, 99 bottles of beer on the wall." ]
# STRINGSALGORITHMS
def sing():
    l = []
    for i in range(99, 1, -1):
        l.append(f'{i} bottles of beer on the wall, {i} bottles of beer.')
        l.append(f'Take one down and pass it around, {i-1} {"bottles" if i-1 != 1 else "bottle"} of beer on the wall.')
    l.append('1 bottle of beer on the wall, 1 bottle of beer.')
    l.append(f'Take one down and pass it around, no more bottles of beer on the wall.')
    return l + ['No more bottles of beer on the wall, no more bottles of beer.', 'Go to the store and buy some more, 99 bottles of beer on the wall.']

# 2383. Minimum Hours of Training to Win a Competition
# You are entering a competition, and are given two positive integers initialEnergy and initialExperience denoting your initial energy and initial experience respectively.
#
# You are also given two 0-indexed integer arrays energy and experience, both of length n.
#
# You will face n opponents in order. The energy and experience of the ith opponent is denoted by energy[i] and experience[i] respectively. When you face an opponent, you need to have both strictly greater experience and energy to defeat them and move to the next opponent if available.
#
# Defeating the ith opponent increases your experience by experience[i], but decreases your energy by energy[i].
#
# Before starting the competition, you can train for some number of hours. After each hour of training, you can either choose to increase your initial experience by one, or increase your initial energy by one.
#
# Return the minimum number of training hours required to defeat all n opponents.
#
#
#
# Example 1:
#
# Input: initialEnergy = 5, initialExperience = 3, energy = [1,4,3,2], experience = [2,6,3,1]
# Output: 8
# Explanation: You can increase your energy to 11 after 6 hours of training, and your experience to 5 after 2 hours of training.
# You face the opponents in the following order:
# - You have more energy and experience than the 0th opponent so you win.
#   Your energy becomes 11 - 1 = 10, and your experience becomes 5 + 2 = 7.
# - You have more energy and experience than the 1st opponent so you win.
#   Your energy becomes 10 - 4 = 6, and your experience becomes 7 + 6 = 13.
# - You have more energy and experience than the 2nd opponent so you win.
#   Your energy becomes 6 - 3 = 3, and your experience becomes 13 + 3 = 16.
# - You have more energy and experience than the 3rd opponent so you win.
#   Your energy becomes 3 - 2 = 1, and your experience becomes 16 + 1 = 17.
# You did a total of 6 + 2 = 8 hours of training before the competition, so we return 8.
# It can be proven that no smaller answer exists.
# Example 2:
#
# Input: initialEnergy = 2, initialExperience = 4, energy = [1], experience = [3]
# Output: 0
# Explanation: You do not need any additional energy or experience to win the competition, so we return 0.
#
#
# Constraints:
#
# n == energy.length == experience.length
# 1 <= n <= 100
# 1 <= initialEnergy, initialExperience, energy[i], experience[i] <= 100
class Solution:
    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:
        hours = 0
        for i in range(len(energy)):
            while initialEnergy <= energy[i] or initialExperience <= experience[i]:
                hours += 1
                if initialEnergy <= energy[i]:
                    initialEnergy += 1
                else:
                    initialExperience += 1
            initialEnergy -= energy[i]
            initialExperience += experience[i]
        return hours

# PatternCraft - Visitor
# The Visitor Design Pattern can be used, for example, to determine how an attack deals a different amount of damage to a unit in the StarCraft game.
#
# The pattern consists of delegating the responsibility to a different class.
#
# When a unit takes damage it can tell the visitor what to do with itself.
#
# Your Task
# Complete the code so that when a Tank attacks a Marine it takes 21 damage and when a Tank attacks a Marauder it takes 32 damage.
#
# The Marine's initial health should be set to 100 and the Marauder's health should be set to 125.
#
# You have 3 classes:
#
# Marine: has a health property and accept(visitor) method
# Marauder: has a health property and accept(visitor) method
# TankBullet: the visitor class. Has visitLight(unit) and visitArmored(unit) methods
# Ressources
# PatternCraft > Visitor
# SourceMaking > Visitor
# Wikipedia > Visitor
# PatternCraft series
# State Pattern
# Strategy Pattern
# Visitor Pattern
# Decorator Pattern
# Adapter Pattern
# Command Pattern
# The original PatternCraft series (by John Lindquist) is a collection of Youtube videos that explains some of the design patterns and how they are used (or could be) on StarCraft.
#
# DESIGN PATTERNSFUNDAMENTALS
class Marine:
    def __init__(self):
        self.health = 100

    def accept(self, visitor):
        self.health -= 21


class Marauder:
    def __init__(self):
        self.health = 125

    def accept(self, visitor):
        self.health -= 32


class TankBullet:
    def visit_light(self, unit):
        unit.health -= 21

    def visit_armored(self, unit):
        unit.health -= 32

# 4. Median of Two Sorted Arrays
# Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.
#
# The overall run time complexity should be O(log (m+n)).
#
#
#
# Example 1:
#
# Input: nums1 = [1,3], nums2 = [2]
# Output: 2.00000
# Explanation: merged array = [1,2,3] and median is 2.
# Example 2:
#
# Input: nums1 = [1,2], nums2 = [3,4]
# Output: 2.50000
# Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.
#
#
# Constraints:
#
# nums1.length == m
# nums2.length == n
# 0 <= m <= 1000
# 0 <= n <= 1000
# 1 <= m + n <= 2000
# -106 <= nums1[i], nums2[i] <= 106
# Solution 1 My solution - O((m + n)log(m + n)) / O(m + n)
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        l = nums1 + nums2
        l.sort()
        if len(l) % 2 == 0:
            return (l[len(l) // 2] + l[len(l) // 2 - 1]) / 2
        return l[len(l) // 2]
# Solution 2 Two pointers - O(m + n) / O(m + n)
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        l, x, y = [], 0, 0
        while x < len(nums1) and y < len(nums2):
            if nums1[x] > nums2[y]:
                l.append(nums2[y])
                y += 1
            else:
                l.append(nums1[x])
                x += 1
        while x < len(nums1):
            l.append(nums1[x])
            x += 1
        while y < len(nums2):
            l.append(nums2[y])
            y += 1
        if len(l) % 2 == 0:
            return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2
        return l[len(l) // 2]
# Solution 3 Binary Search - O(log(min(m, n))) / O(1)
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        if len(nums1) > len(nums2):
            nums1, nums2 = nums2, nums1
        m, n = len(nums1), len(nums2)
        low, high = 0, m
        while low <= high:
            middleX = (low + high) // 2
            middleY = (m + n + 1) // 2 - middleX
            maxX = float('-inf') if middleX == 0 else nums1[middleX - 1]
            maxY = float('-inf') if middleY == 0 else nums2[middleY - 1]
            minX = float('inf') if middleX == m else nums1[middleX]
            minY = float('inf') if middleY == n else nums2[middleY]
            if maxX <= minY and maxY <= minX:
                if (m + n) % 2 == 0:
                    return (max(maxX, maxY) + min(minX, minY)) / 2
                else:
                    return max(maxX, maxY)
            elif maxX > minY:
                high = middleX - 1
            else:
                low = middleX + 1

# MinMaxMin: Bounded Nums
# Given an unsorted array of integers, find the smallest number in the array, the largest number in the array, and the smallest number between the two array bounds that is not in the array.
#
# For instance, given the array [-1, 4, 5, -23, 24], the smallest number is -23, the largest number is 24, and the smallest number between the array bounds is -22. You may assume the input is well-formed.
#
# You solution should return an array [smallest, minimumAbsent, largest]
#
# The smallest integer should be the integer from the array with the lowest value.
#
# The largest integer should be the integer from the array with the highest value.
#
# The minimumAbsent is the smallest number between the largest and the smallest number that is not in the array.
#
# minMinMax([-1, 4, 5, -23, 24]); //[-23, -22, 24]
# minMinMax([1, 3, -3, -2, 8, -1]); //[-3, 0, 8]
# minMinMax([2, -4, 8, -5, 9, 7]); //[-5, -3,9]
# ARRAYS
def min_min_max(arr):
    mi, ma = min(arr), max(arr)
    mid = mi
    while True:
        mid += 1
        if mid not in arr:
            break
    return [mi, mid, ma]

# 392. Is Subsequence
# Solution
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        try:
            for i in s:
                t = t[t.index(i)+1:]
            return True
        except:
            return False

# Solution 2
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        if len(s) == 0:
            return True
        for i in range(len(t)):
            if s:
                if t[i] == s[0]:
                    s = s[1:]
        return len(s) == 0
# Solution 3 Two Pointers
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        x, y = 0, 0
        while x < len(s) and y < len(t):
            if t[y] == s[x]:
                x += 1
            y += 1
        return x == len(s)

# Least Larger
# Task
# Given an array of numbers and an index, return either the index of the smallest number that is larger than the element at the given index, or -1 if there is no such index ( or, where applicable, Nothing or a similarly empty value ).
#
# Notes
# Multiple correct answers may be possible. In this case, return any one of them.
# The given index will be inside the given array.
# The given array will, therefore, never be empty.
#
# Example
# least_larger( [4, 1, 3, 5, 6], 0 )  ->  3
# least_larger( [4, 1, 3, 5, 6], 4 )  -> -1
# ALGORITHMSARRAYS
def least_larger(a, i):
    top, ans = float('inf'), -1
    for x in range(len(a)):
        if a[x] > a[i]:
            if top > abs(a[i] - a[x]):
                top, ans = abs(a[i] - a[x]), x
    return ans

# 203. Remove Linked List Elements
# Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.
#
#
#
# Example 1:
#
#
# Input: head = [1,2,6,3,4,5,6], val = 6
# Output: [1,2,3,4,5]
# Example 2:
#
# Input: head = [], val = 1
# Output: []
# Example 3:
#
# Input: head = [7,7,7,7], val = 7
# Output: []
#
#
# Constraints:
#
# The number of nodes in the list is in the range [0, 104].
# 1 <= Node.val <= 50
# 0 <= val <= 50
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        dummy = ListNode(None, next=head)
        prev, cur = dummy, head
        while cur:
            if cur.val == val:
                prev.next = cur.next
            else:
                prev = cur
            cur = cur.next
        return dummy.next

# 1048. Longest String Chain
# You are given an array of words where each word consists of lowercase English letters.
#
# wordA is a predecessor of wordB if and only if we can insert exactly one letter anywhere in wordA without changing the order of the other characters to make it equal to wordB.
#
# For example, "abc" is a predecessor of "abac", while "cba" is not a predecessor of "bcad".
# A word chain is a sequence of words [word1, word2, ..., wordk] with k >= 1, where word1 is a predecessor of word2, word2 is a predecessor of word3, and so on. A single word is trivially a word chain with k == 1.
#
# Return the length of the longest possible word chain with words chosen from the given list of words.
#
#
#
# Example 1:
#
# Input: words = ["a","b","ba","bca","bda","bdca"]
# Output: 4
# Explanation: One of the longest word chains is ["a","ba","bda","bdca"].
# Example 2:
#
# Input: words = ["xbc","pcxbcf","xb","cxbc","pcxbc"]
# Output: 5
# Explanation: All the words can be put in a word chain ["xb", "xbc", "cxbc", "pcxbc", "pcxbcf"].
# Example 3:
#
# Input: words = ["abcd","dbqca"]
# Output: 1
# Explanation: The trivial word chain ["abcd"] is one of the longest word chains.
# ["abcd","dbqca"] is not a valid word chain because the ordering of the letters is changed.
#
#
# Constraints:
#
# 1 <= words.length <= 1000
# 1 <= words[i].length <= 16
# words[i] only consists of lowercase English letters.
class Solution:
    def longestStrChain(self, words: List[str]) -> int:
        d = {}
        words.sort(key=len)
        for i in words:
            d[i] = max(d.get(i[:j] + i[j + 1:], 0) + 1 for j in range(len(i)))
        return max(d.values())

# Delta Bits
# Complete the function to determine the number of bits required to convert integer A to integer B (where A and B >= 0)
#
# The upper limit for A and B is 216, int.MaxValue or similar.
#
# For example, you can change 31 to 14 by flipping the 4th and 0th bit:
#
#  31  0 0 0 1 1 1 1 1
#  14  0 0 0 0 1 1 1 0
# ---  ---------------
# bit  7 6 5 4 3 2 1 0
# Thus 31 and 14 should return 2.
#
# BITSBINARYALGORITHMS
def convert_bits(a, b):
    return bin(a ^ b).count('1')

# 566. Reshape the Matrix
# In MATLAB, there is a handy function called reshape which can reshape an m x n matrix into a new one with a different size r x c keeping its original data.
#
# You are given an m x n matrix mat and two integers r and c representing the number of rows and the number of columns of the wanted reshaped matrix.
#
# The reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were.
#
# If the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.
#
#
#
# Example 1:
#
#
# Input: mat = [[1,2],[3,4]], r = 1, c = 4
# Output: [[1,2,3,4]]
# Example 2:
#
#
# Input: mat = [[1,2],[3,4]], r = 2, c = 4
# Output: [[1,2],[3,4]]
#
#
# Constraints:
#
# m == mat.length
# n == mat[i].length
# 1 <= m, n <= 100
# -1000 <= mat[i][j] <= 1000
# 1 <= r, c <= 300
class Solution:
    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:
        if len(mat) * len(mat[0]) != r * c:
            return mat
        ans, x, y = [[0] * c for i in range(r)], 0, 0
        for i in range(len(mat)):
            for j in range(len(mat[0])):
                ans[x][y] = mat[i][j]
                y += 1
                if y == c:
                    x += 1
                    y = 0
        return ans

# Simple elevator
# There is a house with 4 levels. In that house there is an elevator. You can program this elevator to go up or down, depending on what button the user touches inside the elevator.
#
# Valid levels must be only these numbers: 0,1,2,3
#
# Valid buttons must be only these strings: '0','1','2','3'
#
# Possible return values are these numbers: -3,-2,-1,0,1,2,3
#
# If the elevator is on the ground floor(0th level) and the user touches button '2' the elevator must go 2 levels up, so our function must return 2.
#
# If the elevator is on the 3rd level and the user touches button '0' the elevator must go 3 levels down, so our function must return -3.
#
# If the elevator is on the 2nd level, and the user touches button '2' the elevator must remain on the same level, so we return 0.
#
# We cannot endanger the lives of our passengers, so if we get erronous inputs, our elevator must remain on the same level. So for example:
#
# goto(2,'4') must return 0, because there is no button '4' in the elevator.
# goto(4,'0') must return 0, because there is no level 4.
# goto(3,undefined) must return 0.
# goto(undefined,'2') must return 0.
# goto([],'2') must return 0 because the type of the input level is array instead of a number.
# goto(3,{}) must return 0 because the type of the input button is object instead of a string.
# STATE MACHINESFUNDAMENTALS
def goto(level, button):
    if level not in (0, 1, 2, 3) or button not in ['0', '1', '2', '3']:
        return 0
    if level > int(button):
        return int(button) - level
    return abs(level - int(button))

# 389. Find the Difference
# You are given two strings s and t.
#
# String t is generated by random shuffling string s and then add one more letter at a random position.
#
# Return the letter that was added to t.
#
#
#
# Example 1:
#
# Input: s = "abcd", t = "abcde"
# Output: "e"
# Explanation: 'e' is the letter that was added.
# Example 2:
#
# Input: s = "", t = "y"
# Output: "y"
#
#
# Constraints:
#
# 0 <= s.length <= 1000
# t.length == s.length + 1
# s and t consist of lowercase English letters.
class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        x, y = {}, {}
        for i in s:
            x[i] = x.get(i, 0) + 1
        for i in t:
            if i not in x:
                return i
            y[i] = y.get(i, 0) + 1
            if y[i] > x[i]:
                return i

# User class for Banking System
# A company is opening a bank, but the coder who is designing the user class made some errors. They need you to help them.
#
# You must include the following:
# Note: These are NOT steps to code the class
#
# A withdraw method
# Subtracts money from balance
# One parameter, money to withdraw
# Raise a ValueError if there isn't enough money to withdraw
# Return a string with name and balance(see examples)
# A check method
# Adds money to balance
# Two parameters, other user and money
# Other user will always be valid
# Raise a ValueError if other user doesn't have enough money
# Raise a ValueError if checking_account isn't true for other user
# Return a string with name and balance plus other name and other balance(see examples)
# An add_cash method
# Adds money to balance
# One parameter, money to add
# Return a string with name and balance(see examples)
# Additional Notes:
#
# Checking_account should be stored as a boolean
# No input numbers will be negative
# Output must end with a period
# Float numbers will not be used so, balance should be integer
# No currency will be used
# Examples:
#
# Jeff = User('Jeff', 70, True)
# Joe = User('Joe', 70, False)
#
# Jeff.withdraw(2) # Returns 'Jeff has 68.'
#
# Joe.check(Jeff, 50) # Returns 'Joe has 120 and Jeff has 18.'
#
# Jeff.check(Joe, 80) # Raises a ValueError
#
# Joe.checking_account = True # Enables checking for Joe
#
# Jeff.check(Joe, 80) # Returns 'Jeff has 98 and Joe has 40'
#
# Joe.check(Jeff, 100) # Raises a ValueError
#
# Jeff.add_cash(20.00) # Returns 'Jeff has 118.'
# Good Luck
# FUNDAMENTALSOBJECT-ORIENTED PROGRAMMING
class User(object):
    def __init__(self, name, balance, checking_account):
        self.name = name
        self.balance = balance
        self.checking_account = checking_account
    #Happy coding
    def withdraw(self, money):
        if money > self.balance:
            raise ValueError
        self.balance -= money
        return f'{self.name} has {self.balance}.'
    def check(self, user, money):
        if user.balance < money:
            raise ValueError
        if not user.checking_account:
            raise ValueError
        self.balance += money
        user.balance -= money
        return f'{self.name} has {self.balance} and {user.name} has {user.balance}.'
    def add_cash(self, money):
        self.balance += money
        return f'{self.name} has {self.balance}.'

# 520. Detect Capital
# We define the usage of capitals in a word to be right when one of the following cases holds:
#
# All letters in this word are capitals, like "USA".
# All letters in this word are not capitals, like "leetcode".
# Only the first letter in this word is capital, like "Google".
# Given a string word, return true if the usage of capitals in it is right.
#
#
#
# Example 1:
#
# Input: word = "USA"
# Output: true
# Example 2:
#
# Input: word = "FlaG"
# Output: false
#
#
# Constraints:
#
# 1 <= word.length <= 100
# word consists of lowercase and uppercase English letters.
# Solution 1
class Solution:
    def detectCapitalUse(self, word: str) -> bool:
        flag = False
        for i in word:
            if ord(i) > 90:
                flag = False
                break
            else:
                flag = True
        if flag:
            return True
        for i in range(1, len(word)):
            if ord(word[i]) < 97:
                return False
        return True
# Solution 2
class Solution:
    def detectCapitalUse(self, word: str) -> bool:
        if word == word.upper():
            return True
        if word == word.title():
            return True
        if word == word.lower():
            return True
        return False

# Recursive Replication
# You need to design a recursive function called replicate which will receive arguments times and number.
#
# The function should return an array containing repetitions of the number argument. For instance, replicate(3, 5) should return [5,5,5]. If the times argument is negative, return an empty array.
#
# As tempting as it may seem, do not use loops to solve this problem.
#
# RECURSIONALGORITHMS
@countcalls
def replicate(times, number, ans=[]):
    if times < 0:
        return []
    if times == 0:
        return ans
    return replicate(times - 1, number, ans + [number])

# Flick Switch
# Task
# Create a function that always returns True for every item in a given list. However, if an element is the word "flick", switch to always returning the opposite boolean value.
#
# Examples
# ["codewars", "flick", "code", "wars"] ➞ [True, False, False, False]
#
# ['flick', 'chocolate', 'adventure', 'sunshine'] ➞[False, False, False, False]
#
# ['bicycle', 'jarmony', 'flick', 'sheep', 'flick'] ➞ [True, True, False, False, True]
# Notes
# "flick" will always be given in lowercase.
# A list may contain multiple flicks.
# Switch the boolean value on the same element as the flick itself.
# FUNDAMENTALSLISTS
def flick_switch(lst):
    ans, flag = [], True
    for i in lst:
        if i == 'flick':
            flag = not flag
        ans.append(flag)
    return ans

# A Letter's Best Friend
# Task
# Given a string, return if a given letter always appears immediately before another given letter.
#
# Worked Example
# ("he headed to the store", "h", "e") ➞ True
#
# # All occurences of "h": ["he", "headed", "the"]
# # All occurences of "h" have an "e" after it.
# # Return True
#
# ('abcdee', 'e', 'e') ➞ False
#
# # For first "e" we can get "ee"
# # For second "e" we cannot have "ee"
# # Return False
# Examples
# ("i found an ounce with my hound", "o", "u") ➞ True
#
# ("we found your dynamite", "d", "y") ➞ False
# Notes
# All sentences will be given in lowercase.
# FUNDAMENTALSSTRINGS
# Solution
def best_friend(txt, a, b):
    for i in range(len(txt) - 1):
        if txt[i] == a:
            if txt[i + 1] != b:
                return False
    if txt[-1] == a:
        return False
    return True

# 880. Decoded String at Index
# You are given an encoded string s. To decode the string to a tape, the encoded string is read one character at a time and the following steps are taken:
#
# If the character read is a letter, that letter is written onto the tape.
# If the character read is a digit d, the entire current tape is repeatedly written d - 1 more times in total.
# Given an integer k, return the kth letter (1-indexed) in the decoded string.
#
#
#
# Example 1:
#
# Input: s = "leet2code3", k = 10
# Output: "o"
# Explanation: The decoded string is "leetleetcodeleetleetcodeleetleetcode".
# The 10th letter in the string is "o".
# Example 2:
#
# Input: s = "ha22", k = 5
# Output: "h"
# Explanation: The decoded string is "hahahaha".
# The 5th letter is "h".
# Example 3:
#
# Input: s = "a2345678999999999999999", k = 1
# Output: "a"
# Explanation: The decoded string is "a" repeated 8301530446056247680 times.
# The 1st letter is "a".
#
#
# Constraints:
#
# 2 <= s.length <= 100
# s consists of lowercase English letters and digits 2 through 9.
# s starts with a letter.
# 1 <= k <= 109
# It is guaranteed that k is less than or equal to the length of the decoded string.
# The decoded string is guaranteed to have less than 263 letters.
class Solution:
    def decodeAtIndex(self, s: str, k: int) -> str:
        n, i = 0, 0
        while n < k:
            if s[i].isalpha():
                n += 1
            else:
                n *= int(s[i])
            i += 1
        for i in range(i-1, -1, -1):
            if s[i].isdigit():
                n //= int(s[i])
                k %= n
            else:
                if k == 0 or k == n:
                    return s[i]
                n -= 1

# Simple Fun #10: Range Bit Counting
# Task
# You are given two numbers a and b where 0 ≤ a ≤ b. Imagine you construct an array of all the integers from a to b inclusive. You need to count the number of 1s in the binary representations of all the numbers in the array.
#
# Example
# For a = 2 and b = 7, the output should be 11
#
# Given a = 2 and b = 7 the array is: [2, 3, 4, 5, 6, 7]. Converting the numbers to binary, we get [10, 11, 100, 101, 110, 111], which contains 1 + 2 + 1 + 2 + 2 + 3 = 11 1s.
#
# Input/Output
# [input] integer a
# Constraints: 0 ≤ a ≤ b.
#
# [input] integer b
# Constraints: a ≤ b ≤ 100.
#
# [output] an integer
# BITSBINARYALGORITHMS
def range_bit_count(a, b):
    return sum(bin(i).count('1') for i in range(a, b + 1))

# 905. Sort Array By Parity
# Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers.
#
# Return any array that satisfies this condition.
#
#
#
# Example 1:
#
# Input: nums = [3,1,2,4]
# Output: [2,4,3,1]
# Explanation: The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.
# Example 2:
#
# Input: nums = [0]
# Output: [0]
#
#
# Constraints:
#
# 1 <= nums.length <= 5000
# 0 <= nums[i] <= 5000
class Solution:
    def sortArrayByParity(self, nums: List[int]) -> List[int]:
        x, y = 0, len(nums) - 1
        while x < y:
            while x < y and nums[x] & 0x1 == 0:
                x += 1
            while x < y and nums[y] & 0x1 != 0:
                y -= 1
            nums[x], nums[y] = nums[y], nums[x]
        return nums

# MOD 256 without the MOD operator
# MOD 256 without the MOD operator
# The MOD-operator % (aka mod/modulus/remainder):
#
# Returns the remainder of a division operation.
# The sign of the result is the same as the sign of the first operand.
# (Different behavior in Python!)
# The short unbelievable mad story for this kata:
# I wrote a program and needed the remainder of the division by 256. And then it happened: The "5"/"%"-Key did not react. It must be broken! So I needed a way to:
#
# Calculate the remainder of the division by 256 without the %-operator.
# Also here some examples:
#
# Input 254  -> Result 254
# Input 256  -> Result 0
# Input 258  -> Result 2
# Input -258 -> Result -2 (in Python: Result: 254!)
# It is always expected the behavior of the MOD-Operator of the language!
#
# The input number will always between -10000 and 10000.
#
# For some languages the %-operator will be blocked. If it is not blocked and you know how to block it, tell me and I will include it.
#
# For all, who say, this would be a duplicate: No, this is no duplicate! There are two katas, in that you have to write a general method for MOD without %. But this kata is only for MOD 256. And so you can create also other specialized solutions. ;-)
#
# Of course you can use the digit "5" in your solution. :-)
#
# I'm very curious for your solutions and the way you solve it. I found several interesting "funny" ways.
#
# Have fun coding it and please don't forget to vote and rank this kata! :-)
#
# I have also created other katas. Take a look if you enjoyed this kata!
#
# ALGORITHMSFUNDAMENTALSLOGICMATHEMATICSRESTRICTEDPUZZLES
def mod256_without_mod(number):
    if number < 0:
        while number < 0:
            number += 256
        return number
    while number >= 256:
        number -= 256
    return number

# 896. Monotonic Array
# An array is monotonic if it is either monotone increasing or monotone decreasing.
#
# An array nums is monotone increasing if for all i <= j, nums[i] <= nums[j]. An array nums is monotone decreasing if for all i <= j, nums[i] >= nums[j].
#
# Given an integer array nums, return true if the given array is monotonic, or false otherwise.
#
#
#
# Example 1:
#
# Input: nums = [1,2,2,3]
# Output: true
# Example 2:
#
# Input: nums = [6,5,4,4]
# Output: true
# Example 3:
#
# Input: nums = [1,3,2]
# Output: false
#
#
# Constraints:
#
# 1 <= nums.length <= 105
# -105 <= nums[i] <= 105
# Solution
class Solution:
    def isMonotonic(self, nums: List[int]) -> bool:
        return all(i <= j for i,j in zip(nums, nums[1:])) or all(i >= j for i,j in zip(nums, nums[1:]))

# Solution 2
class Solution:
    def isMonotonic(self, nums: List[int]) -> bool:
        cop: int = len(nums) - 1
        count: int = 0
        for i in range(len(nums) - 1):
            if nums[i] <= nums[i + 1]:
                count += 1
            else:
                break
        if cop == count:
            return True
        count: int = 0
        for i in range(len(nums) - 1):
            if nums[i] >= nums[i + 1]:
                count += 1
        return count == cop
# Solution 3
class Solution:
    def isMonotonic(self, nums: List[int]) -> bool:
        cop: list = nums.copy()
        if nums[0] <= nums[-1]:
            nums.sort()
        else:
            nums.sort(reverse=True)
        for i in range(len(nums)):
            if cop[i] != nums[i]:
                return False
        return True
# Solution 3
class Solution:
    def isMonotonic(self, nums: List[int]) -> bool:
        flag: int = 0
        for i in range(1, len(nums)):
            if nums[i] > nums[i - 1]:
                if flag == 0:
                    flag = 1
                elif flag == -1:
                    return False
            if nums[i] < nums[i - 1]:
                if flag == 0:
                    flag = -1
                elif flag == 1:
                    return False
        return True

# Thinkful - Object Drills: Quarks
# Background
# You're modelling the interaction between a large number of quarks and have decided to create a Quark class so you can generate your own quark objects.
#
# Quarks are fundamental particles and the only fundamental particle to experience all four fundamental forces.
#
# Your task
# Your Quark class should allow you to create quarks of any valid color ("red", "blue", and "green") and any valid flavor ('up', 'down', 'strange', 'charm', 'top', and 'bottom').
#
# Every quark has the same baryon_number (BaryonNumber in C#): 1/3.
#
# Every quark should have an .interact() (.Interact() in C#) method that allows any quark to interact with another quark via the strong force. When two quarks interact they exchange colors.
#
# Example
# >>> q1 = Quark("red", "up")
# >>> q1.color
# "red"
# >>> q1.flavor
# "up"
# >>> q2 = Quark("blue", "strange")
# >>> q2.color
# "blue"
# >>> q2.baryon_number
# 0.3333333333333333
# >>> q1.interact(q2)
# >>> q1.color
# "blue"
# >>> q2.color
# "red"
# FUNDAMENTALSOBJECT-ORIENTED PROGRAMMING
class Quark(object):
    def __init__(self, color, flavor):
        self.color = color
        self.flavor = flavor
        self.baryon_number = 0.3333333333333333
    def color(self):
        return self.color
    def flavor(self):
        return self.flavor
    def interact(self, user):
        self.color, user.color = user.color, self.color
        self.flavor, user.flavor = user.flavor, self.flavor

# 1025. Divisor Game
# Alice and Bob take turns playing a game, with Alice starting first.
#
# Initially, there is a number n on the chalkboard. On each player's turn, that player makes a move consisting of:
#
# Choosing any x with 0 < x < n and n % x == 0.
# Replacing the number n on the chalkboard with n - x.
# Also, if a player cannot make a move, they lose the game.
#
# Return true if and only if Alice wins the game, assuming both players play optimally.
#
#
#
# Example 1:
#
# Input: n = 2
# Output: true
# Explanation: Alice chooses 1, and Bob has no more moves.
# Example 2:
#
# Input: n = 3
# Output: false
# Explanation: Alice chooses 1, Bob chooses 1, and Alice has no more moves.
#
#
# Constraints:
#
# 1 <= n <= 1000
class Solution:
    def divisorGame(self, n: int) -> bool:
        return n % 2 == 0

# Email Address Obfuscator
# Many people choose to obfuscate their email address when displaying it on the Web. One common way of doing this is by substituting the @ and . characters for their literal equivalents in brackets.
#
# Example 1:
#
# user_name@example.com
# => user_name [at] example [dot] com
# Example 2:
#
# af5134@borchmore.edu
# => af5134 [at] borchmore [dot] edu
# Example 3:
#
# jim.kuback@ennerman-hatano.com
# => jim [dot] kuback [at] ennerman-hatano [dot] com
# Using the examples above as a guide, write a function that takes an email address string and returns the obfuscated version as a string that replaces the characters @ and . with [at] and [dot], respectively.
#
# Notes
#
# Input (email) will always be a string object. Your function should return a string.
# Change only the @ and . characters.
# Email addresses may contain more than one . character.
# Note the additional whitespace around the bracketed literals in the examples!
# STRINGSALGORITHMS
# Solution
def obfuscate(email):
    return email.replace('.', ' [dot] ').replace('@', ' [at] ')

# 557. Reverse Words in a String III
# Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.
#
#
#
# Example 1:
#
# Input: s = "Let's take LeetCode contest"
# Output: "s'teL ekat edoCteeL tsetnoc"
# Example 2:
#
# Input: s = "God Ding"
# Output: "doG gniD"
#
#
# Constraints:
#
# 1 <= s.length <= 5 * 104
# s contains printable ASCII characters.
# s does not contain any leading or trailing spaces.
# There is at least one word in s.
# All the words in s are separated by a single space.
# Solution
class Solution:
    def reverseWords(self, s: str) -> str:
        return ' '.join(i[::-1] for i in s.split())

# Solution 2 - Choising whitespace in split() method. Works faster
class Solution:
    def reverseWords(self, s: str) -> str:
        return ' '.join(i[::-1] for i in s.split(' '))

# Penultimate
# Find the second-to-last element of a list.
#
# The input list will always contain at least two elements.
#
# Example:
#
# penultimate([1,2,3,4])            # => 3
# penultimate("Python is dynamic") # => 'i'
# (courtesy of haskell.org)
#
# LISTSFUNDAMENTALS
def penultimate(a):
    return a[-2]

# 2038. Remove Colored Pieces if Both Neighbors are the Same Color
# There are n pieces arranged in a line, and each piece is colored either by 'A' or by 'B'. You are given a string colors of length n where colors[i] is the color of the ith piece.
#
# Alice and Bob are playing a game where they take alternating turns removing pieces from the line. In this game, Alice moves first.
#
# Alice is only allowed to remove a piece colored 'A' if both its neighbors are also colored 'A'. She is not allowed to remove pieces that are colored 'B'.
# Bob is only allowed to remove a piece colored 'B' if both its neighbors are also colored 'B'. He is not allowed to remove pieces that are colored 'A'.
# Alice and Bob cannot remove pieces from the edge of the line.
# If a player cannot make a move on their turn, that player loses and the other player wins.
# Assuming Alice and Bob play optimally, return true if Alice wins, or return false if Bob wins.
#
#
#
# Example 1:
#
# Input: colors = "AAABABB"
# Output: true
# Explanation:
# AAABABB -> AABABB
# Alice moves first.
# She removes the second 'A' from the left since that is the only 'A' whose neighbors are both 'A'.
#
# Now it's Bob's turn.
# Bob cannot make a move on his turn since there are no 'B's whose neighbors are both 'B'.
# Thus, Alice wins, so return true.
# Example 2:
#
# Input: colors = "AA"
# Output: false
# Explanation:
# Alice has her turn first.
# There are only two 'A's and both are on the edge of the line, so she cannot move on her turn.
# Thus, Bob wins, so return false.
# Example 3:
#
# Input: colors = "ABBBBBBBAAA"
# Output: false
# Explanation:
# ABBBBBBBAAA -> ABBBBBBBAA
# Alice moves first.
# Her only option is to remove the second to last 'A' from the right.
#
# ABBBBBBBAA -> ABBBBBBAA
# Next is Bob's turn.
# He has many options for which 'B' piece to remove. He can pick any.
#
# On Alice's second turn, she has no more pieces that she can remove.
# Thus, Bob wins, so return false.
#
#
# Constraints:
#
# 1 <= colors.length <= 105
# colors consists of only the letters 'A' and 'B'
# Solution 1 - My solution
class Solution:
    def winnerOfGame(self, colors: str) -> bool:
        if len(colors) <= 3:
            return colors == 'AAA'
        alice, bob = 0, 0
        ans = [colors[0]]
        for i in range(1, len(colors)):
            if colors[i] == ans[-1]:
                ans.append(colors[i])
            else:
                if len(ans) > 2:
                    if ans[-1] == 'A':
                        alice += len(ans) - 2
                    else:
                        bob += len(ans) - 2
                ans = [colors[i]]
        if len(ans) > 2:
            if ans[-1] == "A":
                alice += len(ans) - 2
            else:
                bob += len(ans) - 2
        return alice > bob
# Solution 2 - clearer solution
class Solution:
    def winnerOfGame(self, colors: str) -> bool:
        alice, bob = 0, 0
        x, y = 0, 0
        for i in colors:
            if i == "A":
                x += 1
                bob += max(y - 2, 0)
                y = 0
            else:
                y += 1
                alice += max(x - 2, 0)
                x = 0
        alice += max(x - 2, 0)
        bob += max(y - 2, 0)
        return alice > bob

# Binary Calculator
# In this kata you need to write a function that will receive two strings (n1 and n2), each representing an integer as a binary number. A third parameter will be provided (o) as a string representing one of the following operators: add, subtract, multiply.
#
# Your task is to write the calculate function so that it will perform the arithmetic and the result returned should be a string representing the binary result.
#
# Examples:
#
# 1 + 1 === 10
# 10 + 10 === 100
# Negative binary numbers are usually preceded by several 1's. For this kata, negative numbers can be represented with the negative symbol at the beginning of the string.
#
# Examples of negatives:
#
# 1 - 10 === -1
# 10 - 100 === -10
# BINARYALGORITHMS
def calculate(n1, n2, o):
    n1, n2 = int(f'0b{n1}', 2), int(f'0b{n2}', 2)
    op = {'add': n1 + n2, 'subtract': n1 - n2, 'multiply': n1 * n2}
    ans = bin(op[o])[2:]
    return ans if ans[0] != 'b' else '-' + ans[1:]

# Python's Dynamic Classes #1
# Timmy's quiet and calm work has been suddenly stopped by his project manager (let's call him boss) yelling:
#
# - Who named these classes?! Class MyClass? It's ridiculous! I want you to change it to UsefulClass!
#
# Tim sighed, he already knew it's gonna be a long day.
# Few hours later, boss came again:
# Much better - he said - but now I want to change that class name to SecondUsefulClass,
#
# and went off. Although Timmy had no idea why changing name is so important for his boss, he realized, that it's not the end, so he turned to you, his guru, to help him and asked you to prepare some function, which could change name of given class.
# Note: Proposed function should allow only names with alphanumeric chars (upper & lower letters plus ciphers), but starting only with upper case letter. In other case it should raise an exception.
# Disclaimer: there are obviously betters way to check class name than in example cases, but let's stick with that, that Timmy yet has to learn them.
#
#
#
# To easy? Check Python's Dynamic Classes #2 Kata and Python's Dynamic Classes #3 Kata.
#
# FUNDAMENTALSOBJECT-ORIENTED PROGRAMMING
def class_name_changer(cls, new_name):
    if (not new_name
            or new_name[0].islower()
            or new_name[0].isdigit()
            or not new_name.isalnum()):
        raise Exception

    cls.__name__ = new_name

# 1512. Number of Good Pairs
# Given an array of integers nums, return the number of good pairs.
#
# A pair (i, j) is called good if nums[i] == nums[j] and i < j.
#
#
#
# Example 1:
#
# Input: nums = [1,2,3,1,1,3]
# Output: 4
# Explanation: There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed.
# Example 2:
#
# Input: nums = [1,1,1,1]
# Output: 6
# Explanation: Each pair in the array are good.
# Example 3:
#
# Input: nums = [1,2,3]
# Output: 0
#
#
# Constraints:
#
# 1 <= nums.length <= 100
# 1 <= nums[i] <= 100
# Solution 1 - Simple choosing. Speed O(N**2) - Memory O(1)
class Solution:
    def numIdenticalPairs(self, nums: List[int]) -> int:
        count = 0
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                if nums[i] == nums[j]:
                    count += 1
        return count
# Solution 2 - Hash table. Speed O(N) - Memory O(N)
class Solution:
    def numIdenticalPairs(self, nums: List[int]) -> int:
        d, count = {}, 0
        for i in nums:
            if i in d:
                count += d[i]
                d[i] += 1
            else:
                d[i] = 1
        return count

# Cat and Mouse - 2D Version
# You will be given a string (map) featuring a cat "C" and a mouse "m". The rest of the string will be made up of dots (".") The cat can move the given number of moves up, down, left or right, but not diagonally.
#
# You need to find out if the cat can catch the mouse from it's current position and return "Caught!" or "Escaped!" respectively.
#
# Finally, if one of two animals are not present, return "boring without two animals".
#
# Examples
# moves = 5
#
# map =
# ..C......
# .........
# ....m....
#
# returns "Caught!" because the cat can catch the mouse in 4 moves
# moves = 5
#
# map =
# .C.......
# .........
# ......m..
#
# returns "Escaped!" because the cat cannot catch the mouse in  5 moves
# GRAPH THEORYALGORITHMS
def cat_mouse(map_, moves):
    if "C" not in map_ or "m" not in map_:
        return "boring without two animals"
    map_ =  map_.split('\n')
    for i in range(len(map_)):
        if "C" in map_[i]:
            cp, cr = map_[i].index("C") + 1, i + 1
        if "m" in map_[i]:
            mp, mr = map_[i].index("m") + 1, i + 1
    hunt_moves = abs(max(mr, cr) - min(mr, cr)) + abs(max(cp, mp) - min(cp, mp))
    return "Escaped!" if hunt_moves > moves else "Caught!"

# 706. Design HashMap
# Design a HashMap without using any built-in hash table libraries.
#
# Implement the MyHashMap class:
#
# MyHashMap() initializes the object with an empty map.
# void put(int key, int value) inserts a (key, value) pair into the HashMap. If the key already exists in the map, update the corresponding value.
# int get(int key) returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.
# void remove(key) removes the key and its corresponding value if the map contains the mapping for the key.
#
#
# Example 1:
#
# Input
# ["MyHashMap", "put", "put", "get", "get", "put", "get", "remove", "get"]
# [[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]
# Output
# [null, null, null, 1, -1, null, 1, null, -1]
#
# Explanation
# MyHashMap myHashMap = new MyHashMap();
# myHashMap.put(1, 1); // The map is now [[1,1]]
# myHashMap.put(2, 2); // The map is now [[1,1], [2,2]]
# myHashMap.get(1);    // return 1, The map is now [[1,1], [2,2]]
# myHashMap.get(3);    // return -1 (i.e., not found), The map is now [[1,1], [2,2]]
# myHashMap.put(2, 1); // The map is now [[1,1], [2,1]] (i.e., update the existing value)
# myHashMap.get(2);    // return 1, The map is now [[1,1], [2,1]]
# myHashMap.remove(2); // remove the mapping for 2, The map is now [[1,1]]
# myHashMap.get(2);    // return -1 (i.e., not found), The map is now [[1,1]]
#
#
# Constraints:
#
# 0 <= key, value <= 106
# At most 104 calls will be made to put, get, and remove.
# Solution 1 - My solution with two lists
class MyHashMap:

    def __init__(self):
        self.ke = []
        self.va = []

    def put(self, key: int, value: int) -> None:
        if key in self.ke:
            self.va[self.ke.index(key)] = value
        else:
            self.ke.append(key)
            self.va.append(value)

    def get(self, key: int) -> int:
        if key not in self.ke:
            return -1
        return self.va[self.ke.index(key)]

    def remove(self, key: int) -> None:
        if key in self.ke:
            x = self.ke.index(key)
            self.va.pop(x)
            self.ke.remove(key)

        # Your MyHashMap object will be instantiated and called as such:
# obj = MyHashMap()
# obj.put(key,value)
# param_2 = obj.get(key)
# obj.remove(key)

# Solution 2 - Making big lists with index/value
class MyHashMap:

    def __init__(self):
        self.ans = [None] * 1000001

    def put(self, key: int, value: int) -> None:
        self.ans[key] = value

    def get(self, key: int) -> int:
        x = self.ans[key]
        return x if x != None else -1

    def remove(self, key: int) -> None:
        self.ans[key] = None

# Your MyHashMap object will be instantiated and called as such:
# obj = MyHashMap()
# obj.put(key,value)
# param_2 = obj.get(key)
# obj.remove(key)

# International Morse Code Encryption
# Write a function that will encrypt a given sentence into International Morse Code, both the input and out puts will be strings.
#
# Characters should be separated by a single space. Words should be separated by a triple space.
#
# For example, "HELLO WORLD" should return -> ".... . .-.. .-.. --- .-- --- .-. .-.. -.."
#
# To find out more about Morse Code follow this link: https://en.wikipedia.org/wiki/Morse_code
#
# A preloaded object/dictionary/hash called CHAR_TO_MORSE will be provided to help convert characters to Morse Code.
#
# FUNDAMENTALS
from preloaded import CHAR_TO_MORSE
def encryption(string):
    return ' '.join(CHAR_TO_MORSE.get(i, i) for i in string)

# 229. Majority Element II
# Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.
#
#
#
# Example 1:
#
# Input: nums = [3,2,3]
# Output: [3]
# Example 2:
#
# Input: nums = [1]
# Output: [1]
# Example 3:
#
# Input: nums = [1,2]
# Output: [1,2]
#
#
# Constraints:
#
# 1 <= nums.length <= 5 * 104
# -109 <= nums[i] <= 109
#
#
# Follow up: Could you solve the problem in linear time and in O(1) space?
class Solution:
    def majorityElement(self, nums: List[int]) -> List[int]:
        d, x = {}, len(nums) // 3
        for i in nums:
            d[i] = d.get(i, 0) + 1
        count = []
        for i in d:
            if d[i] > x:
                count += [i]
        return count

# It is written in the stars
# Were you ever interested in the phenomena of astrology, star signs, tarot, voodoo ? (ok not voodoo that's too spooky)...
# Task:
# Your job for today is to finish the star_sign function by finding the astrological sign, given the birth details as a Date object.
# Start and end dates for zodiac signs vary on different resources so we will use this table to get consistent results:
#
# Aquarius ------ 21 January - 19 February
# Pisces --------- 20 February - 20 March
# Aries ---------- 21 March - 20 April
# Taurus -------- 21 April - 21 May
# Gemini -------- 22 May - 21 June
# Cancer -------- 22 June - 22 July
# Leo ------------- 23 July - 23 August
# Virgo ----------- 24 August - 23 September
# Libra ----------- 24 September - 23 October
# Scorpio -------- 24 October - 22 November
# Sagittarius ---- 23 November - 21 December
# Capricorn ----- 22 December - 20 January
#
# Test info: 100 random tests (dates range from January 1st 1940 until now)
# DATE TIMEPUZZLES
def star_sign(date):
    m, d = date.month, date.day
    signs = [(1,20,"Capricorn"), (2,19,"Aquarius"), (3,20,"Pisces"), (4,20,"Aries"),
            (5,21,"Taurus"), (6,21,"Gemini"), (7,22,"Cancer"), (8,23,"Leo"),
            (9,23,"Virgo"), (10,23,"Libra"), (11,22,"Scorpio"), (12,21,"Sagittarius"),
            (12,31,"Capricorn")]
    for i in range(len(signs)):
        if signs[i][0] == m:
            if d <= signs[i][1]:
                return signs[i][2]
            return signs[i + 1][2]

# 1380. Lucky Numbers in a Matrix
# Given an m x n matrix of distinct numbers, return all lucky numbers in the matrix in any order.
#
# A lucky number is an element of the matrix such that it is the minimum element in its row and maximum in its column.
#
#
#
# Example 1:
#
# Input: matrix = [[3,7,8],[9,11,13],[15,16,17]]
# Output: [15]
# Explanation: 15 is the only lucky number since it is the minimum in its row and the maximum in its column.
# Example 2:
#
# Input: matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]]
# Output: [12]
# Explanation: 12 is the only lucky number since it is the minimum in its row and the maximum in its column.
# Example 3:
#
# Input: matrix = [[7,8],[1,2]]
# Output: [7]
# Explanation: 7 is the only lucky number since it is the minimum in its row and the maximum in its column.
#
#
# Constraints:
#
# m == mat.length
# n == mat[i].length
# 1 <= n, m <= 50
# 1 <= matrix[i][j] <= 105.
# All elements in the matrix are distinct.
# Solution
class Solution:
    def luckyNumbers (self, matrix: List[List[int]]) -> List[int]:
        ans = []
        for i in range(len(matrix[0])):
            top, cop = 0, 0
            for j in range(len(matrix)):
                if matrix[j][i] > cop:
                    cop = matrix[j][i]
                    if matrix[j][i] == min(matrix[j]):
                        top = matrix[j][i]
                    else:
                        top = 0
            if top > 0:
                ans.append(top)
        return ans

# Product of the main diagonal of a square matrix.
# Given a list of rows of a square matrix, find the product of the main diagonal.
#
# Examples:
#
# main_diagonal_product([[1,0],[0,1]]) => 1
#
# main_diagonal_product([[1,2,3],[4,5,6],[7,8,9]]) => 45
# http://en.wikipedia.org/wiki/Main_diagonal
#
# MATRIXLINEAR ALGEBRAALGORITHMS
import math
def main_diagonal_product(mat):
    return math.prod(mat[i][i] for i in range(len(mat)))

# 1636. Sort Array by Increasing Frequency
# # Given an array of integers nums, sort the array in increasing order based on the frequency of the values. If multiple values have the same frequency, sort them in decreasing order.
# #
# # Return the sorted array.
# #
# #
# #
# # Example 1:
# #
# # Input: nums = [1,1,2,2,2,3]
# # Output: [3,1,1,2,2,2]
# # Explanation: '3' has a frequency of 1, '1' has a frequency of 2, and '2' has a frequency of 3.
# # Example 2:
# #
# # Input: nums = [2,3,1,3,2]
# # Output: [1,3,3,2,2]
# # Explanation: '2' and '3' both have a frequency of 2, so they are sorted in decreasing order.
# # Example 3:
# #
# # Input: nums = [-1,1,-6,4,5,-6,1,4,1]
# # Output: [5,-1,4,4,-6,-6,1,1,1]
# #
# #
# # Constraints:
# #
# # 1 <= nums.length <= 100
# # -100 <= nums[i] <= 100
# Solution 1, My solution - HashTable
class Solution:
    def frequencySort(self, nums: List[int]) -> List[int]:
        d, ans = {}, []
        for i in nums:
            d[i] = d.get(i, 0) + 1
        while d:
            top, rep = 0, float('inf')
            for i in d:
                if d[i] < rep:
                    top, rep = i, d[i]
                elif d[i] == rep:
                    x = max(top, i)
                    top, rep = x, d[x]
            del d[top]
            ans += [top] * rep
        return ans
# Solution 2 - HashTable Optimized
class Solution:
    def frequencySort(self, nums: List[int]) -> List[int]:
        d = {}
        for i in nums:
            d[i] = d.get(i, 0) + 1
        return sorted(nums, key=lambda x: (d[x], -x))

# Excel sheet column numbers
# Write a function
#
# titleToNumber(title) or title_to_number(title) or titleToNb title ...
#
# (depending on the language)
#
# that given a column title as it appears in an Excel sheet, returns its corresponding column number. All column titles will be uppercase.
#
# Examples:
#
# titleTonumber('A') === 1
# titleTonumber('Z') === 26
# titleTonumber('AA') === 27
# Note for Clojure:
# Don't use Java Math/pow (even with bigint) because there is a loss of precision
# when the length of "title" is growing.
# Write your own function "exp [x n]".
# FUNDAMENTALSALGORITHMS
def title_to_number(title):
    count = 0
    for i in range(len(title)):
        x = ord(title[i]) - 64
        count += x * max(26 ** (len(title) - i - 1), 1)
    return count

# 1979. Find Greatest Common Divisor of Array
# Given an integer array nums, return the greatest common divisor of the smallest number and largest number in nums.
#
# The greatest common divisor of two numbers is the largest positive integer that evenly divides both numbers.
#
#
#
# Example 1:
#
# Input: nums = [2,5,6,9,10]
# Output: 2
# Explanation:
# The smallest number in nums is 2.
# The largest number in nums is 10.
# The greatest common divisor of 2 and 10 is 2.
# Example 2:
#
# Input: nums = [7,5,6,8,3]
# Output: 1
# Explanation:
# The smallest number in nums is 3.
# The largest number in nums is 8.
# The greatest common divisor of 3 and 8 is 1.
# Example 3:
#
# Input: nums = [3,3]
# Output: 3
# Explanation:
# The smallest number in nums is 3.
# The largest number in nums is 3.
# The greatest common divisor of 3 and 3 is 3.
#
#
# Constraints:
#
# 2 <= nums.length <= 1000
# 1 <= nums[i] <= 1000
# Solution - Using math formula: a*b // lcd(a,b) Speed O(N) Memory O(1)
class Solution:
    def findGCD(self, nums: List[int]) -> int:
        mi, ma = float('inf'), 0
        for i in nums:
            if i > ma:
                ma = i
            if i < mi:
                mi = i
        lcd = 1
        while True:
            if ma * lcd % mi == 0:
                lcd *= ma
                break
            lcd += 1
        return ma * mi // lcd

# Survive the attack
# Given two Arrays in which values are the power of each soldier, return true if you survive the attack or false if you perish.
#
# CONDITIONS
#
# Each soldier attacks the opposing soldier in the same index of the array. The survivor is the number with the highest value.
# If the value is the same they both perish
# If one of the values is empty(different array lengths) the non-empty value soldier survives.
# To survive the defending side must have more survivors than the attacking side.
# In case there are the same number of survivors in both sides, the winner is the team with the highest initial attack power. If the total attack power of both sides is the same return true.
# The initial attack power is the sum of all the values in each array.
# EXAMPLES
#
# attackers=[ 1, 3, 5, 7 ]   defenders=[ 2, 4, 6, 8 ]
# //0 survivors                4 survivors
# //return true
#
#
# attackers=[ 1, 3, 5, 7 ]   defenders=[ 2, 4 ]
# //2 survivors  (16 damage)   2 survivors (6 damage)
# //return false
#
# attackers=[ 1, 3, 5, 7 ]   defenders=[ 2, 4, 0, 8 ]
# //1 survivors                3 survivors
# //return true
#
# ARRAYS
def is_defended(attackers, defenders):
    init1, init2 = sum(attackers), sum(defenders)
    for i in range(min(len(attackers), len(defenders))):
        if attackers[i] > defenders[i]:
            defenders[i] = 0
        elif attackers[i] < defenders[i]:
            attackers[i] = 0
        else:
            attackers[i], defenders[i] = 0, 0
    x, y = sum(1 for i in attackers if i > 0), sum(1 for i in defenders if i > 0)
    if x == y:
        return init1 <= init2
    return x < y

# 34. Find First and Last Position of Element in Sorted Array
# Given an array of integers nums sorted in non-decreasing order,
# find the starting and ending position of a given target value.
#
# If target is not found in the array, return [-1, -1].
#
# You must write an algorithm with O(log n) runtime complexity.
#
#
#
# Example 1:
#
# Input: nums = [5,7,7,8,8,10], target = 8
# Output: [3,4]
# Example 2:
#
# Input: nums = [5,7,7,8,8,10], target = 6
# Output: [-1,-1]
# Example 3:
#
# Input: nums = [], target = 0
# Output: [-1,-1]
#
#
# Constraints:
#
# 0 <= nums.length <= 105
# -109 <= nums[i] <= 109
# nums is a non-decreasing array.
# -109 <= target <= 109
# Solution 2 - My solution with daily task
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        if len(nums) == 0:
            return [-1, -1]
        ans, l, r = [-1, -1], 0, len(nums) - 1
        while l <= r:
            m = (l + r) // 2
            if nums[m] == target:
                ans[0] = m
                r = m - 1
            elif nums[m] < target:
                l = m + 1
            else:
                r = m - 1
        if ans[0] == -1:
            return ans
        l, r = 0, len(nums) - 1
        while l <= r:
            m = (l + r) // 2
            if nums[m] == target:
                ans[1] = m
                l = m + 1
            elif nums[m] < target:
                l = m + 1
            else:
                r = m - 1
        return ans

# Weight of its Contents
# Welcome to the Mathematics gameshow. I'm your host, Apex Rhombus, and it's time for the lightning round!
#
# Today we'll talk about a hypothetical bottle. This entire bottle weighs 120 grams. Its contents weigh twice as much as the bottle itself. What, may I ask, do the contents weigh?
#
# ...Did you guess 80 grams? Correct! Now that you've got that idea, I'm gonna ask you that question in 10 different ways so you'd better get ready!
#
# Let's make a contentWeight function that takes in two parameters: bottleWeight and scale. This function will return the weight of the contents inside the bottle.
#
# bottleWeight will be an integer representing the weight of the entire bottle (contents included).
#
# scale will be a string that you will need to parse. It will tell you how the content weight compares to the weight of the bottle by itself. 2 times larger, 6 times larger, and 15 times smaller would all be valid strings (smaller and larger are the only comparison words).
#
# The first test case has been filled out for you. Good luck!
#
# ALGORITHMSMATHEMATICS
def content_weight(bottle_weight, scale):
    x = bottle_weight / (int(scale.split()[0]) + 1)
    if scale.endswith('larger'):
        return x * int(scale.split()[0])
    return bottle_weight - x * int(scale.split()[0])

# 2068. Check Whether Two Strings are Almost Equivalent
# Two strings word1 and word2 are considered almost equivalent if the differences between the frequencies of each letter from 'a' to 'z' between word1 and word2 is at most 3.
#
# Given two strings word1 and word2, each of length n, return true if word1 and word2 are almost equivalent, or false otherwise.
#
# The frequency of a letter x is the number of times it occurs in the string.
#
#
#
# Example 1:
#
# Input: word1 = "aaaa", word2 = "bccb"
# Output: false
# Explanation: There are 4 'a's in "aaaa" but 0 'a's in "bccb".
# The difference is 4, which is more than the allowed 3.
# Example 2:
#
# Input: word1 = "abcdeef", word2 = "abaaacc"
# Output: true
# Explanation: The differences between the frequencies of each letter in word1 and word2 are at most 3:
# - 'a' appears 1 time in word1 and 4 times in word2. The difference is 3.
# - 'b' appears 1 time in word1 and 1 time in word2. The difference is 0.
# - 'c' appears 1 time in word1 and 2 times in word2. The difference is 1.
# - 'd' appears 1 time in word1 and 0 times in word2. The difference is 1.
# - 'e' appears 2 times in word1 and 0 times in word2. The difference is 2.
# - 'f' appears 1 time in word1 and 0 times in word2. The difference is 1.
# Example 3:
#
# Input: word1 = "cccddabba", word2 = "babababab"
# Output: true
# Explanation: The differences between the frequencies of each letter in word1 and word2 are at most 3:
# - 'a' appears 2 times in word1 and 4 times in word2. The difference is 2.
# - 'b' appears 2 times in word1 and 5 times in word2. The difference is 3.
# - 'c' appears 3 times in word1 and 0 times in word2. The difference is 3.
# - 'd' appears 2 times in word1 and 0 times in word2. The difference is 2.
#
#
# Constraints:
#
# n == word1.length == word2.length
# 1 <= n <= 100
# word1 and word2 consist only of lowercase English letters.
class Solution:
    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:
        d1, d2 = {}, {}
        for i in range(len(word1)):
            d1[word1[i]] = d1.get(word1[i], 0) + 1
            d2[word2[i]] = d2.get(word2[i], 0) + 1
        for i in d1:
            if d1[i] > 3:
                if i not in d2:
                    return False
                if abs(d2[i] - d1[i]) > 3:
                    return False
        for i in d2:
            if d2[i] > 3:
                if i not in d1:
                    return False
                if abs(d2[i] - d1[i]) > 3:
                    return False
        return True

# Thinkful - String Drills: Areacode extractor
# Welcome to the Mathematics gameshow. I'm your host, Apex Rhombus, and it's time for the lightning round!
#
# Today we'll talk about a hypothetical bottle. This entire bottle weighs 120 grams. Its contents weigh twice as much as the bottle itself. What, may I ask, do the contents weigh?
#
# ...Did you guess 80 grams? Correct! Now that you've got that idea, I'm gonna ask you that question in 10 different ways so you'd better get ready!
#
# Let's make a contentWeight function that takes in two parameters: bottleWeight and scale. This function will return the weight of the contents inside the bottle.
#
# bottleWeight will be an integer representing the weight of the entire bottle (contents included).
#
# scale will be a string that you will need to parse. It will tell you how the content weight compares to the weight of the bottle by itself. 2 times larger, 6 times larger, and 15 times smaller would all be valid strings (smaller and larger are the only comparison words).
#
# The first test case has been filled out for you. Good luck!
#
# ALGORITHMSMATHEMATICS
# Solution
def content_weight(bottle_weight, scale):
    x = bottle_weight / (int(scale.split()[0]) + 1)
    if scale.endswith('larger'):
        return x * int(scale.split()[0])
    return bottle_weight - x * int(scale.split()[0])

# 867. Transpose Matrix
# Given a 2D integer array matrix, return the transpose of matrix.
#
# The transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix's row and column indices.
#
#
#
#
#
# Example 1:
#
# Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
# Output: [[1,4,7],[2,5,8],[3,6,9]]
# Example 2:
#
# Input: matrix = [[1,2,3],[4,5,6]]
# Output: [[1,4],[2,5],[3,6]]
#
#
# Constraints:
#
# m == matrix.length
# n == matrix[i].length
# 1 <= m, n <= 1000
# 1 <= m * n <= 105
# -109 <= matrix[i][j] <= 109
class Solution:
    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:
        ans, l = [], []
        for i in range(len(matrix[0])):
            for j in range(len(matrix)):
                l.append(matrix[j][i])
                if len(l) == len(matrix):
                    ans.append(l)
                    l = []
        return ans
    
# A Gift Well Spent
# Note: This kata has been inspired by GCJ 2010's "Store credit", where one also has to parse the actual input. If you solved this kata, try that one too. Note that GCJ's version always has a solution, whereas this kata might not.
#
# Story
# You got a gift card for your local store. It has some credit you can use to buy things, but it may be used only for up to two items, and any credit you don't use is lost. You want something for a friend and yourself. Therefore, you want to buy two items which add up the entire gift card value.
#
# Task
# You will get the value of the gift card c and a finite list of item values. You should return a pair of indices that correspond to values that add up to c:
#
# buy(2,[1,1])       = [0,1]
# buy(3,[1,1])       = None
# buy(5,[5,2,3,4,5]) = [1,2]
# The indices start at 0 (1 in COBOL). The first index should always be smaller than the second index. If there are multiple solutions, return the minimum (lexicographically):
#
# buy(5,[1,2,3,4,5]) = [0,3] # the values at [1,2] also adds up to five, but [0,3] < [1,2]
# LISTSALGORITHMS
def buy(x,arr):
    for i in range(len(arr)):
        for j in range(i + 1, len(arr)):
            if arr[i] + arr[j] == x:
                return [i, j]
    return

# 1935. Maximum Number of Words You Can Type
# There is a malfunctioning keyboard where some letter keys do not work. All other keys on the keyboard work properly.
#
# Given a string text of words separated by a single space (no leading or trailing spaces) and a string brokenLetters of all distinct letter keys that are broken, return the number of words in text you can fully type using this keyboard.
#
#
#
# Example 1:
#
# Input: text = "hello world", brokenLetters = "ad"
# Output: 1
# Explanation: We cannot type "world" because the 'd' key is broken.
# Example 2:
#
# Input: text = "leet code", brokenLetters = "lt"
# Output: 1
# Explanation: We cannot type "leet" because the 'l' and 't' keys are broken.
# Example 3:
#
# Input: text = "leet code", brokenLetters = "e"
# Output: 0
# Explanation: We cannot type either word because the 'e' key is broken.
#
#
# Constraints:
#
# 1 <= text.length <= 104
# 0 <= brokenLetters.length <= 26
# text consists of words separated by a single space without any leading or trailing spaces.
# Each word only consists of lowercase English letters.
# brokenLetters consists of distinct lowercase English letters.
class Solution:
    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:
        count = 0
        for i in text.split():
            top = 0
            for j in i:
                if j in brokenLetters:
                    top += 1
                    break
            if top > 0:
                count += 1
        return len(text.split()) - count
    
# Hands Up
# Imagine that you have an array of 3 integers each representing different person. Each number can be 0, 1, or 2 which represents the number of hands that person is holding up.
#
# Now imagine there is a sequence which follows these rules:
#
# None of the people have their arms raised at first
# Firstly, a person raises 1 hand; then they raise the second hand; after that they put both hands down - these steps form a cycle
# Person #1 performs these steps all the time, person #2 advances only after person #1 puts their hands down, and person #3 advances only after person #2 puts their hands down
# The first 10 steps of the sequence represented as a table are:
#
# Step   P1   P2   P3
# --------------------
#  0     0    0    0
#  1     1    0    0
#  2     2    0    0
#  3     0    1    0
#  4     1    1    0
#  5     2    1    0
#  6     0    2    0
#  7     1    2    0
#  8     2    2    0
#  9     0    0    1
# Given a number, return an array, containing 3 integers, each representing the number of hands raised by each person at that step, starting from 0.
#
# FUNDAMENTALSALGORITHMS
def get_positions(n):
    ans = [0, 0, 0]
    for i in range(n % 27):
        if ans[0] != 3:
            ans[0] += 1
            if ans[0] == 3:
                ans[0] = 0
                ans[1] += 1
                if ans[1] == 3:
                    ans[1] = 0
                    ans[2] += 1
                    if ans[2] == 3:
                        ans = [0, 0, 0]
    a, b, c = ans
    return a, b, c

# 746. Min Cost Climbing Stairs
# You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.
#
# You can either start from the step with index 0, or the step with index 1.
#
# Return the minimum cost to reach the top of the floor.
#
#
#
# Example 1:
#
# Input: cost = [10,15,20]
# Output: 15
# Explanation: You will start at index 1.
# - Pay 15 and climb two steps to reach the top.
# The total cost is 15.
# Example 2:
#
# Input: cost = [1,100,1,1,1,100,1,1,100,1]
# Output: 6
# Explanation: You will start at index 0.
# - Pay 1 and climb two steps to reach index 2.
# - Pay 1 and climb two steps to reach index 4.
# - Pay 1 and climb two steps to reach index 6.
# - Pay 1 and climb one step to reach index 7.
# - Pay 1 and climb two steps to reach index 9.
# - Pay 1 and climb one step to reach the top.
# The total cost is 6.
#
#
# Constraints:
#
# 2 <= cost.length <= 1000
# 0 <= cost[i] <= 999
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        x, y = 0, 0
        for i in range(2, len(cost) + 1):
            z = min(x + cost[i-1], y + cost[i-2])
            x, y = z, x
        return x

# draw me a chessboard
# A grid is a perfect starting point for many games (Chess, battleships, Candy Crush!).
#
# Making a digital chessboard I think is an interesting way of visualising how loops can work together.
#
# Your task is to write a function that takes two integers rows and columns and returns a chessboard pattern as a two dimensional array.
#
# So chessBoard(6,4) should return an array like this:
#
# [
#     ["O","X","O","X"],
#     ["X","O","X","O"],
#     ["O","X","O","X"],
#     ["X","O","X","O"],
#     ["O","X","O","X"],
#     ["X","O","X","O"]
# ]
# And chessBoard(3,7) should return this:
#
# [
#     ["O","X","O","X","O","X","O"],
#     ["X","O","X","O","X","O","X"],
#     ["O","X","O","X","O","X","O"]
# ]
# The white spaces should be represented by an: 'O'
#
# and the black an: 'X'
#
# The first row should always start with a white space 'O'
#
# PUZZLESFUNDAMENTALSASCII ARTALGORITHMS
def chess_board(rows, columns):
    ans, d = [], {'O': 'X', 'X': 'O'}
    for i in range(rows):
        top = ['O' if i % 2 == 0 else 'X']
        for j in range(1, columns):
            top.append(d[top[-1]])
        ans.append(top)
    return ans

# 1108. Defanging an IP Address
# Given a valid (IPv4) IP address, return a defanged version of that IP address.
#
# A defanged IP address replaces every period "." with "[.]".
#
#
#
# Example 1:
#
# Input: address = "1.1.1.1"
# Output: "1[.]1[.]1[.]1"
# Example 2:
#
# Input: address = "255.100.50.0"
# Output: "255[.]100[.]50[.]0"
#
#
# Constraints:
#
# The given address is a valid IPv4 address.
class Solution:
    def defangIPaddr(self, address: str) -> str:
        return address.replace('.', '[.]')

# Reduce My Fraction
# input:   [numerator, denominator]
# output:  [reduced numerator, reduced denominator]
# example: [45, 120] --> [3, 8]
# All numerators and denominators will be positive integers.
#
# Note: This is an introductory Kata for a series... coming soon!
#
# FUNDAMENTALSRECURSIONALGORITHMS
def reduce_fraction(fraction):
    x, y = fraction
    if x >= y:
        if x % y == 0:
            return x // y, 1
        else:
            for i in range(y - 1, 0, -1):
                if x % i == 0 and y % i == 0:
                    return x // i, y // i
    else:
        if y % x == 0:
            return 1, y // x
        for i in range(x - 1, 0, -1):
            if x % i == 0 and y % i == 0:
                return x // i, y // i

# 1848. Minimum Distance to the Target Element
# Given an integer array nums (0-indexed) and two integers target and start, find an index i such that nums[i] == target and abs(i - start) is minimized. Note that abs(x) is the absolute value of x.
#
# Return abs(i - start).
#
# It is guaranteed that target exists in nums.
#
#
#
# Example 1:
#
# Input: nums = [1,2,3,4,5], target = 5, start = 3
# Output: 1
# Explanation: nums[4] = 5 is the only value equal to target, so the answer is abs(4 - 3) = 1.
# Example 2:
#
# Input: nums = [1], target = 1, start = 0
# Output: 0
# Explanation: nums[0] = 1 is the only value equal to target, so the answer is abs(0 - 0) = 0.
# Example 3:
#
# Input: nums = [1,1,1,1,1,1,1,1,1,1], target = 1, start = 0
# Output: 0
# Explanation: Every value of nums is 1, but nums[0] minimizes abs(i - start), which is abs(0 - 0) = 0.
#
#
# Constraints:
#
# 1 <= nums.length <= 1000
# 1 <= nums[i] <= 104
# 0 <= start < nums.length
# target is in nums.
# Solution 1 - Speed O(N) Memory O(1)
class Solution:
    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:
        top = float('inf')
        for i in range(len(nums)):
            if nums[i] == target and abs(i - start) < top:
                top = abs(i - start)
        return top
# Solution 2 Speed O(N) Memory O(1)
class Solution:
    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:
        l = r = start
        while l >= 0 or r < len(nums):
            if l >= 0 and nums[l] == target:
                return start - l
            if r < len(nums) and nums[r] == target:
                return r - start
            l -= 1
            r += 1

# HTML Generator
# Another rewarding day in the fast-paced world of WebDev. Man, you love your job! But as with any job, somtimes things can get a little tedious. Part of the website you're working on has a very repetitive structure, and writing all the HTML by hand is a bore. Time to automate! You want to write some functions that will generate the HTML for you.
#
# To organize your code, make of all your functions methods of a class called HTMLGen. Tag functions should be named after the tag of the element they create. Each function will take one argument, a string, which is the inner HTML of the element to be created. The functions will return the string for the appropriate HTML element.
#
# For example,
#
# JavaScript:
#
# var g = new HTMLGen();
# var paragraph = g.p('Hello, World!');
# var block = g.div(paragraph);
#
# // The following are now true
# paragraph === '<p>Hello, World!</p>'
# block === '<div><p>Hello, World!</p></div>'
# Python:
#
# g = HTMLGen();
# paragraph = g.p('Hello, World!')
# block = g.div(paragraph)
#
# # The following are now true
# paragraph == '<p>Hello, World!</p>'
# block == '<div><p>Hello, World!</p></div>'
# Your HTMLGen class should have methods to create the following elements:
#
# a
# b
# p
# body
# div
# span
# title
# comment
# Note: The comment method should wrap its argument with an HTML comment. It is the only method whose name does not match an HTML tag. So, g.comment('i am a comment') must produce <!--i am a comment-->.
#
# FUNCTIONAL PROGRAMMINGPUZZLES
class HTMLGen:
    def __init__(self):
        self.tags = {'a': '<a>{}</a>', 'b': '<b>{}</b>',
               'p': '<p>{}</p>', 'body': '<body>{}</body>',
               'div': '<div>{}</div>', 'span': '<span>{}</span>',
               'title': '<title>{}</title>', 'comment': '<!--{}-->'}
    def a(self, content):
        return self.tags['a'].format(content)
    def b(self, content):
        return self.tags['b'].format(content)
    def p(self, content):
        return self.tags['p'].format(content)
    def body(self, content):
        return self.tags['body'].format(content)
    def div(self, content):
        return self.tags['div'].format(content)
    def span(self, content):
        return self.tags['span'].format(content)
    def title(self, content):
        return self.tags['title'].format(content)
    def comment(self, content):
        return self.tags['comment'].format(content)

# 119. Pascal's Triangle II
# Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal's triangle.
# In Pascal's triangle, each number is the sum of the two numbers directly above it as shown:
#
# Example 1:
#
# Input: rowIndex = 3
# Output: [1,3,3,1]
# Example 2:
#
# Input: rowIndex = 0
# Output: [1]
# Example 3:
#
# Input: rowIndex = 1
# Output: [1,1]
#
# Constraints:
# 0 <= rowIndex <= 33
#
# Follow up: Could you optimize your algorithm to use only O(rowIndex) extra space?
# Solution
class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        row = [1]
        for i in range(rowIndex):
            row = [sum(x) for x in zip([0] + row, row + [0])]
        return row
# Solution 2
class Solution(object):
    def getRow(self, r):
        ans = [1]*(r+1);
        up = r
        down = 1
        for i in range(1, r):
            ans[i] = int(ans[i-1]*up/down);
            up = up - 1
            down = down + 1
        return ans;
# Solution 3 Speed O(N), Memory O(1)
class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        row = [1]
        for i in range(rowIndex):
            row = [x + y for x,y in zip([0] + row, row + [0])]
        return row

# Matrix creation
# Create an identity matrix of the specified size( >= 0).
#
# Some examples:
#
# (1)  =>  [[1]]
#
# (2) => [ [1,0],
#          [0,1] ]
#
#        [ [1,0,0,0,0],
#          [0,1,0,0,0],
# (5) =>   [0,0,1,0,0],
#          [0,0,0,1,0],
#          [0,0,0,0,1] ]
# FUNDAMENTALSARRAYSMATRIXLINEAR ALGEBRAMATHEMATICSLANGUAGE FEATURES
def get_matrix(n):
    mat = [[0] * n for j in range(n)]
    for i in range(len(mat)):
        mat[i][i] = 1
    return mat

# 2138. Divide a String Into Groups of Size k
# A string s can be partitioned into groups of size k using the following procedure:
#
# The first group consists of the first k characters of the string, the second group consists of the next k characters of the string, and so on. Each character can be a part of exactly one group.
# For the last group, if the string does not have k characters remaining, a character fill is used to complete the group.
# Note that the partition is done so that after removing the fill character from the last group (if it exists) and concatenating all the groups in order, the resultant string should be s.
#
# Given the string s, the size of each group k and the character fill, return a string array denoting the composition of every group s has been divided into, using the above procedure.
#
#
#
# Example 1:
#
# Input: s = "abcdefghi", k = 3, fill = "x"
# Output: ["abc","def","ghi"]
# Explanation:
# The first 3 characters "abc" form the first group.
# The next 3 characters "def" form the second group.
# The last 3 characters "ghi" form the third group.
# Since all groups can be completely filled by characters from the string, we do not need to use fill.
# Thus, the groups formed are "abc", "def", and "ghi".
# Example 2:
#
# Input: s = "abcdefghij", k = 3, fill = "x"
# Output: ["abc","def","ghi","jxx"]
# Explanation:
# Similar to the previous example, we are forming the first three groups "abc", "def", and "ghi".
# For the last group, we can only use the character 'j' from the string. To complete this group, we add 'x' twice.
# Thus, the 4 groups formed are "abc", "def", "ghi", and "jxx".
#
#
# Constraints:
#
# 1 <= s.length <= 100
# s consists of lowercase English letters only.
# 1 <= k <= 100
# fill is a lowercase English letter.
# Solution 1
class Solution:
    def divideString(self, s: str, k: int, fill: str) -> List[str]:
        ans = []
        for i in range(0, len(s), k):
            it = s[i:i+k]
            if len(it) == k:
                ans += [it]
            else:
                ans += [it + (k - len(it)) * fill]
        return ans
# Solution 2
class Solution:
    def divideString(self, s: str, k: int, fill: str) -> List[str]:
        ans, s = [], s + fill * (k - 1)
        for i in range(0, len(s) - len(s) % k, k):
            ans += [s[i:i+k]]
        return ans
# Solution 3
class Solution:
    def divideString(self, s: str, k: int, fill: str) -> List[str]:
        ans, so = [], s + fill * (k - 1)
        for i in range(0, len(s), k):
            ans += [so[i:i+k]]
        return ans
    
# Thinkful - Number Drills: Rømer temperature
# You're writing an excruciatingly detailed alternate history novel set in a world where Daniel Gabriel Fahrenheit was never born.
#
# Since Fahrenheit never lived the world kept on using the Rømer scale, invented by fellow Dane Ole Rømer to this very day, skipping over the Fahrenheit and Celsius scales entirely.
#
# Your magnum opus contains several thousand references to temperature, but those temperatures are all currently in degrees Celsius. You don't want to convert everything by hand, so you've decided to write a function, celsius_to_romer() that takes a temperature in degrees Celsius and returns the equivalent temperature in degrees Rømer.
#
# For example: celsius_to_romer(24) should return 20.1.
#
# FUNDAMENTALS
def celsius_to_romer(x):
    return (x * (21/40) + 7.5)

# 1475. Final Prices With a Special Discount in a Shop
# You are given an integer array prices where prices[i] is the price of the ith item in a shop.
#
# There is a special discount for items in the shop. If you buy the ith item, then you will receive a discount equivalent to prices[j] where j is the minimum index such that j > i and prices[j] <= prices[i]. Otherwise, you will not receive any discount at all.
#
# Return an integer array answer where answer[i] is the final price you will pay for the ith item of the shop, considering the special discount.
#
#
#
# Example 1:
#
# Input: prices = [8,4,6,2,3]
# Output: [4,2,4,2,3]
# Explanation:
# For item 0 with price[0]=8 you will receive a discount equivalent to prices[1]=4, therefore, the final price you will pay is 8 - 4 = 4.
# For item 1 with price[1]=4 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 4 - 2 = 2.
# For item 2 with price[2]=6 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 6 - 2 = 4.
# For items 3 and 4 you will not receive any discount at all.
# Example 2:
#
# Input: prices = [1,2,3,4,5]
# Output: [1,2,3,4,5]
# Explanation: In this case, for all items, you will not receive any discount at all.
# Example 3:
#
# Input: prices = [10,1,1,6]
# Output: [9,0,1,6]
#
#
# Constraints:
#
# 1 <= prices.length <= 500
# 1 <= prices[i] <= 1000
# Accepted
# 125.1K
# Submissions
# 162.9K
# Acceptance Rate
# 76.8%
# Solution 1 O(N**2) / O(1)
class Solution:
    def finalPrices(self, prices: List[int]) -> List[int]:
        for i in range(len(prices)):
            for j in range(i + 1, len(prices)):
                if prices[j] <= prices[i]:
                    prices[i] = prices[i] - prices[j]
                    break
        return prices
# Solution 2 O(N**2) / O(N)
class Solution:
    def finalPrices(self, prices: List[int]) -> List[int]:
        ans = []
        for i in range(len(prices)):
            top = -1
            for j in range(i + 1, len(prices)):
                if prices[j] <= prices[i]:
                    top = prices[i] - prices[j]
                    break
            if top > -1:
                ans.append(top)
            else:
                ans.append(prices[i])
        return ans
# Solution 3 O(N) / O(N)
class Solution:
    def finalPrices(self, prices: List[int]) -> List[int]:
        res, stack = prices[:], []
        for i, price in enumerate(prices):
            while stack and prices[stack[-1]] >= price:
                res[stack.pop()] -= price
            stack.append(i)
        return res

# Binary Pyramid 101
# Given two numbers m and n, such that 0 ≤ m ≤ n :
# 
# convert all numbers from m to n (inclusive) to binary
# sum them as if they were in base 10
# convert the result to binary
# return as a string
# Example
# 1, 4  -->  1111010
# 
# because:
#     1  // 1 in binary is 1
# +  10  // 2 in binary is 10
# +  11  // 3 in binary is 11
# + 100  // 4 in binary is 100
# -----
#   122  // 122 in binary is 1111010
# MATHEMATICSFUNDAMENTALS
def binary_pyramid(m,n):
    return bin(sum(int(bin(i)[2:]) for i in range(m, n + 1)))[2:]

# 844. Backspace String Compare
# Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character.
#
# Note that after backspacing an empty text, the text will continue empty.
#
#
#
# Example 1:
#
# Input: s = "ab#c", t = "ad#c"
# Output: true
# Explanation: Both s and t become "ac".
# Example 2:
#
# Input: s = "ab##", t = "c#d#"
# Output: true
# Explanation: Both s and t become "".
# Example 3:
#
# Input: s = "a#c", t = "b"
# Output: false
# Explanation: s becomes "c" while t becomes "b".
#
#
# Constraints:
#
# 1 <= s.length, t.length <= 200
# s and t only contain lowercase letters and '#' characters.
#
#
# Follow up: Can you solve it in O(n) time and O(1) space?
class Solution:
    def backspaceCompare(self, s: str, t: str) -> bool:
        x, y = len(s) - 1, len(t) - 1
        top_x, top_y = 0, 0
        while x >= 0 or y >= 0:
            while x >= 0:
                if s[x] == '#':
                    top_x += 1
                    x -= 1
                elif top_x > 0:
                    top_x -= 1
                    x -= 1
                else:
                    break
            while y >= 0:
                if t[y] == '#':
                    top_y += 1
                    y -= 1
                elif top_y > 0:
                    top_y -= 1
                    y -= 1
                else:
                    break
            if x >= 0 and y >= 0 and s[x] != t[y]:
                return False
            if (x >= 0) != (y >= 0):
                return False
            x -= 1
            y -= 1
        return True

# Thinkful - Logic Drills: Umbrella decider
# Write a function take_umbrella() that takes two arguments: a string representing the current weather and a float representing the chance of rain today.
#
# Your function should return True or False based on the following criteria.
#
# You should take an umbrella if it's currently raining or if it's cloudy and the chance of rain is over 0.20.
# You shouldn't take an umbrella if it's sunny unless it's more likely to rain than not.
# The options for the current weather are sunny, cloudy, and rainy.
#
# For example, take_umbrella('sunny', 0.40) should return False.
#
# As an additional challenge, consider solving this kata using only logical operaters and not using any if statements.
#
# FUNDAMENTALS
def take_umbrella(w, r):
    l = [False, True]
    x = w == 'rainy' or (w == 'cloudy' and r > 0.20) or (w == 'sunny' and r > 0.50)
    return l[x]

# 2032. Two Out of Three
# Given three integer arrays nums1, nums2, and nums3, return a distinct array containing all the values that are present in at least two out of the three arrays. You may return the values in any order.
#
#
# Example 1:
#
# Input: nums1 = [1,1,3,2], nums2 = [2,3], nums3 = [3]
# Output: [3,2]
# Explanation: The values that are present in at least two arrays are:
# - 3, in all three arrays.
# - 2, in nums1 and nums2.
# Example 2:
#
# Input: nums1 = [3,1], nums2 = [2,3], nums3 = [1,2]
# Output: [2,3,1]
# Explanation: The values that are present in at least two arrays are:
# - 2, in nums2 and nums3.
# - 3, in nums1 and nums2.
# - 1, in nums1 and nums3.
# Example 3:
#
# Input: nums1 = [1,2,2], nums2 = [4,3,3], nums3 = [5]
# Output: []
# Explanation: No value is present in at least two arrays.
#
#
# Constraints:
#
# 1 <= nums1.length, nums2.length, nums3.length <= 100
# 1 <= nums1[i], nums2[j], nums3[k] <= 100
class Solution:
    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:
        d, ans = {}, []
        for i in set(nums1):
            d[i] = d.get(i, 0) + 1
        for i in set(nums2):
            d[i] = d.get(i, 0) + 1
        for i in set(nums3):
            d[i] = d.get(i, 0) + 1
        for k in d:
            if d[k] > 1:
                ans.append(k)
        return ans

# Are there doubles?
# Your job is to build a function which determines whether or not there are double characters in a string (including whitespace characters). For example aa, !! or   .
#
# You want the function to return true if the string contains double characters and false if not. The test should not be case sensitive; for example both aa & aA return true.
#
# Examples:
#
#   double_check("abca")
#   #returns False
#
#   double_check("aabc")
#   #returns True
#
#   double_check("a 11 c d")
#   #returns True
#
#   double_check("AabBcC")
#   #returns True
#
#   double_check("a b  c")
#   #returns True
#
#   double_check("a b c d e f g h i h k")
#   #returns False
#
#   double_check("2020")
#   #returns False
#
#   double_check("a!@€£#$%^&*()_-+=}]{[|\"':;?/>.<,~")
#   #returns False
# REGULAR EXPRESSIONSFUNDAMENTALS
def double_check(strng):
    strng = strng.lower()
    return not all(x != y for x, y in zip(strng, strng[1:]))

# 884. Uncommon Words from Two Sentences
# A sentence is a string of single-space separated words where each word consists only of lowercase letters.
#
# A word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence.
#
# Given two sentences s1 and s2, return a list of all the uncommon words. You may return the answer in any order.
#
#
#
# Example 1:
#
# Input: s1 = "this apple is sweet", s2 = "this apple is sour"
# Output: ["sweet","sour"]
# Example 2:
#
# Input: s1 = "apple apple", s2 = "banana"
# Output: ["banana"]
#
#
# Constraints:
#
# 1 <= s1.length, s2.length <= 200
# s1 and s2 consist of lowercase English letters and spaces.
# s1 and s2 do not have leading or trailing spaces.
# All the words in s1 and s2 are separated by a single space.
class Solution:
    def uncommonFromSentences(self, s1: str, s2: str) -> List[str]:
        d = {}
        for i in s1.split():
            d[i] = d.get(i, 0) + 1
        for i in s2.split():
            d[i] = d.get(i, 0) + 1
        return [i for i in d if d[i] == 1]

# Pair Zeros
# Task
# For a given list of digits 0 to 9, return a list with the same digits in the same order, but with all 0s paired. Pairing two 0s generates one 0 at the location of the first one.
#
# Examples
# input: [0, 1, 0, 2]
# paired: ^-----^
#     -> [0, 1,   2]
#   kept: ^
#
# input: [0, 1, 0, 0]
# paired: ^-----^
#     -> [0, 1,    0]
#   kept: ^        ^
#
# input: [1, 0, 7, 0, 1]
# paired:    ^-----^
#     -> [1, 0, 7,    1]
#   kept:    ^
#
# input: [0, 1, 7, 0, 2, 2, 0, 0, 1, 0]
# paired: ^--------^        ^--^
#     -> [0, 1, 7,    2, 2, 0,    1, 0]
#   kept: ^                 ^        ^
# Notes
# Pairing happens from left to right. For each pairing, the second 0 will always be paired towards the first ( right to left )
# 0s generated by pairing can NOT be paired again
# ( void where not applicable: ) Don't modify the input array or you may fail to pass the tests
# ALGORITHMSARRAYSFUNDAMENTALSFUNCTIONAL PROGRAMMING
def pair_zeros(arr):
    l, top = arr.copy(), 0
    flag = True
    while top < len(arr):
        if l[top] == 0:
            flag = not flag
            if flag:
                l[top] = None
                continue
        top += 1
    return [i for i in l if i != None]

# 1560. Most Visited Sector in a Circular Track
# Given an integer n and an integer array rounds. We have a circular track which consists of n sectors labeled from 1 to n. A marathon will be held on this track, the marathon consists of m rounds. The ith round starts at sector rounds[i - 1] and ends at sector rounds[i]. For example, round 1 starts at sector rounds[0] and ends at sector rounds[1]
#
# Return an array of the most visited sectors sorted in ascending order.
#
# Notice that you circulate the track in ascending order of sector numbers in the counter-clockwise direction (See the first example).
#
#
#
# Example 1:
#
#
# Input: n = 4, rounds = [1,3,1,2]
# Output: [1,2]
# Explanation: The marathon starts at sector 1. The order of the visited sectors is as follows:
# 1 --> 2 --> 3 (end of round 1) --> 4 --> 1 (end of round 2) --> 2 (end of round 3 and the marathon)
# We can see that both sectors 1 and 2 are visited twice and they are the most visited sectors. Sectors 3 and 4 are visited only once.
# Example 2:
#
# Input: n = 2, rounds = [2,1,2,1,2,1,2,1,2]
# Output: [2]
# Example 3:
#
# Input: n = 7, rounds = [1,3,5,7]
# Output: [1,2,3,4,5,6,7]
#
#
# Constraints:
#
# 2 <= n <= 100
# 1 <= m <= 100
# rounds.length == m + 1
# 1 <= rounds[i] <= n
# rounds[i] != rounds[i + 1] for 0 <= i < m
class Solution(object):
    def mostVisited(self, n, rounds):
        x, y = rounds[0], rounds[-1]
        if x <= y:
            return range(x, y + 1)
        return range(1, y + 1) + range(x, n + 1)

# 584. Find Customer Referee
# Table: Customer
#
# +-------------+---------+
# | Column Name | Type    |
# +-------------+---------+
# | id          | int     |
# | name        | varchar |
# | referee_id  | int     |
# +-------------+---------+
# In SQL, id is the primary key column for this table.
# Each row of this table indicates the id of a customer, their name, and the id of the customer who referred them.
#
#
# Find the names of the customer that are not referred by the customer with id = 2.
#
# Return the result table in any order.
#
# The result format is in the following example.
#
#
#
# Example 1:
#
# Input:
# Customer table:
# +----+------+------------+
# | id | name | referee_id |
# +----+------+------------+
# | 1  | Will | null       |
# | 2  | Jane | null       |
# | 3  | Alex | 2          |
# | 4  | Bill | null       |
# | 5  | Zack | 1          |
# | 6  | Mark | 2          |
# +----+------+------------+
# Output:
# +------+
# | name |
# +------+
# | Will |
# | Jane |
# | Bill |
# | Zack |
# +------+
# Solution MySQL
SELECT name FROM Customer WHERE referee_id <> 2 or referee_id IS NULL

# Solution PostgreSQL
SELECT name FROM Customer WHERE referee_id <> 2 or referee_id IS NULL

# Solution 2 PostgreSQL
SELECT name FROM Customer WHERE referee_id != 2 or referee_id IS NULL

# Jenny the youngest detective
# Jenny is 9 years old. She is the youngest detective in North America. Jenny is a 3rd grader student, so when a new mission comes up, she gets a code to decipher in a form of a sticker (with numbers) in her math notebook and a comment (a sentence) in her writing notebook. All she needs to do is to figure out one word, from there she already knows what to do. And here comes your role - you can help Jenny find out what the word is!
#
# In order to find out what the word is, you should use the sticker (array of 3 numbers) to retrive 3 letters from the comment (string) that create the word.
#
# Each of the numbers in the array refers to the position of a letter in the string, in increasing order.
# Spaces are not places, you need the actual letters. No spaces.
# The returned word should be all lowercase letters.
# if you can't find one of the letters using the index numbers, return "No mission today". Jenny would be very sad, but that's life... :(
# Example: input: [5, 0, 3], "I Love You" output: "ivy" (0 = "i", 3 = "v", 5 = "y")
#
# STRINGSARRAYSALGORITHMSFUNDAMENTALS
def missing(nums, s):
    nums.sort()
    s = s.replace(' ', '').lower()
    if max(nums) >= len(s):
        return 'No mission today'
    return ''.join(s[i] for i in nums)

# Multiply
# This code does not execute properly. Try to figure out why.
#
# DEBUGGINGFUNDAMENTALS
# Solution PostgreSQL
SELECT price * amount AS total FROM items;

# 595. Big Countries
# SQL Schema
# Pandas Schema
# Table: World
#
# +-------------+---------+
# | Column Name | Type    |
# +-------------+---------+
# | name        | varchar |
# | continent   | varchar |
# | area        | int     |
# | population  | int     |
# | gdp         | bigint  |
# +-------------+---------+
# name is the primary key (column with unique values) for this table.
# Each row of this table gives information about the name of a country, the continent to which it belongs, its area, the population, and its GDP value.
#
#
# A country is big if:
#
# it has an area of at least three million (i.e., 3000000 km2), or
# it has a population of at least twenty-five million (i.e., 25000000).
# Write a solution to find the name, population, and area of the big countries.
#
# Return the result table in any order.
#
# The result format is in the following example.
#
#
#
# Example 1:
#
# Input:
# World table:
# +-------------+-----------+---------+------------+--------------+
# | name        | continent | area    | population | gdp          |
# +-------------+-----------+---------+------------+--------------+
# | Afghanistan | Asia      | 652230  | 25500100   | 20343000000  |
# | Albania     | Europe    | 28748   | 2831741    | 12960000000  |
# | Algeria     | Africa    | 2381741 | 37100000   | 188681000000 |
# | Andorra     | Europe    | 468     | 78115      | 3712000000   |
# | Angola      | Africa    | 1246700 | 20609294   | 100990000000 |
# +-------------+-----------+---------+------------+--------------+
# Output:
# +-------------+------------+---------+
# | name        | population | area    |
# +-------------+------------+---------+
# | Afghanistan | 25500100   | 652230  |
# | Algeria     | 37100000   | 2381741 |
# +-------------+------------+---------+
# Solution MySQL
SELECT name, population, area
FROM World
WHERE area >= 3000000 OR population >= 25000000;
# Solution 1 PostgreSQL
SELECT name, population, area
FROM World
WHERE area >= 3000000 OR population >= 25000000;
# Solution 2 Faster PostgreSQL
SELECT name, population, area
FROM World
WHERE area >= 3000000
UNION
SELECT name, population, area
FROM World
WHERE population >= 25000000

# 342. Power of Four
# Given an integer n, return true if it is a power of four. Otherwise, return false.
#
# An integer n is a power of four, if there exists an integer x such that n == 4x.
#
#
#
# Example 1:
#
# Input: n = 16
# Output: true
# Example 2:
#
# Input: n = 5
# Output: false
# Example 3:
#
# Input: n = 1
# Output: true
#
#
# Constraints:
#
# -231 <= n <= 231 - 1
#
#
# Follow up: Could you solve it without loops/recursion?
# Solution
class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        i = 0
        while 4 ** i <= n:
            if 4 ** i == n:
                return True
            i += 1
        return False

# Solution 2
class Solution(object):
    def isPowerOfFour(self, n):
        return n & n-1 == 0 and (n-1) % 3 == 0

# Red Knight
# Red Knight is chasing two pawns. Which pawn will be caught, and where?
#
# Input / Output
# Input will be two integers:
#
# N / n (Ruby) vertical position of Red Knight (0 or 1).
# P / p (Ruby) horizontal position of two pawns (between 2 and 1000000).
# Output has to be a tuple (python, haskell, Rust, prolog, C#), an array (javascript, ruby), an object (java), or a structure (C) with:
#
# "Black" or "White" - which pawn was caught
# Where it was caught (horizontal position)
# Example
# Input = 0, 4
# Output = ("White", 8)
# 1
# 2
# 3
# 0
# 4
# 5
# 6
# 7
# 0
# 1
# Notes
# Red Knight will always start at horizontal position 0.
# The black pawn will always be at the bottom (vertical position 1).
# The white pawn will always be at the top (vertical position 0).
# The pawns move first, and they move simultaneously.
# Red Knight moves 2 squares forward and 1 up or down.
# Pawns always move 1 square forward.
# Both pawns will start at the same horizontal position.
# PUZZLESALGORITHMSFUNDAMENTALS
def red_knight(N, P):
    d = {'White': 'Black', 'Black': 'White'}
    flag = 'White' if N == 0 else 'Black'
    N = 0
    while N < P:
        P += 1
        N += 2
        flag = d[flag]
    return flag, N

# 2859. Sum of Values at Indices With K Set Bits
# You are given a 0-indexed integer array nums and an integer k.
#
# Return an integer that denotes the sum of elements in nums whose corresponding indices have exactly k set bits in their binary representation.
#
# The set bits in an integer are the 1's present when it is written in binary.
#
# For example, the binary representation of 21 is 10101, which has 3 set bits.
#
#
# Example 1:
#
# Input: nums = [5,10,1,5,2], k = 1
# Output: 13
# Explanation: The binary representation of the indices are:
# 0 = 0002
# 1 = 0012
# 2 = 0102
# 3 = 0112
# 4 = 1002
# Indices 1, 2, and 4 have k = 1 set bits in their binary representation.
# Hence, the answer is nums[1] + nums[2] + nums[4] = 13.
# Example 2:
#
# Input: nums = [4,3,2,1], k = 2
# Output: 1
# Explanation: The binary representation of the indices are:
# 0 = 002
# 1 = 012
# 2 = 102
# 3 = 112
# Only index 3 has k = 2 set bits in its binary representation.
# Hence, the answer is nums[3] = 1.
#
#
# Constraints:
#
# 1 <= nums.length <= 1000
# 1 <= nums[i] <= 105
# 0 <= k <= 10
class Solution(object):
    def sumIndicesWithKSetBits(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        ans = 0
        for i in range(len(nums)):
            if bin(i).count('1') == k:
                ans += nums[i]
        return ans

# Distance from the average
# Given a starting list/array of data, it could make some statistical sense to know how much each value differs from the average.
#
# If for example during a week of work you have collected 55,95,62,36,48 contacts for your business, it might be interesting to know the total (296), the average (59.2), but also how much you moved away from the average each single day.
#
# For example on the first day you did something less than the said average (55, meaning -4.2 compared to the average), much more in the second day (95, 35.8 more than the average and so on).
#
# The resulting list/array of differences starting from [55, 95, 62, 36, 48] is thus [4.2, -35.8, -2.8, 23.2, 11.2].
#
# Assuming you will only get valid inputs (ie: only arrays/lists with numbers), create a function to do that, rounding each difference to the second decimal digit (this is not needed in Haskell); extra points if you do so in some smart, clever or concise way :)
#
# With Clojure to round use:
# (defn roundTo2 [n] (/ (Math/round (* n 100.0)) 100.0))
# ARRAYSLISTSSTATISTICSFUNDAMENTALSDATA SCIENCE
def distances_from_average(test_list):
    mean = sum(test_list) / len(test_list)
    return [round(mean - i, 2) for i in test_list]

# 779. K-th Symbol in Grammar
# We build a table of n rows (1-indexed). We start by writing 0 in the 1st row. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10.
#
# For example, for n = 3, the 1st row is 0, the 2nd row is 01, and the 3rd row is 0110.
# Given two integer n and k, return the kth (1-indexed) symbol in the nth row of a table of n rows.
#
#
#
# Example 1:
#
# Input: n = 1, k = 1
# Output: 0
# Explanation: row 1: 0
# Example 2:
#
# Input: n = 2, k = 1
# Output: 0
# Explanation:
# row 1: 0
# row 2: 01
# Example 3:
#
# Input: n = 2, k = 2
# Output: 1
# Explanation:
# row 1: 0
# row 2: 01
#
#
# Constraints:
#
# 1 <= n <= 30
# 1 <= k <= 2n - 1
# Solution 1 - Hamming weight
class Solution(object):
    def kthGrammar(self, n, k):
        return bin(k - 1).count('1') % 2
# Solution 2 Recursive
class Solution(object):
    def kthGrammar(self, n, k):
        if n == 1:
            return 0
        if k % 2 == 0:
            if self.kthGrammar(n-1, k / 2) == 0:
                return 1
            else:
                return 0
        else:
            if self.kthGrammar(n - 1, (k + 1) / 2) == 0:
                return 0
            else:
                return 1

# Fun with lists: indexOf
# Implement the method indexOf (index_of in PHP), which accepts a linked list (head) and a value, and returns the index (zero based) of the first occurrence of that value if exists, or -1 otherwise.
#
# For example: Given the list: 1 -> 2 -> 3 -> 3, and the value 3, indexOf / index_of should return 2.
#
# The linked list is defined as follows:
#
# class Node:
#     def __init__(self, data, next=None):
#         self.data = data
#         self.next = next
# Note: the list may be null and can hold any type of value.
#
# Good luck!
#
# This kata is part of fun with lists series:
#
# Fun with lists: length
# Fun with lists: indexOf
# Fun with lists: lastIndexOf
# Fun with lists: countIf
# Fun with lists: anyMatch + allMatch
# Fun with lists: filter
# Fun with lists: map
# Fun with lists: reduce
# LISTSFUNDAMENTALS
def index_of(head, value):
    top = 0
    while head:
        if type(head.data) == type(value):
            if head.data == value:
                return top
        head = head.next
        top += 1
    return -1

# 944. Delete Columns to Make Sorted
# You are given an array of n strings strs, all of the same length.
#
# The strings can be arranged such that there is one on each line, making a grid.
#
# For example, strs = ["abc", "bce", "cae"] can be arranged as follows:
# abc
# bce
# cae
# You want to delete the columns that are not sorted lexicographically. In the above example (0-indexed), columns 0 ('a', 'b', 'c') and 2 ('c', 'e', 'e') are sorted, while column 1 ('b', 'c', 'a') is not, so you would delete column 1.
#
# Return the number of columns that you will delete.
#
#
#
# Example 1:
#
# Input: strs = ["cba","daf","ghi"]
# Output: 1
# Explanation: The grid looks as follows:
#   cba
#   daf
#   ghi
# Columns 0 and 2 are sorted, but column 1 is not, so you only need to delete 1 column.
# Example 2:
#
# Input: strs = ["a","b"]
# Output: 0
# Explanation: The grid looks as follows:
#   a
#   b
# Column 0 is the only column and is sorted, so you will not delete any columns.
# Example 3:
#
# Input: strs = ["zyx","wvu","tsr"]
# Output: 3
# Explanation: The grid looks as follows:
#   zyx
#   wvu
#   tsr
# All 3 columns are not sorted, so you will delete all 3.
#
#
# Constraints:
#
# n == strs.length
# 1 <= n <= 100
# 1 <= strs[i].length <= 1000
# strs[i] consists of lowercase English letters.
class Solution(object):
    def minDeletionSize(self, strs):
        top = 0
        for i in range(len(strs[0])):
            for j in range(len(strs) - 1):
                if strs[j][i] > strs[j+1][i]:
                    top += 1
                    break
        return top



# Genetic Algorithm Series - #3 Crossover
# In genetic algorithms, crossover is a genetic operator used to vary the programming of chromosomes from one generation to the next.
#
# The one-point crossover consists in swapping one's cromosome part with another in a specific given point. The image bellow shows the crossover being applied on chromosomes 1011011001111 and 1011100100110 with the cut point (index) 4:
#
#
#
# In this kata you have to implement a function crossover that receives two chromosomes chromosome1, chromosome2 and a zero-based index and it has to return an array with the crossover result on both chromosomes [chromosome1, chromosome2].
#
# Example:
# crossover('111000', '000110', 3) should return ['111110', 000000']
#
# See other katas from this series
# Genetic Algorithm Series - #1 Generate
# Genetic Algorithm Series - #2 Mutation
# Genetic Algorithm Series - #3 Crossover
# Genetic Algorithm Series - #4 Get population and fitnesses
# Genetic Algorithm Series - #5 Roulette wheel selection
# This kata is a piece of2 kyuBinary Genetic Algorithm
#
# STRINGSALGORITHMSGENETIC ALGORITHMS
def crossover(chromosome1, chromosome2, index):
    x, y = '', ''
    for i in range(index, len(chromosome1)):
        x += chromosome2[i]
        y += chromosome1[i]
    return [chromosome1[:index] + x, chromosome2[:index] + y]

# 2248. Intersection of Multiple Arrays
# Given a 2D integer array nums where nums[i] is a non-empty array of distinct positive integers, return the list of integers that are present in each array of nums sorted in ascending order.
#
#
# Example 1:
#
# Input: nums = [[3,1,2,4,5],[1,2,3,4],[3,4,5,6]]
# Output: [3,4]
# Explanation:
# The only integers present in each of nums[0] = [3,1,2,4,5], nums[1] = [1,2,3,4], and nums[2] = [3,4,5,6] are 3 and 4, so we return [3,4].
# Example 2:
#
# Input: nums = [[1,2,3],[4,5,6]]
# Output: []
# Explanation:
# There does not exist any integer present both in nums[0] and nums[1], so we return an empty list [].
#
#
# Constraints:
#
# 1 <= nums.length <= 1000
# 1 <= sum(nums[i].length) <= 1000
# 1 <= nums[i][j] <= 1000
# All the values of nums[i] are unique.
# Solution 1
class Solution(object):
    def intersection(self, nums):
        d = {}
        for i in nums:
            for j in i:
                d[j] = d.get(j, 0) + 1
        for i in d.copy():
            if d[i] != len(nums):
                del d[i]
        return sorted(d.keys())
# Solution 2
class Solution(object):
    def intersection(self, nums):
        d = {}
        for i in nums:
            for j in i:
                d[j] = d.get(j, 0) + 1
        top = []
        for i in d:
            if d[i] == len(nums):
                top.append(i)
        return sorted(top)
    
# Fibonacci's FizzBuzz
# Instructions
# The goal of this kata is two-fold:
#
# 1.) You must produce a fibonacci sequence in the form of an array, containing a number of items equal to the input provided.
#
# 2.) You must replace all numbers in the sequence divisible by 3 with Fizz, those divisible by 5 with Buzz, and those divisible by both 3 and 5 with FizzBuzz.
#
# For the sake of this kata, you can assume all input will be a positive integer.
#
# Use Cases
# Return output must be in the form of an array, with the numbers as integers and the replaced numbers (fizzbuzz) as strings.
#
# Examples
# Input:
#
# fibs_fizz_buzz(5)
# Output:
#
# [ 1, 1, 2, 'Fizz', 'Buzz' ]
# Input:
#
# fibs_fizz_buzz(1)
# Output:
#
# [1]
# Input:
#
# fibs_fizz_buzz(20)
# Output:
#
# [1,1,2,"Fizz","Buzz",8,13,"Fizz",34,"Buzz",89,"Fizz",233,377,"Buzz","Fizz",1597,2584,4181,"FizzBuzz"]
# ##Good Luck!##
#
# FUNDAMENTALSALGORITHMS
def fibs_fizz_buzz(n):
    top = []
    x, y = 0, 1
    for i in range(n):
        x, y = y, x + y
        if x % 3 == 0 and x % 5 == 0:
            top.append('FizzBuzz')
        elif x % 3 == 0:
            top.append('Fizz')
        elif x % 5 == 0:
            top.append('Buzz')
        else:
            top.append(x)
    return top

# 2848. Points That Intersect With Cars
# You are given a 0-indexed 2D integer array nums representing the coordinates of the cars parking on a number line. For any index i, nums[i] = [starti, endi] where starti is the starting point of the ith car and endi is the ending point of the ith car.
#
# Return the number of integer points on the line that are covered with any part of a car.
#
#
#
# Example 1:
#
# Input: nums = [[3,6],[1,5],[4,7]]
# Output: 7
# Explanation: All the points from 1 to 7 intersect at least one car, therefore the answer would be 7.
# Example 2:
#
# Input: nums = [[1,3],[5,8]]
# Output: 7
# Explanation: Points intersecting at least one car are 1, 2, 3, 5, 6, 7, 8. There are a total of 7 points, therefore the answer would be 7.
#
#
# Constraints:
#
# 1 <= nums.length <= 100
# nums[i].length == 2
# 1 <= starti <= endi <= 100
# Solution HashSet Speed O(N) - Memory O(N)
class Solution(object):
    def numberOfPoints(self, nums):
        s = set()
        for i in nums:
            for j in range(i[0], i[1] + 1):
                if j not in s:
                    s.add(j)
        return len(s)

# 8 towers
# Marcus was spending his last summer day playing chess with his friend Rose.
#
# Surprisingly, they had a lot of pieces (we suspect Marcus is a part-time thief, but we will leave that aside), and Marcus wondered in how many different positions could 8 towers (rooks) be in the board, without threatening themselves.
#
# Rose (who was smarter) was wondering if there was any relation between the size of the board, and the number of positions.
#
# So, you should help!
#
# Write a function that, given N (positive-only integer) the size of the board , returns the number of different combinations in which these towers can be.
#
# Example:
#
# towerCombination(2) returns 2, because only the following possibilities can be achieved.
#
# | x 0 |
# | 0 x |
#
# | 0 x |
# | x 0 |
# towerCombination(3) returns 6, because only the following possibilities can be achieved.
#
# | x 0 0 |
# | 0 x 0 |
# | 0 0 x |
#
# | x 0 0 |
# | 0 0 x |
# | 0 x 0 |
#
# | 0 x 0 |
# | x 0 0 |
# | 0 0 x |
#
# | 0 x 0 |
# | 0 0 x |
# | x 0 0 |
#
# | 0 0 x |
# | x 0 0 |
# | 0 x 0 |
#
# | 0 0 x |
# | 0 x 0 |
# | x 0 0 |
# ALGORITHMS
import math
def tower_combination(n):
    return math.factorial(n)

# Waiting room
# There's a waiting room with N chairs set in single row. Chairs are consecutively numbered from 1 to N. First is closest to the entrance (which is exit as well).
#
# For some reason people choose a chair in the following way
#
# Find a place as far from other people as possible
# Find a place as close to exit as possible
# All chairs must be occupied before the first person will be served
#
# So it looks like this for 10 chairs and 10 patients
#
# Chairs	1	2	3	4	5	6	7	8	9	10
# Patients	1	7	5	8	3	9	4	6	10	2
# Your task is to find last patient's chair's number.
#
# Input: number of chairs N, an integer greater than 2.
# Output: a positive integer, the last patient's chair number.
# Have fun :)
#
# SORTINGPUZZLESALGORITHMS
def last_chair(n):
    return n - 1

# Convert a linked list to a string
# Convert a linked list to a string
# Related Kata
# Although this Kata is not part of an official Series, you may also want to try out Parse a linked list from a string if you enjoyed this Kata.
#
# Preloaded
# Preloaded for you is a class, struct or derived data type Node ( depending on the language ) used to construct linked lists in this Kata:
#
# class Node():
#     def __init__(self, data, next = None):
#         self.data = data
#         self.next = next
# Prerequisites
# This Kata assumes that you are already familiar with the idea of a linked list. If you do not know what that is, you may want to read this article on Wikipedia. Specifically, the linked lists this Kata is referring to are singly linked lists, where the value of a specific node is stored in its data / $data / Data property, the reference to the next node is stored in its next / $next / Next / next_node property and the terminator for a list is null / NULL / None / nil / nullptr / null().
#
# Task
# Create a function stringify which accepts an argument list / $list and returns a string representation of the list. The string representation of the list starts with the value of the current Node, specified by its data / $data / Data property, followed by a whitespace character, an arrow and another whitespace character (" -> "), followed by the rest of the list. The end of the string representation of a list must always end with null / NULL / None / nil / nullptr / null() ( all caps or all lowercase depending on the language you are undertaking this Kata in ). For example, given the following list:
#
# Node(1, Node(2, Node(3)))
# ... its string representation would be:
#
# "1 -> 2 -> 3 -> None"
# And given the following linked list:
#
# Node(0, Node(1, Node(4, Node(9, Node(16)))))
# ... its string representation would be:
#
# "0 -> 1 -> 4 -> 9 -> 16 -> None"
# Note that null / NULL / None / nil / nullptr / null() itself is also considered a valid linked list. In that case, its string representation would simply be "null" / "NULL" / "None" / "nil" / "nullptr" / @"NULL" / "null()" ( again, depending on the language ).
#
# For the simplicity of this Kata, you may assume that any Node in this Kata may only contain non-negative integer values. For example, you will not encounter a Node whose data / $data / Data property is "Hello World".
#
# Enjoy, and don't forget to check out my other Kata Series :D
#
# LINKED LISTSRECURSIONALGORITHMS
def stringify(node):
    ans = []
    while node:
        ans.append(str(node.data))
        node = node.next
    return ' -> '.join(ans + ['None'])

# Which color is the brightest?
# One of the common ways of representing color is the RGB color model, in which the Red, Green, and Blue primary colors of light are added together in various ways to reproduce a broad array of colors.
#
# One of the ways to determine brightness of a color is to find the value V of the alternative HSV (Hue, Saturation, Value) color model. Value is defined as the largest component of a color:
#
# V = max(R,G,B)
# You are given a list of colors in 6-digit hexidecimal notation #RRGGBB. Return the brightest of these colors!
#
# For example,
#
# brightest(["#001000", "#000000"]) == "#001000"
# brightest(["#ABCDEF", "#123456"]) == "#ABCDEF"
# If there are multiple brightest colors, return the first one:
#
# brightest(["#00FF00", "#FFFF00", "#01130F"]) == "#00FF00"
# Note that both input and output should use upper case for characters A, B, C, D, E, F.
#
# ALGORITHMSSTRINGS
def brightest(colors):
    count, ans = 0, 0
    for j in colors:
        top = 0
        for i in range(1, len(j), 2):
            x = int(j[i], 16) * 16 + int(j[i + 1], 16)
            if top < x:
                top = x
        if top > count:
            count = top
            ans = j
    return ans

# 2549. Count Distinct Numbers on Board
# You are given a positive integer n, that is initially placed on a board. Every day, for 109 days, you perform the following procedure:
#
# For each number x present on the board, find all numbers 1 <= i <= n such that x % i == 1.
# Then, place those numbers on the board.
# Return the number of distinct integers present on the board after 109 days have elapsed.
#
# Note:
#
# Once a number is placed on the board, it will remain on it until the end.
# % stands for the modulo operation. For example, 14 % 3 is 2.
#
#
# Example 1:
#
# Input: n = 5
# Output: 4
# Explanation: Initially, 5 is present on the board.
# The next day, 2 and 4 will be added since 5 % 2 == 1 and 5 % 4 == 1.
# After that day, 3 will be added to the board because 4 % 3 == 1.
# At the end of a billion days, the distinct numbers on the board will be 2, 3, 4, and 5.
# Example 2:
#
# Input: n = 3
# Output: 2
# Explanation:
# Since 3 % 2 == 1, 2 will be added to the board.
# After a billion days, the only two distinct numbers on the board are 2 and 3.
#
#
# Constraints:
#
# 1 <= n <= 100
class Solution(object):
    def distinctIntegers(self, n):
        return max(n - 1, 1)
    
# Tap Code Translation
# Tap Code Translation
# Tap code is a way to communicate using a series of taps and pauses for each letter. In this kata, we will use dots . for the taps and whitespaces for the pauses.
#
# The number of taps needed for each letter matches its coordinates in the following polybius square (note the c/k position). Then you "tap" the row, a pause, then the column. Each letter is separated from others with a pause too.
#
#    1  2  3  4  5
# 1  A  B C\K D  E
# 2  F  G  H  I  J
# 3  L  M  N  O  P
# 4  Q  R  S  T  U
# 5  V  W  X  Y  Z
# Input:
# A lowercase string of a single word (no whitespaces or punctuation, only letters).
#
# Output:
# The encoded string as taps and pauses.
#
# Examples
# text = "dot"
#   "D" = (1, 4) = ". ...."
#   "O" = (3, 4) = "... ...."
#   "T" = (4, 4) = ".... ...."
#
# output: ". .... ... .... .... ...."
#
#
# "example" -> ". ..... ..... ... . . ... .. ... ..... ... . . ....."
# "more"    -> "... .. ... .... .... .. . ....."
# Happy coding!
#
# ALGORITHMSSTRINGSCRYPTOGRAPHYSECURITY
def tap_code_translation(text):
    ans = []
    for i in text:
        x = ord(i) - 96
        if x > 10:
            if x == 11:
                x = 3
            else:
                x -= 1
        first = (x + 4) // 5
        while x > 5:
            x -= 5
        second = x
        ans.append('.' * first + ' ' + '.' * second)
    return ' '.join(ans)

# 1356. Sort Integers by The Number of 1 Bits
# You are given an integer array arr. Sort the integers in the array in ascending order by the number of 1's in their binary representation and in case of two or more integers have the same number of 1's you have to sort them in ascending order.
#
# Return the array after sorting it.
#
#
#
# Example 1:
#
# Input: arr = [0,1,2,3,4,5,6,7,8]
# Output: [0,1,2,4,8,3,5,6,7]
# Explantion: [0] is the only integer with 0 bits.
# [1,2,4,8] all have 1 bit.
# [3,5,6] have 2 bits.
# [7] has 3 bits.
# The sorted array by bits is [0,1,2,4,8,3,5,6,7]
# Example 2:
#
# Input: arr = [1024,512,256,128,64,32,16,8,4,2,1]
# Output: [1,2,4,8,16,32,64,128,256,512,1024]
# Explantion: All integers have 1 bit in the binary representation, you should just sort them in ascending order.
#
#
# Constraints:
#
# 1 <= arr.length <= 500
# 0 <= arr[i] <= 104
# Solution 1 list
class Solution(object):
    def sortByBits(self, arr):
        d, ans = [], []
        for i in arr:
            d.append((i, bin(i).count('1')))
        for i in range(len(d)):
            top, val = float('inf'), float('inf')
            for j in d:
                if j[1] < top:
                    val, top = j[0], j[1]
                elif j[1] == top:
                    if j[0] < val:
                        val, top = j[0], j[1]
            ans.append(val)
            d.remove((val, top))
        return ans
# Solution 2 Hashtable
class Solution(object):
    def sortByBits(self, arr):
        d, ans = {}, []
        for i in arr:
            d[i] = d.get(i, 0) + 1
        while d:
            top, val = float('inf'), float('inf')
            for j in d:
                x = bin(j).count('1')
                if x < top:
                    val, top = j, x
                elif x == top:
                    if j < val:
                        val, top = j, x
            d[val] -= 1
            if d[val] == 0:
                del d[val]
            ans.append(val)
        return ans
# Solution 3 Math with bits
class Solution(object):
    def sortByBits(self, arr):
        for i in range(len(arr)):
            arr[i] += bin(arr[i]).count('1') * 10001
        arr.sort()
        for i in range(len(arr)):
            arr[i] = arr[i] % 10001
        return arr

# Suitcase packing
# Mr. Square is going on a holiday. He wants to bring 2 of his favorite squares with him, so he put them in his rectangle suitcase.
#
# Write a function that, given the size of the squares and the suitcase, return whether the squares can fit inside the suitcase.
#
# fit_in(a,b,m,n)
# a,b are the sizes of the 2 squares
# m,n are the sizes of the suitcase
# Example
# fit_in(1,2,3,2) should return True
# fit_in(1,2,2,1) should return False
# fit_in(3,2,3,2) should return False
# fit_in(1,2,1,2) should return False
# PUZZLES
def fit_in(a,b,m,n):
    return (a + b <= max(m, n)) and (max(a, b) <= min(m, n))

# 2451. Odd String Difference
# You are given an array of equal-length strings words. Assume that the length of each string is n.
#
# Each string words[i] can be converted into a difference integer array difference[i] of length n - 1 where difference[i][j] = words[i][j+1] - words[i][j] where 0 <= j <= n - 2. Note that the difference between two letters is the difference between their positions in the alphabet i.e. the position of 'a' is 0, 'b' is 1, and 'z' is 25.
#
# For example, for the string "acb", the difference integer array is [2 - 0, 1 - 2] = [2, -1].
# All the strings in words have the same difference integer array, except one. You should find that string.
#
# Return the string in words that has different difference integer array.
#
#
#
# Example 1:
#
# Input: words = ["adc","wzy","abc"]
# Output: "abc"
# Explanation:
# - The difference integer array of "adc" is [3 - 0, 2 - 3] = [3, -1].
# - The difference integer array of "wzy" is [25 - 22, 24 - 25]= [3, -1].
# - The difference integer array of "abc" is [1 - 0, 2 - 1] = [1, 1].
# The odd array out is [1, 1], so we return the corresponding string, "abc".
# Example 2:
#
# Input: words = ["aaa","bob","ccc","ddd"]
# Output: "bob"
# Explanation: All the integer arrays are [0, 0] except for "bob", which corresponds to [13, -13].
#
#
# Constraints:
#
# 3 <= words.length <= 100
# n == words[i].length
# 2 <= n <= 20
# words[i] consists of lowercase English letters.
class Solution(object):
    def oddString(self, words):
        l = [0] * len(words)
        for i in range(len(words)):
            ans = []
            for j in range(len(words[i]) - 1):
                ans.append(ord(words[i][j + 1]) - 97 - ord(words[i][j]) - 97)
            l[i] = ans
        for i in range(1, len(l) - 1):
            if l[i - 1] != l[i] and l[i - 1] != l[i + 1]:
                return words[i - 1]
            elif l[i] != l[i - 1] and l[i] != l[i + 1]:
                return words[i]
            elif l[i + 1] != l[i] and l[i + 1] != l[i - 1]:
                return words[i + 1]
            
# Set Reducer
# Set Reducer
# Intro
# These arrays are too long! Let's reduce them!
#
# Description
# Write a function that takes in an array of integers from 0-9, and returns a new array:
#
# Numbers with no identical numbers preceding or following it returns a 1: 2, 4, 9  => 1, 1, 1
# Sequential groups of identical numbers return their count: 6, 6, 6, 6 => 4
# Example
#
# [0, 4, 6, 8, 8, 8, 5, 5, 7] => [1, 1, 1, 3, 2, 1]
#
# Your function should then repeat the process on the resulting array, and on the resulting array of that, until it returns a single integer:
#
# [0, 4, 6, 8, 8, 8, 5, 5, 7] =>  [1, 1, 1, 3, 2, 1] => [3, 1, 1, 1] => [1, 3] => [1, 1] => [2]
#
# When your function has reduced the array to a single integer following these rules, it should return that integer.
#
# [2] => 2
#
# Rules and assertions
# All test arrays will be 2+ in length
# All integers in the test arrays will be positive numbers from 0 - 9
# You should return an integer, not an array with 1 element
# Visual example
# Example of the flow of the algorithm
#
# RECURSIONALGORITHMSLOGICARRAYS
def set_reducer(inp):
    ans, n, count = [], 0, 0
    while n < len(inp):
        if n == len(inp) - 1:
            if count > 0:
                ans.append(count + 1)
            else:
                ans.append(1)
            break
        if inp[n] != inp[n + 1]:
            if count > 0:
                ans.append(count + 1)
                count = 0
            else:
                ans.append(1)
        else:
            count += 1
        n += 1
    while len(ans) > 1:
        l, n, count = [], 0, 0
        while n < len(ans):
            if n == len(ans) - 1:
                if count > 0:
                    l.append(count + 1)
                else:
                    l.append(1)
                break
            if ans[n] != ans[n + 1]:
                if count > 0:
                    l.append(count + 1)
                    count = 0
                else:
                    l.append(1)
            else:
                count += 1
            n += 1
        ans = l
    return ans[0]

# 925. Long Pressed Name
# Your friend is typing his name into a keyboard. Sometimes, when typing a character c, the key might get long pressed, and the character will be typed 1 or more times.
#
# You examine the typed characters of the keyboard. Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed.
#
#
#
# Example 1:
#
# Input: name = "alex", typed = "aaleex"
# Output: true
# Explanation: 'a' and 'e' in 'alex' were long pressed.
# Example 2:
#
# Input: name = "saeed", typed = "ssaaedd"
# Output: false
# Explanation: 'e' must have been pressed twice, but it was not in the typed output.
#
#
# Constraints:
#
# 1 <= name.length, typed.length <= 1000
# name and typed consist of only lowercase English letters.
class Solution(object):
    def isLongPressedName(self, name, typed):
        i = 0
        for j in range(len(typed)):
            if i < len(name) and name[i] == typed[j]:
                i += 1
            elif j == 0 or typed[j] != typed[j - 1]:
                return False
        return i == len(name)
    
# Simple Fun #8: Kill K-th Bit
# Task
# In order to stop the Mad Coder evil genius you need to decipher the encrypted message he sent to his minions. The message contains several numbers that, when typed into a supercomputer, will launch a missile into the sky blocking out the sun, and making all the people on Earth grumpy and sad.
#
# You figured out that some numbers have a modified single digit in their binary representation. More specifically, in the given number n the kth bit from the right was initially set to 0, but its current value might be different. It's now up to you to write a function that will change the kth bit of n back to 0.
#
# Example
# For n = 37 and k = 3, the output should be 33.
#
# 3710 = 1001012 ~> 1000012 = 3310
#
# For n = 37 and k = 4, the output should be 37.
#
# The 4th bit is 0 already (looks like the Mad Coder forgot to encrypt this number), so the answer is still 37.
#
# Input/Output
# [input] integer n
# Constraints: 0 ≤ n ≤ 231 - 1.
#
# [input] integer k
# The 1-based index of the changed bit (counting from the right).
#
# Constraints: 1 ≤ k ≤ 31.
#
# [output] an integer
# More Challenge
# Are you a One-Liner? Please try to complete the kata in one line(no test for it) ;-)
# PUZZLESBITSBINARY
def kill_kth_bit(n, k):
    return n & ~(1 << k - 1)

# 2578. Split With Minimum Sum
# Given a positive integer num, split it into two non-negative integers num1 and num2 such that:
#
# The concatenation of num1 and num2 is a permutation of num.
# In other words, the sum of the number of occurrences of each digit in num1 and num2 is equal to the number of occurrences of that digit in num.
# num1 and num2 can contain leading zeros.
# Return the minimum possible sum of num1 and num2.
#
# Notes:
#
# It is guaranteed that num does not contain any leading zeros.
# The order of occurrence of the digits in num1 and num2 may differ from the order of occurrence of num.
#
#
# Example 1:
#
# Input: num = 4325
# Output: 59
# Explanation: We can split 4325 so that num1 is 24 and num2 is 35, giving a sum of 59. We can prove that 59 is indeed the minimal possible sum.
# Example 2:
#
# Input: num = 687
# Output: 75
# Explanation: We can split 687 so that num1 is 68 and num2 is 7, which would give an optimal sum of 75.
#
#
# Constraints:
#
# 10 <= num <= 109
class Solution(object):
    def splitNum(self, num):
        num = sorted(str(num))
        x, y = '', ''
        for i in range(len(num)):
            if int(i) % 2 == 0:
                x += num[i]
            else:
                y += num[i]
        return int(x) + int(y)

# Help Suzuki count his vegetables....
# Help Suzuki count his vegetables....
#
# Suzuki is the master monk of his monastery so it is up to him to ensure the kitchen is operating at full capacity to feed his students and the villagers that come for lunch on a daily basis.
#
# This week there was a problem with his deliveries and all the vegetables became mixed up. There are two important aspects of cooking in his kitchen, it must be done in harmony and nothing can be wasted. Since the monks are a record keeping people the first order of business is to sort the mixed up vegetables and then count them to ensure there is enough to feed all the students and villagers.
#
# You will be given a string with the following vegetables:
#
# "cabbage", "carrot", "celery", "cucumber", "mushroom", "onion", "pepper", "potato", "tofu", "turnip"
# Return a list of objects (tuple in Python, array in JavaScript, table in COBOL) with the count of each vegetable in descending order. If there are any non vegetables mixed in discard them. If the count of two vegetables is the same sort in reverse alphabetical order (Z->A).
#
# (119, "pepper"),
# (114, "carrot"),
# (113, "turnip"),
# (102, "onion"),
# (101, "tofu"),
# (100, "cabbage"),
# (93, "mushroom"),
# (90, "cucumber"),
# (88, "potato"),
# (80, "celery")
# Please also try the other Kata in this series..
#
# Help Suzuki purchase his Tofu!
# Help Suzuki pack his coal basket!
# Help Suzuki rake his garden!
# Suzuki needs help lining up his students!
# How many stairs will Suzuki climb in 20 years?
# FUNDAMENTALS
def count_vegetables(string):
    string = string.split()
    ans, s = [], {"cabbage", "carrot", "celery",
                     "cucumber", "mushroom", "onion",
                     "pepper", "potato", "tofu", "turnip"}
    ans = [(string.count(i), i) for i in set(string) if i in s]
    return sorted(ans, key=lambda x: (x[0], x[1]), reverse=True)

# 1441. Build an Array With Stack Operations
# You are given an integer array target and an integer n.
#
# You have an empty stack with the two following operations:
#
# "Push": pushes an integer to the top of the stack.
# "Pop": removes the integer on the top of the stack.
# You also have a stream of the integers in the range [1, n].
#
# Use the two stack operations to make the numbers in the stack (from the bottom to the top) equal to target. You should follow the following rules:
#
# If the stream of the integers is not empty, pick the next integer from the stream and push it to the top of the stack.
# If the stack is not empty, pop the integer at the top of the stack.
# If, at any moment, the elements in the stack (from the bottom to the top) are equal to target, do not read new integers from the stream and do not do more operations on the stack.
# Return the stack operations needed to build target following the mentioned rules. If there are multiple valid answers, return any of them.
#
#
#
# Example 1:
#
# Input: target = [1,3], n = 3
# Output: ["Push","Push","Pop","Push"]
# Explanation: Initially the stack s is empty. The last element is the top of the stack.
# Read 1 from the stream and push it to the stack. s = [1].
# Read 2 from the stream and push it to the stack. s = [1,2].
# Pop the integer on the top of the stack. s = [1].
# Read 3 from the stream and push it to the stack. s = [1,3].
# Example 2:
#
# Input: target = [1,2,3], n = 3
# Output: ["Push","Push","Push"]
# Explanation: Initially the stack s is empty. The last element is the top of the stack.
# Read 1 from the stream and push it to the stack. s = [1].
# Read 2 from the stream and push it to the stack. s = [1,2].
# Read 3 from the stream and push it to the stack. s = [1,2,3].
# Example 3:
#
# Input: target = [1,2], n = 4
# Output: ["Push","Push"]
# Explanation: Initially the stack s is empty. The last element is the top of the stack.
# Read 1 from the stream and push it to the stack. s = [1].
# Read 2 from the stream and push it to the stack. s = [1,2].
# Since the stack (from the bottom to the top) is equal to target, we stop the stack operations.
# The answers that read integer 3 from the stream are not accepted.
#
#
# Constraints:
#
# 1 <= target.length <= 100
# 1 <= n <= 100
# 1 <= target[i] <= n
# target is strictly increasing.
class Solution(object):
    def buildArray(self, target, n):
        que, top = [], 0
        for i in range(1, n + 1):
            if top == len(target):
                break
            que.append('Push')
            if i == target[top]:
                top += 1
            else:
                que.append('Pop')
        return que

# Thinkful - Logic Drills: Graceful addition
# You like the way the Python + operator easily handles adding different numeric types, but you need a tool to do that kind of addition without killing your program with a TypeError exception whenever you accidentally try adding incompatible types like strings and lists to numbers.
#
# You decide to write a function my_add() that takes two arguments. If the arguments can be added together it returns the sum. If adding the arguments together would raise an error the function should return None instead.
#
# For example, my_add(1, 3.414) would return 4.414, but my_add(42, " is the answer.") would return None.
#
# Hint: using a try / except statement may simplify this kata.
#
# FUNDAMENTALS
def my_add(a, b):
    try:
        return a + b
    except:
        return

# 171. Excel Sheet Column Number
# Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number.
#
# For example:
#
# A -> 1
# B -> 2
# C -> 3
# ...
# Z -> 26
# AA -> 27
# AB -> 28
# ...
#
#
# Example 1:
#
# Input: columnTitle = "A"
# Output: 1
# Example 2:
#
# Input: columnTitle = "AB"
# Output: 28
# Example 3:
#
# Input: columnTitle = "ZY"
# Output: 701
#
#
# Constraints:
#
# 1 <= columnTitle.length <= 7
# columnTitle consists only of uppercase English letters.
# columnTitle is in the range ["A", "FXSHRXW"].
class Solution(object):
    def titleToNumber(self, chars):
        if len(chars) == 1:
            return ord(chars) - 64
        return (ord(chars[0]) - 64) * (26 ** (len(chars) - 1)) + self.titleToNumber(chars[1:])

# 80's Kids #2: Help ALF Find His Spaceship
# Late last night in the Tanner household, ALF was repairing his spaceship so he might get back to Melmac. Unfortunately for him, he forgot to put on the parking brake, and the spaceship took off during repair. Now it's hovering in space.
#
# ALF has the technology to bring the spaceship home if he can lock on to its location.
#
# Given a map:
#
# ..........
# ..........
# ..........
# .......X..
# ..........
# ..........
# The map will be given in the form of a string with \n separating new lines. The bottom left of the map is [0, 0]. X is ALF's spaceship.
#
# In this example:
#
# findSpaceship(map) => [7, 2]
# If you cannot find the spaceship, the result should be
#
# "Spaceship lost forever."
# Can you help ALF?
#
# Check out my other 80's Kids Katas:
# 80's Kids #1: How Many Licks Does It Take
# 80's Kids #2: Help Alf Find His Spaceship
#
# 80's Kids #3: Punky Brewster's Socks
#
# 80's Kids #4: Legends of the Hidden Temple
#
# 80's Kids #5: You Can't Do That on Television
#
# 80's Kids #6: Rock 'Em, Sock 'Em Robots
#
# 80's Kids #7: She's a Small Wonder
#
# 80's Kids #8: The Secret World of Alex Mack
#
# 80's Kids #9: Down in Fraggle Rock
#
# 80's Kids #10: Captain Planet
#
# ARRAYSALGORITHMS
def find_spaceship(astromap):
    if 'X' not in astromap:
        return 'Spaceship lost forever.'
    astromap = astromap.split('\n')
    for i in astromap:
        if 'X' in i:
            return [i.index('X'), len(astromap) - (astromap.index(i) + 1)]

# 1535. Find the Winner of an Array Game
# Given an integer array arr of distinct integers and an integer k.
#
# A game will be played between the first two elements of the array (i.e. arr[0] and arr[1]). In each round of the game, we compare arr[0] with arr[1], the larger integer wins and remains at position 0, and the smaller integer moves to the end of the array. The game ends when an integer wins k consecutive rounds.
#
# Return the integer which will win the game.
#
# It is guaranteed that there will be a winner of the game.
#
#
#
# Example 1:
#
# Input: arr = [2,1,3,5,4,6,7], k = 2
# Output: 5
# Explanation: Let's see the rounds of the game:
# Round |       arr       | winner | win_count
#   1   | [2,1,3,5,4,6,7] | 2      | 1
#   2   | [2,3,5,4,6,7,1] | 3      | 1
#   3   | [3,5,4,6,7,1,2] | 5      | 1
#   4   | [5,4,6,7,1,2,3] | 5      | 2
# So we can see that 4 rounds will be played and 5 is the winner because it wins 2 consecutive games.
# Example 2:
#
# Input: arr = [3,2,1], k = 10
# Output: 3
# Explanation: 3 will win the first 10 rounds consecutively.
#
#
# Constraints:
#
# 2 <= arr.length <= 105
# 1 <= arr[i] <= 106
# arr contains distinct integers.
# 1 <= k <= 109
# Solution 1 - Speed O(N) / Memory O(1)
class Solution(object):
    def getWinner(self, arr, k):
        top, count = arr[0], 0
        for i in range(1, len(arr)):
            if arr[i] > top:
                top, count = arr[i], 0
            count += 1
            if count == k:
                break
        return top
# Solution 2 - Speed O(N) / Memory O(N * N)
class Solution(object):
    def getWinner(self, arr, k):
        if k >= len(arr):
            return max(arr)
        from collections import defaultdict
        d = defaultdict(int)
        while True:
            x, y = arr[0], arr[1]
            if x > y:
                d[x] += 1
                arr.append(arr.pop(1))
            else:
                d[y] += 1
                arr.append(arr.pop(0))
            if d[arr[0]] == k:
                return arr[0]
            
# ⚠️Fusion Chamber Shutdown⚠️
# A laboratory is testing how atoms react in ionic state during nuclear fusion. They introduce different elements with Hydrogen in high temperature and pressurized chamber. Due to unknown reason the chamber lost its power and the elements in it started precipitating
# Given the number of atoms of Carbon [C],Hydrogen[H] and Oxygen[O] in the chamber. Calculate how many molecules of Water [H2O], Carbon Dioxide [CO2] and Methane [CH4] will be produced following the order of reaction affinity below
#
# 1. Hydrogen reacts with Oxygen   = H2O
# 2. Carbon   reacts with Oxygen   = CO2
# 3. Carbon   reacts with Hydrogen = CH4
# FOR EXAMPLE:
# (C,H,O) = (45,11,100)
# return no. of water, carbon dioxide and methane molecules
# Output should be like:
# (5,45,0)
# FUNDAMENTALS
# Make sure you follow the order of reaction
# output should be H2O,CO2,CH4
def burner(c,h,o):
    water = min(h // 2, o)
    h = max(h - water * 2, 0)
    o = max(o - water, 0)
    carbon = min(c, o // 2)
    o = max(o - carbon * 2, 0)
    c = max(c - carbon, 0)
    methane = min(c, h // 4)
    return (water, carbon, methane)

# Wealth equality, finally!
# The year is 2088 and the Radical Marxist Socialist People's Party (RMSPP) has just seized power in Brazil.
#
# Their first act in power is absolute wealth equality through coercive redistribution.
#
# Create a function that redistributes all wealth equally among all citizens.
#
# Wealth is represented as an array/list where every index is the wealth of a single citizen.
# The function should mutate the input such that every index has the same amount of wealth.
#
# See example:
#
# Input:
# [5, 10, 6]  >>> This represents:
#            # citizen 1 has wealth 5
#            # citizen 2 has wealth 10
#            # citizen 3 has wealth 6
# Should be after the test:
#  [7, 7, 7] >>> wealth has now been equally redistributed
# Info:
#
# MUTATE the input array/list, don't return anything
# Input is guaranteed to hold at least 1 citizen
# Wealth of a citizen will be an integer with minimum equal to 0 (negative wealth is not possible)
# Handling of floating point error will not be tested
# FUNDAMENTALSARRAYS
def redistribute_wealth(wealth):
    mean = sum(wealth) / len(wealth)
    if int(mean) == mean:
        mean = int(mean)
    for i in range(len(wealth)):
        wealth[i] = mean

# 1005. Maximize Sum Of Array After K Negations
# Given an integer array nums and an integer k, modify the array in the following way:
#
# choose an index i and replace nums[i] with -nums[i].
# You should apply this process exactly k times. You may choose the same index i multiple times.
#
# Return the largest possible sum of the array after modifying it in this way.
#
#
#
# Example 1:
#
# Input: nums = [4,2,3], k = 1
# Output: 5
# Explanation: Choose index 1 and nums becomes [4,-2,3].
# Example 2:
#
# Input: nums = [3,-1,0,2], k = 3
# Output: 6
# Explanation: Choose indices (1, 2, 2) and nums becomes [3,1,0,2].
# Example 3:
#
# Input: nums = [2,-3,-1,5,-4], k = 2
# Output: 13
# Explanation: Choose indices (1, 4) and nums becomes [2,3,-1,5,4].
#
#
# Constraints:
#
# 1 <= nums.length <= 104
# -100 <= nums[i] <= 100
# 1 <= k <= 104
class Solution(object):
    def largestSumAfterKNegations(self, nums, k):
        nums.sort()
        top, ind = float('inf'), 0
        for i in range(len(nums)):
            if nums[i] < 1:
                if k > 0:
                    nums[i] = -nums[i]
                    k -= 1
                else:
                    break
            if nums[i] < top:
                top, ind = nums[i], i
        while k > 0:
            nums[ind] = -nums[ind]
            k -= 1
        return sum(nums)
    
# Complete The Pattern #7 - Cyclical Permutation
# Task:
# You have to write a function pattern which creates the following pattern (See Examples) upto desired number of rows.
#
# If the Argument is 0 or a Negative Integer then it should return "" i.e. empty string.
#
# Examples:
# pattern(9):
#
# 123456789
# 234567891
# 345678912
# 456789123
# 567891234
# 678912345
# 789123456
# 891234567
# 912345678
# pattern(5):
#
# 12345
# 23451
# 34512
# 45123
# 51234
# Note: There are no spaces in the pattern
#
# Hint: Use \n in string to jump to next line
#
# ASCII ARTFUNDAMENTALS
def pattern(n):
    if n <= 0:
        return ''
    word, strng = [], [i for i in range(1, n + 1)]
    for i in range(n):
        word.append(''.join(str(i) for i in strng))
        strng = strng[1:] + [strng[0]]
    return '\n'.join(word)

# 2144. Minimum Cost of Buying Candies With Discount
# A shop is selling candies at a discount. For every two candies sold, the shop gives a third candy for free.
#
# The customer can choose any candy to take away for free as long as the cost of the chosen candy is less than or equal to the minimum cost of the two candies bought.
#
# For example, if there are 4 candies with costs 1, 2, 3, and 4, and the customer buys candies with costs 2 and 3, they can take the candy with cost 1 for free, but not the candy with cost 4.
# Given a 0-indexed integer array cost, where cost[i] denotes the cost of the ith candy, return the minimum cost of buying all the candies.
#
#
#
# Example 1:
#
# Input: cost = [1,2,3]
# Output: 5
# Explanation: We buy the candies with costs 2 and 3, and take the candy with cost 1 for free.
# The total cost of buying all candies is 2 + 3 = 5. This is the only way we can buy the candies.
# Note that we cannot buy candies with costs 1 and 3, and then take the candy with cost 2 for free.
# The cost of the free candy has to be less than or equal to the minimum cost of the purchased candies.
# Example 2:
#
# Input: cost = [6,5,7,9,2,2]
# Output: 23
# Explanation: The way in which we can get the minimum cost is described below:
# - Buy candies with costs 9 and 7
# - Take the candy with cost 6 for free
# - We buy candies with costs 5 and 2
# - Take the last remaining candy with cost 2 for free
# Hence, the minimum cost to buy all candies is 9 + 7 + 5 + 2 = 23.
# Example 3:
#
# Input: cost = [5,5]
# Output: 10
# Explanation: Since there are only 2 candies, we buy both of them. There is not a third candy we can take for free.
# Hence, the minimum cost to buy all candies is 5 + 5 = 10.
#
#
# Constraints:
#
# 1 <= cost.length <= 100
# 1 <= cost[i] <= 100
class Solution(object):
    def minimumCost(self, cost):
        cost.sort(reverse=True)
        count = 0
        for i in range(len(cost)):
            if (i + 1) % 3 == 0:
                continue
            count += cost[i]
        return count

# Remove B M W
# It happened decades before Snapchat, years before Twitter and even before Facebook. Targeted advertising was a bit of a challenge back then. One day, the marketing professor at my university told us a story that I am yet to confirm using reliable sources. Nevertheless, I retold the story to dozens of my students already, so, sorry BMW if it is all a big lie.
#
# Allegedly, BMW, in an attempt to target the educated, produced billboard posters featuring the English alphabet with three letters missing: B, M and W. Needless to say, many were confused, some to the extent of road accidents.
#
# Your task is to write a function that takes one parameter str that MUST be a string and removes all capital and small letters B, M and W.
# If data of the wrong data type was sent as a parameter the function must throw an error with the following specific message:
#
# TypeError("This program only works for text.")
# For Python here's a good resource you might need for the exception type ;)
#
# FUNDAMENTALSSTRINGSREGULAR EXPRESSIONS
def remove_bmw(string):
    try:
        return string.replace('B', '').replace('M', '').replace('W', '').replace('b', '').replace('m', '').replace('w', '')
    except:
        return "This program only works for text."
    
# 2047. Number of Valid Words in a Sentence
# A sentence consists of lowercase letters ('a' to 'z'), digits ('0' to '9'), hyphens ('-'), punctuation marks ('!', '.', and ','), and spaces (' ') only. Each sentence can be broken down into one or more tokens separated by one or more spaces ' '.
#
# A token is a valid word if all three of the following are true:
#
# It only contains lowercase letters, hyphens, and/or punctuation (no digits).
# There is at most one hyphen '-'. If present, it must be surrounded by lowercase characters ("a-b" is valid, but "-ab" and "ab-" are not valid).
# There is at most one punctuation mark. If present, it must be at the end of the token ("ab,", "cd!", and "." are valid, but "a!b" and "c.," are not valid).
# Examples of valid words include "a-b.", "afad", "ba-c", "a!", and "!".
#
# Given a string sentence, return the number of valid words in sentence.
#
#
#
# Example 1:
#
# Input: sentence = "cat and  dog"
# Output: 3
# Explanation: The valid words in the sentence are "cat", "and", and "dog".
# Example 2:
#
# Input: sentence = "!this  1-s b8d!"
# Output: 0
# Explanation: There are no valid words in the sentence.
# "!this" is invalid because it starts with a punctuation mark.
# "1-s" and "b8d" are invalid because they contain digits.
# Example 3:
#
# Input: sentence = "alice and  bob are playing stone-game10"
# Output: 5
# Explanation: The valid words in the sentence are "alice", "and", "bob", "are", and "playing".
# "stone-game10" is invalid because it contains digits.
#
#
# Constraints:
#
# 1 <= sentence.length <= 1000
# sentence only contains lowercase English letters, digits, ' ', '-', '!', '.', and ','.
# There will be at least 1 token.
class Solution(object):
    def countValidWords(self, sentence):
        count = 0
        for word in sentence.split():
            top = True
            if len(word) == 1:
                if all(i not in word for i in '01234567489-'):
                    count += 1
                    print(word, 'len 1')
                    continue
            if word.count('!') + word.count(',') + word.count('.') > 1:
                top = False
            if any(word.count(i) > 0 for i in '!,.'):
                if word[-1] not in '!,.':
                    top = False
            if '-' in word:
                if word.count('-') > 1 or word[-1] == '-' or word[0] == '-':
                    top = False
                else:
                    x = word.index('-') 
                    if not word[x-1].isalpha() or not word[x + 1].isalpha():
                        top = False
            if any(i in word for i in '0123456789'):
                top = False
            if top:
                count += 1
        return count
    
# Count cubes in a Menger Sponge
# The Menger Sponge is a three-dimensional fractal, first described by Karl Menger in 1926.
#
# Mengers Sponge (Level 0-3)
#
# An illustration of the iterative construction of a Menger sponge
# A method of constructing a Menger Sponge can be visualized as follows:
#
# Start from a cube (first part of image).
# Scale down the cube so that side length is 1/3 of its original, and make 20 copies of it.
# Place the copies so that they measure the same size as the original cube but without its central parts (next part of image)
# Repeat the process from step 2 for the new smaller cubes from the previous step.
# In each iteration (e.g. repeating the last three steps), the effect will be that parts of the cube will be removed, they'll never be added. Menger sponge will always consist of parts will never be removed, regardless of how many iterations you do.
# An alternative explanation:
#
# Start from a cube (first part of image).
# Devide each cube into 27 equal sized cubes.
# Remove the middle-cube and the six cubes on each side of the group of 27 cubes (second part of image).
# Repeat the process from step 2 for the smaller cubes (third and fourth part of image).
# Task
# In this kata you will create a function that takes non negative integers (from 0 to n) and return the amount of cubes that the Menger Sponge would have in that specific iteration.
#
# Example
# For n = 0, the ouptut should be 1;
# For n = 1, the output should be 20;
# For n = 2, the output should be 400;
# For n = 3, the output should be 8000;
# for n = 4, the output should be 160000;
# For n = 5, the output should be 3200000;
# For n = 6, the output should be 64000000.
# Happy coding!
#
# ALGORITHMSMATHEMATICS
def calc_ms(n):
    return 20 ** n

# Happy Birthday
# It's your best friend's birthday! You already bought a box for the present. Now you want to pack the present in the box. You want to decorate the box with a ribbon and a bow.
#
# But how much cm of ribbon do you need?
#
# Write the method wrap that calculates that!
#
# A box has a height, a width and a length (in cm). The ribbon is crossed on the side with the largest area. Opposite this side (also the side with the largest area) the loop is bound, calculate with 20 cm more tape.
#
#   wrap(17,32,11) => 162
#   wrap(13,13,13) => 124
#   wrap(1,3,1) => 32
# Notes:
# height, width and length will always be >0
#
# The ribbon and the bow on the present looks like this:
#
#
# FUNDAMENTALS
def wrap(h, w, l):
    l = [h, w, l]
    l.sort()
    return l[0] * 4 + l[1] * 2 + l[2] * 2 + 20

# 1759. Count Number of Homogenous Substrings
# Given a string s, return the number of homogenous substrings of s. Since the answer may be too large, return it modulo 109 + 7.
#
# A string is homogenous if all the characters of the string are the same.
#
# A substring is a contiguous sequence of characters within a string.
#
#
#
# Example 1:
#
# Input: s = "abbcccaa"
# Output: 13
# Explanation: The homogenous substrings are listed as below:
# "a"   appears 3 times.
# "aa"  appears 1 time.
# "b"   appears 2 times.
# "bb"  appears 1 time.
# "c"   appears 3 times.
# "cc"  appears 2 times.
# "ccc" appears 1 time.
# 3 + 1 + 2 + 1 + 3 + 2 + 1 = 13.
# Example 2:
#
# Input: s = "xy"
# Output: 2
# Explanation: The homogenous substrings are "x" and "y".
# Example 3:
#
# Input: s = "zzzzz"
# Output: 15
#
#
# Constraints:
#
# 1 <= s.length <= 105
# s consists of lowercase letters.
class Solution(object):
    def countHomogenous(self, s):
        count, top = 0, 1
        for i in range(len(s)):
            if i == len(s) - 1:
                count += (top * (top + 1) // 2) % (10 ** 9 + 7)
                break
            if s[i] == s[i + 1]:
                top += 1
            else:
                count += (top * (top + 1) // 2) % (10 ** 9 + 7)
                top = 1
        return count

# Thinkful - Object Drills: Vectors
# Create a Vector class with x and a y attributes that represent component magnitudes in the x and y directions.
#
# Your vectors should handle vector additon with an .add() method that takes a second vector as an argument and returns a new vector equal to the sum of the vector you call .add() on and the vector you pass in.
#
# For example:
#
# >>> a = Vector(3, 4)
# >>> a.x
# 3
# >>> a.y
# 4
# >>> b = Vector(1, 2)
# >>> c = a.add(b)
# >>> c.x
# 4
# >>> c.y
# 6
# Adding vectors when you have their components is easy: just add the two x components together and the two y components together to get the x and y components for the vector sum.
#
# FUNDAMENTALS
class Vector(object):
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def add(self, v):
        return Vector(self.x + v.x, self.y + v.y)

# 2614. Prime In Diagonal
# You are given a 0-indexed two-dimensional integer array nums.
#
# Return the largest prime number that lies on at least one of the diagonals of nums. In case, no prime is present on any of the diagonals, return 0.
#
# Note that:
#
# An integer is prime if it is greater than 1 and has no positive integer divisors other than 1 and itself.
# An integer val is on one of the diagonals of nums if there exists an integer i for which nums[i][i] = val or an i for which nums[i][nums.length - i - 1] = val.
#
#
# In the above diagram, one diagonal is [1,5,9] and another diagonal is [3,5,7].
#
#
#
# Example 1:
#
# Input: nums = [[1,2,3],[5,6,7],[9,10,11]]
# Output: 11
# Explanation: The numbers 1, 3, 6, 9, and 11 are the only numbers present on at least one of the diagonals. Since 11 is the largest prime, we return 11.
# Example 2:
#
# Input: nums = [[1,2,3],[5,17,7],[9,11,10]]
# Output: 17
# Explanation: The numbers 1, 3, 9, 10, and 17 are all present on at least one of the diagonals. 17 is the largest prime, so we return 17.
#
#
# Constraints:
#
# 1 <= nums.length <= 300
# nums.length == numsi.length
# 1 <= nums[i][j] <= 4*106
class Solution(object):
    def diagonalPrime(self, nums):
        def is_prime(N):
            if N < 2:
                return False
            count = 2
            while count ** 2 <= N:
                if N % count == 0:
                    return False
                count = count + 1
            return True
        top, n = 0, len(nums)
        for i in range(n):
            if is_prime(nums[i][i]):
                top = max(nums[i][i], top)
            if is_prime(nums[i][n -i - 1]):
                top = max(nums[i][n -i - 1], top)
        return top
    
# Simple Fun #40: Timed Reading
# Task
# Timed Reading is an educational tool used in many schools to improve and advance reading skills. A young elementary student has just finished his very first timed reading exercise. Unfortunately he's not a very good reader yet, so whenever he encountered a word longer than maxLength, he simply skipped it and read on.
#
# Help the teacher figure out how many words the boy has read by calculating the number of words in the text he has read, no longer than maxLength.
#
# Formally, a word is a substring consisting of English letters, such that characters to the left of the leftmost letter and to the right of the rightmost letter are not letters.
#
# Example
# For maxLength = 4 and text = "The Fox asked the stork, 'How is the soup?'", the output should be 7
#
# The boy has read the following words: "The", "Fox", "the", "How", "is", "the", "soup".
#
# Input/Output
# [input] integer maxLength
#
# A positive integer, the maximum length of the word the boy can read.
#
# Constraints: 1 ≤ maxLength ≤ 10.
#
# [input] string text
#
# A non-empty string of English letters and punctuation marks.
#
# [output] an integer
#
# The number of words the boy has read.
#
# PUZZLES
def timed_reading(max_length, text):
    l = []
    for i in text.split():
        while i and not i[-1].isalpha():
            i = i[:-1]
        if i:
            l.append(i)
    return sum(len(i) <= max_length for i in l)

# 1683. Invalid Tweets
# Table: Tweets
#
# +----------------+---------+
# | Column Name    | Type    |
# +----------------+---------+
# | tweet_id       | int     |
# | content        | varchar |
# +----------------+---------+
# tweet_id is the primary key (column with unique values) for this table.
# This table contains all the tweets in a social media app.
#
#
# Write a solution to find the IDs of the invalid tweets. The tweet is invalid if the number of characters used in the content of the tweet is strictly greater than 15.
#
# Return the result table in any order.
#
# The result format is in the following example.
#
#
#
# Example 1:
#
# Input:
# Tweets table:
# +----------+----------------------------------+
# | tweet_id | content                          |
# +----------+----------------------------------+
# | 1        | Vote for Biden                   |
# | 2        | Let us make America great again! |
# +----------+----------------------------------+
# Output:
# +----------+
# | tweet_id |
# +----------+
# | 2        |
# +----------+
# Explanation:
# Tweet 1 has length = 14. It is a valid tweet.
# Tweet 2 has length = 32. It is an invalid tweet.
# Solution PostrgreSQL
-- Write your PostgreSQL query statement below
SELECT tweet_id
FROM Tweets
WHERE LENGTH(content) > 15;
# Solution MySQL
# Write your MySQL query statement below
SELECT tweet_id
FROM Tweets
WHERE LENGTH(content) > 15;

# Complete The Pattern #5 - Even Ladder
# Task:
# You have to write a function pattern which creates the following pattern up to n/2 number of lines.
#
# If n <= 1 then it should return "" (i.e. empty string).
# If any odd number is passed as argument then the pattern should last up to the largest even number which is smaller than the passed odd number.
# Examples:
# pattern(8):
#
# 22
# 4444
# 666666
# 88888888
# pattern(5):
#
# 22
# 4444
# Note: There are no spaces in the pattern
#
# Hint: Use \n in string to jump to next line
#
# ASCII ARTFUNDAMENTALS
def pattern(n):
    if n <= 1:
        return ''
    top, x = [], 2
    while n % 2 != 0:
        n -= 1
    for i in range(2, n + 1, 2):
        top.append(str(i) * x)
        x += 2
    return '\n'.join(top)

# 2678. Number of Senior Citizens
# You are given a 0-indexed array of strings details. Each element of details provides information about a given passenger compressed into a string of length 15. The system is such that:
#
# The first ten characters consist of the phone number of passengers.
# The next character denotes the gender of the person.
# The following two characters are used to indicate the age of the person.
# The last two characters determine the seat allotted to that person.
# Return the number of passengers who are strictly more than 60 years old.
#
#
#
# Example 1:
#
# Input: details = ["7868190130M7522","5303914400F9211","9273338290F4010"]
# Output: 2
# Explanation: The passengers at indices 0, 1, and 2 have ages 75, 92, and 40. Thus, there are 2 people who are over 60 years old.
# Example 2:
#
# Input: details = ["1313579440F2036","2921522980M5644"]
# Output: 0
# Explanation: None of the passengers are older than 60.
#
#
# Constraints:
#
# 1 <= details.length <= 100
# details[i].length == 15
# details[i] consists of digits from '0' to '9'.
# details[i][10] is either 'M' or 'F' or 'O'.
# The phone numbers and seat numbers of the passengers are distinct.
class Solution(object):
    def countSeniors(self, details):
        return sum(i[-4:-2] > '60' for i in details)


# Multi-tap Keypad Text Entry on an Old Mobile Phone
# Prior to having fancy iPhones, teenagers would wear out their thumbs sending SMS messages on candybar-shaped feature phones with 3x4 numeric keypads.
#
# ------- ------- -------
# |     | | ABC | | DEF |
# |  1  | |  2  | |  3  |
# ------- ------- -------
# ------- ------- -------
# | GHI | | JKL | | MNO |
# |  4  | |  5  | |  6  |
# ------- ------- -------
# ------- ------- -------
# |PQRS | | TUV | | WXYZ|
# |  7  | |  8  | |  9  |
# ------- ------- -------
# ------- ------- -------
# |  *  | |space| |  #  |
# |     | |  0  | |     |
# ------- ------- -------
# Prior to the development of T9 systems (predictive text entry), the method to type words was called "multi-tap" and involved pressing a button repeatedly to cycle through all its possible values, in order. For example:
#
# Pressing the button 7 repeatedly will cycle through the letters P -> Q -> R -> S -> 7 -> P -> ....
# Pressing the button 0 is cycling through SPACE -> 0 -> SPACE -> 0 -> ....
# Buttons with a single symbol on it just type this symbol.
# A character is "locked in" and inserted into the message once the user presses a different key or pauses for a short period of time (thus, no extra button presses are required beyond what is needed for each letter individually). For example:
#
# To type a letter "R" you would press the 7 key three times (as the screen display for the current character cycles through P->Q->R->S->7).
# To type in a digit 3, you would press the button 3 four times.
# To type in the message "ABC", you would press the button 2 once, wait a second, then press the button 2 twice to enter the letter B, then pause for another second, and press the button 2 three times, to enter the letter C. You would have to press the button 2 six times in total.
# In order to send the message "WHERE DO U WANT 2 MEET L8R" a teen would have to actually do 47 button presses. No wonder they abbreviated...
#
# For this assignment, write code that can calculate the amount of button presses required for any phrase, with the following requirements:
#
# Punctuation can be ignored for this exercise.
# Likewise, the phone doesn't distinguish between upper and lowercase characters (but you should allow your module to accept input in either form, for convenience).
# Tested phrases contain letters (A-Z and a-z), digits (0-9), and special characters # and *.
# FUNDAMENTALS
def presses(phrase):
    l = ['1', 'ABC2', 'DEF3', 'GHI4', 'JKL5', 'MNO6', 'PQRS7',
        'TUV8', 'WXYZ9', '*', ' 0', '#']
    top = 0
    phrase = phrase.upper()
    for char in phrase:
        for but in l:
            if char in but:
                top += but.index(char) + 1
    return top

# 2785. Sort Vowels in a String
# Given a 0-indexed string s, permute s to get a new string t such that:
#
# All consonants remain in their original places. More formally, if there is an index i with 0 <= i < s.length such that s[i] is a consonant, then t[i] = s[i].
# The vowels must be sorted in the nondecreasing order of their ASCII values. More formally, for pairs of indices i, j with 0 <= i < j < s.length such that s[i] and s[j] are vowels, then t[i] must not have a higher ASCII value than t[j].
# Return the resulting string.
#
# The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in lowercase or uppercase. Consonants comprise all letters that are not vowels.
#
#
#
# Example 1:
#
# Input: s = "lEetcOde"
# Output: "lEOtcede"
# Explanation: 'E', 'O', and 'e' are the vowels in s; 'l', 't', 'c', and 'd' are all consonants. The vowels are sorted according to their ASCII values, and the consonants remain in the same places.
# Example 2:
#
# Input: s = "lYmpH"
# Output: "lYmpH"
# Explanation: There are no vowels in s (all characters in s are consonants), so we return "lYmpH".
#
#
# Constraints:
#
# 1 <= s.length <= 105
# s consists only of letters of the English alphabet in uppercase and lowercase.
class Solution(object):
    def sortVowels(self, s):
        word, l = '', []
        for i in s:
            if i.lower() in {'a', 'e', 'i', 'o', 'u'}:
                l.append(i)
        top = 0
        l.sort()
        for i in s:
            if i.lower() not in {'a', 'e', 'i', 'o', 'u'}:
                word += i
            else:
                word += l[top]
                top += 1
        return word

# Don't rely on luck.
# The test fixture I use for this kata is pre-populated.
#
# It will compare your guess to a random number generated using:
#
# randint(1,100)
# You can pass by relying on luck or skill but try not to rely on luck.
#
# "The power to define the situation is the ultimate power." - Jerry Rubin
#
# Good luck!
#
# GAMESPUZZLES
from random import randint,seed
seed(1)
guess = randint(1,100)
seed(1)

# 1652. Defuse the Bomb
# You have a bomb to defuse, and your time is running out! Your informer will provide you with a circular array code of length of n and a key k.
#
# To decrypt the code, you must replace every number. All the numbers are replaced simultaneously.
#
# If k > 0, replace the ith number with the sum of the next k numbers.
# If k < 0, replace the ith number with the sum of the previous k numbers.
# If k == 0, replace the ith number with 0.
# As code is circular, the next element of code[n-1] is code[0], and the previous element of code[0] is code[n-1].
#
# Given the circular array code and an integer key k, return the decrypted code to defuse the bomb!
#
#
#
# Example 1:
#
# Input: code = [5,7,1,4], k = 3
# Output: [12,10,16,13]
# Explanation: Each number is replaced by the sum of the next 3 numbers. The decrypted code is [7+1+4, 1+4+5, 4+5+7, 5+7+1]. Notice that the numbers wrap around.
# Example 2:
#
# Input: code = [1,2,3,4], k = 0
# Output: [0,0,0,0]
# Explanation: When k is zero, the numbers are replaced by 0.
# Example 3:
#
# Input: code = [2,4,9,3], k = -2
# Output: [12,5,6,13]
# Explanation: The decrypted code is [3+9, 2+3, 4+2, 9+4]. Notice that the numbers wrap around again. If k is negative, the sum is of the previous numbers.
#
#
# Constraints:
#
# n == code.length
# 1 <= n <= 100
# 1 <= code[i] <= 100
# -(n - 1) <= k <= n - 1
class Solution(object):
    def decrypt(self, code, k):
        if k == 0:
          return [0] * len(code)
        l, code = [], code * 2
        for i in range(len(code) // 2):
          if k > 0:
            l.append(sum(code[i + 1:i + k + 1]))
          else:
            x = i + len(code) // 2 - 1
            l.append(sum(code[x: x + k: -1]))
        return l
    
# Linked Lists - Length & Count
# Linked Lists - Length & Count
#
# Implement Length() to count the number of nodes in a linked list.
#
# length(null) => 0
# length(1 -> 2 -> 3 -> null) => 3
# Implement Count() to count the occurrences of an integer in a linked list.
#
# count(null, 1) => 0
# count(1 -> 2 -> 3 -> null, 1) => 1
# count(1 -> 1 -> 1 -> 2 -> 2 -> 2 -> 2 -> 3 -> 3 -> null, 2) => 4
# I've decided to bundle these two functions within the same Kata since they are both very similar.
#
# The push()/Push() and buildOneTwoThree()/BuildOneTwoThree() functions do not need to be redefined.
#
# Related Kata in order of expected completion (increasing difficulty):
# Linked Lists - Push & BuildOneTwoThree
# Linked Lists - Length & Count
# Linked Lists - Get Nth Node
# Linked Lists - Insert Nth Node
# Linked Lists - Sorted Insert
# Linked Lists - Insert Sort
# Linked Lists - Append
# Linked Lists - Remove Duplicates
# Linked Lists - Move Node
# Linked Lists - Move Node In-place
# Linked Lists - Alternating Split
# Linked Lists - Front Back Split
# Linked Lists - Shuffle Merge
# Linked Lists - Sorted Merge
# Linked Lists - Merge Sort
# Linked Lists - Sorted Intersect
# Linked Lists - Iterative Reverse
# Linked Lists - Recursive Reverse
#
# Inspired by Stanford Professor Nick Parlante's excellent Linked List teachings.
#
# LINKED LISTSDATA STRUCTURESFUNDAMENTALS
class Node(object):
    def __init__(self, data):
        self.data = data
        self.next = None


def length(node):
    count = 0
    while node:
        count += 1
        node = node.next
    return count


def count(node, data):
    count = 0
    while node:
        if node.data == data:
            count += 1
        node = node.next
    return count

# 1846. Maximum Element After Decreasing and Rearranging
# You are given an array of positive integers arr. Perform some operations (possibly none) on arr so that it satisfies these conditions:
#
# The value of the first element in arr must be 1.
# The absolute difference between any 2 adjacent elements must be less than or equal to 1. In other words, abs(arr[i] - arr[i - 1]) <= 1 for each i where 1 <= i < arr.length (0-indexed). abs(x) is the absolute value of x.
# There are 2 types of operations that you can perform any number of times:
#
# Decrease the value of any element of arr to a smaller positive integer.
# Rearrange the elements of arr to be in any order.
# Return the maximum possible value of an element in arr after performing the operations to satisfy the conditions.
#
#
#
# Example 1:
#
# Input: arr = [2,2,1,2,1]
# Output: 2
# Explanation:
# We can satisfy the conditions by rearranging arr so it becomes [1,2,2,2,1].
# The largest element in arr is 2.
# Example 2:
#
# Input: arr = [100,1,1000]
# Output: 3
# Explanation:
# One possible way to satisfy the conditions is by doing the following:
# 1. Rearrange arr so it becomes [1,100,1000].
# 2. Decrease the value of the second element to 2.
# 3. Decrease the value of the third element to 3.
# Now arr = [1,2,3], which satisfies the conditions.
# The largest element in arr is 3.
# Example 3:
#
# Input: arr = [1,2,3,4,5]
# Output: 5
# Explanation: The array already satisfies the conditions, and the largest element is 5.
#
#
# Constraints:
#
# 1 <= arr.length <= 105
# 1 <= arr[i] <= 109
class Solution(object):
    def maximumElementAfterDecrementingAndRearranging(self, arr):
        arr.sort()
        top = 0
        for i in arr:
            top = min(top + 1, i)
        return top

# What century is it?
# Return the century of the input year. The input will always be a 4 digit string, so there is no need for validation.
#
# Examples
# "1999" --> "20th"
# "2011" --> "21st"
# "2154" --> "22nd"
# "2259" --> "23rd"
# "1124" --> "12th"
# "2000" --> "20th"
# STRINGSALGORITHMSDATE TIME
def what_century(year):
    x = (int(year) - 1) // 100 + 1
    SUFFIXES = {1: 'st', 2: 'nd', 3: 'rd'}
    if 10 <= x % 100 <= 20:
        suffix = 'th'
    else:
        suffix = SUFFIXES.get(x % 10, 'th')
    return str(x) + suffix

# 1980. Find Unique Binary String
# Given an array of strings nums containing n unique binary strings each of length n, return a binary string of length n that does not appear in nums. If there are multiple answers, you may return any of them.
#
#
#
# Example 1:
#
# Input: nums = ["01","10"]
# Output: "11"
# Explanation: "11" does not appear in nums. "00" would also be correct.
# Example 2:
#
# Input: nums = ["00","01"]
# Output: "11"
# Explanation: "11" does not appear in nums. "10" would also be correct.
# Example 3:
#
# Input: nums = ["111","011","001"]
# Output: "101"
# Explanation: "101" does not appear in nums. "000", "010", "100", and "110" would also be correct.
#
#
# Constraints:
#
# n == nums.length
# 1 <= n <= 16
# nums[i].length == n
# nums[i] is either '0' or '1'.
# All the strings of nums are unique.
class Solution(object):
    def findDifferentBinaryString(self, nums):
        top = ''
        for i in range(len(nums)):
            top += '1' if nums[i][i] == '0' else '0'
        return top

# Ball Upwards
# You throw a ball vertically upwards with an initial speed v (in km per hour). The height h of the ball at each time t is given by h = v*t - 0.5*g*t*t where g is Earth's gravity (g ~ 9.81 m/s**2). A device is recording at every tenth of second the height of the ball. For example with v = 15 km/h the device gets something of the following form: (0, 0.0), (1, 0.367...), (2, 0.637...), (3, 0.808...), (4, 0.881..) ... where the first number is the time in tenth of second and the second number the height in meter.
#
# Task
# Write a function max_ball with parameter v (in km per hour) that returns the time in tenth of second of the maximum height recorded by the device.
#
# Examples:
# max_ball(15) should return 4
#
# max_ball(25) should return 7
#
# Notes
# Remember to convert the velocity from km/h to m/s or from m/s in km/h when necessary.
# The maximum height recorded by the device is not necessarily the maximum height reached by the ball.
# FUNDAMENTALS
def max_ball(v0):
    return round(10 * v0 / 9.81 / 3.6)

# 1877. Minimize Maximum Pair Sum in Array
# The pair sum of a pair (a,b) is equal to a + b. The maximum pair sum is the largest pair sum in a list of pairs.
#
# For example, if we have pairs (1,5), (2,3), and (4,4), the maximum pair sum would be max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8.
# Given an array nums of even length n, pair up the elements of nums into n / 2 pairs such that:
#
# Each element of nums is in exactly one pair, and
# The maximum pair sum is minimized.
# Return the minimized maximum pair sum after optimally pairing up the elements.
#
#
#
# Example 1:
#
# Input: nums = [3,5,2,3]
# Output: 7
# Explanation: The elements can be paired up into pairs (3,3) and (5,2).
# The maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.
# Example 2:
#
# Input: nums = [3,5,4,2,4,6]
# Output: 8
# Explanation: The elements can be paired up into pairs (3,5), (4,4), and (6,2).
# The maximum pair sum is max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8.
#
#
# Constraints:
#
# n == nums.length
# 2 <= n <= 105
# n is even.
# 1 <= nums[i] <= 105
# Solution 1 - Sort and Two Pointers
class Solution(object):
    def minPairSum(self, nums):
        nums.sort()
        x, y, top = 0, len(nums) - 1, 0
        while x < y:
            if nums[x] + nums[y] > top:
                top = nums[x] + nums[y]
            x += 1
            y -= 1
        return top
# Solution 2 - Sort and Two Pointers by One Pointer
class Solution(object):
    def minPairSum(self, nums):
        nums.sort()
        x, top = 0, 0
        while x < len(nums) / 2:
            top = max(top, nums[x] + nums[-x - 1])
            x += 1
        return top

# Coordinates Validator
# You need to create a function that will validate if given parameters are valid geographical coordinates.
#
# Valid coordinates look like the following: "23.32353342, -32.543534534". The return value should be either true or false.
#
# Latitude (which is first float) can be between 0 and 90, positive or negative. Longitude (which is second float) can be between 0 and 180, positive or negative.
#
# Coordinates can only contain digits, or one of the following symbols (including space after comma) __ -, . __
#
# There should be no space between the minus "-" sign and the digit after it.
#
# Here are some valid coordinates:
#
# -23, 25
# 24.53525235, 23.45235
# 04, -23.234235
# 43.91343345, 143
# 4, -3
# And some invalid ones:
#
# 23.234, - 23.4234
# 2342.43536, 34.324236
# N23.43345, E32.6457
# 99.234, 12.324
# 6.325624, 43.34345.345
# 0, 1,2
# 0.342q0832, 1.2324
# REGULAR EXPRESSIONSALGORITHMS
def is_valid_coordinates(coordinates):
    try:
        x, y = [abs(float(i)) for i in coordinates.split(',') if 'e' not in i]
    except:
        return False
    return x <= 90 and y <= 180

# 2932. Maximum Strong Pair XOR I
# You are given a 0-indexed integer array nums. A pair of integers x and y is called a strong pair if it satisfies the condition:
#
# |x - y| <= min(x, y)
# You need to select two integers from nums such that they form a strong pair and their bitwise XOR is the maximum among all strong pairs in the array.
#
# Return the maximum XOR value out of all possible strong pairs in the array nums.
#
# Note that you can pick the same integer twice to form a pair.
#
#
#
# Example 1:
#
# Input: nums = [1,2,3,4,5]
# Output: 7
# Explanation: There are 11 strong pairs in the array nums: (1, 1), (1, 2), (2, 2), (2, 3), (2, 4), (3, 3), (3, 4), (3, 5), (4, 4), (4, 5) and (5, 5).
# The maximum XOR possible from these pairs is 3 XOR 4 = 7.
# Example 2:
#
# Input: nums = [10,100]
# Output: 0
# Explanation: There are 2 strong pairs in the array nums: (10, 10) and (100, 100).
# The maximum XOR possible from these pairs is 10 XOR 10 = 0 since the pair (100, 100) also gives 100 XOR 100 = 0.
# Example 3:
#
# Input: nums = [5,6,25,30]
# Output: 7
# Explanation: There are 6 strong pairs in the array nums: (5, 5), (5, 6), (6, 6), (25, 25), (25, 30) and (30, 30).
# The maximum XOR possible from these pairs is 25 XOR 30 = 7 since the only other non-zero XOR value is 5 XOR 6 = 3.
#
#
# Constraints:
#
# 1 <= nums.length <= 50
# 1 <= nums[i] <= 100
class Solution(object):
    def maximumStrongPairXor(self, nums):
        top = 0
        for i in range(len(nums)):
            for j in range(i, len(nums)):
                if abs(nums[i] - nums[j]) <= min(nums[i], nums[j]):
                    top = max(top, nums[i] ^ nums[j])
        return top

# Can you get the loop ?
# You are given a node that is the beginning of a linked list. This list contains a dangling piece and a loop. Your objective is to determine the length of the loop.
#
# For example in the following picture the size of the dangling piece is 3 and the loop size is 12:
#
#
# # Use the `next' attribute to get the following node
# node.next
# Notes:
#
# do NOT mutate the nodes!
# in some cases there may be only a loop, with no dangling piece
# Thanks to shadchnev, I broke all of the methods from the Hash class.
#
# Don't miss dmitry's article in the discussion after you pass the Kata !!
#
# ALGORITHMSLINKED LISTSPERFORMANCE
# Solution 1 - Speed O(N) / Memory O(N)
def loop_size(node):
    d, top = {}, 0
    while node not in d:
        d[node] = top
        top += 1
        node = node.next
    return top - d[node]
# Solution 2 Speed O(N) / Memory O(1) FLoyd Algorithm
def loop_size(node):
    x, y = node.next, node.next.next
    while x != y:
        x, y = x.next, y.next.next
    count, y = 1, y.next
    while x != y:
        count += 1
        y = y.next
    return count

# 1887. Reduction Operations to Make the Array Elements Equal
# Given an integer array nums, your goal is to make all elements in nums equal. To complete one operation, follow these steps:
#
# Find the largest value in nums. Let its index be i (0-indexed) and its value be largest. If there are multiple elements with the largest value, pick the smallest i.
# Find the next largest value in nums strictly smaller than largest. Let its value be nextLargest.
# Reduce nums[i] to nextLargest.
# Return the number of operations to make all elements in nums equal.
#
#
#
# Example 1:
#
# Input: nums = [5,1,3]
# Output: 3
# Explanation: It takes 3 operations to make all elements in nums equal:
# 1. largest = 5 at index 0. nextLargest = 3. Reduce nums[0] to 3. nums = [3,1,3].
# 2. largest = 3 at index 0. nextLargest = 1. Reduce nums[0] to 1. nums = [1,1,3].
# 3. largest = 3 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [1,1,1].
# Example 2:
#
# Input: nums = [1,1,1]
# Output: 0
# Explanation: All elements in nums are already equal.
# Example 3:
#
# Input: nums = [1,1,2,2,3]
# Output: 4
# Explanation: It takes 4 operations to make all elements in nums equal:
# 1. largest = 3 at index 4. nextLargest = 2. Reduce nums[4] to 2. nums = [1,1,2,2,2].
# 2. largest = 2 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [1,1,1,2,2].
# 3. largest = 2 at index 3. nextLargest = 1. Reduce nums[3] to 1. nums = [1,1,1,1,2].
# 4. largest = 2 at index 4. nextLargest = 1. Reduce nums[4] to 1. nums = [1,1,1,1,1].
#
#
# Constraints:
#
# 1 <= nums.length <= 5 * 104
# 1 <= nums[i] <= 5 * 104
# Solution Speed - O(N log N) / Memory - O(1)
class Solution(object):
    def reductionOperations(self, nums):
        count, x = 0, 1
        nums.sort(reverse=True)
        while x < len(nums):
            if nums[x] != nums[x - 1]:
                count += x
            x += 1
        return count

# Closure Counter
# Closure Counter
# Define the function counter that returns a function that returns an increasing value.
# The first value should be 1.
# You're going to have to use closures.
# Example:
# const newCounter = counter();
# newCounter() // 1
# newCounter() // 2
# Closure:
# A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). In other words, a closure gives you access to an outer function’s scope from an inner function. In JavaScript, closures are created every time a function is created, at function creation time.
#
# https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures
#
# FUNDAMENTALS
def counter():
    i = 0
    def inscrease():
        nonlocal i
        i += 1
        return i
    return inscrease

# 2716. Minimize String Length
# Given a 0-indexed string s, repeatedly perform the following operation any number of times:
#
# Choose an index i in the string, and let c be the character in position i. Delete the closest occurrence of c to the left of i (if any) and the closest occurrence of c to the right of i (if any).
# Your task is to minimize the length of s by performing the above operation any number of times.
#
# Return an integer denoting the length of the minimized string.
#
#
#
# Example 1:
#
# Input: s = "aaabc"
# Output: 3
# Explanation: In this example, s is "aaabc". We can start by selecting the character 'a' at index 1. We then remove the closest 'a' to the left of index 1, which is at index 0, and the closest 'a' to the right of index 1, which is at index 2. After this operation, the string becomes "abc". Any further operation we perform on the string will leave it unchanged. Therefore, the length of the minimized string is 3.
# Example 2:
#
# Input: s = "cbbd"
# Output: 3
# Explanation: For this we can start with character 'b' at index 1. There is no occurrence of 'b' to the left of index 1, but there is one to the right at index 2, so we delete the 'b' at index 2. The string becomes "cbd" and further operations will leave it unchanged. Hence, the minimized length is 3.
# Example 3:
#
# Input: s = "dddaaa"
# Output: 2
# Explanation: For this, we can start with the character 'd' at index 1. The closest occurrence of a 'd' to its left is at index 0, and the closest occurrence of a 'd' to its right is at index 2. We delete both index 0 and 2, so the string becomes "daaa". In the new string, we can select the character 'a' at index 2. The closest occurrence of an 'a' to its left is at index 1, and the closest occurrence of an 'a' to its right is at index 3. We delete both of them, and the string becomes "da". We cannot minimize this further, so the minimized length is 2.
#
#
#
# Constraints:
#
# 1 <= s.length <= 100
# s contains only lowercase English letters
class Solution(object):
    def minimizedStringLength(self, s):
        return len(set(s))

# Make a square box!
# Easy; Make a box
# Given a number as a parameter (between 2 and 30), return an array containing strings which form a box.
# Like this:
#
# n = 5
#
# [
#   '-----',
#   '-   -',
#   '-   -',
#   '-   -',
#   '-----'
# ]
# n = 3
#
# [
#   '---',
#   '- -',
#   '---'
# ]
# STRINGSARRAYSASCII ARTALGORITHMS
def box(n):
    l = []
    for i in range(n):
        if i in {0, n -1}:
            l.append('-' * n)
        else:
            l.append('-' + ' ' * (n - 2) + '-')
    return l

# 1814. Count Nice Pairs in an Array
# You are given an array nums that consists of non-negative integers. Let us define rev(x) as the reverse of the non-negative integer x. For example, rev(123) = 321, and rev(120) = 21. A pair of indices (i, j) is nice if it satisfies all of the following conditions:
#
# 0 <= i < j < nums.length
# nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])
# Return the number of nice pairs of indices. Since that number can be too large, return it modulo 109 + 7.
#
#
#
# Example 1:
#
# Input: nums = [42,11,1,97]
# Output: 2
# Explanation: The two pairs are:
#  - (0,3) : 42 + rev(97) = 42 + 79 = 121, 97 + rev(42) = 97 + 24 = 121.
#  - (1,2) : 11 + rev(1) = 11 + 1 = 12, 1 + rev(11) = 1 + 11 = 12.
# Example 2:
#
# Input: nums = [13,10,35,24,76]
# Output: 4
#
#
# Constraints:
#
# 1 <= nums.length <= 105
# 0 <= nums[i] <= 109
class Solution(object):
    def countNicePairs(self, nums):
        d = {}
        for i in range(len(nums)):
            d[nums[i] - int(str(nums[i])[::-1])] = d.get(nums[i] - int(str(nums[i])[::-1]), 0) + 1
        return sum(val * (val - 1) // 2 for val in d.values()) % (10 ** 9 + 7)

# Spin Around, Touch the Ground
# Given a list of directions to spin, "left" or "right", return an integer of how many full 360° rotations were made. Note that each word in the array counts as a 90° rotation in that direction.
#
# Worked Example
# ["right", "right", "right", "right", "left", "right"] ➞ 1
# # You spun right 4 times (90 * 4 = 360)
# # You spun left once (360 - 90 = 270)
# # But you spun right once more to make a full rotation (270 + 90 = 360)
# Examples
# ["left", "right", "left", "right"] ➞ 0
#
# ["right", "right", "right", "right", "right", "right", "right", "right"] ➞ 2
#
# ["left", "left", "left", "left"] ➞ 1
# Notes
# Return a positive number.
# All tests will only include the words "right" and "left".
# ALGORITHMSARRAYS
def spin_around(lst):
    count = 0
    for i in lst:
        if i == 'left':
            count -= 1
        else:
            count += 1
    return abs(count) // 4

# 2169. Count Operations to Obtain Zero
# You are given two non-negative integers num1 and num2.
#
# In one operation, if num1 >= num2, you must subtract num2 from num1, otherwise subtract num1 from num2.
#
# For example, if num1 = 5 and num2 = 4, subtract num2 from num1, thus obtaining num1 = 1 and num2 = 4. However, if num1 = 4 and num2 = 5, after one operation, num1 = 4 and num2 = 1.
# Return the number of operations required to make either num1 = 0 or num2 = 0.
#
#
#
# Example 1:
#
# Input: num1 = 2, num2 = 3
# Output: 3
# Explanation:
# - Operation 1: num1 = 2, num2 = 3. Since num1 < num2, we subtract num1 from num2 and get num1 = 2, num2 = 3 - 2 = 1.
# - Operation 2: num1 = 2, num2 = 1. Since num1 > num2, we subtract num2 from num1.
# - Operation 3: num1 = 1, num2 = 1. Since num1 == num2, we subtract num2 from num1.
# Now num1 = 0 and num2 = 1. Since num1 == 0, we do not need to perform any further operations.
# So the total number of operations required is 3.
# Example 2:
#
# Input: num1 = 10, num2 = 10
# Output: 1
# Explanation:
# - Operation 1: num1 = 10, num2 = 10. Since num1 == num2, we subtract num2 from num1 and get num1 = 10 - 10 = 0.
# Now num1 = 0 and num2 = 10. Since num1 == 0, we are done.
# So the total number of operations required is 1.
#
#
# Constraints:
#
# 0 <= num1, num2 <= 105
# Solution 1 - Euclidean algorithm O(log min(num1, num2))
class Solution(object):
    def countOperations(self, num1, num2):
        return 0 if num1 * num2 == 0 else num1 // num2 + self.countOperations(num2, num1 % num2)
# Solution 2 O(max(num1, num2))
class Solution(object):
    def countOperations(self, num1, num2):
        count = 0
        while num1 != 0 and num2 != 0:
            if num1 >= num2:
                num1 = abs(num2 - num1)
            else:
                num2 = abs(num1 - num2)
            count += 1
        return count
    
# Doubleton number
# We will call a natural number a "doubleton number" if it contains exactly two distinct digits. For example, 23, 35, 100, 12121 are doubleton numbers, and 123 and 9980 are not.
#
# For a given natural number n (from 1 to 1 000 000), you need to find the next doubleton number. If n itself is a doubleton, return the next bigger than n.
#
# Examples:
# doubleton(120) == 121
# doubleton(1234) == 1311
# doubleton(10) == 12
# SETSFUNDAMENTALS
def doubleton(num):
    def check(n):
        d = {}
        for i in str(n):
            d[i] = d.get(i, 0) + 1
            if len(d) > 2:
                return False
        return len(d) in {2}
    num += 1
    while not check(num):
        num += 1
    return num

# 1018. Binary Prefix Divisible By 5
# You are given a binary array nums (0-indexed).
#
# We define xi as the number whose binary representation is the subarray nums[0..i] (from most-significant-bit to least-significant-bit).
#
# For example, if nums = [1,0,1], then x0 = 1, x1 = 2, and x2 = 5.
# Return an array of booleans answer where answer[i] is true if xi is divisible by 5.
#
#
#
# Example 1:
#
# Input: nums = [0,1,1]
# Output: [true,false,false]
# Explanation: The input numbers in binary are 0, 01, 011; which are 0, 1, and 3 in base-10.
# Only the first number is divisible by 5, so answer[0] is true.
# Example 2:
#
# Input: nums = [1,1,1]
# Output: [false,false,false]
#
#
# Constraints:
#
# 1 <= nums.length <= 105
# nums[i] is either 0 or 1.
class Solution(object):
    def prefixesDivBy5(self, nums):
        l, top = [True] * len(nums), 0
        for i in range(len(nums)):
            top = top * 2 + nums[i]
            l[i] = top % 5 == 0
        return l
    
# Uglify Word
# Summary
# In this kata, you have to make a function named uglify_word (uglifyWord in Java and Javascript). It accepts a string parameter.
# 
# What does the uglify_word do?
# It checks the char in the given string from the front with an iteration, in the iteration it does these steps:
# 
# There is a flag and it will be started from 1.
# Check the current char in the iteration index.
# If it is an alphabet character [a-zA-Z] and the flag value is equal to 1, then change this character to upper case.
# If it is an alphabet character [a-zA-Z] and the flag value is equal to 0, then change this character to lower case.
# Otherwise, if it is not an alphabet character, then set the flag value to 1.
# If the current char is an alphabet character, do a boolean not operation to the flag.
# After the iteration has done, return the fixed string that might have been changed in such iteration.
# 
# Examples
# uglify_word("aaa") === "AaA"
# uglify_word("AAA") === "AaA"
# uglify_word("BbB") === "BbB"
# uglify_word("aaa-bbb-ccc") === "AaA-BbB-CcC"
# uglify_word("AaA-BbB-CcC") === "AaA-BbB-CcC"
# uglify_word("eeee-ffff-gggg") === "EeEe-FfFf-GgGg"
# uglify_word("EeEe-FfFf-GgGg") === "EeEe-FfFf-GgGg"
# uglify_word("qwe123asdf456zxc") === "QwE123AsDf456ZxC"
# uglify_word("Hello World") === "HeLlO WoRlD"
# ALGORITHMS
def uglify_word(s):
    d = {0: lambda x: x.lower(), 1: lambda x: x.upper()}
    flag, word = 1, ''
    for i in s:
        if i.isalpha():
            word += d[flag](i)
            flag = not flag
        else:
            word += i
            flag = 1
    return word

# 728. Self Dividing Numbers
# A self-dividing number is a number that is divisible by every digit it contains.
#
# For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.
# A self-dividing number is not allowed to contain the digit zero.
#
# Given two integers left and right, return a list of all the self-dividing numbers in the range [left, right].
#
#
#
# Example 1:
#
# Input: left = 1, right = 22
# Output: [1,2,3,4,5,6,7,8,9,11,12,15,22]
# Example 2:
#
# Input: left = 47, right = 85
# Output: [48,55,66,77]
#
#
# Constraints:
#
# 1 <= left <= right <= 104
class Solution(object):
    def selfDividingNumbers(self, left, right):
        def check(n):
            x = str(n)
            if '0' in x:
                return False
            return all(n % int(i) == 0 for i in x)
        l = []
        for i in range(left, right + 1):
            if check(i):
                l.append(i)
        return l
    
# From A to Z
# Given a string indicating a range of letters, return a string which includes all the letters in that range, including the last letter. Note that if the range is given in capital letters, return the string in capitals also!
#
# Examples
# "a-z" ➞ "abcdefghijklmnopqrstuvwxyz"
# "h-o" ➞ "hijklmno"
# "Q-Z" ➞ "QRSTUVWXYZ"
# "J-J" ➞ "J"
# Notes
# A hyphen will separate the two letters in the string.
# You don't need to worry about error handling in this one (i.e. both letters will be the same case and the second letter will always be after the first alphabetically).
# ALGORITHMSSTRINGS
def gimme_the_letters(sp):
    al = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
    a, b = sp.split('-')
    return al[al.index(a): al.index(b) + 1]

# 1952. Three Divisors
# Given an integer n, return true if n has exactly three positive divisors. Otherwise, return false.
#
# An integer m is a divisor of n if there exists an integer k such that n = k * m.
#
#
#
# Example 1:
#
# Input: n = 2
# Output: false
# Explantion: 2 has only two divisors: 1 and 2.
# Example 2:
#
# Input: n = 4
# Output: true
# Explantion: 4 has three divisors: 1, 2, and 4.
#
#
# Constraints:
#
# 1 <= n <= 104
# Solution 1 Speed O(N // 2) Memory O(1)
class Solution(object):
    def isThree(self, n):
        count = 1
        for i in range(1, n // 2 + 1):
            top = 1
            while i * top < n:
                top += 1
            if top * i == n:
                count += 1
        return count == 3

# Solution 2 Speed O(log(N)) Memory O(1)
class Solution(object):
    def isThree(self, n):
        limit, count = n, 0
        for i in range(1, limit):
            if n % i == 0:
                limit = n / i
                if limit != i:
                    count += 1
                count += 1
        return count == 3

# Tube strike options calculator
# Tube strike options calculator
# The sweaty bus ride
# There is a tube strike today so instead of getting the London Underground home you have decided to take the bus. It's a hot day and you have been sitting on the bus for over an hour, but the bus is hardly moving. Your arm is sticking to the window and sweat drips off your nose as you try to read your neighbour's book when you say to yourself, "This is ridiculous. I could have walked faster than this!" Suddenly you have an idea for an app that helps people decide whether to walk or take the bus home when the London Underground is on strike.
# You rush home (relatively speaking) and begin to define the function that will underpin your app.
#
# Function specification
# You must create a function which takes three parameters; walking distance home, distance the bus must travel, and the combined distance of walking from the office to the bus stop and from the bus stop to your house. All distances are in kilometres.
# So for example, if your home is 5km away by foot, and the bus that takes you home travels 6km, but you have to walk 500 metres to the bus stop to catch it and 500 metres to your house once the bus arrives (i.e. 1km in total), which is faster, walking or taking the bus?
#
# Example - Which of these is faster?:
#
# Start---Walk 5km--->End
# Start---Walk 500m---Bus 6km---Walk 500m--->End
# Walking speed and bus driving speed have been given to you as two pre-loaded variables ($global_variables in Ruby).
#
# walk = 5 (km/hr) bus = 8 (km/hr)
#
# The function must return the fastest option, either "Walk" or "Bus". If the walk is going to be over 2 hours, the function should recommend that you take the bus. If the walk is going to be under 10 minutes, the function should recommend that you walk. If both options are going to take the same amount of time, the function should recommend that you walk
#
# FUNDAMENTALSALGORITHMS
def calculator(distance, bus_drive, bus_walk):
    by_walk = distance / walk
    by_bus = bus_walk / walk + bus_drive / bus
    if by_walk < 1/6:
        return 'Walk'
    elif by_walk <= 2:
        return 'Bus' if by_bus < by_walk else 'Walk'
    return 'Bus'

# 1037. Valid Boomerang
# Given an array points where points[i] = [xi, yi] represents a point on the X-Y plane, return true if these points are a boomerang.
#
# A boomerang is a set of three points that are all distinct and not in a straight line.
#
#
#
# Example 1:
#
# Input: points = [[1,1],[2,3],[3,2]]
# Output: true
# Example 2:
#
# Input: points = [[1,1],[2,2],[3,3]]
# Output: false
#
#
# Constraints:
#
# points.length == 3
# points[i].length == 2
# 0 <= xi, yi <= 100
# Solution Geometry Triangle Area Speed O(1), Memory O(1)
class Solution(object):
    def isBoomerang(self, p):
        x1, y1, x2, y2, x3, y3 = p[0][0], p[0][1], p[1][0], p[1][1], p[2][0], p[2][1]
        return x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0

# Alphabetical Grid
# Task:
# You need to write a function grid that returns an alphabetical grid of size NxN, where a = 0, b = 1, c = 2....
#
# Examples:
# grid(4)
#
# a b c d
# b c d e
# c d e f
# d e f g
# grid(10)
#
# a b c d e f g h i j
# b c d e f g h i j k
# c d e f g h i j k l
# d e f g h i j k l m
# e f g h i j k l m n
# f g h i j k l m n o
# g h i j k l m n o p
# h i j k l m n o p q
# i j k l m n o p q r
# j k l m n o p q r s
# Notes:
# After "z" comes "a"
# If function receive N < 0 should return:
# None
# FUNDAMENTALSALGORITHMS
def grid(N):
    if N < 0: return None
    if N == 0: return ''
    al, word = 'abcdefghijklmnopqrstuvwxyz' * N, []
    for i in range(N):
        top = [' '.join(al[i: i + N])]
        word.append(' '.join(top))
    return '\n'.join(word)

# 1556. Thousand Separator
# Given an integer n, add a dot (".") as the thousands separator and return it in string format.
#
#
#
# Example 1:
#
# Input: n = 987
# Output: "987"
# Example 2:
#
# Input: n = 1234
# Output: "1.234"
#
#
# Constraints:
#
# 0 <= n <= 231 - 1
class Solution(object):
    def thousandSeparator(self, n):
        if n == 0:
            return '0'
        top, count = '', 0
        while n:
            top = str(n % 10) + top
            count += 1
            n //= 10
            if n:
                if count == 3:
                    top = '.' + top
                    count = 0
        return top

# Day of the Year
# Work out what number day of the year it is.
#
# toDayOfYear([1, 1, 2000]) => 1
# The argument passed into the function is an array with the format [D, M, YYYY], e.g. [1, 2, 2000] for February 1st, 2000 or [22, 12, 1999] for December 22nd, 1999.
#
# Don't forget to check for whether it's a leap year! Three criteria must be taken into account to identify leap years:
#
# The year can be evenly divided by 4;
# If the year can be evenly divided by 100, it is NOT a leap year, unless;
# The year is also evenly divisible by 400. Then it is a leap year.
# FUNDAMENTALS
import calendar
def to_day_of_year(date):
    count = 0
    for i in range(1, date[1]):
        count += calendar.monthrange(date[-1], i)[1]
    count += date[0]
    return count

# 724. Find Pivot Index
# Given an array of integers nums, calculate the pivot index of this array.
#
# The pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index's right.
#
# If the index is on the left edge of the array, then the left sum is 0 because there are no elements to the left. This also applies to the right edge of the array.
#
# Return the leftmost pivot index. If no such index exists, return -1.
#
#
#
# Example 1:
#
# Input: nums = [1,7,3,6,5,6]
# Output: 3
# Explanation:
# The pivot index is 3.
# Left sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11
# Right sum = nums[4] + nums[5] = 5 + 6 = 11
# Example 2:
#
# Input: nums = [1,2,3]
# Output: -1
# Explanation:
# There is no index that satisfies the conditions in the problem statement.
# Example 3:
#
# Input: nums = [2,1,-1]
# Output: 0
# Explanation:
# The pivot index is 0.
# Left sum = 0 (no elements to the left of index 0)
# Right sum = nums[1] + nums[2] = 1 + -1 = 0
#
#
# Constraints:
#
# 1 <= nums.length <= 104
# -1000 <= nums[i] <= 1000
#
#
# Note: This question is the same as 1991: https://leetcode.com/problems/find-the-middle-index-in-array/
class Solution(object):
    def pivotIndex(self, nums):
        for i in range(len(nums)):
            if sum(nums[:i]) == sum(nums[i+1:]):
                return i
        return -1


# Game Hit the target
# Hit the target
# given a matrix n x n (2-7), determine if the arrow is directed to the target (x).
# There will be only 1 arrow '>' and 1 target 'x'
# An empty spot will be denoted by a space " ", the target with a cross "x", and the scope ">"
# Examples:
# given matrix 4x4:
# [
#
#   [' ', ' ', ' ', ' '],
#
#   [' ', ' ', ' ', ' '], --> return true
#
#   [' ', '>', ' ', 'x'],
#
#   [' ', ' ', ' ', ' ']
#
# ]
# given matrix 4x4:
# [
#
#   [' ', ' ', ' ', ' '],
#
#   [' ', '>', ' ', ' '], --> return false
#
#   [' ', ' ', ' ', 'x'],
#
#   [' ', ' ', ' ', ' ']
#
# ]
# given matrix 4x4:
# [
#
#   [' ', ' ', ' ', ' '],
#
#   [' ', 'x', '>', ' '], --> return false
#
#   [' ', '', ' ', ' '],
#
#   [' ', ' ', ' ', ' ']
#
# ]
#
# In this example, only a 4x4 matrix was used, the problem will have matrices of dimensions from 2 to 7
# Happy hacking as they say!
#
# GAMESMATRIXARRAYSSTRINGSFUNDAMENTALS
# Solution
def solution(mtrx):
    for i in mtrx:
        if '>' in i and 'x' in i:
            return i.index('>') < i.index('x')
    return False

# noobCode 03: CHECK THESE LETTERS... see if letters in "String 2" are present in "String 1"
# Write a function that checks if all the letters in the second string are present in the first one at least once, regardless of how many times they appear:
#
# ["ab", "aaa"]    =>  true
# ["trances", "nectar"]    =>  true
# ["compadres", "DRAPES"]  =>  true
# ["parses", "parsecs"]    =>  false
# Function should not be case sensitive, as indicated in example #2. Note: both strings are presented as a single argument in the form of an array.
#
# STRINGSALGORITHMS
 def letter_check(arr):
    return all(i.lower() in arr[0].lower() for i in arr[1])

# 191. Number of 1 Bits
# Write a function that takes the binary representation of an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight).
#
# Note:
#
# Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.
# In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 3, the input represents the signed integer. -3.
#
#
# Example 1:
#
# Input: n = 00000000000000000000000000001011
# Output: 3
# Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits.
# Example 2:
#
# Input: n = 00000000000000000000000010000000
# Output: 1
# Explanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit.
# Example 3:
#
# Input: n = 11111111111111111111111111111101
# Output: 31
# Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits.
#
#
# Constraints:
#
# The input must be a binary string of length 32.
#
#
# Follow up: If this function is called many times, how would you optimize it?
class Solution(object):
    def hammingWeight(self, n, count=0):
        return self.hammingWeight(n & n-1, count+1) if n!=0 else count

# 2869. Minimum Operations to Collect Elements
# You are given an array nums of positive integers and an integer k.
#
# In one operation, you can remove the last element of the array and add it to your collection.
#
# Return the minimum number of operations needed to collect elements 1, 2, ..., k.
#
#
#
# Example 1:
#
# Input: nums = [3,1,5,4,2], k = 2
# Output: 4
# Explanation: After 4 operations, we collect elements 2, 4, 5, and 1, in this order. Our collection contains elements 1 and 2. Hence, the answer is 4.
# Example 2:
#
# Input: nums = [3,1,5,4,2], k = 5
# Output: 5
# Explanation: After 5 operations, we collect elements 2, 4, 5, 1, and 3, in this order. Our collection contains elements 1 through 5. Hence, the answer is 5.
# Example 3:
#
# Input: nums = [3,2,5,3,1], k = 3
# Output: 4
# Explanation: After 4 operations, we collect elements 1, 3, 5, and 2, in this order. Our collection contains elements 1 through 3. Hence, the answer is 4.
#
#
# Constraints:
#
# 1 <= nums.length <= 50
# 1 <= nums[i] <= nums.length
# 1 <= k <= nums.length
# The input is generated such that you can collect elements 1, 2, ..., k.
class Solution(object):
    def minOperations(self, nums, k):
        d, count = {i: 1 for i in range(1, k +1)}, 0
        top = -1
        while d:
            if nums[top] in d:
                del d[nums[top]]
            top -= 1
        return abs(top) - 1


# Closest to Zero
# Simply find the closest value to zero from the list. Notice that there are negatives in the list.
#
# List is always not empty and contains only integers. Return None if it is not possible to define only one of such values. And of course, we are expecting 0 as closest value to zero.
#
# Examples:
#
# [2, 4, -1, -3]  => -1
# [5, 2, -2]      => None
# [5, 2, 2]       => 2
# [13, 0, -6]     => 0
# LISTSFUNDAMENTALS
def closest(lst):
    top = float('inf')
    for i in lst:
        if abs(i) < abs(top):
            top = i
    if lst.count(abs(top)) > 0 and lst.count(-top) > 0 and top != 0:
        return None
    return top

# 1662. Check If Two String Arrays are Equivalent
# Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.
#
# A string is represented by an array if the array elements concatenated in order forms the string.
#
#
#
# Example 1:
#
# Input: word1 = ["ab", "c"], word2 = ["a", "bc"]
# Output: true
# Explanation:
# word1 represents string "ab" + "c" -> "abc"
# word2 represents string "a" + "bc" -> "abc"
# The strings are the same, so return true.
# Example 2:
#
# Input: word1 = ["a", "cb"], word2 = ["ab", "c"]
# Output: false
# Example 3:
#
# Input: word1  = ["abc", "d", "defg"], word2 = ["abcddefg"]
# Output: true
#
#
# Constraints:
#
# 1 <= word1.length, word2.length <= 103
# 1 <= word1[i].length, word2[i].length <= 103
# 1 <= sum(word1[i].length), sum(word2[i].length) <= 103
# word1[i] and word2[i] consist of lowercase letters.
# Solution O(N) O(N)
class Solution(object):
    def arrayStringsAreEqual(self, word1, word2):
        return ''.join(word1) == ''.join(word2)

# Solution 2 - O(min(word1, word2)) Memory O(1)
class Solution(object):
    def arrayStringsAreEqual(self, word1, word2):
        for x, y in zip(self.generate(word1), self.generate(word2)):
            if x != y:
                return False
        return True

    def generate(self, n):
        for i in n:
            for j in i:
                yield j
        yield None
        
# Stacked Balls - 2D
# Background
# I have stacked some pool balls in a triangle.
#
# Like this,
#
# pool balls
# Kata Task
# Given the number of layers of my stack, what is the total height?
#
# Return the height as multiple of the ball diameter.
#
# Example
# The image above shows a stack of 5 layers.
#
# Notes
# layers >= 0
# approximate answers (within 0.001) are good enough
# See Also
#
# Stacked Balls - 2D
# Stacked Balls - 3D with square base
# Stacked Balls - 3D with triangle base
# FUNDAMENTALS
def stack_height_2d(layers):
    if layers in {0, 1}:
        return layers
    return 1 + (layers - 1) * 0.8660254

# 1160. Find Words That Can Be Formed by Characters
# You are given an array of strings words and a string chars.
#
# A string is good if it can be formed by characters from chars (each character can only be used once).
#
# Return the sum of lengths of all good strings in words.
#
#
#
# Example 1:
#
# Input: words = ["cat","bt","hat","tree"], chars = "atach"
# Output: 6
# Explanation: The strings that can be formed are "cat" and "hat" so the answer is 3 + 3 = 6.
# Example 2:
#
# Input: words = ["hello","world","leetcode"], chars = "welldonehoneyr"
# Output: 10
# Explanation: The strings that can be formed are "hello" and "world" so the answer is 5 + 5 = 10.
#
#
# Constraints:
#
# 1 <= words.length <= 1000
# 1 <= words[i].length, chars.length <= 100
# words[i] and chars consist of lowercase English letters.
# Solution
class Solution(object):
    def countCharacters(self, words, chars):
        d, count = {}, 0
        for i in chars:
            d[i] = d.get(i, 0) + 1
        for i in words:
            top, flag = {}, True
            for j in i:
                top[j] = top.get(j, 0) + 1
                if j not in d or top[j] > d[j]:
                    flag = False
                    break
            if flag:
                count += len(i)
        return count

# Supernatural
# This kata is a tribute/fanwork to the TV-show: Supernatural
#
# Balls!
#
# Those wayward Winchester boys are in trouble again, hunting something down in New Orleans. You are Bobby Singer, you know how "idjits" they can be, so you have to prepare. They will call you any minute with the race of the thing, and you want to answer as soon as possible. By answer, I mean: tell them how to kill, or fight it.
#
# You have something like a database (more like drunken doodling) to help them:
#
# werewolf : Silver knife or bullet to the heart
# vampire : Behead it with a machete
# wendigo : Burn it to death
# shapeshifter : Silver knife or bullet to the heart
# angel : Use the angelic blade
# demon : Use Ruby's knife, or some Jesus-juice
# ghost : Salt and iron, and don't forget to burn the corpse
# dragon : You have to find the excalibur for that
# djinn : Stab it with silver knife dipped in a lamb's blood
# pagan god : It depends on which one it is
# leviathan : Use some Borax, then kill Dick
# ghoul : Behead it
# jefferson starship : Behead it with a silver blade
# reaper : If it's nasty, you should gank who controls it
# rugaru : Burn it alive
# skinwalker : A silver bullet will do it
# phoenix : Use the colt
# witch : They are humans
# else : I have friggin no idea yet
# You can access the database as drunkenDoodling/drunken_doodling/DrunkenDoodling depending on your language.
#
# So a call would go down like this:
#
# The guys call you: bob('rugaru')
#
# ...and you reply (return) with the info, and your signature saying of yours! Burn it alive, idjits!
#
# GAMESFUNDAMENTALS
def bob(what):
    d = {'werewolf' : 'Silver knife or bullet to the heart', 'vampire' : 'Behead it with a machete',
        'wendigo' : 'Burn it to death', 'shapeshifter' : 'Silver knife or bullet to the heart',
        'angel' : 'Use the angelic blade', 'demon' : "Use Ruby's knife, or some Jesus-juice",
        'ghost' : "Salt and iron, and don't forget to burn the corpse", 'dragon' : 'You have to find the excalibur for that', 
         'djinn' : "Stab it with silver knife dipped in a lamb's blood",
        'pagan god' : 'It depends on which one it is', 'leviathan' : 'Use some Borax, then kill Dick',
        'ghoul' : 'Behead it', 'jefferson starship' : 'Behead it with a silver blade',
        'reaper' : "If it's nasty, you should gank who controls it", 'rugaru' : 'Burn it alive',
        'skinwalker' : 'A silver bullet will do it', 'phoenix' : 'Use the colt', 'witch' : 'They are humans'}
    word = ', idjits!'
    if what in d:
        return d[what] + word
    return 'I have friggin no idea yet' + word

# 1266. Minimum Time Visiting All Points
# On a 2D plane, there are n points with integer coordinates points[i] = [xi, yi]. Return the minimum time in seconds to visit all the points in the order given by points.
#
# You can move according to these rules:
#
# In 1 second, you can either:
# move vertically by one unit,
# move horizontally by one unit, or
# move diagonally sqrt(2) units (in other words, move one unit vertically then one unit horizontally in 1 second).
# You have to visit the points in the same order as they appear in the array.
# You are allowed to pass through points that appear later in the order, but these do not count as visits.
#
#
# Example 1:
#
#
# Input: points = [[1,1],[3,4],[-1,0]]
# Output: 7
# Explanation: One optimal path is [1,1] -> [2,2] -> [3,3] -> [3,4] -> [2,3] -> [1,2] -> [0,1] -> [-1,0]
# Time from [1,1] to [3,4] = 3 seconds
# Time from [3,4] to [-1,0] = 4 seconds
# Total time = 7 seconds
# Example 2:
#
# Input: points = [[3,2],[-2,2]]
# Output: 5
#
#
# Constraints:
#
# points.length == n
# 1 <= n <= 100
# points[i].length == 2
# -1000 <= points[i][0], points[i][1] <= 1000
# Solution O(N) O(1) Chebyshov Distance
class Solution(object):
    def minTimeToVisitAllPoints(self, points):
        count = 0
        for i in range(len(points) - 1):
            count += max(abs(points[i][0] - points[i + 1][0]), abs(points[i][1] - points[i + 1][1]))
        return count
    
# Cartesian coordinates from degree angle
# Write a simple function that takes polar coordinates (an angle in degrees and a radius) and returns the equivalent cartesian coordinates (rounded to 10 places).
#
# For example:
#
# coordinates(90,1)
# => (0.0, 1.0)
#
# coordinates(45, 1)
# => (0.7071067812, 0.7071067812)
# ALGORITHMSMATHEMATICSGEOMETRY
import math

def coordinates(degrees, radius):
    grad = degrees * (math.pi / 180)
    return (round(radius * math.cos(grad), 10), round(radius * math.sin(grad), 10))

# 2264. Largest 3-Same-Digit Number in String
# You are given a string num representing a large integer. An integer is good if it meets the following conditions:
#
# It is a substring of num with length 3.
# It consists of only one unique digit.
# Return the maximum good integer as a string or an empty string "" if no such integer exists.
#
# Note:
#
# A substring is a contiguous sequence of characters within a string.
# There may be leading zeroes in num or a good integer.
#
#
# Example 1:
#
# Input: num = "6777133339"
# Output: "777"
# Explanation: There are two distinct good integers: "777" and "333".
# "777" is the largest, so we return "777".
# Example 2:
#
# Input: num = "2300019"
# Output: "000"
# Explanation: "000" is the only good integer.
# Example 3:
#
# Input: num = "42352338"
# Output: ""
# Explanation: No substring of length 3 consists of only one unique digit. Therefore, there are no good integers.
#
#
# Constraints:
#
# 3 <= num.length <= 1000
# num only consists of digits.
# Solution 1 O(N) O(1)
class Solution(object):
    def largestGoodInteger(self, num):
        top, cop = '', num[0]
        for i in range(1, len(num)):
            if num[i] == cop[-1]:
                cop += num[i]
                if len(cop) == 3:
                    top = max(top, cop)
                    cop = cop[-1]
            else:
                cop = num[i]
        return top
# Solution 2 O(N) O(1)
class Solution(object):
    def largestGoodInteger(self, num):
        top = ''
        for i in range(2, len(num)):
            if num[i-2] == num[i-1] == num[i]:
                top = max(top, num[i-2:i+1])
        return top

# Find heavy ball - level: novice
# There are 8 balls numbered from 0 to 7. Seven of them have the same weight. One is heavier. Your task is to find its number.
#
# Your function findBall will receive single argument - scales object. The scales object contains an internally stored array of 8 elements (indexes 0-7), each having the same value except one, which is greater. It also has a public method named getWeight(left, right) which takes two arrays of indexes and returns -1, 0, or 1 based on the accumulation of the values found at the indexes passed are heavier, equal, or lighter.
#
# getWeight returns:
#
# -1 if left pan is heavier
#
# 1 if right pan is heavier
#
# 0 if both pans weight the same
#
# Examples of scales.getWeight() usage:
#
# scales.getWeight([3], [7]) returns -1 if ball 3 is heavier than ball 7, 1 if ball 7 is heavier, or 0 i these balls have the same weight.
#
# scales.getWeight([3, 4], [5, 2]) returns -1 if weight of balls 3 and 4 is heavier than weight of balls 5 and 2 etc.
#
# So where's the catch, you may ask. Well - the scales is very old. You can use it only 4 TIMES before the scale breaks.
#
# Note - Use scales.get_weight() in the Python, Crystal, Ruby And C versions.
#
# Too easy ? Try higher levels:
#
# conqueror
# master
# PUZZLESLOGICRIDDLES
def find_ball(scales):
    # call scales.get_weight() at most 4 TIMES
    # return indexOfHeavierBall
    for i in range(1, 8, 2):
        leftPan = [i-1]
        rightPan = [i]
        w = scales.get_weight(leftPan, rightPan)

        if w < 0:
            return leftPan[0]

        if w > 0:
            return rightPan[0]

# 1688. Count of Matches in Tournament
# You are given an integer n, the number of teams in a tournament that has strange rules:
#
# If the current number of teams is even, each team gets paired with another team. A total of n / 2 matches are played, and n / 2 teams advance to the next round.
# If the current number of teams is odd, one team randomly advances in the tournament, and the rest gets paired. A total of (n - 1) / 2 matches are played, and (n - 1) / 2 + 1 teams advance to the next round.
# Return the number of matches played in the tournament until a winner is decided.
#
#
#
# Example 1:
#
# Input: n = 7
# Output: 6
# Explanation: Details of the tournament:
# - 1st Round: Teams = 7, Matches = 3, and 4 teams advance.
# - 2nd Round: Teams = 4, Matches = 2, and 2 teams advance.
# - 3rd Round: Teams = 2, Matches = 1, and 1 team is declared the winner.
# Total number of matches = 3 + 2 + 1 = 6.
# Example 2:
#
# Input: n = 14
# Output: 13
# Explanation: Details of the tournament:
# - 1st Round: Teams = 14, Matches = 7, and 7 teams advance.
# - 2nd Round: Teams = 7, Matches = 3, and 4 teams advance.
# - 3rd Round: Teams = 4, Matches = 2, and 2 teams advance.
# - 4th Round: Teams = 2, Matches = 1, and 1 team is declared the winner.
# Total number of matches = 7 + 3 + 2 + 1 = 13.
#
#
# Constraints:
#
# 1 <= n <= 200
# Solution O(logN) O(1)
class Solution(object):
    def numberOfMatches(self, n):
        count = 0
        while n != 1:
            if n % 2 == 0:
                n = n / 2
                count += n
            else:
                count += (n - 1) / 2
                n = n // 2 + 1
        return count
# Solution O(1) O(1)
class Solution(object):
    def numberOfMatches(self, n):
        return n - 1

# Offload your work!
# You are the best freelancer in the city. Everybody knows you, but what they don't know, is that you are actually offloading your work to other freelancers and and you rarely need to do any work. You're living the life!
#
# To make this process easier you need to write a method called workNeeded to figure out how much time you need to contribute to a project.
#
# Giving the amount of time in minutes needed to complete the project and an array of pair values representing other freelancers' time in [Hours, Minutes] format ie. [[2, 33], [3, 44]] calculate how much time you will need to contribute to the project (if at all) and return a string depending on the case.
#
# If we need to contribute time to the project then return "I need to work x hour(s) and y minute(s)"
# If we don't have to contribute any time to the project then return "Easy Money!"
# FUNDAMENTALS
def work_needed(project_minutes, free_lancers):
    for i in free_lancers:
        if i[0] > 0:
            project_minutes -= i[0] * 60
        if i[1] > 0:
            project_minutes -= i[1]
    if project_minutes <= 0:
        return 'Easy Money!'
    return f'I need to work {project_minutes // 60} hour(s) and {project_minutes % 60} minute(s)'

# 1716. Calculate Money in Leetcode Bank
# Hercy wants to save money for his first car. He puts money in the Leetcode bank every day.
#
# He starts by putting in $1 on Monday, the first day. Every day from Tuesday to Sunday, he will put in $1 more than the day before. On every subsequent Monday, he will put in $1 more than the previous Monday.
# Given n, return the total amount of money he will have in the Leetcode bank at the end of the nth day.
#
#
#
# Example 1:
#
# Input: n = 4
# Output: 10
# Explanation: After the 4th day, the total is 1 + 2 + 3 + 4 = 10.
# Example 2:
#
# Input: n = 10
# Output: 37
# Explanation: After the 10th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37. Notice that on the 2nd Monday, Hercy only puts in $2.
# Example 3:
#
# Input: n = 20
# Output: 96
# Explanation: After the 20th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96.
#
#
# Constraints:
#
# 1 <= n <= 1000
class Solution(object):
    def totalMoney(self, n):
        if n % 7 == 0:
            return sum((1 + 7 + i * 2) * 7 / 2 for i in range(n // 7))
        x = sum((1 + 7 + i * 2) * 7 / 2 for i in range(n // 7))
        return x + sum(i + n // 7 for i in range(1, n % 7 + 1))

# Lottery machine
# Your task is to write an update for a lottery machine. Its current version produces a sequence of random letters and integers (passed as a string to the function). Your code must filter out all letters and return unique integers as a string, in their order of first appearance. If there are no integers in the string return "One more run!"
#
# Examples
# "hPrBKWDH8yc6Lt5NQZWQ"  -->  "865"
# "ynMAisVpHEqpqHBqTrwH"  -->  "One more run!"
# "555"                   -->  "5"
# STRINGSFUNDAMENTALS
def lottery(s):
    top = ''
    for i in s:
        if i.isdigit() and i not in top:
            top += i
    return top if top else 'One more run!'

# 1903. Largest Odd Number in String
# You are given a string num, representing a large integer. Return the largest-valued odd integer (as a string) that is a non-empty substring of num, or an empty string "" if no odd integer exists.
#
# A substring is a contiguous sequence of characters within a string.
#
#
#
# Example 1:
#
# Input: num = "52"
# Output: "5"
# Explanation: The only non-empty substrings are "5", "2", and "52". "5" is the only odd number.
# Example 2:
#
# Input: num = "4206"
# Output: ""
# Explanation: There are no odd numbers in "4206".
# Example 3:
#
# Input: num = "35427"
# Output: "35427"
# Explanation: "35427" is already an odd number.
#
#
# Constraints:
#
# 1 <= num.length <= 105
# num only consists of digits and does not contain any leading zeros.
class Solution(object):
    def largestOddNumber(self, num):
        while num[-1] not in {'1', '3', '5', '7', '9'}:
          num = num[:-1]
          if not num:
            return ''
        return num

# Mr Martingale
# You're in the casino, playing Roulette, going for the "1-18" bets only and desperate to beat the house and so you want to test how effective the Martingale strategy is.
#
# You will be given a starting cash balance and an array of binary digits to represent a win (1) or a loss (0). Return your balance after playing all rounds.
#
# The Martingale strategy
#
# You start with a stake of 100 dollars. If you lose a round, you lose the stake placed on that round and you double the stake for your next bet. When you win, you win 100% of the stake and revert back to staking 100 dollars on your next bet.
#
# Example
# martingale(1000, [1, 1, 0, 0, 1]) === 1300
# Explanation:
#
# you win your 1st round: gain $100, balance = 1100
# you win the 2nd round: gain $100, balance = 1200
# you lose the 3rd round: lose $100 dollars, balance = 1100
# double stake for 4th round and lose: staked $200, lose $200, balance = 900
# double stake for 5th round and win: staked $400, won $400, balance = 1300
# Note: Your balance is allowed to go below 0.
#
# GAMESPUZZLES
def martingale(bank, outcomes):
    top = 100
    for i in outcomes:
        if i == 1:
            bank += top
            top = 100
        else:
            bank -= top
            top *= 2
    return bank

# 606. Construct String from Binary Tree
# Given the root of a binary tree, construct a string consisting of parenthesis and integers from a binary tree with the preorder traversal way, and return it.
#
# Omit all the empty parenthesis pairs that do not affect the one-to-one mapping relationship between the string and the original binary tree.
#
#
#
# Example 1:
#
#
# Input: root = [1,2,3,4]
# Output: "1(2(4))(3)"
# Explanation: Originally, it needs to be "1(2(4)())(3()())", but you need to omit all the unnecessary empty parenthesis pairs. And it will be "1(2(4))(3)"
# Example 2:
#
#
# Input: root = [1,2,3,null,4]
# Output: "1(2()(4))(3)"
# Explanation: Almost the same as the first example, except we cannot omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output.
#
#
# Constraints:
#
# The number of nodes in the tree is in the range [1, 104].
# -1000 <= Node.val <= 1000
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def tree2str(self, root):
        if not root:
            return ''
        left = ('(' + str(self.tree2str(root.left)) + ')') if root.left or root.right else ''
        right = ('(' + str(self.tree2str(root.right)) + ')' ) if root.right else ''
        return str(root.val) + left + right

# Count up the points for the 7 Wonders board game! Easy version
# 7 Wonders
# 7 Wonders is a board game that consists of building your city, gathering resources and fighting your neighbors.
#
# One part of the game is also to research science in order to gain points at the end of the game. There are 3 types of science glyphs you can gather:
#
# Compasses
# Gears
# Tablets
# The way points are added up works as described here:
#
# Step 1
# Each distinct set of three different glyphs is worth 7 points:
#
# 1 Compass, 1 Gear and 1 Tablet    =  7 points
# 2 Compasses, 1 Gear and 1 Tablet  =  7 points (because it's just one disctinct set)
# Note that a distinct set of three different glyphs means 1 Compass, 1 Gear and 1 Tablet. No more, no less!
#
# Step 2
# The amount of each glyph you own is squared and then summed up:
#
# 1 Compass, 1 Gear and 1 Tablet    =  1*1 + 1*1 + 1*1  =  3 points
# 2 Compasses, 1 Gear and 1 Tablet  =  2*2 + 1*1 + 1*1  =  6 points
# Finally
# The total science points is equal to the sum of the two steps:
#
# 1 Compass, 1 Gear and 1 Tablet    =  7 + 3  =  10 points
# 2 Compasses, 1 Gear and 1 Tablet  =  7 + 6  =  13 points
# You will be given 3 inputs corresponding to the amount of each glyph you have acquired in the game. Your task is to output the final score. Take into account that you may have no glyphs at all!
#
# PUZZLES
def seven_wonders_science(compasses, gears, tablets):
    s1 = min(compasses, gears, tablets) * 7
    s2 = sum(i * i for i in (compasses, gears, tablets))
    return s1 + s2

# 94. Binary Tree Inorder Traversal
# Given the root of a binary tree, return the inorder traversal of its nodes' values.
#
#
#
# Example 1:
#
#
# Input: root = [1,null,2,3]
# Output: [1,3,2]
# Example 2:
#
# Input: root = []
# Output: []
# Example 3:
#
# Input: root = [1]
# Output: [1]
#
#
# Constraints:
#
# The number of nodes in the tree is in the range [0, 100].
# -100 <= Node.val <= 100
#
#
# Follow up: Recursive solution is trivial, could you do it iteratively?
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def inorderTraversal(self, root):
        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else []

# Most sales
# You work in the best consumer electronics corporation, and your boss wants to find out which three products generate the most revenue. Given 3 lists of the same length like these:
#
# products: ["Computer", "Cell Phones", "Vacuum Cleaner"]
# amounts: [3, 24, 8]
# prices: [199, 299, 399]
# return the three product names with the highest revenue (amount * price).
#
# Note: if multiple products have the same revenue, order them according to their original positions in the input list.
#
# FUNDAMENTALS
def top3(products, amounts, prices):
    d = {products[i]: amounts[i] * prices[i] for i in range(len(products))}
    l = sorted(d.items(), key=lambda x: x[1], reverse=True)
    return [i[0] for i in l][:3]

# 867. Transpose Matrix
# Given a 2D integer array matrix, return the transpose of matrix.
#
# The transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix's row and column indices.
#
#
#
#
#
# Example 1:
#
# Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
# Output: [[1,4,7],[2,5,8],[3,6,9]]
# Example 2:
#
# Input: matrix = [[1,2,3],[4,5,6]]
# Output: [[1,4],[2,5],[3,6]]
#
#
# Constraints:
#
# m == matrix.length
# n == matrix[i].length
# 1 <= m, n <= 1000
# 1 <= m * n <= 105
# -109 <= matrix[i][j] <= 109
class Solution(object):
    def transpose(self, matrix):
        m = [[0] * len(matrix) for j in range(len(matrix[0]))]
        for i in range(len(matrix[0])):
            for j in range(len(matrix)):
                m[i][j] = matrix[j][i]
        return m
    
# Thinking & Testing : How many "word"?
# No Story
#
# No Description
#
# Only by Thinking and Testing
#
# Look at result of testcase, guess the code!
#
# #Series:
# 01:A and B?
# 02:Incomplete string
# 03:True or False
# 04:Something capitalized
# 05:Uniq or not Uniq
# 06:Spatiotemporal index
# 07:Math of Primary School
# 08:Math of Middle school
# 09:From nothingness To nothingness
# 10:Not perfect? Throw away!
# 11:Welcome to take the bus
# 12:A happy day will come
# 13:Sum of 15(Hetu Luosliu)
# 14:Nebula or Vortex
# 15:Sport Star
# 16:Falsetto Rap Concert
# 17:Wind whispers
# 18:Mobile phone simulator
# 19:Join but not join
# 20:I hate big and small
# 21:I want to become diabetic ;-)
# 22:How many blocks?
# 23:Operator hidden in a string
# 24:Substring Magic
# 25:Report about something
# 26:Retention and discard I
# 27:Retention and discard II
# 28:How many "word"?
# 29:Hail and Waterfall
# 30:Love Forever
# 31:Digital swimming pool
# 32:Archery contest
# 33:The repair of parchment
# 34:Who are you?
# 35:Safe position
#
#
# #Special recommendation
# Another series, innovative and interesting, medium difficulty. People who like to challenge, can try these kata:
#
# <a href="http://www.codewars.com/kata/56c85eebfd8fc02551000281">Play Tetris : Shape anastomosis</a><br>
# Play FlappyBird : Advance Bravely
#
# PUZZLESGAMES
def testit(s):
    w, n, i = 'word', 0, 0
    for j in s.lower():
        if j == w[i]:
            n += j == w[-1]
            i = (i + 1) % len(w)
    return n

# 1287. Element Appearing More Than 25% In Sorted Array
# Given an integer array sorted in non-decreasing order, there is exactly one integer in the array that occurs more than 25% of the time, return that integer.
#
#
#
# Example 1:
#
# Input: arr = [1,2,2,6,6,6,6,7,10]
# Output: 6
# Example 2:
#
# Input: arr = [1,1]
# Output: 1
#
#
# Constraints:
#
# 1 <= arr.length <= 104
# 0 <= arr[i] <= 105
class Solution(object):
    def findSpecialInteger(self, arr):
        val, top, n = arr[0], 0, len(arr) // 4
        for i in range(len(arr)):
            if arr[i] == val:
                top += 1
                if top > n:
                    return  val
            else:
                val, top = arr[i], 1

# Noonerize Me
# Spoonerize... with numbers... numberize?... numboonerize?... noonerize? ...anyway! If you don't yet know what a spoonerism is and haven't yet tried my spoonerism kata, please do check it out first.
#
# You will create a function which takes an array of two positive integers, spoonerizes them, and returns the positive difference between them as a single number or 0 if the numbers are equal:
#
# [123, 456] = 423 - 156 = 267
# Your code must test that all array items are numbers and return "invalid array" if it finds that either item is not a number. The provided array will always contain 2 elements.
#
# When the inputs are valid, they will always be integers, no floats will be passed. However, you must take into account that the numbers will be of varying magnitude, between and within test cases.
#
# MATHEMATICSARRAYSALGORITHMS
def noonerize(numbers):
    if any(not isinstance(i, int) for i in numbers):
        return 'invalid array'
    return abs(int(str(numbers[1])[0] + str(numbers[0])[1:]) - int(str(numbers[0])[0] + str(numbers[1])[1:]))


# 1464. Maximum Product of Two Elements in an Array
# Given the array of integers nums, you will choose two different indices i and j of that array. Return the maximum value of (nums[i]-1)*(nums[j]-1).
#
#
# Example 1:
#
# Input: nums = [3,4,5,2]
# Output: 12
# Explanation: If you choose the indices i=1 and j=2 (indexed from 0), you will get the maximum value, that is, (nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12.
# Example 2:
#
# Input: nums = [1,5,4,5]
# Output: 16
# Explanation: Choosing the indices i=1 and j=3 (indexed from 0), you will get the maximum value of (5-1)*(5-1) = 16.
# Example 3:
#
# Input: nums = [3,7]
# Output: 12
#
#
# Constraints:
#
# 2 <= nums.length <= 500
# 1 <= nums[i] <= 10^3
class Solution(object):
    def maxProduct(self, nums):
        x, y = min(nums[0], nums[1]), max(nums[1], nums[0])
        for i in range(2, len(nums)):
            if nums[i] >= y:
                y, x = nums[i], y
            elif nums[i] > x:
                x = nums[i]
        return (x - 1) * (y - 1)


# 80's Kids #1: How Many Licks Does it Take?
# How many licks does it take to get to the tootsie roll center of a tootsie pop?
#
# A group of engineering students from Purdue University reported that its licking machine, modeled after a human tongue, took an average of 364 licks to get to the center of a Tootsie Pop. Twenty of the group's volunteers assumed the licking challenge-unassisted by machinery-and averaged 252 licks each to the center.
#
# Your task, if you choose to accept it, is to write a function that will return the number of licks it took to get to the tootsie roll center of a tootsie pop, given some environmental variables.
#
# Everyone knows it's harder to lick a tootsie pop in cold weather but it's easier if the sun is out. You will be given an object of environmental conditions for each trial paired with a value that will increase or decrease the number of licks. The environmental conditions all apply to the same trial.
#
# Assuming that it would normally take 252 licks to get to the tootsie roll center of a tootsie pop, return the new total of licks along with the condition that proved to be most challenging (causing the most added licks) in that trial.
#
# Example:
#
# totalLicks({ "freezing temps": 10, "clear skies": -2 });
# Should return:
#
# "It took 260 licks to get to the tootsie roll center of a tootsie pop. The toughest challenge was freezing temps."
# Other cases: If there are no challenges, the toughest challenge sentence should be omitted. If there are multiple challenges with the highest toughest amount, the first one presented will be the toughest. If an environment variable is present, it will be either a positive or negative integer. No need to validate.
#
# Check out my other 80's Kids Katas:
# 80's Kids #1: How Many Licks Does It Take
# 80's Kids #2: Help Alf Find His Spaceship
#
# 80's Kids #3: Punky Brewster's Socks
#
# 80's Kids #4: Legends of the Hidden Temple
#
# 80's Kids #5: You Can't Do That on Television
#
# 80's Kids #6: Rock 'Em, Sock 'Em Robots
#
# 80's Kids #7: She's a Small Wonder
#
# 80's Kids #8: The Secret World of Alex Mack
#
# 80's Kids #9: Down in Fraggle Rock
#
# 80's Kids #10: Captain Planet
#
# ALGORITHMS
def total_licks(env):
    if not env:
        return f'It took {252} licks to get to the tootsie roll center of a tootsie pop.'
    s = sum(v for k, v in env.items())
    w = f'It took {252 + s} licks to get to the tootsie roll center of a tootsie pop.'
    if s + 252 < 252:
        return w
    return w + f' The toughest challenge was {max(env, key=env.get)}.'

# 1582. Special Positions in a Binary Matrix
# Given an m x n binary matrix mat, return the number of special positions in mat.
#
# A position (i, j) is called special if mat[i][j] == 1 and all other elements in row i and column j are 0 (rows and columns are 0-indexed).
#
#
#
# Example 1:
#
#
# Input: mat = [[1,0,0],[0,0,1],[1,0,0]]
# Output: 1
# Explanation: (1, 2) is a special position because mat[1][2] == 1 and all other elements in row 1 and column 2 are 0.
# Example 2:
#
#
# Input: mat = [[1,0,0],[0,1,0],[0,0,1]]
# Output: 3
# Explanation: (0, 0), (1, 1) and (2, 2) are special positions.
#
#
# Constraints:
#
# m == mat.length
# n == mat[i].length
# 1 <= m, n <= 100
# mat[i][j] is either 0 or 1.
# Solution
class Solution(object):
    def numSpecial(self, mat):
        count = 0
        m, n = 0, 0
        while m < len(mat):
            for i in range(len(mat[m])):
                if mat[m][i] == 1:
                    top = 0
                    for k in range(len(mat[m])):
                        if mat[m][k] == 1:
                            top += 1
                            if top > 1:
                                break
                    if top == 1:
                        top = 0
                        for j in range(len(mat)):
                            if mat[j][i] == 1:
                                top += 1
                                if top > 1:
                                    break
                    if top == 1:
                        count += 1
            m += 1
        return count
# Solution 2 Python syntax sugar
class Solution(object):
    def numSpecial(self, mat):
        count = 0
        m = 0
        while m < len(mat):
            if mat[m].count(1) == 1:
                if sum(i[mat[m].index(1)] == 1 for i in mat) == 1:
                    count += 1
            m += 1
        return count
    
# Negative Connotation
# You will be given a string with sets of characters, (i.e. words), seperated by between one and four spaces (inclusive).
#
# Looking at the first letter of each word (case insensitive-"A" and "a" should be treated the same), you need to determine whether it falls into the positive/first half of the alphabet ("a"-"m") or the negative/second half ("n"-"z").
#
# Return True/true if there are more (or equal) positive words than negative words, False/false otherwise.
#
# "A big brown fox caught a bad rabbit" => True/true
# "Xylophones can obtain Xenon." => False/false
# FUNDAMENTALS
def connotation(strng):
    en_al_l = 'abcdefghijklmnopqrstuvwxyz'
    n = [1 if en_al_l.index(i[0].lower()) <= en_al_l.index('m') else 0 for i in strng.split()]
    return n.count(1) >= n.count(0)

# 2482. Difference Between Ones and Zeros in Row and Column
# You are given a 0-indexed m x n binary matrix grid.
#
# A 0-indexed m x n difference matrix diff is created with the following procedure:
#
# Let the number of ones in the ith row be onesRowi.
# Let the number of ones in the jth column be onesColj.
# Let the number of zeros in the ith row be zerosRowi.
# Let the number of zeros in the jth column be zerosColj.
# diff[i][j] = onesRowi + onesColj - zerosRowi - zerosColj
# Return the difference matrix diff.
#
#
#
# Example 1:
#
#
# Input: grid = [[0,1,1],[1,0,1],[0,0,1]]
# Output: [[0,0,4],[0,0,4],[-2,-2,2]]
# Explanation:
# - diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 2 + 1 - 1 - 2 = 0
# - diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 2 + 1 - 1 - 2 = 0
# - diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 2 + 3 - 1 - 0 = 4
# - diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 2 + 1 - 1 - 2 = 0
# - diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 2 + 1 - 1 - 2 = 0
# - diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 2 + 3 - 1 - 0 = 4
# - diff[2][0] = onesRow2 + onesCol0 - zerosRow2 - zerosCol0 = 1 + 1 - 2 - 2 = -2
# - diff[2][1] = onesRow2 + onesCol1 - zerosRow2 - zerosCol1 = 1 + 1 - 2 - 2 = -2
# - diff[2][2] = onesRow2 + onesCol2 - zerosRow2 - zerosCol2 = 1 + 3 - 2 - 0 = 2
# Example 2:
#
#
# Input: grid = [[1,1,1],[1,1,1]]
# Output: [[5,5,5],[5,5,5]]
# Explanation:
# - diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 3 + 2 - 0 - 0 = 5
# - diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 3 + 2 - 0 - 0 = 5
# - diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 3 + 2 - 0 - 0 = 5
# - diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 3 + 2 - 0 - 0 = 5
# - diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 3 + 2 - 0 - 0 = 5
# - diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 3 + 2 - 0 - 0 = 5
#
#
# Constraints:
#
# m == grid.length
# n == grid[i].length
# 1 <= m, n <= 105
# 1 <= m * n <= 105
# grid[i][j] is either 0 or 1.
class Solution(object):
    def onesMinusZeros(self, grid):
        n, m = len(grid), len(grid[0])
        r = [sum(grid[i]) for i in range(n)]
        c = [sum(grid[j][i] == 1 for j in range(n)) for i in range(m)]
        return [[r[i] + c[j] - (n - r[i] + m - c[j]) for j in range(m)] for i in range(n)]

# Differential Averaging
# Say you have a ratings system. People can rate a page, and the average is displayed on the page for everyone to see.
#
# One way of storing such a running average is to keep the the current average as well as the total rating that all users have submitted and with how many people rated it, so that the average can be calculated and updated when a new rating has been made.
#
# There are a couple of minor problems with this: first, you're keeping 3 columns instead of 1, which isn't ideal. Second is, if you're not careful, the number could get too large and get less and less accurate as the data format tries to keep up.
#
# So what you need to do is this: write a function that takes the current average, the current number of ratings (data points) made, and a new value to add to the average; then return the new value. That way, you only need 2 columns in your database, and the number will not get crazy large over time.
#
# To be clear:
#
# current = 0.5
# points = 2
# add = 1
#
# --> 0.6666666666666666666666666666666666 // (2/3)
# There are also plenty of examples in the example tests.
#
# MATHEMATICSALGEBRAALGORITHMS
def add_to_average(current, points, add):
    return (current * points + add) / (points + 1)

# 1436. Destination City
# You are given the array paths, where paths[i] = [cityAi, cityBi] means there exists a direct path going from cityAi to cityBi. Return the destination city, that is, the city without any path outgoing to another city.
#
# It is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city.
#
#
#
# Example 1:
#
# Input: paths = [["London","New York"],["New York","Lima"],["Lima","Sao Paulo"]]
# Output: "Sao Paulo"
# Explanation: Starting at "London" city you will reach "Sao Paulo" city which is the destination city. Your trip consist of: "London" -> "New York" -> "Lima" -> "Sao Paulo".
# Example 2:
#
# Input: paths = [["B","C"],["D","B"],["C","A"]]
# Output: "A"
# Explanation: All possible trips are:
# "D" -> "B" -> "C" -> "A".
# "B" -> "C" -> "A".
# "C" -> "A".
# "A".
# Clearly the destination city is "A".
# Example 3:
#
# Input: paths = [["A","Z"]]
# Output: "Z"
#
#
# Constraints:
#
# 1 <= paths.length <= 100
# paths[i].length == 2
# 1 <= cityAi.length, cityBi.length <= 10
# cityAi != cityBi
# All strings consist of lowercase and uppercase English letters and the space character.
# Solution O(N) O(N)
class Solution(object):
    def destCity(self, paths):
        city = set(path[0] for path in paths)
        for i in range(len(paths)):
            x = paths[i][1]
            if x not in city:
                return x

# An English Twist on a Japanese Classic
# Background:
# In Japan, a game called Shiritori is played. The rules are simple, a group of people take turns calling out a word whose beginning syllable is the same as the previous player's ending syllable. For example, the first person would say the word ねこ, and the second player must make a word that starts with こ, like　こむぎ. This repeats until a player can not think of a word fast enough or makes a word that ends in ん, because there are no words that begin with ん　in the Japanese language.
#
# English Shiritori has the same principle, with the first and last letters of words. That being said the lose condition is saying a word that doesn't start with the previous word's last letter or not saying a word quick enough.
#
# For example: apple -> eggs -> salmon -> nut -> turkey ...
#
# Your Task:
# You will be given a list of strings, a transcript of an English Shiritori match. Your task is to find out if the game ended early, and return a list that contains every valid string until the mistake. If a list is empty return an empty list. If one of the elements is an empty string, that is invalid and should be handled.
#
# Examples:
# All elements valid:
# The array {"dog","goose","elephant","tiger","rhino","orc","cat"}
#
# should return {"dog","goose","elephant","tiger","rhino","orc","cat"}
#
# An invalid element at index 2:
# The array {"dog","goose","tiger","cat", "elephant","rhino","orc"}
#
# should return ("dog","goose") since goose ends in 'e' and tiger starts with 't'
#
# An invalid empty string at index 2:
# The array {"ab","bc","","cd"}
#
# should return ("ab","bc")
#
# All invalid empty string at index 0:
# The array {"","bc","","cd"}
#
# should return An Empty List
#
# Resources:
# https://en.wikipedia.org/wiki/Shiritori
#
# Notes:
# 猫 = ねこ = neko = cat
#
# 小麦 = こむぎ = komugi = wheat
#
# FUNDAMENTALSALGORITHMSSTRINGS
def game(words):
    if not words or not words[0]:
        return []
    stack = [words[0]]
    for i in range(1, len(words)):
        if not words[i] or words[i][0] != stack[-1][-1]:
            break
        else:
            stack.append(words[i])
    return stack

# 2960. Count Tested Devices After Test Operations
# You are given a 0-indexed integer array batteryPercentages having length n, denoting the battery percentages of n 0-indexed devices.
#
# Your task is to test each device i in order from 0 to n - 1, by performing the following test operations:
#
# If batteryPercentages[i] is greater than 0:
# Increment the count of tested devices.
# Decrease the battery percentage of all devices with indices j in the range [i + 1, n - 1] by 1, ensuring their battery percentage never goes below 0, i.e, batteryPercentages[j] = max(0, batteryPercentages[j] - 1).
# Move to the next device.
# Otherwise, move to the next device without performing any test.
# Return an integer denoting the number of devices that will be tested after performing the test operations in order.
#
#
#
# Example 1:
#
# Input: batteryPercentages = [1,1,2,1,3]
# Output: 3
# Explanation: Performing the test operations in order starting from device 0:
# At device 0, batteryPercentages[0] > 0, so there is now 1 tested device, and batteryPercentages becomes [1,0,1,0,2].
# At device 1, batteryPercentages[1] == 0, so we move to the next device without testing.
# At device 2, batteryPercentages[2] > 0, so there are now 2 tested devices, and batteryPercentages becomes [1,0,1,0,1].
# At device 3, batteryPercentages[3] == 0, so we move to the next device without testing.
# At device 4, batteryPercentages[4] > 0, so there are now 3 tested devices, and batteryPercentages stays the same.
# So, the answer is 3.
# Example 2:
#
# Input: batteryPercentages = [0,1,2]
# Output: 2
# Explanation: Performing the test operations in order starting from device 0:
# At device 0, batteryPercentages[0] == 0, so we move to the next device without testing.
# At device 1, batteryPercentages[1] > 0, so there is now 1 tested device, and batteryPercentages becomes [0,1,1].
# At device 2, batteryPercentages[2] > 0, so there are now 2 tested devices, and batteryPercentages stays the same.
# So, the answer is 2.
#
#
# Constraints:
#
# 1 <= n == batteryPercentages.length <= 100
# 0 <= batteryPercentages[i] <= 100
# Solution 1 Similar bruteforce
# Complexity
# Time complexity: O(N**2 / 2)
#
# Space complexity: O(1)
#
# Code
class Solution(object):
    def countTestedDevices(self, batteryPercentages):
        count = 0
        for i in range(len(batteryPercentages)):
            if batteryPercentages[i] > 0:
                count += 1
                for j in range(i + 1, len(batteryPercentages)):
                    batteryPercentages[j] = max(0, batteryPercentages[j] - 1)
        return count
#
# Solution 2
# Complexity
# Time complexity: O(N)
#
# Space complexity: O(1)
#
class Solution(object):
    def countTestedDevices(self, batteryPercentages):
        count = 0
        for i in range(len(batteryPercentages)):
            count += batteryPercentages[i] > count
        return count

# 2961. Double Modular Exponentiation
# You are given a 0-indexed 2D array variables where variables[i] = [ai, bi, ci, mi], and an integer target.
#
# An index i is good if the following formula holds:
#
# 0 <= i < variables.length
# ((aibi % 10)ci) % mi == target
# Return an array consisting of good indices in any order.
#
#
#
# Example 1:
#
# Input: variables = [[2,3,3,10],[3,3,3,1],[6,1,1,4]], target = 2
# Output: [0,2]
# Explanation: For each index i in the variables array:
# 1) For the index 0, variables[0] = [2,3,3,10], (23 % 10)3 % 10 = 2.
# 2) For the index 1, variables[1] = [3,3,3,1], (33 % 10)3 % 1 = 0.
# 3) For the index 2, variables[2] = [6,1,1,4], (61 % 10)1 % 4 = 2.
# Therefore we return [0,2] as the answer.
# Example 2:
#
# Input: variables = [[39,3,1000,1000]], target = 17
# Output: []
# Explanation: For each index i in the variables array:
# 1) For the index 0, variables[0] = [39,3,1000,1000], (393 % 10)1000 % 1000 = 1.
# Therefore we return [] as the answer.
#
#
# Constraints:
#
# 1 <= variables.length <= 100
# variables[i] == [ai, bi, ci, mi]
# 1 <= ai, bi, ci, mi <= 103
# 0 <= target <= 103
# Solution O(N) O(N)
class Solution(object):
    def getGoodIndices(self, variables, target):
        out = set()
        for i in range(len(variables)):
            a, b, c, m = variables[i]
            if (a**b % 10)**c % m == target:
                out.add(i)
        return out

# 242. Valid Anagram
# Given two strings s and t, return true if t is an anagram of s, and false otherwise.
#
# An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.
#
#
#
# Example 1:
#
# Input: s = "anagram", t = "nagaram"
# Output: true
# Example 2:
#
# Input: s = "rat", t = "car"
# Output: false
#
#
# Constraints:
#
# 1 <= s.length, t.length <= 5 * 104
# s and t consist of lowercase English letters.
#
#
# Follow up: What if the inputs contain Unicode characters? How would you adapt your solution to such a case?
# Solution 1 - One HashTable O(N) O(N)
class Solution(object):
    def isAnagram(self, s, t):
        d = {}
        for i in s:
            d[i] = d.get(i, 0) + 1
        for i in t:
            d[i] = d.get(i, 0) - 1
        for i in d:
            if d[i] != 0:
                return False
        return True
# Solution 2 - Two HashTable O(N) O(N)
class Solution(object):
    def isAnagram(self, s, t):
        if len(s) != len(t):
            return False
        d1, d2 = {}, {}
        for i in s:
            if i  not in d1:
                d1[i] = 1
            else:
                d1[i] += 1
        for i in t:
            if i not in d2:
                d2[i] = 1
            else:
                d2[i] += 1
        return d1 == d2
 # Solution 3 - Similar Sorting O(N log(N)) O(N)
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        return sorted(s) == sorted(t)
# Solution 4 - One Liner O(N**2) O(N)
class Solution(object):
    def isAnagram(self, s, t):
        if len(s) != len(t):
            return False
        return all(s.count(i) == t.count(i) for i in t)
    
# Explosive Sum
# How many ways can you make the sum of a number?
# From wikipedia: https://en.wikipedia.org/wiki/Partition_(number_theory)
#
# In number theory and combinatorics, a partition of a positive integer n, also called an integer partition, is a way of writing n as a sum of positive integers. Two sums that differ only in the order of their summands are considered the same partition. If order matters, the sum becomes a composition. For example, 4 can be partitioned in five distinct ways:
#
# 4
# 3 + 1
# 2 + 2
# 2 + 1 + 1
# 1 + 1 + 1 + 1
# Examples
# Basic
# exp_sum(1) # 1
# exp_sum(2) # 2  -> 1+1 , 2
# exp_sum(3) # 3 -> 1+1+1, 1+2, 3
# exp_sum(4) # 5 -> 1+1+1+1, 1+1+2, 1+3, 2+2, 4
# exp_sum(5) # 7 -> 1+1+1+1+1, 1+1+1+2, 1+1+3, 1+2+2, 1+4, 5, 2+3
#
# exp_sum(10) # 42
# Explosive
# exp_sum(50) # 204226
# exp_sum(80) # 15796476
# exp_sum(100) # 190569292
# See here for more examples.
#
# ALGORITHMSMATHEMATICSFUNDAMENTALS
class PWithCache:
    def __init__(self):
        self.computed_pn = {0: 1}
    def __call__(self, n: int) -> int:
        if n in self.computed_pn:
            return self.computed_pn[n]
        total = 0
        for k in range(1, n+1):
            minus_one_term = n - k*(3*k-1)//2
            plus_one_term = n - k*(3*k+1)//2
            first_term = 0 if minus_one_term < 0 else self(minus_one_term)
            second_term = 0 if plus_one_term < 0 else self(plus_one_term)
            if k % 2:
                total += first_term + second_term
            else:
                total -= first_term + second_term
        self.computed_pn[n] = total
        return total

def exp_sum(n):
    P = PWithCache()
    return P(n)

# 2353. Design a Food Rating System
# Design a food rating system that can do the following:
#
# Modify the rating of a food item listed in the system.
# Return the highest-rated food item for a type of cuisine in the system.
# Implement the FoodRatings class:
#
# FoodRatings(String[] foods, String[] cuisines, int[] ratings) Initializes the system. The food items are described by foods, cuisines and ratings, all of which have a length of n.
# foods[i] is the name of the ith food,
# cuisines[i] is the type of cuisine of the ith food, and
# ratings[i] is the initial rating of the ith food.
# void changeRating(String food, int newRating) Changes the rating of the food item with the name food.
# String highestRated(String cuisine) Returns the name of the food item that has the highest rating for the given type of cuisine. If there is a tie, return the item with the lexicographically smaller name.
# Note that a string x is lexicographically smaller than string y if x comes before y in dictionary order, that is, either x is a prefix of y, or if i is the first position such that x[i] != y[i], then x[i] comes before y[i] in alphabetic order.
#
#
#
# Example 1:
#
# Input
# ["FoodRatings", "highestRated", "highestRated", "changeRating", "highestRated", "changeRating", "highestRated"]
# [[["kimchi", "miso", "sushi", "moussaka", "ramen", "bulgogi"], ["korean", "japanese", "japanese", "greek", "japanese", "korean"], [9, 12, 8, 15, 14, 7]], ["korean"], ["japanese"], ["sushi", 16], ["japanese"], ["ramen", 16], ["japanese"]]
# Output
# [null, "kimchi", "ramen", null, "sushi", null, "ramen"]
#
# Explanation
# FoodRatings foodRatings = new FoodRatings(["kimchi", "miso", "sushi", "moussaka", "ramen", "bulgogi"], ["korean", "japanese", "japanese", "greek", "japanese", "korean"], [9, 12, 8, 15, 14, 7]);
# foodRatings.highestRated("korean"); // return "kimchi"
#                                     // "kimchi" is the highest rated korean food with a rating of 9.
# foodRatings.highestRated("japanese"); // return "ramen"
#                                       // "ramen" is the highest rated japanese food with a rating of 14.
# foodRatings.changeRating("sushi", 16); // "sushi" now has a rating of 16.
# foodRatings.highestRated("japanese"); // return "sushi"
#                                       // "sushi" is the highest rated japanese food with a rating of 16.
# foodRatings.changeRating("ramen", 16); // "ramen" now has a rating of 16.
# foodRatings.highestRated("japanese"); // return "ramen"
#                                       // Both "sushi" and "ramen" have a rating of 16.
#                                       // However, "ramen" is lexicographically smaller than "sushi".
#
#
# Constraints:
#
# 1 <= n <= 2 * 104
# n == foods.length == cuisines.length == ratings.length
# 1 <= foods[i].length, cuisines[i].length <= 10
# foods[i], cuisines[i] consist of lowercase English letters.
# 1 <= ratings[i] <= 108
# All the strings in foods are distinct.
# food will be the name of a food item in the system across all calls to changeRating.
# cuisine will be a type of cuisine of at least one food item in the system across all calls to highestRated.
# At most 2 * 104 calls in total will be made to changeRating and highestRated.
from sortedcontainers import SortedList


class FoodRatings(object):
    def __init__(self, foods, cuisines, ratings):
        self.food_dct = {}
        self.csn_dct = defaultdict(SortedList)
        for food, cuisine, rating in zip(foods, cuisines, ratings):
            self.food_dct[food] = (cuisine, rating)
            self.csn_dct[cuisine].add((-rating, food))

    def changeRating(self, food, newRating):
        cuisine, rating = self.food_dct[food]
        self.food_dct[food] = cuisine, newRating
        self.csn_dct[cuisine].remove((-rating, food))
        self.csn_dct[cuisine].add((-newRating, food))

    def highestRated(self, cuisine):
        return self.csn_dct[cuisine][0][1]
    
# Common Denominators
# Common denominators
#
# You will have a list of rationals in the form
#
# { {numer_1, denom_1} , ... {numer_n, denom_n} }
# or
# [ [numer_1, denom_1] , ... [numer_n, denom_n] ]
# or
# [ (numer_1, denom_1) , ... (numer_n, denom_n) ]
# where all numbers are positive ints. You have to produce a result in the form:
#
# (N_1, D) ... (N_n, D)
# or
# [ [N_1, D] ... [N_n, D] ]
# or
# [ (N_1', D) , ... (N_n, D) ]
# or
# {{N_1, D} ... {N_n, D}}
# or
# "(N_1, D) ... (N_n, D)"
# depending on the language (See Example tests) in which D is as small as possible and
#
# N_1/D == numer_1/denom_1 ... N_n/D == numer_n,/denom_n.
# Example:
# convertFracs [(1, 2), (1, 3), (1, 4)] `shouldBe` [(6, 12), (4, 12), (3, 12)]
# Note:
# Due to the fact that the first translations were written long ago - more than 6 years - these first translations have only irreducible fractions.
#
# Newer translations have some reducible fractions. To be on the safe side it is better to do a bit more work by simplifying fractions even if they don't have to be.
#
# Note for Bash:
# input is a string, e.g "2,4,2,6,2,8" output is then "6 12 4 12 3 12"
#
# FUNDAMENTALSALGORITHMSMATHEMATICS
import math
def convertFracts(lst):
    D = 1
    for _, den in lst:
        D *= den // math.gcd(den, D)
    return [[D*n//d, D] for n, d in lst]

# 1913. Maximum Product Difference Between Two Pairs
# The product difference between two pairs (a, b) and (c, d) is defined as (a * b) - (c * d).
#
# For example, the product difference between (5, 6) and (2, 7) is (5 * 6) - (2 * 7) = 16.
# Given an integer array nums, choose four distinct indices w, x, y, and z such that the product difference between pairs (nums[w], nums[x]) and (nums[y], nums[z]) is maximized.
#
# Return the maximum such product difference.
#
#
#
# Example 1:
#
# Input: nums = [5,6,2,7,4]
# Output: 34
# Explanation: We can choose indices 1 and 3 for the first pair (6, 7) and indices 2 and 4 for the second pair (2, 4).
# The product difference is (6 * 7) - (2 * 4) = 34.
# Example 2:
#
# Input: nums = [4,2,5,9,7,4,8]
# Output: 64
# Explanation: We can choose indices 3 and 6 for the first pair (9, 8) and indices 1 and 5 for the second pair (2, 4).
# The product difference is (9 * 8) - (2 * 4) = 64.
#
#
# Constraints:
#
# 4 <= nums.length <= 104
# 1 <= nums[i] <= 104
class Solution(object):
    def maxProductDifference(self, nums):
        w, x = 0, 0,
        for i in range(len(nums)):
            if w <=  nums[i]:
                w, x, = nums[i], w
            elif x <= nums[i]:
                x = nums[i]
        y, z = float('inf'), float('inf')
        for i in range(len(nums)):
            if y >= nums[i]:
                y, z = nums[i], y
            elif z >= nums[i]:
                z = nums[i]
        return (w * x) - (y * z)
    
# Hamming Numbers
# A Hamming number is a positive integer of the form 2i3j5k, for some non-negative integers i, j, and k.
#
# Write a function that computes the nth smallest Hamming number.
#
# Specifically:
#
# The first smallest Hamming number is 1 = 203050
# The second smallest Hamming number is 2 = 213050
# The third smallest Hamming number is 3 = 203150
# The fourth smallest Hamming number is 4 = 223050
# The fifth smallest Hamming number is 5 = 203051
# The 20 smallest Hamming numbers are given in the Example test fixture.
#
# Your code should be able to compute the first 5 000 ( LC: 400, Clojure: 2 000, Haskell: 12 691, NASM, C, D, C++, Go and Rust: 13 282 ) Hamming numbers without timing out.
#
# NUMBER THEORYALGORITHMS
def hamming(n):
    l = [1]
    n2, n3, n5 = 0, 0, 0
    for i in range(1, n):
        mn = min(l[n2] * 2, l[n3] * 3, l[n5] * 5)
        if 2 * l[n2] == mn:
            n2 += 1
        if 3 * l[n3] == mn:
            n3 += 1
        if 5 * l[n5] == mn:
            n5 += 1
        l.append(mn)
    return l[-1]

# 661. Image Smoother
# An image smoother is a filter of the size 3 x 3 that can be applied to each cell of an image by rounding down the average of the cell and the eight surrounding cells (i.e., the average of the nine cells in the blue smoother). If one or more of the surrounding cells of a cell is not present, we do not consider it in the average (i.e., the average of the four cells in the red smoother).
#
#
# Given an m x n integer matrix img representing the grayscale of an image, return the image after applying the smoother on each cell of it.
#
#
#
# Example 1:
#
#
# Input: img = [[1,1,1],[1,0,1],[1,1,1]]
# Output: [[0,0,0],[0,0,0],[0,0,0]]
# Explanation:
# For the points (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0
# For the points (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0
# For the point (1,1): floor(8/9) = floor(0.88888889) = 0
# Example 2:
#
#
# Input: img = [[100,200,100],[200,50,200],[100,200,100]]
# Output: [[137,141,137],[141,138,141],[137,141,137]]
# Explanation:
# For the points (0,0), (0,2), (2,0), (2,2): floor((100+200+200+50)/4) = floor(137.5) = 137
# For the points (0,1), (1,0), (1,2), (2,1): floor((200+200+50+200+100+100)/6) = floor(141.666667) = 141
# For the point (1,1): floor((50+200+200+200+200+100+100+100+100)/9) = floor(138.888889) = 138
#
#
# Constraints:
#
# m == img.length
# n == img[i].length
# 1 <= m, n <= 200
# 0 <= img[i][j] <= 255
class Solution(object):
    def imageSmoother(self, img):
        """
        :type img: List[List[int]]
        :rtype: List[List[int]]
        """
        m, n = len(img), len(img[0])
        l = [[0 for i in range(n)] for j in range(m)]
        for i in range(m):
            for j in range(n):
                out = []
                out.append(img[i][j])
                if 0 <= i-1 < m:
                    out.append(img[i-1][j])
                    if 0 <= j-1 < n:
                        out.append(img[i-1][j-1])
                    if 0 <= j+1 < n:
                        out.append(img[i-1][j+1])
                if 0 <= j-1 < n:
                    out.append(img[i][j-1])
                if 0 <= j+1 < n:
                    out.append(img[i][j+1])
                if 0 <= i+1 < m:
                    out.append(img[i+1][j])
                    if 0 <= j-1 < n:
                        out.append(img[i+1][j-1])
                    if 0 <= j+1 < n:
                        out.append(img[i+1][j+1])
                l[i][j] = sum(out) // len(out)
        return l

# Validate Sudoku with size `NxN`
# Given a Sudoku data structure with size NxN, N > 0 and √N == integer, write a method to validate if it has been filled out correctly.
#
# The data structure is a multi-dimensional Array, i.e:
#
# [
#   [7,8,4,  1,5,9,  3,2,6],
#   [5,3,9,  6,7,2,  8,4,1],
#   [6,1,2,  4,3,8,  7,5,9],
#
#   [9,2,8,  7,1,5,  4,6,3],
#   [3,5,7,  8,4,6,  1,9,2],
#   [4,6,1,  9,2,3,  5,8,7],
#
#   [8,7,6,  3,9,4,  2,1,5],
#   [2,4,3,  5,6,1,  9,7,8],
#   [1,9,5,  2,8,7,  6,3,4]
# ]
# Rules for validation
#
# Data structure dimension: NxN where N > 0 and √N == integer
# Rows may only contain integers: 1..N (N included)
# Columns may only contain integers: 1..N (N included)
# 'Little squares' (3x3 in example above) may also only contain integers: 1..N (N included)
# ARRAYSPUZZLESALGORITHMS
class Sudoku(object):
    def __init__(self, data):
        self.data = data
    def is_valid(self):
        if any(len(i) != len(self.data) for i in self.data):
            return False
        for i in range(len(self.data)):
            s = set(range(1, len(self.data) + 1))
            for j in range(len(self.data)):
                if not isinstance(self.data[i][j], int) or type(self.data[i][j]) == bool:
                    return False
                if self.data[i][j] in s:
                    s.remove(self.data[i][j])
            if len(s) != 0:
                return False
        for i in range(len(self.data)):
            s = set(range(1, len(self.data) + 1))
            for j in range(len(self.data)):
                if self.data[j][i] in s:
                    s.remove(self.data[j][i])
            if len(s) != 0:
                return False
        step = 1
        while step ** 2 < len(self.data):
            step += 1
        pos = list(range(step))
        for i in range(0, len(self.data), step):
            for j in range(0, len(self.data), step):
                s = set(range(1, len(self.data) + 1))
                for k in pos:
                    for l in pos:
                        if self.data[i+k][j + l] not in s:
                            return False
                        else:
                            s.remove(self.data[i+k][j + l])
        return True

# 2706. Buy Two Chocolates
# You are given an integer array prices representing the prices of various chocolates in a store. You are also given a single integer money, which represents your initial amount of money.
#
# You must buy exactly two chocolates in such a way that you still have some non-negative leftover money. You would like to minimize the sum of the prices of the two chocolates you buy.
#
# Return the amount of money you will have leftover after buying the two chocolates. If there is no way for you to buy two chocolates without ending up in debt, return money. Note that the leftover must be non-negative.
#
#
#
# Example 1:
#
# Input: prices = [1,2,2], money = 3
# Output: 0
# Explanation: Purchase the chocolates priced at 1 and 2 units respectively. You will have 3 - 3 = 0 units of money afterwards. Thus, we return 0.
# Example 2:
#
# Input: prices = [3,2,3], money = 3
# Output: 3
# Explanation: You cannot buy 2 chocolates without going in debt, so we return 3.
#
#
# Constraints:
#
# 2 <= prices.length <= 50
# 1 <= prices[i] <= 100
# 1 <= money <= 100
# Solution O(N) O(1)
class Solution(object):
    def buyChoco(self, prices, money):
        ab_m, m = float('inf'), float('inf')
        for i in prices:
            if ab_m > i:
                ab_m, m = i, ab_m
            elif m > i:
                m = i
        return money - (ab_m + m) if ab_m + m <= money else money

# Vigenère Cipher Helper
# The Vigenère cipher is a classic cipher originally developed by Italian cryptographer Giovan Battista Bellaso and published in 1553. It is named after a later French cryptographer Blaise de Vigenère, who had developed a stronger autokey cipher (a cipher that incorporates the message of the text into the key).
#
# The cipher is easy to understand and implement, but survived three centuries of attempts to break it, earning it the nickname "le chiffre indéchiffrable" or "the indecipherable cipher."
#
# From Wikipedia:
#
# The Vigenère cipher is a method of encrypting alphabetic text by using a series of different Caesar ciphers based on the letters of a keyword. It is a simple form of polyalphabetic substitution.
#
# . . .
#
# In a Caesar cipher, each letter of the alphabet is shifted along some number of places; for example, in a Caesar cipher of shift 3, A would become D, B would become E, Y would become B and so on. The Vigenère cipher consists of several Caesar ciphers in sequence with different shift values.
#
# Assume the key is repeated for the length of the text, character by character. Note that some implementations repeat the key over characters only if they are part of the alphabet -- this is not the case here.
#
# The shift is derived by applying a Caesar shift to a character with the corresponding index of the key in the alphabet.
#
# Visual representation:
#
# "my secret code i want to secure"  // message
# "passwordpasswordpasswordpasswor"  // key
# Write a class that, when given a key and an alphabet, can be used to encode and decode from the cipher.
#
# Example
# var alphabet = 'abcdefghijklmnopqrstuvwxyz';
# var key = 'password';
#
# // creates a cipher helper with each letter substituted
# // by the corresponding character in the key
# var c = new VigenèreCipher(key, alphabet);
#
# c.encode('codewars'); // returns 'rovwsoiv'
# c.decode('laxxhsj');  // returns 'waffles'
# Any character not in the alphabet must be left as is. For example (following from above):
#
# c.encode('CODEWARS'); // returns 'CODEWARS'
# ALGORITHMSCIPHERSSECURITYOBJECT-ORIENTED PROGRAMMINGSTRINGS
class VigenereCipher(object):
    def __init__(self, key, alphabet):
        self.key = key * 10
        self.alphabet = alphabet * 2

    def encode(self, text):
        l = []
        for i in range(len(text)):
            if text[i].isalpha() and text[i] in self.alphabet:
                l.append(self.alphabet[self.alphabet.index(text[i]) + self.alphabet.index(self.key[i])])
            else:
                l.append(text[i])
        return ''.join(l)

    def decode(self, text):
        l = []
        for i in range(len(text)):
            if text[i].isalpha() and text[i] in self.alphabet:
                l.append(self.alphabet[
                             self.alphabet.index(text[i], len(self.alphabet) // 2) - self.alphabet.index(self.key[i])])
            else:
                l.append(text[i])
        return ''.join(l)

# 1637. Widest Vertical Area Between Two Points Containing No Points
# Given n points on a 2D plane where points[i] = [xi, yi], Return the widest vertical area between two points such that no points are inside the area.
#
# A vertical area is an area of fixed-width extending infinitely along the y-axis (i.e., infinite height). The widest vertical area is the one with the maximum width.
#
# Note that points on the edge of a vertical area are not considered included in the area.
#
#
#
# Example 1:
#
# ​
# Input: points = [[8,7],[9,9],[7,4],[9,7]]
# Output: 1
# Explanation: Both the red and the blue area are optimal.
# Example 2:
#
# Input: points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]]
# Output: 3
#
#
# Constraints:
#
# n == points.length
# 2 <= n <= 105
# points[i].length == 2
# 0 <= xi, yi <= 109
# Solution O(N log N) O(1)
class Solution:
    def maxWidthOfVerticalArea(self, points: List[List[int]]) -> int:
        points.sort()
        top, strt = 0, points[0][0]
        for i in range(1, len(points)):
            if points[i][0] != strt:
                top = max(top, points[i][0] - strt)
                strt = points[i][0]
        return top
# Solution 2 O(N log N) O(N)
class Solution:
    def maxWidthOfVerticalArea(self, points: List[List[int]]) -> int:
        l = sorted({x for x, y in points})
        return max([x2 - x1 for x1, x2 in zip(l, l[1:])] + [0])

# Financing Plan on Planet XY140Z-n
# I need to save some money to buy a gift. I think I can do something like that:
#
# First week (W0) I save nothing on Sunday, 1 on Monday, 2 on Tuesday... 6 on Saturday, second week (W1) 2 on Monday... 7 on Saturday and so on according to the table below where the days are numbered from 0 to 6.
#
# Can you tell me how much I will have for my gift on Saturday evening after I have saved 12? (Your function finance(6) should return 168 which is the sum of the savings in the table).
#
# Imagine now that we live on planet XY140Z-n where the days of the week are numbered from 0 to n (integer n > 0) and where I save from week number 0 to week number n included (in the table below n = 6).
#
# How much money would I have at the end of my financing plan on planet XY140Z-n?
#
# --	Su	Mo	Tu	We	Th	Fr	Sa
# W6							12
# W5						10	11
# W4					8	9	10
# W3				6	7	8	9
# W2			4	5	6	7	8
# W1		2	3	4	5	6	7
# W0	0	1	2	3	4	5	6
# Example:
# finance(5) --> 105
# finance(6) --> 168
# finance(7) --> 252
# finance(5000) --> 62537505000
# Note:
# your solution will be nicer without loops.
#
# MATHEMATICSALGORITHMS
# Solution 1
def finance(n):
    count = 3
    for i in range(2, n + 1):
        count += sum(range(i, i*2 + 1))
    return count
# Solution 2 Math solution
def finance(n):
    return n * (n + 1) * (n + 2) / 2

# 1422. Maximum Score After Splitting a String
# Given a string s of zeros and ones, return the maximum score after splitting the string into two non-empty substrings (i.e. left substring and right substring).
#
# The score after splitting a string is the number of zeros in the left substring plus the number of ones in the right substring.
#
#
#
# Example 1:
#
# Input: s = "011101"
# Output: 5
# Explanation:
# All possible ways of splitting s into two non-empty substrings are:
# left = "0" and right = "11101", score = 1 + 4 = 5
# left = "01" and right = "1101", score = 1 + 3 = 4
# left = "011" and right = "101", score = 1 + 2 = 3
# left = "0111" and right = "01", score = 1 + 1 = 2
# left = "01110" and right = "1", score = 2 + 1 = 3
# Example 2:
#
# Input: s = "00111"
# Output: 5
# Explanation: When left = "00" and right = "111", we get the maximum score = 2 + 3 = 5
# Example 3:
#
# Input: s = "1111"
# Output: 3
#
#
# Constraints:
#
# 2 <= s.length <= 500
# The string s consists of characters '0' and '1' only.
# Solution O(N) O(1)
class Solution:
    def maxScore(self, s: str) -> int:
        count_s = s.count('1', 1)
        if s[0] == '0':
            count_s += 1
        total = count_s
        for i in range(1, len(s) - 1):
            if s[i] == '0':
                count_s += 1
            else:
                count_s -= 1
            total = max(total, count_s)
        return total

# Least Common Multiple
# Write a function that calculates the least common multiple of its arguments; each argument is assumed to be a non-negative integer. In the case that there are no arguments (or the provided array in compiled languages is empty), return 1. If any argument is 0, return 0.
#
# MATHEMATICSALGORITHMS
def lcm(*args):
    if not args:
        return 1
    if 0 in args:
        return 0
    m = max(args)
    lcm = m
    while any(lcm % i != 0 for i in args):
        lcm += m
    return lcm

# 1496. Path Crossing
# Given a string path, where path[i] = 'N', 'S', 'E' or 'W', each representing moving one unit north, south, east, or west, respectively. You start at the origin (0, 0) on a 2D plane and walk on the path specified by path.
#
# Return true if the path crosses itself at any point, that is, if at any time you are on a location you have previously visited. Return false otherwise.
#
#
#
# Example 1:
#
#
# Input: path = "NES"
# Output: false
# Explanation: Notice that the path doesn't cross any point more than once.
# Example 2:
#
#
# Input: path = "NESWW"
# Output: true
# Explanation: Notice that the path visits the origin twice.
#
#
# Constraints:
#
# 1 <= path.length <= 104
# path[i] is either 'N', 'S', 'E', or 'W'.
# Solution O(N) O(N)
class Solution:
    def isPathCrossing(self, path: str) -> bool:
        x, y = 0, 0
        st = {(x, y)}
        for i in path:
            x += 1 if i == 'E' else (-1 if i == 'W' else 0)
            y += 1 if i == 'N' else (-1 if i == 'S' else 0)
            if (x, y) in st:
                return True
            st.add((x, y))
        return False

# flatten()
# For this exercise you will create a global flatten method. The method takes in any number of arguments and flattens them into a single array. If any of the arguments passed in are an array then the individual objects within the array will be flattened so that they exist at the same level as the other arguments. Any nested arrays, no matter how deep, should be flattened into the single array result.
#
# The following are examples of how this function would be used and what the expected results would be:
#
# flatten(1, [2, 3], 4, 5, [6, [7]]) # returns [1, 2, 3, 4, 5, 6, 7]
# flatten('a', ['b', 2], 3, None, [[4], ['c']]) # returns ['a', 'b', 2, 3, None, 4, 'c']
# ARRAYSALGORITHMS
def flatten(*args):
    if not args:
        return []
    l = []
    for i in args:
        if isinstance(i, list):
            l += flatten(*i)
        else:
            l += [i]
    return l

# 2966. Divide Array Into Arrays With Max Difference
# You are given an integer array nums of size n and a positive integer k.
#
# Divide the array into one or more arrays of size 3 satisfying the following conditions:
#
# Each element of nums should be in exactly one array.
# The difference between any two elements in one array is less than or equal to k.
# Return a 2D array containing all the arrays. If it is impossible to satisfy the conditions, return an empty array. And if there are multiple answers, return any of them.
#
#
#
# Example 1:
#
# Input: nums = [1,3,4,8,7,9,3,5,1], k = 2
# Output: [[1,1,3],[3,4,5],[7,8,9]]
# Explanation: We can divide the array into the following arrays: [1,1,3], [3,4,5] and [7,8,9].
# The difference between any two elements in each array is less than or equal to 2.
# Note that the order of elements is not important.
# Example 2:
#
# Input: nums = [1,3,3,2,7,3], k = 3
# Output: []
# Explanation: It is not possible to divide the array satisfying all the conditions.
#
#
# Constraints:
#
# n == nums.length
# 1 <= n <= 105
# n is a multiple of 3.
# 1 <= nums[i] <= 105
# 1 <= k <= 105
# Solution O(N log N) O(N)
class Solution(object):
    def divideArray(self, nums, k):
        if len(nums) < 3:
            return []
        nums.sort()
        l = []
        for i in range(0, len(nums), 3):
            if nums[i + 2] - nums[i] > k:
                return []
            else:
                l.append(nums[i:i+3])
        return l
    
# 2965. Find Missing and Repeated Values
# You are given a 0-indexed 2D integer matrix grid of size n * n with values in the range [1, n2]. Each integer appears exactly once except a which appears twice and b which is missing. The task is to find the repeating and missing numbers a and b.
#
# Return a 0-indexed integer array ans of size 2 where ans[0] equals to a and ans[1] equals to b.
#
#
#
# Example 1:
#
# Input: grid = [[1,3],[2,2]]
# Output: [2,4]
# Explanation: Number 2 is repeated and number 4 is missing so the answer is [2,4].
# Example 2:
#
# Input: grid = [[9,1,7],[8,9,2],[3,4,6]]
# Output: [9,5]
# Explanation: Number 9 is repeated and number 5 is missing so the answer is [9,5].
#
#
# Constraints:
#
# 2 <= n == grid.length == grid[i].length <= 50
# 1 <= grid[i][j] <= n * n
# For all x that 1 <= x <= n * n there is exactly one x that is not equal to any of the grid members.
# For all x that 1 <= x <= n * n there is exactly one x that is equal to exactly two of the grid members.
# For all x that 1 <= x <= n * n except two of them there is exatly one pair of i, j that 0 <= i, j <= n - 1 and grid[i][j] == x.
# Solution O(N) O(N) Math
class Solution(object):
    def findMissingAndRepeatedValues(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: List[int]
        """
        n = len(grid)
        sm, total, sn = n**2 * (n**2 + 1) // 2, 0, set()
        for i in range(n):
            for j in range(n):
                total += grid[i][j]
                if grid[i][j] in sn:
                    rep_num = grid[i][j]
                sn.add(grid[i][j])
        return [rep_num, (sm - total) + rep_num]

# 1758. Minimum Changes To Make Alternating Binary String
# You are given a string s consisting only of the characters '0' and '1'. In one operation, you can change any '0' to '1' or vice versa.
#
# The string is called alternating if no two adjacent characters are equal. For example, the string "010" is alternating, while the string "0100" is not.
#
# Return the minimum number of operations needed to make s alternating.
#
#
#
# Example 1:
#
# Input: s = "0100"
# Output: 1
# Explanation: If you change the last character to '1', s will be "0101", which is alternating.
# Example 2:
#
# Input: s = "10"
# Output: 0
# Explanation: s is already alternating.
# Example 3:
#
# Input: s = "1111"
# Output: 2
# Explanation: You need two operations to reach "0101" or "1010".
#
#
# Constraints:
#
# 1 <= s.length <= 104
# s[i] is either '0' or '1'.
# Solution 1 - O(N) O(1) HashSet
class Solution:
    def minOperations(self, s: str) -> int:
        d = {'0':'1', '1':'0'}
        top, count = 0, 0
        cur = '0'
        for i in range(len(s)):
            if cur == s[i]:
                count += 1
                cur = d[cur]
            else:
                cur = s[i]
        top = count
        count, cur = 0, '1'
        for i in range(len(s)):
            if cur == s[i]:
                count += 1
                cur = d[cur]
            else:
                cur = s[i]
        return min(top, count)
# Solution 2 OnePass O(N) O(N)
class Solution:
    def minOperations(self, s: str) -> int:
        count_one, count_zero = 0, 0
        cur_zero, cur_one = '0', '1'
        for i in range(len(s)):
            if s[i] == cur_zero:
                count_zero += 1
            else:
                count_one += 1
            cur_one, cur_zero = cur_zero, cur_one
        return min(count_zero, count_one)
    
# Sorting by bits
# In this kata you're expected to sort an array of 32-bit integers in ascending order of the number of on bits they have.
#
# E.g Given the array [7, 6, 15, 8]
#
# 7 has 3 on bits (000...0111)
# 6 has 2 on bits (000...0110)
# 15 has 4 on bits (000...1111)
# 8 has 1 on bit (000...1000)
# So the array in sorted order would be [8, 6, 7, 15].
#
# In cases where two numbers have the same number of bits, compare their real values instead.
#
# E.g between 10 (...1010) and 12 (...1100), they both have the same number of on bits '2' but the integer 10 is less than 12 so it comes first in sorted order.
#
# Your task is to write a function that takes an array of integers and sort them as described above.
#
# Note: your solution has to sort the array in place.
#
# Example:
#
# [3, 8, 3, 6, 5, 7, 9, 1]   =>    [1, 8, 3, 3, 5, 6, 9, 7]
# LOGICARRAYSALGORITHMSDATA STRUCTURESFUNDAMENTALSBITSBINARYSORTING
# Solution 1 - Using sort
def sort_by_bit(arr):
    arr.sort(key=lambda x: (bin(x).count('1'), x))
# Solution 2 -Bubble sort
def sort_by_bit(arr):
    for i in range(1, len(arr)):
        for j in range(len(arr) - i):
            top = bin(arr[j])[2:].count('1')
            x = bin(arr[j + 1])[2:].count('1')
            if top > x:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
            elif top == x:
                m = min(arr[j], arr[j + 1])
                m_ind = j if arr[j] == m else j + 1
                arr[j], arr[j + 1] = arr[m_ind], arr[j if j != m_ind else j + 1]

# 91. Decode Ways
# A message containing letters from A-Z can be encoded into numbers using the following mapping:
#
# 'A' -> "1"
# 'B' -> "2"
# ...
# 'Z' -> "26"
# To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, "11106" can be mapped into:
#
# "AAJF" with the grouping (1 1 10 6)
# "KJF" with the grouping (11 10 6)
# Note that the grouping (1 11 06) is invalid because "06" cannot be mapped into 'F' since "6" is different from "06".
#
# Given a string s containing only digits, return the number of ways to decode it.
#
# The test cases are generated so that the answer fits in a 32-bit integer.
#
#
#
# Example 1:
#
# Input: s = "12"
# Output: 2
# Explanation: "12" could be decoded as "AB" (1 2) or "L" (12).
# Example 2:
#
# Input: s = "226"
# Output: 3
# Explanation: "226" could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).
# Example 3:
#
# Input: s = "06"
# Output: 0
# Explanation: "06" cannot be mapped to "F" because of the leading zero ("6" is different from "06").
#
#
# Constraints:
#
# 1 <= s.length <= 100
# s contains only digits and may contain leading zero(s).
# Solution 1 - DP O(N) O(N)
class Solution:
    def numDecodings(self, s: str) -> int:
        count1, count2 = 1 if s[0] > '0' else 0, 0
        top = s[0]
        for i in s[1:]:
            prev = count1
            top += i
            if i > '0':
                count1 = count1 + count2
            else:
                count1 = 0
            if len(top) == 2:
                if '09' < top <= '26':
                    count2 = prev
                else:
                    count2 = 0
                top = top[-1]
        return count1 + count2
# Solution 2 DP O(N) O(N)
class Solution:
    def numDecodings(self, s: str) -> int:
        dp = [0 for i in range(len(s) + 1)]
        dp[0] = 1
        dp[1] = 0 if s[0] == '0' else 1
        for i in range(2, len(s) + 1):
            if 0 < int(s[i - 1]) <= 9:
                dp[i] += dp[i - 1]
            if 10 <= int(s[i - 2:i]) <= 26:
                dp[i] += dp[i - 2]
        return dp[len(s)]
    
# PatternCraft - Decorator
# The Decorator Design Pattern can be used, for example, in the StarCraft game to manage upgrades.
#
# The pattern consists in "incrementing" your base class with extra functionality.
#
# A decorator will receive an instance of the base class and use it to create a new instance with the new things you want "added on it".
#
# Your Task
# Complete the code so that when a Marine gets a WeaponUpgrade it increases the damage by 1, and if it is a ArmorUpgrade then increase the armor by 1.
#
# You have 3 classes:
#
# Marine: has a damage and an armor properties
# MarineWeaponUpgrade and MarineArmorUpgrade: upgrades to apply on marine. Accepts a Marine in the constructor and has the same properties as the Marine
# Resouces
# PatternCraft > Decorator
# SourceMaking > Decorator
# Wikipedia > Decorator
# PatternCraft series
# State Pattern
# Strategy Pattern
# Visitor Pattern
# Decorator Pattern
# Adapter Pattern
# Command Pattern
# The original PatternCraft series (by John Lindquist) is a collection of Youtube videos that explains some of the design patterns and how they are used (or could be) on StarCraft.
#
# DESIGN PATTERNSFUNDAMENTALS
class Marine:
    def __init__(self, damage, armor):
        self.damage = damage
        self.armor = armor
class Marine_weapon_upgrade:
    def __init__(self, marine):
        self.marine = marine
        self.damage = self.marine.damage + 1
        self.armor = self.marine.armor

class Marine_armor_upgrade:
    def __init__(self, marine):
        self.marine = marine
        self.armor = self.marine.armor + 1
        self.damage = self.marine.damage
        
# 2970. Count the Number of Incremovable Subarrays I
# You are given a 0-indexed array of positive integers nums.
#
# A subarray of nums is called incremovable if nums becomes strictly increasing on removing the subarray. For example, the subarray [3, 4] is an incremovable subarray of [5, 3, 4, 6, 7] because removing this subarray changes the array [5, 3, 4, 6, 7] to [5, 6, 7] which is strictly increasing.
#
# Return the total number of incremovable subarrays of nums.
#
# Note that an empty array is considered strictly increasing.
#
# A subarray is a contiguous non-empty sequence of elements within an array.
#
#
#
# Example 1:
#
# Input: nums = [1,2,3,4]
# Output: 10
# Explanation: The 10 incremovable subarrays are: [1], [2], [3], [4], [1,2], [2,3], [3,4], [1,2,3], [2,3,4], and [1,2,3,4], because on removing any one of these subarrays nums becomes strictly increasing. Note that you cannot select an empty subarray.
# Example 2:
#
# Input: nums = [6,5,7,8]
# Output: 7
# Explanation: The 7 incremovable subarrays are: [5], [6], [5,7], [6,5], [5,7,8], [6,5,7] and [6,5,7,8].
# It can be shown that there are only 7 incremovable subarrays in nums.
# Example 3:
#
# Input: nums = [8,7,6,6]
# Output: 3
# Explanation: The 3 incremovable subarrays are: [8,7,6], [7,6,6], and [8,7,6,6]. Note that [8,7] is not an incremovable subarray because after removing [8,7] nums becomes [6,6], which is sorted in ascending order but not strictly increasing.
#
#
# Constraints:
#
# 1 <= nums.length <= 50
# 1 <= nums[i] <= 50
# Solution O(N**3) O(1)
class Solution:
    def incremovableSubarrayCount(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return 1
        count = 0
        for i in range(len(nums)):
            for j in range(i, len(nums)):
                x = nums[:i] + nums[j+1:]
                if all(i < j for i, j in zip(x, x[1:])):
                    count += 1
        return count

# 2974. Minimum Number Game
# You are given a 0-indexed integer array nums of even length and there is also an empty array arr. Alice and Bob decided to play a game where in every round Alice and Bob will do one move. The rules of the game are as follows:
#
# Every round, first Alice will remove the minimum element from nums, and then Bob does the same.
# Now, first Bob will append the removed element in the array arr, and then Alice does the same.
# The game continues until nums becomes empty.
# Return the resulting array arr.
#
#
#
# Example 1:
#
# Input: nums = [5,4,2,3]
# Output: [3,2,5,4]
# Explanation: In round one, first Alice removes 2 and then Bob removes 3. Then in arr firstly Bob appends 3 and then Alice appends 2. So arr = [3,2].
# At the begining of round two, nums = [5,4]. Now, first Alice removes 4 and then Bob removes 5. Then both append in arr which becomes [3,2,5,4].
# Example 2:
#
# Input: nums = [2,5]
# Output: [5,2]
# Explanation: In round one, first Alice removes 2 and then Bob removes 5. Then in arr firstly Bob appends and then Alice appends. So arr = [5,2].
#
#
# Constraints:
#
# 1 <= nums.length <= 100
# 1 <= nums[i] <= 100
# nums.length % 2 == 0
# Solution 1
# Complexity
# Time complexity: O(N*N)
# Space complexity: O(N)
#
# Code
class Solution:
    def numberGame(self, nums: List[int]) -> List[int]:
        l  = []
        for j in range(len(nums) // 2):
            ab_top, top = float('inf'), float('inf')
            for i in nums:
                if ab_top > i:
                    ab_top, top = i, ab_top
                elif top > i:
                    top = i
            l += [top, ab_top]
            nums.remove(top)
            nums.remove(ab_top)
        return l

# Solution 2 - Sorting and Bubble Sort

# Complexity
# Time complexity: O(N log N)
# Space complexity: O(1)
# Code
class Solution:
    def numberGame(self, nums: List[int]) -> List[int]:
        nums.sort()
        for i in range(1, len(nums), 2):
            nums[i-1], nums[i] = nums[i], nums[i-1]
        return nums

# 2971. Find Polygon With the Largest Perimeter
# You are given an array of positive integers nums of length n.
#
# A polygon is a closed plane figure that has at least 3 sides. The longest side of a polygon is smaller than the sum of its other sides.
#
# Conversely, if you have k (k >= 3) positive real numbers a1, a2, a3, ..., ak where a1 <= a2 <= a3 <= ... <= ak and a1 + a2 + a3 + ... + ak-1 > ak, then there always exists a polygon with k sides whose lengths are a1, a2, a3, ..., ak.
#
# The perimeter of a polygon is the sum of lengths of its sides.
#
# Return the largest possible perimeter of a polygon whose sides can be formed from nums, or -1 if it is not possible to create a polygon.
#
#
#
# Example 1:
#
# Input: nums = [5,5,5]
# Output: 15
# Explanation: The only possible polygon that can be made from nums has 3 sides: 5, 5, and 5. The perimeter is 5 + 5 + 5 = 15.
# Example 2:
#
# Input: nums = [1,12,1,2,5,50,3]
# Output: 12
# Explanation: The polygon with the largest perimeter which can be made from nums has 5 sides: 1, 1, 2, 3, and 5. The perimeter is 1 + 1 + 2 + 3 + 5 = 12.
# We cannot have a polygon with either 12 or 50 as the longest side because it is not possible to include 2 or more smaller sides that have a greater sum than either of them.
# It can be shown that the largest possible perimeter is 12.
# Example 3:
#
# Input: nums = [5,5,50]
# Output: -1
# Explanation: There is no possible way to form a polygon from nums, as a polygon has at least 3 sides and 50 > 5 + 5.
#
#
# Constraints:
#
# 3 <= n <= 105
# 1 <= nums[i] <= 109
# Complexity
# Time complexity: O(N log N)
# Space complexity: O(1)
#
# Code
class Solution:
    def largestPerimeter(self, nums: List[int]) -> int:
        nums.sort()
        l: int = -1
        s: int = sum(nums[:2])
        for i in range(2, len(nums)):
            if nums[i] < s:
                l = nums[i] + s
            s += nums[i]
        return l
    
# 1155. Number of Dice Rolls With Target Sum
# You have n dice, and each die has k faces numbered from 1 to k.
#
# Given three integers n, k, and target, return the number of possible ways (out of the kn total ways) to roll the dice, so the sum of the face-up numbers equals target. Since the answer may be too large, return it modulo 109 + 7.
#
#
#
# Example 1:
#
# Input: n = 1, k = 6, target = 3
# Output: 1
# Explanation: You throw one die with 6 faces.
# There is only one way to get a sum of 3.
# Example 2:
#
# Input: n = 2, k = 6, target = 7
# Output: 6
# Explanation: You throw two dice, each with 6 faces.
# There are 6 ways to get a sum of 7: 1+6, 2+5, 3+4, 4+3, 5+2, 6+1.
# Example 3:
#
# Input: n = 30, k = 30, target = 500
# Output: 222616187
# Explanation: The answer must be returned modulo 109 + 7.
#
#
# Constraints:
#
# 1 <= n, k <= 30
# 1 <= target <= 1000
# Solution
class Solution:
    def numRollsToTarget(self, n: int, k: int, target: int) -> int:
        memorization: dict = {}
        def dp(n: int, target: int) -> int:
            if n == 0:
                return 0 if target > 0 else 1
            if (n, target) in memorization:
                return memorization[(n, target)]
            total: int = 0
            for f in range(max(0, target-k), target):
                total += dp(n-1, f)
            memorization[(n, target)] = total
            return total
        return dp(n, target) % (10**9 + 7)
    
# Vector class
# Create a Vector object that supports addition, subtraction, dot products, and norms. So, for example:
#
# a = Vector([1, 2, 3])
# b = Vector([3, 4, 5])
# c = Vector([5, 6, 7, 8])
#
# a.add(b)      # should return a new Vector([4, 6, 8])
# a.subtract(b) # should return a new Vector([-2, -2, -2])
# a.dot(b)      # should return 1*3 + 2*4 + 3*5 = 26
# a.norm()      # should return sqrt(1^2 + 2^2 + 3^2) = sqrt(14)
# a.add(c)      # raises an exception
# If you try to add, subtract, or dot two vectors with different lengths, you must throw an error!
#
# Also provide:
#
# a toString method, so that using the vectors from above, a.toString() === '(1,2,3)' (in Python, this is a __str__ method, so that str(a) == '(1,2,3)')
# an equals method, to check that two vectors that have the same components are equal
# Note: the test cases will utilize the user-provided equals method.
#
# OBJECT-ORIENTED PROGRAMMINGALGORITHMSLINEAR ALGEBRA
class Vector:
    def __init__(self, arr: list):
        self.vector = arr
    def add(self, new_vector):
        if len(new_vector.vector) != len(self.vector):
            raise Error
        return Vector([x + y for x, y in zip(self.vector, new_vector.vector)])
    def equals(self, new_vector):
        return all(i == j for i,j in zip(self.vector, new_vector.vector))
    def subtract(self, new_vector):
        return Vector([x - y for x, y in zip(self.vector, new_vector.vector)])
    def dot(self, new_vector):
        return sum(x * y for x, y in zip(self.vector, new_vector.vector))
    def norm(self):
        return sum(i**2 for i in self.vector) ** .5
    def __str__(self):
        return f"({','.join(str(i) for i in self.vector)})"
    
# 1578. Minimum Time to Make Rope Colorful
# Alice has n balloons arranged on a rope. You are given a 0-indexed string colors where colors[i] is the color of the ith balloon.
#
# Alice wants the rope to be colorful. She does not want two consecutive balloons to be of the same color, so she asks Bob for help. Bob can remove some balloons from the rope to make it colorful. You are given a 0-indexed integer array neededTime where neededTime[i] is the time (in seconds) that Bob needs to remove the ith balloon from the rope.
#
# Return the minimum time Bob needs to make the rope colorful.
#
#
#
# Example 1:
#
#
# Input: colors = "abaac", neededTime = [1,2,3,4,5]
# Output: 3
# Explanation: In the above image, 'a' is blue, 'b' is red, and 'c' is green.
# Bob can remove the blue balloon at index 2. This takes 3 seconds.
# There are no longer two consecutive balloons of the same color. Total time = 3.
# Example 2:
#
#
# Input: colors = "abc", neededTime = [1,2,3]
# Output: 0
# Explanation: The rope is already colorful. Bob does not need to remove any balloons from the rope.
# Example 3:
#
#
# Input: colors = "aabaa", neededTime = [1,2,3,4,1]
# Output: 2
# Explanation: Bob will remove the ballons at indices 0 and 4. Each ballon takes 1 second to remove.
# There are no longer two consecutive balloons of the same color. Total time = 1 + 1 = 2.
#
#
# Constraints:
#
# n == colors.length == neededTime.length
# 1 <= n <= 105
# 1 <= neededTime[i] <= 104
# colors contains only lowercase English letters.
# Solution 1 - O(N) O(1)
class Solution:
    def minCost(self, colors: str, neededTime: List[int]) -> int:
        if len(colors) == 1:
            return 0
        count, s, top = 0, 0, 0
        for i in range(1, len(colors)):
            s += neededTime[i-1]
            top = max(top, neededTime[i-1])
            if colors[i-1] != colors[i]:
                count += s - top
                s, top = 0, 0
        if colors[-2] == colors[-1]:
            s += neededTime[-1]
            top = max(top, neededTime[-1])
            count += s - top
        return count
# Solution 2 - O(N) O(1) But shorter than solution above
class Solution:
    def minCost(self, colors: str, neededTime: List[int]) -> int:
        sm, mx = 0, 0
        for i in range(len(colors)):
            if colors[i-1] != colors[i]:
                mx = 0
            sm += min(mx, neededTime[i])
            mx = max(mx, neededTime[i])
        return sm

# Custom FizzBuzz Array
# Write a function that returns a (custom) FizzBuzz sequence of the numbers 1 to 100.
#
# The function should be able to take up to 4 arguments:
#
# The 1st and 2nd arguments are strings, "Fizz" and "Buzz" by default;
# The 3rd and 4th arguments are integers, 3 and 5 by default.
# Thus, when the function is called without arguments, it will return the classic FizzBuzz sequence up to 100:
#
# [ 1, 2, "Fizz", 4, "Buzz", "Fizz", 7, ... 14, "FizzBuzz", 16, 17, ... 98, "Fizz", "Buzz" ]
# When the function is called with (up to 4) arguments, it should return a custom FizzBuzz sequence, for example:
#
# ('Hey', 'There')      -->  [ 1, 2, "Hey", 4, "There", "Hey", ... ]
# ('Foo', 'Bar', 2, 3)  -->  [ 1, "Foo", "Bar", "Foo", 5, "FooBar", 7, ... ]
# Examples
# fizz_buzz_custom()[15]                         # returns 16
# fizz_buzz_custom()[44]                         # returns "FizzBuzz" (45 is divisible by 3 and 5)
# fizz_buzz_custom('Hey', 'There')[25]         # returns 26
# fizz_buzz_custom('Hey', 'There')[11]         # returns "Hey" (12 is divisible by 3)
# fizz_buzz_custom("What's ", "up?", 3, 7)[80] # returns "What's " (81 is divisible by 3)
# The function must return the sequence as a list.
#
# ARRAYSLOGICFUNDAMENTALS
def fizz_buzz_custom(string_one='Fizz', string_two='Buzz', num_one=3, num_two=5):
    l: list = []
    for i in range(1, 101):
        if i % num_one == 0 and i % num_two == 0:
            l.append(string_one + string_two)
        elif i % num_one == 0:
            l.append(string_one)
        elif i % num_two == 0:
            l.append(string_two)
        else:
            l.append(i)
    return l

# 1531. String Compression II
# Run-length encoding is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string "aabccc" we replace "aa" by "a2" and replace "ccc" by "c3". Thus the compressed string becomes "a2bc3".
#
# Notice that in this problem, we are not adding '1' after single characters.
#
# Given a string s and an integer k. You need to delete at most k characters from s such that the run-length encoded version of s has minimum length.
#
# Find the minimum length of the run-length encoded version of s after deleting at most k characters.
#
#
#
# Example 1:
#
# Input: s = "aaabcccd", k = 2
# Output: 4
# Explanation: Compressing s without deleting anything will give us "a3bc3d" of length 6. Deleting any of the characters 'a' or 'c' would at most decrease the length of the compressed string to 5, for instance delete 2 'a' then we will have s = "abcccd" which compressed is abc3d. Therefore, the optimal way is to delete 'b' and 'd', then the compressed version of s will be "a3c3" of length 4.
# Example 2:
#
# Input: s = "aabbaa", k = 2
# Output: 2
# Explanation: If we delete both 'b' characters, the resulting compressed string would be "a4" of length 2.
# Example 3:
#
# Input: s = "aaaaaaaaaaa", k = 0
# Output: 3
# Explanation: Since k is zero, we cannot delete anything. The compressed string is "a11" of length 3.
#
#
# Constraints:
#
# 1 <= s.length <= 100
# 0 <= k <= s.length
# s contains only lowercase English letters.
class Solution:
    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:
        @lru_cache(None)
        def dp(i, prev, prev_cnt, k):
            if k < 0:
                return float('inf')
            if i >= len(s):
                return 0
            delete = dp(i + 1, prev, prev_cnt, k - 1)
            if s[i] == prev:
                keep = dp(i + 1, prev, prev_cnt + 1, k)
                if prev_cnt in {1, 9, 99}:
                    keep += 1
            else:
                keep = dp(i + 1, s[i], 1, k) + 1
            return min(delete, keep)
        return dp(0, '', 0, k)
    
# Square Matrix Multiplication
# Write a function that accepts two square (NxN) matrices (two dimensional arrays), and returns the product of the two. Only square matrices will be given.
#
# How to multiply two square matrices:
#
# We are given two matrices, A and B, of size 2x2 (note: tests are not limited to 2x2). Matrix C, the solution, will be equal to the product of A and B. To fill in cell [0][0] of matrix C, you need to compute: A[0][0] * B[0][0] + A[0][1] * B[1][0].
#
# More general: To fill in cell [n][m] of matrix C, you need to first multiply the elements in the nth row of matrix A by the elements in the mth column of matrix B, then take the sum of all those products. This will give you the value for cell [m][n] in matrix C.
#
# Example
#   A         B          C
# |1 2|  x  |3 2|  =  | 5 4|
# |3 2|     |1 1|     |11 8|
# Detailed calculation:
#
# C[0][0] = A[0][0] * B[0][0] + A[0][1] * B[1][0] = 1*3 + 2*1 =  5
# C[0][1] = A[0][0] * B[0][1] + A[0][1] * B[1][1] = 1*2 + 2*1 =  4
# C[1][0] = A[1][0] * B[0][0] + A[1][1] * B[1][0] = 3*3 + 2*1 = 11
# C[1][1] = A[1][0] * B[0][1] + A[1][1] * B[1][1] = 3*2 + 2*1 =  8
# Link to Wikipedia explaining matrix multiplication (look at the square matrix example): http://en.wikipedia.org/wiki/Matrix_multiplication
#
# A more visual explanation of matrix multiplication: http://matrixmultiplication.xyz
#
# MATRIXLINEAR ALGEBRAALGORITHMS
def matrix_mult(a, b):
    mt = []
    for n in range(len(a)):
        rows = []
        for m in range(len(a)):
            x = sum(a[n][k] * b[k][m] for k in range(len(a)))
            rows.append(x)
        mt.append(rows)
    return mt

# 2006. Count Number of Pairs With Absolute Difference K
# Given an integer array nums and an integer k, return the number of pairs (i, j) where i < j such that |nums[i] - nums[j]| == k.
# 
# The value of |x| is defined as:
# 
# x if x >= 0.
# -x if x < 0.
#  
# 
# Example 1:
# 
# Input: nums = [1,2,2,1], k = 1
# Output: 4
# Explanation: The pairs with an absolute difference of 1 are:
# - [1,2,2,1]
# - [1,2,2,1]
# - [1,2,2,1]
# - [1,2,2,1]
# Example 2:
# 
# Input: nums = [1,3], k = 3
# Output: 0
# Explanation: There are no pairs with an absolute difference of 3.
# Example 3:
# 
# Input: nums = [3,2,1,5,4], k = 2
# Output: 3
# Explanation: The pairs with an absolute difference of 2 are:
# - [3,2,1,5,4]
# - [3,2,1,5,4]
# - [3,2,1,5,4]
#  
# 
# Constraints:
# 
# 1 <= nums.length <= 200
# 1 <= nums[i] <= 100
# 1 <= k <= 99
# Solution 1 - Brute Force - Nested loops. Speed O(N**2) and Memory O(1)
# Note: if we should find a differences by absolute (abs) method, we can nof check i < j, but in the end, we have pairs*2
# variations of multiplicate numbers. And then we just should divide answer on 2
class Solution:
    def countKDifference(self, nums: List[int], k: int) -> int:
        count: int = 0
        for i in range(len(nums)):
            for j in range(len(nums)):
                if abs(nums[i] - nums[j]) == k:
                    count += 1
        return count // 2
# Solution 2 HashTable. Speed O(N) and Memory O(N)
class Solution:
    def countKDifference(self, nums: List[int], k: int) -> int:
        hm: dict = {}
        for i in nums:
            hm[i] = hm.get(i, 0) + 1
        count: int = 0
        for i in nums:
            if k + i in hm:
                count += hm[k + i]
        return count
    
# Longest Common Subsequence
# Write a function called LCS that accepts two sequences and returns the longest subsequence common to the passed in sequences.
#
# Subsequence
# A subsequence is different from a substring. The terms of a subsequence need not be consecutive terms of the original sequence.
#
# Example subsequence
# Subsequences of "abc" = "a", "b", "c", "ab", "ac", "bc" and "abc".
#
# LCS examples
# lcs( "abcdef" , "abc" ) => returns "abc"
# lcs( "abcdef" , "acf" ) => returns "acf"
# lcs( "132535365" , "123456789" ) => returns "12356"
# Notes
# Both arguments will be strings
# Return value must be a string
# Return an empty string if there exists no common subsequence
# Both arguments will have one or more characters (in JavaScript)
# All tests will only have a single longest common subsequence. Don't worry about cases such as LCS( "1234", "3412" ), which would have two possible longest common subsequences: "12" and "34".
# Note that the Haskell variant will use randomized testing, but any longest common subsequence will be valid.
#
# Note that the OCaml variant is using generic lists instead of strings, and will also have randomized tests (any longest common subsequence will be valid).
#
# Tips
# Wikipedia has an explanation of the two properties that can be used to solve the problem:
#
# First property
# Second property
# STRINGSALGORITHMS
def lcs(s1, s2):
    if not s1 or not s2:
        return ''
    matrix = [["" for x in range(len(s2))] for x in range(len(s1))]
    for i in range(len(s1)):
        for j in range(len(s2)):
            if s1[i] == s2[j]:
                if i == 0 or j == 0:
                    matrix[i][j] = s1[i]
                else:
                    matrix[i][j] = matrix[i-1][j-1] + s1[i]
            else:
                matrix[i][j] = max(matrix[i-1][j], matrix[i][j-1], key=len)
    return matrix[-1][-1]

# 1897. Redistribute Characters to Make All Strings Equal
# You are given an array of strings words (0-indexed).
#
# In one operation, pick two distinct indices i and j, where words[i] is a non-empty string, and move any character from words[i] to any position in words[j].
#
# Return true if you can make every string in words equal using any number of operations, and false otherwise.
#
#
#
# Example 1:
#
# Input: words = ["abc","aabc","bc"]
# Output: true
# Explanation: Move the first 'a' in words[1] to the front of words[2],
# to make words[1] = "abc" and words[2] = "abc".
# All the strings are now equal to "abc", so return true.
# Example 2:
#
# Input: words = ["ab","a"]
# Output: false
# Explanation: It is impossible to make all the strings equal using the operation.
#
#
# Constraints:
#
# 1 <= words.length <= 100
# 1 <= words[i].length <= 100
# words[i] consists of lowercase English letters.
# Solution O(N) O(N)
class Solution:
    def makeEqual(self, words: List[str]) -> bool:
        dt: dict = defaultdict(int)
        for i in words:
            for j in i:
                dt[j] += 1
        n: int = len(words)
        for i in dt:
            if dt[i] % n != 0:
                return False
        return True

# Ackermann Function
# The Ackermann function is a famous function that played a big role in computability theory as the first example of a total computable function that is not primitive recursive.
#
# Since then the function has been a bit simplified but is still of good use. Due to its definition in terms of extremely deep recursion it can be used as a benchmark of a compiler's ability to optimize recursion.
#
# The goal of this kata is to code a function which will be given two inputs, m and n, and will return the Ackermann number A(m,n) defined by:
#
# A(m,n) = n+1                          if m=0
# A(m,n) = A(m-1,1)                     if m>0 , n=0
# A(m,n) = A(m-1,A(m,n-1))              if m,n > 0
# m,n should be non-negative integers, the function should return null (Javascript), None (Python), or nil (Ruby) for other type, non-integer and negative numbers. In C, input is restricted to integer type.
#
# MATHEMATICSALGORITHMSRECURSION
def Ackermann(m, n):
    if type(m) != int or type(n) != int or m < 0 or n < 0:
        return
    if m == 0:
        return n + 1
    if m > 0 and n == 0:
        return Ackermann(m-1, 1)
    if m > 0 and n > 0:
        return Ackermann(m-1, Ackermann(m, n-1))

# 1624. Largest Substring Between Two Equal Characters
# Given a string s, return the length of the longest substring between two equal characters, excluding the two characters. If there is no such substring return -1.
#
# A substring is a contiguous sequence of characters within a string.
#
#
#
# Example 1:
#
# Input: s = "aa"
# Output: 0
# Explanation: The optimal substring here is an empty substring between the two 'a's.
# Example 2:
#
# Input: s = "abca"
# Output: 2
# Explanation: The optimal substring here is "bc".
# Example 3:
#
# Input: s = "cbzxy"
# Output: -1
# Explanation: There are no characters that appear twice in s.
#
#
# Constraints:
#
# 1 <= s.length <= 300
# s contains only lowercase English letters.
# Solution O(N**2) O(1)
class Solution:
    def maxLengthBetweenEqualCharacters(self, s: str) -> int:
        count: int = -1
        for i in range(len(s)):
            for j in range(i + 1, len(s)):
                if s[i] == s[j]:
                    count = max(count, j - i - 1)
        return count
# Solution 2 O(N) O(N)
class Solution:
    def maxLengthBetweenEqualCharacters(self, s: str) -> int:
        count: int = -1
        for i in range(len(s)):
            for j in range(i + 1, len(s)):
                if s[i] == s[j]:
                    count = max(count, j - i - 1)
        return count

# Angle Between Clock Hands
# Given a Date (in JS and Ruby) or hours and minutes (in C and Python), return the angle between the two hands of a 12-hour analog clock in radians.
#
# Notes:
# The minute hand always points to the exact minute (there is no seconds hand).
# The hour hand does not "snap" to the tick marks: e.g. at 6:30 the angle is not 0 because the hour hand is already half way between 6 and 7.
# Return the smaller of the angles ( <= π ).
# Return π if the hands are opposite.
# Examples
# at noon the angle is: 0
# at 3:00 the angle is: π/2 (90 degrees)
# at 6:00 the angle is: π (180 degrees)
# at 9:00 the angle is: π/2 (90 degrees)
# MATHEMATICSDATE TIMEALGORITHMS
from math import pi
def hand_angle(hours, minutes):
    h, m = .5 * (60 * hours + minutes), 6 * minutes
    angel = abs(h - m)
    x = min(angel, 360 - angel)
    return (pi / 180) * x

# 455. Assign Cookies
# Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.
#
# Each child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] >= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.
#
#
#
# Example 1:
#
# Input: g = [1,2,3], s = [1,1]
# Output: 1
# Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3.
# And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.
# You need to output 1.
# Example 2:
#
# Input: g = [1,2], s = [1,2,3]
# Output: 2
# Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2.
# You have 3 cookies and their sizes are big enough to gratify all of the children,
# You need to output 2.
#
#
# Constraints:
#
# 1 <= g.length <= 3 * 104
# 0 <= s.length <= 3 * 104
# 1 <= g[i], s[j] <= 231 - 1
# Solution O(N log(N) + min(len(s), len(g))) == O(Nlog(N)) \ Memory O(1)
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        count: int = 0
        top = g.pop(0)
        for i in s:
            if i >= top:
                count += 1
                if g:
                    top = g.pop(0)
                else:
                    break
        return count
# Solution O(Nlog(N)) Memory O(1)
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        x, y = 0, 0
        while x < len(g) and y < len(s):
            if s[y] >= g[x]:
                x = x + 1
            y += 1
        return x

# Play with two Strings
# Your task is to Combine two Strings. But consider the rule...
#
# By the way you don't have to check errors or incorrect input values, everything is ok without bad tricks, only two input strings and as result one output string;-)...
#
# And here's the rule:
# Input Strings a and b: For every character in string a swap the casing of every occurrence of the same character in string b. Then do the same casing swap with the inputs reversed. Return a single string consisting of the changed version of a followed by the changed version of b. A char of a is in b regardless if it's in upper or lower case - see the testcases too.
# I think that's all;-)...
#
# Some easy examples:
#
# Input: "abc" and "cde"      => Output: "abCCde"
# Input: "ab" and "aba"       => Output: "aBABA"
# Input: "abab" and "bababa"  => Output: "ABABbababa"
# Once again for the last example - description from KenKamau, see discourse;-):
#
# a) swap the case of characters in string b for every occurrence of that character in string a
# char 'a' occurs twice in string a, so we swap all 'a' in string b twice. This means we start with "bababa" then "bAbAbA" => "bababa"
# char 'b' occurs twice in string a and so string b moves as follows: start with "bababa" then "BaBaBa" => "bababa"
#
# b) then, swap the case of characters in string a for every occurrence in string b
# char 'a' occurs 3 times in string b. So string a swaps cases as follows: start with "abab" then => "AbAb" => "abab" => "AbAb"
# char 'b' occurs 3 times in string b. So string a swaps as follow: start with "AbAb" then => "ABAB" => "AbAb" => "ABAB".
#
# c) merge new strings a and b
# return "ABABbababa"
#
# There are some static tests at the beginning and many random tests if you submit your solution.
#
# Hope you have fun:-)!
# FUNDAMENTALSSTRINGSALGORITHMS
# Solution Speed O(len(a) + len(b)) Memory O(a2 + b2)
def work_on_strings(a,b):
    a1, b2 = {}, {}
    for i in a:
        x = i.lower()
        a1[x] = a1.get(x, 0) + 1
    for i in b:
        x = i.lower()
        b2[x] = b2.get(x, 0) + 1
    ansa, ansb = '', ''
    for i in a:
        x = i.lower()
        if x in b2:
            ansa += i.swapcase() if b2[x] % 2 != 0 else i
        else:
            ansa += i
    for i in b:
        x = i.lower()
        if x in a1:
            ansb += i.swapcase() if a1[x] % 2 != 0 else i
        else:
            ansb += i
    return ansa + ansb

# 2610. Convert an Array Into a 2D Array With Conditions
# You are given an integer array nums. You need to create a 2D array from nums satisfying the following conditions:
#
# The 2D array should contain only the elements of the array nums.
# Each row in the 2D array contains distinct integers.
# The number of rows in the 2D array should be minimal.
# Return the resulting array. If there are multiple answers, return any of them.
#
# Note that the 2D array can have a different number of elements on each row.
#
#
#
# Example 1:
#
# Input: nums = [1,3,4,1,2,3,1]
# Output: [[1,3,4,2],[1,3],[1]]
# Explanation: We can create a 2D array that contains the following rows:
# - 1,3,4,2
# - 1,3
# - 1
# All elements of nums were used, and each row of the 2D array contains distinct integers, so it is a valid answer.
# It can be shown that we cannot have less than 3 rows in a valid array.
# Example 2:
#
# Input: nums = [1,2,3,4]
# Output: [[4,3,2,1]]
# Explanation: All elements of the array are distinct, so we can keep all of them in the first row of the 2D array.
#
#
# Constraints:
#
# 1 <= nums.length <= 200
# 1 <= nums[i] <= nums.length
# Solution 1 - HashTable O(N**2) O(N)
class Solution:
    def findMatrix(self, nums: List[int]) -> List[List[int]]:
        d: dict = {}
        for i in nums:
            d[i] = d.get(i, 0) + 1
        ans: list = list()
        while d:
            top: list = []
            for i in d.copy():
                top.append(i)
                d[i] -= 1
                if d[i] == 0:
                    del d[i]
            ans.append(top)
        return ans
# Solution 2 - Flag O(N * len(ans)), O(N)
class Solution:
    def findMatrix(self, nums: List[int]) -> List[List[int]]:
        ans: list = [[]]
        for i in nums:
            flag: bool = False
            for l in ans:
                if i not in l:
                    l.append(i)
                    flag: bool = True
                    break
            if not flag:
                ans += [[i]]
        return  ans
# Solution 3 - HashTable O(N) O(N)
class Solution:
    def findMatrix(self, nums: List[int]) -> List[List[int]]:
        sq: list = [0] * (len(nums) + 1)
        ans: list = []
        for i in nums:
            if sq[i] >= len(ans):
                ans.append([])
            ans[sq[i]].append(i)
            sq[i] += 1
        return ans

# Convert all the cases!
# In this kata, you will make a function that converts between camelCase, snake_case, and kebab-case.
#
# You must write a function that changes to a given case. It must be able to handle all three case types:
#
# py> change_case("snakeCase", "snake")
# "snake_case"
# py> change_case("some-lisp-name", "camel")
# "someLispName"
# py> change_case("map_to_all", "kebab")
# "map-to-all"
# py> change_case("doHTMLRequest", "kebab")
# "do-h-t-m-l-request"
# py> change_case("invalid-inPut_bad", "kebab")
# None
# py> change_case("valid-input", "huh???")
# None
# py> change_case("", "camel")
# ""
# Your function must deal with invalid input as shown, though it will only be passed strings. Furthermore, all valid identifiers will be lowercase except when necessary, in other words on word boundaries in camelCase.
#
# (Any translations would be greatly appreciated!)
#
# STRINGSREGULAR EXPRESSIONSALGORITHMS
def change_case(id, target):
    if target not in {'kebab', 'camel', 'snake'}:
        return None
    if not id:
        return ''
    x = 0
    for i in id:
        if i.isupper():
            x += 1
    y, z = id.count('_'), id.count('-')
    if (x > 0 and (y > 0 or z > 0)) or (y > 0 and (x > 0 or z > 0)) or (z > 0 and (x > 0 or y > 0)):
        return None
    word: str = ''
    flag: bool = False
    for i in id:
        if not i.isupper() and i not in {'-', '_'}:
            if flag:
                word += i.upper()
                flag = not flag
            else:
                word += i
        elif i.isupper():
            if target == 'camel': word += i
            elif target == 'kebab': word += '-' + i.lower()
            elif target == 'snake': word += '_' + i.lower()
        elif i == '-':
            if target == 'snake': word += '_'
            elif target == 'kebab': word += i
            elif target == 'camel': flag = True
        elif i == '_':
            if target == 'kebab': word += '-'
            elif target == 'snake': word += i
            elif target == 'camel': flag = True
    return word

# Neutralisation
# Given two strings comprised of + and -, return a new string which shows how the two strings interact in the following way:
#
# When positives and positives interact, they remain positive.
# When negatives and negatives interact, they remain negative.
# But when negatives and positives interact, they become neutral, and are shown as the number 0.
# Worked Example
# ("+-+", "+--") ➞ "+-0"
# # Compare the first characters of each string, then the next in turn.
# # "+" against a "+" returns another "+".
# # "-" against a "-" returns another "-".
# # "+" against a "-" returns "0".
# # Return the string of characters.
# Examples
# ("--++--", "++--++") ➞ "000000"
#
# ("-+-+-+", "-+-+-+") ➞ "-+-+-+"
#
# ("-++-", "-+-+") ➞ "-+00"
# Notes
# The two strings will be the same length.
#
# ALGORITHMSSTRINGS
def neutralise(s1, s2):
    return ''.join('+' if x == y == '+' else '-' if x == y == '-' else '0' for x, y in zip(s1, s2))

# Pandas Series 101: Rename Columns
# Rename Columns
# Input parameters
# pandas.DataFrame object
# sequence
# Task
# Your function must return a new pandas.DataFrame object with same data than the original input but now its column names are the elements of the sequence. You must not modify the original input.
#
# The number of columns of the input will always be equal to the size of the sequence.
#
# Examples
#    0  1  2
# 0  1  2  3
# 1  4  5  6
#
# names = ['A', 'B', 'C']
#    A  B  C
# 0  1  2  3
# 1  4  5  6
# STRINGSDATA FRAMESFUNDAMENTALSDATA SCIENCE
import pandas as pd

def rename_columns(df, names):  
    df2 = df.copy()
    df2.columns = [i for i in names]
    return df2

# Genetic Algorithm Series - #2 Mutation
# Mutation is a genetic operator used to maintain genetic diversity from one generation of a population of genetic algorithm chromosomes to the next.
#
# Mutation
#
# A mutation here may happen on zero or more positions in a chromosome. It is going to check every position and by a given probability it will decide if a mutation will occur.
#
# A mutation is the change from 0 to 1 or from 1 to 0.
#
# Note: Some tests are random. If you think your algorithm is correct but the result fails, trying again should work.
#
# See other katas from this series
# Genetic Algorithm Series - #1 Generate
# Genetic Algorithm Series - #2 Mutation
# Genetic Algorithm Series - #3 Crossover
# Genetic Algorithm Series - #4 Get population and fitnesses
# Genetic Algorithm Series - #5 Roulette wheel selection
# ALGORITHMSGENETIC ALGORITHMSSTRINGS
from random import choices
def mutate(chromosome, p):
    return ''.join(choices([str(int(not bool(int(i)))), i], [p, 1 - p])[0] for i in chromosome)

# Quicksum
# A checksum is an algorithm that scans a packet of data and returns a single number. The idea is that if the packet is changed, the checksum will also change, so checksums are often used for detecting transmission errors, validating document contents, and in many other situations where it is necessary to detect undesirable changes in data.
#
# For this problem, you will implement a checksum algorithm called Quicksum. A Quicksum packet allows only uppercase letters and spaces. It always begins and ends with an uppercase letter.
#
# Otherwise, spaces and uppercase letters can occur in any combination, including consecutive spaces.
#
# A Quicksum is the sum of the products of each character’s position in the packet times the character’s value. A space has a value of zero, while letters have a value equal to their position in the alphabet.
#
# So, A = 1, B = 2, etc., through Z = 26. Here are example Quicksum calculations for the packets "ACM" and "A C M":
#
# ACM
# 1 × 1 + 2 × 3 + 3 × 13 = 46
#
# A C M
# 1 x 1 + 3 x 3 + 5 * 13 = 75
# When the packet doesn't have only uppercase letters and spaces or just spaces the result to quicksum have to be zero (0).
#
# AbqTH #5 = 0
# FUNDAMENTALS
def quicksum(packet):
    s: int = 0
    for i in range(len(packet)):
        if (not packet[i].isalpha() and packet[i] != ' ') or packet[i].islower():
            return 0
        if packet[i].isalpha():
            s += (ord(packet[i]) - 64) * (i + 1)
    return s

# Case-sensitive!
# Your task is very simple. Given an input string s, case_sensitive(s), check whether all letters are lowercase or not. Return True/False and a list of all the entries that are not lowercase in order of their appearance in s.
#
# For example, case_sensitive('codewars') returns [True, []], but case_sensitive('codeWaRs') returns [False, ['W', 'R']].
#
# Goodluck :)
#
# Have a look at my other katas!
#
# Alphabetically ordered
#
# Find Nearest square number
#
# Not prime numbers
#
# Find your caterer
#
# STRINGSFUNDAMENTALS
def case_sensitive(s):
    flag: bool = True
    ans: list = list()
    for i in s:
        if i.isupper():
            flag = not flag
            ans += i
    return [flag, ans]

# Acrostic reader
# An acrostic is a text in which the first letter of each line spells out a word. It is also a quick and cheap way of writing a poem for somebody, as exemplified below :
#
#
#
# Write a program that reads an acrostic to identify the "hidden" word. Specifically, your program will receive a list of words (reprensenting an acrostic) and will need to return a string corresponding to the word that is spelled out by taking the first letter of each word in the acrostic.
#
# STRINGSFUNDAMENTALS
def read_out(acrostic):
    return ''.join(i[0] for i in acrostic)

# Holiday II - Plane Seating
# Finding your seat on a plane is never fun, particularly for a long haul flight... You arrive, realise again just how little leg room you get, and sort of climb into the seat covered in a pile of your own stuff.
#
# To help confuse matters (although they claim in an effort to do the opposite) many airlines omit the letters 'I' and 'J' from their seat naming system.
#
# the naming system consists of a number (in this case between 1-60) that denotes the section of the plane where the seat is (1-20 = front, 21-40 = middle, 40+ = back). This number is followed by a letter, A-K with the exclusions mentioned above.
#
# Letters A-C denote seats on the left cluster, D-F the middle and G-K the right.
#
# Given a seat number, your task is to return the seat location in the following format:
#
# '2B' would return 'Front-Left'.
#
# If the number is over 60, or the letter is not valid, return 'No Seat!!'.
#
# FUNDAMENTALSSTRINGSARRAYS
def plane_seat(a):
    al: str = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    if int(a[:-1]) > 60 or a[-1] in {'I', 'J'} or al.index(a[-1]) > 10:
        return 'No Seat!!'
    x, y = '', ''
    n = al.index(a[-1])
    if 0 <= n <= al.index('C'):
        y = 'Left'
    elif al.index('C') < n <= al.index('F'):
        y = 'Middle'
    else:
        y = 'Right'
    n = int(a[:-1])
    if 1 <= n <= 20:
        x = 'Front'
    elif 21 <= n <= 40:
        x = 'Middle'
    else:
        x = 'Back'
    return f'{x}-{y}'

# Help Suzuki complete his chores!
# Suzuki has a long list of chores required to keep the monastery in good order. Each chore can be completed independently of the others and assigned to any student. Knowing there will always be an even number of chores and that the number of students isn't limited, Suzuki needs to assign two chores to each student in a way which minimizes the total duration of the day's work.
#
# For example, with the list of chores [1, 5, 2, 8, 4, 9, 6, 4, 2, 2, 2, 9], he'll need 6 students whose total workload will be: [7, 8, 8, 10, 10, 11] (as for [5+2, 4+4, 6+2, 8+2, 1+9, 9+2]). In this case, the maximal workload is minimized to 11 (=9+2. Keep in mind two chores must be assigned to each student involved).
#
# Input/output
# Input: 10 ≤ chores length ≤ 30, chores length is always even.
# Output: array of workloads, in ascending order.
# Please also try the other Kata in this series..
#
# Help Suzuki count his vegetables...
# Help Suzuki pack his coal basket!
# Help Suzuki purchase his Tofu!
# Help Suzuki rake his garden!
# Suzuki needs help lining up his students!
# How many stairs will Suzuki climb in 20 years?
# ALGORITHMS
def chore_assignment(chores):
    chores.sort()
    ans: list = []
    while chores:
        ans.append(chores[0] + chores[-1])
        chores.pop(0)
        chores.pop()
    ans.sort()
    return ans

# Chuck Norris II - One Punch
# Chuck Norris is the world's toughest man - he once kicked a horse in the chin. Its descendants today are known as giraffes.
#
# Like his punches, Chuck NEVER needs more than one line of code.
#
# Your task, to please Chuck, is to create a function that chains 4 methods on a SINGLE LINE! You can pass with multiple lines, but CHuck will pity you. Go big or go home. ONE LINE!!
#
# Chuck expects his list of favourite items to be split, sorted, joined AND have any occurrences of the letters 'e' and 'a' removed - why, you ask? Well Nunchuks hasn't got the letters 'a' or 'e' in it has it?? Chuck says shut your mouth... and don't forget the capitals.
#
# If anyone dares to provide Chuck with an empty string, an integer or an array, just return a description of their face once Chuck finds out: 'Broken!'
#
# Go, go go!!!
#
# FUNDAMENTALSREGULAR EXPRESSIONSALGORITHMS
def one_punch(item):
    return ' '.join(' '.join(''.join(i.replace('e', '').replace('a', '').replace('E', '').replace('A', '')) for i in sorted(item.split())).split(' ')) if (type(item) == str and item) else 'Broken!'

# Put a Letter in a Column
# Create a function that takes index [0, 8] and a character. It returns a string with columns. Put character in column marked with index.
#
# Ex.: index = 2, character = 'B'
#
# | | |B| | | | | | |
#  0 1 2 3 4 5 6 7 8
# Assume that argument index is integer [0, 8]. Assume that argument character is string with one character.
#
# FUNDAMENTALSSTRINGS
def build_row_text(index, character):
    s: str = ''
    for i in range(9):
        s += f'|{character if index == i else " "}'
    return s + '|'

# 2125. Number of Laser Beams in a Bank
# Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.
#
# There is one laser beam between any two security devices if both conditions are met:
#
# The two devices are located on two different rows: r1 and r2, where r1 < r2.
# For each row i where r1 < i < r2, there are no security devices in the ith row.
# Laser beams are independent, i.e., one beam does not interfere nor join with another.
#
# Return the total number of laser beams in the bank.
#
#
#
# Example 1:
#
#
# Input: bank = ["011001","000000","010100","001000"]
# Output: 8
# Explanation: Between each of the following device pairs, there is one beam. In total, there are 8 beams:
#  * bank[0][1] -- bank[2][1]
#  * bank[0][1] -- bank[2][3]
#  * bank[0][2] -- bank[2][1]
#  * bank[0][2] -- bank[2][3]
#  * bank[0][5] -- bank[2][1]
#  * bank[0][5] -- bank[2][3]
#  * bank[2][1] -- bank[3][2]
#  * bank[2][3] -- bank[3][2]
# Note that there is no beam between any device on the 0th row with any on the 3rd row.
# This is because the 2nd row contains security devices, which breaks the second condition.
# Example 2:
#
#
# Input: bank = ["000","111","000"]
# Output: 0
# Explanation: There does not exist two devices located on two different rows.
#
#
# Constraints:
#
# m == bank.length
# n == bank[i].length
# 1 <= m, n <= 500
# bank[i][j] is either '0' or '1'.
# Solution 1 - Math O(N * M) O(1)
class Solution:
    def numberOfBeams(self, bank: List[str]) -> int:
        count: int = 0
        flag: bool = False
        top: int = 0
        for i in bank:
            x = i.count('1')
            if x > 0:
                if not flag:
                    top = x
                    flag = True
                else:
                    count += top * x
                    top = x
        return count
# Solution 2 - Math O(N * M) O(1)
class Solution:
    def numberOfBeams(self, bank: List[str]) -> int:
        count: int = 0
        prev_top: int = 0
        for i in bank:
            top = i.count('1')
            if top > 0:
                count += prev_top * top
                prev_top = top
        return count
    
# Largest product in a series
# Complete the greatestProduct method so that it'll find the greatest product of five consecutive digits in the given string of digits.
#
# For example:
#
# greatestProduct("123834539327238239583") // should return 3240
# The input string always has more than five digits.
#
# Adapted from Project Euler.
#
# MATHEMATICSALGORITHMS
import math
def greatest_product(st):
    top: int = 0
    for i in range(len(st) - 4):
        s = math.prod(int(j) for j in st[i:i+5])
        if s > top:
            top = s
    return top

# 2367. Number of Arithmetic Triplets
# You are given a 0-indexed, strictly increasing integer array nums and a positive integer diff. A triplet (i, j, k) is an arithmetic triplet if the following conditions are met:
#
# i < j < k,
# nums[j] - nums[i] == diff, and
# nums[k] - nums[j] == diff.
# Return the number of unique arithmetic triplets.
#
#
#
# Example 1:
#
# Input: nums = [0,1,4,6,7,10], diff = 3
# Output: 2
# Explanation:
# (1, 2, 4) is an arithmetic triplet because both 7 - 4 == 3 and 4 - 1 == 3.
# (2, 4, 5) is an arithmetic triplet because both 10 - 7 == 3 and 7 - 4 == 3.
# Example 2:
#
# Input: nums = [4,5,6,7,8,9], diff = 2
# Output: 2
# Explanation:
# (0, 2, 4) is an arithmetic triplet because both 8 - 6 == 2 and 6 - 4 == 2.
# (1, 3, 5) is an arithmetic triplet because both 9 - 7 == 2 and 7 - 5 == 2.
#
#
# Constraints:
#
# 3 <= nums.length <= 200
# 0 <= nums[i] <= 200
# 1 <= diff <= 50
# nums is strictly increasing.
# Solution HashSet O(N) O(N)
class Solution:
    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:
        hs: set = set()
        count: int = 0
        for i in nums:
            if i - diff in hs and i - diff * 2 in hs:
                count += 1
            hs.add(i)
        return count
# Solution Combination with memorization O(N**3), O(1)
class Solution:
    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:
        count: int = 0
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                for k in range(j + 1, len(nums)):
                    if nums[j] - nums[i] == nums[k] - nums[j] == diff:
                        count += 1
        return count

# 1275. Find Winner on a Tic Tac Toe Game
# Tic-tac-toe is played by two players A and B on a 3 x 3 grid. The rules of Tic-Tac-Toe are:
#
# Players take turns placing characters into empty squares ' '.
# The first player A always places 'X' characters, while the second player B always places 'O' characters.
# 'X' and 'O' characters are always placed into empty squares, never on filled ones.
# The game ends when there are three of the same (non-empty) character filling any row, column, or diagonal.
# The game also ends if all squares are non-empty.
# No more moves can be played if the game is over.
# Given a 2D integer array moves where moves[i] = [rowi, coli] indicates that the ith move will be played on grid[rowi][coli]. return the winner of the game if it exists (A or B). In case the game ends in a draw return "Draw". If there are still movements to play return "Pending".
#
# You can assume that moves is valid (i.e., it follows the rules of Tic-Tac-Toe), the grid is initially empty, and A will play first.
#
#
#
# Example 1:
#
#
# Input: moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]
# Output: "A"
# Explanation: A wins, they always play first.
# Example 2:
#
#
# Input: moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]
# Output: "B"
# Explanation: B wins.
# Example 3:
#
#
# Input: moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]]
# Output: "Draw"
# Explanation: The game ends in a draw since there are no moves to make.
#
#
# Constraints:
#
# 1 <= moves.length <= 9
# moves[i].length == 2
# 0 <= rowi, coli <= 2
# There are no repeated elements on moves.
# moves follow the rules of tic tac toe.
# Solution O(R + C) O(R + C)
class Solution:
    def tictactoe(self, moves: List[List[int]]) -> str:
        m: list = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
        for i in range(len(moves)):
            m[moves[i][0]][moves[i][1]] = 'A' if i % 2 == 0 else 'B'
        for j in 'AB':
            if (
                (m[0][0] == m[1][1] == m[2][2] == j)
                or (m[0][2] == m[1][1] == m[2][0] == j)
                or (m[0][0] == m[1][0] == m[2][0] == j)
                or (m[0][1] == m[1][1] == m[2][1] == j)
                or (m[0][2] == m[1][2] == m[2][2] == j)
                or (m[0][0] == m[0][1] == m[0][2] == j)
                or (m[1][0] == m[1][1] == m[1][2] == j)
                or (m[2][0] == m[2][1] == m[2][2] == j)
            ):
                return j
        return 'Draw' if len(moves) == 9 else 'Pending'

# 2870. Minimum Number of Operations to Make Array Empty
# You are given a 0-indexed array nums consisting of positive integers.
#
# There are two types of operations that you can apply on the array any number of times:
#
# Choose two elements with equal values and delete them from the array.
# Choose three elements with equal values and delete them from the array.
# Return the minimum number of operations required to make the array empty, or -1 if it is not possible.
#
#
#
# Example 1:
#
# Input: nums = [2,3,3,2,2,4,2,3,4]
# Output: 4
# Explanation: We can apply the following operations to make the array empty:
# - Apply the first operation on the elements at indices 0 and 3. The resulting array is nums = [3,3,2,4,2,3,4].
# - Apply the first operation on the elements at indices 2 and 4. The resulting array is nums = [3,3,4,3,4].
# - Apply the second operation on the elements at indices 0, 1, and 3. The resulting array is nums = [4,4].
# - Apply the first operation on the elements at indices 0 and 1. The resulting array is nums = [].
# It can be shown that we cannot make the array empty in less than 4 operations.
# Example 2:
#
# Input: nums = [2,1,2,2,3,3]
# Output: -1
# Explanation: It is impossible to empty the array.
#
#
# Constraints:
#
# 2 <= nums.length <= 105
# 1 <= nums[i] <= 106
# Solution O(N) O(N)
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        count: int = 0
        d: dict = {}
        for i in nums:
            d[i] = d.get(i, 0) + 1
        for i in d:
            if d[i] == 1:
                return -1
            if d[i] % 3 == 0:
                count += d[i] // 3
            else:
                while d[i] - 3 >= 2:
                    d[i] -= 3
                    count += 1
                if d[i] % 2 == 0:
                    count += d[i] // 2
        return count

# Schrödinger's Boolean
# Can a value be both True and False?
#
# Define omnibool so that it returns True for the following:
#
# omnibool == True and omnibool == False
# If you enjoyed this kata, be sure to check out my other katas.
#
# LANGUAGE FEATURESMETAPROGRAMMINGPUZZLES
# Solution
class AlwaysTrue:
    def __eq__(self, other):
        return True

omnibool = AlwaysTrue()

# 976. Largest Perimeter Triangle
# Given an integer array nums, return the largest perimeter of a triangle with a non-zero area, formed from three of these lengths. If it is impossible to form any triangle of a non-zero area, return 0.
#
#
#
# Example 1:
#
# Input: nums = [2,1,2]
# Output: 5
# Explanation: You can form a triangle with three side lengths: 1, 2, and 2.
# Example 2:
#
# Input: nums = [1,2,1,10]
# Output: 0
# Explanation:
# You cannot use the side lengths 1, 1, and 2 to form a triangle.
# You cannot use the side lengths 1, 1, and 10 to form a triangle.
# You cannot use the side lengths 1, 2, and 10 to form a triangle.
# As we cannot use any three side lengths to form a triangle of non-zero area, we return 0.
#
#
# Constraints:
#
# 3 <= nums.length <= 104
# 1 <= nums[i] <= 106
# Solution O(NlogN) O(1)
class Solution:
    def largestPerimeter(self, nums: List[int]) -> int:
        nums.sort(reverse=True)
        for i in range(2, len(nums)):
            if nums[i] + nums[i-1] > nums[i-2]:
                return nums[i-2] + nums[i-1] + nums[i]
        return 0
    
# 43. Multiply Strings
# Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.
#
# Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.
#
#
#
# Example 1:
#
# Input: num1 = "2", num2 = "3"
# Output: "6"
# Example 2:
#
# Input: num1 = "123", num2 = "456"
# Output: "56088"
#
#
# Constraints:
#
# 1 <= num1.length, num2.length <= 200
# num1 and num2 consist of digits only.
# Both num1 and num2 do not contain any leading zero, except the number 0 itself.
class Solution:
    def multiply(self, num1: str, num2: str) -> str:
        if num1 == '0' or num2 == '0':
            return '0'
        d: dict = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4,
        '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}
        r_d: dict = {0: '0', 1: '1', 2: '2', 3: '3', 4: '4',
        5: '5', 6: '6', 7: '7', 8: '8', 9: '9'}
        x1, x2 = 0, 0
        for i in num1:
            x1 = x1 * 10 + d[i]
        for i in num2:
            x2 = x2 * 10 + d[i]
        x3 = x1 * x2
        ans: str = ''
        while x3:
            ans += r_d[x3 % 10]
            x3 //= 10
        return ans[::-1]

# 54. Spiral Matrix
# Given an m x n matrix, return all elements of the matrix in spiral order.
#
#
#
# Example 1:
#
#
# Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
# Output: [1,2,3,6,9,8,7,4,5]
# Example 2:
#
#
# Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
# Output: [1,2,3,4,8,12,11,10,9,5,6,7]
#
#
# Constraints:
#
# m == matrix.length
# n == matrix[i].length
# 1 <= m, n <= 10
# -100 <= matrix[i][j] <= 100
# Solution O(M * (M + N)) O(M + N)
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        l: list = []
        for k in range(len(matrix)):
            if matrix:
                for i in range(len(matrix[0]) - 1):
                    if matrix[0]:
                        l.append(matrix[0].pop(0))
            for i in range(len(matrix) - 1):
                if matrix[i]:
                    l.append(matrix[i].pop())
            if matrix:
                for i in range(len(matrix[-1]) - 1, 0, -1):
                    if matrix[-1]:
                        l.append(matrix[-1].pop(i))
            for i in range(len(matrix) - 1, 0, -1):
                if matrix[i]:
                    l.append(matrix[i].pop(0))
            for i in matrix:
                if not i:
                    matrix.remove(i)
        return l + matrix[0] if matrix else l

# 300. Longest Increasing Subsequence
# Given an integer array nums, return the length of the longest strictly increasing
# subsequence
# .
#
#
#
# Example 1:
#
# Input: nums = [10,9,2,5,3,7,101,18]
# Output: 4
# Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.
# Example 2:
#
# Input: nums = [0,1,0,3,2,3]
# Output: 4
# Example 3:
#
# Input: nums = [7,7,7,7,7,7,7]
# Output: 1
#
#
# Constraints:
#
# 1 <= nums.length <= 2500
# -104 <= nums[i] <= 104
#
#
# Follow up: Can you come up with an algorithm that runs in O(n log(n)) time complexity?
# Solution O(N**2) O(N)
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        n: int = len(nums)
        dp: list = [1] * n
        for i in range(1, n):
            for j in range(i):
                if nums[i] > nums[j] and dp[i] < dp[j] + 1:
                    dp[i] = dp[j] + 1
        return max(dp)
    
# Identify the array's ordering
# Write a function that takes a single array as an argument (containing multiple strings and/or positive numbers and/or arrays), and returns one of four possible string values, depending on the ordering of the lengths of the elements in the input array:
#
# Your function should return...
#
# “Increasing” - if the lengths of the elements increase from left to right (although it is possible that some neighbouring elements may also be equal in length)
# “Decreasing” - if the lengths of the elements decrease from left to right (although it is possible that some neighbouring elements may also be equal in length)
# “Unsorted” - if the lengths of the elements fluctuate from left to right
# “Constant” - if all element's lengths are the same.
# Numbers and Strings should be evaluated based on the number of characters or digits used to write them.
#
# Arrays should be evaluated based on the number of elements counted directly in the parent array (but not the number of elements contained in any sub-arrays).
#
# Happy coding! :)
#
# ARRAYSSTRINGSALGORITHMSFUNDAMENTALS
def order_type(arr):
    if not arr or len(arr) == 1:
        return 'Constant'
    l: list = []
    for i in arr:
        if type(i) in {str, list}:
            l.append(len(i))
        else:
            l.append(len(str(i)))
    if all(x == y for x, y in zip(l, l[1:])):
        return 'Constant'
    elif all(x <= y for x, y in zip(l, l[1:])):
        return 'Increasing'
    elif all(x >= y for x, y in zip(l, l[1:])):
        return 'Decreasing'
    return 'Unsorted'

# 1689. Partitioning Into Minimum Number Of Deci-Binary Numbers
# A decimal number is called deci-binary if each of its digits is either 0 or 1 without any leading zeros. For example, 101 and 1100 are deci-binary, while 112 and 3001 are not.
#
# Given a string n that represents a positive decimal integer, return the minimum number of positive deci-binary numbers needed so that they sum up to n.
#
#
#
# Example 1:
#
# Input: n = "32"
# Output: 3
# Explanation: 10 + 11 + 11 = 32
# Example 2:
#
# Input: n = "82734"
# Output: 8
# Example 3:
#
# Input: n = "27346209830709182346"
# Output: 9
#
#
# Constraints:
#
# 1 <= n.length <= 105
# n consists of only digits.
# n does not contain any leading zeros and represents a positive integer.
class Solution:
    def minPartitions(self, n: str) -> int:
        return int(max(n))
    
# Mix Fruit Juice
# Story
# Jumbo Juice makes a fresh juice out of fruits of your choice.Jumbo Juice charges $5 for regular fruits and $7 for special ones. Regular fruits are Banana, Orange, Apple, Lemon and Grapes. Special ones are Avocado, Strawberry and Mango. Others fruits that are not listed are also available upon request. Those extra special fruits cost $9 per each. There is no limit on how many fruits she/he picks.The price of a cup of juice is the mean of price of chosen fruits. In case of decimal number (ex. $5.99), output should be the nearest integer (use the standard rounding function of your language of choice).
#
# Input
# The function will receive an array of strings, each with the name of a fruit. The recognition of names should be case insensitive. There is no case of an empty array input.
#
# Example
# ['Mango', 'Banana', 'Avocado'] //the price of this juice bottle is (7+5+7)/3 = $6($6.333333...)
# FUNDAMENTALSARRAYS
def mix_fruit(arr):
    basic: set = {'banana', 'orange', 'apple', 'lemon', 'grapes'}
    special: set = {'avocado', 'strawberry', 'mango'}
    count: int = 0
    for i in arr:
        i = i.lower()
        if i in basic:
            count += 5
        elif i in special:
            count += 7
        else:
            count += 9
    return round(count / len(arr))

# 2942. Find Words Containing Character
# You are given a 0-indexed array of strings words and a character x.
#
# Return an array of indices representing the words that contain the character x.
#
# Note that the returned array may be in any order.
#
#
#
# Example 1:
#
# Input: words = ["leet","code"], x = "e"
# Output: [0,1]
# Explanation: "e" occurs in both words: "leet", and "code". Hence, we return indices 0 and 1.
# Example 2:
#
# Input: words = ["abc","bcd","aaaa","cbc"], x = "a"
# Output: [0,2]
# Explanation: "a" occurs in "abc", and "aaaa". Hence, we return indices 0 and 2.
# Example 3:
#
# Input: words = ["abc","bcd","aaaa","cbc"], x = "z"
# Output: []
# Explanation: "z" does not occur in any of the words. Hence, we return an empty array.
#
#
# Constraints:
#
# 1 <= words.length <= 50
# 1 <= words[i].length <= 50
# x is a lowercase English letter.
# words[i] consists only of lowercase English letters.
# Solution 1 - Simple checking O(N) O(N)
class Solution:
    def findWordsContaining(self, words: List[str], x: str) -> List[int]:
        ans: list = []
        for i in range(len(words)):
            if x in words[i]:
                ans.append(i)
        return ans
# Solution 2 - More Pythonic O(N) O(N)
class Solution:
    def findWordsContaining(self, words: List[str], x: str) -> List[int]:
        return [k for k, v in enumerate(words) if x in v]

# 2980. Check if Bitwise OR Has Trailing Zeros
# You are given an array of positive integers nums.
#
# You have to check if it is possible to select two or more elements in the array such that the bitwise OR of the selected elements has at least one trailing zero in its binary representation.
#
# For example, the binary representation of 5, which is "101", does not have any trailing zeros, whereas the binary representation of 4, which is "100", has two trailing zeros.
#
# Return true if it is possible to select two or more elements whose bitwise OR has trailing zeros, return false otherwise.
#
#
#
# Example 1:
#
# Input: nums = [1,2,3,4,5]
# Output: true
# Explanation: If we select the elements 2 and 4, their bitwise OR is 6, which has the binary representation "110" with one trailing zero.
# Example 2:
#
# Input: nums = [2,4,8,16]
# Output: true
# Explanation: If we select the elements 2 and 4, their bitwise OR is 6, which has the binary representation "110" with one trailing zero.
# Other possible ways to select elements to have trailing zeroes in the binary representation of their bitwise OR are: (2, 8), (2, 16), (4, 8), (4, 16), (8, 16), (2, 4, 8), (2, 4, 16), (2, 8, 16), (4, 8, 16), and (2, 4, 8, 16).
# Example 3:
#
# Input: nums = [1,3,5,7,9]
# Output: false
# Explanation: There is no possible way to select two or more elements to have trailing zeros in the binary representation of their bitwise OR.
#
#
# Constraints:
#
# 2 <= nums.length <= 100
# 1 <= nums[i] <= 100
# Solution Nested Loops O(N**2) O(1)
class Solution:
    def hasTrailingZeros(self, nums: List[int]) -> bool:
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                if bin(nums[i] | nums[j])[-1] == '0':
                    return True
        return False

# 2981. Find Longest Special Substring That Occurs Thrice I
# You are given a string s that consists of lowercase English letters.
#
# A string is called special if it is made up of only a single character. For example, the string "abc" is not special, whereas the strings "ddd", "zz", and "f" are special.
#
# Return the length of the longest special substring of s which occurs at least thrice, or -1 if no special substring occurs at least thrice.
#
# A substring is a contiguous non-empty sequence of characters within a string.
#
#
#
# Example 1:
#
# Input: s = "aaaa"
# Output: 2
# Explanation: The longest special substring which occurs thrice is "aa": substrings "aaaa", "aaaa", and "aaaa".
# It can be shown that the maximum length achievable is 2.
# Example 2:
#
# Input: s = "abcdef"
# Output: -1
# Explanation: There exists no special substring which occurs at least thrice. Hence return -1.
# Example 3:
#
# Input: s = "abcaba"
# Output: 1
# Explanation: The longest special substring which occurs thrice is "a": substrings "abcaba", "abcaba", and "abcaba".
# It can be shown that the maximum length achievable is 1.
#
#
# Constraints:
#
# 3 <= s.length <= 50
# s consists of only lowercase English letters.
# Solution O(N**3) O(1)
class Solution:
    def maximumLength(self, s: str) -> int:
        mx = -1
        top = s[0]
        for i in range(1, len(s)):
            count = 0
            for j in range(len(s)):
                if top == s[j:j+len(top)]:
                    count += 1
                if count > 2:
                    mx = max(mx, len(top))
                    break
            if s[i] == top[-1]:
                top += s[i]
                count = 0
                for j in range(len(s)):
                    if top == s[j:j+len(top)]:
                        count += 1
                    if count > 2:
                        mx = max(mx, len(top))
                        break
            else:
                top = s[i]
        return mx

# 10031. Smallest Missing Integer Greater Than Sequential Prefix Sum
# You are given a 0-indexed array of integers nums.
#
# A prefix nums[0..i] is sequential if, for all 1 <= j <= i, nums[j] = nums[j - 1] + 1. In particular, the prefix consisting only of nums[0] is sequential.
#
# Return the smallest integer x missing from nums such that x is greater than or equal to the sum of the longest sequential prefix.
#
#
#
# Example 1:
#
# Input: nums = [1,2,3,2,5]
# Output: 6
# Explanation: The longest sequential prefix of nums is [1,2,3] with a sum of 6. 6 is not in the array, therefore 6 is the smallest missing integer greater than or equal to the sum of the longest sequential prefix.
# Example 2:
#
# Input: nums = [3,4,5,1,12,14,13]
# Output: 15
# Explanation: The longest sequential prefix of nums is [3,4,5] with a sum of 12. 12, 13, and 14 belong to the array while 15 does not. Therefore 15 is the smallest missing integer greater than or equal to the sum of the longest sequential prefix.
#
#
# Constraints:
#
# 1 <= nums.length <= 50
# 1 <= nums[i] <= 50
class Solution:
    def missingInteger(self, nums: List[int]) -> int:
        s: int = nums[0]
        for i in range(1, len(nums)):
            if nums[i - 1] + 1 == nums[i]:
                s += nums[i]
            else:
                break
        while s in nums:
            s += 1
        return s

# 2894. Divisible and Non-divisible Sums Difference
# You are given positive integers n and m.
#
# Define two integers, num1 and num2, as follows:
#
# num1: The sum of all integers in the range [1, n] that are not divisible by m.
# num2: The sum of all integers in the range [1, n] that are divisible by m.
# Return the integer num1 - num2.
#
#
#
# Example 1:
#
# Input: n = 10, m = 3
# Output: 19
# Explanation: In the given example:
# - Integers in the range [1, 10] that are not divisible by 3 are [1,2,4,5,7,8,10], num1 is the sum of those integers = 37.
# - Integers in the range [1, 10] that are divisible by 3 are [3,6,9], num2 is the sum of those integers = 18.
# We return 37 - 18 = 19 as the answer.
# Example 2:
#
# Input: n = 5, m = 6
# Output: 15
# Explanation: In the given example:
# - Integers in the range [1, 5] that are not divisible by 6 are [1,2,3,4,5], num1 is the sum of those integers = 15.
# - Integers in the range [1, 5] that are divisible by 6 are [], num2 is the sum of those integers = 0.
# We return 15 - 0 = 15 as the answer.
# Example 3:
#
# Input: n = 5, m = 1
# Output: -15
# Explanation: In the given example:
# - Integers in the range [1, 5] that are not divisible by 1 are [], num1 is the sum of those integers = 0.
# - Integers in the range [1, 5] that are divisible by 1 are [1,2,3,4,5], num2 is the sum of those integers = 15.
# We return 0 - 15 = -15 as the answer.
#
#
# Constraints:
#
# 1 <= n, m <= 1000
# Solution 1 - Brute Force O(N) O(1)
class Solution:
    def differenceOfSums(self, n: int, m: int) -> int:
        count: int = 0
        for i in range(1, n + 1):
            if i % m != 0:
                count += i
            elif i % m == 0:
                count -= i
        return count
# Solution 2 Math O(1) O(1)
class Solution:
    def differenceOfSums(self, n: int, m: int) -> int:
        k = n // m
        return n * (n + 1) // 2 - (k + 1) * k * m
    
# Arrays and hex color codes
# Given an array with 3 subarrays, each containing hexadecimal color codes loosely defining red, green and blue colors based on their predominant byte value, return a string description of which of the three colors each array contains.
#
# Input is an array which contains 3 subarrays. These subarrays contain strings representing colors in RGB format, each string will contain one predominant color channel that is more saturated than the other two. Among all the strings in an subarray only 2 color channels will come up as predominant - the one that appears more often is "major" and the one that appears less often is "minor". Your task is to determine the major and minor colors inside each subarray and return them in the following format: {Major1}+{Minor1},{Major2}+{Minor2},{Major3}+{Minor3}.
#
# Example:
#
# input = [
#   ["FFA07A", "FA8072", "8DC4DE"],
#   ["7FFF00", "ADFF2F", "FF0000", "00FF7F", "00FF7F"],
#   ["ADD8E6", "6B8E23", "9ACD32", "32CD32", "00FF00"]
# ]
#
# result = "Red+Blue,Green+Red,Green+Blue"
# Explanation:
#
# first subarray's predominant colors: Red, Red, Blue (Red is major, Blue is minor)
# second subarray's predominant colors: Green, Green, Red, Green, Green (Green is major, Red is minor)
# third subarray's predominant colors: Blue, Green, Green, Green, Green (Green is major, Blue is minor)
# FUNDAMENTALSARRAYS
from PIL import ImageColor
def get_colors(col_arr):
    l: list = []
    for j in col_arr:
        d: dict = {}
        for k in j:
            r, g, b = ImageColor.getcolor('#' + k, "RGB")
            mx = max(r, g, b)
            if mx == r:
                d['Red'] = d.get('Red', 0) + 1
            elif mx == g:
                d['Green'] = d.get('Green', 0) + 1
            else:
                d['Blue'] = d.get('Blue', 0) + 1
        l.append(f"{max(d, key=d.get)}+{min(d, key=d.get)}")
    return ','.join(l)

# 2574. Left and Right Sum Differences
# Given a 0-indexed integer array nums, find a 0-indexed integer array answer where:
#
# answer.length == nums.length.
# answer[i] = |leftSum[i] - rightSum[i]|.
# Where:
#
# leftSum[i] is the sum of elements to the left of the index i in the array nums. If there is no such element, leftSum[i] = 0.
# rightSum[i] is the sum of elements to the right of the index i in the array nums. If there is no such element, rightSum[i] = 0.
# Return the array answer.
#
#
#
# Example 1:
#
# Input: nums = [10,4,8,3]
# Output: [15,1,11,22]
# Explanation: The array leftSum is [0,10,14,22] and the array rightSum is [15,11,3,0].
# The array answer is [|0 - 15|,|10 - 11|,|14 - 3|,|22 - 0|] = [15,1,11,22].
# Example 2:
#
# Input: nums = [1]
# Output: [0]
# Explanation: The array leftSum is [0] and the array rightSum is [0].
# The array answer is [|0 - 0|] = [0].
#
#
# Constraints:
#
# 1 <= nums.length <= 1000
# 1 <= nums[i] <= 105
# Solution O(N) O(1)
class Solution:
    def leftRightDifference(self, nums: List[int]) -> List[int]:
        left_sm, right_sm = 0, sum(nums)
        for i in range(len(nums)):
            x: int = nums[i]
            right_sm -= x
            nums[i] = abs(left_sm - right_sm)
            left_sm += x
        return nums

# Return substring instance count - 2
# Complete the solution so that it returns the number of times the search_text is found within the full_text.
#
# search_substr( full_text, search_text, allow_overlap = True )
# so that overlapping solutions are (not) counted. If the searchText is empty, it should return 0. Usage examples:
#
# search_substr('aa_bb_cc_dd_bb_e', 'bb') # should return 2 since bb shows up twice
# search_substr('aaabbbcccc', 'bbb') # should return 1
# search_substr( 'aaa', 'aa' ) # should return 2
# search_substr( 'aaa', '' ) # should return 0
# search_substr( 'aaa', 'aa', False ) # should return 1
# STRINGSREGULAR EXPRESSIONSALGORITHMS
# Solution
def search_substr(full_text, search_text, allow_overlap=True):
    if not full_text or not search_text:
        return 0
    if allow_overlap:
        count: int = 0
        for i in range(len(full_text)):
            if full_text[i: i + len(search_text)] == search_text:
                count += 1
        return count
    return full_text.count(search_text)

# 2176. Count Equal and Divisible Pairs in an Array
# Given a 0-indexed integer array nums of length n and an integer k, return the number of pairs (i, j) where 0 <= i < j < n, such that nums[i] == nums[j] and (i * j) is divisible by k.
#
#
# Example 1:
#
# Input: nums = [3,1,2,2,2,1,3], k = 2
# Output: 4
# Explanation:
# There are 4 pairs that meet all the requirements:
# - nums[0] == nums[6], and 0 * 6 == 0, which is divisible by 2.
# - nums[2] == nums[3], and 2 * 3 == 6, which is divisible by 2.
# - nums[2] == nums[4], and 2 * 4 == 8, which is divisible by 2.
# - nums[3] == nums[4], and 3 * 4 == 12, which is divisible by 2.
# Example 2:
#
# Input: nums = [1,2,3,4], k = 1
# Output: 0
# Explanation: Since no value in nums is repeated, there are no pairs (i,j) that meet all the requirements.
#
#
# Constraints:
#
# 1 <= nums.length <= 100
# 1 <= nums[i], k <= 100
# Solution O(N**2) O(1)
class Solution:
    def countPairs(self, nums: List[int], k: int) -> int:
        count: int = 0
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                if nums[i] == nums[j] and i * j % k == 0:
                    count += 1
        return count

# Ninja vs Samurai: Attack + Block
# Something is wrong with our Warrior class. All variables should initialize properly and the attack method is not working as expected.
#
# If properly set, it should correctly calculate the damage after an attack (if the attacker position is == to the block position of the defender: no damage; otherwise, the defender gets 10 damage if hit "high" or 5 damage if hit "low". If no block is set, the defender takes 5 extra damage.
#
# For some reason, the health value is not being properly set. The following shows an example of this code being used:
#
# ninja = Warrior('Hanzo Hattori')
# samurai = Warrior('Ryōma Sakamoto')
#
# samurai.block = 'l'
# ninja.attack(samurai, 'h')
# # samurai.health should be 90 now
# The warrios must be able to fight to the bitter end, and good luck to the most skilled!
#
# Notice that health can't be below 0: once hit to 0 health, a warrior attribute deceased becomes true; if hit again, the zombie attribute becomes true too!
#
# DEBUGGING
Position = {'high': 'h', 'low': 'l'}  # don't change this!


class Warrior():
    def __init__(self, name):
        # each warrior should be created with a name and 100 health points
        self.name = name
        self.health = 100
        # default guard is "", that is unguarded
        self.block = ""
        self.deceased = False
        self.zombie = False

    def attack(self, enemy, position):
        damage: int = 0
        # attacking high deals 10 damage, low 5
        # 0 damage if the enemy blocks in the same position
        if enemy.block != position: damage += 10 if position == Position['high'] else 5
        # and even more damage if the enemy is not blocking at all
        if enemy.block == "": damage += 5
        enemy.set_health(enemy.health - damage)

    def set_health(self, new_health):
        # health cannot have negative values
        self.health = max(0, new_health)
        # if a warrior is set to 0 health he is dead
        if self.health == 0:
            if self.deceased: self.zombie = True
            self.deceased = True


# 739. Daily Temperatures
# Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.
#
#
#
# Example 1:
#
# Input: temperatures = [73,74,75,71,69,72,76,73]
# Output: [1,1,4,2,1,1,0,0]
# Example 2:
#
# Input: temperatures = [30,40,50,60]
# Output: [1,1,1,0]
# Example 3:
#
# Input: temperatures = [30,60,90]
# Output: [1,1,0]
#
#
# Constraints:
#
# 1 <= temperatures.length <= 105
# 30 <= temperatures[i] <= 100
# Solution Stack O(N) O(N)
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        stack: list = [0]
        ans: list = [0] * len(temperatures)
        for i in range(1, len(temperatures)):
            while stack and temperatures[i] > temperatures[stack[-1]]:
                ans[stack[-1]] = i - stack[-1]
                stack.pop()
            stack.append(i)
        return ans

# 2231. Largest Number After Digit Swaps by Parity
# You are given a positive integer num. You may swap any two digits of num that have the same parity (i.e. both odd digits or both even digits).
#
# Return the largest possible value of num after any number of swaps.
#
#
#
# Example 1:
#
# Input: num = 1234
# Output: 3412
# Explanation: Swap the digit 3 with the digit 1, this results in the number 3214.
# Swap the digit 2 with the digit 4, this results in the number 3412.
# Note that there may be other sequences of swaps but it can be shown that 3412 is the largest possible number.
# Also note that we may not swap the digit 4 with the digit 1 since they are of different parities.
# Example 2:
#
# Input: num = 65875
# Output: 87655
# Explanation: Swap the digit 8 with the digit 6, this results in the number 85675.
# Swap the first digit 5 with the digit 7, this results in the number 87655.
# Note that there may be other sequences of swaps but it can be shown that 87655 is the largest possible number.
#
#
# Constraints:
#
# 1 <= num <= 109
class Solution:
    def largestInteger(self, num: int) -> int:
        odd, even = [], []
        ans: list = []
        while num:
            x = num % 10
            if x % 2 == 0:
                even.append(x)
                ans.append(True)
            else:
                odd.append(x)
                ans.append(False)
            num //= 10
        odd.sort()
        even.sort()
        i: int = 0
        ans = ans[::-1]
        while odd and even:
            if ans[i] == True:
                ans[i] = even.pop()
            else:
                ans[i] = odd.pop()
            i += 1
        while odd:
            ans[i] = odd.pop()
            i += 1
        while even:
            ans[i] = even.pop()
            i += 1
        top: int = 0
        while ans:
            top =  top * 10 + ans.pop(0)
        return top
    
# Get Password from grid
# In this kata you are expected to recover a scattered password in a (m x n) grid (you'll be given directions of all password pieces in the array)
#
# The array will contain pieces of the password to be recovered, you'll get directions on how to get all the the pieces, your initial position in the array will be the character "x".
#
# Heres what the array looks like
#
# [
#   ["p", "x", "m"],
#   ["a", "$", "$"],
#   ["k", "i", "t"]
# ]
# The given directions would consist of [left, right, up, down] and [leftT, rightT, upT, downT], the former would be used to move around the grid while the latter would be used when you have a password to that direction of you.( E.g if you are in a position and the move to make is leftT it means theres a password to the left of you, so take the value and move there)
#
# So in the 2d array example above, you will be given the directions ["lefT", "downT", "rightT", "rightT"], making for the word "pa$$".
#
# Remember you initial position is the character "x".
#
# So you write the function getPassword(grid, directions) that uses the directions to get a password in the grid.
#
# Another example.
#
# grid = [
#   ["a", "x", "c"],
#   ["g", "l", "t"],
#   ["o", "v", "e"]
# ];
#
# directions = ["downT", "down", "leftT", "rightT", "rightT", "upT"]
#
# getPassword(grid, directions) // => "lovet"
# Once again, Your initial position is the character "x", so from the position of "x" you follow the directions given and get all pieces in the grid.
#
# LOGICARRAYSALGORITHMSDATA STRUCTURES
def get_password(grid, directions):
    m, n = 0, 0
    for i in range(len(grid)):
        if 'x' in grid[i]:
            m, n = i, grid[i].index('x')
    word: str = ''
    for i in directions:
        if i[-1].isupper():
            if i[:-1] in {'down', 'up'}:
                m += 1 if i[:-1] == 'down' else -1
            else:
                n += -1 if i[:-1] == 'left' else 1
            word += grid[m][n]
        else:
            if i in {'down', 'up'}:
                m += 1 if i == 'down' else -1
            else:
                n += -1 if i == 'left' else 1
    return word

# 2190. Most Frequent Number Following Key In an Array
# You are given a 0-indexed integer array nums. You are also given an integer key, which is present in nums.
#
# For every unique integer target in nums, count the number of times target immediately follows an occurrence of key in nums. In other words, count the number of indices i such that:
#
# 0 <= i <= nums.length - 2,
# nums[i] == key and,
# nums[i + 1] == target.
# Return the target with the maximum count. The test cases will be generated such that the target with maximum count is unique.
#
#
#
# Example 1:
#
# Input: nums = [1,100,200,1,100], key = 1
# Output: 100
# Explanation: For target = 100, there are 2 occurrences at indices 1 and 4 which follow an occurrence of key.
# No other integers follow an occurrence of key, so we return 100.
# Example 2:
#
# Input: nums = [2,2,2,2,3], key = 2
# Output: 2
# Explanation: For target = 2, there are 3 occurrences at indices 1, 2, and 3 which follow an occurrence of key.
# For target = 3, there is only one occurrence at index 4 which follows an occurrence of key.
# target = 2 has the maximum number of occurrences following an occurrence of key, so we return 2.
#
#
# Constraints:
#
# 2 <= nums.length <= 1000
# 1 <= nums[i] <= 1000
# The test cases will be generated such that the answer is unique.
class Solution:
    def mostFrequent(self, nums: List[int], key: int) -> int:
        d: dict = {}
        for i in range(len(nums) - 1):
            if nums[i] == key:
                d[nums[i + 1]] = d.get(nums[i + 1], 0) + 1
        top: int = 0
        v_top: int = 0
        for i in d:
            if d[i] > top:
                v_top, top = i, d[i]
        return v_top
    
# Fixed xor
# Fixed xor
# Write a function that takes two hex strings as input and XORs them against each other. If the strings are different lengths the output should be the length of the shortest string.
#
# Hint: The strings would first need to be converted to binary to be XOR'd.
#
# Note:
# If the two strings are of different lengths, the output string should be the same length as the smallest string. This means that the longer string will be cut down to the same size as the smaller string, then xor'd
#
# Further help
# More information on the XOR operation can be found here https://www.khanacademy.org/computing/computer-science/cryptography/ciphers/a/xor-bitwise-operation
#
# More information of the binary and hex bases can be found here https://www.khanacademy.org/math/algebra-home/alg-intro-to-algebra/algebra-alternate-number-bases/v/number-systems-introduction
#
# Examples:
#
# fixed_xor("ab3f", "ac") == "07"
# fixed_xor("aadf", "bce2") == "163d"
# fixed_xor("1c0111001f010100061a024b53535009181c", "686974207468652062756c6c277320657965") == "746865206b696420646f6e277420706c6179"
# ALGORITHMSMATHEMATICSLOGICALGEBRABINARYCRYPTOGRAPHY
def fixed_xor(a, b):
    return ''.join(f'{int(x, 16) ^ int(y, 16):x}' for x, y in zip(a, b))

# 1704. Determine if String Halves Are Alike
# You are given a string s of even length. Split this string into two halves of equal lengths, and let a be the first half and b be the second half.
#
# Two strings are alike if they have the same number of vowels ('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'). Notice that s contains uppercase and lowercase letters.
#
# Return true if a and b are alike. Otherwise, return false.
#
#
#
# Example 1:
#
# Input: s = "book"
# Output: true
# Explanation: a = "bo" and b = "ok". a has 1 vowel and b has 1 vowel. Therefore, they are alike.
# Example 2:
#
# Input: s = "textbook"
# Output: false
# Explanation: a = "text" and b = "book". a has 1 vowel whereas b has 2. Therefore, they are not alike.
# Notice that the vowel o is counted twice.
#
#
# Constraints:
#
# 2 <= s.length <= 1000
# s.length is even.
# s consists of uppercase and lowercase letters.
# Solution O(N) O(1)
class Solution:
    def halvesAreAlike(self, s: str) -> bool:
        n: int = len(s) // 2
        count: int = 0
        vowels: set = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}
        for i in range(n):
            if s[i] in vowels:
                count += 1
            if s[i + n] in vowels:
                count -= 1
        return count == 0
    
# Are all elements equal? (Infinity version)
# Task
# Create a function eq_all that determines if all elements of any iterable are equal; the iterable may be infinite. Return value is a bool.
#
# Examples
# eq_all('aaa')   : True
# eq_all('abc')   : False
# eq_all('')      : True
#
# eq_all([0,0,0]) : True
# eq_all([0,1,2]) : False
# eq_all([])      : True
# Notes
# For the function result to be True, the iterable must be finite; False, however, can result from an element finitely far from the left end. There will be no tests with infinite series of equal elements.
# Elements will be primitive values.
#
# FUNDAMENTALS
# Solution
def eq_all(iterable):
    if not iterable:
        return True
    d: dict = {}
    for i in iterable:
        d[i] = d.get(i, 0) + 1
        if len(d) > 1:
            return False
    return True

# 1347. Minimum Number of Steps to Make Two Strings Anagram
# You are given two strings of the same length s and t. In one step you can choose any character of t and replace it with another character.
#
# Return the minimum number of steps to make t an anagram of s.
#
# An Anagram of a string is a string that contains the same characters with a different (or the same) ordering.
#
#
#
# Example 1:
#
# Input: s = "bab", t = "aba"
# Output: 1
# Explanation: Replace the first 'a' in t with b, t = "bba" which is anagram of s.
# Example 2:
#
# Input: s = "leetcode", t = "practice"
# Output: 5
# Explanation: Replace 'p', 'r', 'a', 'i' and 'c' from t with proper characters to make t anagram of s.
# Example 3:
#
# Input: s = "anagram", t = "mangaar"
# Output: 0
# Explanation: "anagram" and "mangaar" are anagrams.
#
#
# Constraints:
#
# 1 <= s.length <= 5 * 104
# s.length == t.length
# s and t consist of lowercase English letters only.
class Solution:
    def minSteps(self, s: str, t: str) -> int:
        hts, htt = {}, {}
        for i in s:
            hts[i] = hts.get(i, 0) + 1
        for i in t:
            htt[i] = htt.get(i, 0) + 1
        count: int = 0
        for i in hts:
            if i not in htt:
                count += hts[i]
            elif htt[i] < hts[i]:
                count += hts[i] - htt[i]
        return count
    
# Getting MAD
# Getting the Minimum Absolute Difference
# Task
# Given an array of integers with at least 2 elements: a1, a2, a3, a4, ... aN
#
# The absolute difference between two array elements ai and aj, where i != j, is the absolute value of ai - aj.
#
# Return the minimum absolute difference (MAD) between any two elements in the array.
#
# Example
# For [-10, 0, -3, 1]
#
# the MAD is 1.
#
# Explanation:
#
# | -10 -    0  | = 10
# | -10 -  (-3) | =  7
# | -10 -    1  | = 11
# |   0 - (-10) | = 10
# |   0 -  (-3) | =  3
# |   0 -    1  | =  1
# |  -3 - (-10) | =  7
# |  -3 -    0  | =  3
# |  -3 -    1  | =  4
# |   1 - (-10) | = 11
# |   1 -    0  | =  1
# |   1 -  (-3) | =  4
# The minimum value is 1 ( both | 0 - 1 | and | 1 - 0 | ).
#
# Note
# Note that the same value can appear more than once in the array. In that case, the MAD will be 0.
#
# FUNDAMENTALSARRAYSALGORITHMS
def getting_mad(arr):
    cop = list(set(arr))
    if len(cop) != len(arr):
        return 0
    ans: int = float('inf')
    for i in range(len(cop)):
        for j in range(i + 1, len(cop)):
            ans = min(ans, abs(cop[i] - cop[j]))
    return ans if ans < float('inf') else 0

# 1657. Determine if Two Strings Are Close
# Two strings are considered close if you can attain one from the other using the following operations:
#
# Operation 1: Swap any two existing characters.
# For example, abcde -> aecdb
# Operation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character.
# For example, aacabb -> bbcbaa (all a's turn into b's, and all b's turn into a's)
# You can use the operations on either string as many times as necessary.
#
# Given two strings, word1 and word2, return true if word1 and word2 are close, and false otherwise.
#
#
#
# Example 1:
#
# Input: word1 = "abc", word2 = "bca"
# Output: true
# Explanation: You can attain word2 from word1 in 2 operations.
# Apply Operation 1: "abc" -> "acb"
# Apply Operation 1: "acb" -> "bca"
# Example 2:
#
# Input: word1 = "a", word2 = "aa"
# Output: false
# Explanation: It is impossible to attain word2 from word1, or vice versa, in any number of operations.
# Example 3:
#
# Input: word1 = "cabbba", word2 = "abbccc"
# Output: true
# Explanation: You can attain word2 from word1 in 3 operations.
# Apply Operation 1: "cabbba" -> "caabbb"
# Apply Operation 2: "caabbb" -> "baaccc"
# Apply Operation 2: "baaccc" -> "abbccc"
#
#
# Constraints:
#
# 1 <= word1.length, word2.length <= 105
# word1 and word2 contain only lowercase English letters.
class Solution:
    def closeStrings(self, word1: str, word2: str) -> bool:
        if len(word1) != len(word2):
            return False
        htw1, htw2 = {}, {}
        for i in word1:
            htw1[i] = htw1.get(i, 0) + 1
        for i in word2:
            htw2[i] = htw2.get(i, 0) + 1
        for i in htw1:
            if i not in htw2:
                return False
        return sorted(htw1.values()) == sorted(htw2.values())

# 2996. Smallest Missing Integer Greater Than Sequential Prefix Sum
# You are given a 0-indexed array of integers nums.
#
# A prefix nums[0..i] is sequential if, for all 1 <= j <= i, nums[j] = nums[j - 1] + 1. In particular, the prefix consisting only of nums[0] is sequential.
#
# Return the smallest integer x missing from nums such that x is greater than or equal to the sum of the longest sequential prefix.
#
#
#
# Example 1:
#
# Input: nums = [1,2,3,2,5]
# Output: 6
# Explanation: The longest sequential prefix of nums is [1,2,3] with a sum of 6. 6 is not in the array, therefore 6 is the smallest missing integer greater than or equal to the sum of the longest sequential prefix.
# Example 2:
#
# Input: nums = [3,4,5,1,12,14,13]
# Output: 15
# Explanation: The longest sequential prefix of nums is [3,4,5] with a sum of 12. 12, 13, and 14 belong to the array while 15 does not. Therefore 15 is the smallest missing integer greater than or equal to the sum of the longest sequential prefix.
#
#
# Constraints:
#
# 1 <= nums.length <= 50
# 1 <= nums[i] <= 50
# Solution O(N) O(1)
class Solution:
    def missingInteger(self, nums: List[int]) -> int:
        s: int = nums[0]
        for i in range(1, len(nums)):
            if nums[i - 1] + 1 == nums[i]:
                s += nums[i]
            else:
                break
        while s in nums:
            s += 1
        return s
    
# 3000. Maximum Area of Longest Diagonal Rectangle
# You are given a 2D 0-indexed integer array dimensions.
#
# For all indices i, 0 <= i < dimensions.length, dimensions[i][0] represents the length and dimensions[i][1] represents the width of the rectangle i.
#
# Return the area of the rectangle having the longest diagonal. If there are multiple rectangles with the longest diagonal, return the area of the rectangle having the maximum area.
#
#
#
# Example 1:
#
# Input: dimensions = [[9,3],[8,6]]
# Output: 48
# Explanation:
# For index = 0, length = 9 and width = 3. Diagonal length = sqrt(9 * 9 + 3 * 3) = sqrt(90) ≈ 9.487.
# For index = 1, length = 8 and width = 6. Diagonal length = sqrt(8 * 8 + 6 * 6) = sqrt(100) = 10.
# So, the rectangle at index 1 has a greater diagonal length therefore we return area = 8 * 6 = 48.
# Example 2:
#
# Input: dimensions = [[3,4],[4,3]]
# Output: 12
# Explanation: Length of diagonal is the same for both which is 5, so maximum area = 12.
#
#
# Constraints:
#
# 1 <= dimensions.length <= 100
# dimensions[i].length == 2
# 1 <= dimensions[i][0], dimensions[i][1] <= 100
# Solution O(N) O(1)
class Solution:
    def areaOfMaxDiagonal(self, dimensions: List[List[int]]) -> int:
        mx = 0
        area = 0
        for i in dimensions:
            if (i[0]**2 + i[1]**2)**.5 > mx:
                mx = (i[0]**2 + i[1]**2)**.5
                area = i[0] * i[1]
            elif (i[0]**2 + i[1]**2)**.5 == mx:
                mx = (i[0]**2 + i[1]**2)**.5
                area = max(i[0] * i[1], area)
        return area

# Guess and convert
# In this kata, you have to define a function named func that will take a list as input.
#
# You must try and guess the pattern how we get the output number and return list - [output number,binary representation,octal representation,hexadecimal representation], but you must convert that specific number without built-in : bin,oct and hex functions.
#
# Examples :
#
# func([12,13,6,3,6,45,123]) returns - [29,'11101','35','1d']
#
# func([1,9,23,43,65,31,63,99]) returns - [41,'101001','51','29']
#
# func([2,4,6,8,10,12,14,16,18,19]) returns - [10,'1010','12','a']
# PUZZLES
def func(l):
    n: int = sum(l) // len(l)
    ans: list = [format(n, f) for f in ['b', 'o', 'x']]
    return [n] + ans

# 2225. Find Players With Zero or One Losses
# You are given an integer array matches where matches[i] = [winneri, loseri] indicates that the player winneri defeated player loseri in a match.
#
# Return a list answer of size 2 where:
#
# answer[0] is a list of all players that have not lost any matches.
# answer[1] is a list of all players that have lost exactly one match.
# The values in the two lists should be returned in increasing order.
#
# Note:
#
# You should only consider the players that have played at least one match.
# The testcases will be generated such that no two matches will have the same outcome.
#
#
# Example 1:
#
# Input: matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]
# Output: [[1,2,10],[4,5,7,8]]
# Explanation:
# Players 1, 2, and 10 have not lost any matches.
# Players 4, 5, 7, and 8 each have lost one match.
# Players 3, 6, and 9 each have lost two matches.
# Thus, answer[0] = [1,2,10] and answer[1] = [4,5,7,8].
# Example 2:
#
# Input: matches = [[2,3],[1,3],[5,4],[6,4]]
# Output: [[1,2,5,6],[]]
# Explanation:
# Players 1, 2, 5, and 6 have not lost any matches.
# Players 3 and 4 each have lost two matches.
# Thus, answer[0] = [1,2,5,6] and answer[1] = [].
#
#
# Constraints:
#
# 1 <= matches.length <= 105
# matches[i].length == 2
# 1 <= winneri, loseri <= 105
# winneri != loseri
# All matches[i] are unique.
# Solution HashTable O(NlogN) O(N)
class Solution:
    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:
        d: dict = {}
        ans: list = [[], []]
        for i in matches:
            w = d.get(i[0], [0, 0])
            d[i[0]] = [w[0] + 1, w[1] + 1]
            y = d.get(i[1], [0, 0])
            d[i[1]] = [y[0] + 0, y[1] + 1]
        for i in d:
            if d[i][1] > 0:
                if d[i][0] == d[i][1]:
                    ans[0].append(i)
                elif d[i][0] + 1 == d[i][1]:
                    ans[1].append(i)
        ans[0].sort()
        ans[1].sort()
        return ans

# Sorting Arrays by the Amount of Perfect Squares that Each Element May Generate
# You will be given an array of positive integers. The array should be sorted by the amount of distinct perfect squares and reversed, that can be generated from each number permuting its digits.
#
# E.g.: arr = [715, 112, 136, 169, 144]
#
# Number   Perfect Squares w/ its Digits   Amount
#  715                -                       0
#  112               121                      1
#  136               361                      1
#  169           169, 196, 961                3
#  144             144, 441                   2
# So the output will have the following order: [169, 144, 112, 136, 715]
#
# When we have two or more numbers with the same amount of perfect squares in their permutations, we sorted by their values.
#
# In the example given above, we can see that 112 and 136 both generate a perfect square. So 112 comes first.
#
# Examples for this kata:
#
# sort_by_perfsq([715, 112, 136, 169, 144]) == [169, 144, 112, 136, 715]
# # number of perfect squares:                   3    2    1    1    0
# We may have in the array numbers that belongs to the same set of permutations.
#
# sort_by_perfsq([234, 61, 16, 441, 144, 728]) == [144, 441, 16, 61, 234, 728]
# # number of perfect squares:                      2    2    1   0   0    0
# Features of the random tests:
#
# Number of tests: 80
# Arrays between 4 and 20 elements
# Integers having from 1 to 7 digits included
# Enjoy it!!
#
# ALGORITHMSMATHEMATICSNUMBER THEORYPERMUTATIONS
import math
import itertools
def sort_by_perfsq(arr):
    d: dict = {}
    for i in arr:
        count: int = 0
        for j in set(itertools.permutations(map(int, str(i)))):
            x: int = int(''.join(str(k) for k in j))
            count += math.sqrt(x).is_integer()
        d[i] = count
    ans: list = []
    while d:
        top: int = 0
        top_val: int = float('-inf')
        for i in d:
            if top_val < d[i]:
                top, top_val = i, d[i]
            elif top_val == d[i]:
                top = min(top, i)
        ans.append(top)
        del d[top]
    return ans

# 380. Insert Delete GetRandom O(1)
# Implement the RandomizedSet class:
#
# RandomizedSet() Initializes the RandomizedSet object.
# bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise.
# bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise.
# int getRandom() Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.
# You must implement the functions of the class such that each function works in average O(1) time complexity.
#
#
#
# Example 1:
#
# Input
# ["RandomizedSet", "insert", "remove", "insert", "getRandom", "remove", "insert", "getRandom"]
# [[], [1], [2], [2], [], [1], [2], []]
# Output
# [null, true, false, true, 2, true, false, 2]
#
# Explanation
# RandomizedSet randomizedSet = new RandomizedSet();
# randomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.
# randomizedSet.remove(2); // Returns false as 2 does not exist in the set.
# randomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].
# randomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.
# randomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].
# randomizedSet.insert(2); // 2 was already in the set, so return false.
# randomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.
#
#
# Constraints:
#
# -231 <= val <= 231 - 1
# At most 2 * 105 calls will be made to insert, remove, and getRandom.
# There will be at least one element in the data structure when getRandom is called.
import random
class RandomizedSet:
    def __init__(self):
        self.ht = {}
        self.data = []

    def insert(self, val: int) -> bool:
        if val not in self.ht:
            self.data.append(val)
            self.ht[val] = len(self.data) - 1
            return True
        return False

    def remove(self, val: int) -> bool:
        if val in self.ht:
            last_item, indx_val = self.data[-1], self.ht[val]
            self.data[indx_val], self.ht[last_item] = last_item, indx_val 
            self.data.pop()
            self.ht.pop(val)
            return True
        return False

    def getRandom(self) -> int:
        return random.choice(self.data)

# Your RandomizedSet object will be instantiated and called as such:
# obj = RandomizedSet()
# param_1 = obj.insert(val)
# param_2 = obj.remove(val)
# param_3 = obj.getRandom()

# Special Scores For Words
# We define a special score for a word (ssw) as follows. We multiply the corresponding 10 - base ascii code for each letter of the word by its respective frequency of this letter in the word, we collect these addens and we sum them up.
#
# For example for the word, investigation we have the respective ascci codes and frequencies for each letter:
#
# Letter    Ascii decimal code        Letter Frequency (in "investigation")
#  i             105                            3
#  n             110                            2
#  t             116                            2
#  a              97                            1
#  e             101                            1
#  g             103                            1
#  o             111                            1
#  s             115                            1
#  v             118                            1
# So the ssw for this word will be:
#
# ssw = 3 * 105 + 2 * 110 + 2 * 116 + 97 * 1 + 101 * 1 + 103 * 1 + 111 * 1 + 115 * 1 + 118 * 1 = 1412
# We need a function find_word() (Javascript: findWord()) that receives two arguments, number of letters, num_let (Javascript: numLet) and a maximum special scoremax_ssw (Javascript: maxSsw) for the word. The function will output a word from a data base of 2000 words that have the highest possible ssw of the given number of letters but smaller or equal than the given max_ssw. If we have more than one word with the same number of letters, num_let, and the same special score, ssw, it will be chosen the last word of the list of words sorted. You were provided with a list of 2000 words of the Oxford Dictionary Of English (U.K. English), named WORD_LIST for python, $word_list for ruby, wordList for javascript.
#
# Let's see some cases:
# num_let = 8
# max_ssw = 888
# find_word(num_let, max_ssw) == 'southern'
# /// There are three words with 8 letters and with ssw == 888
# 'question', 'security' and 'southern'
# The list of these words sorted withe its respespective ssw is [(888, 'question'),
# (888, 'security'), (888, 'southern')], 'southern' should be chosen
#
# num_let = 9
# max_ssw = 500
# find_word(num_let, max_ssw) == None # in Ruby nil, in Javascript null
# /// the word of 9 letters with minimum ssw is 'candidate' with ssw = 925
# There are no word of 9 letters less than 500
# We may have the case when the all the words of certain number of letters are bellow max_ssw
#
# num_let = 7
# max_ssw = 1412
# find_word(num_let, max_ssw) == 'support'
# ///'support' is the word of 7 letters with highest ssw (797)
# Enjoy it!
#
# FUNDAMENTALSDATA STRUCTURESALGORITHMSMEMOIZATION
TOM = {}

def summizing(word):
    ht: dict = {}
    for i in word:
        ht[i] = ht.get(i, 0) + 1
    return sum(ord(i) * ht[i] for i in ht)

def find_word(num_let, max_ssw):
    top_score, top_word = 0, ''
    for i in WORD_LIST:
        if len(i) == num_let:
            if i in TOM:
                if TOM[i] >= top_score and TOM[i] <= max_ssw:
                    top_score, top_word = TOM[i], i
                else:
                    continue
            else:
                x = summizing(i)
                if x >= top_score and x <= max_ssw:
                    top_score, top_word = x, i
                    TOM[i] = x
    return top_word if top_word else None

# 1207. Unique Number of Occurrences
# Given an array of integers arr, return true if the number of occurrences of each value in the array is unique or false otherwise.
#
#
#
# Example 1:
#
# Input: arr = [1,2,2,1,1,3]
# Output: true
# Explanation: The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences.
# Example 2:
#
# Input: arr = [1,2]
# Output: false
# Example 3:
#
# Input: arr = [-3,0,1,-3,1,1,1,-3,10,0]
# Output: true
#
#
# Constraints:
#
# 1 <= arr.length <= 1000
# -1000 <= arr[i] <= 1000
# Solution
class Solution(object):
    def uniqueOccurrences(self, arr):
        counter = Counter(arr).values()
        if(len(counter) == len(set(counter))): return True
        return False


# Solution 2 O(N) O(N) HashTable and HashSet
class Solution:
    def uniqueOccurrences(self, arr: List[int]) -> bool:
        ht: dict = {}
        for i in arr:
            ht[i] = ht.get(i, 0) + 1
        hs: set = set()
        for i in ht:
            if ht[i] in hs:
                return False
            else:
                hs.add(ht[i])
        return True
# Solution 3 O(N) O(N) HashTable
class Solution:
    def uniqueOccurrences(self, arr: List[int]) -> bool:
        ht: dict = {}
        for i in arr:
            ht[i] = ht.get(i, 0) + 1
        return len(ht.values()) == len(set(ht.values()))

# Remove a Specific Element of an Array
# You will be given a certain array of length n, such that n > 4, having positive and negative integers but there will be no zeroes and all the elements will occur once in it.
#
# We may obtain an amount of n sub-arrays of length n - 1, removing one element at a time (from left to right).
#
# For each subarray, let's calculate the product and sum of its elements with the corresponding absolute value of the quotient, q = SubProduct/SubSum (if it is possible, SubSum cannot be 0). Then we select the array with the lowest value of |q|(absolute value)
#
# e.g.: we have the array, arr = [1, 23, 2, -8, 5]
#
# Sub Arrays            SubSum    SubProduct         |q|
# [23, 2, -8, 5]         22         -1840         83.636363
# [1, 2, -8, 5]           0           -80          No value
# [1, 23, -8, 5]         21          -920         43.809524
# [1, 23, 2, 5]          31           230          7.419355  <--- selected array
# [1, 23, 2, -8]         18           368         20.444444
# Let's compare the given array with the selected subarray:
#
# [1, 23, 2, -8, 5]
# [1, 23, 2,     5]
# The difference between them is at the index 3 for the given array, with element -8, so we put both things for a result [3, -8].
#
# That means that to obtain the selected subarray we have to take out the value -8 at index 3. We need a function that receives an array as an argument and outputs the pair [index, arr[index]] that generates the subarray with the lowest value of |q|.
#
# select_subarray([1, 23, 2, -8, 5]) == [3, -8]
# Another case:
#
# select_subarray([1, 3, 23, 4, 2, -8, 5, 18]) == [2, 23]
# In Javascript the function will be selectSubarray().
#
# We may have some special arrays that may have more than one solution as the one that follows below.
#
# select_subarray([10, 20, -30, 100, 200]) == [[3, 100], [4, 200]]
# If there is more than one result the function should output a 2Darray sorted by the index of the element removed from the array.
#
# Thanks to Unnamed for detecting the special cases when we have multiple solutions.
#
# Features of the random tests:
#
# Number of tests = 200
# length of the array, l, such that 20 <= l <= 100
# Enjoy it!!
#
# FUNDAMENTALSDATA STRUCTURESALGORITHMSMATHEMATICSLOGIC
import math
def select_subarray(arr):
    cost_ans: list = [float('inf')]
    ans: list = [[-1, float('inf')]]
    total: int = sum(arr)
    for i in range(len(arr)):
        x: int = total - arr[i]
        if x != 0:
            y: int = math.prod(arr[:i] + arr[i+1:])
            q: int = (abs(y / x))
            if q < cost_ans[-1]:
                ans.clear(); ans.append([i, arr[i]])
                cost_ans.clear(); cost_ans.append(q)
            elif q == cost_ans[-1]:
                ans.append([i, arr[i]])
    return ans[0] if len(ans) == 1 else ans

# 75. Sort Colors
# Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.
#
# We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.
#
# You must solve this problem without using the library's sort function.
#
#
#
# Example 1:
#
# Input: nums = [2,0,2,1,1,0]
# Output: [0,0,1,1,2,2]
# Example 2:
#
# Input: nums = [2,0,1]
# Output: [0,1,2]
#
#
# Constraints:
#
# n == nums.length
# 1 <= n <= 300
# nums[i] is either 0, 1, or 2.
#
#
# Follow up: Could you come up with a one-pass algorithm using only constant extra space?
# Solution O(N) O(1) Two Pointers
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        left, right = 0, len(nums) - 1
        top: int = 0
        while top <= right:
            if nums[top] == 0:
                nums[top], nums[left] = nums[left], nums[top]
                left += 1
            if nums[top] == 2:
                nums[top], nums[right] = nums[right], nums[top]
                right -= 1
            else:
                top += 1
        return nums
    
# Most Consecutive Zeros of a Binary Number
# Given a string (str) containing a base-10 integer between 0 and 10000, convert the integer to its binary representation. At that point, obtain a count of the maximum amount of consecutive 0s. From there, return the count in written form with a capital letter.
#
# max_consec_zeros("9") => "Two"
# max_consec_zeros("13") => "One"
# max_consec_zeros("15") => "Zero"
# max_consec_zeros("42") => "One"
# max_consec_zeros("550") => "Three"
# In the very first example, we have an argument of "9" which is being passed to the method. The binary representation of 9 is 1001 which can be read as: one, zero, zero, one. There are, at most, two consecutive 0s, resulting in the integer 2 as the value of the count. The output in the block of code above reflects the final step of taking 2 from standard form to the written form "Two" as prompted.
#
# In the very last example, we have an argument of "550" which is being passed to the method. The binary representation of 550 is 1000100110 which can be read as: one, zero, zero, zero, one, zero, zero, one, one, zero. There are, at most, three consecutive 0s, resulting in the integer 3 as the value of the count. The output in the block of code above reflects the final step of taking 3 from standard form to the written form of "Three" as prompted.
#
# One way, among many, to visualize the end of each step might look like:
#
# max_consec_zeros("777")
# 1: "777"
# 2: 777
# 3: 1100001001
# 4: 4
# 5: "Four"
# max_consec_zeros("777") => "Four"
# Happy coding!
#
# FUNDAMENTALSMATHEMATICSSTRINGS
 def max_consec_zeros(s):
    words: dict = {0: "Zero", 1: "One", 2: "Two", 3: "Three",
                  4: 'Four', 5: 'Five', 6: 'Six', 7: 'Seven',
                  8: 'Eight', 9: 'Nine', 10: 'Ten', 11: 'Eleven',
                  12: 'Twelve', 13: 'Thirteen'}
    top: int = 0
    seq: int = 0
    for i in bin(int(s))[2:]:
        if i == '0':
            seq += 1
            top = max(top, seq)
        else:
            seq = 0
    return words[top]
 
# 7. Reverse Integer
# Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.
#
# Assume the environment does not allow you to store 64-bit integers (signed or unsigned).
#
#
#
# Example 1:
#
# Input: x = 123
# Output: 321
# Example 2:
#
# Input: x = -123
# Output: -321
# Example 3:
#
# Input: x = 120
# Output: 21
#
#
# Constraints:
#
# -231 <= x <= 231 - 1
class Solution:
    def reverse(self, x: int) -> int:
        flag: bool = x < 0
        if flag:
            x *= -1
        ans: int = 0
        while x:
            ans = ans * 10 + (x % 10)
            x //= 10
        if ans < -2**31 or ans > 2**31-1:
            return 0
        return -ans if flag else ans
    
# LOTTO 6 aus 49 - 6 of 49
# In Germany we have "LOTTO 6 aus 49". That means that 6 of 49 numbers are drawn as winning combination.
# There is also a "Superzahl", an additional number, which can increase your winning category.
#
# In this kata you have to write two methods.
#
# def number_generator():
#
# def check_for_winning_category(your_numbers, winning_numbers):
# The first method is for drawing the lottery numbers.
# You have to create an array with 7 random numbers. 6 from these are from 1 - 49.
# Of course every number may only occur once.
# And the 7th number is the "Superzahl". A number from 0 - 9. This number is independent from the first six numbers.
# The first 6 numbers have to be in ascending order.
#
# A result could be:
# 4, 9, 17, 22, 25, 35, 0
# Or:
# 4, 18, 22, 34, 41, 44, 4
#
# The second method should check a given number against the winning combination and have to return the winning category:
#
# 1  - 6 numbers and Superzahl match
# 2  - 6 numbers match
# 3  - 5 numbers and Superzahl match
# 4  - 5 numbers match
# 5  - 4 numbers and Superzahl match
# 6  - 4 numbers match
# 7  - 3 numbers and Superzahl match
# 8  - 3 numbers match
# 9  - 2 numbers and Superzahl match
# -1 - if the numbers do not match any of the rules above
#
#
# Have fun coding it and please don't forget to vote and rank this kata! :-)
#
# I have created other katas. Have a look if you like coding and challenges.
#
# MATHEMATICSALGORITHMS
import random
def number_generator():
    ans: list = [random.randint(1, 49) for i in range(6)]
    return sorted(ans) + [random.randint(0, 9)]

def check_for_winning_category(your_numbers, winning_numbers):
    count: int = sum(i in winning_numbers[:6] for i in your_numbers[:6])
    top: int = your_numbers[-1] == winning_numbers[-1]
    if count == 6: return 1 if top else 2
    elif count == 5: return 3 if top else 4
    elif count == 4: return 5 if top else 6
    elif count == 3: return 7 if top else 8
    elif count == 2: return 9 if top  else -1
    return -1

# 347. Top K Frequent Elements
# Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.
#
#
#
# Example 1:
#
# Input: nums = [1,1,1,2,2,3], k = 2
# Output: [1,2]
# Example 2:
#
# Input: nums = [1], k = 1
# Output: [1]
#
#
# Constraints:
#
# 1 <= nums.length <= 105
# -104 <= nums[i] <= 104
# k is in the range [1, the number of unique elements in the array].
# It is guaranteed that the answer is unique.
#
#
# Follow up: Your algorithm's time complexity must be better than O(n log n), where n is the array's size.
# Solution O(N) O(N) Bucket
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        ht: dict = {}
        for i in nums:
            ht[i] = ht.get(i, 0) + 1
        bucket: list = [None] * (len(nums) + 1)
        for i in ht:
            if not bucket[ht[i]]:
                bucket[ht[i]] = [i]
            else:
                bucket[ht[i]].extend([i])
        ans: list = []
        for i in range(len(bucket) - 1, -1, -1):
            if bucket[i]:
                ans.extend(bucket[i])
                if len(ans) >= k:
                    break
        return ans[:k]
# Solution HashTable O(NK) O(N + K)
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        ht: dict = {}
        for i in nums:
            ht[i] = ht.get(i, 0) + 1
        ans: list = []
        while k > 0:
            top: int = float('-inf')
            top_value: int = None
            for i in ht:
                if ht[i] > top:
                    top, top_value = ht[i], i
            ans.append(top_value)
            del ht[top_value]
            k -= 1
        return ans

# Cubic Tap Code
# Cubic Tap Code
# This works similarly to Tap Code except instead of being mapped onto a 5x5 square, letters are mapped onto a 3x3x3 cube, left to right, top to bottom, front to back with space being the 27th "letter". Letters are represented by a series of taps (represented as dots .) and pauses (represented by spaces  ), for example A is represented as . . . (first column, first row, first layer) and   is represented as ... ... ... (third column, third row, third layer).
#
# For reference the three layers of the cube are as follows (underscore represents space):
#
# 1  1  2  3
# 1  A  B  C
# 2  D  E  F
# 3  G  H  I
#
# 2  1  2  3
# 1  J  K  L
# 2  M  N  O
# 3  P  Q  R
#
# 3  1  2  3
# 1  S  T  U
# 2  V  W  X
# 3  Y  Z  _
# Your task (should you choose to accept it)
# Create two functions encode() and decode(), to encode and decode strings to and from cubic tap code.
#
# Input
# encode() takes a string of uppercase letters and spaces and outputs a string of dots and spaces. decode() takes a string of dots and spaces and outputs a string of uppercase letters and spaces. All inputs will be valid.
#
# Examples
# encode("N") => ".. .. .."
# encode("TEST") => ".. . ... .. .. . . . ... .. . ..."
# encode("HELLO WORLD") => ".. ... . .. .. . ... . .. ... . .. ... .. .. ... ... ... .. .. ... ... .. .. ... ... .. ... . .. . .. ."
#
# decode(".. .. ..") => "N"
# decode(".. . ... .. .. . . . ... .. . ...") => "TEST"
# decode(".. ... . .. .. . ... . .. ... . .. ... .. .. ... ... ... .. .. ... ... .. .. ... ... .. ... . .. . .. .") => "HELLO WORLD"
# CIPHERSALGORITHMSCRYPTOGRAPHY
# Solution
CHARS: list = [
    [['A',  'B',  'C'], ['D',  'E',  'F'], ['G',  'H',  'I']],
    [['J',  'K',  'L'], ['M',  'N',  'O'], ['P',  'Q',  'R',]],
    [['S',  'T',  'U'], ['V',  'W',  'X'], ['Y',  'Z',  ' ']]
]
LAYER: list = ['ABCDEFGHI', 'JKLMNOPQR', 'STUVWXYZ ']
def encode(string):
    ans: list = []
    for char in string:
        top: list = []
        for layer in range(3):
            if char in LAYER[layer]:
                top.append(layer)
        for rows in range(3):
            if char in CHARS[top[0]][rows]:
                top.append(rows)
                top.append(CHARS[top[0]][top[1]].index(char))
        x: str = ' '.join((i + 1) * '.' for i in top[::-1])
        ans.append(x)
    return ' '.join(ans)

def decode(string):
    word: str = []
    string = string.split()
    for i in range(0, len(string), 3):
        word.append(CHARS[len(string[i+2])-1][len(string[i+1])-1][len(string[i])-1])
    return ''.join(word)

# 2545. Sort the Students by Their Kth Score
# There is a class with m students and n exams. You are given a 0-indexed m x n integer matrix score, where each row represents one student and score[i][j] denotes the score the ith student got in the jth exam. The matrix score contains distinct integers only.
#
# You are also given an integer k. Sort the students (i.e., the rows of the matrix) by their scores in the kth (0-indexed) exam from the highest to the lowest.
#
# Return the matrix after sorting it.
#
#
#
# Example 1:
#
#
# Input: score = [[10,6,9,1],[7,5,11,2],[4,8,3,15]], k = 2
# Output: [[7,5,11,2],[10,6,9,1],[4,8,3,15]]
# Explanation: In the above diagram, S denotes the student, while E denotes the exam.
# - The student with index 1 scored 11 in exam 2, which is the highest score, so they got first place.
# - The student with index 0 scored 9 in exam 2, which is the second highest score, so they got second place.
# - The student with index 2 scored 3 in exam 2, which is the lowest score, so they got third place.
# Example 2:
#
#
# Input: score = [[3,4],[5,6]], k = 0
# Output: [[5,6],[3,4]]
# Explanation: In the above diagram, S denotes the student, while E denotes the exam.
# - The student with index 1 scored 5 in exam 0, which is the highest score, so they got first place.
# - The student with index 0 scored 3 in exam 0, which is the lowest score, so they got second place.
#
#
# Constraints:
#
# m == score.length
# n == score[i].length
# 1 <= m, n <= 250
# 1 <= score[i][j] <= 105
# score consists of distinct integers.
# 0 <= k < n
class Solution:
    def sortTheStudents(self, score: List[List[int]], k: int) -> List[List[int]]:
        for i in range(len(score)):
            for j in range(len(score) - i - 1):
                if score[j][k] < score[j + 1][k]:
                    score[j], score[j + 1] = score[j + 1], score[j]
        return score

# self_converge
# self_converge
# Goal: Given a number (with a minimum of 3 digits), return the number of iterations it takes to arrive at a derived number that converges on to itself, as per the following Kaprekar routine. As a learning exercise, come up with a solution that uses recursion. The following steps would be applicable to a number that originally had exactly 4 digits.
#
# Initialize a counter to count the number of iterations
# Take any four-digit number n, using at least two different digits.
# Arrange the digits in descending and then in ascending order to get two four-digit numbers, adding leading zeros if necessary.
# Add as many zeroes so that the width of the original number is maintained.
# Subtract the smaller number from the bigger number. Let us call this nseq.
# Check if nseq (the remainder) from Step 4 equals the previous value of n. If not, increment the iteration counter and go back to step 2 and perform it on the nseq.
# If the number of digits to start with was more than 4, convergence occurs on to a cycle of numbers. Therefore in Step 5, detect this cycle by comparing to not only the previous value, but to all previous values of n.
#
# If there is a match, then return the count of iterations
# If the sequence_number collapses to zero, then return -1
# Converge values
# While 3-digit numbers converge to the same unique number k which is also 3 digits long, all 4-digit numbers also converge to the same unique value k1 which is 4 digits long. However, 5 digit numbers converge to any one of the following values: 53955, 59994, 61974, 62964, 63954, 71973, 74943, 75933, 82962, 83952.
#
# Example
# 1234 -> 4
#
# 1. 4321 - 1234 =  3087 /
# 2. 8730 - 378  =  8352 /
# 3. 8532 - 2358 =  6174 /
# 4. 7641 - 1467 =  6174 // same as previous
# 414 -> 5
#
# 1. 441 - 144 =  297 /
# 2. 972 - 279 =  693 /
# 3. 963 - 369 =  594 /
# 4. 954 - 459 =  495 /
# 5. 954 - 459 =  495 // same as previous
# 50000 -> 4
#
# 1. 50000 - 5      =  49995 /
# 2. 99954 - 45999  =  53955 /  # first
# 3. 95553 - 35559  =  59994 /
# 4. 99954 - 45999  =  53955 /  # 2nd time
# RECURSIONALGORITHMS
def convert(n: int, flag: bool = False, zeroes: int = 0) -> int:
    l: list = []
    while n:
        l.append(n % 10)
        n //= 10
    l.sort(reverse=flag)
    ans: int = 0
    for i in l:
        ans = ans * 10 + i
    if flag:
        while ans < int(f'1{"0" * zeroes}'):
            ans *= 10
    return ans


def self_converge(n):
    hs: set = set()
    count: int = 1
    prev_x: int = -1
    zeroes: int = len(str(n)) - 1
    x: int = convert(n, flag=True, zeroes=zeroes) - convert(n)
    while x != prev_x:
        if x > 9999:
            if x in hs: return count
        count += 1
        prev_x = x
        hs.add(prev_x)
        x = convert(x, flag=True, zeroes=zeroes) - convert(x)

    return count

# 645. Set Mismatch
# You have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, due to some error, one of the numbers in s got duplicated to another number in the set, which results in repetition of one number and loss of another number.
#
# You are given an integer array nums representing the data status of this set after the error.
#
# Find the number that occurs twice and the number that is missing and return them in the form of an array.
#
#
#
# Example 1:
#
# Input: nums = [1,2,2,4]
# Output: [2,3]
# Example 2:
#
# Input: nums = [1,1]
# Output: [1,2]
#
#
# Constraints:
#
# 2 <= nums.length <= 104
# 1 <= nums[i] <= 104
# Solution
class Solution(object):
    def findErrorNums(self, nums):
        return [sum(nums) - sum(set(nums)), list(set(range(1, len(nums) + 1)) - set(nums))[0]]


# Solution 2 Math O(N) O(1)
class Solution:
    def findErrorNums(self, nums: List[int]) -> List[int]:
        l, x, y = len(nums), sum(nums), sum(set(nums))
        k = (l * (l + 1)) // 2
        return [x-y, k-y]
# Solution 3 HashTable O(N) O(N)
class Solution:
    def findErrorNums(self, nums: List[int]) -> List[int]:
        ht: dict = {}
        for i in range(1, len(nums) + 1):
            ht[i] = 0
        for i in nums:
            ht[i] += 1
        missing, dub = 0, 0
        for i in ht:
            if ht[i] == 0:
                missing = i
            elif ht[i] > 1:
                dub = i
        return [dub, missing]

# Range function
# Create range generator function that will take up to 3 parameters - start value, step and stop value. This function should return an iterable object with numbers. For simplicity, assume all parameters to be positive numbers.
#
# Examples:
#
# range(5) --> 1,2,3,4,5
# range(3, 7) --> 3,4,5,6,7
# range(2, 3, 15) --> 2,5,8,11,14
# FUNDAMENTALS
def range_function(*args):
    if len(args) == 1:
        return range(1, args[0] + 1)
    elif len(args) == 2:
        return range(args[0], args[1] + 1)
    return range(args[0], args[2] + 1, args[1])

# 594. Longest Harmonious Subsequence
# We define a harmonious array as an array where the difference between its maximum value and its minimum value is exactly 1.
#
# Given an integer array nums, return the length of its longest harmonious subsequence among all its possible subsequences.
#
# A subsequence of array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements.
#
#
#
# Example 1:
#
# Input: nums = [1,3,2,2,5,2,3,7]
# Output: 5
# Explanation: The longest harmonious subsequence is [3,2,2,2,3].
# Example 2:
#
# Input: nums = [1,2,3,4]
# Output: 2
# Example 3:
#
# Input: nums = [1,1,1,1]
# Output: 0
#
#
# Constraints:
#
# 1 <= nums.length <= 2 * 104
# -109 <= nums[i] <= 109
class Solution:
    def findLHS(self, nums: List[int]) -> int:
        ht: dict = {}
        for i in nums:
            ht[i] = ht.get(i, 0) + 1
        top: int = 0
        for i in ht:
            if i-1 in ht:
                top = max(top, ht[i] + ht[i-1])
        return top

# Catalog
# You are given a small extract of a catalog:
#
# s = "<prod><name>drill</name><prx>99</prx><qty>5</qty></prod>
#
# <prod><name>hammer</name><prx>10</prx><qty>50</qty></prod>
#
# <prod><name>screwdriver</name><prx>5</prx><qty>51</qty></prod>
#
# <prod><name>table saw</name><prx>1099.99</prx><qty>5</qty></prod>
#
# <prod><name>saw</name><prx>9</prx><qty>10</qty></prod>
#
# ...
# (prx stands for price, qty for quantity) and an article i.e "saw".
#
# The function catalog(s, "saw") returns the line(s) corresponding to the article with $ before the prices:
#
# "table saw > prx: $1099.99 qty: 5\nsaw > prx: $9 qty: 10\n..."
# If the article is not in the catalog return "Nothing".
#
# Notes
# There is a blank line between two lines of the catalog.
#
# The same article may appear more than once. If that happens return all the lines concerned by the article (in the same order as in the catalog; however see below a note for Prolog language).
#
# The line separator of results may depend on the language \nor \r\n. In Pascal \n is replaced by LineEnding.
#
# in Perl use "£" instead of "$" before the prices.
#
# You can see examples in the "Sample tests".
#
# Note for Prolog language
# If the article is not in the catalog then R equals "".
#
# R substrings (separated by "\n") must be in alphabetic order.
#
# FUNDAMENTALSSTRINGS
def catalog(s, article):
    s = s.split('\n')
    ans: list = []
    for i in s:
        if article in i:
            x = i.replace('<prod>', '').replace('</prod>', '').replace('<name>', '').replace('</name>', '')
            x = x.replace('<prx>', ' > prx: $').replace('</prx>', '').replace('<qty>', ' qty: ').replace('</qty>', '')
            ans.append(x)
    return '\r\n'.join(ans) if ans else 'Nothing'

# 1837. Sum of Digits in Base K
# Given an integer n (in base 10) and a base k, return the sum of the digits of n after converting n from base 10 to base k.
#
# After converting, each digit should be interpreted as a base 10 number, and the sum should be returned in base 10.
#
#
#
# Example 1:
#
# Input: n = 34, k = 6
# Output: 9
# Explanation: 34 (base 10) expressed in base 6 is 54. 5 + 4 = 9.
# Example 2:
#
# Input: n = 10, k = 10
# Output: 1
# Explanation: n is already in base 10. 1 + 0 = 1.
#
#
# Constraints:
#
# 1 <= n <= 100
# 2 <= k <= 10
class Solution:
    def sumBase(self, n: int, k: int) -> int:
        ans: int = 0
        while n:
            ans += n % k
            n //= k
        return ans

# telephone words
# Businesses use keypad letters in creative ways to spell out a phone number and make it more memorable. Example: http://en.wikipedia.org/wiki/File:Telephone-keypad2.svg
#
# Create a mapping for your dialer as given in the above link. Constraints:
#
# letters are all uppercase
# digits 0, 1 are mapped to 0, 1 respectively
# Write a function that takes four digits of a phone number, and returns a list of all of the words that can be written with that number. (You should return all permutations, not only English words.)
#
# STRINGSARRAYSALGORITHMS
def telephone_words(digit_string):
    letters: list = [['0'], ['1'], ['ABC'], ['DEF'], ['GHI'],
                    ['JKL'], ['MNO'], ['PQRS'], ['TUV'], ['WXYZ']]
    ans: list = []
    for first in letters[int(digit_string[0])][0]:
        for second in letters[int(digit_string[1])][0]:
            for third in letters[int(digit_string[2])][0]:
                for fourth in letters[int(digit_string[3])][0]:
                    ans.append(first + second + third + fourth)
    return ans

# 1143. Longest Common Subsequence
# Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.
#
# A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.
#
# For example, "ace" is a subsequence of "abcde".
# A common subsequence of two strings is a subsequence that is common to both strings.
#
#
#
# Example 1:
#
# Input: text1 = "abcde", text2 = "ace"
# Output: 3
# Explanation: The longest common subsequence is "ace" and its length is 3.
# Example 2:
#
# Input: text1 = "abc", text2 = "abc"
# Output: 3
# Explanation: The longest common subsequence is "abc" and its length is 3.
# Example 3:
#
# Input: text1 = "abc", text2 = "def"
# Output: 0
# Explanation: There is no such common subsequence, so the result is 0.
#
#
# Constraints:
#
# 1 <= text1.length, text2.length <= 1000
# text1 and text2 consist of only lowercase English characters.
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        F: list = [[0] * (len(text2) + 1) for i in range((len(text1) + 1))]
        for i in range(1, len(text1) + 1):
            for j in range(1, len(text2) + 1):
                if text1[i-1] == text2[j-1]:
                    F[i][j] = 1 + F[i-1][j-1]
                else:
                    F[i][j] = max(F[i-1][j], F[i][j-1])
        return F[-1][-1]

# Numbers so vain, they probably think this Kata is about them.
# Well, those numbers were right and we're going to feed their ego.
#
# Write a function, isNarcissistic, that takes in any amount of numbers and returns true if all the numbers are narcissistic. Return false for invalid arguments (numbers passed in as strings are ok).
#
# For more information about narcissistic numbers (and believe me, they love it when you read about them) follow this link: https://en.wikipedia.org/wiki/Narcissistic_number
#
# ALGORITHMSMATHEMATICS
def is_narcissistic(*args):
    for n in args:
        if not str(n).isdigit(): return False
        b: int = len(str(n))
        top: int = 0
        for i in str(n):
            top += int(i) ** b
        if top != int(n):
            return False
    return True

# 2160. Minimum Sum of Four Digit Number After Splitting Digits
# You are given a positive integer num consisting of exactly four digits. Split num into two new integers new1 and new2 by using the digits found in num. Leading zeros are allowed in new1 and new2, and all the digits found in num must be used.
#
# For example, given num = 2932, you have the following digits: two 2's, one 9 and one 3. Some of the possible pairs [new1, new2] are [22, 93], [23, 92], [223, 9] and [2, 329].
# Return the minimum possible sum of new1 and new2.
#
#
#
# Example 1:
#
# Input: num = 2932
# Output: 52
# Explanation: Some possible pairs [new1, new2] are [29, 23], [223, 9], etc.
# The minimum sum can be obtained by the pair [29, 23]: 29 + 23 = 52.
# Example 2:
#
# Input: num = 4009
# Output: 13
# Explanation: Some possible pairs [new1, new2] are [0, 49], [490, 0], etc.
# The minimum sum can be obtained by the pair [4, 9]: 4 + 9 = 13.
#
#
# Constraints:
#
# 1000 <= num <= 9999
class Solution:
    def minimumSum(self, num: int) -> int:
        lst: list = []
        while num:
            lst.append(num % 10)
            num //= 10
        lst.sort()
        x, y = 0, 0
        for i in range(len(lst)):
            if i % 2 == 0:
                x = x * 10 + lst[i]
            else:
                y = y * 10 + lst[i]
        return x + y

# Diamonds and Toads
# Base on the fairy tale Diamonds and Toads from Charles Perrault. In this kata you will have to complete a function that take 2 arguments:
#
# A string, that correspond to what the daugther says.
# A string, that tell you wich fairy the girl have met, this one can be good or evil.
# The function should return the following count as a hash:
#
# If the girl have met the good fairy:
# count 1 ruby everytime you see a r and 2 everytime you see a R
# count 1 crystal everytime you see a c and 2 everytime you see a C
# If the girl have met the evil fairy:
# count 1 python everytime you see a p and 2 everytime uou see a P
# count 1 squirrel everytime you see a s and 2 everytime you see a S
# Note: For this kata I decided to remplace the normal Diamonds and Toads by some programming languages. And just discover that Squirrel is a programming language.
#
# FUNDAMENTALSSTRINGS
def diamonds_and_toads(sentence, fairy):
    flag: bool = fairy == 'good'
    ht: dict = {}
    if flag:
        ht['ruby'] = 0
        ht['crystal'] = 0
    else:
        ht['python'] = 0
        ht['squirrel'] = 0
    for i in sentence:
        if flag:
            if i in 'rR':
                ht['ruby'] += (1 if i.islower() else 2)
            if i in 'cC':
                ht['crystal'] += (1 if i.islower() else 2)
        else:
            if i in 'pP':
                ht['python'] += (1 if i.islower() else 2)
            if i in 'sS':
                ht['squirrel'] += (1 if i.islower() else 2)
    return ht

# 2956. Find Common Elements Between Two Arrays
# You are given two 0-indexed integer arrays nums1 and nums2 of sizes n and m, respectively.
#
# Consider calculating the following values:
#
# The number of indices i such that 0 <= i < n and nums1[i] occurs at least once in nums2.
# The number of indices i such that 0 <= i < m and nums2[i] occurs at least once in nums1.
# Return an integer array answer of size 2 containing the two values in the above order.
#
#
#
# Example 1:
#
# Input: nums1 = [4,3,2,3,1], nums2 = [2,2,5,2,3,6]
# Output: [3,4]
# Explanation: We calculate the values as follows:
# - The elements at indices 1, 2, and 3 in nums1 occur at least once in nums2. So the first value is 3.
# - The elements at indices 0, 1, 3, and 4 in nums2 occur at least once in nums1. So the second value is 4.
# Example 2:
#
# Input: nums1 = [3,4,2,3], nums2 = [1,5]
# Output: [0,0]
# Explanation: There are no common elements between the two arrays, so the two values will be 0.
#
#
# Constraints:
#
# n == nums1.length
# m == nums2.length
# 1 <= n, m <= 100
# 1 <= nums1[i], nums2[i] <= 100
# Solution HashTable
# Complexity
# Time complexity: O(N)
#
# Space complexity: O(N)
class Solution:
    def findIntersectionValues(self, nums1: List[int], nums2: List[int]) -> List[int]:
        ht1, ht2 = dict(), dict()
        for i in range(len(nums2)):
            ht2[nums2[i]] = ht2.get(nums2[i], 0) + 1
        for i in range(len(nums1)):
            ht1[nums1[i]] = ht1.get(nums1[i], 0) + 1
        ans1, ans2 = 0, 0
        for i in ht1:
            if i in ht2:
                ans1 += ht1[i]
        for i in ht2:
            if i in ht1:
                ans2 += ht2[i]
        return [ans1, ans2]
# Solution 2 HashSet
# Complexity
# Time complexity: O(N)
#
# Space complexity: O(N)
class Solution:
    def findIntersectionValues(self, nums1: List[int], nums2: List[int]) -> List[int]:
        hs1, hs2 = set(nums1), set(nums2)
        ans1, ans2 = 0, 0
        for i in nums1:
            if i in hs2:
                ans1 += 1
        for i in nums2:
            if i in hs1:
                ans2 += 1
        return [ans1, ans2]
    
# Optimum coding school location
# Preface
# You are currently working together with a local community to build a school teaching children how to code. First plans have been made and the community wants to decide on the best location for the coding school. In order to make this decision data about the location of students and potential locations is collected.
#
# Problem
# In order to be able to attract and teach as many students as possible we want to minimize the total traveling distance for potential students. The streets system is organized in a traditional grid system and students can only travel horizontally or vertically (not diagonal).
#
# The locations of interested students is given as an array with the first value of each entry presenting the x coordinate and the second value presenting the y coordinate:
#
# students = [[3,7],[2,2],[14,1], ...];
# Potential locations are passed as an array of objects with an unique id, a x and y coordinate:
#
# locations = [{"id": 1, "x": 3, "y": 4}, {"id": 2, "x": 8, "y": 2}, ...];
# Your task is now to evaluate which of the school locations would be best to minimize the distance for all potential students to the school.
#
# The desired output should consist of a string indicating the ID of the best suitable location and the x and y coordinates in the following form:
#
# "The best location is number 1 with the coordinates x = 3 and y = 4"
# ALGORITHMS
def optimum_location(students, locations):
    total, total_value = float('inf'), None
    for start in locations:
        top: int = 0
        for stud in students:
            top += abs(stud[0] - start['x']) + abs(stud[1] - start['y'])
        if top < total:
            total, total_value = top, start
    return f'The best location is number {total_value["id"]} with the coordinates x = {total_value["x"]} and y = {total_value["y"]}'